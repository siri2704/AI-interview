Hey guys!
Welcome to Gate Smashers! Is it possible to always know the number of elements needed in advance? Sometimes, the increase or decrease in the number of elements depends upon the requirement. For example, we already fixed the size of the array as A[5]. That means that we will need 5 elements. What if we need 10 elements at the runtime? What will we do then? In this situation, the array fails. Or suppose that we fixed the size of the array as 100 elements but we only need 5 elements. In this case, our memory gets wasted. In this situation, Linked List overcomes the disadvantage of Array. In this video, we will discuss Linked list, its structure, and its power. So quickly subscribe to our channel, if you haven't done yet. Make sure you like this video. And press the bell icon to get all the latest updates. Let's start with the definition of Linked List. Look what the definition of Linked List says. "A linked list is a linear data structure that includes a series of connected nodes. Here, each node store the data and the address of the next node." See, there's a term 'Node', which we are repeatedly using. Node is an important part of the linked list, in which we store the data. There are two parts of the node. First is where we store the data. In the second part of it, the address of the next node is stored. The structure of all the nodes is the same. Data will be stored in the first, and the address will be stored in the other. Let me explain to you by drawing the structure of a node. I drew a node. I divided it into two parts. The first one is the data part, while the other will be the address part. The address part will store the address of the next node. Why did we do so? Why is it storing the address of the next node? It's because it is a linear data structure. That means that its nodes are in sequence. As soon as it will get the address from this node, it will directly jump to that node. You must have played Treasure Hunt. Every student must have played it. In that, the previous clue has the information about the next clue. It has, right? It will see that clue and read the information of the next clue and go to that place. The clue doesn't need to be around them. It will directly go towards it. It looks like a linear data structure. Okay? The linked list works this way. This node may exist at any location of the memory. But the address will only be in the linked part. I am drawing the node in a sequence. But the address may be anything. The address doesn't need to be in the sequence. I drew the second node which also has two parts. The first part will store the data, while the other will store the address. I am drawing the third node which also has two parts. The first will store data, while the other will store the address. Let's draw the fourth one to understand it thoroughly. It also has two parts. The first for data, and the second for address. If there are only 4 nodes, how the last node of the linked lists be recognized as the last node of the linked list? There will be a Null. Null means that the linked list has been stopped and this is the last node. The last node can be identified by this. How will we connect the linked list? The address of this will be stored in the link part of the previous node. If the address is matched, they will be linked together. We will give the address of the third node to the address part of this and they will also get linked. If we give the address of the fourth node to the link part of it,  they will also get connected. Right? Let me give some data to them.
I entered 1, 2, 3, and 4 respectively. Now, how will we identify the first node of the link? For the first node, we gave it a pointer. This is the first node. We gave a pointer to the linked list and named it 'Head'. You can use any name. But in most of the books, 'Head' or 'Start' is used to give it a standard name. The list starts from here. Okay? This pointer will identify the first node from where the linked list starts. And this Null identified the last node. I promised you to tell you its power. Its power is that, suppose I need to add a node, suppose that I want to add a node between the second and the third node, I put its data in this, 5 I want to insert it between these two. First of all, we will break the linked list. Broke it? After breaking it, we will connect them. We will discuss the insertion in an upcoming video. For now, just look at its power. We broke the linked lists and then reconnected them after adding a node. The same happens in the case of deletion. Suppose that I want to delete this. Suppose that I want to delete this node. I deleted it. After deleting... I broke the linked list. Now we need to reconnect it, so we will connect both of them. We will reconnect both of these to connect the linked list. This is its power. Let's see the types of linked lists. There are three types of linked lists. First, single linked list.
Second, double linked list. Third, circular linked list. Now I will explain the basic structure of single, double, and circular linked lists. We will discuss each of them one by one. Right? We will also study its algos. We will learn everything properly. For now, just learn what a single linked list is. Actually, the example that I just gave you was of single linked lists. It contains nodes having two parts, data and next. The first node will be pointed by the HEAD pointer. We created the next node, through which we created another node. The second node contains the address of which node? Oh sorry! The 'next' part of the first node contains the address of the second node. The second node contains the address of the third node. There will be NULL in the 'next' part of the last node. This is a single linked list. The linked list that moves only in the forward direction is the single linked list.  Then comes the double linked list. What's double linked lists? It moves in the forward direction as well as in the backward direction. It has 3 parts. The first part is previous. Then data, and next. We just named them previous, data, and next to explain to you that we will store data in the middle part. We will store the address of the previous node in the first part. In the next part, the address of the next node is stored, in the same way as a single linked list. The actual difference in this is previous. Okay? In this, we store the address of the previous node. As you know, we store the address of the next node in the next. This means that we have the addresses of the next node as well as the previous node. That's why it can move forward as well as backward. Everything apart from this is the same. The next part is the circular linked list. By the name only, you must have guessed that it creates a circle. The circular linked list also has two parts, circular single linked list, and circular double linked list. The first part, which is circular single linked list, the next part of the last node of it contains the address of the first node. Since it has the address of first node, obviously it will be connected to the first node. It's connected. It will form a circle. Right? Now see, in the circular double linked list, the next part of the last node contains the address of the first node, so it links to it. It linked. If we put the address of the last node in the previous part of the first node, they both will be linked. This is the case of the circular double linked list. Okay? In this video, we discussed the linked list, how it overcame the disadvantage of the array, the structure of the node, and the power of the linked list. In the further videos, we learn in detail about how the operations will be performed in the single linked list, double linked list, and circular linked list. Thank you!