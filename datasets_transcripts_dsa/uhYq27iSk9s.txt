hey everyone welcome back and today let's run through the top eight data structures you need for coding interviews so we'll start with simpler data structures and then get to more complex ones so the most fundamental data structure we have is an array arrays are stored in a contiguous way for example if you had a piece of ram or memory this array would be stored in a subset of that memory in order for example this part if you magnified it if you took this memory and magnified it you would get the above data structure an array where all the values are stored in order this makes arrays very efficient because we can access any element in the array in constant time as long as we know which index that we want to access to insert an element at the end we can do that in big o of one time we just need the index of where we're inserting at and then we can just add a value to that index we can also remove a value from the end of the array and big o of one time all we have to do is delete it or just write it out we could put a placeholder value here like a zero and then we would consider this to be the new end of the array we could do the same thing with the value here and we could do it as many times as we would like now arrays aren't perfect because to insert into the middle of an array in the worst case it would take big o of n time complexity where n is the size of the array because for example if we want to insert over here but we don't want to delete this what we would have to do is shift over every single value in the array our array would look something like this and then we would have to insert the new value here for example a two and the idea is very similar when we're removing from the middle as well because we can't just remove this because at that point our array is not contiguous anymore we've basically split it into two parts that's not what we want we'd have to remove this value here this value there and then this value over here linked lists are another data structure that are pretty similar to arrays in that they store an ordered list of elements but when it comes to memory what's going on under the hood in your ram they're actually completely different the values themselves are not contiguous in ram for example if you want to look at this set of values the three could be somewhere in memory the six could be somewhere in memory and then nine could be somewhere completely different so if in ram these values are stored in different spots then how are they connected well they have pointers the three points to the six the six points to the eight and the eight points to the nine and there are some downsides to storing things in this way in ramps for example if we have four elements in our linked list we want to access the third one what's the value in the third node we can't just randomly access that in big o of one time like we can with arrays to do that we would actually have to start at the beginning and then count one two three so we lost that ability but there are some benefits to linked lists first of all when it comes to inserting at the end and removing at the end we can also do that in constant time just as we can with arrays as long as we have a pointer to the last element in the linked list all we would have to do is take a single pointer and then connect it to a new value that we could insert when it comes to removing at the end we can also do that in constant time all we would have to do is take this pointer instead of pointing it at this a node it we could instead point it at null and then this would be the new end of the list we can also even insert into the middle of the linked list in constant time because all we would have to do is take a node put it here take this pointer instead of pointing it at eight we could point it at the seven and then this seven could be pointing at the eight also to remove from the middle of a linked list is also big of one time we would just remove the node take the pointer and instead point it at the next node we don't have to shift everything over like we did with an array next we have hash maps which along with arrays are probably going to be the single most common data structure that you use hash maps are actually built on top of arrays and they work very similar so with an array instead of having a key you would have an index uh you know starting at zero going to one two three up until the length of the array minus one and then from that index you would map it to some value the value could be an integer or something else hash maps are similar in that the value can be anything but the the key in this case not the index the key can also be pretty much anything you could have numbers so you could have zero one two three but the numbers don't have to be bounded the way they do with arrays you could have a seven you could have a hundred you could have a thousand and these could be it you can have arbitrary keys but instead of having numbers you can also have characters or strings and not only are hashmaps more flexible than arrays in many ways they're also more efficient for example if you want to insert any value any key value pair something like this that can be done in big o of one time if you also wanted to remove that from the hash map that can also be done in big o of one time now the trade-off here is that you can only insert or remove the order of values in a hash map is not relevant a hash map is an unordered data structure there's no concept of beginning or end of the hashmap now the best feature of a hashmap is being able to search the hashmap if you want to search for a particular key if you want to know does the character z exist as a key in the hash map you can also do that in constant time cues are another helpful data structure and in many cases they are implemented using linked lists as you can see we have two pointers between each node in this case because this is actually a doubly linked list cues are typically used to process a set of elements in the same order that they are added for example if we first add the 3 then the 6 then the 8 and we want to process them in the same order that they were added we would you know pop from the left and then pop this six then pop the eight simultaneously we could also be adding additional elements at the same time so if you wanted to push an element to the front of the queue or pop an element from the front you could do that in constant time in both cases now this is actually not just an ordinary cube this is actually called a double ended queue because we can push to the front and pop from the front but we can also push to the back of the queue which is what you would more typically do push elements here pop elements from over here but we can also push elements to the end and pop elements from the end and we can do that in constant time in both cases in continuing we have binary trees they're typically used as tree maps actually over here you can see that each node just has a single value but with tree maps each node will have a key value and then it'll be mapped to the true value of the node on first glance tree maps are just less efficient versions of hash maps which is mostly true the majority of the time a hash map is going to be much better than a tree map but when you have a binary search tree which is kind of what this is and what the time complexity over here is based off of a binary search tree not just a binary tree it has a certain property where for every single node every node in the left subtree of that node is going to be less than it so you can see that 3 is less than 6. on the right side every value is going to be greater than 6. 8 is greater than 6. this property can be used to search for values in the tree in login time if the tree is balanced also removing and inserting into the tree can also be done in login time the benefit of using a binary tree over a hash app is that the values are ordered what that means is you can do a depth first search over the tree and then get the ordered list of elements now tries or prefix trees are another kind of tree each node typically represents a single character and each node can have up to 26 children usually each node is for one of the characters in the alphabet so if you wanted to insert a new word into this try and let's say that word is ant you wouldn't you have to reinsert a node for every single character what you could do is reuse some of the characters for example we already have an a over here and we already have an n that goes after the a so all we really need to do is add a t character to the end of that and now we have the word and to insert a word we can do that in big o of n time where n is the size of the word itself to search for a word we can also do that in big o of and time so what exactly is the benefit of a prefix tree over something like a hash map well it's in the name prefix if we want to find all words that start with the letter a we can do that by searching over this graph in this case a is the prefix and we want to find all words that start with that prefix this type of data structure could also be very convenient for an auto complete type of functionality like autocomplete in google search or something like that next we have heaps which are a very interesting data structure because they're typically visualized as trees now typically you'll have either a min heap or a max heap in this case i have a min heap and the order property is that the minimum value is always going to be the root of the tree and the children of this are always going to be greater also for the structure of the heap is always going to be a complete tree which means that every level in the tree will be completely full except for the last level potentially of the tree and while they're visualized as trees they're actually typically implemented with a rays under the hood you can see that this is an array where the first value is kind of missing but for the indexes we have 0 1 2 3 4. the reason they're implemented this way is because to get the children of a node such as the one at index 1 you can get the left child by taking the index multiplying it by two so let's say two times i where i is the index you can get the left child like that you can get the right child by taking the two times the index plus one so if you take two times one plus one then you'll have three so the left child is six the right child is eight you can see that that is correct and that definition holds for every single node in the tree every single position of the array the main benefit of a heap is that you can get the minimum value in this case since it's a min heap you can get the minimum value in constant time but if you wanted to pop the minimum value you could do that in login time so it's a relatively efficient data structure when it comes to removing values as well as inserting values graphs are some of the hardest data structures to work with and actually we've been talking about graphs throughout this entire video all a graph is is a node with some edges that connect the nodes together now linked lists trees prefix trees a lot of those are also graphs as well but a more general graph can get more complicated because there's no restrictions in this case you can see we have a directed graph because every edge connecting the nodes has a direction what this means is that six has a edge that connects it to four but four cannot go backwards to six any node could have an arbitrary number of neighbors it's not like a tree or a binary tree where they can only have two children this can get very complicated so one of the best ways to represent a more general graph is using an adjacency list as you can see here every single node in the graph has a list of neighbors you can see seven does not have any neighbors it doesn't have any edges outgoing from it but you can see six has four neighbors it has a seven a four a three and an eight as a neighbor as well graphs are a very complicated topic because there's so many different algorithms that can be used on top of them with varying time complexities if you want to learn more about any of the topics i talked about in this video you can check out the rest of my channel and to make it even easier for you i created a site called nikko.io where you can learn about a lot of the topics that i talked about in this video in a very organized fashion if this was helpful please like and subscribe it really supports the channel a lot consider checking out my patreon where you can further support the channel and hopefully i'll see you pretty soon thanks for watching