hey guys welcome to get another decision by scalar and in this particular session we're going to look into data structures complete course with interview questions so now before we move on with understanding what exactly will be covered in this session please make sure to subscribe to our channel so that you don't miss our upcoming videos and also leave a like if you enjoy our content and if you have any queries leave a comment down below and we will help you out so now let's understand what exactly will be covered in this session we will start off with the introduction to sorting then look into particular sorting algorithms like insertion sort bubble sort selection sort counting sort merge sort and more after that we'll be looking into linked lists stacks and hashtags in data structures and once that is done finally we'll be looking into interview questions on data structures completely so this is what will be covered in this particular session without delays we'll get into it very quickly introducing what we're going to cover today right so today we're going to talk about sorting and why is sorting important i mean sorting is essentially nothing but arranging data that you have in a particular order right for example if i have a few numbers i could say i want to arrange them in in an increasing order or if i have people let's say i want to arrange them in in the decreasing order of their height or increasing order of their height etc the ordering because you are able to order something helps you in a lot of things for example sorting might then help you do binary search on that data if you want to look for something or if i give you queries around hey tell me how many numbers are bigger than a specific number that also i mean if the array is sorted you can just look for the index of the element first element bigger and then you know how many numbers are bigger etcetera so sorting helps in those contexts if it is ordered in fact most nosql dbs they actually try to maintain data in a sorted form sorted set is is what it is called because it makes searching for data looking for data doing bunch of analysis on data easier and easier right so today we're gonna just to elaborate we're not going to talk about searching searching i'm going to talk more about sorting sorting is arranging data in a particular order right so for example if i let's give you five numbers i give you numbers let's say 5 10 3 2 and 8. these are numbers in no particular order right now if i say arrange these numbers in an increasing order where all i mean the smallest number comes at the front of the list and so forth that part is called sorting so i mean if you sort this then you'll have 2 3 5 8 and 10. it's an arrangement of the given numbers so that they are in some particular form or order as i said like the reason why it is important is because it helps you do a bunch of different kind of operations on the data fairly quickly if what you have is sorted and i gave the example of nosql databases where they maintain data in sorted sets because it lets them do a bunch of different kind of queries in a sorted form in fact we will talk about some form of mapreduce when we go to a system design modules there also you will see like a lot of things are generated in sorted forms because it allows for for certain mode operations to happen later on does everybody understand like what sorting is so maybe like the way i would explain sorting is taking a just like in binary search i took the real-world example of searching in a dictionary what we normally do in real life i'm again going to be taking the example a real life example of what we might have done in in our lives before right all of us went to school and in school we were made to stand in increasing order of our heights now let's take that example which is i have a class full of people and i want to arrange them in increasing order of their height right now assume they are standing in some random order what are the different ways in which i can actually arrange them in increasing order of their height and i'm going to take various uh sort of approaches i would have taken and then i would sort of map it to what that approach is in real life so approach one approach one could be that i ask everybody to come one by one and i mean let's say if i have a few people already standing in the line let's say i have a few people that have already arranged in the line and let's say there is this new guy with this height that comes in fact it is better to imagine i mean maybe i can write the height of each of those individuals let me just write the height so imagine i had somebody with height 1 5 12 and 27 already in the line somebody with height 7 comes one thing which i can do is i can find the right position for this person which is between 5 and 12. and i insert 7 there which means then i'll have 1 5 7 here and then 12 and 27 i'll push one space back right so 12 comes here 27 comes here right and then as people keep coming let's say there is a person called 32 i'll figure out where 32 should lie here i'll figure out 32 should come here i'll insert 32 here everything up after 32 would be pushed one space back to make space for 32 here there is nothing this is called insertion sort this technique where i get numbers i figure out what is the right location for them i can do that through binary search or i can do that through a linear scan either is fine once i find out what their location should be i shift all of the other numbers one space to their right and then insert this number new number at the new location now that is called insertion sort if i have to write the approach for this or the steps for this basically assume that i am maintaining my sorted array in let's say sorted array list that's a sorted list which is initially empty and imagine i keep getting a few numbers right what i do is i start from the end of this list for example here if i had 1 5 12 and 27 and i wanted to insert 7 i'll start from the end is 7 already bigger than 27 it is not so what i would do is i'll shift 27 one space to its right so imagine this was the array i have one space left here so i'll shift 27 to its right so 27 comes here then i go and again check 12 is 12 i mean is 7 bigger than 12 no it is not so i'll shift 12 to 1 space to its right 12 comes here then i check the next number which is 5 is 7 bigger than 5 yes that means this is the location of 7 and i insert it here that is i keep doing this with every new number that i encounter and that makes for what is known as insertion sort what is the best case complexity here best case time complexity here and what is worst case time complexity here best case for sorting order one would be the time complexity of inserting a new element best case right because you you start with seven you'll find that i mean let's say the new element that we are inserting in this new array let's say that is 32 best cases i look at the first element and i find that 32 is bigger than that and therefore 32 just gets inserted here it is for the addition of the last like the new element order one is the best thing that you can do but you will have to add n such elements so therefore if you do order one for n elements you will end up with order n best case complexity so in the best case insertion sort will take order n time what is the worst case when do we get the worst case what is the worst case and when in what kind of data would we get worst case if the array was reverse sorted which means if let's say i was giving you numbers i first give you number five you insert five then i give you four you insert four here right because you'll have to shift five five one then i'll give you three you'll figure out that actually three is smaller so you'll shift five here and you'll shift four here and then three comes here then i give you two you'll again like shift five here you'll shift four here you'll shift three here and then two will come here and then again you'll do one more shift and to get one in if i one is the next number right this ends up taking i mean for the first number you take one step for the second number you take two steps for the third number you take three and for the fourth number four and five and six and so forth so this becomes almost order of n square so worst case this might take order of n square when when the numbers are sorted in decreasing order a very interesting question which is does the time complexity affect if we take linked list there are two parts here right like one is i mean there are two things that we're looking for one is what is the right index where this new number should go and the second is shifting shifting greater numbers to make space one place right right so your linked list will save you on this time so this time will become zero however finding this one in a linked list because you can't really jump to a random location you'll have to do a linear scan to figure out where the number should occur right so you'll that might still end up taking order of n square because searching for the right index the step number one that might end up taking order n you can't apply binary search in linked list because you can't just jump to a random location in the list right now the way i explained insertion sort was that you were getting a stream of numbers and then you're sort of sorting it by putting them in the right location now whatever i said that can also be applied to an existing array as well let me explain right now the way i detailed insertion sort is by saying that you know what like five i'm getting five then i'm getting four then i'm getting three then two then one imagine i was already given an array right so imagine i had the array as let's say 5 8 3 2 18 hypothetically right and i asked you to sort this array in place without using extra memory i do not want to use any extra memory can you sort this array without using extra memory insertion sort so i don't again have the flexibility of creating a new array i am doing this in place how do we do that in place even when you're doing in place imagine i start from five right so first i'll start with five i'll say i only have to sort this five is the new number that i've gotten right so i have one place five is a new number i've gotten obviously it will go at this position so five comes here then i go to the second number and i say let's put this in a temporary variable temp is equal to 8. now 8 is the new number i'm trying to insert in the first two locations right so first i'll compare with 5 is 8 already bigger than 5 yes it is so it will come here then i look at sorting the first three numbers i pick 3 so i delete 3 from here imagine and it is this 3 is the new number to be inserted so first i check with 8 is 3 bigger than 8 no it is not so 8 will come here is 3 bigger than 5 no it does not so 5 will come here and then 3 gets inserted here so now if you look i mean by now i have the first three numbers sorted now i'll take this number two which is i'm trying to sort the first four numbers i'll take the new number two and imagine that two is the new number that i was getting so i put this in a temporary variable and do the same comparison is 8 no so 8 comes here is 2 bigger than 5 no so 5 comes here is 2 bigger than 3 no so 3 comes here and then 2 comes here and then finally 18 is bigger than eight so 18 will directly come here does that make sense so same approach all i'm doing is i'm saving on the additional space if an array is given to me already the worst case time complexity is still the same nothing has changed in the approach i'm just using the same space that was there in the arrays instead of creating a new array okay so if you apply binary search for position it will contain more computations like finding plus swapping yes if you do apply binary search you'll first take login time to find the right location and then in worst case order n extra time to create the space i mean right shifting all of the elements to create space for this other element right so it will end up taking n plus log n every single step instead of just n every single step so this log n is additional overall time complexity will still remain n square because you'll do this n times so instead of n into n you'll get n into n plus log n which is basically n square plus n log n which is still order of n square but why do that i mean why do this additional operation why not just start from the end you have to shift the bigger elements one step to the right anyway just start from the end shift the elements to the right and then like fit the element wherever you find the first place all right everything clear till now so that is one way in which you would sort let's say your classmates right the second approach that i have is let's say i have an array right like let's say the same array i had in fact let me go with the original 5 10 3 to 8. so 5 10 3 and i put this in an array now what i know is that in the sorted array the smallest number has to come at the beginning of the i do we all agree with that smallest number has to come at the beginning of the array right so one thing that i can do which is not very optimal but still works so this every single time i look at what is the minimum in my given array for example if i run this loop i'll figure out that 2 is the minimum i say ok great if 2 is the minimum let me push 2 to the beginning of the array so 2 comes here and then i can just swap it with 5 so 5 comes at the place of 2. so when i do this 2 comes here 5 comes here now what i know is that now 2 is at the right position i only have to sort the remaining 4 elements and i repeat the process i for the remaining 4 elements i again look for the minimum find 3 so i swap 10 with three and then i sort the last three elements and then again like i look for the minimum five i put five here and then so forth right the only downside of this approach while this approach works the only downside is it is order of n square no matter what the input so the best case worst case everything is order of n square the good thing with insertion sort was that there is a case where the best case was order n so therefore the average performance could have been better if we do this it is always order of n square i mean basically the steps were find minimum two is put in start of array and then start plus plus that was the the approach if the array is already sorted even then to find the minimum in the array you'll have to look at all n elements so every single time finding the element is taking you out of n right so that approach is a precursor to bubble sort so while this approach works the question is can we do something so that if the array is already sorted then we don't have to go through all of the elements all over again like every single time finding the minimum takes me a lot of time how do we decide when to break check whether the array is already sorted or not let me maybe give some other case right so insertion sort will still be order n if let's say only one element was not in its right position every other element was in the right position for example if the array was let's say one two three four zero the array is just very simply some random elements bubble sort is a variation of exactly this bubble sort is as the name suggests it is like bubbling something to the top right so what you do is you compare all adjacent elements one by one and wherever you have a pair of numbers so what you do is for example let's say people are standing and in some random order in the line right so for example i have people standing as 5 10 3 to 8. let me just write it like this 5 10 3 2 8. my objective is somehow bubble this the smallest number two to the top so what i do is i say the last person standing in the line hey you compare yourself against the next person to you you obviously know how to compare yourself against the next person you can check your height versus the other person's side obviously if you're standing behind and you're smaller then you should swap yourself right so i say eight look at two if you're smaller than two then swap yourself it says i'm not smaller great then i said 2 look at the next person ahead of you if you're smaller than that then swap and i do see like 2 or 2 is smaller than 3 so i swap so 3 comes here 2 comes here then i say 2 swap yourself against the next person if the next person is smaller i figure out 2 is actually smaller than 10 sure i mean should get swapped so 2 comes here 10 comes here and then i again say 2 again compare yourself against 5 if you're smaller swap yourself so 2 again gets compared with 5 5 comes here 2 comes here so what has happened in this one order n loop the smallest number has bubbled itself to the top of the array this is why i mean because the smallest element is bubbling to the top it is called bubble sort even this approach in the worst case will take order n square there is one difference here though if there are no swaps that happen all throughout in this order n loop then we just stop there which means if the array was already sorted then we would not do the next iteration we'll keep doing the next iteration as long as there is swap happening so let me elaborate again what happens is imagine you are standing in the line i start from the last person i say compare yourself against your neighbor you compared yourself against the neighbor if you are smaller then you swap yourself and then you do that till the start of the array one thing which is guaranteed in this loop whatever is the smallest number will bubble up to the top of the array then you're left with sorting only the remaining part of the array and you also know if there is any iteration where i went from the last person to the first person there was no swap happening between the neighbors then i know that elements are already in the increasing order i can just stop i do the same process again now two i don't care about i already know two is in the right position for the remaining elements so i again start from eight i say eight are you bigger than three eight will say yes i am and i said three are you bigger than ten no i'm not so we'll swap three comes here ten comes here three are you bigger than five you're not so sure i mean then let's again swap so three comes here five comes here again if you see three has bubbled up to the top which was the next smallest element and then you're left with sorting only the last three elements any iteration where you don't have any swaps your array is already sorted you can just stop since we had one or more swaps in the first traversal we'll start again from eight but will not go till two two will be ignored i mean the first element is already sorted so we'll be you know we'll stop here now that in the second iteration we know that the first two elements are fixed we'll start again from eight but we will stop at after three i mean we'll not look at three and two anymore because we know that they are in the right position every single iteration what is happening is the smallest element is bubbling to the top and any single iteration i know that there is no swap that has happened i can just break and therefore i do have a best case complexity which is if the array was already sorted i will do an order n iteration to figure out are there any swaps but post that order any iteration i can just break or if i reach a stage where intermediary stage where let's say i did these and then the remaining numbers were already sorted then also i'll just break right so i'm not really spending time sorting if the array is already sorted does that make sense let me actually write the pseudo code for this what i'm going to do is i'm going to start so here is my inner loop right so i'm going to i'm going to start from the last element let's say there is a j that starts from n minus 1 goes to imagine i am doing a loop of i from 0 to whatever i'll tell you what 0 to whatever it is it goes to i imagine that like numbers still i are sorted right now nothing is sorted so n minus 1 to i what i do is here i compare a of j with a of j minus 1. now i know that in the right order a of j should be bigger so if it is smaller if there are two numbers where the second number is smaller then obviously they should be swapped the second number if it is smaller if this is smaller then they should be swap because they are not in the right order so i just say swap a of j comma a of j minus 1 right by the end of this a of i will have the smallest element anyhow i is starting from 0 a of i will have smallest element anyhow i also keep track of one variable here has there any swap that has happened let's say there is a flag which is initially zero i just whenever there is a swap that happens i make flag as one if at the end of it if i see that flag is 0 then i just break which means this element was already sorted there is no need to look at other elements and then i goes from 0 to n minus 1. yeah sorry this is i plus 1. correct so again like what is happening in the algorithm is the smallest element is bubbling to the top and you're just taking in the process making sure that if the remaining elements are in the right place there was no swap then the element is all i mean array is already sorted so let's just break yeah i mean actually we don't need the n minus 1 when we come to n minus 1 i plus 1 would anyhow this j 2 will not run so i can just do n minus 2. again let's let's look at what is the best and worst case complexity of this algorithm best case is order n which is my array was already sorted or almost sorted and then i mean i do this iteration flag becomes 0 i break in the worst cases when it is reverse sorted so i every single time i have to do all a lot of these swaps and that is actually order of n square all right so this is by the way called bubble sort find the smallest element move it to the beginning this is called selection sort in selection sort as well you could be it's what we were discussing where we were selecting the smallest element and moving it to the beginning of the array that is selection sort the reason why we are discussing this is these are intuitive ways of how we think about sorting and the technique can be can come into use later on let's do a dry run with with bubble sort just to see the best case right so imagine i asked you to sort this array one two three four five imagine this was my input correct minor character selection sort is sort of an led algorithm because what you're doing is you're saying that i know the smallest element should come at the beginning so let's find the smallest element you put it in the beginning and then you sort the remaining array let me however show like how the bubble sort is still best case order n i mean selection sort by the way we can also make order n in one case i'll also go over that selection sort this slight variation and it can become best case order n let's first look at how it becomes order in best case in bubble sort imagine this was your input right you start with i as 0 i is 0 j your flag is also 0. j basically goes from so you have your index one two three four j will start with four and it will go till one four till one and what do you do every single time you just compare a of j with a of j minus one so you hear you check is five less than four the answer will be no so then you move on to the next j so from four you will go to three from four you will go to three then you compare four with three is four less than three no then you will compare three with the previous element is three less than two no it's 2 less than 1 no so at no point this if condition gets executed so there is no swap and therefore flag never be becomes equal to 1. so when this loop finishes when the j loop finishes you come to the point where flag is still zero and therefore you break so just after the first iteration with i zero you end up breaking because you figured out there was no swap involved in my error so my arrow is already sorted why should i look at things again so that's why you get the best cases order n worst case is obviously n square now let's look at what is the case or like how do we make sure that even my selection sort which is like very greedy like can i modify it somehow so that that also becomes or best case order n let's see let's take some random input right so i had five three eight four six now the way selection sort works is you go from the beginning you look at this you try to find the minimum element in the array this is the the approach just before bubble sort that i had talked about you try to find out the minimum element in the array in this case i find three as the minimum element and then for this i take an order n loop right in order n i find minimum of the array now if in this iteration only i would have figured out that the array is sorted in this order n if i figured out that the array is sorted which is all of a i is less than a i plus 1. then my work is done however if it is not then the smallest number that i found which is three i try to swap it with the previous element basically i i try to put it here and shift all of the remaining numbers one step to the right which means the array now becomes three here i have five eight four six in fact let me just change the array a little bit so that it becomes slightly better imagine if the array was four five six eight when i do the swap then the array becomes or when i push it here then it becomes three comes to the beginning and then i have four five six eight now again i know that at this point of time 3 is at the right position i still need to sort the remaining array i'll again have to do an order of n minus 1 loop this this this and this to figure out the minimum number in this case it is 4 as the minimum number but by the way in this order n minus 1 loop i figured out the array is already sorted so i can therefore stop my process the key thing to do here is when you find the minimum element you don't just swap but you shift the prefix of the array one step to the right create space for this new element and then you put it in the right place if you do that then i mean the selection sort also becomes best case order n one thing is i mean in most cases you will neither be using bubble sort or selection sort or insertion sort actually in certain chart may be in certain cases but most cases you'll not be using these these are algorithms that that are good to think about the approach that we utilize here this might come into use later on in some of the other kind of context and some of the other kind of problems but the sorting algorithm that is currently in use in most of the libraries that you use are either merge sort or quick sort quick sort as being the most popular one because it has better average performance does not use additional memory but those are the ones because they sort of perform in order of n log n time all of these are worst case order of n square average case is also order of n square almost java 8 array.sort also uses quicksort but like bubble sort insertion sort three algorithms that i talked about they're good to know from their approach standpoint because there are some problems that might utilize this approach these are not necessarily the sorting algorithms you will use in day to day sorting algorithms that you will use i'll talk about that in a few moments but just so that i again complete my discussion on selection sort let me write the pseudo code for selection sort sudo code is very simple right now if i have to sort imagine when i is 0 i need to sort everything from 0 to n right so what i do is i take this will go to some number and figure out what i will take the loop from i to n i'll figure out the minimum in fact let me actually also track its index i can just keep it as a of i and index is equal to i and this loop can run from i plus one so if let's say a of j is less than min 1 then minimum is equal to a of j index is equal to j here one of the other things which i also track is if a of j is greater than a of j plus one then there's a flag that i set to let's say one let's say there's a flag here which is also zero and once i have found my minimum then all i need to do is all of the other numbers they are shifting one space to the right so i again once i have found the minimum i will take a loop of j is equal to [Music] and then at the end you have a of i is equal to minimum that is one way of shifting basically what i'm doing is if i have an array let's say i have five six three two eight i'm going through once to figure out what is the minimum once i find the minimum i bring minimum to the front which is two comes here and then five six three i shift one space to the right and then i try only sorting this piece where every single time i have a flag to check is this piece already sorted or not if if at all at any point of time i find that there is a section of array that has already sorted then i just break out and and i'm done here i mean i could very well also have done instead of doing all of this i could have done swap a of i comma a of index i could have done this as well as long as i'm checking that for the remaining array is the array sorted or not if the array is sorted then i just break that is the only optimization that i put in nothing else now i'm going to be covering a few other sorting algorithms and then we'll do a few problems on these count sort is the easiest one downshot shortens when the elements that you are sorting they are limited in range limited in range meaning for example i tell you hey you have characters a to z you have a lot of characters and you need to sort them or you only have numbers 0 and 1 or you only have numbers from 1 to 20. then what you do is instead of counting or basically maintaining like numbers themselves you just count how many numbers for example i gave you an array of zeros and ones right so bunch of 0 1 0 1 1 one zero etcetera and i told you to sort this array one very simple way would be i calculate the frequency of zero and frequency of one this is basically exactly what count sort means right like you're maintaining the count of the numbers themselves so you you say like i'll count how many times 0 came let's say 0 came 10 number of times and i'll count how many number of times one came let's say it came five number of times then i know my sorted array my sorted array is zero zero zero zero zero ten times and then one one one one one five times so one very common application of this is if i give you two strings and i ask you are these strings anagrams of each other anagram says like two strings are anagrams if they are just some or the other permutation of the same string for example if i give you a string banana and i give you another string let's say this is not really a word but i give you these two strings right and i ask you are these anagrams of each other your answer will be yes because they have the same count of n there are two n's here there are two n's here they have same count of a they have three a's here there are three a's here and they have same count of b you know that you only have 26 different characters so in a 26 array array of size 26 you can maintain the counts of number of a's number of b's number of c's and so forth and you can just compare the counts right so count sort is very simple if you have limited number of numbers if your range is very limited you maintain the count of every single number you encounter and then like you just print those numbers those main number of times you go from start to beginning so we are going to maintain a new array for zero and one however zero and one are just two two numbers two variables so it is still order one space if you only have let's say 20 numbers then it's just order of twenty space which is not order n right like it is not dependent on the number of numbers that you have in total and let me maybe give you an example right and then i'll write code for it that will make it clearer very simple imagine i gave you a string of characters a string of characters and i just asked you to sort that string of characters for example let's say the string is congratulations let's say that is a string and then there were a bunch of bunch more characters as well but like let's just say that this is the thing there could be thousands and thousands of characters here thousands hundreds of thousands of characters the one conventional way of sorting is like doing the bubble sort or the selection sword etc right if it's a selection sort would be you figure out which is the smallest character which is a you shift a to the front however i mean if there are a lot of characters that will take a lot of time so what i say is hey by the way i know that the kind of letters could only be from a to z correct i have a b c d e f till z correct there are only 26 characters possible 26 different characters possible so if i somehow maintain the character count right i have only 26 characters if i have an array which has the count of what are the number of a's here what are the number of b's here c here and so forth for example when i encounter c i say let's increase the count of character c by one so c's count becomes one and i mean this is this could just be an array right because any character can be mapped from a number from 0 to 26 so i just maintain an array of size 26 which is all initialized to 0 to begin with when i encounter c i increase the count of c by 1. then encounter o let's say os somewhere here i increase the count of o by one when i encounter n i increase the count of n by one with r i'll again increase the count of r by one a a will become one let's say when i encounter a again here a's count will become two so that way i mean i'm just maintaining count of every character right like and if i have to write code for this i would just do very simple i would say that you know what like i have a array of size 26 which is initialized to zero this is c plus plus format but like java etcetera it will be similar and then i just say you know what like let's assume that the character is ch and i go over this string str and i just say ar ch minus a which will now give me a number from 0 to 26 plus plus at the end of it i'll have frequency count of every character and then like sorting is very simple i just go character by character right so i just go from for i is 0 to 26 i look at the count of the current character like for example when i is 0 then i'm looking in the count of a so what i do is i take a loop from 0 to arr of i whatever is the count and i print a plus i those many number of times so what will happen is if the count of a was 2 then this will print a twice then let's say if the count of b was 1 then it will print b if let's say the count of c was 3 then we'll print c three times and so forth so all i'm doing is i'm just counting the numbers frequency of the numbers and then i'm just printing in them those main number of times going in the order of numbers does that make some sense count short how is it working as long as the range is limited for example let's say if if you have numbers from minus 20 to 20 even then you can use the array right because you can just say that every single number num corresponds to the index num plus 20. so when you encounter them you just say you know error of num plus 20 plus plus and when you print then like for arr of i is count you print i minus 20. in general if you see for doing this if you have a range of numbers let's say the range is r count sort takes order of r memory right if the range from min to max of the array if the range max minus min if this is r then it takes you order of r memory right because you need those very number of counts variable right if r is small small ish for example let's say if r is thousand or ten thousand or hundred thousand or one million if let's say r is up to 1 million then you can use count sort because you can maintain the counts and therefore like you will still run however let's say if the numbers were not limited if if there could be any integer then you can't use count short count is only applicable when the numbers are limited in the range as i showed with counting characters in a string because characters are limited characters can only have 26 different values so it is not done in place in the sense that you're still counting the number of a's number of b's and c's and then you can fill it in the same array for example if you said tell me here instead of printing a plus i i can just say you know what let's have an index variable which is zero and i have let's say my original string was str i can just say you know what str of index plus plus is equal to i plus a i can fill it in the same array instead of printing but i mean you'll still have to maintain counts etc merge sort is if imagine you had to sort a deck of cards one possible way which is by the way also called divide and conquer could be that i break down this deck of card to half deck of card and half deck of card so i divide into two parts right like half goes let's say to the left half goes to the right i sort those individually right so half deck of cards i sort them somehow by some magic and right side also i thought somehow by some magic so now i have two sorted deck of cards right i have two sorted deck of cards now the problem becomes if i have two sorted deck of cards can i merge them so that they still remain sorted imagine let me give you an example right so let's say i have an array two three five let's say i have another array one six eight if i was given these two arrays can i merge them into another array which is completely sorted is that possible or not if that is possible then this could become another algorithm which is like whenever i need to sort an array i can divide it into two parts recursively sort them and then i can merge them so merge becomes the important step the question is i have given you a problem you have two arrays not necessarily of the same length let's say this is of size a this is of size b can you create another array of size a plus b where all of the elements come from a or b and they are all sorted is the question clear like you have some a number of arrays in array a your b number of elements in array b array a and b are individually sorted so a is a sorted array b is also a sorted array you have to merge them into another sorted array how would you do that basically if i have been given two numbers let's say i have an array a two three five and i have an array b which is let's say one four eight and then i have to create a sorted array right which is of size three plus three which is six one two three four five six correct this is the eventual sorted ad i have to contain or create one thing is the first element in the sorted array is going to be the completely minimum of all everything in the array right so given array a sorted minimum from array a is on position number zero correct minimum from array b is also on position number zero so therefore whichever is the minimum of these two i don't need to look at any other element whichever is the minimum of these two is going to be the first element in the sorted array is that something we all agree with and what is the minimum of these two minimum of these two is one so one comes here now if i have inserted one here and it is as good as saying that now i remove one from b it is the same thing right so what i just do is how do i remove one from b i just change this pointer to now point at this number four this is as good as saying that i'm now merging two arrays one array which is a and one array which is b but b is starting from this point onwards and i again do the same thing what is the next number that should come here it should be the minimum of numbers here and minimum of numbers here what is the minimum of numbers here array at this pointer what is the minimum of numbers here the array at this point whichever is smaller which is 2 comes here and this pointer moves one step forward so in short the approach becomes that you have two pointers let's say there's a pointer 1 which is for array a there's a pointer 2 which is for array b and you just say the following while pointer 1 is less than whatever is the size of a and pointer to is less than size of b you do the following you figure out which one is smaller you just check if a of pointer one is smaller than equal to b of pointer two then simple this is what goes in the sorted array so let's say sorted off let's keep an index a of pointer one you increment the pointer one plus plus because now pointer one has been assigned here else you put pointer to element here so sorted off again index plus plus is equal to b pointer two pointer two plus plus the only thing is when i'm done with this while loop it is possible it is possible that all of the smaller elements are in one of the added imagine like this array was one two three here and there were let's say four five six here my pointer one will end up going here and i'll end up breaking out where i've only filled in one two three in the sorted array four five six is yet to be filled so i'll have to check for that which is at the end of this while loop if whichever pointer is is not done so i just check while pointer one is less than size a i just keep adding sorted of index plus plus is equal to a of pointer one plus plus and very similarly i do the same thing with pointer 2 while pointer 2 is less than size of b same thing sorted b of pointer 2 plus plus right that will cause the merge to happen does this make sense right now if that can happen which means now if merging can happen and what is the time complexity of this merge imagine i have two arrays of size n and n h m plus n n plus n right like so it takes me order n time to merge if in fact the array a was of size m this was of size n it takes me order of m plus n time right that means if i have a order n array to be sorted if i divide it into two parts i say that sort first part separately sort the second part separately once they are sorted then merging them will take me order of n by two plus n by two time which is order n time so merging them will take me order n time now how do i sort the first half of the array i can do the same thing with the first half as well i can say that even to sort the first half again break it down into two parts and then sort the first half or the second half merge it with the end condition being that once i have an area of only size one it is already sorted how about i modify this and i say that i have three arrays that need to be merged right imagine i have a 2 5 10. imagine there is another array 1 8 9 and imagine there is another array 3 4 12. let's say there were three arrays right how would you merge these three arrays into one array which has all elements are sorted we can do two at a time but we don't necessarily need to right like we look at this what is the first element going to be in the merged array it is the smallest of all where does the smallest come from it is either the first element from here or the first element from here or the first element from here whichever is the minimum from here that becomes your smallest so i can have three pointers pointer one pointing to the zeroth element pointer two here pointer three here whichever is the smallest of these three which in this case is one one comes here and then all i do is i move this pointer one step to the right and i again repeat the same thing whichever is the smallest of these three which is two two comes here and then two's pointer moves one step to the right now again five eight three whichever is the smallest three is the smallest three comes here and three's pointer moves to the right five eight four four is the smallest so four comes here and its pointer moves to the right five eight twelve five is the smallest so five comes here and five's pointer moves to the right and then so forth right in the case of merge or it is only two arrays an extension of the previous question then instead of two if there were three arrays how do you go about merging three arrays i mean you can merge two areas at a time you can merge these two at a time and then you end up merging these two but you'll end up using more memory because to merge these two you'll need an additional array of size 6 then you'll create an area of size 9. what i'm doing is i'm just directly creating an array of size 9 so that i reduce the amount of memory required to maintain that intermediate rearray also i reduce a step okay all right coming back to the merge sort how does merge sort work as the name suggests it's divide and conquer which is basically now that i know that i have the superpower of taking two sorted arrays and merging them what i can do is i given an array a i sort the first half so sort a to zero to n by two sort a of n by 2 plus 1 to n and then merge these guys that can become my approach and this how do you sort the first half this also can happen in the same way where you again divide into two parts 0 to n by four and then n by four to n by two and again then you merge et cetera right and if i have to write code for this it becomes fairly simple which is let's say if the array if the question was how do you sort array a from index i to index j if if obviously like the size of the array is already 1 which means if j is equal to i let's just put that then your array is already sorted so you can just directly return if not then what you do is you basically sort the first half which is you say i'll go from a of i to mid where my mid is i plus j by 2 then i'll sort a from mid plus 1 to j and once these two guys are sorted then i will need a temp array where i'll merge the array from i to mid and mid plus 1 to j and then i'll make sure that a of i to j becomes equal to 10. i'll just do that but basically i'm just applying recursion here and what i'm saying is if you want me to solve by the way let's say there is there are four numbers right five three two six let's say those were the four numbers i say that first sort the first half so let me call the function to solve these two numbers five and three somebody sort this and then give it to me and then sort the second half separately so somebody sort two and six and give it to me and once i have them sorted then i will actually merge them right now to sort five and three i again do the same thing i split it half i say somebody sought five for me and somebody shot three for me here also and somebody saw two for me and then six for me once they are sorted then i'll merge five is sorted three sorted how do i merge in my merge step the same way we have seen we have two arrays we have to merge when we merge this will become 3 5 and that is what i replace my original array with so this array becomes 3 and 5. very similarly 2 6 remains 2 6 and then once i have 3 5 and 2 6 then i merge them to find 2 comes first then comes 3 then comes 5 then comes 6 and this becomes my actual sorted array which i replace this with just out of curiosity why do we divide them into equal halves although in the end we move two single elements and merge them in sorted order can't we take pairs in the array and do the same way of merging let's say i have more numbers right so imagine i had 5 6 8 1 2 13 15 12 3 how many do we have we have 4 and let's imagine i removed 12 from here question is if we have to sort anyway why don't we take pairs by pairs right so let's let's just take pair 5 6 8 1 2 13 15 3 and let's just first sort them so we we end up sorting them and for example we end up finding that this is 5 6 this becomes 1 8 this is 213 and this becomes 315 right now the problem is like we've done pair by sorting but the array is still not sorted then we'll have to do sorting of four four elements each right how do we do that we say that you know what like there are first four elements here the first half is sorted the second half is also sorted let's merge somehow which again i'll take another array and then i'll merge etc so this will get sorted then i'll do again the same thing which is i take four elements half is sorted half assorted and i'll do the same thing and then finally i'll look at all of the eight elements so you're going just in the reverse order what i just said you're just going in the reverse order which is also correct it's just a harder to code because the previous approach can be coded using recursion which i'll just show uh in your approach what you're doing is you're building bottom up right like you're sort of saying that let's first sort all pair of elements once they are sorted then let's look at all four size elements great once they are done then let's look at all 88 size chunks once they are done then look at all 16 size chunks and then 32 size and then 64 and so forth right then finally i'll have the entire array sorted which works it's just harder to quote what i said was the other way down that instead of going from one to two to four to eight and so forth let's start from n let's divide that into n by two parts then n by four then n by eight and i'll finally reach the one part anyway and then my recursion function will keep returning and i'll have the eventual answer so if you look here my recursive function this will do the same thing my recursive function here will also do the same thing let me also write it as merge step so what is happening is if i have an n sized array i'm dividing it into two arrays of size n by two each n by two each i'm sorting it using the same methodology which is this n by two will create arrays of size and by four n by four here also again same n by four and by four these will create arrays of size n by eight n by eight again n by 8 n by 8 same thing and this n by 16 and by 16 and so forth how many levels will you have here i mean we go from n to n by 2 and by 2 n by 4 and by 8 4 to n by 8 and by 8 to n by 16 how many levels log n levels right so in every level n is becoming half of what it was as we have seen the same pattern in binary search etc etc i mean as you go if n is becoming half what it was it takes you log n steps to finally come to one at every step what is happening i at every step basically i have n by two n by two sorted array i'm merging them which takes me order n time this takes me order n time and y two plus n by two are order n what happens on this level these two guys merge and takes it takes them n by four plus n by four which is n by two time these two guys merge and it takes them n by two times if you add them up it will take you order n time on this level as well very similarly on the other level as well where you have n by eight there are eight instances of n by eight it will again take you order n time so the total time taken on every level it takes you order n time there are login levels the total time taken is n log n that is an intuitive way to understand i can also explain the mathematical way of explaining this but the intuitive way of understanding the time complexity of merge sort is that on every level you're doing one merge the merge is order n number of levels is login and therefore in fact if you look at irvine's approach if you were to implement it in every iteration what you're doing is you're first creating pairs and you're merging the pairs takes you order end time then you're looking at all four four blocks right like blocks of four each in one order n operation you'll have sorted blocks of four each then in again one order n operation you would have sorted blocks of eight eight each and you'll keep doing that till you cover the entire array so the number of steps to cover the entire array would be log n and every single iteration is an order n iteration so it takes you an order of n log n i can explain the math behind it as well is it n log n in every case best case is sure i mean you can probably put an optimization that the array is already sorted if a half is already sorted you don't need to do all of the splitting etc so best case you can still make order n but yes worst case is order n log n worst case it takes you order n log and you can put a check to make sure that you're not doing the entire splitting etc if the array is already sorted all right what is the space complexity of merge sort so if you look at the implementation here we are allocating this additional memory temp to calculate this merged part right why because when we are merging to sorted arrays we need this temporary space where we put in the result which is not a part of the original array this is additional space if i have to look at this tree in this n by 2 part i would have taken a temp array which was of size n by two here i would have taken a temp array which was of size n by two in fact let's look at total space allocation right so this n by two will make a call to n by four eight etcetera so this this is a login stack memory space plus in each of these so imagine i was sorting this array of size n this will end up calling for n by two this will end up calling for n by four n by eight and so forth in each of this i would have a temp array allocated which will be freed as long as i mean i fill it back right so this temp array here is of size n by four as soon as i am done then this will be freed then i come back here here it will be of size additional size of n by two as soon as i'm done it will be freed and then i'll come back here and i'll have a time barrier additional size n so maximum space that i end up using additional is i have log n stack of recursion plus i have this additional order n size array that i might have used which is my temp array so order n extra space is what we end up using apart from the array space so space complexity becomes order n time complexity becomes order of n log n there's one more way to by the way calculate time complexity i mean if you assume that the time taken for sorting an array of size n is tn and tn is nothing but i'm saying first sort array first half of the array then sort second half of the array which is also size n by two and then merge them which is it takes you some n time let's say let's say it takes you one time this is basically saying 2 times t n by 2 plus n right if you break it down further your n by 2 is 2 times t n by 4 plus n by 2 which is the same as 4 times t n by 4 plus 2 n which you'll see will finally come to 2 power i t times n by 2 power i plus n into i i mean this is just a little mathematical therefore i explain the intuitive way first which i mean if you want this to become equal to 1 i becomes log n so you have n into t times 1 plus n into log n which is n log n this is what how masters theorem actually works i'm just elaborating that expanding that equation even if you don't know about master's theorem that is fine as long as you understand the intuition of why it is n log n because in the recursion tree there are login levels on every level i'm using order n time so time complexity becomes order of n log n space complexity becomes order of n is there any way without using the extra space so actually merging two sorted arrays without using extra space in order n is not possible that becomes the the blocker right so if you can merge the array in place without using extra memory then your problem would have been sorted but the problem is like merging without extra memory is is the issue all right does this make sense merge sort space complexity time complexity all of that all right today we'll be talking about quicksort and today we'll be solving a lot more problems actually by the way i just wanted to maybe also share one news with all of you today was the first case when one of the fellow students at scalar has gotten an offer as a cto at one of the energy companies which is a fairly big company now right and that reason why i'm sharing this with all of you is to show you that look i mean learning matters i mean and then like again i can't disclose the exact salary of the person but it is it is in a few crs we're not talking about likes right so the thing that matters at the end of i mean that is basically the north star for all of us he is he's 30 something but like we all should focus on the learning aspect as long as we do that eventually all of us will succeed will go and build really really great things in the future he is part of skiller academy and not scalar plus and i can't disclose the name of the company and i'll show i'm sure like that news will come out later on it will be shared with all of the community as well once he joins is still sort of confidential but just letting you guys know i mean look it is important that all of us focus on learning as long as we do that i mean obviously like what you find later on is is going to be a function of what you know at present plus like some bit of experience i mean so again just to also elaborate this person is not somebody who is very young as i said like he's 30 plus already has more than 78 years of experience actually has more than 10 years of experience but as long as you keep learning the right things you'll move keep moving forward and that is all of us should just aspire to become one person better every day that being said back to back to what is the agenda for today today we're going to actually talk about one sorting algorithm which is actually used in most libraries that you beat in java or python or c plus plus the sort function that you use they all use a different algorithm which we will talk about today but instead of talking about the algorithm which is i believe not the right way to introduce a concept what i'm going to do is i'm going to give you a problem a real life problem that you may take an attempt at solving and then we'll use that to maybe introduce the approach so imagine this imagine um you have a bunch of nuts and bolts let me just you have nuts and bolt right so nuts basically look something like this and then you have bolt that is basically a circle that fits into the nut the nuts and bolts and usually they're created in pairs right so you have a nut of a size and then the bolt actually clearly fits if the nut and bolt are the same size then they fit now imagine you have a lot of nuts and lots of bolts and you are given that every single nut is of unique size it is every single nut and bolt are of different sizes so none of them have the same size and you are also given that every nut has a corresponding bolt one fact that is given is every nut has corresponding bolt which means they both fit each other two is no two nuts have same size so they are all different sizes however it is very hard for you to just visually differentiate which one is bigger or which one is smaller so what do you do what you do is like if you pick a nut and you pick two bolts if the bolt is loose then you know that the bolt is bigger if the bolt is not going in then you know that the bolt is actually smaller now the problem is given that info can you sort all of the nuts and bolts in increasing order of their size with the right nut and bolt paired up currently they are all just in this array you have a table full of nuts and bolts you don't know which one is paired up with which which one right one is how can you arrange that and two is how can you do it as fast as possible let me explain again right so imagine this let's say i had only two nuts imagine i had this nut another nut and i had another bolt and then another bolt right now what i can do is i can pick let's say this particular one and i pick this one and let's say i try to match them there are following things that can happen one is these guys clearly fit in that case i know that this nut is to be paired with let's let's just call it bolt one bolt two this is not one not two if they fit then i know these guys are in the pair they are they belong together and then i can just compare the other bolt if it is smaller than this particular nut then it goes before this nut right if it is smaller otherwise if it is bigger it goes after and then we i definitely know that the pair for this this bolt is this nut right so i just put these two guys together either after or before depending on how it compares with this current nut so if i have to define the problem formally you can pick a random nut an x and you can pick a random bolt if you pick these two guys you will get either of the following result either you will get nx is equal to b y which means both of these guys belong together or you will get to know that by the way this nut is smaller than bolt or you will get to know that nut is bigger than bolt these are the three results you can get you cannot compare nut with nut so for example i cannot get nx and ny and compare these guys i can't similarly i can't compare bolt with bolt this i can't do this i can't do however i can take a random nut and a random bolt and i can compare them does that make sense now it does right now i mean the question is how do i sort these guys how do i sort these guys when i can't really compare a nut with a nut and a bolt with a bolt the bolt size is not given to you i mean think of it like this right you have a table which is full of these nuts and bolts and there's only minor variation in the size what you should end up with for example in this case imagine that these guys were equal n1 and b2 was equal so i would put n1 and b2 together and assume that b1 was smaller than n1 so i would put n2 and b1 before this and i will return this list n2 b1 as the first entry and 1 b2 as the second entry right so if you just compare with the bolt with the nut you do get the relation whether a nut is bigger than a bolt or not so imagine if this nut was paired with another bolt bz then you know that bz is actually smaller than b by so you can compare the pairs by picking nut from one pair bolt from another pair there is no size given or the only way is you just pick a random nut and bolt and then compare whether they're one is smaller than the other or not let's actually look at how do we do that right so one is if i pick any random nut let's say any i mean if you given let's say n different nuts let's say i pick some random nut let's call that nut n n one right what i can do is now i have a bunch of bolts i have b1 b2 b3 b4 b5 till bn i can compare each of those bolts with this n1 and i'll basically get three kinds of bolts there will be one heap of bolts which are lesser right so there's one heap of bolts which are smaller than n1 there is one heap of bolt that we will get let's call this bold bigger which is bigger than n1 and there is exactly one bolt that i will get which will be equal to this nut correct if i compare all of the bolts with this nut i will get three sets one bolt which is equal and then a set of bolts that are smaller and set up both that are bigger how these guys compare amongst each other that i don't know but essentially i i do know which bolts are smaller than this nut which bolts are bigger than this nut that you guys all agree with so if i pick any random nut i can distribute all of these bolts this way and very similarly now that i know that this bolt is the same as this nut so i can pick all of the nuts which were n2 m3 n4 n5 n6 and 7n8 till n and i can say let me compare all all of these nuts with this bolt right i'll get some nuts that are smaller so i'll basically have some of these guys if i compare with this bold i'll get some nuts here let me take a different color some nuts here which are smaller some nuts which are bigger the equal one is already here so you'll not find anybody who's equal so what we have done is we first started with one nut right and then we use that to break all of the bolts in three parts one bolt which is equal a lot of bolts that are smaller a lot of bolts that are bigger and then once you found the equal bolt we use that bolt to actually split the nuts remaining nuts into two parts smaller nuts and bigger nuts now what i know is all of the bolts smaller bolts will have their corresponding nut somewhere here i mean basically now i have three sets right i have a set of nuts and bolts which are smaller and they are guaranteed to be present in pairs here same guarantees holes here then i have one pair which is n1 b1 and then i have set of nuts and bolt that are bigger now i can actually recursively solve sort this set separately and i can sort this set separately but my problem has now reduced to sorting smaller set of nuts and bolts and if if obviously if this had only had one element then i know that this they are already sorted i don't need to test them this is exactly how quick sort work i'll introduce it very very slowly but let me take a few examples just to show how is this working and that will give you a sense of like or sort of some intuition behind how quick sort works so imagine i was given some random let's say n1 n2 n3 n4 and 5 nuts and let's say i had random five bolts as well what i'm going to do is i'm going to mark let's say hypothetically what the process is going to be like so what i'll do is i'll in step one i'll pick this nut and i'll say let's compare it with all of these five bolts and we'll find some bolts that are bigger some bolts that are equal imagine hypothetically let's say n1 was equal to b3 and imagine that b2 and b4 were smaller bolts and we found out let's say that b1 and b5 are bigger bolts very similarly then what i did was that i picked b3 and i started comparing b3 with with all of these guys n2 n3 n4 and n5 and i would come to know whether they are bigger than b3 or smaller than b3 all of the bolts again let's say hypothetically n2 and n3 were smaller and let's say n4 and n5 were bigger now the problem becomes that i i know that n1 b3 whenever i sort is going to be the third element in the set i have two elements before i don't know their order but those two elements have basically b2 b4 n2 n4 as two pairs and i have two elements after which is b1 b5 and for n5 that are yet to be sorted that is after right however this portion is fixed i don't need to change this portion it is in the right position it is where it should be i do not need to change this position this is already in its correct position so then what i do is i recursively sort the first half and then once this is sorted then i'll go to the second half how do i sort the first half i again do the same thing i say let's pick a random nut let's say i pick n2 as the random nut and i compare b2 and b4 with it oh sorry this should be this should be m3 so b2 b4 n2 n3 b1 b5 and 4n5 right okay so then i let's say pick n2 as the as the one not right and i compare b2 and b4 with it i know that i don't need to compare b1 and b5 they're definitely bigger i'll deal with them separately i'm only concerned with sorting these two pairs so i compare b2 and b4 and hypothetically let's say i find that n2 is the same as b4 so i find these guys are equal and hypothetically let's say i find that b2 was bigger i know that b2 will be paired up with m3 so i put it as it is these guys are sorted now then i have n1 b3 and i do a very similar process here as well i pick any one of these guys let's say i pick n4 and hypothetically let's say n4 pairs up with b1 and i find that b5 is smaller so therefore b5 will come here the pair of b5 is n5 that will come here so this becomes your sorted array totally now this process where i actually picked one element and i started comparing all of the remaining elements with it is called choosing a pivot so while this is a more complicated case let me take an example of sorting an array of integers and i'll show you with that imagine let's say my array was five two one eight six and one of b3 is largest that means this set does not exist the set is empty but the remaining set is still smaller set than what you began with it has now n minus one bolt and n minus one nuts so you still have a smaller problem to solve so in every step you're reducing the size of the problem so that is actually your worst case where you will end up taking n square time but still i mean that still gets you to your answer so at each step one of the pair comes at its right place let me let me just elaborate that with this array as well so in the quick start process what you do is you pick one element any random element to be the pivot for example i say that i want to pick five as the pivot so what you do is the first part is you count how many numbers are smaller than five right so you basically let's have two is smaller one is smaller eight six are not smaller that means the right position of five is the third position because there are two numbers smaller so what you do is you put five here one probably comes here so your array is basically one two five eight six and then once you have put five in the right position then you compare all of the remaining elements what you want is all of the smaller elements are on the left side all of the bigger elements are on the right side which in this case has automatically happened but in case it wasn't what you would do is you would start from here and you would start another pointer from here the first number that you find on the right side which is actually smaller than five you'll stop there just try to find the first number from on the left side which is actually bigger than five you'll stop there and then you swap those two guys so in order n you'll be able to get to a place where all smaller numbers are on the left side all bigger numbers are on the right side and then the problem becomes that 5 is in the right position now as long as i can sort the left side of the array and right side of the array separately my entire array will be sorted and that i can again do recursively so in every step when i choose a pivot one number will come at the right position and it will divide the remaining array into two parts two smaller subsets that need to be sorted do we have to take pivot as the middle to make the swap easier i mean so if the thing is when you're choosing the pivot you don't know which one is the middle element i mean you basically start with choosing a random number as the pivot in the array that you have to sort if you are unlucky then it would turn out to be one of the numbers which is either the highest number in the area or the smallest number in the array if you are i mean if it is just very very random chances are you will find a pivot somewhere towards the middle i mean let me actually go step by step does the nuts and bolt approach make some sense basically picking one nut comparing all of the bolts with it to divide them into smaller heap bigger heap equal to and using the equal to bolt to divide the remaining nuts into a smaller heap bigger heap equal to and i know that this equal to part is in the right position now i need to sort the smaller heap of nuts and bolts separately bigger heap of nuts and bolts separately let me take another example of this actually here there wasn't swap let's see what kind of thing we can do where we would need a swap imagine i still have five as the first element let's say there is six eight one and two hypothetically let's say this was the array and again we chose five to be the pivot if five is the pivot the first step let's count the number of numbers smaller than five one and two so that means five should come at position number three in the error so five should come here so what do i do the quickest way is i just swap right so i just bring five here i bring back eight here so five comes here it comes here i remove the circle now i know five is the pivot what i want is all smaller numbers should be on the left all bigger numbers should be on the right right now it is the opposite so what do i do i say that i'll start with a pointer on the left side let's call it start pointer i'll also start with the pointer on the right side let's call it the end pointer or maybe we can just call it left and right both are also okay left and right i compare the first number and i see whether it is in this right half or not in the correct half or not right so 2 is smaller than 5 it should have been in the left half so it is not in the correct half so i make my right pointer weight here my right pointer is currently pointing at 2. very similarly i start a loop on left to find the first number which is not in the correct half in this case the first number that i find which is 8 is not in the correct half because 8 is bigger than 5 it should have been on the right half and then the first place wherever left and right is i just swap them so essentially 2 comes here 8 comes here and i now know that these two guys are in the right half so then i again start moving my left till i find the next number which is not in the right half which is six so my left will will wait at six very similarly i start moving right to find the next number which is not in the right half which would be one and i'll just wait at one and i end up swapping one and six so one comes here six comes here so your right pointer will move from this position to this position and your left pointer will move from this position to this position if you add these guys up you'll get total sum as n minus one n being the size of the array this will help you shift all smaller elements to the left of the array bigger elements to the right of the array so if i have to write the steps of quick sort one is choose any number randomly as pivot and then once you have chosen a pivot put pivot in the right position for calculating the right question you'll have to count numbers smaller than pivot so this is one order and iteration third thing that you do is using left and right pointer shift smaller numbers in left half bigger numbers and right so the fourth step is sort left part and right part separately can we optimize by choosing the correct pivot the most optimal pivot is your median basically a number which can divide the array into two equal parts that is the best pivot right because then you're left with smaller arrays to sort it is obviously faster to sort smaller arrays however the problem is like it is very hard to know what is the median of the array why do you want to spend a lot of time finding out the median so what quicksort says is as long as your your pivot choice is completely random if it is completely random then i mean you're still fine average time time complexity will will still become n log n all right what is the approach behind quick sort quick sort is essentially choose a pivot divide the array into smaller numbers bigger numbers sort the smaller numbers separately sort the bigger numbers separately your array will automatically be sorted divide and conquer most of the library functions that you use they use quick sort and they choose pivot randomly i'll explain like why randomly still works here the one thing which you'll notice is in this entire process we have not used any additional memory we did the swapping etc in place so we have not created a duplicate array all of this is happening inside the same array that is important because while merge sort also is order of n log n which we will see with quick sort merge sort uses additional space or it requires this separate array where you merge the two arrays which is additional memory required so one of the reasons why merge sort is not used extensively but quicksort is used extensively is because quicksort does not use additional space the worst case of quicksort is still really bad collections you also use quick sort now since we don't have random access how does it work for example if you use what you're saying is let's say if we have been implemented the list with a linked list then how would the the quick sort sort of work there because here i mean if you see in the quick sort you're not really doing random access all of your access is still sequential right for example let us go step by step we say let's choose any number randomly as pivot i can take a loop till the number because i'll still anyhow have to take an order n loop throughout the entire list to count the number of numbers smaller so that i know what is the right position i'll have to do that anyway so i take a linear loop to get to the number that's fine i take a linear loop to find out the right position and again i do the same thing i anyhow have to split the numbers into left and right pointer i can take a linear loop for that so in all of this case if you see we i'm not doing any random access i'm actually going step by step in a linear loop let's do what is the time complexity analysis what is let's do what is best case what is worst case and what is average case what is the best case with quicksort what is the best pivot you can choose assuming that the array is not already sorted what is the best pivot you can choose media let's say you were very lucky and you were choosing the middle element all of the time what would happen is if you were given an array of size n you would put the median in the right place so median would be in the right place and then you will have an n by two size array here and by two size array here you'll need to sort these separately so what happens is exactly like merge sort you start with an array of size n this reduces to sorting array of size n by two twice one on the left side one on the right side that becomes i mean basically time to sort an area of size n is the same as two times t n by two plus order of n for for merging and this basically comes to order of n log n so if you are choosing the median as the pivot all of the time then you end up sorting it in order of n log n if you are choosing the median as the pivot every time and and by the way this is uh probably not the best case best cases in the array is already sorted best case meaning that if you're given an array and then your median is the best right so you end up sorting in order of n log n what is the worst case i mean what is the worst kind of pivot you can choose one end when your pivot is actually on one of the ends so what happens is in one step in order of n what you would do is you'll end up choosing a pivot that is on one end so your pivot is here and you'll find all of the other remaining n minus 1 elements are on one side which means that in one order n loop you have only fixed the position of one element and you still have n minus one numbers to be sorted and if you keep doing that again and again if you're extremely unlucky your time to sort will become n plus n minus 1 plus n minus 2 plus n minus 3 plus n minus 4 which is order of n square so your worst case becomes order of n square if you are very very unlucky that you are choosing the extremes as your median all of the time does this make sense why is the best case order of n log n y is the worst case order of n square just in terms of how we choose the pivot if we are really really good with choosing the pivot then we end up choosing the median as the pivot that means it divides the array into two equal halves which is exactly the kind of thing that we did in merge sort right like you start with an area of size and you end up with two equal halves of size n by two and by two each which you have to sort which again will split further into n by four and by four if you again choose median this tree will have log n number of levels on every level you're doing order n operation so your becomes the best case if you're choosing the best pivot then it becomes n into log n if you are choosing the median as a pivot then you'll have order of n log and complexity that is clear to everybody right okay what is the worst case worst case is when you're choosing one of the pivot your time to solve or sort n sized array is in order n you were able to fix the position of one element the other n minus 1 still need to be sorted and if i just expand on what t n minus 1 would look like it would be n minus 1 plus t n minus 2 which is what n plus n minus 1 plus what is t n minus 2 n minus 2 plus t n minus 3 which if you keep adding up will become n square i was not talking about the best case case really i was talking about given an array if let's say i had flexibility on what i choose as the median so what kind of pivot what kind of pivot will give me the best complexity what kind of pivot will give me the worst complexity that was what i was looking at right so what is the average case complexity one algorithm that i wanted to address which is called bucket sort if you guys remember we did something called a count sort right which is when the elements were in limited range we would just count the frequency of elements and that would help us sort bucket sort is a slight variant of that variant being that if i can categorize numbers into buckets where i know the buckets are sorted in some fashion then the sorting problem becomes easier for me latex is exactly bucket sort for example hypothetically let's say you had a lot of numbers so let's say i have 456 923 let's say i had 150 let's add 268 and let's say i had 12 and maybe i also have 950. now imagine i was to create 10 buckets 10 buckets bucket 0 1 2 3 4 5 6 7 eight nine which is for the the most significant digit of the number let's say the hundredth place of the number assuming that a lot of the numbers are smaller than thousand they can be one million ten million as well so then we'll choose the most significant bit and we'll keep it the same position for all numbers if i do that then i know that 423 will go in the fourth bucket most significant digit is four more significant digit here assuming all of for all of them the most significant digit that we're looking at at is the third digit from the back so 923 will go in the nine bucket 150 will go in the one bucket 268 will go in the two bucket zero one two will go in 0 bucket 950 will go in the 9 bucket what i know is now if i start going bucket by bucket and i have sorted the numbers within a bucket if i have sorted the numbers within a bucket and if i just start picking numbers from here and appending them then i end up getting the entire array sorted why because i definitely know that any number that is starting with 0 is definitely going to be smaller than any number starting with 1. so dividing them into buckets and then sorting the buckets within themselves i mean sorting the numbers within a single bucket that helps me reduce the complexity to some extent and i'll show you an example of that to a major degree which is what is called as radix sort but the idea is if i can break them into buckets where buckets already have some ordering defined then i can my job becomes just simply appending the numbers in the buckets and that might give me a sorted array and i'll give you a few examples to sort of talk about what bucket sorting is and we'll do one problem on bucket sorting as well which is a hard problem but we'll do that what kind of data streams are can i use for buckets think of them as for example vector of vector of int so for example your v of 0 is a vector of numbers v of 1 is also a vector of numbers and and so forth so the concept of much sort is very simple if you can split numbers into buckets where buckets themselves are ordered in some fashion then i can sort numbers within the buckets and then i merge them that gives me a sorted answer if numbers are not on the same order how do we put them in bucket so even here if you see like 12 was not of the same order i just added another 0 to get it to the same order so imagine i have numbers as 950 1 12 9 23 256. i'll just add zero to make sure they're all of same length how do we keep the values sorted in one bucket i mean within the bucket i mean just use quick sort or whatever kind of sorting you want to use there insertion sort quick sort whatever you want to use let's take an example i mean packet sort alone isn't enough but it's not paired up with a few observations is actually very powerful so one observation that leads to sorting algorithm is called radix sort the weight addict sort works imagine again you have a bunch of numbers to sort right again i'll i'll pick the same thing which is let's say i have 923 950 let's say i have 12 let's say the number one that's a number 100 let's say i have 150 so i have 650 and 688 hypothetically let's have a bunch of these numbers so what radix sort says is look i mean at the end if i was at the end let's make all of these guys equal length so add zeros wherever applicable if all of these numbers are of equal length then at the end most significant bit this bit is the most important bit obviously if the most significant bit of one number is uh smaller than the other number then the overall number is definitely smaller it is only a problem when they both are equal then i will look at other digits so i know that so what i want to do is i want to start sorting digit by digit with most significant digit being the last place where i start because i know this is the final step so what radix sort does is it says let's start with the least significant digit let's first start based on this and what do i do i basically create again 10 buckets corresponding to 0 1 2 3 4 5 6 7 8 9. i will first look at the last digit based on that 923 goes here 950 goes to 0 0 1 2 goes to 2 0 0 1 goes here 100 goes to 0 150 goes to 0 650 also goes to 0 6 88 was here and then i append these guys right what will happen once i have done this step all of the numbers will be sorted by their last digit so i get 950 100 150 650 0 0 1 0 1 2 9 23 and 6 88 i sorted numbers based on their last digit now let's look at the next digit i repeat the same process again but with the next digit now i'm going to erase all of these guys from here we are now going to look at the second digit i say that now let's look at these numbers again one by one but the second digit is what we are looking at so 950 goes at five 100 goes at zero 150 goes again at five 650 also goes at five zero zero one goes at zero zero one two goes at one nine twenty three nine twenty three goes to two and six eighty eight goes to eight i'll again append these guys what this would make sure is now everything is sorted based on the last two digits so i append and when i append i basically get 100 0 0 1 0 1 2 9 23 9 50 150 650 and 688 and now the last step is the magic step this is where i look at the most significant bit so i erase all of this again i look at the most significant bit and i bucketize these guys based on the most significant bit so 100 comes here 0 0 1 comes here 0 1 2 comes here 923 950 150 650 and 688 now once i append them all of the numbers should be sorted which you would see 0 0 1 0 1 2 100 150 650 688 923 950. now this final array that we've gotten this is sorted what has happened we can take msb directly the only problem is then within the bucket if you have multiple numbers and think of like when you have a million numbers right you only have 10 buckets based on msp that means every bucket on average will have 100 000 numbers and if you go to solve or sort of sort each of those buckets separately it will take you a lot of time but here i can sort the entire array by doing this function the number of digits number of time so imagine all of the numbers had five digits i'll do this operation five number of times and my entire array would be sorted in every for every single digit for every single digit i am putting them in buckets 10 buckets and then i am appending them which is an order n operation right so my total amount of time taken is order n into max number of digits space is assuming that we are taking a vector of vector the total space taken by vector of vector combined across all of this is order of n so i'm using an order on n extra space actually order of 10 plus n this is order n do we need to compare an element with the existing elements present in the bracket no right now because the moment you start doing that then your complexity increases currently it is just very dumb way of appending to existing numbers in the bucket why can't we take msb to lsb i mean when we start with msb in the first step we would definitely have put the bigger numbers to the first half of the array the smaller numbers to the second half of the error that i completely agree with in fact numbers would be sorted based on their first digit but as you go to the second digit within these numbers if the sorting is happening in the right way or not because you will have let's say you look at second digit at zero right now sum of those zero numbers will come from the numbers that had the first digit as nine some of those zero numbers will come with some numbers where the first digit was six for example let's look at this example itself right if i started from msb then what would have happened let me erase this my first two numbers will go in the nine bucket 923 950 0 1 2 0 0 1 1 0 0 150 6 50 and 6 88 which is great now if i append them then i get this this is almost sorted the problem is when i move to the next digit it's then that it becomes a problem because 0 1 2 will come here 0 0 1 will come here now 1 0 0 will also come here however i know that 1 0 0 should only come after 0 1 2 when i will merge then i wouldn't know how to maintain this ordering i mean i'm using digits here you can do the same thing with bits they will only have two buckets zero and one here i have ten buckets you'll only have two buckets when you're dealing with bits when you go from lsb to msb that means msb takes higher priority because it is the last deciding factor when you go from msdb to lsb then lsb starts taking higher priority so time complexity is n into number of digits if d is the number of digits that is your time complexity usually the number of digits is the same order as log n it's actually log n to the base 10 and being the maximum number in the array number in array so i mean um usually radix sort is a good number to know and good approach to know because this can be applied at multiple places that being said again like not very commonly used because n log n you can just directly use your sort function why would you go and take the pain of implementing radix sort but it has very similar time complexity if all of what we have discussed till now that makes sense i'll give you one problem which will actually make the bucket shot even clearer the reason why we have bucketshot explain the time complexity again so if you look here what do we what are we doing we are taking digit by digit right so first we look at the last digit and for that digit what do we do we put them in these ten buckets right so basically what happens is what is the last digit of any number let's say i i go i basically do this right i say i goes from 0 to n and we calculate the last digit digit is equal to array of i mod 10 that is your last digit and then you put it in the same bucket so for example let's say if you have bucket array you say bucket of digit dot add ai right you do that all of this is order n process for the last digit correct and then eventually i'll put i'll basically look at numbers in every bucket and i'll keep appending them in another array all of this is order n process i'll have to do this for every digit correct so if all numbers have let's say five digits then my complexity would be n into five because for every digit i'll do an order n operation if every number has b digit and it becomes order of n into d how n log n is similar to n into d so n into d makes sense right order of the algorithm is n into d that makes sense correct okay now what is d what is it like given a number x what is the number of digits that x would have how do you find that basically how do you find number of digits you basically divide x by 10 you check if it is 0 yet then you again divide it by 10 further which is 10 part 2 then you divide x by 10 by 3 x by 10 by 4 number 5 and so forth right when x by 10 to the power i is 0 which is like now 10 bar i has become bigger then that is where you have the number of digits okay if i just put it like this i mean basically if x has i digits then x is approximately equal to 10 raised to i approximately which means if i take log 10 on both sides then i basically get i is equal to log of x that you agree so if if there is a number x then x has basically log base 10 x number of digits so therefore i'd say like whatever is the highest number in the array then d is basically log of that highest number so your d is almost the same as n log x x being the highest number so bucket sort is more generic like bucket sort just says hey look my fundamental is you can create any sort of bucket you want you can create a bucket of all numbers from 1 to 100 all numbers from 100 to 1000 all numbers from 2000 to 3000 could create any bucket that you want as long as it covers all range you put numbers in the bucket where you know that every number in bucket one is going to be smaller than every number in bucket two so you just bucketize these numbers you sort them separately and then you append that becomes bucket sort it is very generic radix sort is using bucket sort in one way why this type of bucketing works going for all positions instead of just msb or lsb let's say if you just go for msb there wherever two numbers have different msb most significant digit there i mean you probably can only do with most significant digits the problem is there will be a few numbers that will have the same most significant digit in fact there are only 10 possible most significant digits right so if you have let's say thousand numbers then on average you'll have 100 numbers in every bucket right for example here as well i had 950 and 923 they'll all go to the nine bucket now how to actually decide the ordering between these in fact if you have a lot of numbers in the bucket then how do you figure out the ordering between those that is not clear so therefore you can't decide only based on most significant digit you'll need to somehow sort these guys within the who have the most significant bit as nine as well right internally you'll need to sort them so there are two ways one is like you just say i'll bucket eyes based on the most significant digit and i will sort each bucket right so what happens is if i had n numbers then on average each of the buckets will have n by 10 numbers to sort them i'll take n by 10 log n by 10 and i'll have 10 such buckets so i'll finally multiply by 10 this will give me n log n by 10 which is the same as n log n so i end up reaching the same algorithm which i have anyhow done before this does not seem to be an improvement so therefore i said like can i improve further on it and and there we said maybe if instead of saying that we'll sort the numbers in the same bucket if we could do bucket shot multiple times in a way where at the end of it all of them would have been sorted then that would be nice so i say you know what like for the sorting based on the most significant bit one thing is if i can somehow reach a state where numbers with the same most significant bit they are already sorted in some way that would be awesome but to sort the numbers with the same most significant bit for example if you remove the most significant bit you'll need to sort them by the remaining bits there also if you just again break it down recursively you'll reach the same state like you'll first have to sort based on the least significant bit then the least significant and most significant together and then the last three two together the last four together and so forth uh in radix you have log base 10 of not the number of elements i mean in n log n n is number of elements this is log base 10 x which is the highest element in the array this is not the number of elements this is highest element in array two different things but yeah i mean um in cases of log n if you have let's say 1 million entries 10 6 entries or 10 7 entries the login is typically 20 22 24. in the case of numbers the number of digit is probably still eight or nine so it can perform twice as faster if max is less than and go for radix or that that i wouldn't say if your log of 10 max is less than in fact significantly less than log n then go for static sort okay in case of integer we could use radix that's why i said like if your log of max is less than log of n you could use products that might run just slightly faster even if you go with bits yes you will eventually end up sorting just that the number of iterations will be more all right let's move to the next problem imagine you're given a bunch of numbers which are not sorted by the way let's say you have 5 8 3 1 6 some numbers right and then you've been given this array that you cannot modify so this is a constant array cannot be modified now what you need is that if this array was sorted let's say this array was sorted the numbers would be 1 3 5 6 8. actually let me change the numbers a little bit let's say this number was 7 right if this number was 7 then the numbers would be 1 3 6 7 8 and then in the sorted array if you were to look at adjacent difference the difference here is 2 difference here is 3 difference here is 1 and difference here is 1. there you have to find out what is the maximum gap between the numbers when the array is sorted in this case the maximum gap is 3 so you say the answer is 3. so given an array how do you find this maximum gap if the given array is constant and obviously one answer is you make a copy of this array you sort the array and you look at the adjacent differences and you take the maximum of that which becomes time complexity order of n log n space complexity ordered of n can you do something better than this i'll repeat the question once more you are given an unsorted array the array is not sorted what you have to find is if the array was sorted and if you looked at the adjacent numbers differences what is the maximum difference you can find what is the max gap you can find so let's get started with our today's lecture on linked list linked list is also a very important topic from the interview point of view so to get comfortable with linked list you have to attempt multiple questions because it's tricky to deal with all the pointers sometimes it's confusing but once you start with it and you practice with it it's it's great okay you'll get comfortable so let's get started now why link list why uh have we come to link list so it's like we started with arrays let's talk about ids so why not we continue with arrays so the problem with rs was that if size is fixed right size fixed that's a problem so if i want to insert more elements i have to create a new array with a greater size so that's that's problematic right what else can i do i can basically create a dynamic array instead of that a dynamic array right so in dynamic array what happens so if i have an array of size let's suppose 5 now all of this is filled and if i want to enter one more element what happens is an array gets created double the size of this array so an array of size 10 will get created and all of this will get copied into this newly created array and then we can insert the element that we would want to insert right now the problem with this is that like suppose now i don't want to enter any more elements so this space will get wasted right this space will get wasted and that's that's a problem right wasted of space is also one of the major problem so now we cannot do anything the dynamic array will anyway get twice the bigger of the previous array so that's a problem with dynamic array so here comes the linked list now here comes the linked list okay in linked list what happens is we don't have to reserve any space okay we don't have to reserve any space rather so what happens let's let's see the logical view so this is i am taking as the memory these are the memory cells okay so you will agree with me that an array the elements are stored in contiguous blocks of memory right elements are stored in contiguous blocks of memory so now in case of a linked list this is not the case this is not the case if let's suppose one element is stored over here another can be stored over here the next could have been here then the next could have been here so now if i want to connect to one node with the other node so how to do that so for that case the structure of linked list looks like this that we have a data part and we have an address part okay so this address part will help us to connect one node with the other row okay one node with the other node so let's look at its structure so here i have this node let's say the data is 5 then i have this node let's say the data is 3 then i have this node the data is let's suppose minus 2 then i have this node let's suppose the data is 1. so i can connect this address part of this node with the next loop then the address part of this node with the next node likewise over here and this is empty because no node is after this now in a linked list so basically i want a point from where i can you know start so basically i need something to uh you know traverse the link list or at least have the link list so in that case we should have the pointer to this very first node okay so that's pointed out by head we can have a head pointer which can store the address of the very first node let's suppose its address is 100 then the address of this node is 250 let's say it's lying at 300 let's say it's at 500 so head will store the address of 100 and what do we mean by pointing this pointer out it means that here the address is stored like 250 then here so basically it's like we have address 250 over here then we have 300 over here then we are storing 500 over here and there it's nothing empty so this was pretty basic about linked list now let us see how can we declare a linked list so in c plus plus we can use a structure or a class as well so a structure can be defined as struct then node then so we have this data field as well as this address field so i will let's suppose i want to store integer type so i'm declaring it as inch then int data then we have uh so we will also have a pointer that is this next pointer right so that's how i can declare structure of the linked list like this and in java how can i do that so i can have a class let's say the class name is node then interval node next okay so that's how we can do that so now linked list is a linear data structure linked list is a linear data structure that means we can only traverse the linked list in this fashion we cannot go to any node from in between okay is it clear that by a linked list is known as a linear data structure by this we mean that next is a pointer next is a pointer of type struct node of type stock node because this pointer is going to point to a node right of type this therefore the type of this pointer is struck no so that's how the structure of this uh in the data that's how the structure of the node look like okay the first part the first entries of data and the second is of next pointer that points to the next node of the list okay cool now let's talk about the advantages and disadvantages of using link list so the advantage of linked list is that it has a dynamic size isn't it dynamic size so if i want to insert a node i can simply create it and attach to this node right attached to the last node of the linked list like this right so it has a dynamic size then second point is that there is an ease of insertion ease of insertion and deletion and deletion so if i talk about an arrays if let's suppose i want to delete an element from here then all of these elements i have to shift to one step left isn't it i have to shift them one step left so that's an extra overhead so in linked list we don't have to do any such thing we just have to manipulate the pointers we will come to that part we will see that dry run in a while okay so now let's talk about disadvantages so first disadvantage is that there is no random excess i cannot uh access any node from in between okay any mode from in between the second disadvantage is that we need extra memory for pointers we need extra memory for pointers so whenever whenever you have you already know the size of your data you already know okay i am going to store 10 elements and that's all i need always go for arrays but if you are not sure that how many elements you are going to store how much data you have so go for linked list the third point is that linked lists are not cache friendly okay link lists are not cache friendly i would suggest that give it a read and this is basically quite a big disadvantage of using linked list use uh due to which we prefer arrays okay due to which we prefer arrays okay now let's talk about that how can we you know insert print delete a node in the linked list so let's come to a little bit of code part so as i told you that this is how in c plus plus we can declare we can made a structure of the linked list right let's make functions let's say so void insert that i would want to insert the node in the linked list so i'm making this function then also let's make another function void print so how to insert a node in a linked list so for that first of all we should have a global head pointer okay we should have a head pointer so let me create that so we just need to write this for that now what do we have to do so for inserting a node first we have to create a node of type this so how to do that we will write node star tem is equal to new node and then we have to set this data part so 10 data is equal to x okay this x whatever the user has supplied then also we have to set this next quarter so next is equal to what let's set it for now as null okay let's set it for now as null now what do we do we have to check if the so if let's suppose head is pointing to a null uh so head is none okay it's pointing to nothing so if head is null if head is null let it be like that if head is not null if head is not null this is the case when there already exists a node head is pointing to this node so now what we'll do if head is not null we will set temp next is equal to head right so we have created a new node this is our temp node let's say the data is 5 over here so what we are doing we are setting it next to the head node because head is pointing to this right now okay and we also have to set head to the new head so head is equal to 10 so basically now head will start pointing over this node so this is how it will look like now 5 then 4 is there and head is pointing to this node so this is the case when head is not null but if head is null so in that case we will set head is equal to 10 directly right so now there's this thing that says this is getting repeated in both the cases so what we can do we can simply uh remove this from here and this is how our final code looks okay so this is how we can insert a node in our linked list now if suppose i want to insert one more node i can create it okay i can create it let this be temp so the data is one now i will set its next to head current head and then i will set head to this newly created node so this is how it will look like that we have this 1 then we have 5 then we have 4 and head is pointing to here now so i am inserting at head so this function is for insertion at head okay this is this function is for insertion at head if you have bought the logic of this that how you are manipulating the pointers you can very well insert any node let's say at end or in between as well so if you let's say want to insert an uh a node at end you can go till end and so basically uh this is let's suppose your linked list and you want to insert a node you want to insert a node at end so you can set a temp pointer over here and it rate the linked list till till the next of a node is not null so here as you can see the next of a node is null so we will stop over here now we will make this point to the new node does that make sense that how we can do how we can insert a node at n likewise you can insert a node at so how can you insert a node at somewhere let's say at position third so this is a linked list and you want to insert a node at let's suppose this position so this is a new node that you want to insert over here what you will do you will start reversing from here you will go so k is equal to 3 that means you want to insert a node at third position you will go till second position and you will manipulate the pointers okay so you are over here then you move to the next element and now you are at k minus 2 position so you will simply stop what you will do you will make this point over this so this will point to this now and this will point to this now so this link will break does that make sense that how we can insert a node at any position in between so now let's talk about that how to implement this print function how to implement this print function so what we'll do we will do we will create a temporary node we will create a temporary node so as to iterate the entire linked list we will set this to head we will set this to head okay now we will simply iterate the linked list like this so while this temp is not equal to null we can simply see out the data we can simply print the data of this temp node you can print the data of this temp node and make the temp point to the next of 10 okay next often and this will go on and print the entire linked list so temp will simply start from the beginning and so temp is here first let's suppose so it will print its data then it will move forward it will print its data then it will move forward it will print its data then it will move forward and now you can see that he will simply come out of this while loop because now the temp is none because now the type is none okay language should not be a constraint you should get the logic okay you should get the logic that how we are doing it that's why i'm also taking examples that how pointers will be moved so don't uh really go with the language you can check that how these things are implemented in java but here please try to understand the logic okay okay now uh what do we do so here is our main function so i i can simply call in sort in sort let's say 5 then i call in sort let's say 4 then insert minus 1 then print so this all will do the trick right now all these functions can be called and our link list will look like this so since we are uh inserting at the head so this will be 5 then this will be 4 then here we will have minus 1 and likewise okay so guys now let's do the final this delete function so let me write a pseudo code of it okay i am not writing the c code for that because that's creating confusion let me write simple pseudo code of it so we have this delete function okay and it's taking the head okay so head is already declared as a global variable so we need not do that right we need not do that so what we can do for deleting an element we can create a node of type whatever class or structure we are declaring so we can set this uh node and make it point to it okay so basically you can see it in this diagram that how we are going to delete and hit delete ahead so we will mark so this is head temp is also pointing over here so basically we can do head is equal to head connects so head will come over here and then we can free the step so basically we will do head is equal to head connects does that make sense okay so now let's quickly move on to the questions let's do the questions now okay i would like to discuss some conditions where you know even if people very well know linked list but sometimes they fail at implementing it okay so the manipulation of the pointers and um you know while handling the linked list it becomes uh tricky so therefore a lot of coders stumbles on that so let us see what we can do about it so some conditions are there that we can definitely check after writing our code that the head so we should check if head is null or not okay as in we should check if um that happy handed the case when head is null okay so don't worry as you will proceed through the questions you will get clear of these things as well okay then you should definitely check your code for a single note what if only a single node is present in the linked list then you should definitely check for two three nodes okay so let's say only two three nodes are present in your linked list you should check if your code is working fine in that case or not and always try to think aloud like that's the suggestion for all the questions that you attempt think aloud write on pen and paper and uh think about all the edge cases that can be handled or that needs to be handled so that will help you a lot okay now let's discuss some questions so here we are discussing some questions now we discussed about printing a linked list from the very start till the very end in iterative manner right in iterative manner this is an iterative manner isn't it can we do it using recursion so basically let's say so this is our print function print function this is our head pointer now what we can do as you can see over here this is a linked list and i want to print it using recursion so basically i can simply print the data of this node and now with the with all the rest of the nodes i just have to do the same thing with them so why not using the same function for them so what i can do is i can simply print the data of this head node so then what i can do i can simply call this function again with the next node as the head node so print func now i am basically calling the head door next so this is this dot representation there this arrow representation it's how you reference it's how you refer to these variables so in java you use this dot so basically for in classes while you implement it you basically use this dot and like in structures i told you you use this arrow function okay so will this do the trick is it sufficient is it sufficient or are we missing something out so if your head is equal to null then you simply have to return right you are you cannot do anything about that so simply return from there this is the base condition so uh let me actually first state the question the question next question is that you have to print the linked list in reverse order in reverse order so this is your linked list this is your head pointer now you have to print it like this 2 1 6 4 how can you do it do you have to go at the end or something is it like that or like can you do something about it in a better way so you can have a stack you can have a stack okay so basically you can put this node into this stack or you can also uh simply put the data of this node onto the stack so you can have a stack like this stack in s then you can traverse the uh this linked list using a temporary pointer let's say t so you are here you put this data onto the stack then you move ahead put this date on top of stack put this data on top of stack put this data on top of stack and now the link list is empty so you can simply pop everything up off right so you'll get two one six 4 simple right what's the time complexity of this it's just order of n and the space complexity is also order of n right it's also order of n so you can also do this using recursion right so as you see over here most people have pointed out as well that we can simply reverse their order and that will do the trick that now i don't have to print this node immediately i have to go till the last and then start printing okay and then start printing so what i can do so basically let me simply copy this so what i can do i can simply bring this over here what's the time complexity of this approach again it's order of n and the space complexity is order of n as well because here also we will be using the call stack recursion uses stack so that's uh ideally what are doing here as well so both are same basically right the next question is to print no so what you need to do again so as i told you before that you just need to go till the so just go till kth node and print it that's it right and print it so it's pretty simple let's move forward okay let's move forward now let's say i ask you to print the kth node print the kth node from end so what we can do we can actually see that what's this kth node from start so we have this node let's say i want to delete this third node okay i want to delete this third node from n so what's the value of this what's the what's this node from very start it's nothing but n minus k this will give us these rest of the nodes right these this will give us these rest of the nodes and plus 1 will give us this node so that is from start it's nothing but fourth node but to delete it you will have to reach till this node so that you can connect this pointer over here and remove this does that make sense so you can if you simply have to print it you can simply go till this position but if you let's say have to delete it so you have to go till k minus one if position and connect this okay so let's find the middle of the linked list now middle of the linked list these are the basic questions and if you get hold of them you'll get pretty comfortable with links so try attempting them on your own okay okay how to find the middle element of the linked list okay first the basic approach we can use is that we can find the number of nodes in the link list and simply do the count by two so we can traverse till count by two and return the node does that make sense that that's how we can do it and the second is let's see so we have this head pointer then we have this mid node and we have this end okay let's say i have two pointers so this is a slow pointer and this is a fast pointer this is moving with the speed of 2 twice so 2 into x and this is moving with the speed of just x so if with this pointer if with this fast pointer starting from the very head i reach till end then this pointer will reach where remember that it's twice the speed of this pointer so if i am reaching with this pointer till the very end this pointer will reach over this place and we will find the mid does that make sense that why the slow and pass pointer work so let's quickly write the code for it so mid of linked list so we have this head we will set slow pointer to head we will set past pointer to head then i'll come to the conditions in afterwards let's write this that the fast pointer you know that it will go two steps forward so next next and slow pointer will go only one step forward so sloka next then after coming out of this while loop we can simply return slow car data let's say so in this condition this fast pointer is reaching till end so we will be moving till fast is not equal to null but this is incomplete this is incomplete because here we are jumping two steps forward so we have to make sure this this exists this node exists so we have to check if past connect is also not none okay so what's the time complexity of this so time complexity is just order of n and space complexity is just order of one now let's talk about another question which is to reverse the linked list so how to reverse the link list so we can use stack so uh like i i'm not going into depth of it let's say the nodes are one two three four now you can basically make a stack like this stack of node pointers okay stack of node pointers now you have to you know return what you have to return this four then three then two then one you actually have to reverse the entire linked list okay so you have to take note pointer so you that you can push them so you keep pushing them this is one then two then three then four now you can simply connect them now you can simply remove them one by one and simply connect them okay so this is one way the time complexity of this approach is order of n and spaces order of n as well now can how can we do it using recursion we can do it using recursion right in which it will look like this so we will have a function reverse then head then we will call uh so we have to reverse it right so we will call itself with the next node now here we will perform some operations and here we have to write the base case let's see what to do about that what are the operations first of all so we have this operation to perform now what do we need so let's see it over here this is one two three four so i am here this is my head and if i'm back to here after recursing that means these all this has been this is done they all are reversed they all are reversed and i am back to this after recursion now what do i need to do now what do i need to do i have to set to connect to one isn't it so in place of two can i write head connect connects and in place of one can i simply write head will this be the case after returning from recursion so i can simply write it over here that head car so you can write head car next car next is equal to head and then also what do you need to do you have to make this null you can make this null so head car next is equal to null but this isn't over right so we have something like this now so but we also need the head of this now this is the head basically so this will actually return a start so what we can write over here let's call it last is equal to so this function will return as that i will come to that i will show you the dry run of this uh so we will simply return last at the end but first let us talk about the base case so do you guys agree that first we have to check the condition for null so if head is equal to null and also if there is one node so we don't have to do anything so if head connect is null in that case we can simply return head isn't it return head so this is it that's all the code now let us look through the drive so recursion uses stack so here i have that and i'm using two variables that is head and last so i'll maintain them i'll maintain them now first so this is my linked list so i am here right now so head is at one and uh so last is what whatever we will get from here so be right now i don't have anything okay right now i don't have anything so i have called this function now basically this is my head so next head is equal to 2 and last is still nothing because again we are calling this reverse function chicken so since we are calling it now head becomes this so next head is equal to three and last distance nothing then moving ahead head is equal to 4 [Music] and last is nothing but here as you can see we will actually not go over here since there is only you can see that head is not null but head next is none that means we don't have to go over here we can simply return the head so now this will return and what's the head at this it's 4 so 4 will get return okay 4 will get written now basically we are returned from this now we are back at 3 as the head so uh answer to 3 has been written right so once we have returned from here now we will do this so head connect connects head is our three so we will set this basically head connect next is this so we will set this over here and we will make head connect as null head connects as null now we are we will get back from this and three will so again last from here is it's four only now again we will do head connect next that is three next point two head okay and head connect is null so now we are done with both of them basically we are done with both of them so 4 will basically return so this will basically return 4 over here and this is also gone now we are back at 1 and we will make head connects connects point to it point to head and we will mark head connects as null so what do we have this is also done so last has had what last had code this node has the new head does that make sense guys let me again do it quickly okay let me go through it quickly so this is my linked list my head is here okay head is here so i am at this if condition and my head is not null also the head connects is also not null so i will not go into this if block i am here so i am calling this reverse head again it should be head connect and now basically i am calling reverse and passing 2 in that chicken so i have to store this on stack so head is equal to 1 and last is equal to whatever this will give me as the answer check it now as uh so now basically i am here now a head is not null and also head next is not null so we will go to this block now here head is equal to 2 last is i don't know right last i don't know so basically we are calling reverse head connects that is 3 we are calling this and we are on this now so head is equal to 3 last is equal to we don't know because now whatever we will get from reverse of head connects that is 4 will be will be coming over here so we are calling head connects that is 4 so head connect is 4 now we are over here now as you see that last is not null but head cut next is none it's null so we will simply return this head what is head head is 4 return 4 where to return it where are we returning it we are returning to this last variable so here will come the 4 okay here will come from this is done we are done with that so basically this we are done now we are back from recursion at this space okay so since we are back now it has this value of last it will return this value over here okay now this is also done but before that also what it it will do it will set this that is head come next connect will point over here and head car next will become now we are done with this and back over here now we have got the answer for last okay over here first of all what we'll do we will set head connect next over here right over here and we will make head connect as null so this will return 4 over here and this is also done this is also done now we are back from recursion over here we will set head connect connects that is to connect to one and mark head connects as null so we are back from here as well so this will return four to us so in last variable what we'll have in finally in last variable what we'll have so we will have the address of this node the head node now okay we will have the address of this head node now okay the time complexity of this approach is order of n and the space complexity is order of n can we do it in order of n time and space as order one using pointers okay using pointers approach iterative approach so we have these nodes let's suppose let's see the intuition first let's suppose i am at this node i am at this node now i can what i can do i can make break this link and make this point over here make this point over here but now i will lose the connection from here so i have i need two pointers at least so that is two here and here but i'll also need a third pointer that is over here because this is a one way linked list right how will i set this to this node there is no way so i need three pointers over here so let this be current next and previous so let's see a dry run of that let's see how we can do this so initially previous and next can be null both previous and next are none initially they are empty and current can be set to this one then we can set so if current is not empty if current sorry if current next current connects is not empty so we can set this next node over this node so that we can we do not lose this contact we do not lose this contact now since we have set this up we can set this link to here now what we need to do now this is actually previous will now move here current will move to next okay current will move to next basically got this link now current connect is not null therefore next will now come over here and we will set current connects as 0.2 this link was set up this link was not set up yet okay this link was set up and now we will set current connects to over here okay now we will set current connects to over here then again previous will come over here and current will come over here now again current connect is not null current next is not 1 so we will set next pointer over here and current connect stars over previous over previous okay now again what do we need to do set previous over here current over here now current next is not none so we will set next over here so that we don't lose the next node we don't lose the next one we are setting this now make current connect point over here now previous will come over here next will uh current will come over here now current connects is null right it's null we will be checking actually we will be checking that current is not none okay so since current is not null so we will set the next over here the next over here and mark current connect stars over here and then just like that previous will come over here current will come over here and now current is null now current is null so we don't have anything to uh we don't having have any node now so this previous node is our head now this is our head is the intuition clear that why we are doing this let's quickly write the pseudo code now so you will set current to head and previous next will be null then while current is not equal to null what we did next we'll go to currentconnext currentconnext will go to previous previous will become current and current will become next finally we can simply return uh pre as the previous has the head pointer so the time complexity is the sub of this approach is nothing but order of n and spaces order of 1 right so this is reversing a linked list is a very important problem in the interview with stacks it's easy right with stacks is easy but with these pointers approach and here we have a recursive approach it's little tricky to understand okay this was it guys from my side for today i hope you guys attempt the questions uh provided in today's contest so thank you very much so we will start with the very first bucket so what i have decided that from each bucket i will be doing one question okay let us do the very first question from each of the buckets take it let us start with the palette of list so the question says that we are given a singly linked list and we have to determine if it is a palindrome or not if it is a palindrome return one or basically if you do boolean it is true for one and if it is not a parent room we return a zero so i mean like in boolean false represents zero and true represents one so basically we have to return true or false if we talk in parallel since of a boolean variable rather than an integer okay and the solution that is expected is linear in time and constant in space okay let us assume that hey this time we are given a linked list okay so suppose you were given an array one two three four three two one this is a parent room right how can we find if it is a palindrome we can start a pointer from the left side and similarly a pointer from the right side going towards left and a pointer from left side going towards right at each index we check so for example at the very first stage left will be this width and right will be this is the pointer at left equals to the pointer right right yes it is equal so now that means it satisfies the property we increment a left and we decrement r is the new left and right equal yes they also are equal so we again increment l and we again decrement r they are also equal then we increment l and we decrement r this time l will be equal to r so i mean like l and r both will be together okay so at this stage we can stop because this is a central point okay so if it had been an array we could have done something like this and l equals to 0 and r equals to n minus 1 while l less than r if a l not equal to a r uh returns false else we do plus plus l minus minus r and when we are out of the loop we can just return true that means that the array was sorted but this thing doesn't work well for a linked list why doesn't this work well for a linked list because in a linked list we don't have render misses we can't directly assess this number and this number similarly a singly linked list doesn't allow you to go backward side it only allows you to go the next side okay so this is why we can't use exact same approach for the linked list okay but now let us see this that let us say this was a linked list okay also reverse this link list what will happen if we reverse this linked list as well then the reverse of this linked list will also be 1 2 3 4 3 2 1 right so we can see that for a palindrome the linked list and the reverse of the linked list is equal okay so i mean like if we are somehow able to reverse a linked list we can find if a linked list is palindrome or not okay now the question comes how will we reverse a linked list okay let us see how we can reverse a linked list okay so linked list is something like this 1 is pointing to 2 2 is pointing to 3 uh 3 is pointed to four which is pointed to three which is pointing to two and finally this is pointing to one okay now suppose at every iteration we are maintaining three pointers this is the previous pointer uh this is the previous pointer this is the now pointer and this is the next pointer now what we see that in the reverse of the linked list now her next will be what was previous element and uh next so basically now next will be the previous element okay now let us do exact same thing let us let us try to use this approach to uh reverse the linked list okay so now if we somehow are able to reverse the linked list and how to reverse the linked list we already know then we will be able to what we will say then we will be able to find if a linked list is palindrome or not okay now from what index should we reverse actually we should reverse only this part of the linked list right because if it reverse this part of the linked list this will change to 1 2 3 and whatever that comes after this doesn't matter to us we will keep on comparing each element so 1 is equal to 1 okay 2 is equal to 2 and 3 is equal to 3 and we are done okay so we will reverse the part of the linked list that comes after the middle element okay let us do that so the question first question comes out is first we have to find the middle element okay then the second thing is reverse the list after the middle element okay and then we have to compare corresponding elements in the first half and reverse of second half okay now let us do this step one by one so how will we find the middle element so i mean like if you have not heard of this approach this is known as here and totals approach okay what a here in total's approach is that we maintain two pointers on the linked list initially the first pointer is here as well as the second pointer is here one pointer moves faster actually at the double speed of the second pointer okay so at the next step the first pointer will go here the second pointer will be here then in the third step first pointer will be here second pointer will be here then first pointer will be here and second pointer will be here so as soon as one of the pointers reaches the end of the linked list that means the other pointer will be at the half position of the linked list okay so i mean you can read about this after this session if you are hearing this approach for the very first time but let us do that we say list node value at toto is i mean you should actually not uh take these variables you should say slow which is initially a and you should also say fast which is equal to a chicken so while fast not equals to null and fast next not equal to null so we move this slow pointer by one step slow is equal to slow connects but we move fast pointer by two steps fast is equal to fast connects for next okay now when the fast will be null so when the fast will be done that will be a situation like this let us say this is a linked list so in this case initially slow will be here and fast will be here then fast will go here and slow will go here then fast will go here and slow will be here so when the fast is null at that time slow is pointing to the first element of the second half of the linked list right okay but let us take a case when the linked list is of odd size one two three four five in this case initially slow is here fast is here then fast goes here slow goes here and fast goes here and slow is here at this point slow is pointing to the first to the exactly middle element okay and we have to reverse the second part i'm like just after the middle element okay so we will say if passed not equal to null slow is equal to slope or next now we are sure that the element slow is pointing to the very first element of the uh what we say linked at the very first element of the second half of the linked list okay awesome but anyways we will have to do wait a second so if first not equal to null second is equal to second for next okay that's it and always we have to set this slow connect equals to none now we reverse the two linked list sorry now reverse the linked list that starts at second okay how will we do that we say list not so this is also a very good technique that you should choose whenever you are solving a linked list problem by solving a linked list problem you maintain a dummy head okay which is node that contains only zero so initially the previous will be dummy the current will be the very first node which is a and next will be nothing so we will say file now not equal to null next is equal to now for next okay then now connext is what now for next is the node that was the just previous node okay so actually we can actually initially take previous as null so that will also work for this okay now connect is equal to previous and now what is the previous now previous is equal to now clear okay so now we have done this at the end the previous node will represent the head of the new list because at the end previous will point to the node 4 which is the new start of the list that comes at the second half okay so now we know this so we will say while your first pointer is at a and the second pointer is at previous we will say while first pointer not equal to null and second pointer not equal to null if first pointer value is not equal to second pointer q value uh return false and we save pointer equals to first pointer connects and second pointer equals to second point of the next finally if we are out that means we can return that means the whole list was a palindrome that's the same correct let us test it okay so actually we did a time limit exceeded so basically we entered in some kind of a loop right let us see where we did wrong okay so we should do this here otherwise always something like this right let us see if we can test it so we are saying why if fast not equals to noise second is equal to second connects okay and we are setting the slow connects to null slow is the previous element so in this case in the very first case we saw that when fast was null slow was pointed to the first element so we also need to know actually the previous so we also need to know the previous slow slow which will be initially null and we will say previous low is equal to 0 okay so uh okay in this case when the array size is given initially slow will be here and fast will be here okay then slow goes here fast goes here slow goes here fast goes here in this case previous slope and x should be null okay else else previous low or next should be equal to null and second is nothing but slow okay okay but in the case of odd slow will point to the very first element so second is equal to slope next okay second is equal to slope next and we set slope on x equals to none okay now does this look good this looks good and so here we are taking the list basically into two parts and then let us see that if we can actually test it first latest testing custom input okay we are not changing now to next right previous is now but now is also next so we have to do this okay and now this will work yep so but this case it should return one right so in the case of one two one uh slow will be here and fast will be here then fast goes here and slow comes here so in this case what is the start of the next this is one so we will say that you have to reverse the list that starts a second so we have to reverse this thing right while now is not equal to null now is actually not a we are reversing the first list now is second yeah now this is okay yes and let us submit it are we missing an x case i think yes we probably are missing the edge case where all the elements are null one advice for any kind of linked list question make sure that you never end up assessing a null element that is actually a very big mistake that many people do okay always ensure that the pointer that you are assessing in a linked list is not null so that is one of the biggest mistakes i have seen many people doing that in linked list questions okay cool so we are done with the very first question so here we learned two techniques the one was the hair and tortoise approach and the second thing was how to reverse a link so basically this is a combination of two questions let us do a question in this pointer now so let us say that we are doing swap list nodes and pairs okay because k reverse linked list is just same as a normal english question normal reversal is question okay let us say that we are uh solving this question that is swap list nodes in pair okay so we are given a basically linked list and we have to swap one and two then we have to swap three and four so basically one and two will become two and one then we are done with this particular part now we are taking the care of the part three and four we again swap it which becomes four and three okay and we are asked that hey we have to use only constant extra space so basically we can't create a new linked list but what is meant by a constant extra space uh question is normally that what we mean by a constant extra space in linked list is that you don't have to create a duplicate node you have to use the nodes that were given in the initial question itself taken okay anyways let us try to see how we can do this so basically linked list is nothing but a game of pointers how you are able to mingle pointers is how you will win the game so let us say that we have one two three and four okay so now suppose i have to reverse this link list i told that in the previous question as well that dummy head is a very common and helpful technique in solving any kind of linked list question okay so for example here what i will say i will assume that there is a dummy node here after which it is one after which it is two and three and four okay so now see suppose i am reversing the pair of four and three i at least need the pointer to four and also the pointer to three okay but i also need the pointer to 2 why because when i have reversed these two i have to make sure that 2 connects points to 4 okay so we at least need three pointers okay so let me first create a dummy node let me name this pointer let us say that when we were swapping 3 and 4 let me name the variable 2 the variable that stores the node 2 as the previous pair end okay so let me say list node value at previous pair end initially it will be dummy right because this is the end of the first pair this is our assumption okay so this will be dummy okay this will be equal to the current pair start okay so this is current pair start okay which is end of k so first in the first case this will be the node a itself chicken awesome okay so while i will say that while the start of current pair is not null part not equal to null okay so i will say current payer second is equal to okay i i let me also assume that current prior start next is also not equal to nine is not equal to null okay so current pair uh start the next so basically both the nodes of the current pair exist okay if if there is only one node we don't need to do any swap right so i will say current per second is equal to current pair start connex okay i also know the previous pair end at the end of the current iteration what will be the previous pair end previous pair end at the end of current iteration will be the starting node of the current pair because the at at this time let us say this was the start and this was the end okay so after this this will change to four and three so basically this will be the previous pair end so which is the current start node okay okay and we also have to make sure that current pair cost second so basically previous pair end connects is equal to current pair second now has to point to four okay and current pair second connects is current pair so now we have make sure that two points to four four points to three okay and finally we have to make sure that three points to this okay current point start current pair start for next should be equal to what is currently the current player second connects okay finally into the current pair techniques and this is previous player n okay and finally i can just return dummy next okay because dummy was just an a node that we assumed okay so now in this case dummy connects will become so the pointers will change like this right and one will now point to three and dummy connects will point to two so the mechanics will actually be two which is the start of the next list let us see if that is correct or not we might have done some errors but let us see hopefully not what did i do oh i didn't comment here what are we doing here so we are saying that initially we actually made sure that dummy connects should be equal to a okay because dummy is going to point to one right that i told earlier like initially dummy should point to one and one should point to so i didn't point it only to first one now let us test this zero okay and i say first point of previous pair end is dummy okay and current pair start is a okay while current player start is not equal to null and current player start connect is not equal to none okay both are not equal to 9 so then current pair second is current sphere start the next okay we change the previous pair and connect to current pair second okay so now dummy node is starting to point to 2 then we make sure we point one for next equals to three okay so now dummy node is pointing to two and one is pointing to three okay now we should point two to one so current to a second connects that is two is now going to point to 1 okay and previous pair end will be equal to 1 that is fine so this thing is fine and what will be current pair start okay so now we have not changed current pair start if previous pointer n not equal to 9 uh current pair start is equal to previous pointer next else currently start is equal to null similarly if current start is not equal to noise then uh okay so we don't have to do that so we only need currently a star and we are done so now 2834 is changed to 34.28 48.74 is changed to 74.48 similarly 40 to 49 is changed to 49.42 and we are doing well let us see if we have seems fine great so we got this as well so one so what thing we learned from this thing the takeaway should be that hey for any linked list question first try to find what are the pointers that you need to know to reorder the list in any way suppose it is swapping pair what are the elements you need to know so that you can change their pointers to something else that is the very first thing you need to know and the second thing is again i tell you to know is this dummy thing this is very important in a lot of linked list questions i will do one more question after this that will use this thing and the third thing is make sure that you are never assessing null okay so here also i do a check of null make sure you are never assessing something that is null okay cool let us do one more question so the question is we are given a simply link singly linked list l0 l1 ln minus 1 to ln okay and we have to reorder this to l0 ln okay so the very first node from this start and the very first node from the end then the very second node from the start and the second node from the end third node from the start third node from the end and so on okay and we must do this in place without altering the nodes values so what in place means is that you don't have to change their values i mean like you can dangle some pointers but that will work okay you just don't have to change the node values or create a duplicate of those nodes that is the only requirement okay so one thing that i find from here is that hey if we somehow let us say that this was our list okay a list was 1 2 3 4 5 and 6 we have to change this to 1 6 2 5 3 and 4 right suppose i know the first half of the list i also know the second half of the list which is uh four five six okay now i reverse the second part of the list this is six five four now what i do i keep on merging this first this is one so i will put this one then i put this six then i put this two then i put five and so on right okay so how can we do that is first split the list in two halves then reverse the second half okay and finally merge two lists this is something that you do this is something very similar to that you do in a question like merge sort right in merge sort the merge step is something like this okay let us do these steps one by one in the previous question we had discussed an approach to split the list in two halves and reverse the second half right we had discussed that in the very first question for the day okay so let us do that so how did we do that we do this question by using two pointers the slow and the start second so initially the slow pointer is equal to a and the first pointer is also equal to then we do files by fast not equal to 9 and fast for next not equal to null flow is equal to super next and fast is equal to fast connects connects so now there were two cases the first case was if fast not equal to null when did that case happen let me redraw it again that case happened when the linked list was of odd size one two three four five so in this case slow will be here and fast will be here slow changes to this fast changes to this slow changes to this fast changes to this in this case fast is not equal to null right okay in this case we can sort we can reverse this whole linked list so this will change to uh 1 2 will remain as it is and this will change to five four three suppose we are able to do that then we can do the merging right or not yes you can do that so it will be equal yes okay okay if the size of the linked list is even then it will be one two three and four then slow will be here and fast will be here uh then slow goes this fast goes this snowball space and fast versus then also we can reverse the linkage that starts at start so that we could do even in the previous question i missed this thing so we can reverse the linked list that just starts at the slow point okay so suppose we reverse this part of the linked list then we are cool let us say let us see how we will do that so we have to make sure that we make sure that the pointer of 2 is now the next of two is null so that these two lists break off right as anything can happen so we will say list node value at previous low is equal to null and previous flow will be equal to slow so finally we can say previous row for next is null so at this point we have broken the list into two halves such that slow points to head of second half okay uh great so now let us reverse the linked list that starts at this slow pointer okay so basically reverse this 345 to 543 so we will say list node value at previous is null list node value at current is equal to slow and list node value at next this variable we will need we will say that file current is not equal to null that means there is still a node here so while current is not equal to null i will say next is equal to current for next and i said current next is equal to previous finally i change previous equals to current and what is the next current the next current is the node that was currently stored in the variable next okay great so now this has reversed the linked list r345 to 543 at the end the node 5 will be the previous node so we can say that list node value at second head is equal to previous now we do we will have to just merge both the linked list right so we will say while a not equal to null sorry yes for this also we will need a dummy node then then we will need a pointer to the current index in the answer so this node value at dummy pointer initially it will be equal to dummy okay we also know need a pointer which will be initially a and we also need the pointer to the second half right so this will be second head so we say that while a pointer not equal to null and second pointer not equal to knight okay so while both of these are not null we first append the second thing to this i mean like then we append but we say we have to first append the node at a point right so we say dummy pointer connects is equal to a pointer okay then dummy pointer equals to dummy pointer next finally dummy pointer connects uh okay and a pointer is also equal to a pointer next then dummy pointer also moves to one step ahead we change dummy pointer connects is equal to p pointer or the node that b pointer points to okay and then we say b pointer is equal to b pointer connects okay great so now what will be we have having is suppose for a linked list of odd size we will be having something like this 1 5 2 4 okay but at this time the pointer to the second pointer the second quarter will be will not be null but the first pointer will be null so we say if pointer is not equal to null that meant that the total number of nodes were odd so we will say bp again okay dp connects is equal to uh what we say the second pointer okay okay so db then x is the second pointer and finally we have reached the end so we don't need to do anything we can uh so yep we are done now but where is the answer the answer is the dummy head connects right because dummy head connects is storing the very first node in the answer so we can just do return dummy pointer next sorry dummy head connects uh like this dummy connext let us see if this works what is this happening this is returning dummy pointer connects what is the dummy pointer the next initially this is the first pointer but the first pointer is null initially the second pointer is also a so the second pointer will still point to this so second quarter will not be equal to that so this should be correct right so let us see why this particular case is having issues okay so in this case we won't ever go here so if we don't ever go here that means that there was only one node right that will happen only if there was less than two nodes so we can say if previous low is equal to null we can just return the original linked list why because this thing will happen i mean like previous slow will be equal to null only if there are zero nodes or one node in that case we don't need to do anything and we can just return the original linked list itself so now this should work yeah are there any other cases that you understand no yes and let us submit it great uh so yes in this thing we missed checking for null one time and we again ended up with an issue so that is why i was saying that never get to a situation where you are not checking for nulls okay and also again you saw that what is the use of wpointer dummy pointer allows us to improve the code quality by not checking for nulls in the initial previous okay so use this technique as well let us do one more question and then we will end let us do this list cycle question because this also requires knowing a technique that many people might not know so let us do this okay so we are saying is told that we are given a linked list we have to return the node where the cycle begins okay the link is mined or might not have a cycle but if there is a cycle we have to return the node the first nodes from the start where the cycle actually started so for example if we start reversing this linked list like this the node 3 is the very first node where the cycle begin right so we have to return the node 3 okay great so let us see how we will do that so see we once found a middle of the link list right we were once able to find the middle of a linked list using the previous approach right if you see the hash approach hash approach has a time has a space complexity of order of n right so we have to do something that has space complexity of order of 1 but time complexity of order of n let us do that so we remember that hey we were able to find the middle of a linked list using the hair and totals approach but if the linked list has a cycle will we ever be able to find the middle no right because fast will never be equal to null so if we start going from 1 2 three four then we will keep on coming back to three four three four so if we were supposed finding this thing uh value at slow is a fast is also a we say five fast is not equal to noise and fast connects not equal to uh fast is equal to fast connect and slow is equal to okay but for when there is a cycle in the linked list this loop will never end okay because it will again going on circle around so let us say what will happen okay suppose the loop is circling around and currently let us say this is the case so this is a linked list one two three four okay okay and suppose all these nodes are in a cycle suppose all these nodes are in a cycle okay it might happen that currently fast is here and slow is here okay that means in the next iteration fast fill co uh what we say at this place and where will slogo slow will also come at this place okay so okay that is the case one the case two is let us say fast and slow are very much behind okay let us say initially the fast was here and slow was here okay then what is going to happen in the next iteration is in the next iteration fast is going to come here and slow is going to go here now this condition is again same as this condition right the condition that we had here so we can say that if fast and slow pointers are in a cycle that means they are definitely going to meet at some time okay so we can say while fast not equal to null and fast connects not equal to null okay if fast is equal equal to null this means that there is a cycle right this means there is a cycle so we can break so here we can say that if fast is not equal to null or and fast connects not equal to null or fast connects not equal to null so let me say that i cycle is equal to false if we enter in this loop we will say that cycle is equal to 2 that means there is a cycle in this current thing okay so if there is a cycle now that now the question comes how will we find the start of the cycle but let us solve the case if there is no cycle if there is a no cycle we can just return null right now let us see how we will find this start of this cycle okay so let us say our cycle is like this there are nodes one two three four five six seven and this seven is pointing to let us say four okay so 7 is pointing to 4 something like this so suppose 7 is pointing to 4 that means this is a cycle okay great so now how will we find that 4 is the start of the cycle how will we be able to do that let us see suppose assume that this size the size of the linked list before the start of cycle was a okay and currently uh both these slow and fast pointers will be traversing four five six seven again four five six seven and so on right okay so now we know that this is so now somewhere inside this linked list will both these nodes made need suppose both the fast and slow meet at this particular place okay and let us assume that from the node start from the node star this distance was b okay so a uh was the distance of start of cycle from head and e was the distance of meeting from the current node distance of meeting from the uh from the start of cycle okay and let us say we also have a variable c which is the start of cycle which is the size of cycle okay okay now can there be any formula between a b and c fast will not become null when there is a cycle that we have assumed so basically that is why at this particular position if fast fast is equal equal to slow we are saying that there is a circuit okay so now let us try to see of one more thing we say that hey this size was a okay this size suppose the nodes met at node 5 this was this size was b and this size is c can there be a relationship between a b and c let us see in this way suppose the fast and slow pointer had traveled this node x times this cycle x times when they were inside the cycle because they were they will keep on circling around right okay suppose they had traveled x times so the total distance travelled by slow total distance travelled by slow will be equal to this which is a plus the number of times they traverse this cycle what will be the number of times let us say they travel this n times and what is the size of this state travel the size of cycle is c so plus n times c and they met at this okay so what is this distance this is b so this will be the distance covered by the slow node correct okay and what will be the distance covered by fast node the distance covered by fast node is nothing but two times the distance covered by slow node but how many iterations would it have done how many iterations would the fast pointer would have turned suppose past pointer did y iterations okay slow pointer had done x iterations and let us say fast pointer had done y iteration so the distance covered by the first point is going to be a so this is n let us say this is m okay so a plus m into c plus b right that means a plus m into c plus b is equal to 2 times a plus n into c plus p is that clear okay from these two equations we can find that we'll be able to find that uh what will be the [Music] the equation will come out to be that hey what is the distance from a plus b okay okay so if we try to expand this equation this will become a plus m into c so let us try to expand the right hand side first this is equal to 2 into a plus 2 into n into c plus 2 into b okay if we take b to the left side so this will become a minus 2 into b and also bring this 8 minus 2 into a plus b right so okay so this is going to be equal to 2 into n into c minus m into c right okay so what we get from this is that uh this is nothing but equal to minus of this is equal to minus a minus b and the right hand side is equal to c into 2 into n minus m right okay but what we find from this this means a plus b a negative is equal to uh is equal to c times something but what is c we see that c is the size of cycle so basically we find that hey the distance from a to b so basically this distance is actually going to be a multiple of the size of cycle right so if we again start a pointer from this particular position and we again so basically till this time this goes till here the pointer that will be at this place will actually come to four again why because it will go from five to six to seven to again four and by the time the another pointer if we start from one will also reach to four and four is going to be the start of cycle chicken so what we can do is we can start we can again put slow is equal to what we say a and we say while slow is not equal to fast this time we will move both the pointers by only one movement okay so we will say slow is equal to slope or next and fast is equal to fast connects okay now that means okay that means now where they have met that is nothing but this start of the linked list start of the cycle so we can just return slow so and this thing should work what happened okay so we will actually have to start with okay so this thing will be actually initially true but at least we have to move fast and slow once they will otherwise always be true like this and it is submit great so we did one more question and today our street points are equal to 1685 cool so that's all for today make sure to complete your streak as well okay bye bye okay so today we are going to cover stacks so let me give you first a little introduction about stack so first of all uh the stack is very much important it's the most favorite topic of the interviewers be well versed with this topic like first go through the basics understand it because they're very straightforward and then attempt as many questions as you can there are some you know a standard problems that you should definitely attempt that was the just about starts now let's get started cool so uh stack is very much similar to the stack of objects you see around yourself so be it stack of plates stack of books so stack of plate stack of books then stack off let's say bowels so you see it and use it every day right so let me draw the stack of plate so this is how a stack of plates look like now from the stack of plate you can insert a plate only from this end that is top right you can only insert a plate on top and you can only remove a plate from top you cannot insert or remove a plate from in between because that will disturb all the plates right so you cannot do that you can only remove and insert a plate only from top so that's essentially the idea behind staff that we can only insert an item from top and we can only remove an item from top okay so conceptually or logically you can think of a stack like this where one end is open and three ends are closed so from only this end we are going to perform operations that is to remove an item and to insert an item as i was saying that we can only insert an element from one end and remove an element from that end only and therefore stack is known as lifo data structure that is the last as you can see the stack of plates over here so this plate which was inserted at the variant will be the first one to come out that is last in first out okay cool so first what we are going to do we are going to understand stack as an abstract data structure that is adt abstract data structure what do we mean by abstract data structure in which the implementation details are hidden but the operations are given to us okay so let me write it over here that implementation hidden okay it's it's not there it's not given but only the operations are there only the operations are there with which using which we can use the stack okay so uh for example you can see the fan on top of you right so you you can you don't know how it's working internally all you care about it's operation as in you uh put on it down the switch and it turns on and you put off the switch and it turns off that's what you care about so that's an abstract cool so we are given let us understand the basic operations that are available with stack okay so there are four basic operations the first one i'm sure you guys if you know about stack you must know about all these operations so that is push function and then second is pop the third is top and the fourth is is empty okay so the push operation actually helps us to push an element on the top of stack so this pushes this element on top of stack then here we have pop so pop removes an element from top of stack then we have top so it returns the element present on top of stack so whatever element is present on top of stack it just simply returns it okay so don't worry we are going to see an example over here is empty is the function that tells us if the stack is empty so if the stack is empty it returns true else it returns false okay so these are the four operations that is push pop talk and is empty push pushes the element on top of stack pop removes an element from top of stack top tells what is on top of stack and is empty returns true if stack is empty as it returns false remember that cop simply removes an element and top does not remove an element it simply tells what is present on top of stack is it clear now okay so basically by performing a question you will have to use in c plus let's say uh you you can use stl right in stl you have stack so in c plus plus you declare a stack like this you can use a stack like this and on this object basically you can call all these functions so push x then s dot pop and so on likewise in java you have collections using which you can use stack so while attempting a question you don't have to implement a stack of your own until and unless told okay so but in a while we are also going to see how to implement a stack we are going to actually implement these operations okay cool okay so let's actually see a dry run of these functions so here this is a stack and uh these are the operations that i would want to perform push to push one push minus one push five then pop pop is empty top so let's perform these functions okay so it's push 2 so what we'll do from where we'll put it we'll put it from here so basically 2 will come over here then it's push 1 so 1 will come over here then minus 1 minus 1 will come over here then there is 5 5 will come over here then we are popping so 5 will be gone right 5 will be gone so we have removed 5 now again pop is there so minus 1 1 will be gone so we have removed minus 1 okay then we are checking is the stack empty what will it return what will this return it will return false because the stack is not empty right the stack is not empty okay so now there is our top so what will be the top function return it will return whatever is present on top of stack so basically top is pointing over here so whatever is on top of stack it will return that so it will return one right it will return one so that was a simple dry run of the of how can we use these operations okay how these operations work now let us come to the applications of stack which are very important applications of stack so some of the applications are undo redo undo redo then we have arithmetic arithmetic expression evaluation right then we have a recursion so these are some of the then we have string reversal and so on so these are some of the applications of staff which are very important and you must know so try to uh figure out that how how a stack can be used in these operations you know that's an activity for you that do try to search that how we can perform an undo redo so this is actually present in your browser right so whenever you uh go to any page from any page and want to come back so basically you store for example let me give you an example so you you are at link let's say one then you go to link two then you go to link three and you want to come back to link two so what you can do you can actually maintain a stack of them so like first you are on link one you can put it on a stack link one then you are going to link two so put it on top of stack then you are going to link 3 then put it on top of stack now you want to come back to link 2 so what you can do you can simply remove this and now you are back to link to does that make sense so likewise you can also have a redo stack okay so that's that's an activity for you that how you can perform a redo operation okay so likewise try to figure out and uh we have arithmetic expression evaluation so i think you all must be very much familiar with this that is you know converting to infix to prefix or postfix then evaluating the postfix notation so that's where you can use stacks okay and then you have recursion stack is a core of recursion so you make function calls and when you come back so that basically those function calls get stored on top of stack okay likewise string reversal okay so there's another application that you may be using in your daily life you must have seen this in shorts app right so what happens in this you are on this screen okay and so here i am actually at my feed i am at my feed okay and i am uh watching this news so i can only uh see another news if i remove it if i remove this so can you see that how this is this is an implementation of stack right guys now let's talk about the implementation of stack so uh could you guys tell me how can we implement a stack so using arrays second is using linked list okay so how can we implement a stack using arrays so basically let's see so we can have an array so size of the array is so arrays a in a and size of the array is 7. okay so what we can do so let's say i want to push 2 push three push minus one pop push seven pop let's see how can we implement these operations using stack okay so what we can do basically we can actually uh you know enforce that one end of the stack will be there to perform all the operation so you can imagine it like we are pushing the elements from here and removing the elements from here so let's say i want to push 2 so 2 comes over here now you can also maintain our top variable which is right now pointing over here that means what is on top of stack 2 is on top of stack then we have push 3 so what we can do we can simply increment this top variable and push 3 in here then push minus 1 so we can simply increment this top variable and push minus 1 now how to pop it how can we pop it top minus minus so basically we are now at uh index one and we have uh so basically minus one is gone okay then uh we are so this was done then we are at seven so again we can increment the value of top and seven comes over here now again pops coming so we can come over here and this is gone so basically that's how we can operate a stack using arrays okay and now can someone tell me the problem of stacks so problems of stack are which are very important if let's say an interviewer asks you to implement a stack using arrays or link list so if i talk about arrays then we have problems overflow and underflow let's say i want to push 1 4 0 5 6 these are the items that i would want to push so one comes over here then four comes over here then zero comes then five comes then six comes and now i would also want to insert let's say -1 so as you can see as i move my pointer forward there is no space because array has a fixed space right so i cannot insert any more element and that leads to the condition of overflow okay and that's it's very important so if interviewer has asked you it's if he's basically maybe judging you that will you cover these cases or not okay so this is the thing so how can you handle it so basically here you have mentioned a size right you can keep a check that if size so if top is equal to the size minus one so in that case that's an overflow you cannot insert any more elements so that's a drawback of arrays and to overcome that basically you can use something known as dynamic arrays okay you can use something known as dynamic arrays okay now let's say i want to pop i am calling pop seven times okay so basically this is gone this is gone third time fourth time fifth time sixth time and seventh time and now i am again calling so now what will happen will i be able to pop any more element no i will not be able to pop any more element because the stack is empty so if i attempt to do so that will lead to under flow condition that will lead to underflow condition so how can you make it all right basically you can put a check that if a top so if top is equal to let's say minus 1 then print under flow and simply return so that's how you can manage underflow and overflow condition does that make sense guys under flow is when you are trying to pop an element when there doesn't exist when you are popping an element when there is no element so how will you be able to pop will you be able to pop no right so that's the case of underflow so you can manage the case of underflow by checking that if top is equal to minus 1 that means you have no element so you simply print underflow and return cool so let's talk about linked list so in linked list what you can do is so you have nodes in linked list where this is the data part and this is the address part so basically the nodes of the linked list can be present anywhere in the memory right on like carrying you don't have everything in a contiguous manner everything is scattered every node is scattered in linked list basically if you have this as a memory so if let's say one node is present over here another node can be present over here okay third node can be present over here so basically this address field actually links node so basically this will be linked to let's say this then this is getting linked to this and so on that's how we store data in linked list so basically uh let's say or you have two and one right now then you want to insert you want to push let's say seven so how you can do right now top is here so at what position if you so you are actually remember you are actually implementing stack using linked list where would you want to insert this node this is your linked list this is what you are building this is the temp node current node that you new node that you are going to insert into your linked list so where will you insert it that we can actually put it it on top of head so now we can actually make this its next pointer point over here so this is how our stack would look like now top will be over here okay so you can in case of a linked list you can imagine a stack like this that like this it's growing right like this is it's throwing and when you want to pop an element so basically you can actually shift this top to the next position and this will be so basically you can free up this space okay so that's how you can implement a stack using linked list now with linked list the cons is of space a lot of space is used in linked list okay so basically uh you are storing pointers as well that will take a lot of space and pros of both stack and cons is that you will be able to perform push and pop operation in just order of one time complexity okay in just order of one time complexity okay cool let's get to the question okay so the first question that we have is of very much famous question and very much asked question it's a valid parenthesis okay valid parenthesis so the question says that you are given brackets the round brackets okay and you have to tell whether the parent pieces are balanced or not let's say uh you are you know uh building this compiler in which you will be writing your code right so basically you will be uh you want your compiler to check verify all code so in that case you will definitely want how can we check if the bracket are valid or not so how can we do that let's see first of all let me give you some examples let me write down the examples okay so what do you say about the very first parenthesis what do you say about the very first parenthesis are these set balanced is it balanced yes it is balanced because a corresponding opening bracket has the corresponding closing bracket so yes it's balanced then if i talk about this is it balanced no it's not because this is complete they are balanced but here this opening parenthesis is lacking a closing parenthesis or you can also say that this parenthesis is lacking a closing parenthesis so this is not balanced this is not managed likewise for this so this is lacking an opening bracket or you can also say that this is lacking an opening bracket so this is also not balanced okay so you have to basically tell are the parent pieces balanced or not let's say we want to attempt this question without stop can anyone think of something okay so let me first actually put some observations let's do the question step by step okay let's do the question step by step so observations are the first observation is that can an opening bracket make a string invalid as in let's say i'm traversing the string and i find an opening bracket so can that opening bracket make the string invalid well it depends upon the future it depends upon the future that if i have this opening bracket maybe in future i'll i'll find a closing bracket and that will be valid or let's say i don't find the corresponding closing bracket in that case it will be invalid so it totally depends it totally depends if i get an opening bracket okay now if i talk about a closing bracket so what about what about a closing bracket can a closing bracket be a problem to us if we encounter it well so if till now for a closing bracket there was no opening bracket in that case yes it is a problem because even if we move any further the string that is given to us will not be valid in any case right in any case so so basically let's actually so okay let's let's take look at uh look at it like this so i have something like this so what will happen let it be like this so i'm not here i will maintain what i can do i can maintain a left and right count which can be initialized to zero now i am at an opening bracket so that means left actually tells of opening bracket and right tells the count of a closing bracket so i found an opening bracket this becomes one and so let this be the thing let this be the bracket now i am here now i am here so what i can do i can simply decrement the value of this and that will tell us that we have we actually found a match for an opening bracket we actually found a match for an opening bracket so we can actually set this to zero right now let's say i have a string like this what will happen what will happen that i am here left and right so basically i have left one then i have a closing bracket so initially both are zero so now this is a closing bracket so is left greater than 0 yes it is that means there is an opening bracket so we can simply decrement it telling that we have found a match now next we go to the next character this is a closing bracket okay so what's the value of left it's 0 that means there's no opening bracket in that case we will simply return that it's invalid because at this point there is no use to move any forward because this closing bracket does not have a matching opening bracket so we can simply return from here does that make sense to everyone okay so whosoever is saying that can we count the number of opening bracket and the closing bracket guys we cannot simply count the number of closing bracket or opening bracket okay let's take an example of that let's say i have this as a string so now left is equal to 2 right is equal to 2 but are they valid are they valid no they are not valid because they are not placed in the correct order therefore this is not a right approach is that cool the time complexity of the approach is what what's the time complexity of the approach so if we have this case here the number of opening blacks closing brackets are two number of opening brackets are 2 so are they valid no they are not valid so this is wrong this way is wrong so what's the time complexity guys time complexity is just order of length of the string because we are iterating the string just once and what's the space complexity just order of one we have not used any space okay we have not used any space now let me make a question little trickier now let's say i have brackets these these and these so this is an extension of the question extension a question come now i'm saying that i have these three sets of parenthesis now i have to tell basically uh my string can contain d6 so i have to tell if those are valid or not let's take an example examples can be this this this then we have this so this will be given to you now you have to tell are they valid or not now can you how can you do it how can you do it so whenever in the interview you're you're telling the interviewer that okay we can use stack for this but she or he already knows right you have to get to it like how what's the intuition so that's is uh very important okay uh some of you are saying that we can use three variables uh so that that will be wrong because then you won't be able to actually find the order you cannot judge the order by taking the that many variables so first of all i am sure that you guys understand that it cannot happen by taking just the left count and the right count because if okay so first of all let's take the example of this now here left is one left is one okay and now i find an uh closing bracket but here they are not same right so this will not work having left and right is a bad idea now taking three variables so here i have this string so if i take three variables uh let's say round or let me write first bracket second bracket third bracket now here the first type so this is type one type two type three first third the left is one okay first right so we have found a right bracket and this manages to be zero then we have third car right so this becomes zero but is this valid no it's not valid because the order is different order doesn't match so therefore that's a bad choice does that make sense you should have a clear idea that why your question is why your approach is wrong you should take as many as like if you are stuck you are not able to think take examples and try to generalize it all you guys are clear with it cool so let's move forward now let's actually build some intuition of this so one thing is that let's consider these bracket one thing is that if so since okay so this is invalid right this is invalid this is also invalid right this is also invalid this is valid this is valid they have uh right set of pairs now this is also this is what this is what this is also valid okay this is also as you can see that this is also valid so if i talk about this string then it's a property of the valid parenthesis that if the complete parenthesis are balanced then their their sub parenthesis will also be balanced as you can see that this is balanced this is also balanced this is also balanced so we are not considering all the substrings right we cannot consider anything like this or something we have to choose the right set but what it means is that whatever the parentheses are inside it they will be balanced anyhow so this is its corresponding pair then we have this it's correct then it's correct then this is there so does that make sense that inside of it parentheses are balanced now so an opening bracket does not bother us right an opening bracket does not bother us because in future we may find a closing bracket for it right but let's suppose i am at this closing bracket let's suppose i am done with everything and i am at this closing bracket now for this closing bracket this is an opening bracket this is an opening bracket does these brackets are of any use to me no they are not can i get rid of them then that would be great right so i if i can get rid of them because they are valid in itself right as i told you by this property so since they're valid if i can get rid of them then i can actually find out if this bracket has a matching opening bracket okay so let's actually see a dry run of this using stack because stack is the data structure that helps us find just look at just the past okay just the past so how and what we can do we are at this bracket this is our opening bracket we are seeing about it in future so push it on to the stack then this is an opening bracket you see about it in future put it on top of stack again an opening bracket put it on top of stack this is a closing bracket was there an opening bracket for this yes where can i see i can see it on top of stack if there is a corresponding match for this or closing bracket then i can simply pop it off next time here this is a closing bracket does this have a match and see how nicely we have removed between whatever was presented that is here we have removed it we have removed it and now we are actually comparing this where can we find it on top of stack so yes it has a match remove it so now we are here now we are here put it so this is our closing bracket yes match found so remove it remove it from top of stack then we have an opening bracket push it on top of stack okay then we have a closing bracket is the corresponding opening bracket present yes it is present remove it from top of stack now we are at the last bracket is the corresponding opening bracket present see here how we have gotten rid of all of this right so basically yes it's present from where we can find on top of stack just remove it what's the condition we have to check for validity and if the stack is empty then return true right if the stack is empty return true but if the stack is not empty so we have to return false that still even after iterating the string let's say we have completely iterated the string even if the stack is not empty so we will have to return false right because there are still left some unmatched opening bracket so at any time let's say uh you have something like this so at any time you don't find so okay let's let's do a dry run of this as well so this is an opening bracket move ahead opening bracket move ahead closing bracket but no corresponding match simply return from here simply return from here okay so now let's move on to the next question but before that let's talk about the time complexity the time complexity of this approach is just order of n because we are going to each and every bracket not more than twice how once while pushing it and another time while popping it so that's only 2 into n which makes it order of n right that makes it order of n and the space complexity is order of n because in the worst case we may end up pushing all the brackets in the stack when let's say the string was something like this in that case you will end up pushing all the brackets in the stack so the space complexity is order of n okay so i hope that's clear and we'll quickly move on to our next question so intuition is that how can we you know previously clear up something to get just the uh you know so here as i talked about that step by step we made the intuition like sorry i just removed it so as i was talking about that inside of it will also be uh you know balance so if we can remove it i will just be able to look at here that's what i want to do so we can simply remove it and that is possible using stack okay so let's move forward quickly cool so question two and this is very very famous question which is of next greater element okay so question is that let's suppose you are given an element you are given the elements in an array let's suppose 10 13 22 7 for each of these elements you have to tell that what is the next greater element to its right just the next greater element to its right so what's the next greater element to the right of 10 it's 13 okay it's 13 the next theta element for 13 it's 22 the next is there any next greater element for 22 no it's not so we can put minus 1 over here we can put minus 1 over here then we have 7 so next creator of 7 to right of it it's minus 1 nothing is there nothing is there okay so let me take this was example 1 let me take another example as well so we have 10 7 4 2 9 10 11 3 2 ok so what's the next right to the right of 10 it's it's 11 right just greater element on the right of 10 it's 11. just greater element on the right of 7 it's 9 it's 9 just later element to the right of 4 9 again to the right of two nine just to the right of nine it's ten just to the right of ten eleven just to the right of eleven nothing to the right of three nothing to the right of two nothing you can okay cool see if you are implementing any question you can use stl in c plus or collections in java you don't have to implement push pop functions on your own that's just for the sake of lift if let's say your interviewer asks you that's it okay that's it cool so if the question is clear please tell me that how can we attempt it at least give me the brute force approach at least give me the brute force approach so you will agree with me that brute force is nothing so brute force is using two loops so you can basically you know let me actually write the code for it as well so the brute force look like that you can have an answer variable answer array then you can iterate through all the elements from 0 to n minus 1 then for those elements you can again iterate from so okay first you can initialize your result to minus 1 if let's say you don't find any element so you can do 4 j that goes from i plus 1 to n minus 1 you can check if a of a of i is so a of i is less than a of j then simply put answer i is equal to a j t k and break from here take a break from here because you just have to find just the larger element you don't have to iterate any further okay now what you have to do actually this should be result and out of this for loop you can set answer i is equal to result does that make sense this is just the brute force approach okay cool let's go ahead so the time complexity of this approach is order of n square since there are two nested for loops and the space complexity would be order of n which we can ignore because that will be just to store the so basically this is just so we can actually you know make it order of one only because we anyway have to take an answer alright answer array we anyway have to take because that's how we are going to return the answer so the space complexity for this we can assume to be order of one right cool now let's talk about the optimized approach and let's build some intuition for that let's see some observation the first observation is that let's suppose the array elements are 12 10 9 8 7 okay 0 1 2 3 4 if let's suppose these were the elements what is going to be the answer for them what's going to be the answer for 12 minus 1 nothing is on right for this minus 1 for this minus 1 minus 1 minus 1 does that make sense the answer for all of them will be minus 1 now let's talk about another example let's say we have 5 4 3 2 and 10 now can someone tell me what is going to be the answer for 5 now for 5 it's going to be 10 for 4 it's going to be 10 3 10 2 10 10 minus 1 does that make sense guys cool so the thing is that as you can see when the sequence was in decreasing order we got -1 for them and here we also had a sequence in decreasing order but once we got an element which was greater than them so this element was greater than these elements so the answer for them became 10 the answer 4 then became 10 look at it like this so let's suppose i have 5 4 3 2 10 so i start from here this is 5 then this is 4 this is 3 this is 2. now 10 came so once the number came which was out of order and greater than them so answer for them became 10. so the answer for them became 10. let's look at one more example we have nine six five four eight so this is nine this is six this is five four then eight came so eight is eight to whichever element it is greater it will become the answer to them that is here so this is nine this is six this is five this is four this is eight so it will become the answer for six five and four okay so can so basically now once we have got the answer for them can i just ignore this and start by finding the answer for these now does that make sense does that make sense okay giving you some intuition that here we are also ignoring whatever was redundant from the past the idea here is that we have a monotonic sequence we have a monotonic sequence over here monotonic sequences then we have a decreasing or increasing sequence so my point is that i had a decreasing sequence once i find an element out of order so all the elements which are smaller to this this will be the answer for them this will be the answer for them chicken now so basically uh let's have elements 11 4 3 2 10 10 so i have 11 then i have 4 then i have 3 2 11 4 3 2 now 10 comes now 10 comes so 10 is greater than these numbers so answer for these will be 10 answer for these will be 10. now since we have got the answer for them we can actually remove this we can actually remove this and now it will be it will become such a sequence it will become such a sequence now 12 comes so this will come over here now whatever is smaller than answer to them 12 will become the answer so 12 will come over here and 12 will come over here now only so we have got the answer for them so we will remove it and now we are just left with it to n uh we have completely iterated the array and whatever we are we are left with to them the answer will be minus 1 minus 1 okay so since we are ignoring whatever is redundant to us previously and since this is a monotonic sequence therefore stack will help us over here so let's see how let's see the dry run using stack so intuition was that we had to look at the just past just past removing this just fast so whatever whatever answer we had got we will just ignore them and now we'll start again from some monotonic sequence like we did over here over above right okay so now let us go through the dry run using stack then again if you guys will have some doubt we will come to those okay so i have 11 put it onto the stack so 11 has been put onto the stack then we have four put it on to the stack then we have 3 put it on top of stack then we have 2 put it on top of stack then we have 10 now this you can see that this is a decreasing order this is a decreasing order now we found an element out of order so to whatever elements 10 is greater the answer for them will become the answer for them will become 10 so is 2 so is 10 greater than 2 yes so we found the answer for 2 answer for 2 is 10 remove it is 10 greater than 3 yes we found the answer for 3 the answer for 3 becomes 10 remove it now is 10 greater than 4 yes so we found the answer for 4 the answer for 4 becomes 10 and simply remove it now is 10 greater than 11 no so simply push 10 on with the top of stack and move ahead and move ahead now we are at 12 so on top of stack there is 10 10 is lesser than 10 so answer for 10 will become 12 right answer for 10 will become 10 now uh so we are at 2 is 12 greater than 11 yes so answer for 11 becomes 12 okay so now nothing is there simply insert 12 on top of stack now move ahead so we are done we are left with no more elements so whatever is present on top of stack the answer for them will become minus 1 so in this case answer for 12 is minus 1 guys does that make sense so i'm sure saying that then in this solution we need to also store index and stack and so that's what we are going to do we actually need to store indexes on top of stack because we actually are trying to find the answer for the previous elements that we are done with so let me quickly show you a dry run of how we can do this using indexes okay so we are having the stack we will place zero over here then we will place one right then we will place two then we will place three so basically still the array is in decreasing order now we found 10 so uh this 10 is greater than what is present on top of stack so basically answer for this so we will write it like this we will write it like this s dot dot okay because this is the index so a of 3 is nothing but 2 so 10 is greater than 2 answer for this has become 10 then likewise answer for this will become 10 element at index 1 is 4 which is lesser than 10 answer for this becomes 10 now 11 is not smaller than 10 so we will simply push the index of 10 which is 4 then we are here now this is 12 12 is greater than a of s dot top so we will simply put mark the answer of a of 4 as 12 so this is again so as we remove it then uh a of 0 is lesser than 10 answer for a of 0 that is 11 will be 12 and now whatever is present on a stack whatever is present in staff you will simply mark their answer as negative 1 so you will put minus 1 here and the time complexity of this approach is order of n since we are putting an element and removing an element just twice so again order of 2 into n which is nothing but n and space complexity in the worst case can be when let's say the complete arrays in decreasing order it it will be order of n so does that make sense to everyone okay guys so we have actually placed uh the link to the questions for the next questions okay so hope you guys try it and uh guys this was it i hope you enjoyed it and if you enjoyed it please like and subscribe and share this with your friends as well okay cool please try them see ya bye bye okay so uh today we are going to study a very very very important data structure this is going to be very handy which can reduce the time complexities of many problems significantly just by adding a little bit on the space side okay and this is called a hash map or a hash table okay and the whole process is called hashing in in today's class we are going to study some basics of hashing uh how a hash table functions and we'll also discuss some problems which have been asked in the interviews and we will see how you can solve these problems optimally using a hash map or hash table okay i have a question for you guys have you ever encountered hashing in your real life uh have you ever faced any practical scenario where you have used hashing let's let's talk about those days when there was no corona or let's call it the pre-kovedara let's let's talk about the covered era so during the pre covered era we used to go out on holidays right we used to go for trekking we used to go to visit different places right and whenever you go to a different place you need to stay in a hotel right so let's say that if you go to a hotel and you want if you want to look for a room right you go to the receptionist and ask whether a room is free or not now the job of the receptionist is that he will take all uh your preferences he will ask you what type of room you want and then based on your preferences he will just check whether a room of those preferences is free or not right so you go to a hotel and in this hotel you have a receptionist right and you go to the receptionist and you ask for a room give me a room which let's say is a single bedded room has a ac has a balcony and all right and this guy will just check whether a room is free or not now this guy has got two ways to check the room first is that he can actually go and he can visit all the rooms of the hotel and check whether such a room is present or not right he will go he will knock each and every door he will check whether the door is closed or whether the door is open whether the key is with him or whether the key is with the person who has taken the room right so this is one way now as as all of you can see that this is a very very unoptimized way of finding a room right because if there are let's say 200 rooms in this hotel this is a very big hotend then he is going to check each and every room for each and every customer right so if there are n customers and if there are m rooms then how many checks is he going to make this unoptimized receptionist is going to make n into m checks this is not going to be profitable for the hotel business whoever is the owner of the hotel he will fire him the next day right the other way that this guy can use is he can maintain a map right he can just uh against each and every room right let's say room number one zero one one zero two he can maintain whether this room is occupied or whether this room is empty right or he can also have the keys in the key holder itself he can also have the room number written right so now whether he has the key or not that is also visible here whether the room is empty or not that is also visible here he can also have the type of the room written here so he can have that 101 is a single bedroom which is empty 102 is a single bedroom which is non-empty let's say 202 is a double bedroom which is empty right so he can have each and every information regarding the room stored against the room number okay is this going to be a better choice yes right that is why each and every receptionist actually does this you must not have seen any research list who actually go and check all the rooms right but this is something which you all must have seen correct uh let's talk about another example okay so let's say that in those days we also used to go to shopping malls right so this was an example when we want to stay on a hotel another example would be that if i want to go to a shopping mall okay now if i want to go to a specific shop in the shopping mall again there are two ways that either i go and check each and every shop in that mall right so there are going to be multiple floors in that mall right each floor will have different shops right and let's say i'm looking for a specific shop okay let's say i want to buy the magical drug coronal okay i have a perception i have read on whatsapp that if i take corona then corona is not going to catch me right so what i would want is i would want to search this shop which is selling this drug coronal right now again i have got two ways to do this first is that i go to each and every floor and i check each and every shop one by one right or some of the malls who have a logical owner or who have a logical management what they do is they put a board or a map of the mall right so what they do is they put a shop number they they give the complete address of the shop floor wise they will say that in the first floor these are the shops which are there in this order right and in the second floor these are the shops so what i can do is i can use this map and i can find the exact location of that shop and then i can go to that shop by this drug and then i can make sure that corona is not affecting but since this was a knowledge that i gained from whatsapp this might not be true right but this way of searching the the shop this definitely is a better approach right instead of visiting each and every shop what i am going to do is i am going to check this mac and then find the exact location of the shop okay does this make sense to everyone these are two examples which all of you must have used like these or something like this in your real life right where you have to keep track of things and you just create a table or you create some entries and you just mark profiles or you just the attendance register that we have that we used to have in our school classes that was also an example of hashing if let's say a teacher wants to know whether a student is present in the class or not right what he will do is he will just do a linear scan on all the students and doing this linear scan while taking the attendance he also keeps he also marks the attendance right so if there are students let's say in our class we have aman then we have monica then we have a mode right so if if i have to check whether uh all of these guys are present in the class or not what i can do is just before beginning the class i can just mark their attendance right now if let's say after uh sometime i i want to know who all were present in the class i will not do another scan i i will just check whether monica is present whether aman was present or not right so this again is another example of hashing which we have been seeing from the school days right okay is oyo also used concept of fishing yes or you must also have used the same concept right okay so this is this is the general idea of hashing now let us see how it actually functions in the uh in the world of computer science okay so let's try to understand this whole process using an example so let's say that we are given an error and this is just to understand how hashing is going to function okay this is going to be a very easy example to understand the working of hash maps and hash tables okay so let us say that you are given an error and in this array you have all the numbers from range one to thousand so you know that any number in this array is going to be from or let's say from zero to thousand okay so you are given an array of size n and each and every number of this array ranges from 0 to 1000 okay you have to return the frequency of frequency of every number let's say you have got queries about the numbers okay so you have this array and now you are getting multiple queries you have to answer these queries and each query asks you the frequency of a number okay so for example if the array is something like this okay if this is the array after getting this array you will get different multiple queries and you have to answer what is the frequency of the given number in that query so for example if your query has 58 you will return 1 because 58 occurs only single time then if let's say you get 3 in the query then you will be returning 2 because 3 is offering twice in this array if you get 2 you will again be returning 2 because 2 again occurs twice in the year is is this scenario is the problem clear how can we solve each and every query in the most optimal time okay let us let us start from the brute force okay what is the brute force way to solve each and every query the brute force way to solve each and every query is that whenever you get a number in the query you iterate over this complete array and you count the occurrences of that number right so if i get 58 i will do an iteration over the complete array which is going to be an order n operation and then i will return one if i get 3 i will again do another order n operation over the complete array and i will return two okay so what is the total time complexity of if if i go by this approach let's say there are q queries solving each query takes order n time so the total time complexity is going to be q into n right now this q can be very very large okay so this is something which is not optimal right any other approach that we can use in this case that you might have studied in the previous classes can we optimize this order and factor here let us say if i do some preprocessing okay if i sort the array if i sort the array what happens to the order now the order is the array sorted in ascending order right now can i find the frequency in a more optimal time can i reduce this factor of n yes now how can we count the frequencies now we can use binary sets you must have studied this you must have learned it in the previous sessions that given a sorted array you can count the number of occurrences of any element using binary sets right you can just find what is the first occurrence of that number using the binary cells then you can also find what is the last occurrence of the number and then you can get the length of this survey right so if you use binary search after sorting then each and every query is going to take how much time only login time right so now what is the total time complexity of finding all the frequencies so if you have q queries then solving all the queries is going to take you q into log base 2 and time this much is the time that you will invest in resolving each and every query but before this you have also sorted the array right so that amount will also be counted now whichever is the greater of these two will be the overall time complexity right this is still is a lot because again n can be very large uh q can also be very large right so can can we further optimize this right so as as many of you have already already suggested what if i have another array right so i can see here if i focus on the constraint of the problem the problem says that any array value is going to be in this range strictly right any array value cannot be more than thousand and it cannot be less than 0 right what if i just have another array where each and every index of the array represent the numbers and the value in the array represents the frequency of a number in this original array so what if i have another edit just call it a frequency array right and and store and count the frequency of each and every original array element in this array right so i can have another let's say frequency array of size what what should be the size of this error what should be the optimal size of my frequency array if if i know that all the numbers are going to be in the range from 0 to 1000 i know that the maximum number that i can have is thousand to have thousand as an index i need an array of size one zero zero one right one thousand one this this array is going to be this array can accommodate all the numbers from zero to thousand in index right so now what i will do is whenever i am i trading over this array so initially i initialize this complete thousand sized array by zero so uh in this array initially i have thousand zeros in every index right and then whenever i visit a number i will just loop over this array whenever i visit a number i will increase i will increase the value here right because this denotes the frequency so initially i am assuming that frequency of each and every number is zero whenever i encounter a number i will increase the frequency right so i will just loop over this array i will say for i equals to 0 i less than n which is the size of the given array i plus plus and i will say frequency of a of i plus plus right if i just do this what will i get in this array frequency of 1 will be increased to 1 right and then frequency of 2 will also be increased and it will be 2 frequency of 3 will also be 2 and so on right so now after i have built this array if i have to return what is the frequency of any given number right what is the operation that i have to do after i have built this array for any number i for any given number i if i have to return what is the frequency frequency is nothing but frequency of i so if i have to return what is the frequency of 58 i will quickly do frequency 58 if i have to return what is the frequency of 2 that is going to be frequency of 2 and that's it right so what is what is the time complexity of this operation time complexity of this operation is constant right this is a constant time operation i'm just retrieving a value from the array right so this is going to take order one time correct now i have a q queries and each query is being solved in order one time correct so what is the overall time complexity of solving all these queries overall time complexity becomes order q because each and every query is taking how much time only order one time right so this is the time to resolve each and every query and then we have also built this array right so we have hydrated over the given original array and then we have also built that array so this takes order and time order n plus whichever is greater will be the final time complexity okay does this make sense to everyone how we have solved this like optimize the time complexity from n square to n log n plus q log n to order n plus q okay now uh one of you just asked what happens when area elements range from one to one risk to power 10 raise to power 18 okay what if so in in this problem it was given to us that the numbers are going to range from 0 to 1000 that is the reason why we are able to create an array right i can create an edit because i know that indexes can be in this range correct now what if the numbers are going to be very large okay a of i as asked by lucky movies what if the range is this can i use the exact same approach so now i cannot use the exact same technique because i cannot have an array i cannot create a frequency array which has a size 10 raised to power 18 right because this is going to cost me a lot of memory right how much memory is it is it going to cost if this is an array of integers one integer takes how much memory four bytes right so if you want to create an array of size 10 raised to power 18 this is going to cost how much time uh how much memory 4 into 10 raised to power 18 bytes can anyone quickly tell me how much uh is this in gbs 4 into 10 raised to power 18 uh bytes how much is it in gbs so if if you want to create an array of that size you need to have this much of memory you need to have this much of memory in the ram right so this much of memory in the ram is definitely not going to be possible for an ordinary computer right so what we are going to do is now we will have to be a little more logical and will have to apply a little more mind right unlike mumbai police so let let us be a little more logical and let us try to see if if we have an upper limit on the memory right if let's say let us take a smaller example and let's say that the numbers are ranging again ranging from just to understand let's take the smaller example that the numbers are again ranging from one to thousand but the largest array that i that i can have can have a size of 100 this is the upper limit on the size of array okay similar example so what we are doing is numbers are ranging from this one to thousand but the maximum size of the array can only be hundred all right now again i cannot use the exact same method by because having an array of size thousand is not possible right so if i want to store the numbers as an index in the array then i can only store till 100 is there a way using which i can map all these numbers from in this range from 0 to 99 because the maximum size that i can have is 100 so can i map all these numbers in this range is there a way have we seen anyway or let's say that all these numbers are ranging from 0 to 1000 right yes what can we do we can simply take modulo right is everyone familiar about what is a modulo operator this gives you the remainder right so if if i take modulo of any number a i with 100 which is the maximum size of the array that i can have can i say that this number which is a i modulo 100 will always lie in the range from 0 to 99 can i say this yes correct so i have got one way to map these numbers which are in this range from zero to thousand to a range which is very very small right this this range has a length length uh thousand thousand one and now uh the resulting length is only 100 so i am mapping these thousand numbers to 100 numbers okay if this is the case how am i going to store the numbers let's have uh an example let's say i have 4 92 5 8 23 15 142 and some random numbers okay and now if i if i can only afford an array of size 100 right how can i map these numbers i will first take the modulo of these numbers with 100 and then whatever number i get by using by doing this operation i will store these numbers in that index so i get the index by taking modulo of these numbers by 100 so first number will be stored against index 92 this will be stored against index 5 this will be against 23 15 42 54 and 64 right so if if i have these as the array index 54 and so on till till 99 then at 0 is going to be empty when is empty uh 2 is empty at 5 i am going to have 5 at 23 i will be having 8 23 at 42 i will be having 142 and then 6 54 764 and so on right so now is this going to work is this going to work correctly if these are the indices and these are and i keep the values in array element mod 100 index okay now some of you are saying that this is going to work but there can be collisions right what are collisions okay so let us say let us say that in the array in the original array i have these numbers 100 or 201 then i have 302 then maybe 300 401 to 200 right if i have these numbers right so in which index should a number belong in index 0 how many numbers am i going to have in index 0 i am going to have 100 then i am also going to have 300 and i am also going to have 200 right all these numbers will try to get inserted against a single index right these are called collisions then there are multiple prospects candidates for a single index right so index 1 will try to accommodate 201 then 401 index 2 is going to have 302 and then two also right so there is no one to one mapping right a one to one mapping does not exist correct if a one to one mapping does not exist is this even possible to use this technique are we going in the wrong direction is this a correct way is this the correct path that we are taking maybe right we we have also studied a data structure called linked list right if if you know about a linked list what if we have an array of linked lists i i have if i keep an array of the linked list nodes right can i say that this can work in that case right so currently if if you are only storing a single element if you are if you are only trying to store a single element against one index then since there is no one is to one mapping this will definitely fail we are going to lose some data right because every time you have a collision the previous number will be overwritten but what if i use a linked list so instead of having uh these integers right if at index 0 i have this complete linked list store so if i have to create an array of linked list what what do i need i only need the pointer to the head stored in the in that correct index right only if if i have an array like this where i have this head pointer then using this head pointer we can have the complete linked list right so we don't need to actually store this complete linked list in the area we only need to store the head pointer right similarly at index 1 we can have the head pointer of 2 0 1 at index 2 we can have the head pointer 2 3 0 2 does this make sense to everyone so we can still manage doing hashing in this case even though the the range which we have to store is very large the size of the array is very small but we are making sure using the modulus operation that we are mapping these numbers to the available size and then using a linked list we can also make sure that we are not losing out any data and we are storing all these numbers using the chaining okay now if if i am storing the values like this now if i have to find what is the number of frequency or let us say if i just want to check whether a number is present or not right what is the worst case time complexity of this case if i am going by this approach if i am storing linked list if i am having an array of linked list nodes what is the worst case time complexity of finding whether a number is present in the array or not worst case is going to be if all the numbers are mapping to a single index right so if let us say that the numbers are these 1 then you have 401 then you have 101 then you have 601 right 701 and 501 correct if i take mod of all these numbers with 100 all of them are going to take the exact same key so all of them are going to map against one so what will happen now if i have to search whether a specific number is present in this array or not i will be traversing this complete linked list right so first let us say i get a query i get a query of let's say 801 i have to check whether this number is present or not so first of all i will try to see in which index is this number is stored so i will just do 801 mod 100 which is going to be 1 so i go to index 1 of my array and now i have a linked list of size n i will i trade over this linked list and since this is also not in sorted order right i will have to check each and every element and i will then figure out whether i have 801 or not right so this is going to be a order and time complexity operation does this make sense to everyone this is the worst case time complexity of checking whether the number is present in this list or not right okay so this is the worst case what could have been an ideal case when can i say that that this is the best thing that that i want what is the ideal case in this in this scenario the ideal case would be that ah if all the numbers are mapping to different index if all the numbers if i have a data and like if i have the data in such a way that all the numbers are distributed evenly amongst all the index right so if i let's say have 401 against one then i have two so let's say i have seven or two and then i have 23 so i have 8 23 and i have exactly one element for each and every index this is going to be the ideal case and what is going to be the time complexity in this case of just finding whether a number is present or not since the list size in each and every case is exactly one the time complexity is going to be constant right so this is the best case time complexity and this is the worst case time complexity is everyone clear about these two okay great so the aim is that the mapping function that we are using right currently the mapping function is mod by the size of the right so the aim should be that whichever mapping function we are using should try to evenly distribute the load amongst all the possible indices right so this this function the mapping function that we are using this is called what is it called anyone knows what is the name of this function this is called the hash function okay and hash function is is a very very big topic in itself there is a lot of research going on there has been a lot of research already done on what could be a better hash function of what case right so you can just go and google up and read about hash functions there are multiple publications on these you can read you can go through some of the publications if you are interested right but taking a mod this is the most simple hash function that you can have but not the most optimal and this was just for the example you have very complex very optimally written hash functions which try to distribute the load evenly okay so you can just go back and read about what are hash functions and you can also read about some of the common hash functions okay cool now if if i write one of the best hash function even which is the best possible hash function currently present in this word can i say that that hash function will guarantee zero collision can there be any hash function which can guarantee zero collisions no way why why no you have got a very big range of numbers right you have to map numbers from let's say zero to thousand you have got only 100 slots there is are you are you aware about the pigeon hole principle you have 100 slots and you have to put thousand things when you put the first hundred things and if your hash function is guaranteeing zero collision 100 slots are filled right now when you pick the 101 index number this is definitely going to collide with at least one of the pre-existing slots right so since you are mapping a bigger list of numbers to a smaller list you will always have collision so there can not be any hash function which can guarantee zero collisions okay however there are hash functions which try to distribute the load evenly that is possible there has been a lot of research done on that you can google and read okay cool so this is this is uh the basics of hashing right uh you can read about hash functions you can also read about hash tables hash table is nothing but key and value right so you must have seen what is the dictionary if you use python you must have used hash maps so hash maps or hash tables they are nothing but a key value pair this key is is the result that you get from the hash function this is a hash code of of any value and in the value you can store it anything right so the key as you all now should understand these keys in this case are this are the index from 0 to 100 right so keys are always and always going to be unique values can repeat you can store the values in list or maybe in some other data structure but keys are always going to be unique okay now there was a question that if if you are using a list is there any specific reason of using a list or can we have any other data structure here what do you guys think can we have any other data structure in in place of list so surit is asking why we use linked list is there any specific criteria correct so komal has got a good solution to that if if i'm using a list what is the worst case time complexity of searching a list in uh if you have a list which is not sorted and which is a linear linked list what is the worst case time complexity of searching in this list worst case time complexity of searching in list is order n okay now do we know any data structure which provides a better searching time complexity is there any data structure which can store the numbers maybe in some order and then can give us a better time complexity do you guys know about binary search trees in a binary search tree all the values on the left subtree are going to be less than or equal to the value of the root all the values of the right subtree are going to be greater than the value of the root right so just by using a technique like binary search it can always discard while searching for a number you can always discard half of the set space right so what is going to be the time complexity to search a number it's going to be log base 2 n if you are using java 8 if any one of you who is using java 8 must know this that in java 8 they optimize this worst case time complexity of of retrieving from a heisman using a balanced binary search tree in in a normal binary screen worst case you can also have in time complexity often if the tree is skewed but if the tree is always balanced then you are always going to have a searching time complexity of log base 2 n so in in java 8 what the hashmap does it if the size of the list is uh still a threshold number which i don't remember correctly i guess it's five or six till then it maintains a list if the size exceeds the threshold value then it converts the list to a balanced binary search tree so the worst case time complexity that we have seen to be order n will reduce to order login okay cool so guys this is uh in brief about hash maps and how they work okay let us quickly solve a problem also okay in which type of questions can we blindly use hash functions okay in in any question it talks about the frequency or counting the numbers or maybe checking whether a number is present or not or checking the presence of anything then you can use hash function or then you can use hashing okay let's quickly solve a problem and then you will get a better idea of when to use hashing okay so the problem says that you are given an array and you have to check whether there exists a sub array which has some equals to zero okay so for example if your array is this in this case does there exist such and such a sub array yes right if you see the sum of this sub array what is the sum of this sub array is exactly 0 so you can return 2 if there exists a sub array which has a sum equal to 0 the sub array can start from any index it can end at any index it can have any length which is possible but if there exists any type of sub array which has some equals to 0 then you can return to else false okay modify cadence algorithm okay how will you do that remember that this sub array can start from any point this server is starting from this point there might be an input where your sub array which is causing a zero sum can be present let's say here or this a value can be present here or maybe the complete array can also be the sub array what is a brute force way if if you are not getting any solution can you quickly write down what is the brute force way okay the brute force way is going to be that you actually try to calculate the sum of each and every possible sub array right so you you first check all these sub areas of size one then you can check all the sub arrays of size two then you can check all these sub arrays of size three and so on right how many sub arrays are possible n square sub arrays are possible to calculate the sum what is going to be the time complexity for every sub array you will also run another loop to calculate the sum so it's going to be an n cube solution right which is highly unoptimized how can we come up with the optimized approach and we have also studied hashing machine doesn't seem to contribute in this question right okay let us let us assume that there exists a sub array okay there exists a sub array which has got some equals to zero okay so let us say this is the initial area that we have and there is a sub array let us say this part which has a sum equals to zero how do we define a sub array we always define a sub array using a range of indices right because as i said the sub array can start at any point it can end at any point right let us say it starts at a point l and ends at an index r and i am saying that we we are just assuming that the sum of this sub array starting from l to r is zero okay now if this sub array has got sum equals to 0 right if if i also have the sum of all the sub arrays starting from 0 stored with me okay what what can we say about this part this part which is in the blue dotted line what is going to be the sum of this part the sum of this part is nothing but sum from 0 to r right and this sum from 0 to r can be broken down as some from the range 0 to l minus 1 right plus sum of the range from l to r does this make sense to everyone right so sum of any sub array can actually be written in terms of this prefix sound right i can write sum from l to r is equal to sum from 0 to r minus sum from 0 to l minus 1 index i can write the sum of any sub array which starts at index l ends at index r in the form of the sum of sub arrays starting from 0 which is nothing but the prefix sum everyone here understands what is a prefix sum right so if if i have a prefix sum array p then i can say that the sum of this sub array starting from an ending at r is nothing but p of r minus p of l minus 1 does this make sense to everyone prefix sum is nothing but prefix sum is the sum of all the indices till this till that index so if i have an array right prefix sum at any index i is nothing but it is the sum of all the elements including the i and all the elements before the i okay so if let's say i have an array 1 2 3 four the prefix sum array would be one and then this will store the sum of these two which is three then this will store the sum of all of them which is six and then this will store the sum of all of them which is ten so this is the prefix sum array for this array if i have all these numbers stored with me already in this array prefix now i can represent the sum of any sub array in the form of prefix sums right and if i am saying that this sum is equal to 0 if this sum is equal to 0 can i make any comment about these two values if this sum is equal to 0 this means that prefix sum of r should definitely be equal to prefix sum of l minus 1 right let us visualize this in this diagram and then it will be more clear so i have these two parts right now i am saying that this this represent this blue box represent the prefix sum of r this is the sum of all these elements from 0 to r okay this three this yellow box this represents the sum of all the numbers in the range l2 are correct and what about this green box this green shaded box represents the prefix sum of the index l minus 1 the sum of all these numbers can i say that if if this is going to be 0 right if i'm adding the sum of all the index from left to right and and if this part is equal to 0 then whatever sum i get at this point the exact same sum will also be present after this because the contribution of this is 0 does this make sense to everyone right so if if i have an array right and if i am just calculating the sum of all the array elements till that index and then there is a part which is contributing exactly zero amount right so this will give some some sum right let's say s this gives as dash and then if i add this as well this gives h double dash this gives as triple dash and then this gives something something something after i'm here i will again get s triple dash because the overall sum of this part is 0. does this make sense to everyone let us take the example as well and then this will be crystal clear so i will just copy this thing so if i just calculate the prefix sum of this array i will be getting 4 right 6 6 minus 3 again is 3 then 4 and then 10 okay now what i was explaining is since the sum of this part is exactly 0 this part the contribution of this part in the sum of all these numbers is going to remain 0 right that is why whatever number i am getting here will also be repeated here right so whatever sum i am getting at this point which is this point is l minus 1 right because i am assuming that this sub array starts from l so the previous is l minus 1 and this is the r these two have to be equal if these two are equal this means that this sub array the contribution of this variable is exactly zero all the values cancel out each other and we are remaining with whatever we had before starting the surveillance right so how can we now solve this problem if we calculate the prefix sum of the array and then if we if we observe that there is a number repeating in the prefix sum can i say that the contribution of all the elements between these two numbers is going to be 0 which means that this sub array is adding to 0 okay is the idea clear to everyone guys is the idea clear right let's let's take another example let's say i have 4 2 0 1 6 okay now if i take the prefix sums i will be getting 4 6 then again 6 and then 7 and 12 so again i can see that a number is repeating in the prefix sum which means that whatever comes in between these two this is if i said that first number should be l minus 1 this is l minus 1 right and if this number is r so whatever is from l to r is going to give me a sum equal to 0 l 2 r a here has exactly one element which is 0 now some one of you asked what if ah same number is repeating twice right that can also be possible you will have to understand what is the physical significance of this thing right so even in this case if i just modify this array here i got 4 then i have 0 then let's say again 0 then i get 2 and then minus 2 and then something right now what will be the prefix sum here again 4 4 6 again 4 and then 5 right so this means that all these numbers which are repeating they all are forming a sub array which is going to give a zero sum if these two are repeating this means that we have a sum 0 here if these two are repeating this means we have a sum 0 here from this plus 1 to this right because this has to be the l minus 1 index so even if you have multiple repetition that points to only one thing that the sub array between them is giving a 0 sum okay now how do we solve this problem so one thing should be clear to everyone that the first step is that you create the prefix summary how can we create the prefix sum array this is very easy task you can have p 0 equals to a of 0 because the first number is going to be the exactly the same and then for building the rest of the array you can just keep calculating you can just keep adding the current value to the previous prefix sum right prefix sum of i is nothing but the previous prefix and whatever is the sum till now plus whatever is the sum of the current elements so now you can run a loop from i equals to 1 i less than and i plus plus and then you can say p of i is equals to p of i minus 1 plus a of i this gives you your complete prefix sum now in this prefix sum you just have to check whether there are two numbers which are repeating or not is there any data structure that we know which can solve this problem very optimally you just have to check whether there are two numbers which are repeating or not how do you check for a repetition of a number you can have a hash map right maybe you can have an integer here and a boolean right then you get four you store true then you get six you store true when you get another six you know that six has already occurred if six has already occurred this means that there is a sub array which is giving a zero sum if you also want to find what is the length of the sub array instead of instead of having the boolean you can try to store the index here this also becomes integer and now you can say that 4 occurs at index 0 6 occurs at index 1 then 6 again occurs at index 2 this means that from this index this plus 1 to 2 we have got a sub array which is giving us sum equals to 0 okay let's take this example which we initially had this one right you you can have your key and value key is the sum value is the index in the hash map you get four sum at index 0 then you get 6 sum at index 1 3 2 and then you again get 4 at index 3 right now we had discussed right the keys are going to be unique so once you get another same key you can just check that this key is already present in the hashmap and the starting index for 0 this means from 1 to 3 i have an array which is giving sum equals to 0 okay does this make sense to everyone what is the time complexity of this complete problem of this this complete algorithm first of all we have calculated the prefix sum this costs us order and while calculating the prefix sum only you can just also enter in the hashmap right here only you what you can do is you can do your map dot put or first maybe you can check if if map dot contains p i this means that you have found a sub array you can directly return true right else you can say map dot put pi and comma whatever you you are storing whether it is index or or whether it is your true or false right and this is going to solve the problem overall time complexity here is order and okay so guys i will now end this session please please do solve all the problems thank you guys okay uh let us begin with the very first session on um dynamic programming of 21 days of code this is not going to be a theoretical session i'm just going to solve three problems that you guys had suggested uh over the linkedin page let me just give a brief about no i'm like what dp is dp is very similar to what recursion is uh or divide and conquer is so as to say uh basically when a solution to a problem can be achieved by solving the same problem with smaller inputs and then you solve the original problem by combining the outputs of the uh smaller problems that is what is known as db in dp there are two important properties that the problem should be overlapping what is meant by overlapping is that one state can be reached from multiple other states and how to identify a tp problem the best advice will be practice as many tp problems as you can it's only a practice with which you will easily be able to identify that hey this is a tp problem and then in a dp problem thus different possible states are almost fixed uh as far as my experience goes no more than eight or nine different states exist of tp okay okay how to find number of states of tp is also dependent upon the question and that and the intuition gets clear to you only when you practice there are some very nice articles about tp that are present on code forces or top quarters so do read them they will also help you identify what are the possible tp states that are generally asked okay but without practice you won't be able to identify that even if you have studied a lot of theory okay so for dp especially i suggest you to solve as many problems as you can okay so today we will be taking one problem from simple adp one from 2d string db and let us say one from uh greedy or dp okay uh so one question is by deburrune the difficulty that i face most about dp is that how to convert a memoization solution to a bottom-up solution that's a very good question there uh what i personally do i when i since the time i have started solving tp problems i always solve them from beginning in a bottom of fashion i don't do it this way that hey first i code a recursive solution a top-down solution and then memoize it and then convert it to bottom-up code i never do that i always try to create tp state in such a way that i can directly start with a bottom-up code as i told earlier there are no more than seven or eight popular states of tp so do read those articles that are mentioning that okay what are the different possible tp states and then things will get clear to you okay so what i will suggest to you is when you are solving a problem solve it anyways and then at least see the solution of it in a bottom of fashion as well okay so because when you have seen the solution to it in a bottom of fashion then you can remember it for always and then when a similar pattern comes you can directly apply that okay so let us start with so first people ask us to solve the longest increasing subsequence problem okay let us do that so this is the longest increasing subsequence problem and let us solve it so the problem says that we have to find the longest increasing subsequence of a given array a array of integers a so basically we will be given an array of integers the length of the array will be almost 2500 in worst case and we have to find a subsequence of an array in which the elements are in strictly increasing order okay strictly increasing order means the next element should be greater than not greater than equal to right okay and as this is a subsequence and not a sub array so it need not be what we say contiguous so that is also fine and we are only asked to find the length of the longest increasing subsequence and not generally what the exact subsequences so we are just asked that what will be the length of the longest increasing subsequence for example in this array a we can choose one two and five so this is the longest increasing subsequence one is smaller than two similarly two is smaller than 5 and what is the length of this subsequence it is 3 so we are just asked to return 3 by the way this is a very popular problem this is a very well known problem and there are two different kind of solutions possible to it uh this problem has one order of n square solution that is quite easy and it's based upon what we say dynamic programming and there is also an order of n log n solution to this okay this is based upon what i think it is more like bind research solution okay as to this class is a tp class i won't be discussing the second order of n login solution but i can just send you guys the link to resources which you can study about that okay but do try this because the bind research solution once it hits you is very good for you okay or actually let us try to solve it in order of login as well as today okay let me answer what the other questions are how much time should i give on tp like one month okay uh uh yes one month i mean like one month of solving only db problems is fine i mean like it depends upon how many different problems you solve of different difficulty if you keep on solving easy problems you are never going to improve right try to solve those problems that you are that you were not able to solve initially try to grow with every problem okay and other than practice any other thing can we do hush uh i'm like for dp your mind works like a machine learning model the more practice you will give to it the more accurate it will get within uh with db okay i mean practice is the best thing and you see a solution always implement it and then also read i mean then also make sure that your mind is totally able to visualize that solution okay okay let's start with this problem so we are asked that hey we are given an array a and we have to find a longest increasing subsequence of this array awesome so how can we do that okay uh suppose i know that okay i want to see that hey can i include let me actually rewrite this area again and let me rewrite this array okay okay okay so now at every iteration i will try to see if i can include that particular element if i can include that particular element in my longest increasing subsequence okay let us see how we can do that so suppose can i include 0 in a subsequence i can include this 0 in a subsequence only if there already was a subsequence in which the last element was less than zero right okay is there any subsequence before it that has the last element less than zero no that means this zero will create one more subsequence we'll create another different subsequence of size one okay then i go to the number eight now i try to see if i can have a subsequence that can have eight as the last element when is that possible that is possible only if before this i had a subsequence that had a number less than 8 as the last number okay what are the subsequences before it that have a number less than 8 as the last number this is a subsequence that has what we say 0 as the last number so i can put 8 ahead of it so what will be the length of subsequence that will be at 8 it will be one plus one which will be equal to two great now i go to four now i will try to include it when can i include i can include it only if uh there was a subsequence before it that had a number less than 4 as a last number there is only one subsequence that was ending with 0 so the answer will be 4 1 plus 1 so which will be 2 okay then i go to 12 now how many subsequences are there before this number 12 that end with a number less than 12 there are three right this subsequence ends with a 4 this subsequence ends with the 8 this subsequence ends with a 0. so either i can add 12 after the subsequence that ends with a 0 or i can i can add 12 at the end of a subsequence that ends with 8 or that ends with a 4 as we see that this is the largest length of a subsequence that ends with a number smaller than 12 so i will add 12 after this so my answer will become 2 plus 1 which is 3 now i go to 2 this is the only subsequence so my answer will become 1 plus 1 which is 2. now i go to 10 what are the subsequences this is a subsequence this is a subsequence this and this out of these the largest is 2 i mean the largest one has a length of 2 so my answer will become 2 plus 1 which is 3 great now i go to 6. what are the subsequences that have a number less than 6 as a large last number this this and this out of these the length of the largest one is 2 so this one will also become 3 okay then i go to 14 and i will see here all these subsequences have a num have the last number as less than 14. then out of all these which one has the smallest length which one has the largest length this has the largest length of 3 right so my answer here will become 3 plus 1 which is 4 okay i hope now the intuition is clear so what we can do is you can create a dp table let me just write the size of a then i will create a dp table of the same size what is the value of the first index going to be the value of the first index is always going to be 1 right so i can say dp 0 is 1 that is the base case now my answer is initially it is 1 then what i do i say for n i equals to 1 i less than n plus plus i now i try to find all those dp states in which the last number was less than the current number so what i will do i will say for in j equals to 0 j less than i plus plus j if array j was less than array that means uh the largest the increasing subsequence at that number ended with something lesser than the current element then i can say that dpi is equal to max of dpi comma 1 plus dpj right basically the length what was the length of this subsequence that particular number plus addition adding the current element okay great so now my answer will become max of answer for my dpi i have to find the largest name and finally i can return answer here what is the time complexity of this this is order of n this is also order of n so the time complexity will become order of n square i think the answer should be correct let us test it what is the issue is it less than or is it less than equal to zero four six nine thirteen fifteen zero four six nine fifteen um longest increasing subsequence originally and in which the subsequence is as long as possible okay here i am returning 14 but the expected output is 15 or initially it will be 0 comma 1 plus dpj that is also fine is it less than or is it less than equal to because it says find the longest increasing find a subsequence of array in which the subsequence elements are in strictly increasing order so that means the elements are always increasing i mean like equal to is not allowed but in this particular question the answer is coming out to be 15 why will that be the case that will be the case when orient i equals to 1 i less than n plus plus i i say ej is less than let us say what if aj is less than equal to what will be the output then then also my question returns 14 okay so that is not the issue there is some other issue there i created a tp of size n initially my answer is one then i say foreign i equals to one i less than n plus plus i okay then i iterate over each the element of array i and then i run a loop from j equals to zero to j less than i okay that is also perfect then i say if array is less than array okay then i update my tpi so which is this dpi to max of tpi comma i'm like what was the value presently there and one plus dpj so that is also fine but the answer here is 15 let me try to print let me try to debug this code as to why this is happening uh let me say that i output my dpi at each stage this is going 14 and 40. this is correct so this should be 14 and 14 that is perfectly correct and i'm not getting 14 anywhere else so that is also fine but i am getting this as zero okay now i got the issue initially the stage of tpi will be one right so initially each of the elements will be dpn comma one that i have said the default value should be one right if it is the only element of pp then the answer should be one so i had i always had actually off by one error i forgot that so i'm like if that element large is the smallest element like in the case of suppose what is say that minus one would have been here then minus one would have been the single element there would have been no element smaller than this right so the dp state here should be one and not zero so now we will be correct correct so we got this as well and let's move to the next question that was wild card pattern matching actually there are two questions like that as far as i remember in interview bit that is the regular expression match and regular expression match two which one do we want to solve let us try to solve the regular expression match two okay let's try to solve this okay so i'm not sure if any one of you has ever seen regex before but what rejects allows you to is basically to find all these strings in your directory that match a particular pattern okay so basically we are we are asked to implement a very similar function to how regexes would be working where the possible values in our rejects are fixed like here we are told that we have to implement a regular expression matching algorithm that can support a dot and a asterisk but dot means a dot can match any character any single character in my uh in the whole string so basically uh let me say that does dot match a yes that is true okay does dot match b yes that is also true but does dot match a e no okay so a full stop can match only one character any character okay at full stop can match one occurrence of any character okay then the second uh uni character given to us is asterisk and asterisk can match zero or more of the preceding element what it means is that suppose we have a star a star can match a it can match a a it can also match a a a and so on okay so this is what s disk means one or more than one zero or more than zero currencies of the previous character in my regular expression pattern okay so for example does this string a a does this pattern match a no because though this a is equal to a but then there should also be a second a but it's not present in the string okay so the very first one is a string the second one is a pattern but the same thing holds this matches this doesn't match because the string is aaa but the pattern is only two ways so it doesn't directly match now double a does it match a star yes it does why because a star is equal to single a it is also equal to double a it is also equal to triple and so on so does a b match star escris a dot estes it does y let us say what can this dot represent this dot can represent a this dot can also represent b right and similarly this can also represent c that means what can dot asterisk represent dot squeeze can represent a a it can also represent bb it can also represent cc right so that is why dot asterisk uh is true right uh matches zero or more of the preceding element your preceding element is a full stop so it can match precede zero or more than zero occurrences of previous character which is anything so it can match zero or more occurrences of anything so basically anything can be a so it will match a a it can also match a b it can also match ac and so on okay cool now let us try to solve this using dynamic programming so we are given a string let us say that this is the string and this is the pattern okay now let us try to i mean like whenever a string problem is given to you there are multiple string problems like longest i mean like even any 2d array dp problem you have to i'm like normally what happens is that or even longest common subsequence problem as such in strings so what you always do like let us say that we have a string like a b c d a and also another string like b c e f g suppose you are given two strings and you try to apply a 2d dp problem you always try to apply 2d dp in the form of prefixes that what is common between the prefix of the string a up to index 4 and string b up to index suppose 2 okay you always try to compute this what is common between the first string for up to index x and the second string up to index y that is the common pattern all the 2 db problems are then yes a star can match an empty string also right i think it should be i'm not really sure let me see can start match an empty string but i think stars is i'm like if there is only a star then that means there is no preceding element okay so either if there is only a star that means there is no preceding element then the pattern is invalid actually okay because a star is valid only if there is a preceding character okay so i think then the string then your pattern will actually be invalid that is what i hope but let us see okay now so i will following this pattern we will try to create a dp state of two thing that means string till i satisfies the pattern till j okay so i will try to create a dp state where i will say dpij represents 2 if the string till index i satisfies the pattern till index j okay always i'm like this is one suggestion i'm like whenever you are trying to solve a problem using tp try to represent your dp state in some english sentence okay after you have represented an english rdp state in english sentence then you can easily find what we say i mean like dp i'm like the state uh relations which states will it depend upon does aab match c star a star b yes it actually does why why because there can be zero occurrences of c okay because i'm like a a b is nothing but zero occurrences of c uh then one then two occurrences of a and one occurrence of b so then it will match because a star can also represent zero occurrences of the previous character so c star will basically just change to an empty string so that is why it was satisfying okay so now i will try to create a boolean dp state how can my tp state be uh let me create let me say that the length of my string is n and my length of the pattern is p dot size okay now i will try to create a 2d db matrix so i will try to create a tp matrix of vector of vector of tool i can say because i only have to represent two or false dp which will be having number of rows equal to n plus 1 y n plus 1 while doing dp problems i always i like i personally like indexing by one to avoid uh i'm like out of bound error checks okay that is why i always create a dp array of size n plus one and this will be a vector of cool uh of size m plus one uh for those who are not familiar with uh what we say the c plus plus index this is creating nothing but our tp matrix of n plus 1 cross m plus 1 dimension okay this is doing nothing but this so will uh okay let us say that let us talk about two strings and let us say that we have a string like this and this is my pattern okay does nothing match nothing i mean like when there is no nothing in the character and nothing in the string in the string does nothing match nothing it does right so what i can say is bp 0 0 is true i'm like nothing matches nothing so if i talk about indexing i am starting one base indexing so zero will be here one two and three so basically zero zero is representing does nothing match nothing okay great so now we have taken care of the base case now i will try to solve the whole question okay and let us take care of other scenarios as well the others will always be false now i will try to see if the string till index i matches the pattern till index j now what are the different scenarios the very first scenario is character at index i at string i is equal to character at uh pattern j right first of all before that let us take care of the special characters in the pattern because that is where an issue can happen okay so i can say that if pattern j minus 1 is equal to dot then i will handle it separately else if this pattern is b right yes if b j minus 1 is equal to dot then i will handle it separately also if b j minus 1 is equal to what we say a star then also i will handle it separately else as in this case patron j is a character it's an english help of english alphabet so that means it should match the s i right it should directly match the character extinct at ith index right okay so that means i can say that if uh string i minus one is equal to pattern j minus one then only i can say tpij is equal to uh uh sure rather i will try to draw it after i have coded it and then i will try to rerun with our test case okay cool so now once i'm like once the character that i'm trying to match in the pattern is not a wildcard character then that means i can only match it with a character right why i can match this a of it of the pattern with only an a of the original character correct i'm like i can match this a only with an a from the from here is that correct so now let us try to see uh so that is the one thing now let us see what we will do if b j minus one is equal to a full stop if it is a full stop then what i can do a full stop can match with one occurrence with exactly one occurrence of any character let us assume that it p i j will be equal to nothing but bp of i minus 1 k minus 1 what this means is let us say i mean like the jth character of pattern matches uh matches ith character of a string suppose if the j character of the pattern matches the character of the string then basically i have to see if whatever the characters were there in the pattern before the jth character match whatever the string was there before the eighth character okay nothing else the problem becomes interesting if you are taking the wildcard character into consideration right because wildcard character can actually match zero or more than one occurrence of the previous character right okay now let us try to see how we can do that first we try to find that what is the character that came before p what is the character that came in the pattern before this start what i mean is that for this case for this case it should return me a c for this case it should return me a full stop for this case it should return me a full stop similarly for this case it should return me an a okay what i can say is that i think actually the previous element with the first character right yeah it will always be the previous letter i'm like we hope we assume that the patterns are defined so i can say that character previous character is equal to uh what we say uh the b uh j minus okay okay so what are the cases now the first case is that if the string at if minus 1 is equal to the previous character what does this mean this means it matches one occurrence of the preceding character okay so what the problem reduces to the dpij will be equal to nothing but bpi minus 1 j minus 1 because it has matched one occurrence of the previous character okay awesome then what are the other cases the other case is that it is not it's not equal to the previous character then that might happen that a i minus 1 uh it might actually happen that if the previous character is equal to dot if previous character is a full stop i mean like in this case i mean like in this case the previous character was a full stop so that means it will definitely match it right in that case it will definitely match it so in that case i can say that dpij will definitely be equal to dp i minus 1 j minus 1 that thing is clear then i will say else if a minus 1 is equal to the previous character and also this is correct uh but what is is there any other case in which this can be true in this case bpij should be false right because it should not match with anything else as dpij should be equal to false right can it match with something but if there are multiple c's and then there is a star let us take care of a case like let us say that there is a c there is a star and then i have this c c c c c so now whenever i will be computing this and this this will match when i will be computing this and this uh this won't match okay then when i will be computing this and this this will be equal to dpi minus 1 this match is still this this is also true but i will be computing this and this dp state then i will get this is equal to this matches this which is false right this can also match this section i should return dp else if a minus one is equal to the previous character dpij is equal to tpi minus one g because this will take care of uh the second occurrence of it as well right take care of multiple occurrences i mean like uh star can match multiple characters because this thing will take care of this right am i missing anything else and finally i will have to return bp and m but is there anything else that i seem to give me saying so i can say that if there is a full stop if there is a full stop then that means the particular characters definitely match and then the only thing reduces to a smaller sub problem so that is fine if it's an asterisk i'm like let us take care of this case at the end else i'm like both are english characters then they should directly match there is nothing better that we can do right because there is an english character there there's an english character there so then they should definitely match so dpij will be equal to actually dpi minus one j minus one why because these characters definitely match and whatever came before this should also match whatever came before this so this will be the state here now let us take care of this important thing if the previous characters are full stop then it will directly match it will definitely match right yes okay as a minus one is equal to the previous character as if a minus one is equal to the previous character that means these both are matching then this problem reduces to i'm like multiple occurrences of that right yes uh and okay suppose then i am saying ppi minus one j okay this matches this so let us actually take let us actually try to create the dp table for this thing this uh cc matches this c star now when i try to match this thing with this thing i will say that this uh c matches this c so the problem reduces to if this particular thing matches this particular thing that is true and then it will put you now when i say that if this matches this thing okay now this thing is matching this thing so that is good and now i will try to check if this thing is also going to match this thing but then here i will be having an issue how should i make sure that this this is true right so i should make sure that if there is a if there is a previous occurrence of a character then that can also be a zero right an asterisk can also be a previous reference of a null character because this asterisk can also represent that there was no occurrence still here right yes then dpij will be equal to dpi minus 1 j minus 2 if the previous character is also stopped that is correct but that can also be a previous sequence of nothing so that is 2 then that is 2. what are we missing here this particular case is a very difficult case to handle so as to have all the cases the bj minus 2 will be the character that was just preceding best risk right and that character can be a full stop that means it should match with any character okay but i might or might not want to match it right if i try to match it if i try to match the ith character of string with this full stop then the problem reduces to this problem or i might not like to match it if i don't like to match it then the problem reduces to dpi k minus 2 right a minus 2 will make it zero occurrences of the pattern of this character and the string till now this makes sense okay i now in this case i say if a minus 1 is equal to the previous character then either i will like to match it either i will like to match it and then the problem reduces to this or i will not like to match it right or i will say that i don't want to match it or this is equal to dpi of j minus 2 in that case if we take care of this string uh this problem will be equal to either i match this c with this c then the problem reduces to dpi minus 1 j which will be equal to matching this c with this c star okay or if i match this c or this reduces to dpi of j minus 2 which will be false now when i try to match this and this uh either i will match both of these if this is equal to this the problem with this is to dpi minus one j dpi minus one will be this and dpj will be this how can i match this i should somehow make sure that this is true right i think that is the only case that is left i mean like uh if we match this how should a c star match a c because this can mean a one occurrence of c so as this matches this the problem can also reduce to matching dpi minus 1 j minus 2 right or dpi minus 1 j minus 2 that will be one thing ppi minus 1 j minus 2 why this this will mean this is uh non appearance of this this is the second occurrence of this or more than second decimal means this was the only reference of it okay and this thing will mean what this thing make zero occurrence correct now this should be correct now the only question comes can our pattern be something like this c star star star start then i can also say that while first let us say that can that case happen in a moment in previous index is equal to what we say j minus 1 while uh previous index is greater than equal to 0 and pattern previous index is equal to star i will try to minus minus previous index so now my previous character will be nothing but uh b of previous index now if the previous character is a full stop the problem reduces to either i will match it now this j will be nothing but i think let us actually first try to see if what all cases does it pass let us then try to see huh so we are following we are failing at this case and why because this is a zero occurrence of this and this should match right and a b star c means see the openness of this so this should return to you let's actually try take this sketch and then see how we are going to uh create a string so our 2d page table will look like a and this will be c and then this will be a just like 0 0 as well so we have a this will grab b this will be a star and this will be c does an empty string match at empty string yes it does match now i try to see if all this are 0 if i try to see it as a match b this will go into this particular scenario right does a match a this will be the scenario when a i minus 1 is equal to b j minus 1 so this will be nothing but equal to this so this thing will become one satisfying it now the problem is does a match a comma b no it doesn't because b is also a character and b is not equal to a so this will not match then the question is does a match a b star right so here we will try to see that uh we have a star we have an extra sphere so the previous character is a b is a b yes we go into this case l schemes correct we found where the issue is dpij is either equal to dp of i minus 1 okay uh so i can match none occurrence of that i mean then it will be equal to dpi comma j minus 2 what it means is that it will only match zero occurrences of previous character right and it should match the zero occurrences of the previous character so now this particular case should be correct let me take it as a custom input yep so that case where we have handled now that thing is perfectly correct this can only match the hero appearances of the previous vector this means this will match uh dpi minus one j which will it will match more than one by like first or second second to greater than two greater than equal to two occurrence of the previous character this will match uh zero occurrences of the previous character and this will match the first occurrence of the previous character only one occurrence of the previous flight now this makes sense but if there is multiple stars then it might fail but first we have to see if there can be multiple stars right rest all should be fine yes and now the question is will it pass submit case can there be multiple stars together there should not be but can there be i'm like it's not specified in the input let's try to submit it abcd is not matching a dot star c dot star and this interesting but i was talking here we have told uh tpi minus 1 okay we have taken care of this case we have also taken care of this case we didn't actually improve this right this was the dpi minus 1 j minus 1 means one occurrence of the previous character okay dpi j minus 2 means more than one occurrence of the previous character this can also be zero principle of the previous vector right or not if if previous character is equal to this then the problem reduces to either i will match the previous vector with this then that is fine or i will reduce the problem to matching this with something else let us try to take this case and then see where we are failing abc bcd and a dot star c dot sub t in this case this dot star is representing this b and this dot star is representing this b and c okay b if it is a dot if the previous character is a dot then it can match any number of previous characters right yes then it can actually match any number of the previous characters so then we just have to find one of the previous indexes where it can match so that means this is equal to another order of n loop right this will be another order of n loop where i try to see if anything matches still here i'm like if there is any part of this substring till here that matches this particular index because pakistan because other other things i will just satisfy with this stuff with this full straw that makes sense so the only question reduces to this that if there was any star here right so then the answer will be to false let us see and i can say that for n i equals to 1 i less than let us say i is equal to 0 i less than equal i less than what is my current character i less than uh current l is equal to 0 and less than i plus plus l that means if there was any character any character where pp of l k minus 2 positive so was n is equal to tp or equals to ppl comma k minus 2 what i mean by this is was there any player like this that hey i mean when i'm trying to match this abc bc with this thing okay i will try to see if there was any pair that matched till here in this particular string after that everything i will measure the full stop okay so tpij will be nothing but was any this has increased my time complexity but hopefully should satisfy this case right this should satisfy this case correct it does so now is there anything i have missing because then i haven't still found that if there can be multiple characters interesting can there be first let us try to submit it and then we will know let's first try to test and then we will submit am i missing any other case i don't know cool i got it correct there was there is not a case of any character any star any multiple stars together but i'm like i hope you guys were able to find i mean like how we actually found the approach what were the different test cases that we had to see okay and still we missed out on some of the edge cases okay i will take up the doubts on this question as well as at the end uh but let us solve one more question for the day that people had requested and then we will take on doubts okay what is the next question the next question is the maximum path in binary tree let us do that question and then we will take the doubts so in the maximum path in binary tree we are given a primary tree that is rooted right i think we are given a yeah we are given a tree node so i mean like if you are given a tree node and then it's a dp problem that is still an easier problem why because you know the root of the tree and that helps you in some things uh so we are given a binary tree t and we have to find a path in the tree of the maximum circle okay and the path can start and end at any node so by the way i'm like what is the definition of a path a path is a sequence of nodes such that no node is repeated more than once so there is no cycle it's a simple path okay so now let us try to take care of i'm like let us see the examples first in this example the largest part starts from this 2 goes up to 1 and then comes down to 3 so that's the weight of the path is 2 plus 1 which is 3 plus 3 which is 6. so 6 is the answer in this case what is the maximum sum path the maximum sum path is only this node minus 10 okay the maximum sum path is nothing but only this node which is minus 10 okay now let us try to see that hey let us try to see can we include a particular node in the path how can we know i mean like what will be the weight of the path if we include that node in the path okay if we include this node in the path that means either i will have a path from the left side that will join it and a path from the right side that will join it what i mean is that suppose there was some tree like this that here is a one and here's a two and here's a three then uh here is a four and then here's a five okay so when i try to include the upper vala1 in my path then i will join it with one path that was going that was coming towards upside from the left hand side what was the weight of that path that that path was c to 2 with having a weight of 5 similarly i will also join it with a pass that will start at 4 and will end at 5 that will only be in the right hand side of the subtree this is also a very popular problem by the way so there will also i will also join it with a path that is from four to five and having a weight of nine okay suppose the path on the right hand side these nodes were minus four and minus 5 these nodes were minus 4 and minus 5. would you ever want to include these nodes in the path no right why because their sum will be less than 0 and that will be bad for me i mean like i don't want to subtract anything from the path that is a very bad thing for me so i will always add the maximum path on the right side with weight greater than equal to zero and the maximum bait path on left side with weight greater than equal to zero because otherwise it's it's going to reduce something from my bit so i don't want to do that so let me say that i can make a recursive function that will return with a maximum weight of the path from the left side node and the maximum weight of the path from the right side node so what i do is that a max path node which is passed a tree node okay in this case i'm like i always try to write the code along with the solution because that makes more sense i will say i'm like the base case is that if a is null in that case i can just return 0 because there is nothing it's a 0 okay s what i will try to do first thing i will try to find what is the maximum path on the left hand side which will be equal to max path node on me for left similarly i will try to find the right path it should be equal to max path node we will always try to have the paths have a weight greater than or equal to 0 right so i can make it the left path is equal to max of 0 comma max path node of a to left and similarly max of zero comma max path node with a right interesting now what should i return i should return the value at a plus left path plus right path that is the maximum path weight that will end at my current node a correct great so that thing makes some sense in fact if i know this thing then i can just i don't need to do anything else right i can just uh paste this thing here i don't need a separate function as well and i think this should work directly oh this is expert some now so and then let's try to test it this doesn't work why doesn't this work given a binary part 3 we have to find the maximum path sum the path may start and end at any node in the tree okay the number of nodes are 10 to the 4 so the integer overflow will never happen because the maximum path will be 10 to the power 7 something so that is fine if a is null i am returning 0 here i am returning something very big that is also not going to happen interesting val plus left path plus right path right that i am not doing wrong that is correct if left path is this i have to say max of zero comma this i i did return correct right i think yes this was an additional issue what happened the expected return value is seven three four seven okay and i'm returning something 90 3096 okay if e is null i return a zero else i try to find what is the max path sum on the left side okay and i also try to find what is the max path sum on the right side okay and then i return the value at that plus left path length plus right part length that also seems to be fine but why my answer is can i have a path from up to down yes i can have that and but i will return yes i got the issue but we are i mean what is the issue with this is suppose your tree is like this then what we are doing wrong is interesting i mean we can't have it in this function we should have another function which is which says in max path ending here okay and max path ending here is this given a tree node value at a so now i try to find what is the maximum path in both of those sub trees so this okay uh i try to do the exact same thing now if a is equal to null i do this and this is the same thing okay now i will have a global answer variable which will be initially let us say in and i will say that answer is equal to max of answer comma what i got from here i'm like that is a triangular path right that is a triangular path but now i can't return this part for example suppose there was a 2 here there was a let us say a 7 here okay this seven needs to know a very straight path that will be ending at seven so it can't include a path that will be three to one minus four minus five it should be one straight direction path right so i will return uh the a plus max of these two max of left path for my right path okay because now i need only a one pressure but i don't need a cross and a straight line path right that is wrong so answer is equal to int min so i will always have to set it in when i start the function so answer will be in pin that makes some sense then i will compute the left path i will compute the right path and i return this great so i will just do a uh what we say max path ending here of a and then i can finally do return so that should be correct that should be correct earlier i was passing this thing completely there which is totally wrong answer is equal to max of answer eval plus what is the issue here okay i missed a semicolon or did i miss anything else seems fine return a val i think this was answer that was supposed to be written i'm not really sure but this seemed to go bad yes yep so i hope you guys were able to understand that what my function was returning was a path that could be like this and then something here so this was a triangular path which is not correct so then it will cause an issue on the upper side okay so then i try to let this operate it and it should be working okay we got 389 out of 400 points interesting let's uh briefly watch the uh n log n solution of the longest increasing subsequence and then we will end the lecture okay now suppose you are creating a subsequence okay now let us say my subsequence is like this i'm like i'm not going to explain that solution in a lot of depth now because we can discuss it in the section that we will be discussing i mean we can have a separate video on discussing this as well in fact that will be a very good thing we can upload a video there to the channel but uh i'm like i will still try to give a kind of an intuition to this okay uh suppose we get uh i'm like uh we are trying to create a longest increasing subsequence okay when we get a zero when we get a zero our initial subsequence will be only zero right this will be the initial subsequence okay now when we get up eight where would you like to put this eight you would i mean like it makes total sense to put this eight here correct okay then we get a four now we try to see where can we put this for this fork should i mean like replace a particular number right this 4 should replace a previous number but this 4 i'm like by the way do you guys i mean guys try to see that this particular area that we are creating is sorted is always sorted okay now we try to see which four uh i mean like which four can go where out of these two zero comma eight comma zero comma four which is a better thing to take zero comma four is always a better thing to take right because 0 comma 4 can later be expanded to 0 comma 4 comma 7 of size 3 but 0 comma 8 won't be able to so 0 comma 4 allows us more scope to expand it right so what we do is we try to find the first number in the current increasing subsequence that is greater than that is greater than 4 okay so we find this 8 we replace this eight by four and what is the length of the current subsequence it is still two right what is the length of the current largest subsequence it is still two great then we go to twelve we've tried to find the first index that is greater than 12 there is no index so that means we put 12 here now what is the on what is the length of the largest subsequence it is three so basically try to see that the array that we are maintaining is is storing the length of the largest subsequence that will be our answer now we go to 2 we try to find the first index that is larger than 2 we find this is 4 we've replaced this 4 with 2 what is the length of the largest increase in subsequence till now it is still 3 and by the way if you would have seen till till here the length of the largest subsequence is 3 right great now we try to put 10 we put 10 we find this is the best place we replace this by 10 and what is the length of the largest subsequence till now it is still 10 and also if you would have seen the length of the largest subsequence till this place is also 3 right okay now we go to 6 we replace this 10 by 6 now we go to 14 we for there is no number that is greater than 14 so we put 14 here and what will be the length of the largest subsequence now it is 4 and you also see that the length of the largest subsequence is 4 here ok now let me try to write the code and then the other things will start becoming more clear to you ok so let me comment out this code this was the dp code and let me write the binded search code now initially my current array will be empty okay then i will say for i equals to 0 i less than n plus plus i first thing i will check if array i if uh i'm like if current array dot empty or array i is greater than what we say current array.pack if any of those two cases is q in what does that mean if these cases is true that means i will the push number right because here 14 was larger than whatever was here that means six so i just pushed back 14. i increased my the size of my current area with one okay then what is the other case in the next case i will try to find first index that is greater than or equal to the value greater than equal to ai okay how can i do that as the current array is always being maintained in a sorted order i mean like if you would have observed this about thing this would all this would have always been bacteria in the sorted order i can bind research this i can say l is equal to 0 r equal to 0 and i say while l is less than equal to r made equal to l plus r minus l by two if array made is uh greater than equal to array i i will say anse i mean like index is equal to mid r is equal to minus 1 this is normal binary search okay else l is equal to minus 1 i am i'm basically trying to find the first index that has the value greater than or equal to bit okay so i will say end in is equal to minus 1 and what i do after this i just change my current array into [Music] array i okay what should rb r should actually be equal to current array dot size minus one awesome uh and finally i can just return my current error.size because that was always storing the length of the largest in in largest uh increasing subsequence till now let us try to test it yep and this is correct and this is somewhere now what did i do  okay again i'm failing at this case oh i have a runtime error why do i have a runtime error i save current array dot empty or array i okay i have to find the very first index that is greater than or equal to the current number okay can the index be minus 1 can it happen that all the numbers are greater than or equal to the current number in that case i will just return 0 right in that case i will just okay when can index be minus 1 this can be minus 1 if all the numbers in the area are smaller than so yes if all the numbers are smaller than that so i can say if index is equal to minus 1 that means all the numbers in the array are smaller than that number then this will be happening right if index is equal to -1 when can that happen that can happen only if all the numbers are smaller than that all the numbers are smaller than that because if there was any one index that was greater than or equal to a i then i would have uh changed my index to that mid right and i'm saying that all the numbers all the indexes are smaller than that as if array bit is greater than equal to array oh sorry we have to actually check as if current array made okay so this is the issue it should be current arrangement all right let us test it so we if we just had an aiming issue and we were checking array mid which should have checked current area this i mean this is running this is running wrong that is another issue i say that okay and i can then set the current array it's greater than equal to index is equal to mode if current array made is greater than equal to ai then that might or might not be the first index then i try to reduce it okay current error.pushback is correct my current error is the array n is equal to zero r is equal to current error.size minus one that is perfectly fine i say while l is less than equal to r i try to find mid i try to see what is the number at that mid index is it greater than or equal to the current number that i'm going to add if it is greater than for example suppose i was going to add 15 here i go to 6 is 6 greater than or equal to 15 no it is not so i will have to search here is 14 greater than equal to yes uh huh 14 is also not so i will go here so let us say that we were trying to add a number three let us say we were trying to add a number three i try to see here i'm like is six greater than equal to three yes it is so it can be the answer or the answer can be somewhere here correct so and i'm returning the current error dot size that makes some sense that makes the sense but why is the answer 14 why is answer 4 in this case the answer should be something like 14. so i try to find the first index then index is equal to mid if index is good this should not be happening oh this is fine yep right because of because i had added that if condition while debugging i forgot to remove that that was true correct we got all the points correct i think many people don't know know that this problem can also be solved in n log n in this small code only okay so in this small code so that was a new thing so today's session is on the dynamic programming day two so here i have the questions and the questions demand uh that has been made is of buy and sell stock so let's dive into that question okay let's get started um say you have an array for which the ith element is the price of a given stock on day i okay you have to design an algorithm to find the maximum profit now you may complete as many transactions as you like that is buy ones buy one and sell one share of a stock multiple times however you may not engage in multiple transactions at the same time that is you must sell the stock before you buy again okay so um let's actually see the example and let's see what it means so we have an integer array which is the which represents the device stocks that are available now the output is two that means so here it says that we have bought this stock on day zero that means one and we have sold it on date one okay first of all let me name them so let's utilize this space let's say we have um so this is index 0 1 2 and index 0 we have 1 2 3 so we bought the stock on day one on day zero and uh we sell it on day one so we get the profit of one right and if we buy it on day one and sell it on day two so that will be again be a profit of one so that means total profit is equal to two so that is what this example is saying and if we look at the next example so we can buy the stock on day so it says that buy the stock on day one that is uh cost is two and sell the stock on day two that is at this right so that means the profit is 10 minus two and that is eight now the thing it says is that we can buy and sell multiple stocks but the constraint is that we cannot keep on buying the stock and keep storing it with us and with the intent of selling it later we cannot do that so please understand this problem many people feel confused with the problem so it says that once you have bought the stock first you have to sell it and then only you can again buy it and then sell it right so that's what the problem is so let's say we have seven one five three six and four okay these are the prices of the stocks on days so zero one two three four five are the days now let's talk about the brute force solution first okay now the brute force solution would be that i can buy the stock right so i can buy the stock here and then i can see that when can i sell the stock okay so if i buy the stock at first i see at zero today then can i sell the stock at any day no right because this stock is greater than it has a greater value has a greater value than any of the stock right so therefore i cannot simply sell this stock let's move to the next element now on the next element if we buy the stock then we can sell it on day two we can sell it on day three on day four day 5 right so now the possibility is that let's say i sell the stock on day 2 so that will give me a profit of 4 and plus now there is a sub problem isn't it so the i will add the cost to the sub problem and the sub problem is of 5 3 6 4 isn't it now this is the sub problem that i can buy try buying this stock and sell it for on the further days so just what i have discussed now will be applicable to all the sub problems okay so this is the case when i have sold my stock of one on day two that is at the cost of five that will give me a profit of four now if let's say i sell the stock on day three so that will give me the profit of two and i have a sub problem which is three which is three six four right likewise if i sell the stock on day six so that will be a profit of five and that will be uh giving me the uh sub problem of six and four right and if i sell the stock uh stock on day five so the profit is of uh 3 and i will get the sub problem of 4 right so this is it now this will happen with every element okay so as i move to 5 this will happen with 5 as well that i can so first of all when can i sell this stock of five so i can sell it on day four right so that will give me a profit of one and uh the sub problem is of six and four so four five that's it right then we will move on to the next element and three can be sold on day four so that means give me a profit of three plus six comma four and i can sell it on day five so profit is of one and the sub problem is this right so likewise i can keep on going on and that will give me these sub problems for every element okay now the thing is that there are n elements and if you see from the from this uh visualization that i have created on in here so if you see on the first level we are for n elements we are having n iterations we are having n possible cases so that will give the time complexity of order of n square right yes so goyal t by uh yes you can so if you are buying a stock on first day and if you are selling the stock on the second day then you can immediately buy the next stock on the second day okay so if you see from the problem that has been given on the platform then you'll be clear okay cool so now for n elements at the first level we are having n possibilities so the time complexities of n square now this is happening n times isn't it for every element this could happen n times in the worst case so uh that is the first level right and now such that i'll be having the next level having n elements n possibilities for n uh elements right then again at the next level i'll be having n elements and so on so that will be like n into n into n and so on so it will be n to the power n the time complexity is of n to the power n which is very huge okay which is very huge so now let's see how can we optimize this using dp so this was the brute force approach now let's see so uh we have 7 1 5 3 6 4 okay let's say this is my dpra here this i'm going to do in bottom-up fashion okay i have a one dra now if let's say i have only a single stock then is there any point of uh so there there won't be any profit right will there be any profit no right can we make it 0 so here we can put the value 0 okay we can put the value 0 now so basically at dpi i will say that it will be nothing but maximum profit we got by doing transactions only till that it position okay so if let's say i am here then this is the let's say the last point where i will be calculating the profit for and that i'll be doing for every element okay cool now i am at uh this index i am at uh this position now the thing is that either so basically we are actually taking it in a way that uh what profit can i achieve on this iii okay so i can either sell a stock or i don't sell a stock if i don't sell a stock that means whatever is present over here will be my answer okay but if i sell a stock then i'll be actually moving from the first location till the i minus 1 is location to check if there is a value which is lesser than this value on which i can so let's say i am at index this okay now for this index let's say this is i and j is at this position so basically either i can not i do not sell any stock on this day or let's say i sell a stock this on this date why am i able to sell stock j on this day because j is lesser than i right element at j is lesser than i so that i have to keep on checking so there are two uh two uh possibilities now that i can sell a stock on one day on that particular day or i cannot sell a stock on that day right so here what we will get so the idea is that for i which goes from 1 to n minus 1 okay and let's see this is our dpra and dp 0 will be initialized to 0 now uh we'll be doing for j which goes from 0 to i minus 1 okay what we'll be doing so also what we have to take so we have to take that when we are not considering the element so in that case whatever is the answer at dpi minus 1 we will have that okay we will have that now uh this is the case when i am not selling the stock on that particular day now when i have to sell so i'll be moving through this loop what i'll be doing is dp of i will be equal to maximum of dp of i okay comma comma d a i that is the uh so wait a minute it will be whatever the profit is at dp of j plus a of i minus a of j so this is the additional profit that i have got while selling the stock on day i that i have bought on day j so this is the profit and this will be added to whatever is boss uh was the profit on dp of j is that clear is this thing clear that whatever was the profit on jth jth day that will be added to the profit that i have achieved now okay so this is what the idea is and this we'll do for all the elements cool and the time complexity would be order of n square right we have two roots so from order of n to the power n we have actually come to order of n square are you guys able to relate that why it's order of n square now how are we processing through this how are we moving through this is it fine guys cool so let's code it quickly and then we'll move on to the more optimized solution okay so let's quickly record it so we are taking an array right so in bp first of all let's consider the size as well okay so here i have pin 10 where i'll take the size then if n is equal to is equal to 0 or if n equal to equal to 1 then we'll return 0 okay cool now let's move ahead let's create our dpra and let's initialize all the elements to 0 so dp of i is equal to 0 now moving forward so we are going to all the elements starting from index 1 okay so starting from index 1 we go to all the elements and what we'll do we'll put the dp of i is equal to dp of i minus 1 that is when we are not selling the stock on day i okay but when we are stalling uh selling so we have to check that when that stock was bought okay we will go from zero all the way when j is less than i and j plus plus now so it will be nothing but dp of i is equal to maximum of bp of i comma bp off uh j plus a of i minus a of j okay and then you simply return b p of n minus 1 let's see if this works cool it worked okay so we have actually got the partial points now this can be further optimized okay let's see the optimized case now so here um let's move forward now this can be further optimized if we make some observation okay so what i'm doing over here i am actually whatever was the profit on day j i am adding it to my current profit right okay so here we have this solution cool now dp of j plus dp of i minus a i minus aj we have now if i if i tweak this a little so what will i get i will get a i plus dp of j minus aj can i write it like this can i write it like this okay so now to inc so basically we have to increase our profit okay to increase the profit i want this to be increased and for that i want this to be increased right so to increase this that is the difference shall be increased okay so for that for that we can maintain so we we were just iterating through the j loop to get this difference so that this could be maximized we were checking for which j value is this difference maximum now instead of iterating through that j array we can actually keep on storing the maximum value of this till now okay till now does that make sense we were only moving our j loop for checking that for which value of a j are we getting this are we uh getting this as the maximum so that our complete the complete value is maximum right so instead of going to each jth position we can actually store this particular value in a variable and then we can keep on updating that variable yes the greedy method is of order of n time complexity and we'll also see that how this can be changed to order of end time complexity okay okay does that make sense so uh let me just code this thing now or let me just code it if you still have any issue we can discuss it okay so let's just proceed now so uh here basically we have to change we have to um remove this loop okay so for that basically we have to keep on storing this particular value as in we have dp of j plus we have this here now i am changing it a little to get a of i plus bp of j minus a of j now i am trying to store this value so here i can maintain a maxi variable let's say which is initially is equal to 0 minus a of i a of 0 okay so basically this will be gone this will be gone and we have max c is equal to sorry first we have to update the dp of i so dp of i is equal to the max of max of dp of i comma a of i plus uh plus max c right so basically here this value has been replaced by maxi okay and also we have to update our maxi variable max equal to maxi comma or dp of i minus a of i okay and here we go so now we will simply so here we have actually eliminated the jth loop does that make sense to everyone now let's see if this works let's see it and here we go cool we have actually got the solution correct we have got all the points so now this is the solution of order of time complexity is equal is uh so time is order of n square right sorry order of n and space is order of n only right order of n but the space can also be optimized in this case the space can be optimized if you carefully notice over here uh then we have so basically dp of i is equal to dp of i minus 1 for every ith position we are actually we only want we are reliable on this dp array because we want dp of i minus 1 so if we store somewhere this dp of i minus 1 and if we utilize it in some way so then we can you know actually do it in just order of one space now i want you i want you guys to try that thing so here we are at uh time of order of n and space of order of n so let's move on to the next question and the next question is minimum jumps array so this is a very uh very important question so given a given a non on array of non-negative integers a of length n you are initially positioned at the first index of the array each element in the array represents your maximum jump length at that position to return the minimum number of jumps required to reach the last index if it's not possible to reach the last index then return minus one okay so the first and the only argument that we have here is of integer a now let's see uh what the problem says with the help of an example so we have 2 1 1 and the i is 2 1 1 so the output is 1 why because the problem says that from index 0 we have to reach the last index so we can take simply the jump of 2 to reach the last index so the element at that position signifies that how many jumps we can take at max okay we can take the jump off one we can take the jump off two for this particular variable here we can take just the jump of one again we can take the just of just the jump of one so let's say i have 2 1 2 3 1 1 4 okay now let's maintain the dp so here we are going to do the dp thing so this is the bottom of dp that i have taken so basically if i talk about the brute force approach in this case then what we'll do we will check till all the so whenever i'm at some position i can go to from here this is true so i can go jump to here or i can jump to here right then i can i will again call for this part as well as this part okay till the position that i can jump for the first element then after jumping to let's say three i will call for rest of the sub problem and after jumping to 1 then i will call for rest of the sub problem so this will go on for every element right so this is the brute force solution now let's talk about the dp solution for dp solution we have we created the dpra let's name it zero one two three four okay so basically the dpi signifies that till that particular position how many minimum number of jumps we can take okay so dp of i tells the minimum jumps we can take from 0 to i okay so at from if we are standing at this position then we don't have to take so considering this position as the last index we don't have to take any jump so this will be zero right now if i am at index one then from index so uh for uh fro so to calculate the number of jumps to reach index one that means so let name it here one zero one two three four okay if i want to go to index one then i can i have to start from zero till i minus one okay i will check that from index so let's start j from here i will check that if from this position i can go to this position or not how to check that we will do it in way like 0 plus that is the index j plus a of j if it's greater than equal to i that means we can move from index j till index i so this is 0 plus 2 that is 2 it's it's greater than equal to 1 here one is i so we can move from this element to this element and we will get what we will get nothing but the cost the jumps we need to reach at this position plus one does that make sense now we come uh so uh we are done with this these positions now we go our place we place our i at here and j will again be placed at 0 okay so from 0 can we move to this so this is nothing but 0 plus 2 and that is 2 2 is greater than equal to 2 we are at index 2 now so yes so that means there'll be nothing but 0 plus 1 so 1 will come over here now our j will move to this position let's see if we can from j till i so this is nothing but a 1 plus 3 that is 4 it is greater than equal to 2 so yes we can jump from this position that is from this position to this position and that will be nothing but whatever is present at this position plus 1 so we have to check that if dp of i is equal to max of dp of i comma uh comma dp of j plus 1 so right now dp of i is maximum then dp of j plus 1 so it will remain one okay and this we will go on till the loop is completed okay let's code it up then we will complete the array so we have so we will take the size of the array and if the size of the ra is equal to is equal to one that means only one element so we'll return zero if the size is equal to zero but if the first element is equal to zero in that case we will return zero right we will return zero sorry if n equal to one we will return minus one because if we cannot take uh if he cannot reach to the end element okay sorry this will be minus 1 it means we cannot go right now let's move on let's dp is equal to dp of n now dp of zero be zero so for in i equal to zero so sorry we will start with one uh i less than n i plus plus and dp of i shall be initialized to into max cool now what we have to do we have to run our second for loop that is into j is equal to zero till j is less than i and j plus plus then if okay so dp of i is equal to maximum of bp of i comma comma we have dp of j plus 1 okay and we will at the end return so if if the last element was reachable that means if dp of n minus 1 is equal to is equal to int max right so that means it was not reachable in that case we will return minus 1 else we will return bp of n minus 1 okay where did it fail uh okay so we actually didn't check the condition here the condition needs to be checked that if a of i if j plus a of j is greater than equal to i and also we have to check that if uh bp of j is not equal to max why because it's a possibility that we could not reach dp of j right so in that case but if we can so we will calculate right now let's see okay sorry this should be minimum right okay we actually have got the partially correct solution because uh because the thing is that uh this is also possible this uh the solution to this problem is also possible in order of n that is the greedy approach i got i want you guys to uh explore that approach okay here we have discussed the uh [Music] so if anyone has any doubt you can ask in this particular solution so alind we are adding aj to j because we are checking that if from jth position if we are able to go to i or not okay why are we doing j plus a of j because we are checking that if from some position will we be able to go or not okay so if we are at this position and we are trying to jump to this location we won't be able to go because we can only take at most two steps so that's why we are checking j plus that is this is zero so zero plus two that is 2 it's it's lesser than the index of index i lets i is here and therefore we cannot jump till here and therefore we are checking the condition okay is that clear sure let's let's move to the next problem and next problem we are taking is of edit distance okay the problem is first of all it's very important so the problem says problem is important because it is asked in many interviews okay it's very common and uh you should definitely understand it like how it works so let's dive in the problem so it says that given two strings a and b find the minimum number of steps required to convert a to b okay each operation is counted as one step now you have the following three operations per word permitted on a word the first is it says that insert a character okay delete a character and replace a character so to convert us uh string a to b i can do these uh three things okay and uh i have to find the minimum steps that i can take to convert one string to another string for example in the input let's say we have a b a d and uh we want to convert it to a b a c so here we can simply replace d by c right and that will give the cost of what one right now here in this case uh it says that the cost is two why because here we are replacing s with t that is the that adds to the cost of one then here we are actually inserting so after uh converting this s to t we will be inserting i okay so that will add up another one and the cost will be two okay so uh is the problem clear to everyone so basically we have to convert a given two strings are there right so we have to convert string a to string b we can make three possible conversions with each character that we can uh replace a character we can insert a character and we can delete a character okay so we have to do it in minimum possible time a minimum possible steps so let's see so let's say i have sunday over here and i want to convert it to saturday cool so what can we do here day at the end are same so now we can actually convert this sun to saturday and what we can do we can so this is also same right so that means we are left with u n and a t u r so we can insert uh we can insert what so guys here we are going to do it using 2d dp the bottom up approach okay uh here i have actually so we are trying to convert this string to this string okay let's see how we'll proceed here we are going to convert this string to this string we have to consider the empty cases as well when let's say this string is empty so this is that case and let's say this string is empty so this is that case now if if we want so this is what we have to convert in so let's say if we want to convert this to this what we what we'll have to do what should be the output here it shall be zero right i don't have to do any operation now if i want to convert this empty string to s in that case i have to add one character if i want to convert this empty string to s and a for that i have to add two characters then three characters four characters five characters six characters seven characters and eight characters right so that's what i have to do now what if we have to convert this string to just an empty string in that case in that case we have to delete one character then we have to delete two characters right to convert sunday to empty string you have to delete three characters to sun to conv sorry to convert sun you have to delete three characters to uh convert s-u-n-d to empty string we have to delete four characters then five characters and finally six characters okay so this is the base case this is the base case now the point is that whenever so add to some if we are standing at some position right let's say we are standing at some position then we are actually trying to do what we are trying to see if i want to get the answer till that particular position that means i want to get the answer for this and this right answer for this and this part then what should i do so please note that this is let's say the box and we are standing at here okay now this is the case so this is the case when i'll be ignoring the current characters okay when can i ignore the current current characters when the character at this place and this place are same then we can ignore them and we can take whatever the value was previous previous right whatever the value we had so we can take this value we can take this value okay we can ignore and we can so let's say i have so they this and this are same right this and this are same and the corresponding block is this so we can ignore this and whatever is the result from till here and here we can consider that okay we can consider that so i hope it makes sense that why are we taking this position if there is a match i minus 1 j minus 1 when there is a match okay now this is the case so just the position above the current cell this is the place when we can insert an element okay so this is for inserting an element so when we have not found a match and we want to insert an element so we will pick up the so that means let's say here we are okay and we want to insert an element so we will be checking this particular location okay we'll be checking i uh i minus 1 j jth position so here we have i minus 1 and j and then for deletion we'll be checking i comma j minus 1 okay why because if let's say so let's say we are at this block only and or let's say when there is not a match let's say this block now this is deletion by the signifies deletion that when we are not considering this so when we are just considering when we are just so we are ignoring this character and that means we are just checking what was the result for this and this string okay so then at that point we can we can uh take the this value okay make sense that we are ignoring this character we are deleting this character and we are checking that what was the maximum when we have ignored this character okay because if we are ignoring that means we don't have to check for this particular position whatever we will be the value ignoring this character we will take it from its left cell okay now let's proceed with our ex let's proceed with this let's see what we'll get let's try run the approach cool so here s and s match therefore we can ignore them and take whatever is present over here that is zero that means we have to make no changes and therefore the steps are zero now we go to this sun s and um so we go to this s and uh u they don't match whatever so whatever is minimum at this location or this location or this location we will take it and we will add 1 to the cost because now we are considering these elements as well okay so 0 is minimum we will take 0 and add 1 for the current operation now let's move on so we have now we will be checking for so let me uh fill it so s and s and u so we are at s and n they don't match we will take the minimum of this this and this so one is minimum this becomes two now s and d so s and d s and d also don't match the minimum is two this becomes 3 now s and a don't match minimum is 3 this becomes 4 s and y don't match minimum is 4 and this becomes 5 now we are at this element and we will check again so a and s doesn't match minimum is 0 we will take 1 then a a and u don't match so 0 is minimum we will add 1 to it a and n doesn't match two we'll get a and d for a and d what we'll get we will get three then here we will be this match right so we will take this cell so add one to it sorry we don't have to do anything we will just take it okay we don't have to add to it cool now a and y are there so four will come over here then so likewise uh shall i fill the complete table or it makes sense now is it clear that we have to have to take the minimum of the three cells that is the above the uh on the top left corner on the or the so either so if you are standing at this so minimum of this or this or this okay so let's code it and finally finally we'll get our result at this location okay because ultimately we are considering the complete string the single cell actually tells that what is the value the jump still that particular position okay the last cell will tell us the final result so we will return the last cell so we have the let's take the string length in some variables so let's say m is equal to a dot length and n is equal to a dot b dot length we will take a 2d dp where it will be of a size of m cross n right and the first cell will have a value of 0 right because that will signify the empty strings so to convert an empty string to empty string will cost us 0. now what do we have to do so basically we have to do the base cases thing right so i is equal to ah 1 you start from 1 i less than so rows is m right and ok so string a is equal to so we have string in tie equal to 1 i is less than equal to okay so here the string length and we will be going through all the let's say all the columns so that is n okay and i plus plus so that will be bp of 0 i is equal to dp of 0 i minus 1 plus 1 what are we doing we are actually initializing our base cases okay we are just adding the values from the previous cell on the top rows and the top on the top row in the top column enter j is equal to let's say 1 and j is less than equal to m j plus plus now bp off so dp of j 0 is equal to dp of j minus 1 0 plus 1 okay um cool now let's move through all the cells that is it's equal to m and i plus plus then 4 into j equal to 1 then j less than equal to n j plus plus then in let's say we are taking the storing the distance like this so q1 denotes the cost uh c1 let's say cost is equal to dp of i minus 1 i minus 1 j okay so this is the cost when we are inserting an element in c2 equal to bp of i j minus 1 this is the cost when we are deleting deleting the element and this is the cost of replacing the element okay i minus 1 j minus 1 by replacement it means that we have change the character to the character that we want now if the current character if it's same right i minus 1 is equal to is equal to b of j minus 1 so at this point bp of i j is equal to dp of i minus 1 j minus 1 right we don't have to add any cost because the characters are same else what do we have to store so we have to store dp of i j is equal to 1 plus minimum of q 1 comma minimum of q 2 comma q 3 okay and finally we will return b p of m n o um these are not q and q two these are c one c two c three okay dpo into m is equal to a dot name perfect m n dpo of m plus one right sorry so it should be m plus one okay let's see now cool we have got the solution cool so uh let me actually uh make you go through the thing the question that we discussed previously i think most of you of you had doubt in that see we are doing dp and we were doing it in bottom bottom up manner okay notice that what dp so you should know that what the state of the dp is right what these cells represent and that actually tells what's the state of the dp so this is the dpi and this is the given array now the state of the dp says that dp of i is equal to maximum profit by doing we have got by doing the transaction till that particular point okay if we are standing at here then from zero till this point what are what is the profit that we have achieved so that's what the dpi of i tells is that clear now moving ahead at position zero we cannot sell this stock even if we buy so therefore the profit is zero now if we go to the next position so here we have to check for we have two options either we can take this up we can sell the stock on this particular day to get the profit so that is uh one sell the stock second is don't sell right so these are the only two options now in case of sell the stock in case of sell the stock we will start so let's say we are at position this and for selling the stock we will start from this position all the way till this position okay till i minus 1 this is i till i minus 1 we will go we will check if the value if the value of jth element is smaller than this element right and also uh what we will check we'll check that whatever is the value at let's say j is here uh actually let's say j is here okay now whatever is the value till this point we will add to the uh profit we have achieved by selling stock one on by selling selling the cost of one on uh for cost of three that means dp of j plus a of i minus a of j makes sense does that make sense that y is this condition for now this is why we have taken this thing okay so this is the case when we are selling the stock we will check for every i we will for every i we will check for every j starting the j from 0 all the way till i minus 1 we will check for this condition and there is some other case as well when we don't sell the stock if we don't sell the stock then we take whatever is present on its previous day so let's say we want to see the cost of this so if we are not selling on this day then we are actually checking whatever is present on here will come over here okay so whatever is maximum whatever is maximum from uh whatever is maximum between this that is when we are selling the stock and when we don't want to sell it shock so whatever is maximum we will take that value in here does that make sense so that's essentially what we are doing okay so that's what the two that's what the dp solution is of order of n square okay the pseudo code says that we'll take the dtra then dp of 0 will be initialized to 0 because of the condition i told over here that we can if we even buy it we cannot sell it and we will go all to all the elements starting from position 1 all the way till n minus 1 and if dp of i is so here we are actually taking the previous dpi that means we are actually not this is the case when we are not considering selling the stock on day it so therefore we are taking the uh cost till i minus 1 we are taking the profit till i minus 1 day i hope that makes sense now moving ahead if we want to sell it so we are going from j uh we are going j equal to i minus 1 right and we will be taking whatever is maximum between dp of i minus 1 and this condition that i told you okay so this is the condition when we are taking stock uh when you are selling stock and this is the condition when we are not selling not selling okay now this will do for all the elements and that will take the time complexity of order of n square now i said that we can optimize it so if we see this particular condition this condition right in this condition we want to maximize this condition i have actually changed it to this okay i have uh changed it and this i have got now so to maximize this this should be maximum right now we are actually iterating in this j loop to find that for which value of j this is maximum for which value of j this is maximum okay so instead of going through every element and checking for which value of j this thing is maximum we can actually keep on storing it from the start okay so that's what we are doing over here that we are storing it from the start we can actually maintain a max variable let's call it max var okay and this scan so initially it will be initialized to dp of dp of j which will be nothing but 0 initially the dp of j is 0 right and we will be doing 0 minus a of j okay minus a of j so we will get dp of 0 minus a of let's call it variable only okay let's call it variable uh equal to a of 0 okay this will be initialized now whenever we are we will be moving in a loop right so uh let me write it so for i dp array dp of zero initialize to zero variable let's let's call it maxi only okay now it will be initialized to dp of 0 minus minus a of 0 okay so for i which goes from 1 to n minus 1 dp of i is equal to dp of i minus 1 when we are not selling the stock so we are taking the stock of the previous day now if we are selling the stock so we will do dp of i equal to maximum of dp of i comma what we want a of i plus max c and then we will update this maxi variable to max of max c comma dp of i minus a of i so essentially we have done it in just order of n so today is the third and the final day where we will be solving particularly tp problems so we will start with the road cutting problem and uh if there is any other uh request for a problem that you want us to solve please do mention in the comments or i will pick up any two randomly okay great let us begin the problem says that there is a root of length n okay on x axis so basically it's a horizontal road with its left hand at x is equal to zero and right end at x is equal to n okay so basically n plus one points are there now there are m weak points out of those n plus one points uh denoted by positive integer values or less than n so basically there are m a one to am weak points okay you have to cut the load at all these weak points okay so we have to make a cut at these points such that you can perform these cuts in any order after a cut road gets divided into two smaller sub-roads yeah because it will be divided okay cost of making a cut is the length of the sub-road in which you are making a cut cost of making a cut is the length of the sub-road in which you are making a cut okay your aim is to minimize this cost okay return an array denoting the sequence in which you will make cuts if two different sequences of course give the same cost return the uh lexicographical is smallest okay okay basically we have to give the sequence of points in which we will cut right and the point should be lexico graphically smallest and we have to uh basically we have to denote the sequence as well okay that will be the sequence in which we will cut so basically there is a road one comma two comma five so that means uh i will first make a cut at so this is the i have to minimize the cost so minimum cost will be here in those two and out of these the minimum will be two comma one comma five so i have to return two comma one comma five uh got it thicker so i mean like the problem to find the minimum seems to be a simple dp problem that hey i'm like uh dpij can represent the minimum cost uh the minimum cost to what we say uh to cut from index i to index j that can be a possible thing but so uh let me say that what is the value of this n okay the n can be up to 10 to the power 9 so basically we can't create a 10 to the power 9 pp table anyway so we have to do something in terms of m so if i have made a cut here then let me think of the dp table look in any dp question when it comes i try to first find that what the state relation can be uh and i haven't seen this question earlier so let me think what the status where the tp state can be so for example n is equal to six and a is equal to one comma two comma five okay let me i mean like when uh the values are not given uh is m always less than n or less than n okay by positive integer so a 1 will be greater than 0 and am will be less than n so let me say i add 0 here and i add 6 here because padding often helps in such tv problems and then if i create a 2d tp i'm not really sure if i should create a 2d dp but if i create a 2d dp then it should be then the answer should be let us say that the indexes are uh zero one two [Music] three four so my final answer should be in tp zero to four chicken uh which will represent the minimum uh sum of costs to split roads right okay let us say that we said this uh so abhishek has asked to please explain the question share a mistake let me explain the question again so basically we are given a road of length n on these road there are some points there are m points like a1 to am where we have to make cuts on the road okay the cost for a cut is equal to the present length of that particular road for example suppose there is initially the road of length six suppose you make the cut two suppose you first make the cut at position two or position one at or position 5 the cost that will be added will be 6 because that is the current length of the code now suppose you had earlier made the cut at 2 now when you will make the cut at 1 the length will be 0 to two right the length will be zero to two which will be three so the cost edit will be three so that is i'm like then you have to find the minimum permutation of cuts such that the total cost is minimum so suppose that is the minimum cost or minimum sum of cost to split roads from index i to index j okay and that means i can make cuts from index what we say i plus 1 to j minus 1 let us say that we say this i mean like i can make cuts from index i plus one to j minus one let us say i can make cuts uh suppose that particular index is k okay suppose that particular index is k then after this the problem will reduce to dp of uh i to k because i have already made a cut at k plus bp of k to j plus what is the current length of that right so okay i mean like i i can say the minimum sum of cost to split loads such that uh then i think i should change that such that the current road is from is of length i to j is of length i2j i mean k minus i plus 1 or what we say ai to aj if this seems to make some sense okay then uh then i will add but basically what is the current length of the code uh of the road that will be ak minus ai plus one right here minus ai plus one although it'll be equal to aj minus bi so this bp relation seems to be fine i'm not really sure let me say that okay i will first i have to uh okay first let me actually put the zero and this n in the array p make a smaller add it okay uh if i pad it then i will have to say that b dot push back let me just make it a comment push back a a is the length of that then i will say reverse b and i will p dot push back 0 then i will again reverse it so as to bring it to the correct position okay tool this seems to be fine and now if i have padded it now i have to create a dp table i have to create dp table of this length right uh the new length is what we say the new p dot size so i will create a dp table of n cross n vector of vector of n p p of n plus one comma vector of n tp of n plus one uh one thing is that it is not given to us that uh what is the value of this m going to be uh so i hope in order of n square solution passes order of n square solution in time as well as in space but i don't really know okay so uh this will be the dp matrix that i will create but will be the base case for this the very first case will be of length three right all the length three cases i have to handle because that is where i can make a cut okay so i can say for end length equals to three and the maximum length will be n right 1 2 3 4 right so n will be in this case n will be 5 so it will be less than n for in length equals to 3 length less than n plus plus 10 that will be the base case then i will uh have to put an i okay then what will be i for n t goes to zero i mean what the start position should be i plus length should be less than n plus plus i uh j is equal to i plus length right or will it be i plus length minus 1 it will be i plus length minus 1 right i plus length minus 1 should be less than n because for index 0 length 3 and 6 2 x 2 okay uh so some people want the problem link this is the problem link okay now i know j then i have to uh have it another loop so it will be an order of n cube time complex three then for n k equals to i plus 1 k less than j i'm like that is where i will split at let's plus key uh initially i will set the value of ppij to be in max i set the value of ppij to be in max but i have to finally return what we say the sequence but i am firstly trying to see if i can if the algorithm that i am coding up has thus correct answer then i will be able to create a parenthesis our tpij will be equal to min of ppi j comma array j minus array i that will be the length of the code uh that will be the cost that will be added plus uh dp of i to k plus dp of k to j that is a sub problem that should be there and then uh finally i will return uh bp of 0 to n minus 1 uh that should be correct but that is not written in the official or the original answer right so let me first see if this is returning the correct cost uh then we will try to what we say create a answer signal okay so suppose let us take care of this test case only for example six and one to five let us try to see what it returns there uh is it a is it it is b um bj minus bi and then returning zero why i say dpij is equal to int max and length is equal to three uh tp i will be zero yes so i plus length minus one should be less than n so that is fine is pj minus pi okay so i should be returning the correct answer right let me try to see what dpi j is coming for each index just if i suppose do that that what is this uh i j and then i said ppij i just first want to clarify if my algorithm is correct uh i'm just trying to see it so uh then it will give me yeah so from 0 to 2 the cost is coming to be two which is correct you know because that's the only thing uh i never do zero one two three four right i never do zero so this array will change to what we say this array will change to 0 1 2 5 6 right so uh the answer will be at 0 to 4 but i'm never computing 0 to 4 here as such okay i'm computing one to four but i'm not computing zero to four uh i plus length minus one should be less than equal to n right n is four n is five here so this thing is coming out to be correct uh my length should be less than or equal to n uh my length starts from 3 and my length should be equal to n right length is less than equal to and then it will be computed i think so that is the thing that yes so the answer is 12 and the 12 was minimum that thing we also know also new right uh so at least we are getting the correct tp answer i will correct numerical value the issue now comes how will we uh what we say how will we create the lexicographically smallest uh permutation okay one thing that is not probably given is that is the array of b1 to bm sorted uh it is not given right it is not given that b1 to bm is sorted so we have to sort that sort of b dot begin to be attained okay great so that thing we already know and now we also know that we are able to come to the correct answer okay so now the problem remains as to how we will create the lexicographical smallest uh permutation okay so to that suppose i'm also storing that what was the index that gave me the minimum value suppose i what the uh yeah what was the index that gave me the minimum value suppose that i also had this rather than doing this i would have told that if uh command x is less than dpij okay that means dpij is first equal to this this and then i can also say that this will be min index uh then i can say that min index of i to j will be uh nothing but k okay so once i have this i already i know that dpi j is going to return to the correct solution so now i have to just probably uh process that array process this matrix backward that in which order will i make the first so i can say that vector of an answer initially will be empty okay uh currently my end point is zero and start zero and n is equal to uh my end will be n minus one right so tell when should i find the sequence of cuts i should keep cutting one okay then i know that there are two problems in which that i have to find okay the dpij and dpkj right so first the very first cut will be actually what we say answer dot push back uh min and start comma end but then there will be sub cuts right then there will be multiple other cuts that will also be there so how should i compute that because otherwise i will have to do that recursively right i first compute that then i compute that oh can i do a recursive function to do that probably if i do a recursive function then it will automatically handle it right uh so let me say that suppose my fault uh refers to what we say start comma end and this is the vector of n and answer okay uh when do i know that this is done i know this when if uh start minus end is less than three right if n minus start is less than three less than two if n minus start plus one that is the length is less than or equal to two that means i am i don't have any other that means i don't have to put anything so in that case i can return as i will say answer dot push back main end of ik and end of starting and then i will record for uh start to a minute of this with this answer and i will also need to pass my minute right and end okay similarly then i can record from this plus one to sorry this only to end and i will need to pass it answer and minute okay and here i will have to have this minute yeah i actually need to have the b of that particular base not minute but okay let us say that i have this then i will say recurse of 0 to n minus 1 to answer to minute but now i will have to change everything in the answer to reverse of that so then i will have to change everything in the answer to the first two basically what was the value in this b so we have to say for uh auto android index and answer uh index will be equal to p of index and i can return on so this should probably work because i'm calculating it in the correct sequence it should be correct probably what am i missing i don't have a semicolon here anything nice um so i'm returning two comma one comma five which is absolutely correct uh i hope i'm not missing any other test case but let us test it yes and let us try to submit it i hope the time complexity passes because we are not given the constraints yeah so we are told that we are based falling we are feeling for the partially correct okay so we have some wrong answer for larger test cases why okay so probably the time limit is exceeding right because there is no other reason why it should fail uh the time limit can be exceeded because this is order of n cube can we bring this to order of n square when i am computing this dpij i need to know the this thing is always going to be fixed so i need to know the minimum value of ppi k plus dp kj right so if somehow i know from i to k which is the minimum k that stores that but that i can't do currently i'm at an order of n cube solution and probably because i'm failing this i have to get into order of n square or anything else [Music] no probably the answer is there's some modular automatic issue yes there can be modular authentication right because n can be up to 10 to the power 9 so uh then if n is up to 10 to the power 9 and all these numbers are 10 to the power 9 10 to the power 9 minus 1 times by 9 minus 2 uh in that case i will overflow right yes in that case i will overflow so then i think i will need to have this vector as a vector of long long end uh long long wind and then probably this should work because there doesn't seem to be any other issue then if i'm failing for the large test cases that i know that there is overflow possible then probably that is the thing and then this dpij will also have to be something larger larger than integer max right or not eventually it should not but it can be so i have to let me make it i have taken it as a long long 10 to the 17. then let me first test for the normal cases if i am doing some compilation issues i think i will be doing this matrix yeah because men in this scale but dj minus bi can be larger right so this seems to be fine okay so this seems to be fine and then let us try to submit it if that is the real issue because that is what seems to me as to be the issue and yes let's try to do it okay that was the issue and we fixed it okay great so basically how i identified that that was the issue that was an interesting thing that hey i saw that the value of n can be up to 10 to the power 9 so when we were calculating the cost of the last three indexes they can be 10 to the power 9 10 to the power 9 minus 1 10 to the power 9 minus 2 which will be equal to 3 into 10 to the power 9 minus 3 which is greater than integer max so there was a chance of an overflow and we fixed it up okay great myself um see in this particular tutorial we will be discussing about data structures interview question and nonsense from intel bit platform so if you don't know what is interrupt platform so i will give you an glance about interrupt interrupt is a platform where you can practice uh coding questions which were asked frequently in and product based companies and also you can find plenty of articles and blogs related to the a tech and uh interview preparation tips okay so in this particular tutorial we will be discussing one of the blog which was written on the data structures interview preparation okay so the link to the blog will be available in the description please do check it out let me walk through the topics that we are going to cover in this particular video and we will be starting with the definition of data structures and where can we use data structures and what is the usage of learning data structures and also we will be discussing about types of data structures available like arteries linked list stack okay and we will be talking about each one of them in detail and writing code for defining them and how to use them and what are the applications of each of them okay where can we use on real world so how can we build an applications using the data structures okay so it's not limited to theoretical so we will be writing plenty amount of code as well and we will be discussing a few important aspects in the right while writing the code okay and a logic behind the code okay so i highly recommend you guys to watch this video till the end and if you are visiting channel for the first time please do subscribe this channel and if you like the video please hit that like button up and if you have any queries please let us know in the comment section we would love to answer them so before starting the actual video so i would like to give you a few tips for your next interview so very first one so if they asked you to define something like define a graph define a tree just don't settle for the definition so please go on extra mile and give them some examples and so that they can understand you know concept in a better manner okay so that you can solve the real word problems as well okay then the second one it is for your dslroms so if they ever interviewed as as could you question and if you know the answer for that as well but don't directly jump over to the solution so ask them few questions like if they have a given an array okay like ask them like will there any chance of um it contains in a negative integers or what if the size of that is zero and also what if there exist are no solution for this what should i return like minus one zero okay so please clarify all your doubts before starting and solution then always start with the brute force approach okay which is an n square or if it isn't recursion based and two power n okay then try to optimize it so like sorting then a linear solution okay so this is how our interviewers will understand that you can solve the problem with the um very brute force manner to the optimized way okay it involves lot of thinking so they want that they don't want people who mug up the things okay so before getting on to the very first question let's try to understand what is the data structure and what are the types available in the data structure and where we can use the data structure in the day-to-day life and uh what is the usage of data data structures in the current organizations okay and what are the fields that our data structures has been implementing okay so it's very important to understand the applications of any concept okay rather than just solving few problems it doesn't make sense if you don't know why to use data structure then what is the need of using data structures okay so then first we'll try to understand uh how can we use data structure and what are the data structures available so the very first question here is what is a data structure so a data structure is a fundamental concept of any programming language essentially for algorithmic design okay it is used for efficient organization and modification of data so let me put it in a simple terms okay so a data structure is a represents okay data structure represents a way of organizing or storing that data in the memory so that it will be easy for us to easy for us to manage data okay like manage in the sense uh it will be some operations like uh insert delete update okay kind of operations so that we generally do perform such operations on any data right so here what is the need okay so what does it make sense like so if i store okay like i will be having 10 files if i store them in my memory like what is the purpose like why we need data structures so it is going to store in any way right so okay if you are talking about 10 files in your mobile it's okay now let me ask you few questions let's say let's take an example of instagram so everyone uses the instagram okay let's assume one profile okay one profile which has a 10k followers okay or let's consider virat kohli's profile okay virat kohli profile okay uh where he will be having uh 150 k followers i'm not sure it's correct or wrong okay let's i'm assuming that okay let's take an example okay now if virat kool has posted one picture okay virat kohli has posted one picture like post or he has shared some story now it has to reach for 150 or 1 million or any number of people right so it has to be accessible for the 1 million people now like just imagine just imagine you are storing that data in somewhere okay in some way and whenever i have open my instagram okay if i'm huge follower of virat kohli since um like whatever post he shares i will be liking that okay and among all the stories that i have been displaying on my profile i'll be first seeing the virat kohli profile okay in within fraction of seconds you can see that right so whenever someone posted it is going to share like amount of time that have been posted as well like one second one hour or 10 minutes so do you think this is going to come in within one second you might be wondering my answer is yes it is going to refresh within the one second or two seconds at max so to get the data that much faster okay viraquali is in mumbai okay let's assume let's say i'm in uh australia or u.s okay then do you think it is traveling from mumbai to u.s within that many seconds no okay like from mumbai restoring in some like with the help of some cdns okay restoring somewhere in data centers and then it is getting access in the us okay by using the cdn uscd like so how we are getting stored this data that is the matter so we need to store the data in such a way that we can access that very easily very fast okay so if you like you can easily assume that like same you will be storing all your books okay like randomly in your room okay now i want to get the one book from the room okay where you have stored all your books randomly okay in some some books and bedrooms some books in the kitchen some books and haul okay now how much amount of time it will going to take to fetch one book that search from one book now can i say that at max it is going to take 10 minutes for sure right now just assume if you have stored all the books all the books all the books in an organized manner in a organized manner now how much time it is going to take i'm pretty much sure that let's say i have stored all the uh physics books in one rack chemistry books in one track data structure test books in one track then it is going to take at max one minute yes one minute okay so there is a huge difference between one minute and ten minutes right so even if it is not making sense for you but a client or user who are waiting for your data will going to make and 10 minutes of waiting time is a little hectic for them okay that is the usage that is the necessary of organizing the data so that we can easily access the things okay so this is the use case that we need to learn data structure okay now we have talked about what is data structure and why we need data structure now how many types are there in data structure so i can say that all the data structures has been classified into two types linear and non-linear what is this linear and non-linear so linear and non-linear what is this linear and nonlinear okay so i can say that like if the elements of a data structure results in a sequence or linear then it is called as a linear data structure and when the elements in a data structure results in a way that traversal of nodes is not done in the sequential manner like you can easily resum remember this as a whenever we are talking about this linear we can say that storing the data in the linear manner or a sequential manner means i'll write one after one okay let's say if i have stored something here then after right after that i will be storing another then right after that then right after that so if i want the third one i can easily go there okay i can easily go here and pick up that because everything is in sequential order they are following the order whatever like so first you came then you go first okay so like that okay now when we are talking about non-linear types it is not like sequential restoring in non-sequential order so what is this non-sequential let's say we will be storing the data structure like um we can assume our file structure okay file stop shop let's say i have a desktop folder in that desktop folder i will be having um let's say scalar folder and again in scalar folder i will be having another folder called data structure and again in data structure i will be having another folder called arrays again in rs i will be storing something so here you might think that for along with data structure there will be something as well let's say my computer or let's say i have a folder of my name called omc and in scalar folder as well i will be having many things okay so here the data is in not in sequential order it is in random okay and if you need something you need to go and search every possible okay then only you will get to know where it is actually stored so that is what a linear and the non-linear data structure means now we'll talk about what are the data structures that comes under linear and non-linear so if you observe the things here for under the linear data structures we will be having arrays linked list stacks and queues okay we'll talk about them each of them in detail in the further okay but as of now let's remember the names okay coming to nonlinear data structures we will be having trees graphs tables and sets okay we'll talk about them each of them for sure okay please bear with me till the end now let's try to understand the where we use these data structures so i have i've told you enough examples in the while discussing the data structure as well now let me put all of these things again like i can simply say is that wherever there is something like programming i can easily say that there is a data structure as well directly or indirectly if you are storing something then directly or indirectly you will be using concept called data structure it represents how you stored your data that's it okay and like you can see these things okay so artificial intelligence compiler design machine learning uh database design management blockchain numerical and statistical analysis operating system development image and space recognition cryptography not limited to these things okay there are few more other like even android applications web applications so everything is being backed by some databases right so indirectly we will be using uh the concept of data structures in storing the data okay like if you are talking about database how how we are using database okay so if you are storing any rdbms database okay like a sequel now can i say that all the data is being stored in the form of tables where you will be having a columns and rows so can i say that this is going to be non-linear data structure yes okay so this is how you will be using the data structure in the day-to-day life okay now let's get into the some this is what we have discussed so far applications of data structures and uh this is the most important question that everyone should uh have to be clear with the benefits of learning data structure so yes if you are a cs guy or if you are one who is aiming for cs jobs like computer science field then you are on the right page you have to learn the data structures for sure okay there is no middleway and even if you consider all the high paying jobs okay all the high paying jobs requires or test you or ask you a data structure on algorithm questions in an interview okay in an interview so why does this happen because these are data structure and algorithm problems involves a lot of problem solving skills okay like if you are given an problem where you will you need to handle a 10 gb of data okay 10 gb of data then how can you organize that okay how can you store that in database and how can you make it is been reasonable for everyone to access so such kind of problem solving skills will come under this data structure that's why companies will ask data structures and algorithms questions in an interview okay now another most question to be addressed here is data structures in c and java so people might be asking like questions like so which language should i pick up for learning data structures beat a c plus plus java a python or any other uh language like javascript she shop so all i can say that is the concept is same okay the basic fundamental concept of any data structure is going to be same but it only differs in way like how you are going to store your answer and how you are going to represent in the things in a syntactical way and how you are converting your logical thinking to the programming so it's i can say that it's just an syntaxes okay and um that is what you need to understand if you know if you have the concept then no one cannot judge you are asked to do only code in this particular language i don't know that okay so no one is gonna tell you that so language doesn't matter okay you can learn it in any language okay so let's talk about this as well okay so uh this is what we have discussed and in an object-oriented programming language like java data structures are being implemented using class and objects okay so in object oriented means oops languages like java python cpespace we use a concepts called classes and the objects to implement the data structures and uh coming to c which is not an object-oriented programming language we use the concepts called structures okay structures and functions to implement the data structures okay and i would like to tell you about these like inbuilt support of languages provided by the different languages as well let's say if you are a java coder and like you wanted to use your data structures in your programming so you might be wondering should i learn the implementation of like should i manually implement all the things in the programming no so java supports in java there is a thing called collections collections library okay where you can get all the inbuilt okay all the inbuilt support for the data structures all you need to do is you need to just uh declare them and you can define them and you can use them okay and coming to c plus plus you will be having stl library okay stl library where stl will provide all the unnecessary support for your uh implementation of the data structures okay you don't need to implement them manually every time okay you can just import these either collections in java c plus stl in the c plus plus and you can use them okay i think now let's get started with the actual questions so the very first question that we are going to discuss is difference between file structure and the storage structure okay so uh let's talk about first file structure so a representation of data into secondary or auxiliary memory may say any device such as hard disk pen drive that stores data which remains intact until manually deleted is known as a file structure okay it is saying that whatever the data that you are storing okay whatever the data that you are storing in your hard disk hard disk and pen drives will be called as your file structure okay and what is about storage structure so a storage structure means whatever the data that you are storing in your ram okay in your ram that is called as an storage structure so uh what is the difference here so if you store anything in the hard disk or pen drive it won't get deleted even after you remove that thing or if power cuts if you face any power cut but in case of the data which is stored in ram if if you guys have witnessed a power cut or if you have shared on your laptop and restarted your laptop then you can't see the data which is stored in the ram okay that is a major difference between the file structure storage and the storage structure okay now the second question so can you tell me how linear data structure differ from non-linear data structure so as we discussed earlier so linear data structure stores the data in the form of a linearly and these nonlinear data structure stores the data in non-linear manner so which is going to be either you need to traverse to all the things okay which is in connected way then that's how you can access them okay so if you observe in this particular diagram so this is called as i'm storing the data in the linear manner means sequential manner if you observe so okay like you can traverse through this um elements using uh one single type okay what is a traversing okay what is a traversing so basically let's say you have an array okay if you don't even know what is array just stick okay like if you have something like this and you have some data here one two three four five six seven now a traversing means a visiting all these blocks okay you can consider this as one block it says one block this has one block okay so traversing means you need to visit all the blocks at once at least okay now so if in in the case of linear data structure you will be starting from one and you will be coming to two from like you can't go to three here okay so if you are traversing in a linear manner with the speed of one and you from here you can go to three then four then five then six then seven so it is going to be linear in fashion right but if you consider this okay like it is starting from the a and from a you will be let's assume this uh things are being represented as a a connection okay connection connection means you can from a you can go to b from a you can go to c or e as well okay if there is exist a path now from a you will be having three choices okay from b again you can go to e or b a again so here there is it is not sticking to one structure one sequence order so you can go to any order that you want okay but in case of linear you can only move to the next thing okay that is in sequential manner okay so that is what and a difference between sequential and non-sequential is now what is an array an array is an a collection of similar type of data stored in a contiguous memory location what is a contiguous memory location let's say okay so this is an array okay and uh my first element okay i have started at the uh address of 100 yeah address of 100 that's it i have stored 20 in it then i can say that i am storing all the integer typed values as of now and i know that integer takes a two bytes of memory okay integer takes two bytes of memory it means that so it will assume like it will take two bytes okay if it has started at 200 if it is taken two too bad then the next bit will start from one or two so and i will be storing another 10 over there and again i am pretty much sure that it is going to take only again two bytes okay so i will be going to 104 and then again i will store another integer and it will take another two bytes so six then uh i will be storing three again it will take one at eight okay now again i will be storing one so it will take one sorry one time so here everything is in sequential order now uh what is the array here like what is the uniqueness of the array so here if you observe we will be storing all the integer type values only yes because in an array you will be you are allowed to store only one type of data okay whatever you have defined it now what is it defining an array okay or declaring an array so declaring means you need to if you wanted to use any a variable you need to declare that first okay how can we declare the int like array so let's say i have an a variable called a rr which represents the array and this symbol will help us to tell this particular thing is a array okay means it is going to store the data in the sequential order okay and it will take multiple uh values at the same time as well which are in types okay only into types now if i have um if i have represented it as something like character array okay if i have rep if i have defined it as something like this then it will take a characters okay one character attack each time okay or only it supports only character or either integers as well because in c language or in c plus plus all the characters and um indirectly equal to the integers until 256 okay and all the numbers until 256 is going to indirectly represent the characters because of the ascii values and if you don't know what is ascii values please have a look at that like just go to google and search for this and you will find what is ascii values okay now let's move on to the next question what is a multi-dimensional array okay so we know that array stores in the data of this manner okay the address might be 100 102 one not eight one ten one twelve one fourteen at last okay now what is this multi-dimensional array so a multi-dimensional array means so i can say that so if you observe this carefully i can say that it has one row and one two three four five six six columns right one row six columns so this is a single dimensional array so whenever you will be having one row okay one row then it is called as a single dimensional array so whenever you will be having a multiple rows okay whenever you will be having multiple rows like this like this okay it is called as a multi-dimensional array so again it is going to call like if you observe this thing carefully it is in the form of matrix right so if i represent this in the matrix so it will be having three rows and a six column so three into six matrix okay so i can say that three rows six columns yep now here at max at max how many elements that you can store here i can say that you can store six elements okay six elements now here you can store at max 18 elements okay 18 elements so you might be wondering like how to access these elements okay so for that you we will be having a concept called indexing indexing what is this indexing so basically let's say we will be having an array with the size of of 6 okay size of 6 so 1 2 3 4 5 6 okay so size of 6 means it can store a 6 values or 6 elements at max okay so if i represent these things in the integer like indexing then it is going to start from the zero then one two three four five and for i like for every array the last the last index is going to be size minus one okay and it will start from the zero okay start from the zero now let's assume here we will be storing a 10 20 30 40 50 60 now how can i access these elements and let's assume the name of this array is arr okay now if i write a r of 3 okay if i write something like this now we will be getting output as a throat index value okay in a r okay array with throat index value so what in a r what is the trial index this is the throat index now we are going to get the 40 as our output if i write arr of 1 what does it mean it means that in arr variable array we need a one index so we are going to get the 20 as the output now if i try to access if i try to access array of 10 what are we going to get you are going to like first check is there any index with the number of 10 no there is no index such that now we it is going to throw an error or exception if you are in java or python guys it will throw an exception which is a named as a array array out of bounds exception array out of bound exception okay which means that the index which you are trying to access is not there okay not there that's it now now this is okay for this is for this like single dimensional array how can we access the multi-dimensional array okay multi-dimensional like array accessing how can we access that so uh in in the case of um like 1d dimensional one-dimensional array we will be having only one row and n columns so we can just represent in one index okay but in case of a multi-dimensional array we will be having something like this okay now let's try to represent these things in rows push so it is going to be zero row one row second row and if i represent these columns zero column first column second column so it's just as representing the things in the matrix okay represent the things in the matrix now so if i want this particular element i can represent it as zero comma zero like let's say if this is an name of array okay this name of array then i can say that array first i need to mention the row which is an zero then i need to mention the column which is again to be zero okay the first zero represents the row second arrow represents the column okay if i write if i write 2 comma like two of one which means a second row this second row and first column okay this is now i am going to get this particular value okay so this is how we are going to access the like we can access the elements in a multi-dimensional and single dimensional arrays okay now what is a linked list okay linked list is an another data structure which is of which follows an a linear data type okay so a linked list is a data structure that are sequence of nodes sequence of nodes where every node is connected to the next node by means of reference point okay we'll talk about that later like now elements are not sorted in adjacent memory locations they are linked using pointers from it to form a chain okay and each node is having data field and the reference point so if you remember if you observe this particular diagram we will be like if you consider this as a node and at the first of we will be having data and the second half we will be having the pointer to the next node pointer to the nest node what does it mean okay let's say okay this is our node okay this is our node and node has been as two parts one is data another one is link to the next node okay so this data represents something let's say 10 i wanted to store that 10 now what is this part is going to store i can say that this part is going to store let's say okay let's come to let's try to define a few other nodes as well okay now this is storing 20 this is storing 30 now this node is being stored in the memory location of 200 and this is being stored in the memory location of 500 and this is being stored in the memory location of thousand okay now now i wanted to go to 20 okay i wanted to go to 20 after the 10 okay i wanted to go to 20 after the 10 so here i need to mention the node address which i would like to go next okay so i wanted to go to the 20 so what is the address of the 20 it is a 500 so i will mention 500 here now after 20 i would like to go to the 30 okay 30 now what is the address of the 30 it is going to be 1000 right so after 30 i don't want to go anywhere okay i don't want to go anywhere so now it is going to store the null okay it which means that if you would like to not to go anyway okay after visiting some node okay then you need to point that as a null pointer okay which represent this is the ending point okay which is the ending point and every starting node will be having a head node okay which represent the starting point of a node okay done okay this is how a linked list is being represented and if you observe the data everything has been stored in the everything has been stored in the form of sequential okay after one we will be storing like going to the 20 so here we will be just directly representing things in the form of memory location okay we are not going anywhere we are directly going to the 500 after 200 so that's what it is in sequential way done now let's go our linked list of linear or non-linear type okay good question we have seen the answer just now right linked list can be considered both linear and non-linear data structure this depends upon the application that they are using okay so this can be treated as a both linear and non-linear but moreover it depends upon the where we are using the context the context where we are uh using that term called linked list okay so when linked list is used for accessing strategies this considered as a linear data structure when they are storing data storage it can be considered as a non-non-linear data structure okay so it totally depends upon the uh application that we are using this linked list okay now let's move on to the next question so how are linked lists are more efficient than arrays good question okay so here i would like to mention the term called uh time complexity time complexity and space complexity okay so whenever you are writing an uh program or whenever you are writing an algorithm okay so these are the two aspects which talks about whether you are your code which you have written is an efficient or not okay so if it is taking minimal amount of space and time minimal okay minimum amount of space and time it can be called as an efficient algorithm for a problem okay like even in the case of uh real world applications let's say you are using a payment okay you are like uh let's say amazon okay amazon website you have what one product okay you have bought one book let's assume one book and now you are paying amount for this okay you are doing payment payment so you just imagine if your payment took one minute of time to finish okay one minute of time to finish how do you think no we are uh i i won't i am not interested in doing the like paying the online okay because it will take one minute of time and uh until that uh you until that you receive the done yes payment has been received your order has been successfully placed you won't be in a piece right it is always like loved up your heart will be like pumping up okay so what if my amount got detected from the account and if like if my order is being cancelled so you might be having these things until you have seen the payment has been done okay so in that case it should be done in the either one second or two seconds of time okay then only people will go and purchase the things on from the amazon website okay so in this case it is an time complexity so one minute of time complexity and one second of time complexity which one do you prefer the answer is up to you okay and that is the answer for the time complexity as well okay now let's come to the question so insertion and deletion operations so basically what is this insertion and deletion so insertion and deletion process is expensive in an array as the room has to be created for the new elements and existing elements must be shifted okay let's say we have an array something like this okay you will be storing one two three four five now i would like to okay in between three and four i would like to insert this six okay like i'm expecting my end array should be looks like one two three six four five now like to perform this operation what are the like what is the process first we need to create this six yes we need to create this six then we need to replace this okay we need to put this here okay to put that here is that as simple as that no so at first we need to create a space here okay then we need to move the fourth to the fifth position and uh five to the sixth position right so we have created the room here and then we have shade like we have shifted four to the next guy and 5 to the next guy then you we have replaced 6 over there like so here to insert one element we are doing three operations three operations even for delete even for delete if i if i wanted to delete that okay if i wanted to delete that first what i need to do i need to delete this six okay i need to delete the i need to delete the six okay then i need to move my four to here and phi to here again it's taking three operations right so which is an like complex thing to understand but in case of for linked list let's see i have a link a list something like this okay eight so i have linked list something like this now i would like to insert nine here okay nine here uh how can i insert so it's just simple right so i will break this point okay connect a two nine after seven and i will connect eight after the 9 that's it it's as simple as that we don't need to perform any uh replace operations or move operations here we're just deleting the like we are just breaking the bond over there and connecting the bond to the nine that's it okay this is as simple as that okay and it is going to take the big off of one complex and if you don't know what is time complexity and space complexity i highly recommend you guys to watch the tutorials which are been already created on the time complexity and space complexity in this particular channel itself okay so there is a playlist called dsa okay you can go there and you will find a plenty amount of videos over there cool so this is about even if i take a deletion operation let's say if i wanted to delete this 9 itself now what i can do so i will simply break this out and i will connect to 8 and i will break this out and i will delete that that's it as simple as that okay we are not doing any complex operations like mo mo mo and all okay it's very simple but but uh i would like to talk about something like accessing as well okay accessing as well so to access an uh array elements it is going to be as simple as that okay you will put your index value and you will get the value so it is going to take constant time but if i wanted to access the linked list elements it is not as simple as that okay if i want to access this particular element first i need to start from the head okay i need to start from the head i need to go to every node okay every node until i found a node which i want then only i can access that element so i can't go in the middle and i get that okay i need to start from the starting position i need to go to the every node and then to check okay yeah so uh the second thing is dynamic in nature dynamic in nature so point to be discussed so here what is a dynamic in nature so basically there are two things static and dynamic so static means let's say if you are defining an array you will be mentioning how many number of columns that you need here itself okay here you can't modify this in later part okay you can store only five elements it is defined it is fixed okay but in case of dynamic you will be giving only like uh the number of uh elements okay that you required okay let's say so you have in the case of static you have defined five but later you observe that you will be requiring 10 elements to be stored that in that case it won't support yes yes now let's say let's this is first point and second point is let's say you would like to store the two elements okay you have defined file but i found that i only required two elements in that case three space is waste okay the space for three elements is waste if you are not using that right but in case of dynamic let's say you will be defining the amount of memory or the amount of elements that you would like to share okay then only you can create the things okay let's say if i want a requirement of two element store then i will create a two elements if i requirement of 100 i will create a hundred that's how it works right so this is about static and dynamic okay and in case of linked list it's always a dynamic it always dynamic in nature okay it is always in dynamic in nature you there is no boundaries for that but in case of arrays while defining the array itself you need to mention whether like how many elements that you are going to store okay so it is one of the drawback for array but how can we make this as a dynamic so there are few concepts okay known as malloc so which helps us to define the memory or allocate the memory uh in the dynamic space okay while our runtime okay you can call this as a runtime so basically we will be having two things compile time and a run time what is this compile time so compile time means after writing the code okay after writing the code you will be putting the things okay like let's say while writing the code itself you will be mentioning the things but runtime means after compiling the program okay based upon the user's requirement the coding has been changing okay that is called our runtime during the runtime so as we discussed it's an memory wastage as well so if i have defined five if i have used only two then it's a memory wastage right so that is what it is uh discussing about now let's move on to the next question so explain the scenarios where you can use a linkedin list and arrays okay so i will like level this particular question to up to your imagination okay in total okay we have seen el hell about these things okay where or what are the different types of linked list are available and different types of arrays available what are the drawbacks here and what are the cons and pros of arrays and linker list now just imagine okay so just take out uh just go through this and just try to imagine whether we can apply a uh in this particular situation can we apply um array on linked list okay so i will just go walk through these things okay so following all the scenarios where you use linked list over array okay so when we do not know the exact number of elements beforehand so as we said there is no a boundaries for linked list so it is means that you can like if we don't know the requirement we can go with uh linked list so whenever something has been changed we can open those changes but in case of array we can't do that so when we know that there would be large number of add or remove operations so as we discussed uh linked list is very easy to perform insert and deletion operations when compared to the arrays so in that cases we can prefer linked list so less number of random access for access operations so random access operations means a searching let's say we have uh different nodes and i wanted to access this particular node okay so i can't easily go i can't easily go to this particular node directly right so i have to start from the starting then i can go to each one manually then only i can access that element so so in that case let's say if i have 1000 nodes thousand nodes i wanted to access the 999 node then how many nodes i need to check i need to check 999 nodes right so it is going to be little complex operation so in case of array i can easily say array of 999 then i will get the answer okay in such cases so like if it has a very less number of random access operations then you can prefer link a list then um when we want to insert items anywhere in the middle of the list such as while implementing the priority queue linked list or more suitable so we'll talk about this periodic use later okay so as of now they are saying that if you wanted to insert something in the middle as we discussed earlier so in that case you can prefer linked list over array now what is the second thing so below are the cases where we use array over the linked list so as of now we discussed about using linked list over array now let's discuss about using arrays over linked list so when we need to create index or randomly access element from the frequent um like more frequently so as i said if we wanted to access 999th index we can simply say arr of array of 999 so you can access the thing very easily now the second point when we know the number of elements in the array beforehand in order to allocate the right amount of memory so as we discussed earlier as well so if you know the requirement exactly let's say if i wanted to have only 20 elements in my array then you can go with the this particular arrays okay if you are not sure about how many elements that are going to are required then you should go to the linkedin list when we need um speed while iterating over the elements in this sequence so speed matters a lot right so that as speed directly depends upon the time complexity so if you are going a little faster in the your memory then like in your array then your overall time complexity is going to be little faster and efficient yes so this is about our scenarios where we prefer either linked list or arrays now what is a double linked list and what are its applications so till now we have talked about single linked list now let's talk about double linked list so a double so in single linked list we will be having only the pointer to the next node okay the pointer to the next to know so just imagine if you have a pointer to the next node in the previous node okay the previous node then this is called as a double linked list okay so here your node would be containing three parts one is data and the next pointer and the previous pointer okay and the previous pointer so this is what a double linked list means let's come into the applications so here so applications of dll so a music player list with the next song and previous song navigation options so everyone loves music right so if you have open any music player okay if you have opened any music player you could have observed uh next pointer like um let's say so if you are listening one music okay there will be options right like go to the next song go to the previous song and pause the song and resume the song so something like this so here so you can assume that this going to the next song is a next pointer going to the previous song is a previous pointer okay this is one use case where you will be using double linked list and the browser catch with the back for a back forward of visit pages okay so let's say i have currently opened a google chrome okay like interview bit of blogs website okay and that will beat blocks website now like before coming to interview bit platform i have opened a scalar academy website scalar academy website okay now uh before uh back okay so like after visiting interview bit as well i have visited another website okay which is collagen let's say scalar forever scalar forever website now now i am currently in the interview big platform if i wanted to go to the uh the webpage or the website which i have opened up before before to the interview bit then what can i say so here you can see these navigation buttons right navigation buttons so this one represents the backward this one represents the forward so this is the current page which i am in so interview bit now if i click on this back page i will go to the scalar academy if i click on this forward page i will go to the forever scalar forever right so this is one use case where we will be using uh dev double linked list now undo and redo functionality on platforms right so let's say like you have opened a notepad okay notepad or word or whatever it might be so you will be pressing ctrl z right so control z will get the like recently deleted the values so and something um so there is something like a redo as well so redo means you have uh like entered something and you have given a backspace like deleted them and you wanted to get back down so undo one redo so these operations will also take a double linked list okay so this is about double linked list and applications of a double linked list now what is a stack what are the applications of a stack so here this particular diagram represents the enough explanation i don't need to explain it manually let's say so let's consider this particular bookshelf okay now what do you think about this particular book so can i say if i have 10 books okay i wanted to put them in a one rack so all i can do is first i will put the one book okay this book then i will put this book then this then then then this this right so i'll put all of them and if i wanted to take the okay if i wanted to take the one book which is on top what it would be it is this particular book when i inserted that i inserted that the last when i am taking that out the first okay last inserted first taken so this is called an lifo so whatever element which has been pushed into the stack okay at first is going to take out as the last okay so stack linear data structure follows the last in first out approach so if you even see this first i have pushed 1 then 2 then 3 then 4 okay if i wanted to take one element okay if i wanted to take one element from the top okay this is going to be four right if i it is going to be four that is what a pop so basically stack has three operations premierely one is push pop on top so push operation helps us to insert the insert the elements into the data structure and pop operation helps us to delete the topmost element which you have in in case of a stack which you have recently added so here the recently added element is the four so when i say pop four is going to be out okay so the top so this top is going to uh give us the topmost element so what is the topmost element i can say that uh a topmost element is the element which is been added recently okay which is been added recently so four is the last element that i have added recently okay hope you have understood the stack and stack operations right so if you want in detail like let me put here so let's say i have these elements one two three four five six now i wanted to put all of these elements in a stack so okay let me put the operations okay i have operations like this so first push one then push to then push four then push three then pop then up pop again then top okay before coming to top let's say push 10 okay now let's see so this is our stack so what is the first operation we send that push one so if i push one it is going to store something like this now again it is saying that push two okay two now again it is saying that push 4 now again it is saying that push 3 now it is saying that pop so what does pop do pop will delete the top most element top most element which you have added recently what is the element which i have added recently is the three right it is the three so i will remove that i will remove that done now what is the next one again it is saying that pop okay pop so i will now what is the top element it is 4 right so i will remove this as well now what is the operation it is saying that push 10 okay so i will push 10 now it is saying that top okay so what is the top so top will give you the top most element which you have added recently so it will give the 10 done so if you like our top don't delete the element okay it will give you the only top most element only pop will delete the element okay so here these are the applications of the stack so we'll talk about them as well so first is check for balanced parenthesis in an expression it's going to be one of the interesting problem in dsa so like where you will be given like a parenthesis like this okay you need to check whether for every opened parenthesis there exists a closed parenthesis that is the problem statement so you can solve this problem using stack so give it a shot okay give it a try and evaluation of post fix expression so there is three three things okay prefix postfix and uh infix okay so like uh these operations are like if you have given a plus b plus into c minus d you need to convert this into these three operations okay so in one such operation for postfix you can use the stack okay you can use the stack and a problem of infix to postfix conversion and reverse testing so a reverse testing means you will be given a string okay you will be given let's assume string like this and you require to reverse this entire string so how can you do that so let's say you have a stack like this so i will start from the first element okay and i will push everything to the stack so we so once i'm done now i will uh i will take the top and i will delete it the particular top element now if i say top i will get the i and i will delete this i will pop out this i know now i will again say top and i will delete it pop the top now again i will say top i will get the m and i will pop up so i will again say top i will get the a and i will pop it out now again i said top i will get v and i will get top popped out so if you see there is nothing in the stack so and if you see the output i got the reverse of a bouncy that's how it should work okay so what is a queue so then the name only suggests that what is a queue okay so just guess okay so a q is a linear data structure that follows a fifo first in first out so what does it mean so if you see okay like they have given one amazing example here so uh you you have in a uh movie mall okay you have been to the movie theater nowadays everything is online booking but just imagine okay uh like and ninety kids can imagine this so there is a movie ticket countdown okay you need to go to the queue and you need to collect the ticket okay buy the ticket from there then only you will be entered into the theater okay so now just imagine so who is going to be uh the first person at the counter whoever come to the counter first they are going to be at first so who is going to get the ticket at first the person who entered first then then so who is going to get the ticket at the last the person who entered into the queue for the last right that is how it works right now let's say i have a few operations that we have taken out there uh for q we will operations have enqueue and dq okay we'll call this so enqueue will do like something like insert what we did for push and dq will do deletion of top element and a friend will give you the top most element okay like the one which is very close to the counter here now let's say if i give the operations like in q 1 in q 3 d q a top q nq5 okay now so just imagine this is a cube okay this is a queue and if i have like first i have nq one so i will put one here then i have enqueue 3 now i have dq so when i say dq what is the element that i am going to get the out first the one which is entered into the first okay in this case the element which entered the queue first is the one so i will i will remove the one done okay now i have top so what is the top element now set three okay after one has been deleted three is at top you will get three now again i say in q5 so i will say five okay this is how it should work now if i again dq what is the element that i am going to get so it's a three right so this is how q should work now what are the applications of queue that the applications of queue so cpu scheduling task bfs algorithm to find shortest distance between two nodes in a graph so if you don't know what is bfs and graph don't worry we are going to learn in this particular video itself so please watch this video till the end uh website uh request processing used as a buffers in applications like mp3 media cd player etc managing and input streaming so these are the some of the applications where we use q so let's move on to the next question how is a stack different from a queue it's very silly question we have discussed so far okay so a stack follows stack follows lifo manner last in first q follows first in first out manner okay so that is a only difference between stack and queue explain the process behind storing a variable in memory okay so they are asking us to tell the process how the data has been stored in the memory okay like some variable take out one example as a variable then tell me so at first at first variable is stored in memory based upon the amount of memory that is needed so here like say a variable is declared as an integer type a float type a string type okay so depends upon the type of the data that we are storing under one particular variable so following other steps a follow to store a variable so the amount of amount of memory is required is assigned first so in case of in we will be requiring two bytes in case of floor we will be requiring four bytes in case of string we will be requiring the amount of characters it has okay so each character will have one byte so it will it will be required the amount of characters it has then that's done with the first then it is stored based upon the data structure being used as well okay so uh here let's say if we have defined integer typed array so it is going to require a contiguous memory locations right so it is not about one particular starting point this is about uh like sequence of operation let's say i have given or 10 as my memory elements then it should assign 20 uh 20 amount okay like 20 bytes of amount for that particular array so it should search for 20 bytes when wherever there is a possibility of 4020 then it will show there but in case of linked list it always finds and the large amount of space because it is dynamic in nature okay so requirement is not stated in the before assigning the things so it depends upon the data type as well let's see how to implement a cube using a stacks okay so how can we implement so we are asked to implement q using stack so yes we can use our like um there is two methods one is using one stack another one is a two stacks so as of now we are sticking to this particular approach okay and uh maybe in some other tutorial we will try to focus on how to implement a queue using single stack as well but as of now let's try to implement the using two stacks so first so we know that our stack so push pop on top and queue operation so nq dq and let's say friend okay so now using these operations and two queues we need to implement these operations okay which is a for q okay so first let's try to understand how what are the operations and how it is going to work so let's say stack works in this particular manner okay when i say push okay push one okay and push three and pop so pop means the what whatever the element which has been uh inserted into a stack at the last that is going to come out of the first okay so this is going to eliminate it done now again i can say top now if i say what is the top most element now currently it is one so i will get a one i if i perform the same operations like in q one uh in q three dq and friend okay now how it should looks like let's say so in q1 yes one and at big enqueue three three and it is saying that dq so what is going to happen so first in first out so what is the element which has been entered into q for the first one so it is going to be eliminated now if i say friend what will be my output it would be three right so now you've got what is the operations of stack and what are the operations of a queue now let's try to implement the queue using a stack okay so for that we will be taking two stacks okay like this stack one step two stack one and stack two and we are going to perform this series of operations like this enqueue of 1 at nq of 2 and q of 5 d q of dq that's it okay so dq and a friend okay these are a q operations okay whenever i do enqueue it is going to push whenever i q dq it is going to be pop whenever i do friend it is going to give me the top now let's try to perform these operations by putting these as a reference okay at first it is saying that um while a stack not is empty so here stack is empty so what we are going to do uh so like first we are going to perform enquiry operation which is a push okay so we'll take this and we'll call this n cube and we say that while stack one is not empty so here stack one is empty so simply we are going to insert this push this one to the here done now again we have seen the enqueue of two so here this time our stack one is not empty okay stack one is not empty so what we are going to do so push everything from stack one to the stack two so whatever we have in stack one we are going to pop out them one by one and push it to the stack two now here we'll pop out this one and we'll push it into one now push data to the stack one so what is the data here two so we'll push it here now push everything back to the stack one okay so we'll pop this here and then we'll push whatever we have pop to the stack one done done now again we have seen the nqf5 so again stack one is not empty so push everything from stack one to stack two so whatever we have in stack one we need to pop them each one of them and push it to the stack so if we pop each everything so first i i will pop a one and i will push it to the stack two then i will pop the two and push it to the stack one so first one then two now it is saying that uh push a data to the stack one so what is the data it's a five so i will push here and again it is saying that push everything back to the stack one so whatever we have in the stack two will pop that each and everything like every element and push it back to the stack one so here first we will pop two first will pop two and then we'll push it here and then we'll pop the one and push it back here so it is going to be looks like this now dq now dq so dq means a pop operation so in queue how it is going to work so whatever you have a pushed whatever you have pushed at the first okay then it is going to come out of the cube for the first so in this case let's say we have called dq okay and if stack1 is empty then error so here stack one is not empty so pop an item from the stack one and return it okay so they are saying that pop the item from the stack one so if i pop what is the element so usually stack eliminates the last in first off so here last has been entered this now i will pop this out and i will say here okay for this we got the answer as one so in this case one is the first thing which has entered into queue right so that is what we got done now dq so again dq so what is the same so again stack one is not empty what we will do we will do pop the stack one element so if we pop we will get two and return the two here that's it now they are saying that print so uh we will be getting the top most element that's it so here we have only five written that so this is how we are going to implement the queue using two stacks okay and there is another method so here we will be making a nq operation little complicated is right so we are performing our swapping operations and then we are putting back to the q stack one and we are making our nq operation little complicated but dq operation is in doing in some constant amount of time so the another approach follows i'm making an enqueue operation little easier and deep your operation little costlier that's it okay so just follow these uh steps okay i am pretty much sure that you will be able to do this okay now let's go so the next question is how do we implement stack using queue so this is the opposite reverse okay so earlier we have done queue using a stack now they are asking stack using q okay so now we need to do this so again we are going to use r2qs two and we know the operations of queue right so first in first out and stack is last in first out so we need to implement these operations so these are the sequence of operations that we can follow here okay so let's try to check okay whether we can able to do this or not so let's take first let's take two cubes q1 q2 and i will take a sequence of pop operations let's say push 1 push 3 push 5 push 6 walk pop top and push okay let's make it little complicated okay now let's do this thing so first step push one so it will come here and then give the data to the q2 okay i will be putting it one in the q2 let me change the color yeah now dq elements one by one from q1 and enqueue it to the q2 so here currently q1 is empty so we are not going to do this step now swap the names of the q1 and q2 okay so uh swap the names in the sense like uh whatever we have in the uh q1 let's put them to the q q 2 and whatever we have in q2 we will be putting them in to the q1 okay so here if we do that like um yeah it can be simply uh changing the names as well so we can do that as well so q2 and q1 done okay again we got a push three so push three so our first thing enqueue to the data to the q2 so here we have q2 as here now so dq elements one by one from the q1 and enqueue to the two so here we will be having only one so we'll pop this out and put it in the of q1 now swap the names of q1 and q2 so swap the names q1 q2 now we'll follow this so push 5 okay push pi so i will i'm going to push it here okay i'm going to push it here and sorry i am sorry sorry so i need to do this here sorry so dequeue elements by one by one and put it back into the q2 so here what is the element that first has got into q1 is three right so i need to pop that off three first and i will push back to the here and then one done now swap the names of two so it is going to be q2 and q1 done now again push 6 so i will push 6 in the q2 and then pull out all of these things and then put it back here so if i pull out all these things it will be looks like something five three one right what is the element that first got entered into the q1 it's a five so we have to pop that out first and we need to put it in queue okay now again same right now they are saying that cop so pop so we'll come to here okay we'll come to here so we we did not stop the things okay so we'll swap the q1 and q2 now they are saying that pop so dq from the pop q1 and return it so what is the element if i if i pop it from the q1 like if i dq from q1 what is the element that i get 6 right y6 6 is the one which has entered into the queue for the first so if i dq i will get the six so so yeah yes so this is what i want right so if i am doing stack so i will i will be getting last in first order so what is the last element that got into the queue so six right so i will be getting six that's it so we we can eliminate this six now again we have pop now what is the element that i get so five so i will get a five so i will eliminate the five now what is the element top so what is the top most element currently it is three so i will get a three now again saying that uh push two so first i will put it into the q two then i will pop out everything from the q1 so if i do pop out i will get three and one and then i will be eliminating here and then just wrapping the names so it is going to be q2 and q1 okay that's it if i perform pop now it is i'm going to get 2 as my answer done so this is how you can implement the start using two queues okay so i'm not writing the code here okay i hope you can able to do that here and uh we'll do a separate video on that as well now let's move on to the next question what is hash map in data structure uh so hashmap is being called as and different names in different programming languages let me put it here so in python we use a dictionary okay in c plus plus we use a map or an ordered map okay and in java we use hash map okay so the operations is same okay the operations are same and the names only different uh while changing to the language to language so a hash map is a data structure that uses implementation of hash table data structure which allows access of data in constant time complexity if you have the key so basically let me tell you how the data has been stored into the hashmap first so hashmap follows two rules key and value so what is the key and what is the value so a key is a unique value okay a key is a unique value so which helps this particular thing to the uh identify the data from the or access the data from the map so let me take one simple example so let's say you will be given an array of elements okay array of elements like this and now you need to calculate the a frequency okay frequency of each element okay frequency of each element now how can you do that so by using the hash map we can do that easy so let's say first i will check whether one is there in the queue or not okay like hash map or not yes one is not there so i will put one and i will make sure value is assigned to the one okay so what does it mean so till now one has been occurred only once okay now again i can see that there is a one so here first i will check whether one is there in my hash map or not yes one is there so what does it mean what does it mean so it means that there is already existed one which has occurred for once okay now what do i need to do if i can simply if i can simply update this value then my job is done so here key is element and value is frequency of a that particular element done now again i have one okay now um which is like already have one in my map so what i need to do i need to just increment my value so if i do that it will become 3 now i have 2 so 2 is not there in the map so i will create 1 ok done now again i have a 2 but i have already to is exist in my map so what i can do i can simply increase the value so now it is a three so whether three is there in my map no so i can just say three to the 1 now the next element is 4 so 4 is not there in my map so i will increment it back now i have 2 okay i have 2 so but already 2 is exist in my map so what do i need to do i need to simply increment the value of the key value of the two done so now let's say cross check the things okay here i have uh an array size of the 8 so 3 plus 3 plus 6 six plus one seven seven plus one eight so eight done so this is the frequency so this is how and um we store data in the hash map so what are the things that you have identified here so in hash map we we can't store the duplicate values okay we can't okay you can't store the duplicate values yes and if we if like we can't store the duplicate values is an a passive statement okay uh what we can say is it will get overrided like overwritten that's it okay like if you have one and again if you have seen one it will just overwrite that one with one and it will like what it will do whatever operation that you are performing okay that's it and how to access the uh hash map elements by using these keys okay let's say this uh particular hash map uh is been under the variable of mp then you can say mp of two then you will get a answer as three okay like this is a key basically and if you do this something like this you will get a value so this is how hash map works now what is the requirement for an object to be used as a key or a value in the hashmap so we have discussed what is a key and what is a value and they are saying that what is the requirement for an object to be used as a cure value so now the key or value object that gets used in hash map must implement equals or hash code method now the hash code is used when inserting the key object into the map and equals method is used when trying to retrieve a value from the map so basically it's something like um equals is used for finding an element and a hash code operation is being used for uh inserting an element okay that's it simply how does a hash map handle collision in java so what is a collision okay i will tell you that so let's say in hash map you have one two three now again i'm trying to like i'm trying to map this um a one two like first i have mapped one like 10 11 and 12 here now again i wanted to for one i wanted to map 15 now in that case this is going to be overridden right but i don't want like that i wanted to be all the values to be handled over there so in such cases how to handle this okay there is a collision right so we have already data again we are trying to insert the data back again so it will collide so how to handle these things so they are saying that uh so this is that in java this is how you will be importing the hashmap so in java uses the approach of chaining the handle collisions okay so we follow the chaining method so in chaining if the new values or within the same keys are attempted to be pushed then these values are stored in a linked list stored in bucket of the key as a chain long with the existing value yes so make sense so uh i will tell you with an example how this is works okay let's say i have a values of uh 10 11 12 11 12 and 13 14 and 15 now i will be having one hash key ascii as um two okay hashtags too now how does it work so basically i will be mapping all these things with the mode of let's say i will take this and 10 mod 2 which is an hash key here so the value is 0 so i will map all the zeroth reminder values to the one key and all the one uh reminder values to the one key let's say here i have a key values of zero on one right so if my hash key is two then i have these although only two possible ways that i can get now so 10 mod 2 is 0 so i need to assign the 10 to the 0th key so i will do that here done now we will take out the next guy which is 11 so 11 so 11 mod 2 is going to be 1 so i need to map the 11 to the 1 now i will get 12 so 12 mod 2 is going to be 0 so it means that i need to assign this 12 to the 0th so already if you can observe already there is a 10 which is been assigned to the 0 now how can i assign 12 so here i will follow and link list matter okay linked list so starting with the node of uh for the key of 0 i will be having a linked list done now 13 so 13 is going to give me the remainder as one so which means that i need to give this to the one so already 11 is existing there so i will form a chain here i will form a chain okay now there is a 14 so if i divide like um if i the remainder is going to be zero so it means that i need to map it here and again so you you got it right so i will for the every key if there is an collision is occurring then we are forming an chain like structure okay we are storing the data in the form of linked list okay this is how we um handle collision in the hash map or hash tables uh in worst case scenario it can happen that all keys might have the same hash code which will result in the hash table turning into a linked list so they are saying that uh let's say if i have given all the even numbers here okay like uh 10 12 14 16 18 20 22 like this then all the values are going to be mapped to the zero itself right zero only zeroth key only so that is what they are saying that so in this case a searching will be taking big w of n right big b of n so if i start from the like if i wanted to search for 20 then first i will be starting from 10 then 12 then 14 16 17 18 i will be searching in the mag at max of n elements n elements right so that is what they are saying that in worst case a big of n will be the complexity as opposed to we go off one time due to the nature of linked list hence care has to be taken while selecting the hashing algorithm uh so this is an like you need to be very careful while telling uh if you have user hash map in your data algorithm and you you should be very careful while telling the complexity over there because in worst case you will be taking login time and in best case it will take we go off and one time which isn't constant so please make sure that you won't get confused now what is the time complexity of basic operations get and put in hash map so yeah so they are saying that uh get and put operations so basically these are the two operations that we perform on hash map okay get is accessing sorry accessing and output is for inserting okay so they are asking us what will be the time complexity time complexity over there so in in best case okay if you are following and a seek like where you will be storing only one value to the each key then in that case the both operations will be off one time which is a constant but if you have uh if you are taking like where your map is in this particular form we have discussed earlier the complexity is going to be in worst case it is going to be big of n okay let's discuss another problem so the next problem is what is the priority key we have talked about q and stack right so what is this periodic tube so a priority queue is an abstract data type that is i like a more of you normal queue but as priority as into elements so uh let's take one example then i can tell you in a better manner okay so let's say you are in a hospital okay and which follows the first come first serve right like first in first out now you are all guys are in a queue and you went to hospital for a normal checkup okay consultants okay normal checkup now um so you are you are standing in a cube and suddenly all of a sudden someone came up with a accident okay met with an accident now there is only one doctor okay who is uh whom you are going to check up for so now what what is going to happen he will stop the queue okay he will stop the line here and he will directly jump to the accident based why because he is the priority case right he is the one which has highest priority we need to give them priority so that is what a priority means okay so here in our case of periodic you everyone will be having some priority okay everyone let's say like um if we have taken politicians okay someone like mla mp and uh governor a cm one pm so everyone has their own priority okay if like mla until this pm comes everyone is like cm is the top one we need to give them priority something like that okay so here we will be maintaining two queues two queues so one to maintain our data and one to maintain our priorities priorities okay so this is what a periodic cube means so the one who who is uh having a highest priority will be going first okay one who is having lowest periodic will be going out so it can be vice versa as well like if your program wants to be like um who is having a lowest priority they need to go to the first so it totally depends upon the application that we are using okay now so elements with higher priorities are processed before the elements with their lower priority that is what we have discussed in order to implement this a minimum of two queues are required one for data and another one for pre-artists so this is what and another thing about the periodic ease so we have a concept called heaps heap data structure okay which we will be talking about in a later part okay so in heaps we have a maxi and min heap so mostly offer to implement these things we will be writing periodic use okay we will be using periodic use so we'll talk about what is heap and what are these maxi mini hype in the last question which is a 40th question i guess okay we'll talk about that during that time so just as of now we will just we can implement maxi mini hip with the periodic that's it just keep that in mind now can we store duplicate key in the hash map so i guess we have answered this question earlier so we can't uh store the like we can't store the duplicate values in the hashmap or if we try to do that it will overwrite the values and keep only one copy that's it so this is what they are saying no okay duplicates keys cannot be inserted into hashmap if you try to insert at any entry with an existing key then the old value would be overridden okay so what value would be overwritten within new value doing this will not change the size of the hashmap right so we are just overriding so size doesn't matter so this is why the keysight method returns all keys as a set in java since it doesn't allow duplicates now here comes the trees yeah so tree data structure what is a tree so so what is a trick so three is recursive non-linear data structure as we talked about what is a linear and non-linear so tree comes under the category of non-linear uh consisting of set of one or more data nodes okay where one node is designated as a root and remaining nodes are called as a children of a root so basically we again just like uh linked list node for tree as well we will be having a node okay node so you can consider this as a node and here every node will be having three parts one is data and this is a right node pointer and this is left node pointer okay so every node will be having these three pointers they are saying that so for every tree we will be having one root so root means the top most element the very first element that has been created in the tree and all other if we of if we have at one root node then all other nodes will be called as an either children's okay or uh like subtree kind of things okay so we'll talk about the terminologies and all in the later part now tree organize the data in the form of hierarchy manner so what is this hierarchy menu so if you can see like uh let's say i have a folder named desktop okay under the desktop i have two folders one is a scalar another one is personal okay and again in this scalar a folder i will be having few other folders let's say arrays like where i will be storing all the programs related to the array topic then linked list then trace and in personal i will be having let's say documents and uh pictures and a videos and again in trees i will be having different topics if i say like um a 2.0 okay a sliding window technique and uh uh queues or stacks kind of thing and even in trees as well we will be having different types like binary trees bananas are trees avl trees red black trees okay so i will be storing something like this so can you tell me now this is going to look like as a tree right okay where we will be having one root that has a uh desktop under that desktop we will be having folders so this is what hierarchy right so one two layers so on very first layer we will be having desktop then scalar and personal folders again folders again programs kind of stuff so this is what they are referring to as a hierarchy data structure so the most commonly used data structure is a binary tree and its variants so as i said we will be having different trees okay different types of trees okay i will name the few okay binary trees binary search trees avl trees and uh complete tree complete binary sorry okay and uh b trees and red black trees so these are also all called as a trees okay but different types of trees among all these trees binary trees and binary search trees are very very important okay and even binaries are more important than binary searches if i wanted to put it in a name here okay so if you're preparing or if you're aiming for big companies big tech companies a big product gate based companies then you need to solve at least 50 plus problems on binary trees so that is going to be good count and you can able to solve the any problems and to learn binary trees or any trees then the requests are prerequisites would be recursion okay recursion for sure and some hashing hashing we use hashing in few tree problems so yeah even this is secondary okay this is secondary like recursion is a must to learn the tree so if you if you wanted to are looking to learn trick topics and recursion please i have made a video on both recent recursion where i will be solving few plenty of good amount of problems starting from the uh basics so you can watch it there as well now let's come to the applications of the trees so first applications are file systems we have seen this right so we have seen this um application here so this one application where we will be saying that this is how our file architecture is being stored okay then comments on social media so what is comments on social media so if i say let's say someone has posted or posted a picture post and i have commented and for my comment multiple people can comment it again yes and for again for comment multiple people can uh comment it again right and can i say this is going to be three structure yes okay and family trees so a family structure so where we will be having starting from the grandparents then parents when uh we generations and then our next generations like children and so their children so this is going to be like pre-structure okay and uh if you want uh you can like they will be representing two things here so let me open my so uh they we will be having a root okay let me take this out okay let me draw this here okay so we will be having first root our root okay so under this we will be having different trees right so i will be writing binary tree here so um here it is in a nra tree so where we will be having uh like different number of amount of childs to an particular root okay now this is a root this is a root and here this is called as h so what is the h so edge is being called as a connecting point to the one a level to the another level okay it creates a representation okay it creates a connection between two nodes and the data present in the node is called as a key then done now these two okay like for this particular route these two will be called as a siblings yeah siblings these two will be called as a siblings so what is the siblings so in general in real world we call um like one level okay like if i say me and my sister we call as a siblings right so we are belongs to one same generation you can consider this as one generation okay and then we have a parent okay and we have parent let's say if i want let's say if i want a parent of if i wanted to parent of these guys i can say that for these two this is the parent parent right and i can say that this is also another sub tree okay subtree and the nodes which don't have any children the nodes which don't have any children are called as a leaves okay nodes which don't have children's are called as leaves okay the subtree means a part of a tree a parent means uh which has some children's then that is called as a parent an edge means connecting point between the two nodes a key means a data which is present inside a one particular node and the root means the top most element where a tree has been became a siblings means which belongs to the same generation or the which belongs to the same parent okay which belongs to the same parent so we have discussed enough and um yeah um now let's move on to the next question so what are binary trees yeah good question what are binary it is what is a binary what is a binary i can say that to either 0 or 1 so when i say binary it is to write one or zero so this is what a binary tree means okay so for each parent or for each root node we will be having two children at most two children at most okay so let's say i have a root okay let's say i have a and for a we will be having two children's b and c okay and for b again i have two children for e and d and for c i have only one children called f and for f again i have two children so let's say g h okay and for e i have another children called x so here you can you can if if i say if i for each node each node we will be having at most at most two children then it is called a binary tree okay so a node okay a tree which has okay at most two children for every node then it is called as a binary tree so you can uh you can consider these two diagrams as well okay so where uh in in the first in left-hand side we will be having a normal tree okay where we will be having uh three nodes here then again like for again for everything we will be having again three so which is not a binary tree right which is not a banana two so if you consider this tree so here we will have two nodes for this and for this we will be having two for these two for these two and for this we will be having 0 0 0 so i say it at most 2 so it can be 0 it can be 1 it can be 2 okay these are the three valid uh things accepted so this is what a binary tree means now let's move on to the next impression so what is a maximum number of nodes in a binary tree of height k what is your height okay what is the height so let's say a height is the number of levels it has okay so from this it can be considered as a one height it can be considered as one height two three okay like sorry three four okay this is a height of four okay now their their question is they will be having a height k and they are asking us to what is the maximum number of nodes that you can have for the height of k binary so let's see okay first let's try to draw the tree which has the um some minimum number okay let's say okay so i have this then two then three then i have this three and uh sorry four five this six seven for this again i have eight 9 10 11 12 13 14 and 15 so this is the height of three okay three so here okay so until here one one and one okay so the height is three here okay the height is three so now tell me how many notes are there can i say that 15 notes so here it belongs to the eight it belongs to the four will belong to and one so what is the one thing that you have identified so by increasing the one level at each time we will be going in a two power manner two power manner okay so for three size we will be having at max we will be having 15 nodes which is going to be 2 power k plus 1 so here k is 3 right so uh 2 2 power 3 plus 1 is going to be 4 so 2 power 4 is 16 so 1 minus 1 so this is the formula that we can get yes so they are given something like that now write a recursive next question is write a recursive function to calculate the height of a binary tree okay height of a binary so let's take one binary here um then three five six and seven so in this case the height is r3 okay the height is three so if i am currently standing at this particular node if i am currently standing at this particular node so um can i say that the maximum left subtree the height of maximum left sub 3 and the height of maximum right subtree plus 1 so y plus 1 i need to include this particular node as well right so can i say that max of a left subtree okay sorry a max of f subtree comma right subtree plus one as my answer yes i can i can so by using this formula how can we write our code so for this we need to know a traversal we need to traverse through all the nodes of a tree yes all the nodes we need to traverse through all the nodes of it so how can we traverse through all the nodes so we have a three things okay to traverse through all the nodes so which is we have two techniques one is dfs and bfs okay uh dfs means a depth first search we will be first let's say we have a tree something like this so we will go till the depth wise like will reach till the leaf node and then we will go back and then we will come to another way okay which means we will come to the start from the root come to the leaf then again we'll go to the another way okay but in bfs manner we will be going in the fashion of breath wise okay so one breath two so breath means horizontally dfs means vertically okay uh so for this we have again under this uh bfs again we have three things pre-order post order and in order okay pre-order post order in order and we'll discuss about them in detail okay in later part now just uh try to solve this particular problem then uh we'll see okay so if i'm currently let's say i have three like this okay now first i will i will give the pass the argument as my root node okay which means i'm starting at here now what is the first thing that i need to check so i need to check if that particular root node is null or not if it is a null what does it mean i don't have any nodes okay so i can simply return 0 right so first thing check if root equal to null so if this is true you can simply return a zero right if it is false if it is false what does it mean you need to go to the left sub tree then you need to go to the right subtree and you need to check the maximum of them okay you want to get the maximum out of the left subtree and right side okay now let's say i will go here first i will go to the left side okay then i will calculate the height of this particular two okay again i will check okay i will make a recursive call okay you can see that here okay i will be making a recursive call and then i will check root is equal to null and no so i will go to the left subtree now left side now again i can check root is null or not so again i can see root is not null so i will go to the left now is there anything here no there is nothing so i will return 0 will return 0 here okay i'm done going to the left side now i will go to the right side and i feel that there is nothing here as well okay there is nothing here as well so the right the right subtree of 4 is going to return 0 now you need to take the maximum off for each node you need to take the maximum of left subtree right subtree and then you need to add the one which is a current level right so maximum of zero on zero is going to be zero right now you need to add the one so zero plus one is going to be one okay which is which is this okay the left sub tree of two is going to return one okay and then you you will be going to the left side right side of the two and again you will say that it will return 0 it will return 0 so you will return 1 so among 1 and 1 of 2 so left subtree of 2 is 1 right subtree of 2 is also 1 so if you take the maximum amount of them you will get one and you will add the current node which is again one so two okay so on going to the left sub tree of one you will get a height of 2 done so now let's go on to the right subtree so i will go here and i can see that there is a the the root is not null so i will go to the left and then again root not so i will go to the left so here i will say it will return 0 and return 0 because it don't have any uh left and right software so i will return 1 here right 1 now it will go to the right which is an null okay it will return zero so among one and zero which means a left subtree and right subtree the one is the maximum one so it will return one plus one so two here now for 3 it will go to the right and there is nothing so it will return 0 and out of 2 and 0 2 is the maximum so it will return 2 plus 1 so which is a 3 done now for this again you will return 2 plus 1 which is a 4 done so for this the height would be the done i hope you have understood so this is how like if you wanted to write the code for this you can check this out this is how you will be writing the code so write a code to count the number of nodes in a binary tree so they are asking us to write the code to check the how many number of nodes present in the binary okay let's say if i have a given a binary tree like this okay now how many nodes are present in this so one two three four five six seven eight nine so at max i have nine nodes nine nodes so my answer would be 9 here so can i say can i say if i want the total number of nodes here total number of nodes here then can i say that the total number of nodes at the left hand side plus the total number of nodes right hand side is going to be my answer plus one right so uh count left side okay plus count right side plus one right so whatever how many number of nodes are there in my left hand side it is going to return three and how many number of uh nodes are there in my right hand sub tree or it will return five and uh here i will do plus one for the current root note so i will do plus one so at is at max it is going to be three plus nine sorry three plus six it is totally nine done okay so this uh simple okay you can try it on your own so this is the code that you can check it out so tray travel source okay as we have discussed there will be three traversal techniques now let's try to understand three traversals in this tutorial we will be learning about trees right from the basic so uh what are the contents that are going to cover in this entire tutorial is different types of arteries available and binary trees and what are the techniques to travel sell in an particular tree and also we are seeing the implementation of trees and implementation of traverse techniques and coming to prerequisites it will be good if you know what is the structure and class and to study trees the recursion is mustang should okay so if you don't know what is irrigation please go and watch my previous video which is a made on a recursion and yeah that's pretty much okay so let's get started oops before starting we do have few formalities to do so first one if you are wasting channel for the first time don't forget to subscribe if you like the content please hit that like button up and if you have any queries please let us know in the comment section now let's get started now let's get started with introduction to the trees so i can simply say that a tree is a non-linear a data structure what is it mean by non-linear so basically data structures has been classified into two types one is a linear data structures uh like um linear data structures like uh arrays linked list stacks use okay and another types are non-linear data structures so non-linear data structures means trees graphs why this is our collagen now these are all called as in non-linear data structures basically entry and graphs uh stores the data in the form of hierarchical okay so what does it mean by hierarchical again so let's see so basically if there is something here okay if there is something here and data has been stored in inside to that like whatever it stores it will be linked to that on top of that level okay now again for this level it might have something okay so it might be anything okay it can have n number of things okay so can i say that these are all one level 11 these are one level can i say that so these are all in one hierarchy so here on hierarchy then hierarchy it has something it has something it has something right so this is how that tree stores the data okay now by this means we are calling it as a hierarchical data structure now let's see uh there are a few things that we need to know before starting the actual representation or coding whatever it might be okay so first one a root okay so i will take a simple uh tree okay now then i will explain everything on that tree itself okay so let's assume we have entry something like this okay now let's see so what is your root so a root can be defined something like this so root will be the starting point of the tree okay so here where did that uh root has been started sorry trey has been started here right so is there anything on top of it no there is nothing in top of here is there anything below the yes everything whatever that comes whatever the data comes that will be below the so can i say that a will be my top so by that means i am calling it as a root okay now something parent now the next one is parent what does this mean by parent what does this mean by parent so a parent is a node okay so which has some change okay let's see let's see let's see so i can say that a has this b and c okay so from a there are two things are coming okay so they are called as in chains okay chills so this b and c are child's of a okay so now these are all the cells who will be called as a parent here right so it's apparently and jails are b c and b of the shells of a cool root is a now what are all the other patterns that you have you can see on this particular diagram so here can i say that b is a parent of d and e right so b is also apparent so can i say that g and h are chills of c yes okay now is there anything is there anything below this d nothing so i can say that d is not a parent okay so that is what happens now the next one is so basically each so i forgot to say everything will be called as an one node okay so this will be called as one node this will be called as a node okay this will be called as a node now at degree degree degree of freedom what is a degree of freedom a degree of a node means the outgoing nodes number of outgoing nodes from that particular node let's say from c how many nodes are going like how many chills let's say chills okay so how many childs are there for c there are two gels right this is g this is a h so there are two things for a how many cells are there again two okay now tell me if i add one thing to g something x okay now tell me what is the degree of a g it's a one i hope you got it right so it can i can say that a degree is something the number of the number of children it has okay particular node has now um so and center what is this mean by angela so and center is something like this okay so let me draw another tree okay so okay now can i say that for this particular node this is an center so the top okay the previous one where it has been generated okay now can i say that this is a and gender of this particular node yes so let me tell you one simple trick okay so this will be your current generation okay so this will be called as a parent grandparent grand grandparent right so these are all the ancestors of this particular guy okay now what are the ancestors of this guy who are the ancestors of this guy this one this one okay so who are the ancestors of this guy no one because a root itself is the starting point okay so there will be no ancestors for the root okay now if there is an centers then there is there will be a descendant as well so who are callers and descendants okay the one the one uh which it has uh like the change of that particular node okay let's see okay let's see so this is one thing okay now if i wanted to say who are the descendants of that particular node you can say that this guy and this guy i can say that right these are all now you can simply call as n so consider this as your appearance okay parent okay now you might be having like he might have one daughter one son something like that right so you can relate to that particular thing as well and the next one will be siblings siblings of a node let's say what are all the siblings okay so uh the siblings means which comes from the same parent okay the notes which comes from same parent let's say i have a tree something like this now for these two guys who is the parent the same one this one now can i say that these two nodes have came from same parent so by that means this will be this particular node will be and sibling of this guy okay again it will be a vice versa as well so for this guy who is a sibling he might right so let's suppose he has another uh node okay another change then for this particular node there are two siblings okay two siblings so this is how uh things works and the next one is a leaf node leaf node leaf node what does it mean by leaf node a node which don't have any outgoing nodes okay a node which doesn't have any children's okay child nodes then we are calling it as a leaf node okay so here if you consider if you consider this particular node has no chills this particular node has no change this particular node has no chills and this guy this guy has one node this guy has one node this guy has one node this guy has two nodes this guy has one node again right so this is the okay so a last level of a particular unknown okay will be called as an leaf nodes leaf nodes okay on and again internal node okay a internal can be defined as an a node which has at least one node one outgoing node or one parent or sorry one children is called as an internal okay a node which has at least one children is called internal okay now uh let's see now there is another important term height and depth of a tree okay height and depth of it so in basic okay so height can be defined as in the max path from root to leaf node let's say i have a tree something like this okay i have something like this okay now tell me what is the highest path from starting from a root to leaf node okay now this guy this guy this guy so here i have path which is very highest okay it has a four nodes okay four nodes path so if i consider this path it is only three it is only three right so here that we have a four nodes four nodes so by means that we can say that number of nodes in a path minus one so then that will be your height okay so here we since we have four nodes involved in that particular path it's a n minus one okay four nodes minus one it's a three okay i can say that this the height of this particular tree isn't three okay now what will be the dip okay now let's see what is it okay you have a tree like this now if i wanted to uh find if i wanted to find depth of this guy okay depth of this guy i can say that from root okay starting from the root what is the number of nodes involved in that particular till that particular node so there were only one node which is a rule right you can exclude this guy okay so now can i i can say that a depth from this particular from starting from root to this particular node is a one now at the same time if you want to find this guy what will be the depth of this guy it will be tuna it will be two so why because starting from the root till that particular node there are two nodes involved okay you can simply call it a path as well so one guy and two guy okay so you can cancel that as well okay so that will be defined as a depth pull let's discuss about a binary so binary is a very important tree which is being asked in many interviews okay so you can expect a lot of artery questions from planetary and binary search trees okay we will talk about band statistically latest now we'll discuss about what is a binary tree so a binary tree is a node a node or every node okay let's call every node in and tree in a tree must have at max of two children's okay to a unknown so i'm saying that let's say you have a node okay it must have either zero or one or two children's of the only okay let's see so we have a node and for this particular node we have two children's this is valid okay we can have zero or one or two okay at max two no two children's okay so now we have a two which value now for this uh particular node again we are having one node yes again it's valid now for this we have a two child nodes it is also valid now for this particular node we don't have any chill nodes so the degree of that particular thing will be zero it is also valid okay you can consider these things as a degree as well degree of a every node should be less than 2 less than or equal to 2 okay now then we can say that it is a binary tree now again in binary tree we have a couple of types a first one is uh first one is a full binary full binary or it can be called as a proper binary tree and stick the binary tree as well okay a proper binary and a strict binary as well and then next one will be complete binary tree okay then the next one will be a perfect binary tree then a degenerate binary tree at last it's an a balanced binary tree okay now we'll talk about each one of them okay so full banana it remains so a tree which has either which has either a zero or a two nodes or two children's then it will be called as an full binary tree let's say unlike a binary tree of our binary tree what are all the possible child nodes zero one and two okay so here in this particular full binary tree we can say that one is not allowed okay so zero okay so root and for this we have two and for this again two and for this particular node we don't have any chill nodes it is a full banana tree okay we have only either two or a zero possibilities okay now let's say if i say just tell me is this a full binary unknown this is not a full binary just because of that fact that for this particular guy for this particular node we have only one node one chain node so one is not allowed okay it has to be either zero or two okay in that by that means we can say that it's a full band at it now we'll see what is a complete binary a complete uh there are certain rules to follow okay so first one is all the nodes are completely filled except the last level okay let's see so if i have a tree something like this okay so before coming to this particular level we need to first fill this level okay so let's say so here here we missed out entering into this particular right of that particular node we have just uh going in a left manner right so this is not allowed okay so before coming into this particular level you have to finish this level okay so let's say first i have to fill the root then i have to enter the left okay then i have to enter the right okay so now it's completed because binary has only at most two things two chain notes and now i need to start from the left okay left so for this guy here and this and now let's say i can't enter like this okay i can't enter like this just because i need to first before coming to right right side i need to first complete the left side of that particular node so i have to complete this then only i have to come back okay now this is how a complete binary tree looks like okay now the second point is in last level all nodes must be as left as possible okay let's say we have another level okay so i have stopped here okay there are no nothing to enter in a tree okay nothing to push in entry now so with this where that the where i'm ending at so i'm ending at left left most side of that particular trick you can say that right now that is what this second definition is now sec throat rule so the node should be added from the left so as i said earlier we need to start from the left side left side of the each level okay so this one is one level this is one level this is one level this is one okay now for every time we are starting fresh and new line fresh level we need to start from the left side okay now that is a complete binary now let's see a perfect binary so now perfect binary tree can be defined like all the leaf nodes all the leaf nodes of particular tree should be in an same level okay same level let's say we have a tree like this now tell me what are all the leaves here this one is a leaf this one is a leaf this one is now all the leaves are in one level no okay so this is one level this is one level this is one level so one leaf is in second level and all other leaves are in trawl level so this is not a perfect binary so how does that perfect binary tree looks like so like this so here all the leaves okay so this one is a leaf this one is a leaf this one is a leaf okay there is no another leaf so all the solutes are in same level so this is called as a perfect binary tree now the next one is degenerated okay degenerated binary trig so basically it's very simple okay so it it looks like this okay it keeps on going at one end only okay so there's something like this as well it is going in a one side okay so let's say i have started from a root okay and then i move to right then i can move to right then i can move to right then again move to right then i can move to right now there is another possibility i have started from the root i have more left then i have moved left then again i have moved left again i haven't moved so i'm either i'm going starting from the loot and going in a left manner otherwise i have i'm starting from a root and going in a right man that's it okay so that is called degenerated let's see how to implement in a binary tree program okay so in this particular thing i will be discussing the code of binary tree in both a language like c plus plus on java okay let's see so a basically a general banner tree something looks like this two and three and four and this will again have five and ten and eleven okay let's assume so let's try to implement this particular binary train and program okay so i can say that this is one node okay this is one node one node one node or node one so everything is unknown yeah so and what every particular node has like every node has some data and this particular node is pointing to something okay and this particular node is pointing to something so can i say that it is pointing two things one is a left one is a right yes now let's see how this particular thing will be different [Music] it will have something like this okay now this a left okay so left thing will be pointing to again three so again which is a node okay so again three left is pointing to something called four again a three right is pointing to node five and right to the 2 is a 10 again it is a no again right to the 10 is 11. so yeah the things that you need to observe here is every node has something like data and a left pointer and a right pointer okay now let's first let's discuss about c plus plus co so how will you represent the same in c plus okay there is much difference between a both c plus plus and java code okay it's only syntactical changes let's see so in c plus plus how we will be using a struct to define a node okay so what it contains a particular node contains some data that is in the format and again we have some both a left and right pointer can i can i say that again a left hand a right pointers are notes right again then what will be the type of these things again struct node star left struct right good yes now let's see how will you implement the same in java okay so in java you will you don't have any struct okay so you have to use a okay a class node okay so you will have in the data okay then here the type of a particular left and right node node left node right now so how to as any data okay so we will have it we have a concept called a constructor we use that concept to initialize the values to and no okay so how it looks like so here a constructor name should be equal to either a struct um name okay so here the stack name is node and here the class name is unknown okay so constructor name should be equal to that so in value okay so since we will be having some value like so while creating a particular node we have to pass that value to that particular given node now so we need to assign that value to data data equal to val now what will be our left and right okay so just assume just assume so you are creating a node okay so since you are just creating a node of root you don't have any kind of left and right right so you have to initialize them to the null okay so left right equal to null okay the same code goes in now java as well a node into value so here you will be assigning uh this dot data equal to val and both are left underwrite equal to null okay in case of java your null should be capital okay you are done now we have created an uh like definition for how to define and now tree node now how to assign a values to this let's see so we'll have a main class main so first you need to create an root root of a tree so struct node star root equal to new node what what is the data of our node so like a root node it's a two okay so you will pass to here done so it will create an something like this done now so you need to create a left and right to that particular things now so how how will you do that so root left equal to so now you are pointing to here okay so root left so again it will be a new node new node of let's say three okay so we have created a three done so now you have you will be creating a left to the left okay so root left three three left four okay so you have to create something like this then how will you do that root left left equal to no node of 4 done now i wanted to create an right to this guy right to this three node okay so what will be the path so root left and root left right okay so root are left right equal to new node of 5 done now i wanted to create an uh root right okay so i wanted to get something like this a root right of seven okay so how can i create root uh right equal to new node of 7 that's it okay so this will form and tree something like this okay so done so there is not much difference between c c plus plus and java code so here instead of using this uh things you will simply use on node and instead of this pointer symbols you will use a dot okay so that's it so you can try on your own as well so now let's see the travel cell techniques of an uh tree so what is a traversal so basically in arrays on linked list right from the zeroth index you will be going to the nth index so how you are using that how you are doing that so by using for loop right so you will be initializing in ti is equal to zero and i less than n and i plus plus so something like that so we need something similar okay to traverse in a tree as well so what are they okay so we call them as a traveler techniques so we have our two things one is a bfs breadth first such and at dfs a depth first search okay so we'll see okay well we'll take some example one example and we'll try to apply these techniques on this uh three okay so we'll let's assume we have a tree like this okay so one none want to be right three four five six and eight now let's say so first we'll see the bfs so bfs what is the beer so breathe first so break breath breath right so i can say that this is one thing but this then this then this so similarly similar can i say that we are going level by level so first we are printing first level then we are visiting next level which includes a 3 2 1 3 then these values of 4 5 and 7 and then this last level eight so simple right so birth persons in means so we are going a level by level so we are printing level first we will completing the first level and then we are going to second level and we are seeing all the visiting all the values or nodes in an particular level then we are going to the next level then we are going to the next level so this is the breadth first search now we will talk about the depth first search okay so which is a very very very important very very very very important okay so again in this particular dfs we do have a three types so preorder in order post order very very important okay so you can do wonders in entries by using these uh three things okay so you can solve many problems i can say that even i can say that without these things you can't solve a few most of the things okay most of the problems and entries okay let's see let's see one by one so before going into finding and how to traverse by using these things now you have to remember few things one is for pre-order pre okay so in one particular node what are all the things we do have a data left and right okay so every node has these things now but with these things we are using uh like we are traversing through the entire of tree okay let's say in pre-order first we are printing the root so when i say root it is the data root data okay now then left we are moving to the left okay left then we are moving to the right okay so first we'll do the whatever the data it has will visit that particular data then we'll go to the left okay then we'll go to the right of that particular particular node okay so now what is about in order in order okay so it's a first we'll move to left then we'll move to root then we'll move to a right okay so in post order first we'll move to a left then we'll move to right then we'll move to a root so now we'll take in one example tree and we'll try to traverse uh we'll try to use these three dfs techniques on that okay so let's assume we have a tree something like this 2 3 5 6 7 8 10 and 12 okay so let's take so first we'll solve start with pre-order what is it period okay so pre-order what are the rules uh what are the formula for prior so it's a root data and left and right okay now where where do we start from we start from this particular root okay so what is the formula r l r so here it's an root data okay root and this r is right okay so what is the first thing that we have it's a root data so whenever we have seen a root data we have to get that particular node data to the output board okay so here in this case here we have two okay so we'll print two here so by means that we have done with this particular r now what is the thing next thing it's a l so it means that it is stating that go to left side okay we'll move here now again we'll repeat the same task for this as well so first thing root data so you have three now it is stating that go to left okay by going left we will come here now our log so now again it is taking that root data so we will have six done now again it is stating that go to left is there anything to the left it's a null there is nothing okay done with this enlargement okay so since it's we are not going there okay now go to left right so is there anything to the right of the six or no so we are not going to the right as well so we are cancelling so done with that thing i can say that we are done with six okay now we will go to the top whoever call this particular six okay it's a three so we are done with this l we have moved to l and performed all the operations right now we have to go to right side of three so it's a seven now again we need to repeat the same task for 7 as well say r so it is stating that print the root data now go to left is there anything to the left is there anything to the left and no is there anything to the right no right is there anything to the left no is there anything to the right or no so we'll cancel that thing as well and then we'll go to the top whoever called this particular thing so we have wasted the right as well so cancel that okay now again from here we will go to top so you have done this operation you have done this you have moved to right left as well now you have to go to a right side so you will come here so again you need to repeat the same task so first r so r means visit the data so it's a 5. now again it's a left so you will go here what is the left okay say again you will simply repeat the things so again you have 8 then it is saying that gold left side there is nothing left okay now is there anything on to the right or no so we are cancelling and we are going to the top okay now currently you are here but then we you have moved to left now you have to move to right okay so right is 10 so rl okay now again first is data so we'll print that 10 now it's a l so it means go left is there anything in the left yes there is to one right so you will move here and you will have lauren okay now again first is our data so we'll pin to one then again it is saying that left goal so there is nothing left again it is saying that going a go right there is no nothing on to the right of the tool so by means that we have completed this particular node as well now we will go to top whoever call this now we are done with l now we left with this r so is there anything to the right to that particular tent no so we have completed that and we have completed this node as well and we'll go to the top okay so we have completed the r as well okay these are all the are right now we will go to the top we have complete and we have completed that so now check so we have nothing to visit we have done with all now check whether all we have visited all the notes of a tree or not okay so first thing two then three then six then seven then five then eight then two one ten so done we have visited we have visited the all the notion entry so this is how a pre-order works now let's see the in order okay in order so became little mess okay let me draw the tree again now we will try to uh see the inorder traversal of this particular trick okay so what are the in our travels and rules first you have to go to left then you have to move to root data then you have to move to right okay so let's write these things l r r okay second thing is a root okay now first it is saying that go to left okay go to left now again you will have lr so again it is stating that go to left again you will have lrr now is there anything to the left of six no so it means that we are done with left now what is the next thing it's a root data so whenever we have seen root data you have to print that out like whatever the node value have to print that in output so here it's just six okay so by means that we have completed the r now it is saying that go to right is there anything in the right no okay so we have completed this and we'll go to the top okay now we are done with left now what is the next thing it is saying that print the data of the particular node so here the node data is four okay we are done with this uh now it is stating that go to right okay so we will come here now we'll again have the llr okay now first thing it is saying that go left is there anything left no now the second r is root right root data so we have to print the seven now it is stating that go to right is there any write to the seven no done will cancel this then you will go to top so you are done with second r then you have done with triad as well so you have visited you have uh travels with the entire subtree of this left side now we will go to the top now we are done with this our ll sorry now we will try to see this r so here our root data so whenever you have seen root data you have to print that particular node data so it's a two now we are done with the second arc now we have to go to the right side now you have to repeat the same task l so it is saying that go to left first okay so you will come here okay now it is same is there anything in the left no and next one is our root data so what is the data here 10 so we will print 10 here so is there anything in the right no so completed go to the top call this particular thing now you are done with the left then what is the second thing how do you print the data so it's a file now it is saying that go right side okay we will come here so it's a 12 okay sorry l rr okay now you will say go left again so is there anything to the left of dual yes it's a tattoo okay you will come here now let's say is there anything to the left no then it is a print it is saying that print a root data so we'll print 13 then it is saying that go right is there anything right no so since you are done with this then you will go here so we are done with the left and what is that next you have to print the root data so it's a 12 now it is saying that gold right is there anything the right of dual no there is nothing to the right of tool so we have we start this as well and you will go to here five now you are done with l you are done with r you are done with this r you have more to write as well so i have done this done so did we covered all the nodes so six four seven so let's count eight okay so eight yes we have covered the only visitor we have listed all the nodes in that battery now that is what is the last order so it's a poster now again we'll take another example and we'll see so it's a two three five four seven six eight and ten okay now we'll try to find the post order traversal of this particular trip so what is the post order travel it's first go left then go right then go root data okay so l r r okay so here r means the second our second thing is right so last we are having a root data so make sure you don't confuse okay okay let's start so first it is saying that go left okay so we'll come here again we'll say rr then we'll go again it is saying that go left lara now again it is saying that go left is there anything left of 4 unknown now it is saying that go right is there anything to the right of 4 no then it is saying that root data so we have to print the data here so it's a 4 first now you are done with this then you will go here okay so you are done with left now you have to go to a right okay so here right means seven so here so is there anything to the left of seven no is there anything right of the seven no the last one is a root data so it's a seven ah now we are done with this then we will go here now you are done with this right as well now you have our root data so it's a three now i will go to the top you are done with these three now you are done with this left now you have to go to the right side okay now it is saying that go left again so you will come here now is there anything left of six no is there anything right off six no is end is that so you are you have to print that data so it's a six you have done with this node then you will go here so it's a five so you are done with the left now you have to go to the right side so first thing you will come here and it is saying that go left okay go left so it's a tenth okay so we say entering the left often is there anything right off the tent it is saying that print that no so it's a 10 done now we will come here okay so it is saying that go left so done left so it is saying that go right now so is there anything in the right of the eight no okay now it is saying that print the root data so what is the root data eight now done with this i will go here now we have more to left we have more to write now we have to print that data off no say five now done with this now we'll go here we have moved to right as well now it's a root data so so how many nodes are there totally eight so we got eight so this is how will travels these things uh in entry okay so again i am saying that these are all very very important so if you don't understand please make sure that uh take another example tree try it on your own okay try it on your own solve uh to do take to do three examples and try to write the in order preorder post order traversals of that particular tree okay now we'll see the uh code of this how like implementation details of this particular travel cells let's see how to implement an at this travels in an in c plus player okay and see so there is no big difference between a c plus plus and java code okay so if you could have understood c plus plus logic then you can easily implement a java logic if you know recursion okay so let's see first we'll start with pre-order what are all the rules of pre-order so first we move to right first root then left then right right so this is the pre-order travel so let's say up tell me one thing tell me so this is the root okay so we need to start from here so i will have a function like this void pre-order where i will be taking a node star a root okay root now tell me so let's assume if that particular given node is null okay if that given root is null what do you need to do you need to simply written nothing nothing to written okay so like you won't have anything okay let's say if root equal to equal to null you will simply just statement like a written okay you are not returning anything that's simply written that's it now if that is not the case if that is not the case if root is not null what you are going to do so first thing will fill the root data in your output so c out a root data okay root data okay root data now tell me so we are done with this part now what you need to do you need to go to a left subtree right left is update so let's go there so again tell me after going to the left subtree what you need to do you need to do the same task what you did for root right so i can call a pre-order of root of left now my root will become a three okay now my root will become a three now again i will do uh check with whether root is null or not so if it is null i will simply return that's it if it is not null i will print a two and three then i will go to the left of three so i will come here now again i will do the same task again i will do the same test first i will print the file then i will go to the top i will check how i will go to the left of this file now left of 5 is null so here my root is currently null so i will simply just return from that okay so if i return i will come here now what is the statement so after returning to the file so here we are done with the root we are done with the l now we are we have to do it go to right reorder of root 2 right that's it now again after going into right side i will found that again my root is null so i will simply return from there okay so i'm done with this i will go here i'm done with the left of this now i have to go to right of this now again i will do the check for rudy null no it's not null so i will go come here so i will print a root data so true data is six now i will come to the second line here now i can say that go to a left okay so after going to the left it says that it's a root is null okay so you you will come to here now i am saying that go to a right right go to right so again the root is not there is nothing to do now we will come back to previous note we will come back to who call that's how you will get to here three right so after coming to three you are done with everything right so we have visited l then you have mr right as well so done so you will go to here now you are done with uh are done l done you have to go to r so right side so we'll come here now then you will move to left side again you will print the four seven okay then you will move to left that you find out that there is nothing left on the left of the seventh so go and then you visit the right side of the seven there's nothing then you are done you will come here so you are done with the left so you will move to a right so you will go print eight then you say nothing you will go to four then you will go to two done so this is how pre-order code looks like now let's go simply you can keep clear write the code for in order so only one change right only one change what is that change what is that change so if root equal to equal to null what we will do we'll simply return from there if not if not first we need to move to in order l r r so this is a root so we need to first move to left of the root so root a left okay now what you need to do now you need to print the data after moving to which a root data okay now after doing this you will move to right side so in order root right that's it right that's it now now the one which is left is white poster again you will have a north star root if that root is a null root equal to null will simply return if not in all other cases you will first you will move to left side so post order root left then after moving to the left you will move to next right so post order root right after moving to the right at last you will print the root data root data done so let's discuss another question question number 29 so the question number 29 is binary search tree what is this binary search tree so it is also a binary tree it is also a binary for sure and but it will have few conditions okay it is a binary tree but it will have few conditions what are the conditions so if we have a root like this okay and all the right okay all the right side to the root elements must be greater than greater than root data and all the left side all the left side must be less than a root data right so this is the condition and which is also in binary so we know what is a binary tree so a binary tree is a tree which we can have at most we can have two children's okay so valid is zero we can have zero children so we can have one children and we can have two children so at max two and uh what is a binary tree when a search tree so banana search tree is a combination of binary tree with some conditions okay so what are the conditions so if we have a root and all the left to side nodes of a root uh must be less than the root data and all the right side notes of a root must be greater than the root data okay and if it has followed that condition then we can say that it is a binary search tree now let's try to implement one binary search tree so let's say we have given this data one uh five seven three let's make it ten here not one and a twelve and thirteen and 4 and 18 okay we have given this particular array then we need to uh try to write and binary search t for this particular array now first element is 10 so first at max we will check if the root is null or not yes a root is null so whatever data we get as a first will be keeping that as a root done then we will move on to the next guy so which is f5 so now what is a five so five is um so i will check first the root is null or not so here root is not null we have 10 here now and then i will check the condition so whether this 5 is less than the root node or root data or greater than the root data so i found that 5 is a less than the root data so i will keep that as a my left node done now let's assume i have 17 okay now i have 17 so a root is not null okay now what i will do i will check whether which is greater than or less than so i find that a 17 is a greater than 10 so i will say 17 to the right okay now i will go to the 3 so root is not null and i will go to the left side again which is 3 is less than right so i will go to the left side again i can see that uh left to the 10 is also not null so i will say again i will check left to the 5 right left to the 5 so which is a empty now i will say put it here now i will go to 12 so ah root is not null then i will toll is greater than so i will come to the left right side and then i can find that right side is also not null so i will check whether 12 is less than or greater than the 17 so i find that 12 is less than 17 so i'll keep this at the left side now with 13 what is it 13 so i will check from the root not null okay so 13 is greater than 10 so i have to come to the right side so i found that right side is also not empty then i will say check whether uh 13 is a less than or greater than 17 so which isn't less than so it has to come to the left side so again at the left hand side which is also not empty now again i need to check whether 13 is greater than 12 or less than 12 i found that which is a greater than 12 so i will go to the right hand side which is a empty so i will put it here now i have four now i have four so uh ten it has to come to the left side of the ten so which is not empty here again i have five so uh five is 4 is less than 5 so i have to come to the 3 again which is not empty so now i will compare with 3 so i can say that 4 is greater than 3 so 4 now i have 18 so i will start here root is not empty root right is not empty root uh so then uh i can find that uh 18 is greater than 17 so i will come to the right which is an empty done so this is how you construct an binary search tree now if you can observe if you can observe all the all the right left subtree or our values are less than root and all the right subtree values are greater than a root and if you can pick up any parent any parent you can see this particular formula so for 17 the left side we will have 12 which is a less than 17 and right side we have 18 which is greater than 70 so this is the thing that we need to follow okay this is called a binary search tree now let's move on to the next question now what is a avl key so avl tree is also an binary tree but which follows an height balanced okay height balanced binary what is this height balanced so basically we will be having height right let's say i have a a node like this okay i have tree like this okay and here it is saying that height balance so for every node for every node to its left and right subtree height should be okay if you subtract okay if you subtract then uh like let's say let me write okay current uh balance equal to height of left subtree minus height of a right subtree must be must be must be equal to the either of minus 1 0 plus 1 okay so if the if this current balance equal to any of these 3 minus one zero or plus one then it is an avl tree if not if not then this is not a avl tree okay we should convert that as a avl tree by swapping the nodes okay so this is what an um aval tree is okay so availa trees are high balanced bsts uh avl three checks the right of a height of a left and right sub trees and assumes the the difference is not more than one okay the difference is called balance factor and is calculated as a height of left subtree minus height of right side done now uh we have a a print uh left view of binary trees let's see the question number 30 first so print left view of any binary trees okay so you will be given in a binary tree okay you need to print the left view what is the left view okay let's say if you are given this particular tree and you are standing here you are standing here now what are all the nodes that you can see here from here so this is the node which you can see this is the this is and this is the node which you can see so uh so now what are all the nodes that you can see you can say that 2 sorry 4 to 1 9 right so this is called left view and if they were asked you to find the right view then what could be your answer 4 6 7 and 9 0 6 7 nine for right left this is the answer so if you observe can i say that let's consider this as one level one level one level one level can i say that in each level in each level you need to print the very first element the very first node that you can visit so here for this particular uh level your answer would be 4. for this particular level your answer should be 2 for this particular level your answer should be 1 then 9 is this what my left view yes so if i print the last node okay if i printed the last node in each of my level then it could be my right yes can i turn this particular question to like that as well so now how to write tail logic to print all the left left view nodes off and binary okay so please pause the video for a while okay think of it now we'll see one approach okay where can we we can do something like that so we have uh studied about map right hash map so uh in this particular hash map we can store all the nodes okay let's say i will i will call this as a one level okay so for zero for zero this isn't zero level this is and first level this is a second level and this is a trial level right now so for each level for each level if i'm visiting if i'm visiting the level for the first time okay if i'm visiting level for the first time and whatever a node that i am getting can i say i can put that in my map so let me do a some dry run here okay so let's pick up a tree so four two six and one and three here it's a five and here it is seven and it's a nine now let's say currently my level uh while passing i will pass this root node and i will pass my level as a zero and let's put some map here okay map so uh as of now map is empty okay now first i will come here i mean and i will just check whether my root is null or not if it is root null then i don't have any nodes in that particular tree so i should return the empty okay so in this case the uh our root is not null so what we can do so i will just check okay before going on to the other part okay i will just check if my the level okay level can uh is there in my map or not so my what is my level now level is zero so which is not there right so i can say that so just put so level and put that particular node data what is the node data here it's a four done done now uh we have seen the traversal techniques right so we let's move on to the another guy okay to the left side now while moving on to the left side i should do level plus one so currently my level is zero now my current level is one so now i will just check first whether root is null or not so root is not null what does it mean it means that it has some data so we should traverse that so before moving on to the next left and right what what should i do i should just check whether this particular level has been already visited or not okay and what is the level now it's a one okay level is equal to one now so here level is equal to zero now level one is not occurred earlier so what does it mean i'm wasting it for the first time so i should put that so what is the data it's a two okay done now i will go to the left again now the this time level is going to be 2 now this level is not occurred earlier not visited earlier so i will do r2 and 1 now uh both are empty so no need to traverse them then i will go to the top again and then i will go to the left sorry right okay right now what is the level here again it's a level is two okay so currently here a level is one from this particular node we have called level plus one so it is eleven is equal to two now tell me if i search level is already occurred so two is two level is already there so i should not modify the value okay i can just ignore that and will continue with my process so there is no right no left there is no right there is no left so i will go to the top down and i will go here now from level 0 here now it's a level 0 plus 1 it is going to be level 1 here right now i can say that is there level 1 in my map yes already there so i won't do any modification of there so simply go to there so again it's a level two so level two there yes level through there now again i have left here so i will come here so it's a level three now now tell me is there level 3 in my map no not exist so what i can do level 3 collect a 3 key and it's a 9 done now i don't have any left and right so i can simply go here and from here there is no right and left okay i can again go come here and i can go here so from level one plus one it's a level two now already level two has been occurred so i won't modify that so there is no left no right here okay done so uh i'm done with all visiting all the trees okay now what are all the values are there in my map four two one nine is this what the left view of a binary which we have taken yes so done done this is our answer right oh so are you able to do this on your own now just try for just try for uh so we have uh wrote this thing for left view now try for right view try for left right view so what what is happening for the right view so you need to you need to store the node data which is been occurred at the last the last which is visiting at the last so when can we visit at the last so it is what like so whatever the data you are seeing whether it's irrespective it is already visited or not you need to keep on modifying your data right let's say let's try it out as well so we take the same thing four two six one three five seven and three okay now so here currently 11 is equal to zero let me put my map here um so now uh level zero is not visited so i will put that here and my data is four now i will go to the left side okay now what is happening uh i have been my this is going to be level one and which is not occurred earlier so i will put that as a two now i will go to the level two which is also not visited so far so i will put level two as one okay so there is no right no right so i will go to the top from here i will come here again it is going to be level two yes level two now i need to i need to uh level two has already been visited okay for the first time but we are searching for an element which is been visited at the last so until until whatever the data has been put so far we need to modify that okay so we'll modify this level two with the second value sorry check three round okay three three now now uh we are done with this so there is no ref and no right here so we'll go to the top from here we will go to the here now uh from we are done with this as well so we'll go to the right side now this is time for the level one okay level one has been already occurred right so what we need to do we need to modify the data as 2v6 yes done now again we'll come to the left side okay if i come to the left side it is going to be level two so level two has already been occurred but i need to modify that modify to be five now again i have left so it's going to be level three level 3 is not occurred earlier so i will put level 3 as 9 and there is no left no right so i will go to the top now from here i will go to the right so there is no right so from here i will go to the top and from here i will go to the right now this time it is going to be level 2 so level 2 has already been occurred but i need to modify that the data currently which is 7 okay which is 7 now done there is no left no right okay go to the top and from here i'm done with this go to the top and this is what i have so what what is the datas i have four six seven nine is this my right view yes i'm done okay if you want to write this as a code you can simply write this as something like this okay let's say left view and i am taking a root and a level okay i will just check if root double equal to null what does it mean it should return simply zero that's else like if not you need to check whether your map contains the particular level or not so map dot a contains uh is for java if you are c plus plus quota it is going to be or this find okay contains a level so it will return either true or false yeah so if it is contents then it should return true okay so when and only if you get false then you need to put okay mp dot put what is our level comma or root data okay and in all other cases you need to go the left or left and are left while moving on to the left then you say left view or root to the left and a level plus one so here it's a point okay so since it's a java it's in class based okay now it's a if you are moving right uh left view uh root dot write and level plus one so at the end just return okay like this map is going to be either or you can pass it as a reference or it you can take that as an global variable so at the end you can traverse through all the values which are there in the map then you will get it okay this is one way okay this is one way um there is another way where you can maintain a global variable okay global variable called uh max level so you know that you will be visiting each node for the first time so if you are uh you will be initializing your max level as minus one in the beginning and if you are visiting like so instead of this particular code instead of this particular code you can just check if your max level less than current level okay so your you have initialized max as global value okay then what you can do you can update your max level equal to current level and you can uh like you can just print coco true data or if they ask you to return the all the left view nodes in the form of a vector then you can just create a take a vector like our output output.pushback root data okay so in this case you are not using an extra memory here okay so you are eliminating this map that's it and you guys know sometimes a map will take a login time so in this case yeah it mostly big off one but yeah and uh this is using dfs technique okay and if you wanted to use bfs technique even that you can try out as well so uh in this case you will be using queue okay so try it out okay we have discussed how to uh print all the nodes using bfs technique right so try it for this particular problem now let's move on to the next problem yes what is it graph data structure it is a graph so a graph is a type of nonlinear data structure that consists of vertices under nodes connected by a edges or links for storing data okay it just connecting the nodes may be directed or undirected so here uh we'll discuss that okay so here let me draw the same thing again so here then a to b and a to e sweet okay now uh this is a graph you can consider this as a one like uh area in your uh city and you can consider this as one area this has one area this has one area and this has one area so now let's try to relate this thing okay if you are standing at a area some a okay now from this you will be having two choices okay two streets okay if you're standing in a circle you will be having two choices either if you can go in this particular path you can reach to the b if you go in this particular street you will reach to the e okay so again from e again you have a path to the d okay you can either reach to b okay or if so if you come back in the same path which you have ended okay which you have came till now and from b if you have visited in this particular path for b as well you can if you if you follow the same path which you have came in then you will be reaching to the a and uh if you have chosen different path you will be reaching to the c now from d as well uh you can you have a three choices either b e c so you can again you will be having two choices either you can go to the b or you can go to the c and you can traverse to the same path which you have coming from okay so here you can consider this as a h this is called as a h what is this so this edge helps us to connect the two vertices or two nodes okay this is called as an either what is or a node okay now uh this is what at the um graph means and yeah we have seen directed and indirectly so basically a graph will be of two types okay directed graph undirected graph what is this mean okay so directed means let's say i have a all the edges which are representing some path so um so now here there is some directions right where edge is representing two so from a now you can go to only to the b okay you can't go to the e because there is no path here so the path here is you can traverse from e to a only okay so it you can see this arrow marks right so this arrow mark represents the directions which you can traverse through so this is called directed graph and this is called undirected graph undirected it is a director okay so director means where you your edges will be pointing to the the node which you can traverse from the current a vertice and uh undirected graph uh won't have any directions you it means like it's a bi-directional you can either go and you can come back on the same path okay that's it and the next question is what are the applications of data structure graph data section so which means where can we use data graph data structure so graphs are used in a wide varieties of applications some of them are as follows uh social network graphs to determine flow of information in social media websites like facebook linkedin so this is the one of the major application major application of a graph data structure what it is social media what is social media how how graph is being used in social media so everyone uses share media nowadays even i know like when i was in my very first year i don't even know why i use facebook but i don't know what is being happening over there so whenever i was started studying a graph i got to know that yes this is the algorithm where they were using so now let's say let's say profile here okay there is a profile name and profile a has around let's say two friends okay to uh let's say let's put it as undirectional so two three friends b c and d and again b will have a few more friends yes so let's say uh you can call them as a e f and even b and c are also a friends okay now a c and um like c has few friends okay h and d and a g now so how does the social media work so let's say a has posted uh one post okay so i have posted a has posted some photo now it will reach to the b it will reach to the b c and d okay suppose if suppose b has liked this particular post or commented this particular post now this particular post will be shown to the e f means all the all the people all the connections of a b as well so this is how a social media work suppose if d has commented or posted your post okay ace course then uh the friends of friends of they can friends of they can see the post okay the friends of friends of friends of this of connection has been made okay this is how social media has been working even the one of the major um application of graph is google maps google maps let's say we have a bangalore and mumbai and some hyderabad and pune and uh these are all the cities that you have and you need to go to the goa let's assume okay so i don't know what is a minimum path but let's take okay let's assume few things so uh from bangalore okay from bangalore to uh i just wanted to go to the back or go okay now let's assume the path is i need to come to the mumbai and i can go to the goal now let's say mumbai to bangalore it will take two hours of flight journey and from mumbai to goa it will take two hours of flight journey flight journey and uh there is another option for me if i can come to pune then from pune as well i can go to goa so let's say from bangalore to pune it will take uh three hours sun pune to go it will take two hours ago now now from there is another path okay from bangalore to hyderabad it will take a one hour and hyderabad to go up uh it will take uh two hours now my question is if i take which path okay which path i can reach the goa in minimal time now this is the question okay the answer is up to you okay this is how a google maps works right so where you you can you will be having different options but google map is suggesting you the best path okay that you can reach the your end destination in the minimal time right so here in this way you will choose this particular path right from bangalore you go to the hyderabad from hyderabad you go to the goa so uh here what is the amount of time that you are taking it's at three hours which is the minimum among all the path if you have went in this particular path it should have taken four hours if you have taken this particular path it could have taken five hours so if you you are following this particular path it will take three hours so this is how this is how a google maps works and this is where and now your graph data structure comes into picture so this is called as an uh shortest uh shortage distance as well okay you will be having different algorithms for this like digital okay and um yeah so you will be having different options right there and uh we will be having different algorithms as well based upon that it will be recommending you the minimum time okay so on second one is neural graph neural networks graph where a nodes represent neurons and edge represents synapses between them so our neural networks are the one of the applications of artificial intelligence or category of artificial intelligence that as well we will be using concept of data sorry graph data structure and transport grids where stations are the nodes and roots or the edges of the graphs so this is the example which we have shown and power or water utility graphs where vertices are connection points and hd wire or pipes connecting them so if this is a true real world problem okay so like a water line or power lines okay and the shortest distance between two end point algorithm so this is where so if i wanted to go to goa from bangalore so this is where shortage distance come picture now let's see the next question so how how do you represent a graph so yeah we have our two ways to represent a graph one is adjacency matrix and another one is adjacency list so adjacency matrix will contain only zeros and ones okay where a zero represents other existing h and the zero exits um represents no h okay if you observe here so we have a p q r s t okay now uh so uh we will be taking like vertices into a vertices matrix like if we if you taken this example we will be having five vertices and we will be having five uh so we need to take five into five matrix so p q r s t p q s pqrst now whatever there exists a path just put it as a one order so p2q there is there exists a path so p2q you will put one and also since it's in direction okay directed undirected graph you need to put the uh both the cases like p to q q to p okay so q to p as well you will put a one okay now this is how you fill this particular matrix and there is another way okay what does that mean so is adjacency list so but mostly people prefer this over um adjacent matrix over matrix okay it's an easy to accessible and little efficient as well so here what is the thing so you will you will take an hash hash map like kind of vector of array okay let's say if you have taken a array like this so where you will be having all your uh vertices like pq or st okay then you will create a vector here for each node where you will be putting all your path okay from p to q you can go from p you can go to q as well so you will create q okay and it's an directed graph okay there is okay so yeah this is this is a directed graph means you you can go to the only the way which uh where you will your arrow will be pointing towards okay now from p you can go to r as well okay so you will put a r here that's about the p now let's go to the r okay so from r you can go to the s that's the only choice you have so s now from q you can go to yes you can go to t hey yes and t done done now from s you can go to p you can go to s itself okay so you can go to p you can go to s and you can go to t as well okay and from t you can't go anywhere so it's an end here okay this is how an um adjacent dream adjacency list looks like okay i will try to code uh these all of these whatever we have seen so far and also we will there is a concept called graph traversal techniques okay so what is this graph traversal techniques graph traversal techniques so these graph traversal techniques are dfs and bfs what are these so we will be given this graph right like how to traverse through entire graph okay traverse means where we can go to each and every node in case of graph okay so for that we will be having two approaches one is dfs and one is bfs so a dfs follows a recursive approach and bfs follows an iterative approach and a bfs uses data structure called queue and dfs since its entry casso approach it will use a stack okay now we'll try to understand what is this graphical techniques and how to write how to code them and how to represent our graph in adjacency matrix and adjacency list in this tutorial we will be learning about graph traversal algorithms are namely breadth first search and depth first search so coming to prerequisites it will be good if you know how to represent a graph using either java or c plus plus but in this particular video i will be coding in c plus plus okay so yeah without wasting any time let's get started before starting if you are visiting channel for the first time please don't forget to subscribe and if you like the content please hit that like button up and if you have any queries or questions please let us know in the comment section now let's first discuss a bit first search then we'll see our depth first search okay so probably if you have seen my earlier video which was on trees you might end up hearing this word called a bfs over there so yes like what is the difference so in this video we will be talking about graph so the same topic now bfs so they are also bfs here also bfs both are same right no okay so these are all different because the data structure has been different so trees and graphs so again so you might if you know what is a graph earlier so you might think that yes we do have nodes here we do have adjacencies here like we do have edges and we will travels from one edge node to another node okay that's it right so yes but the difference is entries usually there will be no cycles so what is a cycle let's say you have a node like this okay you have a tree something like this so now you will start visiting from here okay we'll go here then you will go here then you will go here again you will come here again so it is never ending process right just because of the fact that you never see a root which is a null right so it will go in an infinite loop or infinite recursive calls now what is the solution so basically so you won't see this kind of situation in trees okay but in graphs we do have that situation okay so where you will be having cyclic graphs okay so graphs are being we have a different graph okay directed and directed recyclic and acyclic graphs so here we need to handle both okay so for that we are having something special for graphs okay so let's see so first we'll have what we'll see one example where we can find bfs for that particular graph we'll see couple of examples until we get some familiar about how bfs works in a graph then we'll jump on to the logical then we'll see coding path okay let's start so let's see you have a a graph like this so 1 and 2 then 4 and 5 okay so from here you will have a so here then here okay now first you will start from here one okay you will reach this guy and let's assume this is your output okay now tell me what are all the adjacent to the one these are all the adjacent so what is mean by adjacent so the nodes are what this is so basically we call these particular things as a vertices in a graph and three we call them as a notes okay so here can i say there is some path from one two two one one two three so if there exist a path then i can say that they are adjacencies okay so from from one there is a path from two two okay uh from one there is a path to two and three so i will first visit one then i will go to two then i will visit three okay now what is the next element so i will go to two okay and i will travel okay i will go to all the adjacencies of two okay what are all the adjacent of a two it's a four five and one okay so did we visited one already yes we have seen one already so we'll print four and five done so now we will go to three so what are all the adjacencies of three it's a one and five so we have listed one already here and we have also visited five two done three done one done four done five done okay so we have reached a five as well okay now you will go to four okay what are all the adjacent of a four okay so you have visited two you have visited five right so you will have to beat six so you will add a visit here like you will visit that particular six now now it's a five so what are all the adjacence of five three six four two okay three six photo so you are done with two you are done with three you are done with four you are done with six so you won't add anything okay from you will at last you will come to six what is a six so what are all the adjacent surface six four five okay so you have visited four already you have wasted five already so can i say that now on this note i have visited all the notes visited all know all vertices done okay so hope you got some idea how bfs works now we'll see another example okay another good example so that you will get some clear picture about how this dfs algorithm works okay so let's take another our tree and we'll see so graph sorry one have two and three and for two you have a four and for a two there is a five as well and there is a cycle and you have a another node yeah and surprisingly and surprisingly we have another a graph here let's say seven and eight okay seven and eight so is this a valid graph you might have that question is this a valid graph yes this is a valid graph so basically this entire graph will cause of one component and this one entire graph will come as another component component graph okay so there will be lot of questions like there is some important questions based upon this component graph okay so hopefully we will see them in next videos so here now let's say i will start with one okay i will start with one so i will put a one here now what are all the adjacent to the one say two one three so i will pick up a two now i will go to all the adjacent of a two so who are all the uh yeah three so now i will go to adjacent of three so it's a 5 4 1 okay so one is already visited 5 and 4 so you will have a 5 and 4 done so i have completed 1 i have completed 2 now i have 3 so 1 4 that's it right so i have already visited one i have already visited four so i'm done with three so now i will go to five so five five who are all the adjacents it's a two four six okay two four six so two already done four already done so there is only left with six we'll add that now we'll go to four okay so for four two five six three okay two done three done five done six time okay there is nothing to add now i will go to six okay so for six who are all the adjacents five and four okay four done five done okay so on this note i'm done so there is nothing to visit again now here one thing one thing one thing so is this also a graph we need to traverse this as well okay so i will again start from this node okay so then i will add seven okay now where all the resistance will be seven it's a eight now we'll complete at 7 and now we'll go to 8 so is there anything connected to the 8 yes it's a 7 so already 7 is visited so we are done with here now there is nothing to add to the next so this is how it works ok now let's see how our logic will be for bfs okay so listen carefully so which is very very important concept for any interviews if you are attempting like if you are attempting some good product based companies these are all the questions that are going to target okay you might think that this is just an traversal algorithm don't think like that this is beyond that okay this is beyond that you can solve lot of problems using this particular bfs and dfs algorithms in a graph okay now let's uh take a one good graph and we'll try to build our logic by using that graph okay let's say i have it graph something like this one then a 2 3 4 okay i will have 5 6 and 7 8 9 okay so from here here here yeah yeah okay so first thing so whenever you have given an graph you need to draw an adjacency list okay you need to form an adjacency list of that particular graph so you might be wondering what is our adjacency list so you can consider if you are a c plus plus coder so you might think as a vector of list okay and generally there are two ways to represent a graph so one is uh adjacency matrix another one is adjacency list so in adjacency matrix you will represent the graph in terms of ones and zeros where you will be taking vertices to the vertices okay so how many like if there were nine vertices in a graph you will take nine columns and nine rows it's a nine by nine matrix and you will be if there is a path from one particular vertices to one particular what is let's say one two three you will represent a one over there if there is no path between one and three you will represent zero okay so it contains only zeros and ones okay so that is how adjacency matrix is going to look like and well coming to adjacency list so here you will be having a vector of list okay let's see how so adjacency list so basically let's say we will pick up node one okay vertices one and tell me where all the adjacent to the particular vertices like one so two four right one four you are done with one now you will go to next you will go to two who are all the adjacent to the one two two sorry so one three and five will have completed this now you will go to three who are all the adjacents to the three it's a two seven four two seven four i will go to next one this four for all the additions to the four so one three one three then you will go to five it's a two six now you will go to six it's a five seven i will go to seven it's a three comma eight comma six i will go to a8 so it's in seven comma nine then you will go to a nine it's a eight okay so from seven you have three hours okay done so this is the adjacency list looks like so you can call this as a or you can consider this as a vector index okay so one index and for one index you will be having a list okay list means uh you can consider the array okay vector of array so where you will be having two four and all okay so the idea is we will stick to that particular uh vertex okay then you will traverse to that particular array so that you will get an all the adjacencies of that particular vertex so that's it so now we'll see how we will implement bfs by using this for this particular graph okay so you will have a visited array visitor array or vector why this so earlier so what is the problem that we have identified in a trees so you are visiting the same node for the multiple times okay so the same thing happens in graph as well yes right don't you think yes so to reduce that particular problem we are having a visitor array where you will be keeping all the visited vertices okay so with zeros and ones okay you can consider zero means uh not visited one means visited so by default we will be filling them with zeros by means that we are not visited okay so how much indexes we need to take so it will be so if you have n vertices you need to take n plus one vector array just because of the fact that we will be starting from the one index one what this is okay so let's take an array looks like this so we do have nine vertices so i will i have to take 10 okay so starting from 0 1 2 3 4 five six seven eight nine okay so this okay now you will fill all the zeros over there you can consider okay if you even if you don't like consuming a lot of memory you can use a bool as well which takes one bite only okay for bull you can conserve falls as an exhibition and one as a visitor sorry true as a visitor and also you will be having another thing what is called a queue data structure what is a queue a queue is a a data structure which follows the principles of first in first out like whoever comes into the first they will go out first that's it okay now we'll see how that works okay so this is a queue and this is a visitor array okay so first we'll start with this one now tell me is that one visited no so what you will do so you will call it bfs like assume like that okay so now you are visited so bf in bfs now we will mark this guy this particular one as a visitor okay one has visited so one now you will enqueue this particular vertex into the queue okay you will say one okay done now what i need to do i need to visit all the adjacent software one right so i will iterate in and loop okay so i will i will enqueue all the adjacencies of this one okay if they are not visited okay if they have visited no problems they will be in my output right so if they are not visited i will push enqueue all of them into my queue so it will be first two then four so on this note i can say that i am done with one so whenever i am done with this particular guy i will push that into the my output like i will print that into my output so let's say this is my output okay so one i got one now is that q empty no i will pick up this guy and i will visit all the adjacent software that particular purposes now before that what i will do i will mark this guy as a visitor okay so two okay yeah one now i will enqueue all the adjacence of a two so what are all the one three five one is already visited right one is already visited is three visited no so i will push that three now is that 5 visited no so i will push 5 done now what i will do so on that node i can say that i am done with the 2 so i will erase that ok now the next one is 4 okay so first i will mark four as a visited now i will go through all the adjacent software i will go through all the adjacence of four so who are all the adjacent of a4 it's a one one three so is one already visited yes already visited okay so sorry i forgot to override this yeah okay so now one already visited yes so is three already visited yes these three also visited right so you are done with four so you will print output that now you will come to three okay now what are all the additions to the three two seven four okay is two visited yes two is already visited then 7 is visited no so you will mark 7 as a visitor and push it to the queue now is 4 visited yes 4 is already visited okay so you don't need to worry about that you have completed this this and this okay okay so you are done with three and you will with not the output now five so who are all the adjacent to the five two one six is two visited yes it's already visited so no work with two is six visited unknown so we will mark it as a visited and i will push it to skew now so you are done with five as well so i will print it to the output board okay now it just seven for all logistics to the seven three so three done yes already visited so is eight visited no so you will mark it as a visited and push it to the queue now six six already visited no work okay done so i am done with seven as well so i will print it with my output board now six so who are all the additions to the six it's a five one seven five already visited yes seven already visited yes okay no work so you are done with six as well okay we'll print six here done now now it's a eight who are all the existence of eight seven and nine so seven already listed yes so no work so is nine which dead no so you will mark it as a visited and you will push that to the queue and on this node you can say i'm done with eight okay so you will put that in the output now it's a nine okay so who are all resistance to the nine it's a eight so is eight visited yes it's a visitor so now so on that note i can say that i'm done with nine as well so did we covered all the vertices let's see okay so did i visited one yes two yes three yes four yes five yes seven yes six is eight nine done so this is how binary is best first search algorithm looks like okay so without wasting any time let's go on code for this particular approach so now let's discuss the c plus plus code of an bfs algo now first we will be taking two inputs from the user one is vertices and the edges so vertices or the number of vertices we will be having in particular graph and again i am saying that it's an one based indexing graph okay so means i will be starting the vertices names from one okay now edges so why we need edges so it will represent the how many edges we are having in entire graph so that we can iterate that many times and we we can form an adjacency list okay so we'll see that now so for that to from an adjacency list i will be creating array of pixel okay where so for one particular array we will be having indexes right so how many indexes we will be having so what is sr9 okay so since we are concerned one based indexing we will be using what this is plus one okay plus one and then it's a vector okay so here in loop we are iterating throughout the number of edges we will be having and for uh for every time we will be taking two inputs one is from what is another one is a two worthless okay so we will be taking that and we will be forming and graph as essentially so y y two so you are forming u 2 v and v 2 u so y so basically since it's an undirected graph ok so we might have an both sides right so let's say i have a path from 1 to 2 it is equivalently to two to one as well right so that's why it's okay if you use only one thing like if you form only one edge that's totally okay okay not a big problem now let's see so now i'm assuming that you have a adjacency list okay which is having all the edges now we will be having a visited vector so where initially we will be storing all the zeros okay initially we will be storing all the zeros in it now we will be starting from the one okay always my starting point is one so i represent the bfs starts from one so here i am passing visited vector and adjacency list okay now i will go here now here what happened so first whatever i started like so i will make that start as visitor first right one represents registered zero apprentices not registered so i will make it as a one then i will create a queue okay in that queue i will firstly push that starting point okay now i will iterate through the queue until that q is empty okay so since my queue is not empty now i will enter into the loop and i will make an friend like what is a friend happens so it will give me that top element okay so first element so what is the first element it's a one now so my current vertices is one now i will pop that one so i will remove that okay i will print that on to my output screen now i will iterate throughout that like i will move to all the adjacent of that current vertex right one so this is how i can use now so i will let's assume okay so for from one first vertex we will have a two one three okay first i will go to two and i will check whether if that is a visited or not if that is a visited it could have been a one if that is not a zero so if it is zero i will enter into this particular if block okay now if it is zero what i will do i will first mark it as a visited then i will push you to my queue right i am doing that i would then i will go to three okay now i will do the same okay now after doing i will come here again loop okay so my queue is not empty so again i will repeat the same for current value vertex is 2 now right so i have power that one okay so it will do all these things until this q is empty when this will become empty it will become empty when all the vertices are visited okay so uh what visited vector will become one all ones okay so this is how a code looks like for a normal vfs like it is a one a component a graph but we have discussed something different right what is that something different so here you might have in a graph like this so so here right so i will pass one here and i will done with this particular graph now what about this graph so i have to repeat the same again right i need to repeat the again so since i i don't know i don't know what is the starting point what is the starting point always so what i will do now i will return a loop okay let's say which will starts from zero and goes on till what x plus one okay and i will check if that particular i is visited if it is not visited okay i will go okay so first one okay i will go i will call bfs i'm visited and adjacent done okay so i will visit all this graph right i'm done with this graph now again come so i will come after this loop and i will say increment to one to two so i will make my one as two now so two is already visited yes it's a visitor so why so i'm passing this with as my reference okay so whenever it will visit it will get updated here as well and i will mark it as one so three visited four visitors now five is fire now so is five visited now no no five is not visited so what i will do i will make a call to bfs okay now it will do this thing so again i will come back and i will say six six already visited done so this is how code looks like okay so nothing much okay so it's just an our loop so i will remove that here and i will make into i equal to one and i will say iterate to vertex is i plus plus okay so if visited of i is not equal to 0 if not equal to 1 i need to say bfs of i unvisited and adjacency that's it this is how the code looks like okay so if you are in an interview it will be good okay so interview expects you to write this coding like i'll go for to having multiple components but if you are still have that doubt what to write you can ask your interviewer okay so so can i assume is there only one component in this graph or multiple components exist okay so the complexity of this approach looks like you can guess right so yeah it will be mostly big off and since we are visiting all the vertices and you might think yes we are doing for couple of times right so we are calling here and we are having in worst case we will be so let's say it's a one component then it will be big o of n first term now again i am calling all these vertices so you might think it's a big o of n plus 1 n into n but if you carefully observe it will end up at n plus n okay so i can say that max it will be big o of n and coming to space complexity so here you will be using this okay okay visitor array so far that you will be using big of n like big vertices number of vertices then also you are using a q here right a cube so again at worst it might take we go off and right so you can have a a big wall of n plus one it will be you can say that but it's okay so if you can say big wave n as well okay be accurate okay so figure it try to figure it on your own okay that will be a good practice okay cool now let's discuss the dfs what is a dfs a depth first search dip okay dip okay let's see let's see okay so we'll consider a small graph okay so one and from one two three and from two four and here five and three to five and here here okay so this is a graph we have given and uh you ask you to find the dfs of this particular graph so how do you start so let's say we'll start from one okay i will say one now so in bfs we have moved a simultaneously to all the adjacent of a particular vertex but in dfs we don't do that we'll pick up one of its adjacent and will traverse all of its particular adjacents okay so like let's say so now what are all the adjacent of a one say either two and three okay we'll pick up two first okay now we'll pick up two two okay so from two for all the adjacents to the two four and one is one already visited yes it's already visited so we don't need that so we'll say we'll go to four now now from four what are all the possible adjacent two three five six right now is three visited no so you will say i will go to three now i am currently here now what are all the adjacencies of a three so one five four so four already visited one already mister now i will go to five five now from five who are all the adjacent of five three four six three already visited four already visited i will go to six so from six is there any unvisited is there are like quarter or large essence it's a four five so four is already registered five is already visited so nothing to go okay now i will check all other vertices where i left okay so in this way it looks like this is the dfs often at this particular graph is there any other solution yes so at beginning in beginning instead of going at the 2 i will go at the three now okay so first i will whisk one then i will go to three part now what is up from three what are all the possible ways we have i can go to one i can go to five i can go to four so now i will pick up i say i know that one is already visited now i have to go either four or five so i will go to five okay now from five what are all the adjacencies three four six okay now i know that three is already visited okay three is already visited now i will i can choose six now i will choose six okay now from six i have five four okay five is already visited okay i will then i will go to four okay i will go to four now currently i'm at here now what are all the adjacencies of four two three five six okay so three visited five visited six videos so i will go to two okay so from two i will go to uh either four or one okay so since both are already listed i can stay stop here that's it so this is also an correct solution okay so on this node i can say that there might be a different uh solutions for one particular graph okay so it depends upon how you are going and what text you are currently picking up okay so now let's simply jump into our logic okay so i will take up simple a graph let's say i have a one then two then three four five six so this is uh one component have another component let's say seven and eight okay so now first step we need to find the adjacency of this particular graph adjacency list so how does it looks like so we have first one index so first vertex who are all the adjacent of a first two comma three so on for two it's a one comma four and for three it's a one comma five and for four it's f two comma six comma five and for a five it's a three comma four and for six it's a four four seven it's a eight and eight it's a seven okay this is the adjacency of an this particular graph now let's see so first thing is first we do have uh one visited array okay where it will be by default it will be marked as all the zeros so here since we have eight vertices it will be eight plus one it's a totally nine so one two three four five six seven eight and nine okay so let's write the indexes of this 0 1 2 3 4 5 6 7 8 okay now so all these were filled with zeros zeros now how this works now basically this a df is an recursive algorithm okay so if if you are in an interview they are not interested in recursive manner so you know how to write right by using stat okay you can write this on an iterator approach by using stack okay but let's see okay so i will tell you request your approach but it's your job to write the iterative approach okay so it's very easy i gave hint right try it on your own so let's say first i will start from one okay so while discussing the code of bfs i have shown you how to if the given graph is an component based graph so if you have different components i have shown you how to traverse to that right so for i is equal to 1 to what this is plus 1 okay if that vertices not visited i can say that do dfs of that particular vertex that's it okay this is how it looks like so first we'll starts from a dfs of a one okay so from here what are all the ways so i have a two on three okay i have two one three so i will pick up this time i will go with two side okay so ds press of two so before moving on to dfs of two i will mark dfs one as visited one as visited now since i started two i will mark it as a visitor okay now from to where i can go okay so on my output board i can say that till now i have one and two okay so now again what are the adjacent of two it's a one and four okay so i know that one is already visited and i will go with four now so dfs of four okay cool four done two done one as well done okay one is also listed now so from four for all the adjacent so uh before moving on i will mark it as a visitor now over all the adjacent it's a two six five okay uh since i know that two is already visited okay our next i will go with next element called six okay six so before moving on i will mark it as a one face of six okay cool now who are all the adjacent of six it's a four okay i know that four is already visited right visited now i will go with so since we are here so six uh we have been to four okay now for four we have been done with six okay so we come here okay we'll come here so for four we have another option called dfs of five right so there is no going from here so after six we have only four four is already visited so we'll come back to the top like previous call and we'll go to the next adjacency of that particular vertices so it's a five okay i will mark five as a one and i will go to the five now so for five say three and four okay so first i will go to check with three so is three visited no so i will mark it as a visited and i will go dfs of three okay now how is it look like so uh since i am at three who are all the adjacent of three it's a one and five okay one and five so one already visited five already visited okay one already visited and five already visited so there is no mid away from three okay it's blocked so i will go to top so for five so three done and four left so is four already visited yes visited now again i will go to four so out of 4 is also done 5 is also done now from top of the 4 i will go to 2 okay so is there anything left in 2 no from again i will go here there is nothing in here as well okay so strings are we left with three so three is already visited so till now we have on our output to one two four six five three okay so happens stop okay so this is what happens now what i will do so i will go to my main so all this happens for first one okay so first iteration so i is equal to first now what i will do i will go with i will increment my eyes to two okay so it's two visited yes three visited four visited five visited six visited now currently i'm at seven so seven is not visited okay what i will do so i will make a call to dfs of a seven okay so i will mark it as a visitor and i will put it on my output now what happens so from seven over all the adjacent it's eight i will make a dfs of eight marked as a one okay so from eight over all the distance it says seven seven is already visited okay so blocked okay i will come here is there anything to visit from seven no so i will return to main so from main i will increment my i so it's 8 now it is already visited so that's it okay so did we covered all the vertices 2 1 2 3 4 5 6 7 8 okay so i highly recommend you to take another graph and try out this approach okay so it's very very important okay so now let's see the coding part of this particular ddfs now let's discuss the c plus plus code of our dfs algorithm so it's the same like before like till creating an adjacency list same as bfs okay so we have seen that earlier so till here it's the same okay so after we have our decency list we will be doing something different okay so not much okay so let's see so first we will be having averages okay so visited array okay where we will be initializing with r0 by default if it is visited we will be marking there is a one okay then so here i am assuming in case of components okay we have different components to visit okay so if it is not it's very simple right so you will say dfs off we will start with one and you will go visit it and you will go adjacent that's it so it's it's as simple as that if since it is of different components it has different components i am making it as a for loop and i am traversing to the all the vertices and i am checking if that particular vertex is visited i won't go anywhere if that particular is not visited i will call dfs okay so since one is not visited i will call dfs for one and i will come here okay i will come here so since my start is one right then i will say so i will take visited uh vector and adjacency now i will marking a visited of start as a one since i started visiting so and i will print the start as well okay now i will iterate through the all the adjacent often particular start okay so let's see so first i got let's say i have an adjacency from a one to two so i will pick up two and i will start dfs okay so here so again i will go to make a recursive call for two and i will again start right so if there is a two has three and i will again start for three so it's gone like that so since that is why it's called as a depth wise okay so it it will reach till the day so till the last what takes and then if it does particular what test doesn't have any next what text to go then it will make a call to come back okay it will go to previous call then it will it will go to previous and it will from that previous call if there is any adjective to visit then it will do that okay so i will keep on doing that and if that happens okay so i will come back here and now i'm done with one now i will check with two since two is visited again three which date four visited five is really six we say seven yes so we have hope you have remembered our example right seven is not listed so i will make a call to seven so i will mark seven as visited here okay i will print seven in my output board and i will go through all the adjacency of seven okay now what is the distance of a seven it's eight right so i will i know that it's a not visited so i will make him call to dfs of eight okay i will visit that again and i will mark it as a visit and i will print it on my output board and from eight there is uh only seven which is already visited okay now i think we go okay so i will come back to this loop that's how it works okay so that's as simple as that okay so again i'm saying that these are two algorithms are very very important in perspective interviews okay if you are aiming for the high so please don't try to not to skip these algos okay so please try to practice as much of problems you can okay so the next question is what is the difference between tree and graph data structure okay so reverses graph so tree and graph are differentiated by fact that tree structure must be connected and can never have a loops whereas in graph there are no restrictions so the major difference between tree and graph is tree won't contain loops okay but graph can contain loops okay where like we will be calling them as a cyclic graphs okay a kind of thing but uh trees won't contain a graph or like previous own content loops forever 3 provides insights on relationship between your notes in a hierarchical manner and graph follows a network model so here in tree we will be following the hierarchical manner right like structure we have seen one example of file structure but in graph we we are not following the hierarchical structure we will be following the network model where one node is being connected to many other nodes and and that particular node is being connected to many other nodes okay like this so this is the difference between graph and three okay now next question what is the difference between breadth first search and depth first search okay so are both are traversal techniques only okay and but we'll see what is the difference okay major differences between both so here bfs versus dfs graph traversal techniques graph traversal but even it can be for three and three as well okay the main difference between dfs and bfs is the bfs traverse by level by level and whereas dfs travels by the uh starts from this uh starting point starting node and reaches till the end node okay the leaf node and then again it will go back to the starting node then again come to the leaf node okay let's say i will take it one example okay so let's say if you have a tree like this bfs follows the this thing okay first it will complete all the level zero then level one then level two but a dfs would works like this okay it will start first this particular node and it will complete this path okay this path then again it will go back to the top and it will come click this path now again go back to the loop like starting point and again it will complete this path and again go back to the uh root and then it will complete this path okay so depth wise it will starts from the root node and then it will come to till the leaf node and again it will go back to the another path okay there is some another difference so further a bfs here so the data structure the type of data structure it uses to compute the that traverse the graph so uh bfs takes q which follows the first in first out um logic and our dfs takes a fifo which is like cube status stack default lifo stack okay last in first out so dfs yields deeper solutions that are not optimal but it works well when solution is dense whereas the solutions for bfs are optimal okay so dfs solutions are not that much optimal because it will go on deep like it will take out all the possible path okay it will consider all possible ways to solve a problem to reach till the end to reach till the our solution but whereas uh a bfs won't do that okay it will go in a linear manner and checks whether this is a what we are searching for or not okay that's it now the next question how do you know when to use dfs over bfs yeah very good question so i have seen many areas where uh we can solve a problem using a both a dfs and bfs solution but often that selecting the which solution are to write the quota is also an um like kind of uh much needed one in an interview okay because it matters a lot in searching okay finding the optimal solution so probably this question would answer those questions so the usage of dfs heavily depends upon the structure of the search or such tree or graph the number of and locations of solutions needed so following are the best cases where we can use dfs okay so if it is known that solution is not far from the root of the tree a depth breadth first such might be the better so that's telling that okay like if there is a tree like this and solution is what you are searching for is exist here now now tell me so dfs if i follow dfs it will come down till here then okay then it will come down here so till now we have visited four right four or we have instead like path okay if we have concept path we have visited uh five nodes and then we are going to the solution which we are searching for but if i considered a bfs i first complete this level then i will complete this level so to come to our solution i have listed only two nodes right so now it's up to you okay you guys know clearly seen what is an like advantage of using a pfs in sometimes in these cases where our solution is very nearer to the root now so second point the tree is very deep and solutions are rare okay like so um the height of the tree is very big okay but solution is very rare then going for uh dfs going for depth to first search will extremely take longer time to compute the solution which involves uh finding lot hell lot of uh of like ways to solve the problem okay that is going to yield an um big amount of time okay which is not efficient now if the tree is very wide okay like the width of the tree is very high a bfs might need too much of memory yes right so if it has uh for each level okay if this is an array if it is a nra a binary tree oh sorry if it is an nra tree so an array tree i like car it should looks like this something like this okay where each node will be having more than one node okay like it's an infinite okay a node a para node can contain infinite number of gel nodes then it is called as an nra tree okay so in this case the width of the three might be very high right so in this case by going till uh the breadth first wise will take a lot of space okay so in this case going for dfs is a good option so if solutions are frequent but located deep in the tree we opt for dfs okay they are saying that um if your solutions are a very rare and it might enter very uh if your solution might exist in very deep means a very lower order okay then going for dfs is the right approach okay it's an uh it's just an opposite to the what we have discussed in the first point okay now uh next question is what is topolo topological sorting in graph so what is topological sorting which is a very very important algorithm okay if you are preparing for a companies like amazon so amazon this is one of the most frequently asked the graph question in an amazon so it will be having different algo like you can solve this problem using different algorithms like khan algorithm okay topological sorting itself is have one algorithm which follows both the bfs and dfs technique okay so if you are aiming for such big companies please have a look at this topological sorting algorithm okay and um this is one such problem you won't get uh afraid of because most of the people feel that graph is little complicated topic but it is not okay all you need is uh with some strong basics then you can able to easily solve the graph problems and one of the advantage of graph problems is in an interview you will get only standard problems okay like it's very rare okay i can say that it's very rare to get our new problems like unseen problems or unsolved problems either in lead code or interview with platform okay so you will get only the frequently asked problems okay because it's a little uh tough to create and problems okay so let's come to this topological setting so a topological sorting is a linear order of vertices such that every directed edge i what is i comes before joining ordering i so i'm pretty much sure that you haven't understood that definition so let me put down like this okay so um let's take it as a uh becoming a hd okay becoming a hdb so let's say everyone in goal is to become hd now to to become hd we have different path so one part is like um to learn system designing first row so to learn system designing you should be very good at algos if you want to learn algo then you should be very good at ds it's like something like this okay and if you want to be good at data structures then you should learn oops if you wanted to learn oops you should pick up any oops language either c plus plus or java or python done now you can in this this is one part where you can become software engine there is another path okay to if you wanted to get it in startups okay again i'll learn uh web development okay so and you should learn some um like basic dsa as well basic ds as well to learn basic dsc you should learn programming language either c plus place or java or javascript if you wanted to wrap them you can become android dev as well android or ios then again this is going to be same path okay so this is an overview of like where you will be having different options and uh uh you can become an hd now now i wanted to be sort this thing as a propolitical sorting so the topological sorting means let's say for everything for if i wanted to become a software engineer if i would like to uh take out this particular path what is the first thing that i need to do first thing that i need to do i should learn programming language c plus plus java or python then i should learn oops then ds then i'll go then sd then sd become this is one way right and another way is learn c plus plus or java or javascript and learn some solve some basic dsa problems then learn full stack development then become sd this is another part that you can become hd what is another path learn either android or ios and learn some basic dsa then sorry okay okay so yeah here it is and now a c plus place java kind of okay c space or java or javascript or some court link which are android languages or flutter and solve some basic dsa then become hd so to become an hd these are all the path that you need to consider okay and this is called a topological sorting means okay so here i can say that i can say that to become an hde you are dependent upon system design to learn system designing you have to learn the algorithm okay to solve algorithms you should be very good at data structure to learn data structures you should be very good at oops okay then to learn hoops you should learn any of these practical languages so now so this is the order of becoming an hd now what is the order of learning path okay so you need to start from where there will be no dependencies what are what are these here so you should pick up one at least one oops language it is then you should after learning that language you should go to the oops then ds then on go then hd then uh like system design then sd right so this is what topological sorting means okay so before moving on to the any dependencies okay you should learn you should uh visit all the no dependencies then only you can visit the dependencies okay so i hope you got some good idea like i tried the best because it will be it is going to be a good example so and these are all the few of the applications where topological sorting has been are using uh applications or uh job scheduling algo arguments from the given dependencies and among the jobs okay ordering of ordering of formula cell evaluation in spreadsheets ordering of compilation tasks to be performed in make sales for make files and data serialization resolving symbol dependencies in linkers okay so it's very simple okay it's very simple like if you want if you haven't understood the example i can tell you the one as well let's say i have a given an statement like a result equal to x plus y plus z okay so to solve this particular problem first of all you require x then j then y okay i can say that x equal to x equal to x into y okay so for this again you need you require y sorry x right so i can say that x is equal to 2 now again still you require y so for y i can say that 2 okay now your x you have solved the x okay you have the y now what about z you still require j then i can say that z equal to y into r2 okay so you have y okay you have y and you have to so it is going to be you have answered so after getting all these things you will be computing your result right so here before moving on to solving the problem you need to get all your dependencies done then only you can solve the particular problem so in whatever like wherever such cases or constraints are exist then you can use the topological sorting okay hope you have understood now i'm not explaining this code as of now probably might be another separate tutorial because it will take a lot of time and it needs a very good amount of attention as well so i will create and separate tutorial for this where we will be solving two problems of topological sorting and again there is a problem okay so go through this problem so this problem is called as an um islands number of violence problem which isn't very good okay we'll try to call this another separate tutorial now let's solve this particular problem yeah heap data structure in data structure so heap is a special tree based non-linear data structure in which the tree is completely binary complete banana tree uh so i will tell you what is complete binary so a binary tree is said to be complete if all the levels are completely filled except possibly the last level and the last level has all the elements towards as left as as possible heaps of two types so basically completely is something like this okay so let's say suppose you have a root okay and you will be starting from the left first okay and then you will be going to the right and then after this completing this right again you need to start from the right so you it means like you need to follow the sequence okay first you need to complete this then this then this then this you should not go something like this okay okay so here uh your right is empty right so this is not a complete tree this is a computer so which means that your left subtree should not be the empty and the the above levels are also not be empty okay before moving on to the next levels so then we can say that it's a complete tree okay now we have uh heaps of two types as we as i said a maxi pan mini okay i will i will give you an overview of what is uh max heap and how max he will be representing and i mean okay so a max in a max if the data present element the data data element present at the root node must be greatest among all the data present in the tree okay so they are saying that let's say if i have a root of 100 then all my children's okay all my children's should be less than hundred okay so here like the root has to be good like the root or parent node should have the greatest the element greatest element among all the children's okay here let's say here i have 100 now i should have 90 here and i should have a 99 here okay and i can have a 5 and i can have four and three then two i can have one here okay so here if you can see the parent notes okay this is a parent this is a parent this is a panda so parents are greater than the children notes right then this is called as a maxi okay then you can guess what is a min hip right so a min hip will be having it's an opposite okay the root note okay like a root okay sorry let's say 10 okay the root note will be the uh lesser among the all the children's it has okay so here 10 so i can say 20 and i can say 30 and it will have a 40 and 60 and it is having a 35 and 40 that sorry uh it is it can have 50. so it should be like this okay parent node should be less than its children node then we can say this as a minimum okay now i guess we are done okay so this property should recursory true for all the subtrees yeah they are saying that the smallest um the root okay the parent one should be smallest among its all children's okay now i guess we are done with all the data structures in terms of preparation questions okay so for more such interview questions you can check out the interview blogs okay you can find a lot of questions or which are specific to the language or framework or library please do check out the interview with blogs okay so that's it