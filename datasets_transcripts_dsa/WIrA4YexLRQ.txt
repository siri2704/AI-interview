hey everyone welcome back to the channel I hope you guys are doing extremely well so this is another video from the Strivers A to Z DSA course just in case you don't know about this and for the first time here this is world's most in-depth DS algo course why do I say that because you can go over the entire internet you can buy any of the paid courses in the market none of them will be covering any DS algo stuff in such depth this course has 456 modules and you'll be covering 400 plus problems in this particular course itself so once you complete the course you will be ready for any of the DS algorithms in any of the companies in any part of the world that is my guarantee to you so in this video we will be learning about quick sort what about these couple of topics now these couple of topics are very self-explanatory so what I will be doing is I'll be adding notes to them so that once you go through the entire notes you will be able to understand that by yourself a video is not required for these couple of topics so that's why I will not be adding videos so in this video we will be talking about quick sort so without waiting let's get started quick sort algorithm what does the algorithm do very obvious to guess yes it does sort any of the given data structure in an ascending order but if you do some minor tweaks to it yes if you do some minor tweaks to it it'll be also sorting it in an descending order so in this video I'll be teaching you the quick sort algorithm that sorts the given data structure in an ascending order in depth so that you can do the minor tweaks by yourself and you can sort the data structure in a descending order as well so what will be the flow of the lecture very simple first will be explaining the algorithm then I'll be telling you the intuition behind every step of the algorithm once we are done with that we'll be going and writing the pseudo code now remember one thing I'll be adding the pseudo code in such a way that you can code it in C plus plus Java python or any of the programming languages you code in and so this tutorial is going to be language independent and then we will be doing a dry run on the pseudocode so that the recursion is clear on your head once these three steps are done we'll be moving to the online compiler and compiling it so that you get an essence of the online compiler post that I'll be discussing the time complexity and the space complexity as well so you must be thinking let's drive a bit we already know about the merge sort algorithm which has a Time complexity of n log n and it has a space complexity of bigo of n where we use an extra temporary array y pixel so quick sort has a Time complexity similar to moisture and login but doesn't use us any extra temporary array yes it uses recursion stack space but no temporary array so quick sort is slightly better than merge sort but does that mean you don't need to know Marshall no you need to because there are a lot of problems which can be solved just by using merge and we will be seeing that in the arrays playlist when we will be solving problems related to more short term it's very important that you understand all the Sorting algorithms because you never know in an interview the interviewer might ask you any of the Sorting algorithms might ask you any question that might be similar to a particular sorting algorithm so do not skip any of the Sorting algorithms that is what my recommendation to you will be so let's get into the explanation of the algorithm and we will be using this particular array as an example to understand the algorithm so the first step of the algorithm is very simple if you are given an array the first step is very simple pick a paper remember this pick a paper what is a paper pivot can be any element in the array any element can be the first element can be the last can be the median can be the random or can be any element by your choice any element by your chart there is no particular rule to pick up effort no particular Rule now once you have picked the pivot so for an example we say that we will be following the first two and we'll be picking up the pivot as the first element of Any Given array to us so I'll be like okay we're given this array so we will be picking up the pivot as poor that is my job I'll say Okay given this array so I'll be picking pivot as 4 first element at the ending one after that pick that element and place it in its correct place in the sorted array what does it mean now this array is unsorted agreed but if I have to ask you what is the sorted array can I say the sorted array will be one two three four five six seven nine can I and if I have to write it will it be something like 1 2 3 4 5 6 7 9. and if I ask you what is the correct place of food so I have to ask you what is the correct place of 4 you'll be saying correct place of 4 is this which is the fourth place it is currently lying at the first place but actually the correct place of 4 is at the fourth piece that is what you'll do you'll pick up four and you'll say picked up an element and place it in its correct place and just take it and place it in its correct place that is what you have to do pick up a paper and place it in its correct place now how will that help let's understand I said pick a paper so you pick the four and you pleased it in its correct Place done then you picked up six for an example just for an exam and you placed it at its correct place which is this then you picked up two and placed it at its correct place then you picked the five and placed it as at its correct Pace then you picked up seven and place it at its correct please and you picked up nine and placed it added Skype please then you picked up one and placed it at his connect place and he picked up three and placed it at its correct please will the array be sorted at the end of the day that is the reason the intuition was very simple pick up a pivot and pivot can be anything doesn't matter what you pick because at the end of the day if you're putting them into its correct place and every element is put the array will be sorted it doesn't matter what you pick as long as you're putting them into the correct place at the end of the day if I've picked up every element the area will be sorted that's the reason any of them will work but we will go with first element you can go with the last median whatever you wish to Okay so we've understood the algorithm pick up a paper and place it in its correct place in the sorted array but what happens to other elements so the rulers the uh step number two is very simple smaller on the left remember this smaller on the left and large on the right how I'll explain you that afterwards but as of now just understand the explanation and the intuition of the algorithm small on the left and the larger on the right so what are the smallest is six smaller no so six will go on the right it's two smaller yes on the left is five smaller no greater so goes on the right is 7 smaller no it goes on the right is nine smaller no goes on the right is one smaller yes it's three smaller years so if you see can I see I have two one three and I have six five seven nine so these are greater and these are smaller and can I say after one step after one step can I say this that one element is at its correct place in the array I can so what is left can I say the left portion is still an unsorted and the right portion is still unsorted now why is the step what is the intuition behind smaller on the left and larger on the right if you think if you think in a very logical manner a four is at its correct place the left guys to the four in the sorted array will be smaller and the right guys will be greater that's why it's logical to say smaller go on the left and larger go on the right so that's the intuition behind the step two you have understood the intuition behind both the steps now you what you need to do is repeat these steps repeat these steps again and again and how do you do that very simple can I say four is done what is left the left portion and the right portion let's take the left portion two one three can I say it's an individual array it is so let's take that individual array two one three and let's again apply the same books what is of step one pick a paper what is our rule first element let's go and pick up the first element as the pivot two if I ask you the correct order if I have to write the sorted out array can I say this will be the sorted array can I say the correct order of two will be here thereby step two correct order I put it I've picked up every word and put it into the correct order step two small on the left so one is smaller on the left T is larger on the right so can I say 2 is done and we are left with one and three so again two smaller arrays but whenever an array has one element no need to do anything why one element is sorted in itself so can I say at the end you made this array to one two three so at the original places this will change this will change and this will change so the left guy got sorted that's the time for the right guy six five seven nine so let's do it for the right guys well six five seven nine so I'll write it six five seven nine rule one on the sari yes so I did it very simple four was done did the same algorithm on the left did the same algorithm on the right so kind of recursion kind of get you get an idea of recursion take the array get the paper do everything then call it for the left call it for the right kind of you're getting this yes next what's the next stop for the right direction six five seven eight what's your favorite six you have to hypothetically again same rule hypothetically you have to write it what will be five six seven eight so what's the correct order of six yes this one smaller on the larger on the right so can I say two arrays again five seven nine so can I hypothetically say that six was placed at its correct place so I'll go ahead and say six was placed at its correct place right and can I say five can I say five is a single array 5 is also placed at its correct place I can what is left this seven nine so again another array so let's take the seven nine as another array again pick up and pivot seven is the pivot what's the correct place of paper 7 itself and the other one is nine which is the greater so on the right so 7 is placed again go ahead and say 7 is done and now 9 is the single element so that's also done so at the end can I see this is also sorted so at the end can I say the array automatically did it for all the elements and each of them is at its correct place can I say that I can thereby the quick sort algorithm works this is the explanation and the intuition done explanation and the intuition it's very simple if I have to explain it in a shorter way pick up a pivot place it in its correct Place smaller on the left larger on the right and now the question comes how do you do this in a code how do you do this in the code so this is what we will be understanding in the pseudo code because picking a pivot is very easy because first element is kind of easy but now you might be thinking but how do you please the four in its correct place because by naked eye it's very simple this is the sorted way so you are seeing four here so you're saying 4 will be here how do you code it that's where you have to understand the algorithm in depth this other thing that you have to understand in order to do the pseudo code so if you carefully see this is the entire array right and once you have placed four you go for the left and you go for the right now the next doubt that might be coming up to your mind is but striver we have an entire array and then you're placing the pivot at its correct please then you're going to the left and going to the right so do you create new arrays no we'll be using the concept of low and high that we used in the merge sort instead of building new arrays we'll be using pointers to explain that okay the left array is from here to here the right array is from here to here we'll be using kind of pointers so let's understand the explanation in terms of pseudo code so that we can code so before going to the pseudo code let's understand how do we perform these couple of steps using a bit of variables and code logic so that we can actually write the pseudo code so imagine you're given this particular array and you have to apply quick sort to it and this is an unsorted array so will you be carrying this entire array logically doesn't make sense why because in the future you know these arrays will be broken down into smaller steps so we have to recreate new arrays so we will not be doing that instead of that we will be creating low pointer which will be pointing to the zeroth index which is the first time and we'll be keeping an high pointer which will be pointing to the last cat so what does low and high mean it means the array is from here to here very simple now what did I see what's the payment so if pivot is very simple a pivot will be the array of loom why we said paper will be the first element so the first element in the array is array of flow so first step is done that was picking up a pivot what's the next step placing the pivot in its correct place right so let's do it how do you do that in order to do that you take a i Pointer Place it at the lower or the leftmost part of the array and then take a j and place it to the right most part of the area done now you say okay let's find the first element which is greater than my Pivot because if it's smaller than it is at the correct place but if it is greater then then we will find it so let's find is 4 greater than the pivot no because what's your favorite now if I have to write the pivot the pivot is 4 so is 4 greater than the pivot no is 6 greater than the pivot yes so what you will do is you will say Okay 6 is greater than the paper so you'll stop at six so your I pointer stops at six and then you will go and say okay let's find the first element that is smaller than the pivot from the right I'll say three are you smaller than the paper he says yes I am so I'll stop because 3 is smaller so you have figured out the first guy who is greater than the paper on the left and the first guy was smaller than the pivot on the right so you just have a swap so it's a 3 and you say six so you just swap them done with the swap what is the next job that you will do next job again come back and do the same thing figured out the first element from the left which is greater than the pivot is 3 greater than the pivot no so just go ahead is 2 greater than the paper no go ahead is 5 greater than the pivot yes 5 is greater than the pivot so I has stopped at a element which is greater than the pivot now go to the right and find the first element that is smaller than pivot is 6 smaller than pivot no so move is one smaller than the pivot yes stop so five and one will swap one and five swapped perfect let's again continue the same step we say okay on the left find the first who is greater is one greater is one greater than pivot no is 7 greater than pivot yes we stop there so it stops at seven on the right find the first who is lesser than pivot so we move is 9 less than paper no we move is 7 lesser than paper no we move is 3 is 1 lesser than pivot yes and we stop and we stop so we stop here the J stops here like J goes here J goes here and J then stops here so apparently we stopped at a position where J has crossed I it has crossed I you stop you do not swap anymore do not swap it anymore which means you are in the territory you are in the territory where if you see everything is smaller than the pivot and on the right you are at a territory where everything seven nine five six is greater than pivot so you stop what's the last job you'll do since you stopped at one you just take this four and you place it here so you basically say okay one and four goes here so if you see what happens is one three two four is that it's gonna Place seven nine five six as super sum that's very simple and we are done with this yes that's that is how easy it was so once you have placed your pivot at the correct index in the sorted array can I call this as the partition index why can I call this as a partition index very simple the reason being this is where it's at the correct order in the sorted array this is not in the correct order and this is not in the correct order it's a kind of partition left is still to be done and the right is still to be done so that is why you call it as a partition so can I say as of now the low was pointed here and the high was pointed here can I see the new array that you have to sort according to the same algorithm is from here to here and it's from here to here so can I see the new array one array will be low to partition minus one and the other array will be partition plus one comma high this is where the this array is this and this array is this so what you do is perform a quick sort again and perform a quick sort again on this that's it and on this array again repeat the same angle and once you have done this you will be able to completely sort the array right so I think I've understood the explanation the intuition and kind of the algorithm as well as of now it's time to write the pseudo code the pseudo code is going to be very simple we say quick sort and we know it will be given an array and we know the array in the array the area that we have to sort will be from low to high that is something which we definitely know and we know we will only sort the array if it has more than one elements that means a flow is lesser than high because if low is equal to high in that case assume high is here which means this is the array one element is already sorted so if low is lesser than high that means it has more than one elements thereby we will be sorting it and this is what kind of the algorithms gesture will look like if low is lesser than I what do we do imagine you're given this array what did we do at first I figured out the pivot put it at its correct place and then sorted the left half and then the right half so what did we do at the first step place the pivot at its correct place and found out where it was placed and then called for the left and then called for the right so can I say okay let's call a function let's call a function which will do that so I'll tell the function that for this array low to high please find out a pivot place it at its correct place and tell me where you placed it like for this case you will be placing it here tell me where you placed it and I'll call that as partition index partition index done once I've placed it at its correct place I'll have other guys because after the algorithm after the function has taken place how will it look like it looked like something like two one three and this side will look like six five seven nine after the function has taken place so now you have to sort this portion of the array and this portion of the array and the partition index is here so can I again call it quick sort go for the left now which is from which is the array but in this array take from low to partition index minus one and in the right array take it from partition index plus 1 comma high again the lines can swap this can be at the first and then this can also be there it doesn't matter even if you swap it like this it's still okay because you have to sort the left and the right or the right and then the left any any way works as long as you are sorting it this is simple because the recursion will do its job because precaution has been called for this so again it will do a stop quite simple but the question comes up okay he understood till here but how do we write the function let's understand how do you write the function the function remember alighted with maybe a yellow the function has taken an array and has taken a low and has taken a high and you know it has to find a pivot and in our case the pivot is very simple we were saying the paper to be array of flow which is the first element and what did we do at every step if you remember we first kept I here and we kept a g here so let's do that so we said I is equal to array of low perfect or or maybe just just write it for the index I is at low and G is at high this is something which we said and what did we do we kind of said okay if I is here which is the first element greater than pivot and we've stopped here and then we swapped and we kept on doing this kept on doing this till I cross J and we had a left and a right so we kind of write okay keep on doing this so we keep repeating the steps now what are the steps find out because I was here find out the first guy that's greater than the pivot so okay while array of I is lesser than array of pivot that means it's okay this is not the guy that I'm looking for a 4 is less than equal to 4 I'm not looking for you I'm looking for someone greater than you so this is a correct condition and obviously I cannot exceed the arrays boundary which is definitely High it cannot exceed the RS boundary if that's the case we say okay I plus plus that means it keeps on going keeps on going till it doesn't finds an element greater so the moment it is at six the while loop will stop because that's where it has to and similarly from the right similarly from the right we say array of J from the right what do you need to find someone who is smaller so if this guy is greater than pivot if this guy is greater than pivot then what you will do is you will say Okay J again since you're going left just say this and you will say Okay J minus so what these lines will do is this will find the first element which is greater than the pivot and this will find the first element that is lesser than pivot and at the end of the day remember if they haven't crossed if they haven't crossed if you remember then you swap them you say array of I and array of J to be swapped quite simple quite simple and then you can close this this while loop gets closed here very very simple so if I have to show you the algorithm again let's do a dragon what happens first time I stops here and J stops here so 6 and 3 gets swept six and three next I will stop here next J will be stopping here so next one and five get swept next I goes and stops at seven because seven is greater than 4 but J kind of stops here J goes here doesn't stops because 9 is greater J goes here doesn't stop because 7 is greater J goes your stops so if you see J has crossed i j has crossed I because J is at one so if J crosses I do not swap anymore because you are already at the left half three two one and you're already at the right half seven nine five and six you're already at the correct hubs so you do not do a swapping if they have cross they are already in the correct zones so at the end of the day where is J J is at here and Louis at here so that end of the day when this has this has crossed the Stop and we say okay it's time for the pivot to come it's correct please so swap the pivot which is the first element with the array of J which is the last element of the left index which is the last element of the left index so just swap it and this will come here and this will go here quite simple So eventually what you will get is three two one perfect that so once you've done this what do you need to do you need to tell them the partition index and you know the index is nothing but J because that's where the pivot came in so returns a this is how the function will look like quite simple this is how the function will look like again repeating find the first element greater than pivot find the first element smaller than paper swap again keep doing the same thing till you have an left and right once you have that just swap with the last level so if you are if you're able to understand this it's pretty much sharp also before going into the code I'll just like to mention one thing this portion is something which we have to be careful about and this portion is something again which we have to be careful about why because when you write this and you're doing I plus plus this might exceed the low to high array boundary because you are standing at the last and you're checking for the last and then then you're moving it might exceed the boundary so this instead of high will be high minus one this instead of low will be low plus one and there is other doubt that might come into your head why are we doing lesser than equal to and greater here now imagine you add 4 and you place three one two on the left and let's say five six seven nine on the right Boris please what if there was another four then he would have either place four on the left or either on the right so I will say on the left we will place everything lesser than equal to on the right we'll Place everything greater than equal to that's why we are finding greater and we are finding lesser over here got it why because you have to decide where do you put the equal to guys like if there is someone equal to weight you place them you have to decide on that as well so you place it on the left in that case you do it like this if you place it on the right then you have to do the vice versa I hope that does make sense so I can say that we are done with the pseudo code and the dry run as well because while I was writing the code I was doing the dragon as well and now going back to the recursive Dragon for these couple of things I'll recommend you to watch my merge sort video because in that I've explained how these couple of things uh split the arrays and how individual stuffs work so just in case you are not aware how the recursion Works merge sort tutorial is a classic example where I've done the entire Dragon so that you understand recursion in depth how sub problems are solved and everything by the way before moving uh to coding it in an online compiler I just wanted to quickly tell you something this is a divide and conquer algorithm because we're kind of dividing it and when you divide it every part is getting solved by itself so that's why divide and then you conquer basically solve so it's a divide and conquer algorithm now coming into the online compiler will be quickly coding the quick sort algorithm by the way the problem link is in the description make sure you uh code it as well and submit so coming to over here uh we have to return a vector so assume we have a quick sort we say array is 0 and array dot size minus one at the end of the day we are returning the array itself because we have to return it and now let's write the void quick sort and Vector end and then array and then IND low Indy high and we know if low is lesser than high then only we do it like for one elements or that we will not do it and we have to get the partition index and for that we can call the partition function and the partition function can take array low and high and then we can call the quick sort for array and low P index minus 1 and we can also call the quick sort for array P index plus 1 comma High that's it that is what I will do and over here we can say partition and we can say vector and array and we can take the low we can take the high and can I say that the pivot will be array of low we can say the array I will be this we can say the J pointer will be this if you remember well enough and we can just go on till ILS then J and we know that we have to go on till finding the first element that is greater than pivot on the left so we go on till it is less than equal to and we stop at lesser than high minus 1 so that it doesn't crosses the boundary when we do I plus plus and we also on the right have to find the element that is smaller so we go on till it is greater than pivot not equal to because the equal to guys will be on the left and then we go on the same reason low plus 1 that we do not cross it and at the end of the day if they haven't crossed let's take the right guys put them onto the left and in the left guys put them on to the right the swap of array of I array of J perfect at the end once everything is done we know J will be at the last of the left so swap the pivot which is at array of low with the last of the left and since the pivot goes to J we say that's the partition index that's how you can write the partition once you've done this you can quickly go and run this all right it's giving me time limit exceeded why is that happening because I've written less than equal to it will be greater than equal to my bad it All Passes Now quickly let's submit it and see if it's running absolutely fine it is so now moving back uh to the iPad to discuss the time complexity so the time complexity of this particular algorithm is n log n y is it n log n again the same reason as merge sort because every time you're kind of splitting them into two halves now over here the halves are for sure getting into like something and something then again this is getting into something and something so it's kind of not getting equally split as in most shot but they're getting into a couple of halves so this half will be going on like the height of the tree if you remember the more short video will be log base to n that's how uh because 2 to the power something log base to n and y n because every partition every this function is going through the entire array itself so it's a big O of n for everything so n cross it log n and the space complexity we are not using any extra space yes there is a recursion stack space but let's not compute it so the this is the time complexity in the space complexity I did not explain any login in depth because this is a continuous course I'm assuming you have seen the merge sort video where I've discussed in depth about n login so go back and watch it because over here we perform the similar kind of recursion calls so it's very UNL like this being big of n is self explaining why big often because you're moving I from low till high and you're moving J from I to low that's a b go off and it's a very obvious case and for these couple of things it's log n so comes from my shot I've explained that over there so the time complexity is l login and the space complexity is Big of one not taking recursive stack space into account so that's the time complexity and space complexity so with this I can say I have wrapped up more shot as well and the couple of notes will be added very very soon so guys with this we complete step two of Strivers A to Z DSA course the next thing will be step three where we will be starting with the arrays playlist so guys I hope you have understood the quick sort algorithm in depth so just in case you did please make sure you hit that like button and if you're new to our Channel what are you doing kill that subscribe button right away and to continue our tradition do comment understood so that I understand that you have understood everything and also as an assignment yes as an assignment you have to write this code for descending and you have to paste that code in the comments I'll be checking out the comments for sure and here with this I'll be wrapping up this video let's read in some other videos till then bye bye take care don't ever forget your golden I will