did you know that a stack is just like a stack of plates and did you know that a hash map is just a glorified dictionary data structures doesn't have to be hard to learn you honestly just have to learn it the right way I'm going to teach you guys how to be DS Pros well maybe not Pros but you'll at least know what an array is by the end of this video alright so I know you hear the term data structures all the time but what the hell is a data structure data structures are a way to just organize and store data the biggest problem people have when learning about data structures is that they try to memorize things versus actually learning the concept behind what a data structure does so what better way to learn than with common household items one simple data structure that we can use is an array and an array is just a fixed container with multiple tiny containers inside of it you can't really change the size of this data structure but that's okay we'll learn why next you can actually store a bunch of different data types inside of this I'm talking integers Boolean straight with Longs floats you name it so each smaller container is labeled with indexes so if we start at the very left and work our way to the right we'll start with the zero width index and then go all the way to the length of the array yeah we always start with zeros in computer science honestly don't ask me why but that's just the rule so how do we actually go through all the elements in an array so you guys have heard of for Loops before right we can use a for Loop to iterate through every small container in the array until we find what we're looking for this is called a linear search so let's go take a look at an example okay so now we're going to take a look at how to create an array in this example so you can see here we actually have an array with groceries apple banana carrots olive oil and avocado so you can see that we've actually printed out the number of groceries which is just the same thing as the length of the array so you can see here a number of groceries equals five and then we have a for Loop that goes through each item in the grocery list and prints it out so we have our grocery list printed out right there and then what we're going to end up doing is we're going to actually find a grocery item at a specific index so this is how you find a grocery item at index three so we can see here the grocery item at index 3 is olive oil which looks like it is true now remember we can't actually resize an array so if we set a value equal to null and then we print out the number of groceries we'll still have five items but instead we'll have apples bananas carrots and then the third index will be null and then avocados so it'll be the same exact size we can actually replace some values with null arraylists are pretty similar to arrays but they don't have a fixed size so if you remove an item you're actually going to decrease the size of this arraylist and if you add an item you're going to increase the size that's pretty much the biggest difference honestly so let's go look at a coding example here too so here we've actually initialized an array list with strings as our values and we've added the same grocery items so apple banana carrots olive oil and avocados and we're going to go ahead and print the size of this list so we can see that the size of the list is five then we're going to print out every item in the grocery list just like we did with the array and we can see them listed here then we're going to go ahead and actually grab one of the grocery items at the third index and this is denoted using dot get so we can see here the grocery item in index three is olive oil and then we're going to go ahead and remove an element so we're going to remove the zeroth element which is the first element in the list and then we're going to actually print out the size and it looks like we've reduced the size because again arraylists are resizable on like arrays and then we're going to go ahead and print all of the items and you can see we're actually missing the Apple in the beginning because we've removed that element but we have a banana carrots olive oil and avocados okay so let's move on to linked lists linked lists are like arrays and arraylists cousin you know the one that shows up late and hung over to every family reunion okay buddy boy well with linked lists you can really only go forwards or backwards you can't really access elements in between like you can with an array or an arraylist each index points to the next index or node so each node has a pointer to the next node it's kind of like a paper chain so if you break this chain you actually lose all of the elements afterwards and if you iterate through this chain and you don't keep track of where you started you'll also lose all the elements behind you yeah I know pretty unhelpful cousin if you ask me so let's look at a coding example of a linked list shall we so usually what happens in Java is they have a list node class or a linked list class and right here I've actually defined the player which is the data type it'll be a string and then also our list node next because remember list nodes are actually like a chain one node connects to another node which connects to another node so you want to have a reference and memory to your other list node I've gone ahead and initialized all of these list nodes so we have our paper chain right so we have Michael Jordan which points to L2 Ronaldo which points to L3 Steph Curry which points to L4 and Messi which points to null so now I'm going to go ahead and actually insert list node 5 which is garnet into the list at the very end of the linked list um so we actually have to create a temporary list node right here and then we use a while loop right here which will Loop us through the entire linked list when we see that temp is not equal to null but our temp.next which in this case if temp gets to Michael Jordan and our attempt at next is equal to null that means we know we're at the end of the list and we're going to set our temp.next equal to our new node likewise we can do the same exact thing while we're inserting at a specific index in this case we're going to insert right after Michael Jordan so we do the same thing where we check our temp and make sure that it's not equal to null if the temp player equals Michael Jordan then we set our l5s next to temp.next because remember if we get all the way over here and our temp dot next is null we want to set L5 equal to our attempt.next and again we set temp.next equal to to L5 so that's how we insert it and the output looks like this once we inserted Garnet at the end you can see that Garnet is at the end once we try to insert Garnet after Michael Jordan you can see that Garnett is right after Michael Jordan right there okay so hash maps are my favorite data structure the trick is to organize them in the right way let's say we have a list of countries and we're going to organize those countries in an array so let's say we want to find Ghana and well if we want to find Ghana we're going to have to iterate through every element in that list until we find it but what if I told you there was a better way to do that well there definitely is and that's called using a hash map now I like to think of a hash map like a dictionary we can use my makeshift Atlas both as a dictionary but if it's a real dictionary as you can see a hash map is just a key value paired data structure similar to a dictionary you're not going to search through every single page of the dictionary to find the word Venture culock astronostomy you're just going to go straight to the v's and then check there and don't ask me how I know what ventricula is turn off to me it is likewise with hash maps you can use that key to narrow down exactly what you're looking for that way we can start looking at the G's right away rather than going through all of the elements okay now let's look at a coding example so this is how you denote a hash map we have a key which is going to be a string and our value is going to be a list of strings and what we're going to do is we're going to have countries that are associated with a specific letter so what I've done here is I've initialized a bunch of lists so I have a list G which has Ghana Greenland and Greece as the countries inside of this list I have a list I which has India Ireland Iran Iraq and Italy and then I also have a list U which has the US UK and Uruguay so now what we've done is we've actually added our key value pairs our key is the letter itself and our value is the list and I've used the put keyword in order to put these values into our hash map so we put G with our G list the letter i with our I list and the letter U with our U list so now what we can do is use countries dot get I which is using the key to get the value and our value will be that list of countries that start with an i so then for each country we're going to print it out as you can see we have India Ireland Iran Iraq and Italy and then what we're going to do is we're going to actually remove a value so we're going to remove the I list all together and all you have to do is say remove and then add the key to remove the value and then we're going to print out actually what our results are after deleting and after deleting our result is null because we no longer have a value associated with that key in the hash map speaking of data structures and algorithms you're going to want to use a structured platform to actually get concrete practice nicodio offers that platform for you the code has a wide array of practice problems including the nc150 150 data structures and algorithmic questions that are super relevant to the interview process they have questions such as finding the longest substring without repeating characters or searching for values in a 2d array not only that but they've laid out an entire roadmap on these topics so that you can plan your time accordingly and track your progress and if you have trouble working through the problems they have comprehensive video solutions that walk you through each problem step by step as well as a leap code quiz feature to help people quickly review leak code problems and the best part all of this is completely free I've been using this platform for my own prep so that I can teach data structures and algorithms in our Discord sessions every Friday speaking of which we discuss DSA and software engineering Topics in the Discord every week you won't want to miss out and don't forget that nikode Pro includes really detailed courses on interview prep for data structures and algorithms the first 20 people to use the code Puja get a discount on upgrading to neat code Pro link is in the description below alright let's get back into it all right the next data structure is a stack so as you can see my little prop of plates was very helpful in the intro but I'm going to show you guys what a stack actually does so let's say this is our empty stack right here so first we take an element and we plop it on the bottom so that's our first element then we take a second element plop it third element okay so this is our last element so let's say we want to remove some items from the stack well can we take the first item that we put down yeah it's going to be kind of hard to get that first item so we're just going to grab the top item so this is a lifo or elastin first out the last item that we put in the stack is the first item we can pop off of the stack so pretty simple right let's take a look at a coding example so this is how you denote a stack in Java we just use the keyword stack and then we create our data type as well so we're going to store a bunch of strings in our stack and in this case we're going to just store some cars so in order to push things onto the stack all you do is stack dot push and again we're pushing the BMW to the bottom of the list we're pushing the Corvette as the next element on top of the BMW and the lambo at the very top and remember it's a first in last out or last in first out structure so the way that we've pushed all these values the first value that we can take out is the lambo so let's just check and run this we're checking what's on the top it looks like our Lambos on the top if we do a pop that means it removes the element on the top and returns so we get a Lambo and then we actually push another value which is the Toyota Camry and then we do another Peak and it looks like we had the Toyota Camry on top so again the last thing that you put in is the first thing that you get out with a stack cues are pretty dang cool too they're kind of like the opposite of a stack so if you've ever been waiting in line for something you know that the first person that waits in line is the first person that gets served whether that's at a restaurant or a coffee shop or whatever it's fifo the first in first out so you can probably imagine what that looks like and the interesting thing about denoting a cue is that it's an interface so we're going to use a linked list to actually extend this interface and you can use other data structures as well but again a queue is a first in first out data structure so the first element you put in using qdot ad we're adding an apple that's the first element that's going to come out so we've added an apple a banana and a cherry and then we've gone ahead and actually printed out what's in the queue and you can see that we have an apple banana and Cherry and then we go ahead and use Q dot remove to remove the first element in the list and then we print out the removed element which in this case is Apple and then we go ahead and print out the entire list after removal so after removal we have a banana and Cherry and then we're going to add another element to the list which is a date and this actually adds it to the end of the list so we're going to be at the end of the queue now and we are going to actually check what our next element is at the top of the list which is our banana that's our earliest value that we've put in and then we actually Peak our entire list so here you could see our banana and our Terry and our date so that's how we denote a queue and that is how that works so the last data structure but not the least is a tree a tree is similar to a family ancestry tree so if you think of a person right and that person has children and there are many children associated with that person then their children have children and their children have children and you can keep going on and on and on so that's kind of what a tree does you can have some value and that value will have children Etc we can actually use this thing called recursion to Traverse through the tree looking at each child's child until we find the right value in order to find Henry Huckleberry we look for the children that have Huckleberry as a last name and continue down that path until we find the name that we're looking for of course there are better uses of this but this is the best example I could come up with honestly it's kind of like many hash maps all linked together okay so now we're gonna look at a tree which is a little bit different than the other data structures that we've looked at and specifically we'll look at a binary search treat so binary search tree instead of having several descendants it'll have two children per node so here you can see the class node right here so we have a value for our node but then we also have a right child and a left child so you can see that they're denoted here so we actually add elements recursively which means we use a function that calls itself several times until we find the right answer so here for example if we have a new node that we want to insert into a binary tree with a specific value the way that we order these values in a binary tree is in order so our left child will always be less than a certain value of our node and then the right trials will always be more than the certain value of our node so here we want to actually insert by checking okay what is the left child of this node that we're currently at and what is the right child if our value is less than our current node then we want to go to the left if our value is greater than our current node we want to go to the right and we want to keep repeating that process over and over again until we find the right place to insert our node and there no longer is a value that is greater than or less than so that's kind of how we use recursion here we can also find an element the same way so for example we'll start at the first node and then if current is equal to null we can actually return false because that means that's our our base case otherwise if our value is equal to our current value then we return true because we found what we were looking for otherwise again we use recursion this is the contains node recursive function and then we just call contains no recursive current left if it's less than our current value if it's greater than our current value then we actually call again contains node recursive and then we put current dot right into our parameter so we're actually checking to the right because we know our value is greater than the current value there are definitely more data structures that we haven't covered namely tree Maps tries and cyclical graphs but for now it should give you a base understanding of what these data structures look like and how to use them for your coding needs so have fun