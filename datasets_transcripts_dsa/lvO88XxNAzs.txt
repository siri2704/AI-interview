so in this video we will be covering the basis of leak code which is space and time complexity we will also be going through all the questions below there are around 70 questions and this is the exact same presentation I created and the exact same questions I went through in my preparation and why you should take my advice first of all I solved hundreds of leak code and data structure style problems which led me to my first job at a big fan company so if you're completing these questions to prepare for an interview I'm someone who's gone through the process as a candidate and is now on the other side hiring I've also helped many friends and people in online communities to become software engineers and get into companies like apple and Amazon so hopefully all the information and tips I provide will be super useful from that point of view I know you are here for leak code but it's important to remember why we are doing this in the first place so I'll run through this section very quickly and I don't want this to be a Fang interview type channel so I've uploaded all the information you see here on my patreon step zero is to be able to sit down and work for at least 2 hours straight uninterrupted I cannot stress enough the importance of this and just how much working on this has helped me in my life just take a look at the world today the most viewed content in the world has camera Cuts every 2 to 3 seconds on top of that a large number of people struggle to carry out activities without interruption on their phones or something similar whether it be programming or taking a break with a walk and sometimes this can be very damaging to our progress I'm not perfect even I fall victim to this sometimes too but when I became aware of the problem and put steps in place to help myself work with Focus I noticed a big Improvement in my progress and how far far ahead it puts you for example this leak code video has over 100 slides and I'm sure 98% of people will not make it to the end completing every single question I could talk on this topic for ages but that's not what this video is about so instead I'll play this clip to summarize my thoughts quick bit of context this guy chamat was a vice president at Facebook in the early years focused on user growth helping grow the platform to 1 billion users so he knows a thing or two about the effects of constantly using our phones on our ability to focus it's hard think about how all this stuff placed together how does trying to get you know uh posting your waffles online relate to me starting a business and accumulating Capital this is wiring your brain for super fast feedback it's the same brain you're using to build a company don't think they're not the same do you know what I'm saying no yes no yes yes right you have one brain so you're training your brain here whether you think or not whether you know it or not whether you acknowledge it or not acknowledge that these things where you're spending hours a day are rewiring your Psychology and Physiology in a way that now you have to use to go and figure out how to be productive in the commercial world so if you don't change this you are going to get the same behaviors over here change this there's a reason why Steve Jobs was like antisocial media I am telling you I'm not on these apps I'm not him by any stretch of the imagination but I am proactively trying to rewire my brain chemistry to not be short-term focused I'm telling you they're linked okay so let's move on to step one which is to learn a programm in language if you're watching this video I hope you already know a programming language but if not I would suggest python it's the easiest language to learn and the best to work with when solving problems it also offers a wide range of specialities you can use Python to transition to web development data analysis machine learning really most other specialities I have linked the course that I took when I first started and wherever you're watching this I'll make it available I'm not affiliated in any way I just think it's a great course and from my experience paid courses are generally better the content is more in- depth there's a community the creators held accountable and since I've put some investment in them I usually convince myself to finish them once you know what objectoriented programming is including Concepts like classes inheritance and abstraction you're good to go you should be able to build something small without following a tutorial like a rock paper scissors game in the terminal and be able to add new ideas yourself for example randomizing who starts the game you or the computer or like in this example keeping score and if I told you to create a parent class choice you should understand how to add rock paper or scissors to implement that choice and maybe you can have an abstract method which returns that choice as a string it doesn't have to be good just a small project done solo to make sure you get the hang of the language and honestly that's it for learning python step two they structure and algorithms I definitely think date structures is the more important of the two you're much more likely to be asked to write a date structure than an algorithm from scratch in an interview plus you will be using date structures every day on the job which is not the same for algorithms and as you'll see you indirectly cover a lot of the algorithms by doing these leak code questions step three is this video step four is super important it's your foundations as a software engineer there's a 20page doc I put together covering everything from bits to the cloud using what I think is needed from the job I always always refer back to this even now and keep adding to it it's like my personal cheat sheet and I recommend everyone have one and steps 5 to 7 are all interview related information and finally before we get into the technical stuff with Big O notation I have one last message please do not just watch this video or other content without doing the real thing if you want the best possible chance to do well and remember how to answer leak code questions and how to write out date structures you need to make your own notes write out your date structures multiple times solve the leete codes go back and solve them again without looking at the answers participate in mock interviews timed coding challenges do the real thing and you'll be surprised at how much more you can remember by doing this so now we should be ready to get into the fun stuff Big O notation we use time complexity to describe the amount of time it takes to execute a certain algorithm or program not hard time like seconds or minutes but a mathematical generalization of the time taken and we use space complexity to describe the amount of memory used by the algorithm of the two time complexity is a lot lot more likely to be focused on space is cheap and memory is more readily available improvements in time are generally the more often bottleneck and felt more by the users and when we talk about these complexities we are referring to them as the size of the input grows and this is technically where the big old definition comes from you don't need to remember this technical definition but it's good to know the origin so big O is a mathematical notation that describes the limiting behavior of a function when the argument tends towards a certain value or infinity and finally the reason we use Big O is to help us describe the performance of an algorithm in relation to the size of the grown input this provides us with a simple way to compare and analyze different algorithms efficiencies so let's look at an example let's say we are given a problem where we have a list of n numbers of unknown length and we do not know what numbers are in the list we are asked to use code to find and return true if the number two is in the list and false if the number two is not in the list our solution could be to go through every position in the list and check if the number at that position is equal to the number two so here is our code and let's take this list for example full numbering list so we begin at the first index if the number is equal to two then return true if it's not then we just continue and we keep going along our list until we find two and then we return true if two was not in the list then we would reach the end of our Loop and we would break out and return false and the time complexity for this problem is linear as you can see as the input size grows the time taken grows in a straight line to Loop through the entire list of n numbers and make sure that two is or is not in the list it would take end time or the amount of numbers that are in the given input we need to check every number in the list once making this solution o of n linear time the longer the list the bigger n is and the longer it would take to complete our solution and it's important to remember here that we are looking at the worst case scenario if two was always at the start of our list the operation would take constant time one quick operation but in our problem two could also be at the end of the list so we would need to iterate over our entire list to find two which as the list of n numbers grows will take n time to check each number and find two at the end of the list in our worst case scenario what you're looking at here is three different graphs of the same thing we are plotting the different types of complexities that you must know we have around seven complexities to cover and we'll take a look at them more in the next slide for now the best thing you can do is add a graph like this to your notes pick the one that you find easiest to remember and refer to quick we can see that constant operations are the fastest and this makes sense right if we were to pull an item from a list using its index for example the fifth item in a list it will not matter if the list is five items or 5,000 items long it's a constant operation logarithmic operations are the next fastest some graphs might show log n starting off faster than constant operations and this might be true in some Edge case practical applications due to the mathematical aspects of it but I would really suggest focusing on the tail end of these graphs because remember Big O is concerned with as the input size grows what happens to the speed of the operations so we have constant and then log n or logarithmic linear n of log n which is linearithmic quadratic and subsequently cubic so x ^ 3 and so on and then we have exponential and factorial so what you see here is a table of all the complexities from the previous graph in the fastest to slowest order I've also linked some more examples but feel free to pause the video do your own note taking and understanding right now these concepts are probably still abstract to you and that's expected you'll only really grasp them once you put it into practice or do the real thing and it's like driving a car you can read everything there is about driving and changing gears but you won't understand how it's done until you get in the car and drive it so let's go through this table and hopefully we should be somewhat aware of the different time complexities that exist before going on to solve problems so the first one is constant time complexity and this is where the time taken remains constant regardless of the input size and this is the example we gave earlier by accessing an element in an array or list by the index next up is logarithmic and this is where the time taken increases logarithmically as the input size grows operations are typically halfed at each step time increases linearly as n goes up exponentially and this is what gives us that curved shape which looks as if it's becoming a straight line right this one here next up we have linear which is a straight diagonal line and this is where the time taken increases proportionally to the size of the input so if n doubles the time taken doubles and this was the first example that we showed next up we have n log n and this is where the time taken increases in a linear rhythmic manner so we often see this in divide and conquer algorithms and if you're not familiar with what these are or some of these operations on the right here it's fine it's to be expected at this point next up we have quadratic so n ^ 2 and the time taken increases quadratically as the input size grows so each element needs to be compared with every other element so we could have a for Loop within a for Loop for example after that we have exponential where the time taken doubles with each addition to n leading to rapidly growing execution times so imagine if we had a list and every time we added an item to that list the time taken to complete our operation doubles so this is extremely slow and the slowest of all is factorial so the time taken increases factorially with each increase in the input size and if you're unfamiliar with what factorial is it's something in maths where for example if we had five factorial or five followed by the exclamation point this would be 5 * 4 * 3 * 2 * 1 which is equal to 120 and so if we had 10 factorial this equals 3,628 800 so you can see the rapid time increase going from just 5 to 10 factorial and how slow factorial operations are so that's big or notation there will be more material and detailed examples Linked In This document but this will definitely get easier with practice so for now let's move on to problem solving we have all the theoretical knowledge in place it's time to get practical we need a framework for solving problems I see many people fail in interviews because they don't have their own familiar process for problem solving not only does this help with solving the problem but it gives an interviewer confidence in your critical thinking skills and it allows them more opportunities to guide you on the right path so step one is always to read the problem twice and understand it if you're in an interview take the opportunity to ask clarifying questions for example is there a range of numbers in the problem or can it go from positive to negative Infinity it might not help you directly but it helps you understand the problem space and get a bit more comfortable and again it shows the interviewer that you have critical thinker skills next you want to think and verbalize different ways of solving the problem at this point you want to think of high level approaches and to get you started and feeling more comfortable you can always start with a Brute Force approach this might be the slowest complexity solution you can think of but you can voice the fact that you know the solution is not ideal and that you just have one rough idea to get you started you can think of more solutions and for the best one or two solutions take it more deeply and think about the solution end to end from input to output and the steps between it's important to take all of these steps before coding out because remember even Einstein said if he had 1 hour to solve a problem he would spend 55 minutes thinking about the problem and 5 minutes on the solution so if you're not in interview setting I'd really recommend putting pen to paper and drawing out the problem and drawing out potential Solutions with the pseudo code to go with it and we'll see this in practice when we come to look at the questions this will help you visualize your solution and see anything steps that you might be missing this is good when practicing because the more you draw things out the more you begin to see the same patterns in different questions and the solutions become second nature so draw out the answer you think is the best step by step and write the pseudo code from which you can now start coding out your answer once you have the answer and you can get it to work see if you can improve it or think of faster solutions that might take a different approach after that go through other Solutions even if you answered correctly lead code lets you see the top Solutions however be careful a lot of the top answers take the competitive programming approach of writing the answer chaining together several operations in one line in an almost non-readable fashion I would suggest completely ignoring these answers because you want your code to be readable this is something interviewers look out for so look for the answers which seem logical and readable and the comments will often include time complexities and good discussions around the solution which you can benefit from so with all that being said we now have a system in place for answering coding problems and we have the foundation of the time and space complexities in our heads let's finally get our hands dirty and get into the fun stuff on answering some questions I'd suggest pausing the video and trying to solve each question by yourself and coming back to discuss the solution follow the link in the titles or look for the same named question on leak code and try to solve it you should also have your notes page ready where you can write the solution out and notes about what you've learned so when you come back to practice it's all there and it triggers your memory if it takes you longer than 15 to 20 minutes to come up with an answer or you're not working through one I'd suggest going straight to the solution in the interest of working efficiently then try to write out the solution and later in the day come back to the question without looking at the solution so this is the array section and duplicate values is our first question and while I was making these notes I added this Banner here as a guide where it shows the percentage of people who have passed this question successfully on the first try it's not something to take note of honestly because anyone can look up the questions or go straight to the solution and write their answer but it was just a good way for me to try and hit a range of difficulties in questions when working through each section so let's take a look at this question given an integer array nums return true if any value appears at least twice in the array and false if every element is distinct and we have some examples down here so because one is in this list twice we return true and because there is no double or duplicate value in this list we return false so immediately I can think of one solution where we Loop through the list and at each point we loop again to check if the number exists twice so at one we would Loop and and we would go a nested Loop to find this one and if this one did not exist then we would go to the two and then we would send out another loop forward this solution is quite slow however because we have a nested Loop and it would take around quadratic time or n s time complexity a better solution would be to use our python skills and use a set a set in Python is a built-in data type which does not allow for duplicates amongst other properties so if we take a set of the given list and we check the length of it against the length of the original list we will know for certain that any difference in the numbers means there was at least one pair of duplicate numbers this solution is O of n a lot faster than the nested loops and down here you can see I wrote some notes to myself at the time that I was practicing on how to create a set Python and the lookup time for sets and I encourage you to do the same so fairly simple and I don't think it's worth whiteboarding this solution next up in arrays we have missing number and without even reading the question I have left a little reminder to myself as to what the question is and this will be super useful for when you're practicing later and you keep coming back to do the same question and you don't want to come over here and read the whole dialogue so it tells us given an array of nums containing n distinct numbers in the range 0 to n return the only number in the range that is missing from the array so quite a wordy description here we have 301 and the output is two so it looks like we just returned the missing number however we also need to be careful here cuz the question tells us from 0 to n and we can see in the second example that we are looking at the length of the array so if we have two numbers in the array 0 to n becomes 0 to 2 and we want every number 0 1 and two even though it looks like this is a complete array here from 0 to one initially I created this solution where I sorted the numbers and looped through the enumerated list this gives us I and V where I is the index and V is the value inside the loop so for this example in each Loop we would sort the list and at index zero we would have the value zero at index one we would have the value one and at index 2 we would have the the value three so next I have an if statement to check if I is not equal to V because at some point the value would be one greater than the index and at that point we can return the value that should have been at that index which is vus one returning the index here would have worked also and finally we can cover the edge case in example two this solution is n log n which is relatively slow and the reason being is that sorting in Python is n of log n and so that slows our entire solution down otherwise the rest of it would have been linear and we can see from the submissions that I made how slow my initial solution was in comparison to others a better solution would be to take two values the first value being the expected sum of our list and minus from it the actual sum of the list and the difference will give us the missing number and to get that first value we take the length of the list and plus one to it the reason we plus one is because next we take the sum of the range and the range in Python excludes the last value so range three would only give us 0 1 and two if we plus one and take Range four that would give us the expected range which is 0 1 2 3 so we add one take the range and the sum from there we have our value and we can do our calculation to find the missing number and this gives us an O of n answer because you can see in my notes the relative time complexity it takes for each operation in this solution if our list or input Grows by double for example we only have to do double the additions and so this summation here would be our bottleneck I'll put on the screen a good explanation on doing more of the same operation in a linear fashion and how we can look at multiple operations in the same solution to figure out the time complexity so bear in mind that doing multiple of n operations sequentially like we have here and not nested in the same algorithm or solution would still equal o of N and so that's our solution for the missing number in these next two slides I've left some raw notes to show you guys the type of reminders I would leave for myself here I was playing around with the different ways to iterate through dictionaries and the difference between sorted and sort functions in Python I also had a look at lambdas after seeing them in some solutions and I played around with the code I wouldn't recommend getting too far deep into lambdas because in my opinion you can do the same things using plain code like loops and lambdas are slightly less readable but this did make me more comfortable with the language and the next time I saw lambdas I could rewrite the solution to my style anyway on to the next array question find all missing numbers in this problem we have to check the given list for missing numbers in the range one to length of numbers so this is a nice little reminder for myself because I've seen this question before but if you've not seen this question let's read the official description given an array nums of n integers where num's I is in the range 1 to n so essentially we're given a list of numbers from 1 to n return an array of all the integers in the range 1 to n that do not appear in nums so we have a list of nums here and I can see we have some numbers repeated like three and two and we need to return the numbers that are missing from the range of 1 to n where n is the number of items in our list or the length of the list and we return five and six because they're the ones that are missing and this looks to be true in the second example also so whenever we're looking at duplicat cuts my mind immediately goes to if we can use sets so let's go over to our whiteboard and have a look at the solution this is the nums that was passed in in the first example and here I've written out our solution the first thing we want to do is take a set of our numbers so this means we're going to have the same list as a set where all the duplicates are removed and it's not relevant here but just a reminder that sets in Python are unordered also so we have 4 3 2 7 8 we already have two we already have three so let's add the one and we're going to create a list called rep so that we can return this and in here we're going to put the numbers that are missing and then we're going to Loop through the range from one to the length of our numbers plus one so the first value is the first number that we will loop from if we do not include this the range will start from zero but the question tells us we're starting at one and the length of our list here is eight and remember that the end of the range in Python excludes that number so we want to add one so this value becomes 9 and our range is from 1 to 9 and the 9 will be excluded so it's from 1 to 8 and and simply for each I or each number from 1 to 8 we're going to check if it's in our set and if it's not we're going to add it to our list here and at the end we're going to return this list so one is in our set two is in our set three is in our set keep looping four is in our set but five is not so here we're going to add I or five to our return list loop again in our range and the next number is six six is also not in our set so we can add this to our return list and two more Loops we see seven and eight are in our set and finally we can return this list and that is our solution we've solved this in linear time because we're iterating through our range and appending to the new list if the size of our list doubled the number of operations would double also and we're using o of n space because we've created our list in our set again if our input doubled then the length of the set might double depending on how many numbers are missing but to remember complexity and worst case so in the worst case one or no numbers are missing so the set to definitely double and the return list if we had more numbers missing would also grow in a linear fashion I've also included a solution which had all of one space right now I don't think it'll be beneficial to go through it but if you're looking to improve your python skills and understanding of these questions it will definitely be useful to go through this constant space solution so here it is and so that covers everything on this find all the missing numbers question next up we have tucon one of the most popular questions on leak code given an array of integers nums and an integer Target return indices of the two numbers such that they add up to the Target and we can assume that each input would have exactly one solution you may not use the same element twice you can return the answer in any order so if we have an array of numbers here and there are some large constraints on the numbers so pretty much the list can have any numbers inside and we're given a Target we need to return the indices of the two numbers that add up to that Target so two and 7 are in position 0 and 1 and they equal 9 let's take a look at our whiteboard so our Brute Force solution could be to go through each position in the list and check against the rest of the numbers in the list if the addition equals our Target so if we started at number two we would then send out a second Loop to check 7 11 and 15 if they equal our Target and if we did not find a solution then we would Loop to the next number and send out another loop and we would do this again so this is an example of nested loops and in our example here even though we would achieve this on the very first nested loop it's important to remember that when we look at time complexity we're looking at the worst case scenario so if these two numbers here were not in the first two positions there is the potential to Loop through our list of length n and for each number we would do N More Loops giving us o of n^2 so this is a very slow solution but it's a good start a better solution would be to pass through our array once and the way we're going to do this is using a trick which might be difficult if you've never seen this question before so if we being smart about this we could base our Solution on the fact that for each number our Target minus the current number gives us the only value that works so 9 - 2 gives us 7 and we need to find seven in our list to be able to return a solution and this works for every number if we took 9 - 11 we would have min-2 as our solution and we would have to find min-2 in our list the best way to do this is to create a hash map also called a dictionary in Python of our numbers in the input array and their positions as we Loop through our array one time value and index so I'm just going going to change the order of our input array here so that we can fully understand the question and we pass through one more number before getting our solution so our solution here would be 0 and two and I'm just going to add the indexes on top of each number so that we don't get confused okay so initially we take our value two away from the target 9 and we realize that we need to check our hashmap for the number seven initially our hash map starts off empty so we don't find seven in that case we add two to the hashmap and the position of two in our array and then we move on to 11 we check the values of our hash map for minus 2 that doesn't exist so we add 11 and index one to our map and we move along in our Loop to the second index or the third item in our list we do 9 - 7 and we realize we need to check our hashmap for the value two two is in our hashmap so we can return the indices zero and the current pointer which is two and there's our solution the reason we keep our hashmap empty initially instead of populating it and then checking is to avoid using the same number twice on an abstract level let's say we had an array here where each box represent presents a number and let's say these two numbers are our solution at any point in our solution we have checked the left side of our array and hashmap only includes the values that we've looped over and when we finally reach the second element of our solution we know for certain that we're going to find previous element which gives us our solution cuz the hashmap has now been populated with the value and the index of that first element but if we had an array which only contained the number two so we only have two at index zero if the target was four and we had pre-populated our hash map we would end up using that two twice and that's why we fill the hash map while iterating over our array since we are only iterating once which is linear o of N and adding each value to our hashmap which is a constant time complexity and looking up in our hashmap or dictionary which is also a constant time complexity our solution is O of n in terms of space we are creating our hash map and if our two values were the last two in our array we would have a hash map of length n minus one which we can simplify down to O of n space so if you've not yet looked at the code I would recommend pausing here and giving the code a go now that you know the theoretical solution otherwise let's look at the code on the left is the solution that I first wrote out I added a note to myself that we can clean up repeated code by creating a variable for example Target minus V and reusing that instead of the same operation twice and we're doing this on the right here creating the variable diff so we have our hashmap and for each index and value in our enumerated array we find the difference of the target so for example 9 - 2 which gives us 7 we check if the difference is in our hash map which initially starts off as empty so the value seven is not in our hashmap so we can add the value two to our hashmap with the current index which is zero eventually we would reach seven and find our Target value two in our hash map which is the difference between 9 and 7 and then we can return the current index which would be two alongside a look up in our hash map based on the current diff which is 2 or 9 - 7 we check the keys of our hashmap for two we find two and return the value zero which denotes the index of the second number of our solution which adds up to the top Target 9 and that is the solution to tuom after completing this solution I looked at other Solutions and I found one in Java now typically I wouldn't recommend looking at other languages but it was just for my experience and being able to say that I kind of understand another language and how it works and you can tell which solution I wrote was in Python and which one was in Java typically Java runs faster than python because it is a compiled language versus python which is interpreted and if you're not sure what that is go ahead and look it up or you can check out the material provided on software engineering Concepts which has everything you need to know covered inside over here on the right we can see the difference in Java and python for a different problem which is called final value after operations now I'm not going to go into this problem too deeply because the focus of this is the difference in the languages essentially all we have to do is return the value after a string list of additions and subtractions so we start off with zero and for each minus or Plus in a string that we're given we either add or minus one to X or zero so it's a fairly simple problem and you can see 90% of people passed it but over here on the right you can see why I recommended python over java because the same problem is so much more convoluted we have to set the types of our input and our variables as an integer or a number and a string list which is the plus and minuses and there also goes a lot more into creating a loop we have to say the number we start at and the conditions for breaking out of our Loop and what happens at the end of each Loop so just something to be aware of in terms of the differences between languages and something that that you can refer to if you're ever asked about Java and python or typed languages and interpreted and compiled languages so take a look at these and maybe make a table and add the differences to your notes next up we have how many numbers are smaller than the current number and the question tells us given the array nums for each num's I find out how many numbers in the array are smaller than it that is for each num's IE you have to count the number of valid J's such that J does not equal I and num's J is less than num's I return the number numers in an array so this description is quite confusing and it's typically only when I read the examples that I understand what the question is telling me so example 1 81 223 and we return 401 13 so I can see now that 8 is bigger than four numbers in our array so we return four for that index one is not bigger than any other number so we return zero two is only bigger than one other number the second two is also only bigger than one other number and three is bigger than three other numbers immediately you should recognize that similar to the question two some we could do a nested Loop solution checking for each number all the other numbers and seeing if it's bigger or smaller than it however this solution would be quite slow giving us o of n^2 instead a better solution I found is to start by sorting the list which is n of log n and this allows us to avoid the nested Loops so let's take the first example and go over to our whiteboard first up we would create a temporary variable which is our nums array but sorted so we would have 1 2 2 3 and 8 we then create an empty dictionary and then we would Loop through the enumerated sorted list that we called Temp and the reason I was able to come up with this solution is because I had just completed two sum and while drawing out the solution I began to see the same patterns in this question so at this point we check if the number is not in our dictionary then we can add that value to the dictionary and before carrying on with the rest of the solution let's go ahead and give this a go so initially we will have an i or an index of zero and the number one our dictionary is empty so we can just add the two values to our dictionary next up we have two at index one and next we have two at index 2 and so two already exists in our dictionary so we don't do anything and this will be key later and the reason that we sorted it in terms of figuring out the other numbers that are larger than the current number so we continue and we have three three at index 3 and then finally we have eight at index 4 after that we create our return list and we do one final Loop for I in nums we're going to add to our return list the value for that index so for I in nums so this list here eight is our first value we will append to our return list the value of the key I which is 8 so simply put we check our dictionary for I which is 8 and add the value for four next up we check our dictionary for the number one and we find it in this key pair value and add the value zero to the return list next up we have two and we check our dictionary and we find it has value of one so we add that to our return list and here is where the magic of the solution comes in cuz we have the duplicate value two which we're checking next in our dictionary two has the value one so we add one to our return list this two is also only bigger than one other number which is the one and we manag to keep our solution intact by checking if the number was not already in the dictionary at that point and if you remember we skipped adding the second two to our dictionary or updating its value this way the values of each number in our dictionary represents the previous numbers it's bigger than avoiding any duplication issues and finally we have the number three which gives us a value of three also so we would return this solution here which is the correct answer in my notes I added a reminder to myself that time complexity is more important than space because when I completed a mock interview with an engineer who was already in a big tech company he told me that space is cheap and so we focus on time complexity and that became an important reminder for me finally I also added an of and time complexity solution so this would be an improvement on my solution however I found this answer quite convoluted and I thought to myself it would be pretty difficult to come up with this on the first try and as an interviewer you would be pretty impressed and if not a bit skeptical if someone could come up with this answer on the spot however it was good practice to go through the solution and see how it works so I'm not going to go through the solution but feel free to give it a go yourself next up we have minimum time visiting all points and I really like this question because it's slightly different from your typical array type question and the solution is quite unique and it taught me some key lessons so if you want to give it a go pause now on a 2d plane there are end points with integer coordinates points I equal to X and Y return the minimum time in seconds to visit all points in the order given by points you can move according to these rules in one second you can either move vertically hor horizontally or diagonally by one or Square two units so we can either move diagonally in one move or 1 second or vertically or horizontally you have to visit the points in the same order as they appear in the array you are allowed to pass through points that appear later in the order but these do not count as visits so if we were given these points our result would be 7 Seconds which is the minimum time to visit these points and one thing that I think the question misses is our starting point and for example if you're in an interview setting this might a good opportunity to ask a clarifying question do we have to start at 0 0 or can we start at the first point in the array that we're given in this question we can start at the first point so we start at 1 1 and we move diagonally going to 22 3 3 and then up to 34 which is the second point in our list of coordinates and finally we move diagonally all the way back down to Min -1 0 and each point is 1 second in our traversal and so we have 7 seconds if we first take a look at my notes this was a key point in my practice or learning because I realized that coding should not be the difficult part in this question I spent a lot of time trying to code up the solution and work in on the wrong things and I realized that if you understand one or two things the rest of the problem should be easy and this is where I set the hard limit for myself on 15 to 20 minutes to come up with a working solution and the key idea in this question was that the distance between two points is the maximum difference between one of the coordinates X or Y so what this means is that if the next node or coordinate is 10 units away on the x- axis but five away on the y axis it's going to take exactly 10 steps to reach that point the reason being is that you can only move One X or Y at a time or you can move diagonally so if you move diagonally the difference in the Y which is the smaller of the two differences between the current coordinate and the next coordinate this five units difference is made up by moving diagonally so you move diagonally as much as you can and during the process the difference in the Y will be covered after that you reach a point like this at 33 where all that have to do is move in One Direction either vertically or horizontally to make up the remaining difference in the x or the y axis so if we head over to the Whiteboard it should make more sense we start off by creating a result variable which will keep track of the length of time our solution will take given the points that we have to hit we pop off the first two units which is one and one and this will be our starting point and we create a w Loop which only breaks once we we visited all of the points and our points array is empty we'll see this at the end next up we pop off the next two coordinates in our points array so X1 and y1 are 1 1 and X2 and Y2 will be 3 and 4 and here is the key to the solution which I explained earlier in that the minimum amount of moves we can make is the maximum difference between either the x's and the Y's between the two points so we take the absolute difference of the Y values and the absolute difference of the X values and we see which of these two values is bigger for the y's we have 4 - 1 which gives us 3 and for the X's we have 3 - 1 which gives us 2 so we add the value three to our result and we can see this is true by looking at how we move from 1 1 to 34 we move across diagonally as much as possible and that takes us 2 seconds and then we can only move horizontally to make up the final difference in the Y units which gives us 3 seconds then we update our coordinates so 34 is now our X1 and y1 and we repeat the same process with all of the points in the list at the end we'll have our result which is the total seconds it takes to hit all of the points in optimal speed and this is our solution now a question like this might not be asked in the interview because it will be quite difficult to convey a graph type setting but I added this in here because it's a key learning point that once you understand one or two key Concepts in most questions coding it up then becomes super easy and as you can see we only have one W loop with a bunch of constant operations inside so this gives us a Time complexity of O of n we're also only storing a set number of variables the result X1 y1 and X2 and Y2 and regardless of the growing input size we're only storing these set variables so that gives us a constant space complexity and that is our solution for the minimum time to visit all points in a graph next up we have our first medium question and this is one of my favorite questions given an M * n Matrix return all elements of the Matrix in spiral order so if this was our Matrix we would go along the first row down the last column in Reverse along the last row and then back up and to the middle and the same for a larger Matrix so it sounds fairly simple and this is one question that I would highly recommend giving a go so if you feel up to it pause the video and give it a go this might take a long while to figure out or get the code working but I'd suggest not giving up as you can see here there's a lot to cover in my solution on the left I've included the working out that I did to get to my solution and this took me quite a while and you can see the value when I suggest to you guys to draw stuff out and work it out because it really does work and it really does help you quite a lot I started off with the first Matrix that they give us in the question and I put it alongside the input or the Matrix array and then I began drawing out the solution our first move is to go across the first row and I saw that directly corresponds to the first array and then I saw that going down correlates to the last two points in the last two arrays then the purple line going back left is the reverse order of what's remaining in our last AR and the orange line going up and the green line going across will be these two values here so I had a basis for some sort of pattern and I repeated it with a larger Matrix to try to generalize the solution again I saw the first row was the first array of our Matrix the same last two elements by going down going back left on the last row was again the reverse order of the last array minus that last value and the orange and the green line were these two values here except now we had an extra in our green line so I repeated this once more with a larger Matrix except this time I increased n as well as M after that I was happy to pull some sort of algorithm from my whiteboarding and I wrote it out at a high level and I came up with this one here from this I coded up my solution which you can see on the right it took me a while for example my algorithm on the left forgets to check if the Matrix traversal is complete so I had to add this function after and you can see how each step correlates to a section of the code on the right so after trying to submit my solution getting it wrong trying to tweak it and improve it without looking at any solutions completely doing it by myself I finally got to a working solution that passed all of the tests and this really increased my confidence tfold I completed a medium question by myself just by putting pen to paper coming up with the algorithm and writing it out from scratch after that even though I was correct I looked at the best solution I could find and it was a much more simplified and cleaner version of my solution but again I was happy to see that I was on the right track so this is our solution here let's head over to the Whiteboard and see how it works so here we have the simplest Matrix from example one the input that we given and our Solution on the right if you want to give it a goal in one of the larger matrices feel free to play around with it after this solution the first thing we do is create our return variable and then we check while Matrix and this was one of the first key differences I saw in my solution in my solution I was checking while true and then I added a function to check if our Matrix was empty and if it was then we could break out of our W Loop and return our result variable if I hadn't have come up with the solution first it definitely wouldn't have registered as much this key difference in how to write w Loops in a cleaner fashion and this is why I'd always recommend to come up with your own solution no matter how messy or slow your solution might be anyway the first thing we do is add the first row /list of our Matrix to our return variable and we do this by popping off the first list from the Matrix which is 1 2 3 and using the plus equals means we just add the items instead of the array itself next up we move to step two if our Matrix exists and the first list within our Matrix is truthy then for each row in our Matrix we pen to our return variable the last item in that row and we do this by popping it off so that would be the six and the nine so let's remove those and add them to our return variable using the builtin append next up we move to step three add the reverse of the last list so if the Matrix exists we pop off the last item so when you don't add an index we're popping off the end we're adding this to our return variable in reverse order so we would add 8 and 7 and this is this move down here along along the bottom row in Reverse next we move to step four The Matrix does exist and the zeroth element is truthy so for each row in our Matrix in reverse order so this will come into play for a bigger Matrix but for now reversing the order of our Matrix gives us the same Matrix so for each row which is the list four and five pop off the first item from that array and add it to our return variable so let's add the four and not forget to remove it so we go back to the top of our wow Loop the Matrix still exists and we're back at step one in step one we're popping off the first item from The Matrix and adding it to our return variable so let's add the five and remove the first item at this point in the Second Step The Matrix does not exist so we can break free from our W Loop and return our return variable 1 2 3 698 745 1 2 3 698 745 this solution is out of n because each operation is linear so our Matrix grows our operations grow linearly there are no nested Loops or any operations that could expand in a nonlinear fashion as our input grows and so that is the spiral Matrix question our first medium question in our array section next up we have number of islands and this is a very nice question because the solution introduces A New Concept which we'll be looking at later so given an M * n 2D binary grid which represents a map of ones and zeros which is land and water return the number of islands an island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically you may assume all four edges of the grid are all surrounded by water so if we take the first example we can see that the output is one because we have an island here and all of them are connected horizontally or vertically so if we had a one in this position it would be a separate Island and we can see that in the next example so we have one Island here the second island and the third and essentially we need to iterate over this Grid in some way that we can find all of the islands and initially I can think of one very slow solution which is to brute force it in some way by iterating over each position in the grid and then maybe a second iteration around to check whether there's ones and zeros and to be honest if you're not familiar with the concept that the solution implements then I would be very surprised if you were to get it on the first try without using some slow boot Force solution however if you watch the data structures video then you might remember the search algorithms that we went through giving you a good chance so let's take a look at our solution we will be using breath first search again if you have completed your data structures this will be very familiar to you if not I'll quickly go over it breath first search is a traversal algorithm that explores nodes or elements in some iterable object like a tree breath first search is commonly spoken about alongside depth first first search you can think of them like two sides of the same coin breath first search explores all the neighbor Nords on the same level before moving on to the next level and we'll cover these two algorithms a lot more in binary trees so it's a good reminder to ourselves in this section typically there are two implementations of both the algorithms iterative and recursive I typically don't like recursive algorithms they're harder to read and debug and they can take up a lot of space in memory which can cause stack Overflow we have gone so far deep in a cool stack that there is no more available memory so I recommend using the iterative approach and remember from our data structures practice a key difference is the use of a Que in breett first search versus a stack in depth first search so let's take our solution over to the Whiteboard this is the Grid in question and let's start off our solution we first of all check if we have a grid and if we don't we return zero because there are no Islands Let's ignore this breett first search function for now and continue following the execution the same way the code would and let's go down here and create these variables we start off with a count of zero which will count our Islands the rows and The Columns of our grid and we'll be using these to make sure we're in the right range so we're not checking any positions that are outside which will give us an index error and then we have a visited variable which is just an empty set for now and it will keep track of all of the elements in The Matrix which we have visited or not then we start off with an nested Loop so for every item in each row and every item in each column so be going along the rows and then the columns so our rows will be the length of the grid which is 1 2 3 4 and the length of the first item in the Grid or the first row which is five so in range four and in columns five if grid RC which will be 0 0 because we're on the first iteration of each range if this equals 1 and RC is not inv visited then carry out the bre first search function that we skipped earlier so position 0 0 equal 1 is true and RC is not inv visited 0 0 so let's go ahead and jump to our function here let's create a Quee and I think it will be better to call it search CU because this will hold all of the positions in our Matrix which are next up to be searched by our algorithm and I've initialized it as a deck here but a q would work just as fine now let's add z0 to our visited set and remember sets do not allow for duplicates which is why we use one you know we could have used a list and then check if 0 is already in the list but this is much more efficient and then we're going to add 0 to our search queue so while our search queue exists let's pop off the first item so we're going to grab this 0 0 and to this first coordinate we're going to add a bunch of different directions and remember this is the up down left right we're going to check to see if the island exists and not the diagonal as the question told us so we have our first coordinate and then we're going to be adding some directions the first one is 1 0 so we've added to our row and our column here which are 0 0 the direction in the rows and the direction in the columns that we're going to search which is just up down right left so inside our for Loop here the r and the C are going to be 1 and 0 1 0 and I think it might be good to cross off 0 0 even though we've not finished searching around it it's in our visited set and I think this will help us keep track but it's the current item we're searching so I'm going to draw a blue circle around that so we're on this line now R is inside our range 1 and zero is inside our range for the columns so that's nice and easy we just have a quick sanity check now is grid RC equal to 1 so 1 Z would be the second column because we're zero index based in Python and it would be the First Column inside that second row is the value equal to one yes it is and is it not invis one Z is not inv visited so let's go to the next line we're going to add one Z to our q and then we're going to add one Z to visited and at this point you should be able to see the breett first search algorithm starting to come to life we're still inside our full loop for the position 00 0 so we don't need to update our blue circle yet back again we're going to check the next set of directions so RC becomes Min -1 0 immediately I can tell this is outside of our grid so we go to the next one because this if will be false the next one is 01 01 is the first row and the second column this is equal to one and it's not already inv visited so we're going to add the position 01 to our q and our visited set and I'm going to cross it off adding it in here back in our Direction S 0 - 1 will be out of range so our if statement will not execute we go back to the top of our W Loop in that case and we start off again by popping the next item in our search queue that we are going to search so we're going to pop off this one Z update it down here and we can move our blue circle to 1 0 and at this point you can tell in our traversal algorithm that we're going to search what's right and what's down of the current item so let's give it a go so we're currently searching 1 Z and we're going to add these directions to it and we're starting off with 1 Z our new RC will be 2 0 two is in the range of our grid to0 is equal to 1 third row and the zeroth column so we're going to add it to our visited set and append it to our Q so that we can search it later so let's cross it off add 20 to our visited set and append it to our q and then we go back to the top of our for Loop check out Min -1 0-1 1 0 will give us 0 0 except 0 0 is already in our visited set so this if statement will be false and we go to the next direction that we need to search so we've already searched the one above next up let's add 01 which gives us 1 1 and that will be the item that's right of our current search element so I've crossed it off because it's in the range it's equal to one and it's not inv visited in that case let's add it to visited and add it to our search CU and then finally we're going to check 0 - 1 that would give us 1 - 1 which is outside of our grid and that finishes our search for this element we go back to the beginning of our wow Loop and in our search queue we will pop off 01 and repeat the whole process again at this point you should understand kind of what's happening if you don't I would recommend continuing to carry out this algorithm by pen and paper but essentially at this point we would check this one here cross it off our search update the visited and repeat the process for to0 at this point we would search around cross this one off update our visited set update the queue and eventually we would cross off these two here and we would finish because our Q would be empty so we would break out of our wow Loop and come back down here update the count by one at this point we are still only on 0 0 in these two for Loops so R is still equals zero and C is still equal zero but we've visited a bunch of items and added them to our set plus the others that we went through quickly so back at the beginning of our nested for Loop the next item to search would be 01 01 is in our visited so this if statement will be false and we would move on to the next one which would be 02 we would continue repeating this process and for this example we would find that we have visited all of the ones that are possible and if the item in the grid was not in our visited then it is not a one and so the if statement would also be false at that point we found the only Island that we can we break out of our two for Loops once we reach the end of our grid and we return the count of one so it's a super cool solution and if you just spend a minute or two drawing out the algorithm the traversal immediately becomes clear and you can quickly pick up on the concept of Brett first search and how we are approaching this solution and if you're still struggling with it I'd recommend to give the second example of go and finally the time complexity for the solution is O of M * n so something new that we've not looked at this is somewhat similar to the n^2 time complexities except in this case our rows and columns could be very different so we're doing M * n it depends on the input here and in actuality our solution is 4 * n * n because in the worst case scenario we could search each position up right left down and we find another one and we search again up right left down and we continue doing this except when we look at time complexities we're looking at the worst case scenario so when our input is extremely large this four becomes so insignificant that we can boil our solution back down to M * n and that is the number of Island solution so next up in our array section we have two pointers and this is a common technique when working with things like arrays and Link lists and if I zoom in here you can see two pointers is a common pattern that you might come across and don't be too concerned with what's actually happening in the image just be aware of the fact that it's a reminder we have one pointer and a second pointer in our array or linked list or some kind of iterable and we're using those to solve the problem so our first question is the best time to buy and sell stock go ahead and give this a go if you want to otherwise let's read out the question and go through the solution you given an array of prices where prices I is the price of a given stock on the eth day so for example 7 would be the price on day one you want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock return the maximum profit you can achieve from this transaction if you cannot achieve any profit based on the prices arrate then return zero so in a sense we want to find the greatest difference going forward so we have to go from left to right and the second number is when we sell so we're minusing the first number that we choose from a number that must come after it so 7 and 1 might give us a bigger difference but we' have to do 1 - 7 because we're buying at Price 7 and selling at 1 which would give us minus 6 so the best difference in fact is to buy at Price one and sell at Price 6 6 - 1 gives us five and in this case the numbers are always decreasing so whatever price we buy at we're going to have to sell at a loss so in this case no transactions are done and the max maximum profit is zero let's give a look to the solution so our solution says reminder to myself greedy algorithm I know that this is an algorithm where we make the best choice at each step in our problem or in other words making the locally Optimum choice at each stage and this is in our two pointer section so you already know we're going to use two pointers so we have a left and right pointer so for each left pointer iterate right across and calculate the profit when right is greater than l or left we know we have evaluated all potential ual maximum profits so move left to where right is and repeat so this might sound a bit convoluted but let's look at the solution on our whiteboard so let's take the first example and have our set of prices here so we initialize a left and right pointer at 0 and one and we initialize a variable of Max profit and start it off at zero because if we can't find any profit we return zero we have our left pointer at s and our right pointer at one while right is not equal to the length of prices so while we're not at the end of our list if Price's left is less than Price's right let's carry out some functionality so first of all is prices left less than prices right well seven is definitely not less than one so we can skip this if statement and head to making left equal to right and then we plus one to our right pointer so back again we repeat our W Loop 1 is less than five for sure so we can calculate our profit at this point and you can see we're going to be calculating our profit at each point using the two pointers and this is why it's a greedy algorithm we're calculating the best possible choice at each stage of our problem so we check is our new profit greater than our current maximum profit well 5 - 1 is greater than zero so we can update our Max profit to B4 and now we can update R to B + one so the reason we're not moving left is because we want to calculate if there's a greater opportunity for the same Buy price our left pointer and without going through each line of code we know that three is going to be less than our current Max profit because 3 - 1 gives us two so we move right again in this line right is still less than our length of prices because it is 0 1 2 3 4 which is our pointer so it's the value of the index that we're currently looking at and our length is six so is price is left less than Price's right yes it is the profit at this stage would be 5 6 - 1 is 5 and we're checking our new profit against the max profit 5 is greater than four so we update and move along in our W Loop update R so the value of R is five and it points to the element in our list which is the number four one is less than four but the profit by buying at Value one and selling at Value four is not greater than our current Max profit so at this point we would update the right index pointer by one back at the top of the W Loop the right pointer is now equal to the length of the list so we break and return the max profit and you can see why this simple statement works now cuz if we found a new value in our prices which was less than current price and we had already evaluated all of the options up until that price the next best step would be to begin reevaluating from that price so if we had the value zero after the six we know that when our left pointer is at one we've already evaluated the five the three and the six and then our right pointer hits zero we know that from this point forward any profit we try to calculate is certainly going to increase by making our new left pointer which is is our Buy price the zero and that's why this simple if statement works so well and that's the reason for updating our left pointer to be our right if this is not true but back to the question we originally had at hand we update R by one at this point R is equal to the length of our prices because python is zero indexed so at this point R is equal to 6 so we break out of our while loop and we return our Max profit so using two pointers instead of a nested for Loop which would have given us an n^ S time complexity we can get an O of n complexity which is is a lot better and we have constant space because we're only keeping track of three variables no matter how big our input prices array is we're still only keeping track of these three variables so that completes best time to buy and sell stock a nice introduction to two pointers next up we have this array squaring and sorting question and this is a really good one because I know there's at least three approaches we can take to solve it and it would be really interesting for you to pause and give it a go and see which solution you come up with and going through each solution will really help us understand time complexities so this is a good question for that given an integer array nums sorted in non-decreasing order so from smallest to largest return an array of the squares of each number sorted in non decreasing order and if it's not obvious one easy trick to getting a fast time complexity solution in this question is to understand that squaring a negative number or a positive number gives us the same value so we need to square all of the numbers and sort them and it says down here here squaring each element and sorting the new array is very trivial and that is why this question has a higher pass rate it's finding the O of n solution which is a bit difficult so first of all let's take a look at the easiest solution and you can see down here I just made a note to myself that there can often be multiple Solutions and it helps to evaluate the time complexity of each subprocess to help us try to find the optimal solution not only that but it does also help with identifying the time complexity of the current solution you have so the simplest one is to Square all of the numbers in our list and then sort them iterating through the list and Performing the squares is O of N and without getting into the technical details of Python's built-in sort function we know that it is n log n and so the Sorting is the bottom neck of this solution and it gives us an O of n logn solution next up we have the split and merge solution and this one is really cool so I've broken this up into three parts including a little Edge case section so we just check first of all if our number exist it has numbers inside and what we're doing here is we're making sure that there are no negative numbers this increases the efficiency of our solution because if there are no negatives then we can just Square everything and there's no need to sort them because the question tells us it's already in ascending order but from the examples we know there might be some negatives and in that case we need to carry out the next three parts so let's take our split and merge solution over to the Whiteboard and break down exactly what's happening so quickly we've checked our edge cases there is a list and the first number is negative so what we're going to do in the first part is find the index of the first positive number that's all we're doing so all we're going to do is iterate through our list and find the first positive so at this point we're here in our code we set M to equal zero we know that's not the first positive index and we're going to update it when we enumerate through our list we get the index and the value at that position we Loop over our entire list and eventually we find a value which is greater than or equal to zero at that point we set M to be the index and we break from our four Loop so at this point in our code we have M which is equal to 2 2 is this zero here 0 1 2 so this line might look a bit convoluted but all that we're doing here is reversing all of the negatives up to zero and I'm pretty sure you can see why that is because once we Square them the reverse order of the negative section of our list will then be in ascending order so this might be an example of poorly written code and I'd suggest finding your own way to write this instead of doing list comprehensions and we're cre in two variables in one line and we're doing a for Loop in one line we're reversing in one line there's a lot going on here and it's not the best example of clean code so maybe I could have changed that but it's good to see where you've gone wrong when you go back and look at these questions but nonetheless a will be equal to nums from m to the end of our list we set m equal to 2 so 0 1 2 and we're slicing our list from this point on so we have a new variable called a which is equal to 0 3 and 10 and We're looping over our list cutting it off at two not including two and we're reversing it and we're timesing it by minus one to make it positive this will give us one and four and similar to part one this is O of n because we have one Loop in it and we're performing operations as the list grows the operations will grow linearly and finally we're on to part three squaring and merging so we're passing in A and B into this merge function here we set new variables called A and B both equal to zero and a list R which is short for return because that is going to be our list of squared and sorted numbers which you're going to return and before we get into it essentially what we're going to do is for each position in the two lists capital A and capital B we're going to compare each index in the list to make sure we're increasing in the correct ascending order so while a is less than length of a and b is less than the length of list B let's perform some operations so this is our a pointer and this is our B pointer and so this is this one here and that's this pointer and pretty simply we check is the eighth item so pointer a that's one pointer and the second pointer B let's compare them if a is less than b so Z is less than one add the item to our list which we will be returning and update A2 point to the next position we go back to the beginning of our wow Loop and repeat this process 1 is less than three so we can add one to our list and let's not forget that we updated a to plus one to it and then we do the same now that we've added an item from B to our list so let's update the pointer to B4 the second position in B's list which is the first because we're zero indexing and then we go back to the top of our W Loop compare the two again three is less than four let's add three to our list update the position of a compare once again add 4+ 1 to B so B now has a value of two which takes us outside of our list the point of B is in fact equal to the length of our list B which was the negative section of our original nums list so we break out of our wow Loop and here this if statement and essentially what this if else statement does is we add the rest of whichever list we have not finished adding to our return list in this case all that's left is the number 10 so all of the items from the current pointer for our list a let's extend that onto our return list and if it was a that had gone out of scope for our list then we would have done the same for B so by splitting our list reversing and merging we have managed to sort our list in O of end time that's left to do at this point is the squaring which is the easy part and then we can return our list and there's our answer in O of n time super cool way to approach the problem by splitting the list from positive reversing it and then merging the two finally let's take a look at the third solution our third solution focuses on using these two pointers except we do it on the list that is passed in making the solution more efficient and we call this one absolute and merge so this third solution takes advantage of the fact that the absolute squared value of a negative or positive number will be the same and in this solution we use a deck so we're going to take a look at Q's later but if you watched the data structures video or done some practice you should be quite familiar with what decks are and how they work and this solution relies a lot more on the two pointers so we have two parts here we're going to iterate through our list and then we're going to append appending is constant time and iterating through the list is O of n so let's create our answer which we will return and this is our deck which I will represent as an empty list for now we have our left pointer so I'll call it left to be precise which we start off at zero and our right pointer which is the length of the list minus one so here's the same input that we had from the last question so our length is 5 - 1 gives us a right pointer of four because again as always python is zero indexed so we are here while left is less than or equal to right let's check the absolute values of the two and that should immediately let you know what's happening here we're going to create two new variables on the absolute values of those two items in our list based off the left and right pointers so the naming in this solution that I pulled is not great so I'm going to call this left pointer and right pointer and let's call it left value and right value so our left starts off at zero and our right starts off at 10 and in this answer a is being passed in as the list which is a bit different from the last example so let's not confuse ourselves cool so everything set in place now so the absolute value or the health item in our list a the absolute value of minus 4 is 4 same for the right pointer that gives us 10 so we've done that and let's move this now to this conditional statement left is greater than right that's not true so let's go to the else and we're going to append to the left side of our double-ended Q the squared value of our right value here so that gives us 100 and then we're going to reduce our right pointer by one back at the top of our wow Loop we check is left less than or equal to our right pointer that's true and the reason we're checking that is because when that's not true we would have finished iterating over our list and we will see that in a second so let's update our left and right values our right pointer is now three our left value is still four and our right value is now three if left is greater than right left value is four it is indeed greater than three so let's append to the start of our double-ended Q the square of our left value and now you should definitely be able to see why this solution works so well by using two pointers we can in one pass one single Loop iterate over our array and determine at each step which absolute value is bigger before adding to our answer this two-pointer method allows us in one go to avoid sorting our array like we did in the second Solution by splitting and merging reducing the code complexity and number of operations giving us a more efficient solution so let's continue with our solution and add one to our left pointer so we finish in our if statement back to the top this is still true now let's compare the next two values left value is - one but we take the absolute so it's one is the left value greater than the right no it's not so let's append the squared right value and minus one to our right pointer so now we're comparing our last two values this is still true we're comparing Z and minus1 1 is greater than zero so we add the square of that to the start of our double-ended q and and then we can add one to our left pointer so our left and right pointers are equal now and that is the importance of the less than or equal in our wow Loop and so again this shows the value of whiteboarding your Solutions and thinking about your solution end to end because something as small as an equal sign in a comparative operator can completely render your solution Incorrect and not just while solving leak code questions this often happens in your job or production code where something as small as an equal sign or some tiny missing value can completely break your system but there's usually a lot of testing to make sure nothing goes wrong either way make sure to pay attention to the details finally we check if left is greater than right which at this point they are both equal to zero so we hit the else statement and we can see this else not only covers when the right is greater than the left but also when they are equal and then we can append zero to the start of our double-ended q and we can return our answer without forgetting to convert the data type into a list so there's our solution which solely relies on two pointers and a quick note on the space complexity it is bottlenecked on the answer variable where we are storing our sorted squares array and returning that at the end so if we had a really long input the answer array we are storing could also be really long and this is a linear proportion and you can see for each solution how we slowly improved our code until finally we used the two pointer approach and came up with a super efficient algorithm next up is threesome the successor to two suom and it's a medium question easy question typically have one core concept whereas medium questions merge two concepts or two easy questions together so threesome Builds on two sum and there is a two sum part two question in between that might help in figuring out the concepts involved for thre sum so it might help to solve two sum part two before giving three sum a go the question tells us given an integer array nums return all the triplets nums i j and k such that I does not equal j i does not equal K and J does not equal K and the sum of these three numbers should be equal to zero notice that the solution set must not include duplicate triplets remember immediately we can always think of our Brute Force solution as a sort of safety net towards solving the question so we could have a triple nested Loop and search for each answer something like this we start off with the first nested Loop send out a second Loop to check each number and then the third third moves along then the second nested Loop moves along and then we repeat the process moving along in our first nested loop at each point check checking if the sum equals zero however this solution would give us n cubed time complexity which is very slow and it also has the potential to give us duplicates sorting rra will help us overcome the duplicate problem so I've quickly sorted ra so our solution looks something like this I + J + k equal Z and the Green Arrow indicates our Loop that will evaluate all the numbers for the I position before sending out the red arrow in a loop for the J number and the blue arrow in a loop for the K number and now that we've sorted our array we know that when we move on to the next number if this is identical to the previous number we can skip evaluating this number and move on to the next in our sorted array so a triplet with the I position of minus one for example has already been evaluated additionally we know that when the first number is positive we can stop our solution because we will never have a triplet summing to zero for example if we had an extra value in here and our first nested Loop began at zero there's no point continuing so sorting helps us overcome the duplication part of the problem and optimizes the solution a bit more we now have a system for safely filling in the first position in our solution after that we only need two more values to reach a new Target which will be the positive value of whatever I is so for example if I was minus 4 we know the sum of J and K need to be positive4 to give us a solution of zero and now the problem has been reduced to the original tucon problem two numbers and one target so we could use the original solution with a hashmap however now the array is already sorted Ed we can use two pointers to make this solution more efficient so here's our sorted array and if we begin by evaluating the first number in our array minus 4 we set the left pointer to be the next value in our array and the right pointer at the end of the array at each point in the algorithm we check if the sum equals z so for this example -4 -1 gives us -5 plus the 3 gives us -2 so we need to increase the value of our triplet because the sum is less than zero and the only way to do this is by moving the left pointer up because of course moving our right pointer down would have decreased the sum even further we could also have a check to optimize our solution that if it's the same number we can just move the pointer further up again so I've added a one in here to show you how to get to our solution so if this question had a solution that included the Min -4 -4 and 0 and 3 still gives us min-1 so we would move the left pointer up again and there's our solution for I and J plus K and this method will guarantee we find our solution there is no way for us to do this 2. adjustment and need to go back on it for example we will never need to move the left pointer back down or the right pointer back up because any previously unexplored combination that could be considered by reversing the pointers would have already been invalid based on our prior calculations of whether the sum was greater than or less than zero so you can give the code a go yourself otherwise let's walk through the first example now so here's the code for our solution the first thing we do is initialize a triplets list which will be returned at the end and give us our solution after that we sort the numbers and here is the first example from the the question then we begin a loop over our enumerated sorted array of numbers and that is this green arrow here next up we have a check we make sure that the index we're currently evaluating is inside of the range of our array to avoid any errors and then we make sure that the next number we're evaluating is not the same as the previous number to optimize our solution and avoid any unnecessary operations after that we initialize a left and right pointer the left pointer will be the next index along and the right pointer will be at the end of our array and then we begin a w Loop and this is just a conditional check to make sure our left pointer does not cross over our right pointer because we will have evaluated every option at that point then we take the current sum of the three values our pointers are pointing to so for the first Loop it will give us Min -4 + -1 + 2 which equal -3 our current sum is less than zero so we push the left pointer up by 1 we could also include another check at this point to push the left pointer up by one if it's the same as the previous value but never nevertheless our solution we'll check the current sum we'll find that it's less than zero again and we'll push the left pointer up again at this point we have a current sum of - 4 + 0 + 2 which gives us Min -2 left is still less than right in our pointers so we evaluate the current sum -2 is still less than zero and we push left up by one again our current sum is now - 4 + 1 + 2 which gives us -1 -1 is less than zero push the left pointer up by one left is no longer less than right so we break out of our W Loop and go back to the beginning of our four Loop so we've evaluated all of the options for minus 4 and we found that no solution exists I is now 1 and the value of that is -1 we checked if -1 is equal to the previous value we just evaluated it's not so we can set our left pointer and right pointers back to their starting positions at this point our current sum is -1 + -1 + 2 that gives us a value of 0 Z so we finally have a valid triplet and we hit this else block here we add to our triplets array that we initialized earlier our valid triplet which is -1 -1 and 2 and it's important now to keep evaluating for more solutions and this is exactly what's going to happen so we push our left pointer up by one index on this line and then in the next line we do another check to make sure that the left pointer is not equal to the previous left pointer value otherwise we'll be evaluating the same solution the I was already fixed this was our green pointer analyzing all solutions for I which was minus1 we then found a solution with a number for J and some number for K if we push the left pointer up by one and we have the same J number well this will just give us the same K number and a duplicate triplet so 0 is not equal to minus one this W Loop is false so we go back to the previous W Loop left is less than right and the current sum is now equal to -1 + 0 + 2 which gives us a value of 1 at this point our current sum is greater than 0 0 so let's minus one from the right pointer to move it down one value back at the top of our W Loop the current sum is now equal to Z again and we found a second solution for a triplet with the same IE position of minus one so down in our else block we're going to add the new triplet to our Solutions we add one to the left pointer but that would give us a left which is equal to right so this W Loop would be false and the same for the parent while loop and we go back to our for Loop and move along to the next evaluation which would be Min - 1 so I would be two except at this point the value is the same as the previous value we just evaluated and that's here in line 13 so we continue which makes us move along one more iteration in our for Loop to the zero and of course you can see at this point there are no more solutions we could also throw in the checks we talked about earlier for being in the positive side of our sorted array for example we could check if the left pointer when first initialized is a positive number in that case we know there will be no Solutions 0 + two positive numbers will never give us zero and finally our time complexity is O of n^2 because we have one main for Loop which iterates through the elements in the array once and we have our two pointers which also iterate through the array once despite the fact we have three nested while Loops as you've seen in the previous two pointer questions our two pointers only iterate across the array once the second W Loop simply moves our left pointer up skipping numbers that would otherwise have been evaluated in the parent while loop so this makes our solution n s cuz there's there is effectively only one nested Loop and space is of n for two reasons the built-in sort function in python as well as our storing of the triplets list and so altogether there's our solution for threeson finally the last question we have in the two pointer arrays is the longest mountain the question says you may recall that an array is a mountain array if and only if the length of the array is greater than or equal to three there exists some index I zero indexed where the I is greater than zero but less than the length of the array minus one such that every number to the left of I in our array is less than that number and everything to the right of the E number in our array is also less than that number given an integer array R return the length of the longest sub array which is a mountain return zero if there is no mountain subarray so simply put a mountain can be defined as a sequence of three or more elements where there is at least one element or number that acts as the peak this means the elements before the peak strictly increase and the elements after the peak strictly decrease and definitely give this a go because it's a lot simpler than the previous question and since we've gone in this order it should be easier for you to get the solution so looking at our solution the question tells us the array will definitely have at least three items so we don't need to do an edge case check for that we just need to initialize our return variable and this return variable will be the maximum mountain range that we found while iterating over our array so so we start with the main loop from index one the second item in our array the reason being is that the item in the loop the eye that we're looking for is the peak and for the same reason we can skip iterating over the last item because the first and the last items cannot be Peaks then we have this simple conditional check which checks if we are at the peak by seeing if the numbers in the array on either side of our current index are smaller than the current number then we can send out two pointers like a search party we do this for the left side making sure we don't go out of bounds beyond the zero index and afterwards we do the same for the right side making sure we don't go beyond the end of our array so for example if we were at this number seven which is the peak that gives us our solution of five the length of our mountain range of five as we can see in the original question so while left is greater than or equal to zero and current number that left is pointing to is greater than the next number move L down once more so four is greater than zero so we can move the left pointer down one more position in our array the same is not true when comparing the zeroth and the first index so we stopped there we repeat this for the right side of our mountain and we find that the right pointer ends at two or the 0 1 2 3 4 fifth index at that point we check if the max of the current return variable which remember keeps hold of our maximum mountain range that we found while iterating over our array so in our solution we would have moved the green pointer which is indicating our main for Loop we would have continuously moved this along and found no Peaks until the seven so at this point our return very variable is still zero and we compare that against this calculation here we do right minus left which gives us the numbers of steps it takes to go from the current item the left pointer is pointing to in our array to the right pointer and of course we plus one to that to get the actual number of items in this range so the right pointer is at index 5 the left pointer is at index 1 5 - 1 + 1 gives us 5 that's greater than the current return variable of zero so our return variable is now five we would then continue our original for Loop evaluating the next number to see if it's as a peak until we have evaluated all numbers in the array break from our Loop and return the answer and for this question there will be no more Peaks now let's break down the time complexity overall on average it is O of n but the absolute worst case is O of n^ 2 our topmost for Loop is O of n a single linear pass through all the elements in the array and if there are multiple Peaks evenly distributed throughout the array each in a loop operation both left and right could theoretically cover a significant portion of the array for example an array pattern like this where nearly every second element is a peak requires the inner Loops to be executed continuously to scan the mountain range each time and of course it is all of one space because we are only keeping track of our return variable and the two pointers a quick note is that there is a slightly more optimized solution although it does share the same time complexity where instead of a for Loop we can use a while loop which allows us to update our current iteration value this I or the green arrow that we Ed to indicate it what we can do is move the value of this to the end of the mountain range we just evaluated this will save us a few extra operations of unnecessarily checking the next values after a peak we just found so I leave this up to you to give it a go otherwise I'll include the solution in the material so nice and simple that's our longest mountain question Okay so we've made it to the third and final section of our arrays where we will be looking at the sliding window pattern and the concept of a sliding window is super straightforward we use a typically fixed section or window to Traverse over our iterable object like an array or a link list for example p a window of three items and we perform some calculation at each step the window can be dynamic in size but this will typically be for medium to harder questions so the first question is contains nearby duplicate and this is the second part that builds on the first version of this question we answered earlier and what's cool is I decided to check out my previous submissions and I see I completed this question on Christmas day really goes to show how much I put into this and the evidence is all there that if you really do practice and put the time in then then this stuff will become easy and smashing the interview will be a piece of cake believe me anyway this is a fairly straightforward question especially given you know we are looking at sliding Windows if you're unfamiliar with the concept of a sliding window then feel free to stick with me for the solution and maybe give the others in this section ago on the left you'll see I included the raw working out when I first attempted this question and the question asks us given an integer array nums and an integer K return true if there are two distinct indices I and J in the array such that num's ey I equal numers J and the absolute difference between the two is less than or equal to K so we know the difference between these two values must be less than or equal to K and K gives us the max size of our sliding window and in my notes this gave me a solution using a set but we can also use a dictionary so I've included the dictionary implementation below and as always have a look at both to extend the scope of your problem solving methods let's stick with the set solution for now and have a look at it in the Whiteboard the first thing we do is create our scene set to keep track of the items currently in our sliding window of size K so this is the first example question and let's create our scene set next we iterate over our enumerated list using a for Loop and at each iteration we check if the current number num is already in our scene set if the number is in our scene set it indicates that there is a duplicate within the range K indices because the set scene only contains elements within the last K indices and we make sure of this in a second down here so for the index0 and the number I let's add that to our code I equal 0 and the number will be one we check our set number one is not in there so we can just add it to our set then we have a check to maintain our sliding window the length of set is not greater than K so we're not going to execute this now so in the next loop I equal 1 and the number equals 2 two is not in scene so we can add it to our set the length of our set is 2 which is not greater than K one more iteration and we're at index 2 with a number three three is again not in our set so we can add it in there our scene set length is now three which is still not greater than K one more iteration we have an i of three and a number one at this point the number one is in scene so we found a duplicate within the range K we can return true and there's our solution however if we had another number in here let's say four so the third index would have given us number four no duplicate is found and we need to maintain our sliding window length at three so we would have added four in this line seene to add num which is four the length of scene is now four which is greater than K so to maintain our siding window we just remove the last item or the oldest item from our scene set which is nums I minus k i is 3 minus a k of 3 gives us zero so the number in the nums array at index0 is number one so seene do to remove 0 will check our set for the number zero and remove it and that's how we maintain a sliding window of fixed length three using a set without relying on the order so nice and Simple Solution as for the complexities the lookups for a set is constant o of one and there will be a reference chart in the material somewhere for common operation time complexities which you can have a look at adding and removing to a set are also constant except we have one linear iteration going through all the numbers in the array once and of course this gives us a linear time complexity as for the space the space complexity is O of K and the reason is that we store a single set which is at most size K and this is our sliding window and so that's it for the the contains duplicate question part two nice and easy minimum absolute difference and let's get straight into the question here given an array of distinct integers are find all pairs of elements with the minimum absolute difference of any two elements return a list of pairs in ascending order with respect to pairs each pair a b follows A and B are from the array a is less than B and B minus a is equal to the minimum absolute difference of any two elements in our array so essentially we need to return all the unique pairs of numbers with the smallest possible difference in the list in ascending order now you could absolutely Brute Force this with nested loops and get a solution but no surprise we're going to use a faster solution with a sliding window so pause now if you want to give it a go so our solution is super clean we have three parts we sort the array and this will allow us to evaluate the array in a sliding window which is two elements large in order to find the pairs in part two we find the minimum absolute difference in one linear iteration and then in part three we have our sliding window iterate across the array and if the difference equals our minimum difference we add it to the answer list and naturally this will give us the answer in ascending order as the question asks because we sorted the array earlier my original solution had one Loop it still had similar operations but at each point we would check if the new minimum pair difference in the sliding window for the current pair was less than a pair we previously evaluated by checking the minimum difference and updating it if the new difference was smaller and while while it had the same time complexity it was very messy so it's good to see how you can go back and make your code more readable and this applies of course to real world code if you can extract some of the responsibilities of a section of code and modularize it this will help with debugging readability and maintainability so I've left my original solution for you to have a comparison on how we can extract responsibilities and make our code cleaner and looking at the two will be a good exercise so here's the example from the first question and what we're going to do is sort our array in place using the same array so here's our new sorted array and we're going to set the minimum difference initially to be positive infinity and this is of course because if we set any real number which is below 10 ^ 6 we have the potential to break our solution so 4 I in range one to the length of our array so we begin at the second position in our array and to find the minimum difference at each point we compare the current minimum difference to the difference between the current pointer so the current a position in our array and the previous number in the array so at this point the difference is one at this point the difference is one and at this point the difference is also one and in step three we collect all the pairs with the minimum difference and we put them into this result array which we will return at the end so we have a new for Loop and in a similar fashion we check if the current minimum difference starting from the second element is equal to our minimum difference for this question each pair will give us a minimum difference equal to one so we would append one and two to our list and then we would move along append two and three and move along and a pen three and four in that order the time complexity is of course n log n the sort function being the bottleneck and space is all of n worst case based on Python's built-in sort algorithm which you can feel free to check out why and there should be a reference to it in the material but we are also storing the pairs of the answers in a list and if every pair is an answer like in this example then our result array will be n length and so there's our minimum pair different solution finally our last sliding window and our last arrays question a medium question where we are given an array of positive integers nums and a positive integer Target we are asked to return the minimal length of a subarray whose sum is greater than or equal to the Target and if there is no such subray then we return zero and if you want to give it a go pause now or I can give you a hint and tell you that our solution will Implement a sliding window using two pointers another example of how medium questions merge two concepts or two easy questions together so let's take a look at the solution and you can see we don't have that many lines of code so it really does come to just understanding a few Core Concepts like we saw in the graphs question we start off by initializing some variables we set our minimum length to positive Infinity the reason being is that later we will compare if there is a new minimum value against this current Min length value setting the minimum value to anything above the constraint of 10 ^ 9 would have worked just fine but we can initialize our value to positive Infinity to be safe we also initialize a left pointer at zero and the total or the current sum which is the sum total of the values in the current sliding window so there's our left pointer there's our total and let's add our minimum value so we've initialized this left pointer at index zero we then begin a for Loop where the loop index represents our right pointer so let's add that in our right pointer begins at zero and we continue to increase our right pointer to expand the window until we meet our Target condition and that is this WOW Loop so on the first iteration of our W Loop the total value will be two the total is not greater than or equal to our Target yet so we move right up again we add three the total will be five we do this again the total will be six and we do this once more and our total becomes eight at this point we enter into our W Loop because the total 8 is greater than the target 7 and we update the variable which we will return indicating our minimum size subay right so comparing the minimum of infinity against r - L + 1 which gives us the number of items in our minimum subury our right pointer is at the Third index our left pointer is at index 0 so 3 - 0 + 1 gives us four items in our minimum subarray so let's update our return variable to be the number four at this point we begin moving the left pointer up so we begin decreasing our sliding window and the reason being is that we might be able to find a smaller subarray which hits the target value by moving our left pointer along so we move it to the second item in our list and we find that the total is now six so our total has now dropped below our Target and we can continue moving our our right pointer along at this point we have a total of 10 except the minimum subarray is the same as the current minimum subarray so we don't need to update it and we can move our left pointer up and you can see now that a big jump for example from 2 to 4 gives us more room on the left Point as side to decrease the minimum size subarray which is exactly what's just happened because we have a total value now of seven with three items in our subarray and we would continue to repeat this process until we came towards the end of our array and we found a minimum subarray of size two and so we break out of our for Loop and we check at this point if there was any minimum size subarray that sums to the Target or greater than the target so we check if it's positive Infinity in this case we would not have updated our return variable we return zero as the question tells us otherwise we return the minimum size subay and one thing to point out here is that it may look like a typical two-pointer solution but the sliding window concept comes from how the two pointers slide across the array and maintain the window of elements that meet certain conditions as long as the sum of elements within the window is less than the target we continue moving that window along making it shorter or smaller and so this process continues effectively sliding the window over the array to maintain the minimum size subarray that satisfies the condition and there are no hard boundaries on what makes something sliding window or two pointers these are just abstract problem solving patterns that are meant to help you think about a solution and that's why a lot of the solutions in this problem will call it a sliding window and as for the time complexity of this solution it's O of n you might think it's quadratic due to the nested Loops but this is not the case as you've seen in the previous two pointer questions the left and right pointers are traversing the array in one pass and they are independent of each other increasing the input size will not disproportionately affect our operations the left and right pointer will proportionately increase their operations this W Loop will not quadratically increase our operations instead as we've seen before moving the left pointer up is not a compounding effect so our solution would be o of 2 n 2 * n because the left and right pointers are each iterating over our array in one pass independently and our 2 * n solution boils down to O of n as for the space it's of course constant because we're only keeping track of a few variables unaffected by the input size this question also offers a follow-up asking us to get the solution in N log n which is a worst time complexity but it's definitely a useful exercise and the technique is based on prefixed sums and binary search in my opinion this is overkill right now and definitely wouldn't be judged in interview if you don't know the techniques I just mentioned but it's definitely interesting to see how it works and if you can understand it you know you're doing well so that's it for our minimum size subarray some question and the array section in our leak code next up we have a section on bit manipulation and while this may seem like a low-level Computing concept maybe irrelevant to you if you're going for a software role or web development this was actually one of the questions I faced in my software interview so let's understand bit manipulation before looking at the question if you have the material you will have looked at the essential core computer science and programming Concepts provided which includes detailed walkthroughs on bits and lower level mechanisms otherwise a quick reminder without getting into the entire concept space bit short for binary digit the most basic unit of information in Computing a one or a zero and an operator is some symbol or keyword that instructs some mathematical computation or actions for example x + y = z where X and Y are the operands the plus and the equals our operators and of course we have our result Zed we can also have different types of operators the plus is an arithmetic operator and if we were programming and we wanted to assign the value of x + y to Z then the equal sign would be an assignment operator a bitwise operator is simply another type of operator where the defining characteristic is that it performs actions on the bit level and here is a list of bitwise operators the first few somewhat similar to logical operators another type of operator so that should set us up perfectly for the following question where given a non-empty array of integers nums every element appears twice except for one find that single one you must Implement a solution with a linear time complexity and use only constant extra space so I have two slides for this question here and the first one we will be looking at other Solutions you should be an expert by now in knowing that we can always Brute Force our solution except for this type of question it will give us N2 complexity and the question wants us to try achieve this in a linear runtime we could also sort our array and check the neighbor index at each position to check if it is a duplicate of course the Sorting will give us n log n so still not good enough we could also use a hash map very similar to what we did in the two question we would iterate through Ray store the elements and check if we found them again while the iteration continues this gives us a linear time complexity but we're storing our hashmap so that gives us o of n space complexity which is still not good enough and that leaves us with bit manipulation and you'll find bit manipulation is very popular in competitive programming because it's so efficient and specifically we're using the exclusive or bitwise operation giving us linear runtime and constant space this exclusive or operation is the key to solving this problem and let's see why here is an array of numbers from the question's first example and here is their values represented as bits what exclusive or does is it returns a zero if both bits are the same otherwise it returns a one as we saw explained in our table on the right and shown for the bits on the left so we can use this up Arrow to represent our exclusive or so One exclusive or one both bits are the same and that gives us zero pretty simple so far in that case doing the exclusive or on the number one in our array against this number one will also give us zero of course the bits are also identical and that's why we would get zero in that case the same goes for the twos they are also identical and they would also give us an exclusive or value of zero and all together we'll be left with our four the only item in R which does not have a duplicate furthermore this solution also works because we can do it in any order let's see why by taking a look at the specific columns and the single bits per number in our array so if you were to perform exclusive or on the first two values in the array and continue doing this iterating across our array well the first two values 0 and one that gives us one because they are different doing an exclusive or of the one against this zero that would also give us one one against one would give us Zer and 0 against 0 would give us zero so this final value is the same as the first that we had let's check again for the second column 0 against 0 that would give us zero because they are the same doing an exclusive or of this zero against the one that would give us one because they are different the one against the zero in the second column would give us one again and one against the final one would give us zero that's also the same as the second column bit for our single number which does not have a duplicate in our array and finally I'm sure you can guess it but the final column will be the same also 1 against Z would give us one 1 against Z would give us one 1 against 0 1 one exclusive or against zero we have one which is the same as our first bit that we started with so overall we'll be left with the bit value of the only number in our array which does not have a duplicate on a macro scale n exclusive or against zero gives us n all the duplicates in the array will result in zero because they are the same leaving us with the only number without a duplicate which is our n and I don't think we need to go through the code because it's exactly the same as the intuition we simply iterate over the array and we perform the exclusive or operation using the up arrow in place on a single variable changing its value based on current value in our nums array that we are evaluating and you can see on the right here what the values printed out will give us as the bits of the return variable we initialized continue to change along the array finally leaving us with the four our single number which does not have a duplicate so there's one question on bit manipulation very good to get some awareness of what bit manipulation is and how it works a much lower level concept than we've dealt with so far and like I said this was one of the questions I faced in my software engineering interview and in fact I was not afraid to tell the interviewer that I had seen it before I think it's good to be honest and I would suggest you do the same I would be skeptical if someone can come up with this solution never having seen it before and it also shows that you've put in a lot of practice anyway that's it for bit manipulation next up we have a section on dynamic programming a technique used to solve complex Problems by breaking them down into simpler sub problems it works by solving each sub problem only once storing the solution to that sub problem so that when the solution is needed again it can be looked up instead of computing the answer to that sub problem all over again this approach helps save time and computational effort and a quick note that the term memorization refers to the storing of our results from these function calls and sub problems in some data structure so that later we can reuse them so we have a few dynamic programming questions in this section and we're going to start with a medium so hopefully you'll be able to complete the easier questions before going straight to our solution in the coin change problem we are given an array of coins representing coins of different denomination ations and an integer amount representing a total amount of money so here are our coins and the amount we want to reach is 11 return the fewest number of coins that you need to make up that amount if that amount of money cannot be made up by any combination of the coins return minus one you may assume that you have an infinite number of each kind of coin so before diving straight into our dynamic programming solution I'm going to try work our way up to it we could try a greedy algorithm like we've seen before in the best time to buy and sell stock question our greedy algorithm could be to continuously use the biggest coins we can find at each stage while remaining below our Target five is the first biggest coin we can take and remain below our Target so that gives us a current value of five we can't use five or four or three because we'll be above our Target for the next coin so the next biggest we can take is one giving us a value of six and if we repeat that process we can only use the one coin again and that gives us a value of seven which is our Target and we used five once and the coin one twice and overall we used three coins except we know this is not the right answer using the three and the four coin is only two coins and that gives us a target of seven so trying to go for the best choice at each stage by going for the biggest coin will not work we need to evaluate all the solutions and we can do this with depth first search which will lead us nicely into the dynamic programming solution so here's the first example from the question we have a target of 11 so we could use the one or the two or the five coin and seeing as we're going for depth first search we're going to use every coin bear in mind we could also use breadth first search that's that's not the point of this solution at this stage we're simply trying to convey that we're using every coin to find every possible solution so if I was doing depth first search I would use the coin five and that would give me a value of six then maybe I would use five again that would give me a value of one and at this stage I can't use the two or the five cuz that will take me below the Target so I use the one and that gets us to zero and there's one solution let's now look at this in a breath first search and try all the other coins before moving on to the lower levels so if I was to use two and one I would end up with targets 9 and 10 and at the point of this six I could have also used a two and I could have also used a one so this is about to get very messy but bear with me so at this point we have a value left of five at this point we have a value left of four when I first used the two coin I could now use a five I could use a two and I could have used a one at this point I'll be left with four at this point I'll be left with seven and at this point I'll be left with eight a two a five or another one coin giving us N9 five and eight and let's go one more level down before taking a step back one a two or a five so we started at 11 and at each stage we're testing every coin we can possibly use before ending up at zero or going negative and realizing we can't use this combination of coins eventually we will evaluate every combination and find our minimum amount of coins to reach our Target except this is of course Very inefficient we end up with the same sub problem repeated over and over which is leading us to unnecessary repetitions at this point point we have the target eight that we need to evaluate all combination of coins we also had to evaluate the eight Target here after using the one and the two coin the same sub problem reappears when the target four comes up and the same for the nines and the value seven and we see this again and again with the five and the sixes and remember what I first defined dynamic programming as dynamic programming is a computer programming technique where an algorithmic problem is first broken down into sub problems the results are saved and then reused to find a solution efficiently in this such solution we approached the algorithm top down but let's now turn the problem on its head and start from the bottom so what does this mean what we're going to do is start with the smallest Target possible 0 1 2 3 all the way up to 11 and check the minimum number of coins for each Target along the way this will help us avoid repeating the calculations for each sub problem that we see reappearing and that will come to life in the form of this array and what I'm going to do is put the code alongside the intuition because they are identical so this blue arrow is going to represent Where We Are in the code and the first thing we do is create this array up to the length of the target Value Plus one because we have zero indexing the value of each position is the minimum number of coins we need to get to the Target which is our index of the array at this point our Target is zero at this point our Target is one all the way up to our Target of 11 which is the answer we are looking for and eventually each box is going to contain the minimum number of coins we need to reach the current Target which is the index and for all of the sub problems we prefill the value with some arbitrarily large value like we have done before with the Positive Infinity but in this case we can simply add one to the Target and you'll see why this works in a second and then in the next line we can set the index of zero to have a value of zero because of course we need zero coins to reach the target of zero and the question tells us this in example three then we begin the bulk of our work with a full loop across the array starting from the second position up to our Target inside we iterate across our coins so let's track this with our Green Arrow and inside our for loop we're going to have a nested for Loop to iterate over our coins the reason being is that we have to check every solution to find the minimum number of coins there is no getting around this then we have a simple check to skip evaluating the current coin if using that coin takes us below the current sub problem Target that's just common sense and finally here is the important part we set the minimum number of coins that's what the value inside the array represents to be the minimum of the current number of coins versus 1 plus DP IUS C let's break down the minimum comparison second value 1 plus DP IUS c one is the current coin we are evaluating and we are adding to that the value of the DPI minus c Index I is the current sub problem Target and C is the current coin's value so what we are doing is checking if we are using the current coin to reduce our Target I we will then get some new value some new sub problem Target for example in the top down problem we use the value five and then we have a new subpro Target of six and at that point we check what is the best possible solution which we would have already evaluated ated previously in ourr because we are going Bottom up so this will definitely make more sense as we work through the solution so for cing coins we are looking at coin number one for the index I of one so let's keep track of that also index of one and the current coin is one which is this red arrow 1 - 1 is greater than or equal to Zer so we can use it to get to our Target at that point we compare what is the current minimum value well we pre-filled it to 12 and this is why I said earlier that adding one to the Target will work just fine cuz we're comparing 12 against 1 plus DP i - c 1 - 1 DP of 0 well that's zero cuz we need zero coins to get to zero which will indicate that we've reached our Target so 1+ 0 the minimum between 12 and 1 gives us 1 next we iterate to the next coin which is 2 1 - 2 is less than Zer so we can't make this comparison and the same goes for five so we go back to the top of our first for Loop and go to the next sub problem at this point I equal 2 and we go back to eval ating the first coin 2 - 1 is greater than Z and we have a new comparison to make so we're using our first coin which is 1 so we're adding one to the combination of coins to get to our sub problem Target of two and I - c well 2 - 1 gives us 1 so using our coin one to get to the Target of two leaves us with a sub Target of 1 I 2 - 1 C leaves us with a target of one so we've already solved the minimum number of coins we need to reach our Target of one so we're looking back and we're using that value we know that it's one coin so using one plus the value which we previously calculated 1 + 1 gives us 2 2 is less than 12 so we have a new minimum value great at this point we go back to the top of our second for Loop and check out the next coin 2 - 2 is indeed equal to zero so we can go to our minimum check we are now comparing two which is the current minimum value against our DP of i - c 2 - 2 gives us zero and so we have a value of one and a new minimum value of coin to reach our sub Target of two and we can't evaluate five because that will give us a value below zero so I've filled in some of the values and now let's look at a bigger sub problem to make this more interesting we start off with coin 1 that gives us a value of i- C which is 6 7 - 1 that's okay so let's do a comparison of the current minimum number which is 12 against our DP of i - c which is 7 - 1 or 6 1 plus the DP of 6 which we calculated earlier to be 2 1 + 2 gives us three and we have a new minimum value and we knew at six the minimum coins were two because we calculated that earlier in the same way and we figured out that the five and the one coin were the minimum number of coins we could use we then iterate over to the two coin 7 - 2 is 5 and we have a new comparison of 1 plus our DP of 7 - 2 which is 5 and at five we figured out we only need one coin which is the five coin 1 + 1 is 2 and we're in fact comparing this against the value we just calculated which is three so we we have a new minimum value let's iterate across again so we're now looking at the five coin 7 - 5 gives us 2 and we have a new comparison 1 plus DP of 7 - 5 which gives us 2 so we're using the five coin once and the number of coins we needed to get to the sub problem Target of two earlier we figured out that was one and we went through this we only need the two coin and we're doing this comparison against the current minimum value which is two so we don't need to update this we've gone through all the coins and we repeat this process for the sub problem of eight through the same method we'll get the minimum number of coins we need to get 8 9 and 10 and eventually we reach 11 which is our Target for the first coin 11 - 1 is greater than zero so let's make our new comparison 1 plus a DP of 10 at 10 we figured out we need two coins which is the five and the five so at 10 we used the five coin we looked at the five sub problem and at this point we only needed one coin which was also the five to take us to zero so at 10 we only need two coins plus the one coin we're looking at now and that gives us a minimum number of three coins and a new minimum number of coins for our Target 11 which is three we then iterate across to the next coin which is 2 11 - 2 gives us 9 and we have a new comparison 1 plus a DP of 9 which is 3 1 + 3 would give us 4 which is not greater than the current value so then we can iterate across to the five our last value that we need to calculate 11 - 5 that gives us 6 and we have a new comparison 1 plus the DP of six well at six we calculated we only need two coins 1+ 2 gives us three and we don't need to update our value of three and we come to our solution which is the minimum number of coins we need to get to 113 finally if the number of coins at our Target is not equal to the Target + one which is what we initialized all the values to be at 12 then we can return the minimum number of coins otherwise there is no solution and we can return minus one like the question asks us to our time complexity is n * C we have one iteration going across all the values in our array and at each point we're iterating across all the coins these are our two nested Loops giving us a Time complexity of o n * C similar to n s but not quite the same still quadratic time though and of course we have a space of n which is our array of all the values up to our Target 11 and that's coin change the first question in our dynamic programming section next we have the climbing stairs problem pause and give it a go now that you've seen the concept and coded implementation of the dynamic programming approach you are climbing a staircase it takes 10 steps to reach the top each time you can either climb one or two steps in how many distinct ways can you climb to the top so if we had a length of two steps we can either get there by taking two steps or one step twice and for three steps we can either take three single steps we can take one step and then two steps in one go or we can take two steps in one go and then one step and here is our visualization of the problem for four steps in our staircase and I'm going to show you the code above similar to the previous question we create an array and we're naming it dynamic programming DP we set the index of 0o to be Z because it takes zero steps to reach a position of zero and to reach our first step we can only take one step so the value for our Target of one is going to be one one step now for our Target of two we're evaluating all the ways we can reach that second staircase now remember we can either take two steps in one go and that's one way to reach our second step or we can take one step twice so that's another way 1 + 1 gives us two different ways to reach our position of two and these three targets are always going to be the same no matter what our staircase length is positions 0 1 and two are always going to have 0 1 and two unique Solutions now the important part is we create our for Loop starting at the third index and the way we calculate the number of unique steps at index 3 which is our current I is by taking the solution to the previous sub problem plus the one two positions before it why is that well any number inside the four Loop we can either reach it with one or two steps so we can either jump from one straight to three or we can reach three by taking one step from two that's the only way to reach any staircase now you might be wondering well we could go from 1 to two to three except this step here has already been factored in when we calculated the sub problem of the staircase 2 we can just get the Second Step from taking one step from two so to calculate our solution for three we simply take the sum of the last two values that gives us the total number of unit Solutions which is three on the next iteration we simply do the same thing 2 + 3 is the number of unique Solutions we can get to reach four that's either one step from three or two steps from two all the other steps have already been factored in and that's the whole concept of dynamic programming we're calculating all of the sub problems and reusing the solution so 2 + 3 gives us a solution of five and we would simply keep doing this for all of the values up until our Target no matter what the value is and finally at the end we return the value five so a super simple solution to to a nice problem as for the time complexity we have o of n since we have this for Loop and the space complexity is O of n because we're storing this DP list here alternatively we could have a constants based solution because if you've noticed we only need to keep track of the two variables inside our Orange Box to be able to calculate the value of the next step in our staircase so for example we could start off with these two variables to calculate our value for three make the first variable the value of the second variable and make the second value the sum of the two variables before changing the first variable to get to our value of four just repeat the same process and get our new value of five and we would simply repeat this until we reach our Target and so that's it for climbing stairs our second medium question inside dynamic programming is Max subay we are told given an integer array nums find the subarray with the largest sum and return its sum and they give us a definition of what the subarray means essentially just a continuous set of numbers inside our array which is nonempty and this is immediate medum question but given what we've gone through so far it's not that difficult so definitely give this one a go if you can otherwise let's look at the solution so this one here we can definitely solve with brute force and initially I was drawn to some kind of sliding window solution and given what I've said before these are just problem solving techniques so they can blend together but given the way this works out I put it in the dynamic programming section and the reason is at each stage we're solving a sub problem specifically at each point of the array we're solving what is the largest sum and this simply comes down to looking at the max of the current value versus the max of the previous value inside our DP list and the previous value will of course be the solution to the same problem so ignore this second solution for now and let's look at our classic solution where we create our DP list for the zeroth index we only have the value minus 2 so that is the largest sum subarray we can find when we move across to the next index the largest sum is going to be the current value or the current value plus the sum of the previous subarray at this point 1 is greater than 1 plus -2 and then we move along and in blue you can see we've made some changes when we're evaluating minus 3 the largest value is either -3 or -3 plus the previous index -3 + 1 gives us -2 so we've taken into account a previous subarray and at this point our largest subray is this one value here moving on to four of course four is going to be larger than minus 2 and there's no need to include the previous subray value so we have a new Max subarray which gives us a value of four on the left here you can see adding minus one will decrease the the value except at that position in our array minus one is better off including the previous four four is still our Max subarray except we update this value in case at the next point in our index we would be better off by including the four and that can only be done by updating the next index which is the minus one and including that four to make it three and this is exactly what happens when we're evaluating this two the max value we can get is either two or we can include the three the previous index so 2 + 3 gives us five and a new Max subarray sum and we get that by including the four unfortunately the minus one but this helps us because we can now include the two and get a value of five which is greater than four and we continue this way until we find our max value which is six and we return that six of course this is of end time because we are doing a for Loop and iterating over each item in our array and if you looked at the previous climbing stairs question you'll see that in these dynamic programming questions it's not always necessary for us to keep this list and have o of n space on the right is the solution where we only keep track of two variables our Max sum and the current sum so instead of keeping track of the max sum at each point in our list we're just doing a similar maximum comparison and then storing that Max sum in a single variable giving us constant space so feel free to go through this constant space solution line by line but it's pretty intuitive so I'll leave it there for the max subay question so back to the lower level hardcore computer science foundations counting bits and let's get straight to it if you haven't yet familiarized yourself with bits let's take a closer look than the previous bit manipulation question in front of you is a table comparing the numbers in our base 10 system versus the bit system on the left each column represents a value which is derived from 2 to the power of some number which is a singled digigit linear increase so 2 ^ 0 which is 1 2 ^ 1 = 2 2^ 2 is 4 2^ 3 is 8 and so on for the number zero we have zero bits simple for the number one we have a single bit in the First Column the 2 to the^ 0 column giving us a total value of one for the number two we need a single bit in the 2 to the^ 1 column giving us a value of two so we have shifted columns now and for the number three we need a bit in the 2 to ^ 1 column and in the 2 to ^ 0 column giving us 2 + 1 which is equal to 3 and last one let's look at four where we shift columns again because we need a bit in the 2 to the^ two column giving us a value of four now if we take a step back the value of two in bits looks like 10 to us and the value of four looks like the number 100 to us well this is because bits use a base 2 number system and we use a base 10 system so for us each column would be 10 to the power of some value so this would be 10 ^ 0 this would be 10 ^ 1 this would be 10 ^ 2 and so on this would give us 1 in the First Column 10 in the second column and 100 in the third column so if you wanted the number two well we can't move to the next column because this has a value of 10 so we would need a two in the First Column and we are allowed to use the number two or 3 4 5 6 7 8 or 9 because these 10 digits are part of the system it is a base 10 system so the number 615 for example would have a 6 in the hundred's column A 1 in the 10's column and a five in the ones column so that should give us a solid understanding of bits and the base 2 system let's now look at the question here we have the numbers 0 to 8 with their bit representations or in other words the base 10 value on the left and the base 2 value on the right on the left let's highlight the significant bit values these were the values of each of the columns in our base 2 system so for each one of these numbers they are the value of 2 to the power of some X so for the first one X is to the^ 0 x is to the^ 1 x the^ 2 gives us 4 and x ^ 3 gives us 8 this will come in handy later for the first four numbers let's quickly drop down the number of ones inside the bit value this is what the question wants us to find so here we have zero ones here we have one and here we we have one and you'll notice the columns begin to shift at each significant bit for example at one we had a one in the First Column at two the column shifted again and we had a one in the second column at four the column shifted again and at eight the column shifted to add a one in this fourth column here similar to what we saw in the table above if we look a little bit closer every time the column shifts the previous bit values repeat so when the column shifted for the four the first two bits look like a repeat of the zero for the five we still have the the extra one in the third column but this zero and one looks like a repeat of the number one for the six we still have one extra bit in the third column except the first two bits look like a repeat of the number two and the same goes for seven and it looks like when we reach eight this is similar to the four which was similar to the zero and this is the same in the base 10 system when we go from 10 to 11 to 12 to 13 this is just the same as 0 1 2 3 except now we have an extra one in the 10's column so the value of whiteboarding wins again we are beginning to notice a repeating pattern so the pattern we're beginning to notice here is that every time we reach a number which is equal to 2 to the power of some digit we have an extra bit value in a new column for example the one in the third column for 4 to 7 or the one in the fourth column for eight and we plus to that the number of ones in a previous value so for example for8 we had one in the extra column plus the value of ones in zero for the number seven it's this extra one in the third column plus the value of ones in the three for six it was one in the extra column plus the value of ones in the two so we're beginning to notice a pattern let's check number four for example we said this was one in an extra column plus the value of ones in the number zero so pretty similar to our eight example and we can connect these because they are power of twos so things are beginning to add up here the numbers two and three we have a one in the extra column and the bits in The First Column repeat so we have this extra one this extra one and we have zero and one zero and and one and we can also do the same for the number one it's simply one extra value in the very first column and we can check this by looking at our table again here we go for the number one we have one in the very first column and the same number of ones as the number zero for the number two we have a one in the second column and the same number of ones as the number zero so we've noticed some connection on the shifting columns which is connected to the most significant bit which is our 2 to the power of some number and we know exactly why if we wanted to reach the number six from the number two for example we would simply add a one in a third column to increase the value by four or the 2 to the^ two column so when we look back we are offsetting only by the current most significant bit which for the number six is four and in the base 10 system for example if we wanted to go from five to 15 we would just add a one in the 10's column it's the same concept great that's step one the next step is to generalize our solution and if I change the wording of our solution to be more programmatic let's say we had this value of ones ins some previous number by checking a list we create and if I call this list DP then this value of ones and three can become the DP of three and this value of ones in two can become the DP of two and let's quickly change the rest to follow this pattern okay so we're getting closer but we're not quite there yet we need to generalize even further to get to our programming solution and one thing I've noticed by looking at the four is that this previous lookup value is increasing digit by digit linearly 0 1 2 3 until we go back to 8 which is zero at the power of two value we have zero we're looking up the bits in the zero number so we can change these values to be I representing the current index that we are on minus the most significant bit and you'll see right now how this works so we can take I to be the current index that we're on which is the value four and we minus from it the most significant bit so in this case we're minusing four to get to our zero again 5 - 4 gives us the number of bits in the number one which which is exactly what we're looking for and then we're adding to that one which is the extra column that we have for the number five so let's quickly change all of these to match this new pattern great so we are a lot closer to our final solution everything is looking a lot more generalized now and we've gone through the intuition to understand why except there's one more thing if we are writing our code we don't know what the offset is we're not looking at this table so we have this offset which is necessary to tell us which sub problem to check for our solution to the current number we just said this offset is always 2 to the power of some number X well this x is also going to increase in a single digit linear fashion from 0 to 1 to 2 to three and so there's our generalization and if we look at the code this will make a lot more sense here is the code and we're creating this DP array like we've done so far in our previous dynamic programming questions we give it a length of n + 1 to account for the zero number and then we begin with our offset of one which is the first of our 2 to ^ x and then we begin our for Loop skipping the zero because we know that that has Z 1es inside and Let's ignore this if check for a second DP of I which is the current number we're on in our for Loop DP of 1 = 1 plus the DP of 1 - 1 exactly what we had on our whiteboard that gives us a value of 1 now on the next Loop we have to check if the offset * 2 is equal to our current I and this works perfectly because whenever this is true we will have hit a new 2 to the power of some X so on our next Loop we check if the offset which is 1 * 2 is equal to our current I our index is two and this will be our most significant bit and the offset we are looking for and the same will be true for the index value of four and so on so we iterate across our array updating offset and looking backwards for the previous values we solved at each stage before finally returning our array list as asked completing our bottomup Dynamic approach to the counting bits question and of course I'm sure you're becoming experts at this now the runtime is O of n we have one single iteration across our array and some operations which will grow linearly as the input grows and a space of n due to our DP list so that's it for counting bits our last dynamic programming question range some query immutable and this is a different type of question than we've seen so far in terms of input because we have a class with two functions to write we are given an array of numbers and we want to handle some queries which is just asking for a sum between two indices in our array for example the sum from index 0 to three so my first solution here here on the right is of course a very simple way to approach the question simply initialize the list as asked with no modifications in the first init function and use every left and right pointer on the go to calculate the sum as asked this would be over n every time it's run however we can improve this as you can see in my notes two algorithms can have the same complexity but different run times so if we were to improve this we could instead calculate the prefix sums and by prefix we just mean any subarray starting from index zero so we could create an array in O of n Time by calculating the prefixed sums so when given a query our left and right indices we would simply take the right index value away from the left index value except we would go one left index value along let's create our prefix sums array and look at an example so here is our array and you can see at every position we have taken the sum up until that position -2 + 0 gives us -2 + 3 gives us 1 plus - 5 gives us - 4 and so on and when the question passes in this array of two numbers are left and right pointers for example let's take 2 and five so the sum from 2 to 5 is min-1 and if you were to do that by looking at our sums we would simply take the value at the fifth index which represents the sum from index zero all the way up until the fifth index and we would remove the prefix sum that we are not interested in since we are only looking at index 2 to index 5 we can remove these two numbers here and we do this by taking the value at the fifth index minus 3 and minusing from it the sum from from the previous position up until the index we want so if we're looking at 5 to 2 we minus the fifth index value from the first index value minus 3 - -2 gives us -1 but we do have an edge case for example if we wanted to calculate the sum from index 0 to index 2 well we can't look at the next index along from zero so we can fix this in the code we could add an if check for this Edge case or we could take a different approach we could just initialize the array with one extra value in the zero index and so we no longer need to check the next index along from the left pointer but the next index from the right pointer so instead our prefix sums array would look like this and for the same example we would take the next index along from the right pointer and minus from it the left pointer that we are given minus 3 minus -2 gives us min-1 and carrying out this modification in the initialization of our class is O of n of course because we are iterating over each number in the array and creating our sum however this is an improvement on the last solution because we only carry out this o n operation one time after that every query is constant we are just looking up two values and performing a quick operation and you can definitely see a big time Improvement between these two solutions and this might look quite different from the previous dynamic programming questions we've seen so far however a lot of the solutions will tag this as dynamic programming because in a sense we are looking back and reusing values from a previous sub problem or calculation that we had and so that's it for our range sum query question and dynamic programming section next up we have back track tracking questions backtracking is an algorithmic technique where we try to solve a problem by building a solution incrementally finding different paths and if one does not work we backtrack and try another path until we find the right one that satisfies our problem constraints think of problems like Sudoku we can keep trying different numbers in the positions and if we reach a dead end we backtrack change the first number and try again and backtracking is one of the more difficult leak code question sections all the problems here are medium a lot less likely you'll get one of these in an interview but still possible if you working fast or have an interview soon of all the sections I'd recommend covering this last or skipping this entirely however if you are just starting out this will definitely improve your programming skills and there are two Core Concepts in this section permutations and combinations both refer to selecting items from some set of data permutation is referring to the ordering or arranging the data in a different type of way and combinations is referring to the different selections of data from that data set and as you can see from the table the order of the items in permutations is important but not for combinations so the first question is letter case permutation where we are given a string s and we can transform the casing of every letter individually to create another string and we are told to return a list of all possible strings we could create and return the output in any order of course the order within each string matters so in the first example we are keeping the order exactly the same throughout and every time we have an alphabetical letter we are creating two new permutations of the lower and uppercase versions of these letters we have two possible ways of attacking this question we can take the iterative approach and build out a solution incrementally or we can do the similar thing in a recursive fashion let's first walk through the iterative approach and we can go straight to our code because there is no deep intuition behind this it's pretty brute force and that's why it's 2 to the power n a very slow time complexity essentially what we're doing is iterating through the string that we're given checking if it's a letter if it is Crea two new permutations just like in the example and if it's a number then we add it to the existing permutations hence why we have one less append and we add these permutations to a temporary variable before adding them to our output and here is the exact same code but I've added some print lines so that we can walk through it if I run the code on the string from the example you'll see the very first C or character that we iterate across is the a it is an alphabetical letter so we hit this for Loop contained within these two dash lines we add to our temporary variable the upper and the lower case verions of this character and at the end we update our output to equal this temporary variable pretty simple so far so next we iterate over to the one this one character is not alphabetical so we hit the else block contained within these two dash lines here at this point we have two permutations in our output which is what this o is representing we add to each output the smaller and the uppercase a our number one then we update our output to equal this temporary variable ending up with A1 lowercase and A1 uppercase next we hit our character B it is alphabetical so we go to this for Loop and for each current permutation or o in our output we append the upper and lowercase versions of this B character except at this point we have two permutations in our output the uppercase and lowercase versions of a with the number one so first of all we Loop over the lowercase a and the one and we add to that the lower case b and the uppercase B then we go to the second iteration of this Loop we find the second permutation which is currently in our output the uppercase A1 and add to it the lower case b and the upper case b so now we have four permutations in our temp variable and we update our output to equal this and finally we hit the two there is no uppercase and lowercase for the numbers so we simply add it on to every permutation before we get all existing permutations after finishing our iteration of all the characters in this string and we can return our output so logically very simple but in terms of the efficiency of this algorithm pretty complex 2 ^ n the reason it's 2 ^ n is because we have a string of length n and each character can be represented in two different ways upper or lower case so mathematically the total number of different permutations is the product choices of each character 2 * 2 * 2 * 2 maybe we'll get some number Time 1 but that will have no effect and ultimately this simplifies down to 2 ^ n and our space complexity is also 2 ^ n due to the need to store all the permutations in the list output which could be 2 ^ n permutations and as for the recursive solution I won to go into this one too much because it has a worse space complexity however however here's the code and I've added in this print statement and you can see that for example when we take the first letter A we're calling this backtrack immediately that's the first thing that happens in our letter case permutations function and initially our subarray is empty as you can see in the first print statement and if our subarray permutation is equal to the length of our string then we know we can append this to our results and return for the current backtrack however for the most part we'll check if it's an alphabetical string similar to the previous solution and call backtrack if it is on the reverse upper or lower case then the character currently is and increase our iteration by one otherwise we would just call backtrack on the number itself otherwise if it was an alphabetical letter we would just call Backtrack on the original upper or lowercase character and you can see for the very first character a we first call the uppercase backtrack and we keep going down and down the cool stack until we finished our permutations only then is this second backtrack cooled on the lowercase original a and you can see by the first iteration I and at that point we would go down the cool stack and fill in our permutations this has a similar time complexity due to the different possible permutations based on the upper and lowercase characters but a space complexity of n + 2 ^ n in total our recursive cool stack has a over ofn space complexity and the space needed to store all the permutations is 2 to the^ n again and of the two the first solution is a lot neater and definitely more achievable without looking at the answers and so that's it for our letter case permutations question okay so next up we have this subsets question pretty similar to the previous question except this time we're returning all subsets of an array of numbers we can return our output in any order and note that each subset is unique so two and 1 is the same as 1 and two and the question is slightly easier for us because all numbers are unique so there's a lot going on in this solution so again I'm going to head over to the code instead of the Whiteboard so here's our code and similar to the previous question we initialize a result variable which is our list that we will return at the end and then we begin our recursive backtracking Solution on the very first iteration on an empty list so I've added these print statements in here underneath our very first operation to help us understand what's happening on the very first call of our function backtrack we pass in the empty list and the start number zero and the very first thing we do is append our current path to the result and this syntax here appends a snapshot of the current path creating a shallow copy we use shallow copies in backtracking because they efficiently capture the current state of the path when dealing with simple immutable elements like integers we could have used a deep copy except that would make our solution less efficient deep copies are only needed when dealing with nested or mutable objects creating a shallow copy creates a new list object that contains references to the same elements as the original list and since path typically contains simple immutable elements like integers any changes to path such as adding or popping elements do not affect the elements that have already been appended to the results list if the original path list changed an element the previous reference would remain for the shallow copy and the new reference in memory would be made for the changed element m in the original list this is because integers are immutable and that is why we would use deep copies for mutable objects like nested lists so in a sense appending a shallow copy of path to the results list effectively freezes the state of path appending a snapshot of our path if we were to use the original path object then appending this to our results will lead to the elements inside our results changing when we change the path variable later on and so deep and shallow copies are definitely something I'd recommend taking some time to look into so we've added in the very first subset next We Begin our Loop which will have some recursive calls inside beginning at the start index of zero and ending at the length of our numbers we then append to the path the very first item in our nums array which would be the number one at the zeroth index this will give us a path containing just the number one and it might help if I print the path here so we can see the path before our recursive backtrack is one so next we're recursively calling Backtrack on the next iteration along passing in our current path so we go back to the start of our function and our new result is going to include this one plus the empty list we added earlier and then we go back to the start of our for loop from now the index one to again the length of our numbers we now append the next number in our array using the start index which is now one this gives us the number two and our new path is now one and two so we call backtrack again on the next iteration along passing in the New Path of one and two so calling backtrack again will add the New Path to our result giving us the empty list the one and the one and the two two and of course if we do this again we'll end up with 1 2 3 recursion is quite difficult to follow so I've screenshotted our code and headed over to the Whiteboard at the very start we called Backtrack on zero and the empty list which is exactly what we had here and then we had our result which was an empty list then we began a for Loop which is what this purple line is indicating starting off at the index of zero then we added to our path the number one and began a Backtrack on the next index along which was also one and we ended up with the result of the empty list plus the number one so after beginning a new backtrack with the index of one and the path of one we ended up with the result of the empty list and the number one then we began a new for Loop starting at the index of one we added to the path the number two added this new path to our result and began a new for loop at the index of two using the index of two we found the number three in our nums list added this to our path to get 1 2 3 and adding it to our result to get the following then we began a new for Loop using the new index of three a for loop from 3 to 3 will not execute so our code stops here for this recursion we go back on the cool stack to the four Loop that was executing previously at this point the next backtrack along has just finished so we pop off the three from the end of our path and right now we have a path of 1 and two so this is where we've reached so far after that we'll go back to the beginning of our four Loop and two will become three that will also stop our code because we've reached the end of our range so we go back up to the for Loop that was previously being executed at this point we had just called the Backtrack on the next index which was two on the the path one and two so the next line along based on the current path that we have we pop off the last item so right now we just have a path of one then we go back to the top of our for Loop and the next index along which is two following the code we append to our path nums of the index two this will give us three so our new path is one and three and then we begin a new Backtrack on the index of I which is currently 2 + 1 gives us three on the path of 1 and three and this is exactly what we have executing in our code which will append 1 and three to our result and we can continue this way following the code and we'll realize that this solution gives us every possible subset We Begin our main for loop on zero adding one into the first backtrack this will allow us to get 1 1 2 1 2 3 1 3 and then at that point we go all the way back up to the very first for Loop and then iterate from 0 to 1 this then allows us to do the same process but with two so we'll add two in as the result two and three and then go all the way back and iterate to the three and do the same process again exhausting all of our options and this style is very common in our backtracking Solutions as you all see in the next question for example after writing it out now I can see exactly what's going to happen next the backtrack that we just called on the three with the path of 1 and three will not execute its for Loop because the index is three so we'll come back to our code and we'll pop off this three and our path is now one we'll go back to the top of our for Loop and iterate to the next index along which is three this will also stop the execution of our code and we'll go back back to the very first for loop at this point we'll pop off the one our path is now empty and we'll jump back again to the beginning of our for Loop and we'll iterate to the next index along which is one to the empty path we'll append nums of the index one which is two call Backtrack on the index of two and the path which now contains two and we end up appending to our result the number two which is exactly what we have in our code after the one and the three and so that's our solution so with these backtracking questions if we are implementing with the recursion there will typically be some constraint in the question question that we are looking for that limits the depth of our recursion stack stopping the code execution and allowing us to go back up the Coe stack and find all the permutations or combinations that we are looking for and the time complexity for this is n * 2 ^ n n is the number of elements in the input list and each element doubles the number of possible subsets giving us 2 ^ n and the cost of copying the current path to the results list is proportional to the size of the subset so in the worst case we have a full subset size of n the cost operation would take n time so the total time complexity involves all two to the N subsets and for each potentially copying up to n elements giving a worst case of n * 2^ n and the space complexity is also n * 2 ^ n we need to store all 2 ^ n subsets in the absolute worst case each subset can have up to n elements leading to the total storage of 2 ^ n * n and so that that's it for our subsets question now we reach combinations the next type of core Concept in our backtracking section and the question tells us given two integers n and K return all possible combinations of K numbers chosen from the range 1 to n so if they gave us the number four we have a range of 1 2 3 4 and we want all possible combinations with a size of two so 1 2 1 3 1 4 2 3 2 4 and 3 four so the question sounds pretty simple if you'd like to give it a go pause now otherwise let's look at our solution here is our code and you can see again we're following a similar style to the previous questions where we kind of have a function inside of our main function that we're calling after creating our result variable which we will return at the end so let's take the example from the question and start with our n of four and our K of 2 and let's also create our result array this blue arrow is going to indicate where we are in our our code and the first thing we do is call Backtrack on the number one and then empty list this is our backtracking base case and we do this because our range is from one onwards as the question tells us so similar to the previous question we have our start and our path if the length of our path is equal to k then we return only after appending a shallow copy of our path to our results variable and that's because we know we've reached our limit of two items in our path otherwise we begin a for loop from the current start variable to n + 1 this way our Loop will iterate up to an including n cuz the second element in a range is exclusive so I've written this out identically to the previous question so hopefully it will make a lot of sense so here's our current backtrack call the very first one that we make and here is our path which at the moment is empty and we will keep updating this to be the current value of the path our length is not equal to K yet so we hit the for Loop and begin and I'm going to indicate a for loop with this purple line here and I'm going to add the I which at this moment is equal to 1 then we append to our path the I which is one and we call backtrack yet again iterating one value along passing in the start value of two and the path which contains one so we've called backtrack again and we're at the top the length of our path is not yet equal to K so we hit this new for Loop except at this point we begin with a i of two then we append two to our path and we call backtrack once more iterating up one number and passing in the New Path so now things begin to get interesting because the length of our path is indeed equal to K so we can append a shallow copy of our path to the result variable 1 and two and after that we return so the code can stop executing here this takes us back to our backtrack call and we go to the next line popping off the two from our path after that we head back to the top of our for Loop and iterate to the next value along which is three appending this three to the path gives us one and three and we call backtrack again on the next iteration along so we pass in a value of four 4 and the path 1 and three at the start of our new backtrack call the length of the path will be equal to K so we also append this to our results list and you can already see that this backtracking gives us the same solution as the answer in the question indicating that we're likely on the right path so after appending we return and the code execution for this backtrack stops here leading us back up the cool stack where we can now pop the last item in our path we go back up our for Loop and iterate to the next value along which is four and now we can P the value of four to our path which contains one then we call backtrack once more and you can also see why it was important to add the plus one to our n at the end of our range otherwise we wouldn't have looped over to this four and we wouldn't have included the four in the path passing it down to our backtrack down here and eventually appending it to our results at this point the backtrack will return the code execution stops here back up our cool stack we go to the next line and pop off the four from our PA at this point the four Loop has finished cuz we've reached an i of five and at that point our backtrack function has finished so the code execution stops here back up the cool stack we were at this point and we can go to the next line along and pop off the one in our path and so we finished all of the combinations beginning with one at that point we iterate along to the two and the whole process starts again with two at the beginning of our path and we will avoid duplicates this way for example including one again due to the fact that every time we call backtrack we're adding one to our I value dictated by the main for loop at the beginning of our recursion stack so after we finish adding two to our path the next iteration along will add three and we should have two and three being the next combination which is also what the output has in that order and so writing out our code for this backtracking solution in this way almost identical to the previous question helps us develop some problem solving memory giving us a familiar solution for permutations and combinations the time complexity for this solution looks a bit messy o of K * n factorial / by N - K factorial * K factorial so pretty messy indeed in plain English we can say this section here is the number of combinations and each combination takes o of K time to generate cuz we copy the path list of length K to the result and so that's where the K comes from and you may also see this written as o of K * n k and we pronounce this as n choose K where this part here n choose K denotes this entire section here also known as the binomial coefficient this basically just represents the number of ways to choose K elements from a set of n elements and the space complexity is the exact same there are N2 K combinations and each combination is of length K so the space required to store all these combinations is K * n choose K our binomial coefficient and the depth of our recursion stack is at most K because we add elements to the path until the length is K and you see that because at each time we have two two elements in our path we immediately return so if we were just looking at our recursion stack the space would be o of K and the storing of our path is also o of K except the recursion depth and this path list are not the dominant terms here it's the storing of our combinations in the results and that's where our space complexity comes from and so that's it for our combinations question next up is our final question in the backtracking section which is called permutations so we've just done combinations and now we're doing permutations where we are given an array nums of distinct integers so all the integers are unique we want to return all possible permutations in any order of course the order for each list inside of our return list matters and you can clearly see we have every possible permutation and again our backtracking solution is going to be pretty similar to all the questions we be seen in this section so far so I'll definitely give it a shot now otherwise let's go through the solution so here's our code and the first example from the question and you can see of course it's pretty similar to the previous questions We Begin by initializing our results array which we will return at the end before that however we call backtrack passing in zero zero will be our starting index and of course we want to include the one here so we're going to pass in zero the second argument will be the length of our nums and this will be the constraint for when we want to append to our results list each question is different although the style of our backtrack solution is similar the details are different here the question is asking us to return all the permutations of the same size of the original list so we know when we've iterated through our for Loop and our starting index for the backtrack becomes equal to the length of our nums we've reached the end we have three elements inside our nums list so we can append to the result and return the previous example was the same only when we had two integers in our path could we return the question before that however we were not returning and that's because we wanted all possible subsets so even if we only had one integer we would append to our results and continue to find a larger array and then append that also so just to note on the details and the importance of reading the question twice and understanding exactly what it wants so I'm sure you're all experts on this now but let's quickly run through a few steps of our code to help us understand what's happening so we begin with our Backtrack on an index of zero and the length of our nums which is three at the beginning our start is of course not equal to our end so we jump to this for Loop which again I'll show with a purple line and the current index that we are on We Begin by looking up our numbers array and switching the start index with the current I index so at this point our start is equal to zero as is the i in our for Loop so switching these two numbers across keeps the current order in our numbs the same allowing us to append the original order in a second so we're going to call backtrack again as always iterating up to the next index and we're keeping our ending condition the same throughout at this point our start is still not equal to our end so we'll reach our for Loop switch numbers over and call back track again so we have a new for Loop starting at a i of one our start and our I are still equal one and one so our nums this order stays as the original and we call backtrack yet again two is still not equal to three so we reach our for Loop switching over the second index with the second index keeps the original nums list order the same and we call backtrack once more at this point our start is equal to the end so we can append to our results list a shallow copy of our nums so there's the very first permutation in our results and here's where things begin to get interesting our code execution stops here and we go back up to the call stack to where we just called Backtrack on the next index along at this point our start and our eye are still equal we will see later that this line is meant to undo the swap that we done before the backtrack allowing us later to make changes unaffected by our current changes in order to get the full list of permutations so switching the two and the two gives us the original numbers list in the same order we go back up to the beginning of our for Loop except now we've reached the end cuz our IE will be three so our code execution can stop here and we can go back up the cool stack yet again at this point we had just called backtrack with the two so on the next line we will switch the I with the start giving us the same order of our nums list then we go back to the beginning of our for Loop and the one becomes two now we can finally begin switching some numbers around our start was equal to one and our I is now two switching these two numbers across will give us 1 3 2 we're switching the first and the second index one being our start variable and two being the current index so after that we call Backtrack on our start which is 1 + one gives us two and our end is staying the same at three at the top of our new backtrack our start is not equal to our end so we begin a new for loop at this point our I is equal to two as is our start variable so we call backtrack yet again adding one to our start as you can see our start is equal to our end so we will append to our results and return straight after so we add our current numbs list which is 1 3 and 2 code execution stops here back up the call stack we had just called backtrack and switching the current start which is two with the current I which is two does nothing so we have reached the end of our for Loop because at the next iteration our I will be equal to three and we go back up our cool stack once more to when we had just C this backtrack with the two and the three and we reached the next line switching over our start and our I our start is one and our I is two this reorders the nums list back to its original state at this point the for Loop for our backtrack with the start variable of one would have reached its end so we go back up the cool stack once more to when we call the backtrack with the start of one and the end of three our I is equal to zero as is our start so switching these numbers over does nothing and now we can finally Loop over to the next iteration in our very first for Loop and taking a look at our answer right now we have 1 2 and 3 and 1 32 which is the exact same as what the output has so you know we're on the right track and you can see that iterating now to the next index in our main for Loop the one pointing to the two gives us a whole new set of permutations beginning with the number two and finally on the last loop our very first index will have the number three so it's this main for Loop dictating our permutations and the Order of our output in our results variable so I'm going to leave it here because I'm pretty sure you can get the hang of it by now if not feel free to continue following the code execution by yourself as for the time and space complexities it is O of n * n factorial there are n factorial permutations for an array of n distinct elements and we've seen this before for example 3 factorial is 3 * 2 * 1 and for each single permutation it takes n time to generate this to our results list we are carrying out the same number of operations on our n factorial permutations for example swapping the elements and creating a copy of our list so these n operations Times by our n factorial permutations gives us a Time complexity of n * n factorial and similar to the previous questions our space complexity is the exact same as our time complexity we have our n factorial permutations each of length n requiring the same space to store inside our results variable and on top of that we also have a recursion depth of n space so our Co stack is O of N and finally we're also creating a copy of our nums list which at each time we are appending to our results will be of length n so that also needs n space overall however the bottleneck is our n * n factorial space the most dominant term and so that's it for our permutations question covering all the different types of backtracking solutions we have giving us one more solution in the same style we've seen before that we can reuse whenever we are asked this style of question make making changes based on the details that we are asked and so that's it for our backtracking section our next section is linked lists we have gone through a lot of these questions in the data structures part of the material so this should be a Walkin the park for a lot of you and let's head straight into the first question which is called middle of the linked list where we have to given the head of a singly linked list return the middle node of the linked list if there are two middle nodes return the second middle node and the question also defines for us are linked list by giving us a class list node so for example if we were given the linked list from 1 to five we would return the middle node which is three and our output shows 3 4 five because three is pointing to four which points to five so it is a bit misleading because in fact we will just be returning the node itself and we've already gone through this in detail in our data structures video we simply have a w Loop which will push along our slow and fast pointers as long as the node the current fast pointer is pointing to exists and has a next node so in the first step of our wow Loop the slow pointer will move along one node and the fast pointer will go to the next next node the condition for our W Loop is still true so we move along one more in our slow pointer and two more in our fast pointer at this stage the node that the fast pointer is pointing to does not have a next node and so we break out of our wow Loop and return the node that the slow pointer is pointing to and let's quickly see how this will work for an even length list our slow pointer will move along one node and our fast pointer will move along two nodes the condition for our W Loop is still true so so our slow pointer will move along one and our fast pointer will move along two nodes at this point fast is pointing to none so while fast is not true and our slow pointer is pointing to the second of the middle two nodes so we break out of our W Loop and return the second middle node just as the question asks in the second example so a pretty nice intro into linked lists and we can do this in O of end time because it's just one W loop with operations that increase linearly as the input grows and of course we have constant space because we're just keeping track of our slow and fast point as we iterate across our link list no matter how big it is and so that's it for our introduction into link lists with the question where we have to find the middle of the linked list next up we have linked list cycle and we are given the head of a linked list we should determine if the linked list has a cycle in it and this is just defined as some node in the list which can be reached Again by continuously following the next pointer the question also says that internally pause is used to denote the index of the node that the Tail's next pointer is connect connected to PA is not passed in as a parameter so in this example the tail which is minus 4 is connected to the node of index one our PA of one and we need to return true if there is a cycle in the linked list otherwise return false and in our constraints we see that pause is minus one if it is not a cycle otherwise it's a valid index and as a followup we want to try answer this question in constant memory so let's have a look at our solution so here's our link list and again we're going to use a slow and fast point pointer and the trick is that if there is a cycle eventually the two pointers will meet so as the question shows us let's imagine that minus 4 Points back to minus 2 both our slow and fast pointers are initialized on the head of our linked list so while the fast node and the fast. next nodes exist let's move them along like we did in the last question so at step one we're going to move the slow pointer up one and my fast pointer in red is going to move up two nodes to zero let's repeat this again slow pointer moves to zero and the fast pointer follows the loop in the linked list back to the value two so let's clean this up a bit back at the top of the W loop our condition is true so let's move the slow pointer up to the next node in our link list and move the fast pointer to its next next node so our if condition slow is equal to fast is true so we can return true and that's our solution nice and clean if we had a situation where we didn't have a cycle eventually the fast pointer would be none or it wouldn't have a next and we would break out of this W Loop and return false and of course it's oh end time due to the fact that we have one iteration in the worst case scenario where the tail points back to the first node both pointers will meet after n iterations of the slow pointer this is of course because the fast pointer moves twice as fast so it will meet the slow pointer within end steps so the slow pointer would take n steps and the fast pointer would take n / two steps and if you're interested in looking a bit more at this algorithm search up Floyd's toris and hair algorithm and of course we have constant space we're only keeping track of our slow slow and fast pointers and so that's it for finding a cycle in our linked list nice and simple next up we have another question which we have gone over in our dat structures practice for Linked lists where we are asked to reverse a linked list when we are given the head of a singly linked list so pretty simple if we have 1 2 3 4 5 we want to reverse the list so the head is now five and the tail is one so one points to none if our list is empty then we just return an empty output and if we didn't have this example it might be a good clarifying question to ask if you're in an interview shows that you're paying attention to the details and the follow-up question asks if we can implement it iteratively and recursively so today we'll be going through the iterative solution because as I've said before it's much more readable easier to debug and less prone to consuming too much memory but definitely give the recursive solution a go if you can otherwise let's get into our solution so here's our link list and here's our code on the right you see we have in total three variables our previous pointer which we have in blue our current pointer which we have in red which we initialize at the head of our length list and we can add this label to let us know what we've labeled as the head node and we have this next pointer inside of our wow Loop so current is definitely not equal to none so we set the next pointer to be currents next and then we set the current next to be equal to our previous our previous is initialized to point at none so we can set the head node to now point to none and then after that we set the previous to equal our current node so here they are both pointing at our head and then we update our current to be equal to the next pointer so you can see the responsibility of this next pointer is to enable our current to update after we remove the link between the current and the next node and just before that we update previous to equal our current pointer and let's repeat this all over again at the top of our W loop our next pointer moves to point to current next current. next is set to previous so we're essentially removing this arrow and changing it to point in reverse and then we set things up for the next Loop by moving our previous to equal our current and our current to equal our next pointer repeating this again we'll move our next pointer to the four node update the next of our current pointer to be equal to the previous node update our previous to point to the current node and our current node to point to the next pointer setting us up to continue reversing our linked list if we repeat the while loop one more time we reach a position like this we've set our next pointer to be currents next which is none because we're at the tail of of our linked list we set current. next to equal previous so we move this arrow and point it to the for node update previous to be our current and our current to be our next pointer at this stage our wow Loop will no longer execute because current is indeed equal to none we've reached the end of our link list we have one more small adjustment to make which is to update the head of our link list to point to where previous currently is and that is the new head which was the old taale of our linked list and that is how you reverse a linked list nice and simple of course the time complexity of this solution is O of n because we have one W loop with a bunch of operations that increase linearly as our input size grows which is just the length of our link list and the space is of course constant because as we said at the start we only have three variables our previous pointer our current pointer and our next pointer and so that's it for reversing a linked list next up in our linked list section we have another easy but the pass rate has dropped significantly so we're doing a bit more here the question asks us given the head of a link list and the integer value remove all the nodes of the link list that have that value and return the new head so essentially what we're going to do is Loop through this link list checking the next value of each node if we find a node with the current value that we're looking for we kind of want to bypass the current node and we can delete it or not it doesn't matter as long as we remove it from our linked list and take the arrow that the two is pointing to and send it straight to the three and then continue traversing our link list so a fairly easy concept and let's get into our Solution on the left I've C be the link list from the question and before we look at the code let's look at my note which is try to find workarounds and a complete solution to allow all edge cases to be solved by the same function so when I first solved this question I had a lot of if statements for example what if it's an empty list what if it's a head node what if it's the last node that needs deleting so all of these edge cases and looking at the solutions I found one that is a complete solution in that every single type of edge case could be solved by the same function and so let's take a look at that code now the very first thing we do is create a dummy node which points to the head and we do this in case it is the head that needs updating and we can set the value to minus one because the problem constraints tell us that the value will never be below one so let's label this our dummy head and that's how we begin our solution and the next step is we initialize a current node pointer at the dummy head and then we begin a w Loop where the condition is as long as a current node. next exists continue to Traverse our list and check if the node needs deleting and this is because we know that when the current node doesn't have a next where at the end of our list we finished our traversal and now you might ask me but wait if our current node is pointing to the last node for example well a w Loop would stop while current node. next is not equal to none but it's okay because we are checking if the current nodes next is equal to the value that we need to delete so at this point we would have already checked and deleted the six because our current node checks at the node before whether our node's next value needs deleting and this can save us some complexity for example keeping multiple pointers to check what our previous and our next or our next next pointer is similar to the previous question so let's walk through this example from the question and afterwards we'll take a look at the case where the head needs deleting and the dummy head proves its use so the first thing we do is hit the W Loop the first line we check if the current node next value is equal to the value that we're looking for the question told us we want to delete the value of six so this is not true and we hit our else block updating our current node to Traverse our list and point at the next node so now we've entered our original linked list so let's follow our code another iteration of our wow Loop and we find out that the current node's next node is one that needs to be deleted so what we do is we take the current nodes next and we point it to the current nodes next next and what this would look like is taking this arrow and pointing it to the three now at this point we don't need to remove this six once we return the head like the question asks us to the six will be removed from our linked list for example traversing the linked list would go 1 2 3 4 5 six but again it might be a good point to bring up in your interview that you've noticed this potential issue in failing to clean up the deleted node and it's important here not to update our current node because we need one more while loop and one more if check to make sure that after updating our two to bypass the six the three does also not need deleting cuz if the three was a six value we would have to repeat the same process except in this case it's okay so we update our current node to point to the three and a few more while Loops over and we end up at the five the if statement tells us that the current nodes next value is equal to the value we're looking for so we can set the current nodes next to point to the current nodes next next which is none at this point the current nose next is equal to none so our W Loop has finished and we return the dummy Heads next which is in fact the head and let's quickly go over a case where the head needs deleting so we can see the value of this dummy head so let's imagine we have a linked list which looks like this the very first thing we do is set the current node to point to the dummy head in our W loop our current node's next value will need deleting and let's remind ourselves that in fact this is the head so we do the same thing we've done before and point our dummy head to the current nodes next next which is the heads next after that we'll do another loop the two does not need deleting so we update our current node point it to the two node at this point the current nodes next is equal to none so we break from our W Loop and we can return the dummy head. next which is our new head and we can see based on the question that they're passing in a head which is just a node depending on how you write the link list as we saw in our date structures videos we can in fact create a link list and lab the head but in this case this head label is not a concrete value we're just passing around list nodes as an argument for the head so when we return our dummy Heads next node as the head which the question asks for we're simply returning another list node and so that's our solution and of course it's over end time due to the single W Loop and constant space due to the fact we are only keeping two variables our dummy head and our current node so that's it for removing nodes from a linked list so next up we have reverse link list 2 which Builds on the reverse link list question by making us rever us a single part of the link list so not the entire list but a section of the linked list and the question will give us left and right integers which represent the index of the two nodes in our list from which we should reverse the links and before we look at the code let's try and consider our high level approach and some of the edge cases that we might come across so here is the first example from the question and we are told we want to reverse from 2 to 4 so we're given a left pointer of Two and a right pointer of four so we know our left pointer is here and our right is here essentially what we want to do is break each of these links have the four node instead Point backwards to the three the three point backwards to the two and with some steps in between eventually the two point to the node that's immediately right of the right pointer so that's how we can identify that and all that's left now is to make the node left of the left pointer point to the node that is defined by the right pointer and so at a high level there's our solution we have 1 4 3 2 5 1 4 3 2 5 so as you've seen in our quick walk through that we are using the node left of the left pointer and in the case that we need to delete the head so our left was one this could cause some difficulties and similar to the previous question we could check for this with an if statement except it will be a lot easier to introduce a dummy head so previously when we were reversing from the second node we had the head or the number one node point to our right in this case if we are reversing from the very first node we would break this and have the dummy head point to the right instead making the node four our new head and we know this because whatever our dummy head points to is the head of the original linked list so let's begin our solution and we're going to do this in three parts the first part is reaching the node at the left position so in this stage we just want to set things up before we begin breaking links and reversing things so we've created our dummy head and set it to minus one based on a code this could be any value but seeing as the question tells us the value of the node is between 500 and positive 500 then maybe it's a good idea to change this to be positive or negative infinity or outside of this range but based on the solution it's not going to be a problem then we begin by creating two pointers our left previous and our current node current node is going to drive our traversal so it's always going to point to the current node that we're on and we're making changes to and the left previous is the node that's directly left of the left that's given by the question so the question tells us the left that we want to begin reversing from is the two and the right side that we want to finish our reversal is the four node and so by the end of this first stage we want the left previous to point at the head and our current node to point at the left and how we're going to do this is we begin with our left pointer at the dummy head and our current node pointing at the head and we begin a for Loop in the range of left minus one left minus one will give us exactly the number of Loops or iterations of our current node to reach the left pointer so for example 2 - 1 in this case the current node will reach the left pointer and the left previous will reach our head if left was three for example then we would do 3 - 1 current node needs to move twice and our left previous would move 1 2 to the second node setting us up perfectly and we do this simply by updating the two variables at once our left previous becomes what our current node was and the current node simply becomes its next so for this example we will do one iteration our current node is now pointing at the left and our left previous is pointing at the node left of the left pointer and so that's it for the first part in the second stage of our solution We Begin by creating a new variable called previous and setting it to none so there's our previous pointer then we begin a for Loop in the range right minus left + one and we can do this because right minus left gives us the number of links or the number of steps between those two nodes 1 2 and then we plus one because actually we want the number of nodes that we should be taking action on so each iteration of our for Loop corresponds to a node that we are taking action on so in our example we're going to have a range of three and then finally we create one more variable our next pointer and we need this next pointer to be able to update links after breaking them which we're going to see right now in a second we set our C node. next equal previous so in the very first case our previous will be equal to none and we'll do some changes at the end to fix this so what that means is breaking this link and setting two to point to none which is what we set previous to equal originally and then in the third line of our for Loop we set things up for the next iteration of our Loop we do this by setting previous to equal our current node and our current node to equal our next pointer and we've seen this next pointer in action in the previous questions as we've just seen it lets us update our current node so on the next iteration of our for loop our next pointer points to the four our current node next is set to now equal our previous which is the two node and then we update everything again our current node points to the next pointer and our previous is now the three node and we have our final iteration of our for Loop update our next pointer update the current nodes next to be the previous and update our previous to be the current node and our current node to point to what the next pointer is currently pointing to and so that's it for stage two we've reversed all the links between the left pointer and the right pointer and you'll notice this part of the problem was pretty much identical to the entirety of the very first reverse link list problem now all that left to do is some cleanup we need to set our left previous to point to the node directly after where we finished making our changes and we need to update the left which we set To None to point to the last node we changed which is the right so let's have a look at that so here's where we left things so there's two things to clean up and we can do this in two lines finally using our left previous pointer we take the next next of that and set it equal to our current node so the next of our one node is the two node and the next of that is pointing to none and this will always be the case no matter where left is so we're going to take this arrow and point it to the current node which is the five and then we take the left previous is next which is referring to this arrow and point it to the previous which is the four this Arrow here so let's clean this up you see now if I remove all the pointers and the arrows and I've not changed any of the links I've simply moved them around we have R1 pointing to the four our four pointing to the three the three pointing to the two and the two node pointing to the fifth node which points to none 1 4 3 25 1 4 3 25 and so that's our solution and finally here's our notes our reminder for how to answer this question broken down into three parts and the time complexity is of course o of n we're doing one single iteration over our link list which as the length of our link list grows so will the number of operations proportionally and it's constant space because we're only keeping track of these four variables here which is a nice reminder that when I come back to this slide I can check immediately I can see these four four pointers and I know how to answer reversing a link list 2 where we reverse part of the linked list so that's it for this question so next up we have this palindrome linked list question where we are given the head of a singly linked list like always we need to return true if it is a palindrome or false otherwise and it gives you the definition of a palindrome which is just a sequence of characters or numbers that read the same forwards and backwards so 1 2 2 1 1 22 1 and they mark this as an easy question except cep we'll be using a few Concepts from other questions for example finding the middle of a linked list and reversing items in the linked list so personally I would put it at a medium which is why it's towards the end of our link list section so let's get right into our solution here's our link list from the question which is indeed a palindrome so we should return true at the end and the first thing we're going to do is find the middle of the linked list and we've already done this in a previous question in itself so this should be no problem at all we initialize two pointers a fast and a slow pointer so here's our fast pointer initialized at the head and here's our slow pointer also initialized at the head and while fast and fast. next are truthy we're going to move fast along twice and slow along once so one iteration of our Loop will put the fast pointer at the third node along and the slow pointer at the second node along our while condition is still true so we move fast along twice and slow along once and that's all there is to the first part of this question nice and simple now for the second part of the question we're going to reverse our link list except we're only going to reverse the second half so we begin by creating a previous pointer and setting it to none like we've just seen in the previous question so here's our previous pointing at none and then we begin by creating a next pointer and setting it to Slow's next node so here's our next pointer pointing at the last node in our linked list and then again as we've seen before we update slow. next to equal our previous so we're breaking this link here and pointing the two to none and then we set previous to equal our slow and our slow to equal the next point slow is still not equal to none so we repeat the process one more time updating our next pointer to equal now none which is the last nodes next we set our slow. next which is this Arrow to point to our previous which is the node to the left so there's our new link and then we set previous to equal slow and slow to equal our next pointer at this point slow is equal to none so we finished reversing the second half of our link list and finally the third stage of our solution we create two pointers our left and right and we have no need for these four pointers anymore so we can get rid of those we now have our left initialized at the head and our right initialized at our previous our previous had finished at the very last node of our linked list so there's our right pointer and essentially what we're going to do is use the right pointer to iterate across the link list and use the left pointer to do the same and check if they are equal so we begin a while loop which continues as long as our right pointer is not equal to none and this is the only way we can know that we finished our traversal because we did not update the first first half of the linked list so the end of our linked list on the left side still points to the second half of the linked list and that's fine based on what we're trying to achieve in this question so if our left do data or value as it is in the question is not equal to the right then we know it's not a paland drum in this case one is equal to 1 so that's fine and we now update our left pointer to be the next node along and our right pointer to also be the next node along repeat the process again and two is indeed equal to two so we can update both of our pointers again left next and we're at the Third node and right. next and we've reached none at this point our wow Loop no longer executes cuz right is now equal to none so we know we've traversed both sides of our linked list and we know during both traversals each node was identical to the other half so we can break from our W Loop when right is equal to none and return true at the end and so that's our solution so similar to the middle of the link list question we use our slow and fast pointers to find the middle and then we reverse a section of the linked list similar to the previous question using these four pointers except BAS on the details of the question we don't need to do all of the updates so it's fine for us to still have this link from the first to the second half as long as we check if the right pointer is equal to none and then in the third and final section we use two pointers to Traverse both halves of our linked list checking at each stage if the values of the nodes are equal and of course it's of n because all of the operations are linear in time complexity each of the three while Loops are independent so there's no exponential growth of our operations as the link list grows in size and it's all of one space because we we only keeping track of a set of variables for example our fast and slow pointers our next pointer and our left and right pointers and so that's it for our palindrome link list question nice to see how we can bring in previous Concepts and adjust them based on the current question now we have our final question in the link list section which is merging two sorted linked lists so this is quite a nice question especially if you've completed the sorted array squares question in our two pointer section so we are given the head of two link lists list one and two and we want to merge them into one sorted linked list the list should be made by splicing together the nodes of the first two lists return the head of the merged link list so in this example we have 1 1 2 3 4 4 and based on the order of the ones and the fours we can see it doesn't really matter which node comes first if the values are the same and based on the definition of our list node programmatically there will be no difference so let's go ahead and give this a goal here's our solution so the very first thing we do is create a current pointer our dummy head and make them both equal to a brand new list node this is going to be the beginning of our new sorted link list which we will return at the end so here's our dummy head and we don't need to give it a value because we're not going to include it in our final link list then we begin a while loop while list one and list two remember from the question list one and list two are the heads of the two sorted link lists so let's create some pointers for those and the main function of this W Loop is to compare their values and after the comparison we can begin linking to our new dummy head whichever value is smaller in the correct order and we don't need a separate if statement for if the values are equal saving us some code complexity and you'll see why this is the case in a second so for the very first comparison the two are equal so we hit our else block and set current. next to equal list two at the start We Set current to equal our dumy head so the next node in the link list is going to equal this list two except right now this list two is still pointing to the three so let's make sure we don't forget that so this is what it looks like right now and then we update list two and updating the two variables in one line means current will equal list two before we made the change so we can set our current to equal this list two which it was previously and then we begin a new iteration of our W loop at this point list one's value is definitely less than list 2's value so we can repeat the process except on list one this time setting current do next to equal list one current. next is referring to this Arrow so we can point it to list one and then we repeat the same updates moving list one to equal the next node along and our current to equal what this one previously was so let's tidy this up a bit and there we go let's repeat the same process again comparing the two values the list one pointer is less than the list two pointer so we hit the if block update current. next to equal list one which it currently is so that's okay and we can actually remove this label because we don't need it anymore update list one to be the next node along and then update our current to be what list one previously was repeating the wild loop again we'll hit the else block because the list two pointer is less than list one so we'll change our current next to point to the list two node and then update list two to be the next node along and then update current to be what list two previously was we check again they are equal so we hit our else block adding current do next to equal list 2 which it already is updating list two which now equals none because we're at the end of our second list and then update current to be what list to previously was and at this point we can break from our W Loop we don't need to carry on iterating because no matter how long list one is we know that all the values are going to be greater than what current currently is because the question told us the original two lists will always be sorted so what we can do is just append whatever's left of list one on the end of our current merged list and then we check list one or list two this is to make sure that at least one list has some nodes inside that we want to append and then we check if list one Set current do next to equal list one or append list two if it's list two that still has nodes so we set our current do next to equal this list one and there's our new merged link list 1 1 2 3 4 4 1 1 2 3 4 4 and we return dummy. next because the question wants the head of our new merged list so that's it for the solution we're just creating a new merged list using two pointers like we saw in the array section to compare the values of the two lists at each point and add them onto our new merged list so we can do this in all of end time because even though we have two iterations on list one and list two they are independent both occurring in our single independent while loop and of course it's constant space because we're keeping track of three pointers list one list two and our current pointer as well as our dummy head so that's it for merging two sorted link lists and that's also our link list section complete our next section is stacks and if you've gone over the Essential Software foundations then you'll know for example we use this dat dat structure in cool Stacks a crucial Concept in javascript's runtime environment representing the mechanism by which the JavaScript engine keeps track of function calls in a program so a nice reminder that these date structures are not just for practice and interview questions but all of them have crucial applications in real world programming so let's get into our first question which is the minack question and if you've watched the DAT structures video you'll know that this is essentially implementing a priority queue using a stack which we've seen before so it should be fairly familiar and definitely not a medium question in my opinion so with that in mind go ahead and give it a go otherwise let's take a look at our solution we are asked to design a stack that supports push pop top and retrieving the minimum element in constant time and we are given a class Min stack with the four functions that the question wants and of course each solution must be over one time so let's get right into our code and on the right you'll see we initialize a stack in our initialization function now some solutions you'll see might initialize has two stacks one to keep track of the minimum and one to keep track of the values except I think it's a lot cleaner to keep track of one stack and inside our stack the way we keep track of the minimum value is really neat so let's play around with the code of our solution so when we instantiate our class we're creating the Min stack and inside we're initializing this empty stack and let's push the three numbers that the question pushes -2 0 -3 and before we print the result let's take a look at what's actually happening our push function is the most difficult of the three so once we've got that down the rest will be a walk in the park first of all we check if our stack exists for the very first case of adding minus 2 our stack does not exist so our current Min is set to X which is the number that we pass in minus 2 after that we append to the stack minus 2 and the current Min which is also min-2 so at this point our stack looks like this and in actual fact under the hood our stack is just an array of TS the first element in each tle is going to be the value that's passed in - 2 0 - three the second element is always going to keep track of the minimum number up until that point so when we push zero onto our stack we're going to have - 2 - 2 and 0 - 2 because at the point of adding this 0 -2 is still the smallest value that we have in our stat and the way we do this in the code is we check what the current Min is before appending and we do this by using the built-in Min function and checking the X which at this point is zero against the most recent minimum self. stack minus one gives us the element at the end of our stack the rightmost element so we've not yet added our zero in yet so our stack at the index minus one gives us this T and the first element in that is going to be 0 1 - 2 the second element cuz we're zero indexing in Python so that gives us min-2 of 0 and -2 our minimum value is going to be min-2 so we append onto our stack 0 and -2 and in the third example pushing the minus three we're going to create a new two pool first element is going to be minus 3 our value and then we check again and the second element is going to be minus 3 because that's our new value and if we walk through this in the code we'll see that our stack exists so we hit the else block and we check the minimum between Min -3 which is the x that we're passing in and self. stack minus1 which gives us this 0 -2 twoo the first index gives us Min -2 so between -3 and -2 -3 is our new Min so we append onto the stack -3 and -3 so you see that every time we append onto our stack we're appending the new minimum value in the second position and whatever value we pass in in the first position and this is how we're keeping track of our minimum value so when the question asks us to get the minimum which is the next operation in our list we can just return the index of min-1 1 so stack minus one gives us the last two in our stack and the index at the first position gives us minus three our most minimum value so far if we wanted to pop well that's pretty simple pop stays the same we're just using the built-in pop function to pop the last item we're not returning anything so we're popping the entire tupo off of our stack we're just trying to get rid of it which is different from the get min as we see down here in our explanation we're returning minus 3 and if we want top well let's say we've just popped off the minus 3 so our stack now looks like this so now we're on top we should return zero and that's because top simply Returns the last item in our stack as you'll remember from our data structures video last in first out order so this should return zero and our stack will simply be left with our minus 2 -2 and at this point if we get min well we only have one more value left so of course we'll be returning the minus 2 so that's it for our code and of course each solution is constant as the question asks for we're not iterating over our list we're not doing anything complicated each function we're either returning something based on the index and if we know the index then it's a constant operation we're just grabbing whatever information is at that memory address when we do our Min for example we're comparing two values which we already have our X which is being passed in and the exact position of our most recent minimum value to append is just to add on the end and to pop is just to pop off the top of course however our space will be o of n because we're keeping track of our stack so if we pushed onto our stack end times our stack would be of n space and so that's it for this Min stack question next up we have the valid parenthesis question and this is a nice one because it's a little look into how language passes work a fundamental Concept in programming you'll be familiar with this if you have gone through the software engineering material or have done your own learning compilers and interpreters need to ensure code has the correct syntax before beginning to process it otherwise it will break so they use language passes and without getting into the lowlevel specifics this generally means making sure the syntax rules of the programming language are upheld things like checking for balanced symbols such as the opening and closing of brackets which is exactly what this question valid parentheses is asking of us given a string s containing the characters and we see three types of brackets curved curly and square brackets determine if the input string is valid and it's valid if the opening brackets are closed by the same type of brackets in the correct order and every closed bracket has a corresponding Open Bracket of the same type and we see from the three examples below exactly what the question is asking of us so let's get into our solution so here's our input from the first example of the question and here's our code the very first thing we're going to do is initialize a stack and a hashmap or as we call it in Python a dictionary and our dictionary is going to have the keys of the closing of the brackets and the values of the opening corresponding brackets and then we begin a loop across our s string which is passed in so let's make this bigger and add an arrow to show where we are in our if statement we check if the stack exists at this moment in time it does not so we'll come back to this later so instead let's append into our stack the element that we're currently pointing to which is this Open Bracket so here's what our stack looks like at this moment in time and then we go back to the top of our for Loop and move on to the next symbol at this point the stack does exist so we check the second half of our conditional in our if statement if the element is in the hash map so we're checking the keys of our map and it is definitely in our hash map it's this one here and stack minus one so the element at the end of our stack is equal to this hashmap element then we pop from our stack well this stack minus one is pointing to this Open Bracket here and is it equal to the hashmap using the element that we're currently iterating over to check the value in our dictionary this one here well they're definitely equal so we can pop this Open Bracket from our stack and so you can kind of get the gist now of how our solution is working anytime we see a Open Bracket we add it to our stack and anytime we find the corresponding closing bracket we remove that Open Bracket from our stack and at the end if our stack is empty we know we have a valid solution and if we repeat this for the square and the Cur brackets the exact same thing will happen again so let's consider instead a nested version of our question on the first iteration of our for loop we're going to append this Open Bracket to our stack and then again our stack exists but the element that we're currently iterating over in our hashmap which at this point is the open square bracket is not in our hashmap so we can append it to our stack also and just to be clear let's add some quote marks around these brackets because they are strings so on the next iteration of our for Loop we hit the if statement our stack exists and the element we're currently looking at which is the closed square bracket is in our hashmap and the rightmost or the last item in our stack is indeed equal to the value of the key that we use to look up in our hash map so we can pop this square bracket off from our stack and then we iterate along and repeat the same process with the last Open Bracket in our stack and at the end of course we return not stack because for example if we had one more bracket in here we would append this into our stack there would be no corresponding close bracket so we know our solution is not valid and that's why we return the opposite of our stack if it has items inside returning not of our stack will return false and if it's empty then returning not on our falsey value which is the empty stack will return true so that's our solution and another quick reminder in our notes that looking up in the dictionary checks the keys which is this element in hashmap it's over of one look up constant and it's faster than using dick do Keys which in a sense creates a view of the keys and then requires of of n time to iterate and find the key that we're looking for the time complexity is of n because we're iterating over the string s that is passed in with this for Loop so if our string doubles then the amount of operations we have to do doubles either in our if or else statement we're popping or appending and of course the space is also of of n because we have our stack which we're keeping track of if we have a valid solution the stack could be n / 2 which also simplifies to o n because every time we find a corresponding closed bracket we'll pop the Open Bracket off from our stack but again because of the simplification it goes back down to or in and on top of that we also have our hashmap but that's constant space keeping track of the three bracket types the question tells us and so that's it for our valid parentheses question next up we have this question called evaluate reverse polish notation and if you're unfamiliar with what it is the naming will have no meaning to you at all but this is a nice question because I've seen it in University level education as a project so it definitely holds some value we are given an array of strings called tokens that represents an arithmetic expression in a reverse polish notation and the definition for that is a mathematical notation in which operators follow their operands and we've already gone over operators and operands in questions before as well as our software engineering material if you have that but simply put this notation gives two numbers and the operator afterwards so three and four added together so we want to evaluate the expression and return an integer that represents the value of that expression so down here in our first example we would do two and one add it together to give us three and then we would take that value and the next three times them together and give ourselves nine and we're giv given some notes Here on The Operators included in the question the fact that our division won't leave us with any remainders or there'll be no division by zero for example so just a bunch of notes to let us know that it's a clean question and of course it's in our stack section so we're going to be using a stack to solve this and so you should be able to give it a go otherwise let's look at our solution so here's our code and it looks pretty simple the first thing we're going to do is create our stack and then we have our tokens from the first example then we're going to begin a for Loop over each element in our tokens starting off at the two and we have two main blocks inside our function our if block if it is a number and our else block if it is an operator so we check if the element that we're currently iterating over is not in our operators and we know this is the finite set of operators given to us by the question then we can append it to our stack making sure we convert it to an integer because it's given as a string so we can add two to our stack if we Loop over to the one we'll do the same one more Loop and we've reached our operator at this point we pop off the last two items in our stack two and one and we check which kind of operator it is using IF and else statements so nothing too complicated there in this case it is a plus sign so we can append to our stack the addition of our left and right the reason we add it back to our stack is because this new number will be the next operand in our calculation so in this case we'll append the addition of left and right which gives us three so we continue our for Loop hit the three append it to our stack loop again to the asteris and in our else block we hit this else if statement and appen to our stack the multiplic ation of our last two items inside the stack giving us nine at that point we finished our for Loop and we can return the last item in our stack which will always be the only remaining item giving us nine so let's quickly take a more complicated question to see how this would work so in example three in the question we have multiple numbers followed by an operator and it's best to see what this means by walking through the code we would add each number to our stack as we Loop through our for Loop and hit the F Block in each case then we would loop again and hit the addition sign this would lead us to our else block and the very first if statement in this case we still pop off the last two items in our stack 9 add three would give us 12 so we can add this back to our stack in this line here loop again to the minus1 and add that to our stack loop again to the asteris and at this point we would be multiplying the last two items in our stack that would give us minus 132 and you see the very next item in our tokens is another operator so even though we were given several numbers here The Operators and operands would still balance out it's just based on the input tokens and the Order of Operations the question is looking for so at this point we would do 6 / - 132 our right being Theus 132 and the left being our six so we would take the item that went first in our stack and divide it by the last item in our stack as we can see on this line so the float of left divided by right and we make it an integer gives us zero and this is based on the notes that the question gives us that the division between two integers always truncates towards zero so 6 / - 13 2 gives us this negative decimal number if we take the integer of that it gives us zero so we can append zero onto our stack move along in our token string of course the multiplication of 10 and 0 will give us zero iterate along to the 17 add that onto our stack add the last two items that gives us 17 and iterate again add the five to our stack and add it to the 17 and that gives us 22 and again this question differs from the first in that we have multiple numbers in a row so let's take a look at what this means mathematically in Reverse polish notation when whenever we see an operation we're taking the last two operands so in this case the N9 and the three are the last two numbers before we hit the addition and that's why these are the innermost brackets the very first operation that we do then we add the 11 to our stack before hitting the next operation which is this multiplication at that point again we take the last two numbers in our stack that would be the result of this 9 and three addition multiplied by the minus 11 we've just added to our stack giving us 12 * -1 the next most inner bracket in our calculation and again we hit a division so we would just do the same we would take this six which is the first of the last two items in our stack and divide it by the result of the last two operations which would be six / -132 and so hopefully that gives a bit more clarity into how reverse polish notation works and how it connects mathematically so it's a nice solution to a question which requires a bit of understanding about exactly what the question is looking for understanding reverse polish notation might not be something that's easy to pick up if you've never seen it before but if you understand the concept then the question is not too difficult so so I guess it's a medium in terms of understanding exactly what this New Concept is and of course our time complexity for this is over n due to the fact that we have one pass over our token string so the entire time complexity relies on the length of our tokens and the number of operations increases linearly depending on our token's length and similarly our space will also be o of n due to the fact that as you've seen in our token string just now we can have multiple numbers passed in in a row so it's not always just two numbers in our stack so theoretically we could have n numbers passed into our stack giving us n space and so that's it for our evaluate reverse polish notation question so our last question in the stack section is this stack sorting question and it's not actually aite code question but it's something I found very useful to help improve my skills and it's pretty simple all we have to do is take a stack of integers and sort them in ascending or descending order so I leave that up to you that's not the focus it's simply the switching of a greater or less than sign and what I'm going to do is give you this pseudo code and pseudo code is just the description of an algorithm written in plain English so this is the pseudo code that I'm giving you to complete this solution so it should definitely be doable pause and give it a go otherwise let's walk through the code so here's our code on the left and let's walk through it our input stack that is given in is just an array of numbers in the question we're told it's a stack and also based on the pseudo code we're going to use a temporary stack to sort our input stack so the first thing we do is create our temporary stack and then we begin our wow Loop pop off a number from our input stack and don't forget because these two data structures are Stacks we can only stick to stack operations so for example we can't append to the start of our stack only the nend so popping from our stack gives us this 23 and while our temporary stack exists and the last number in our temporary stack which as we've seen in our stack dat structure is similar to the top or Peak function if this number is less than our current number then we do some operations well right now there's nothing in our stack so this W Loop doesn't execute and we go straight to app pending our number to our temporary stack back at the top of our W Loop which is iterating across our input stack we reassign n to be the next item we pop off from our stack which is this 92 at this point our temp stack does exist and the last item in our temp stack is indeed less than the current number so what we do here is add that last number back into our input stack and pop it off from our temporary stack so we could have done this in one line by saying stack. append temp stack. popop but it's all the same so we add the 23 back in here pop it off here at this point the W Loop no longer executes cuz our temporary stack is empty so we append the 92 to our temp stack and you should kind of get a feel for where this algorithm is going now we're simply using the input stack as a kind of placeholder for our numbers while we make sure our temporary stack is in the correct order so back at the top we would reassign our number to be 23 pop it off from our input stack down here in the while loop 92 is not less than 23 so we jump to the last line and append 23 to our temporary stack one more W Loop and our new number is 98 at this point our temporary stack exists and the last number in our temporary stack is less than 98 so we remove this number from our temporary stack add it to our input stack and go back to the top of our W loop at this point the same is true the last number in our temporary stack is less than our current number so what we do is take this 92 add it back to our input stack pop it off from our temporary stack and then finally we'll break from this W Loop and append the 98 to our temporary stack so even though it looks like we've made no progress back at the top of our W Loop the next number we pop will be the 92 down here we know for sure because we've just popped off this 92 due to the fact that it's less than our 98 this W Loop is not going to execute and we can append 92 back to our temporary stack at this point the same is going to be true for the 23 because before we iterated to the 98 in our main for loop our temporary stack was in correct order so we don't have to enter this while loop again and now we can add the 23 popping It Off from our input stack and so hopefully you should get the gist of this stack sorting method and it's always good when you can tell exactly what's going to happen without walking through the code line by line and that's how you know you've understood the algorithm so I can tell for example we're going to pop this 31 off I know the 31 is greater than the 23 so we're going to pop this 23 off add it back to the input stack exit out of this W Loop and add the 31 to this temporary stack so things will look like this so I'm sure you get it by now and if you don't play around with the code and continue to walk through the algorithm and so originally we said ascending or descending order if you want to change it the only thing you need to do is flip this sign around right now we're checking if the L item in our temporary stack is smaller than the current number that's being passed in and if it is we know we need to make some changes because we're giving our temporary stack in descending order so that's it for our Solution on the left is the temporary stack solution we've just walked through that's our iterative solution and on the right we have our recursive solution if you want to give the recursive Solution on the right to go definitely do because it will help in the long term even though it's something that might not be asked in an interview and the time complexity for this I'm sure you've guessed it is over n squ we have a nested while loop the outer w Loop iterates across our input stack of n elements and for each n element our inner W Loop iterates across our temporary stack to find the correct position so in the worst case it will run end times so for example if our input stack is given in descending order and we want to return the answer also in descending order every time we add an item into our temporary stack the next item along is going to be bigger in that case every time we're going to hit the W Loop add the numbers back to our input stack and repeat the process to make sure the biggest number is first giving us n^ s operations in the inner while loop for n items in the outer while loop and our space is of course o of n we have our number variable which is constant it's always going to hold one element and our temporary stack which in the worst case at the end of the algorithm for example will hold all n elements so that's it for our stack sting question so we're on to our next section which is cues and this section is not too long because we've gone over a bunch of cues and their different operations in the DAT structures Video regular cues double-ended cues priority cues and in my opinion if you've done your practice with stacks and similar date structures like arrays then if you are asked a question on cues which you've not covered the knowledge you already have should definitely be easily applicable and so our first question is a nice segue into the Q section we are asked to implement the stack using a q so I'll take the Q dat structure and create a stack and of course this question focuses on the main difference between the two a q is first in first out and a stack is last in first out and the question tells us to implement this last in first out stack using only or up to two Q our solution will only use one q a double-ended q and it should have all of the functions that we've seen before push top pop and empty which is just an empty check and you see in the notes it specifies that we can only use the standard operations of a queue this means pushing to the back of a queue and popping from the front also depending on your language the queue may not be supported natively we are using python so we can use the deck class that's this one here inside delete code editor you won't need to import this outside in your local code editor however you may need to import the deck from the collection's module so in our initialization we would create something like a stack and set it to be equal to our deck which is our double-ended Q so given that I've told you that go ahead and give the question a go it should be fairly easy otherwise let's take a look at the solution so here's our code on the left pretty basic we have our que which we initialize in our initialization function to push into our que which is acting as a stack we simply use a pend so let's imagine this is our que this is the front and this is the back if you want want to push onto our stack we simply append it onto the back this is the same for Q so not much changes there if we want to pop from our stack now we need to do something different so we're going to begin a for Loop in the range of the length of our Q minus one minus one because that's the last item that we want to pop so let's imagine we have four items in our q and we begin a for Loop in the range of the length of our Q which is 4 - 1 which is 3 that gives us a full loop in the range of three so we begin at the first element and let's see what we do we we use pop left because in our queue we're popping from the front first in first out so we're allowed to use this operation as the question tells us so we take this one and we use the push function to add it to the back of our que we do this two more times because our for Loop is in the range three so we will take two add it to the back take three add it to the back and our for Loop has now finished so we can pop from the front of our queue using the deck function pop left to remove this four and there's our queue updated working as a stack if we had a stack and our four was at the back we would simply pop it off the end last in first out our Peak or top function as the question calls it is simple we just return the last item in our queue without popping it off and of course to check if our Q or stack is empty we just check if the length is equal to zero so nice and simple each function is of course constant time complexity except for our pop which is all of N and space is of course all of n because we're keeping Our Deck with n elements and down here we just have a note on the Q module in Python which typically if you're in an interview you'll be asked to write the structures from scratch but in case it's just a reference to the Q module in Python so for example you would import your q and you would use it to create a queue like this so if you're interested in playing around with this module and the deck a bit more I definitely recommend giving it a go anyway that's it for our first question in the Q section next up we have this time needed to buy tickets question and I really like this question because the answer can be so simple if you figure it out no clever coding tricks needed just pure logic and problem solving definitely try this one out because even if you don't get it or you get a suboptimal Brute Force solution seeing the linear solution will be a nice light bulb moment the question is a bit of a boss but essentially we are given this array of integers called tickets the array represents people in a que and each person I so the person at the E index wants to buy that position's value in number of tickets so person at the index zero or the first person in the queue wants two tickets the second person in the queue or the person at the first index wants three tickets each person can only buy one ticket at a time and this ticket buying transaction takes one imaginary second once the person buys their ticket they go to the back of the queue and have to queue up again to buy their ticket and you see we can handle this queuing by minusing one from everyone's ticket value per pass the question wants us to return the time it takes for a given index K to finish buying their tickets so that's the question The Brute Force should be relatively easy to get and if you want a hint at the one pass linear solution I'd suggest revisiting your notes on the minimum time to visit all points question in our array section it's not an exact copy of the solution but the idea behind it is similar so pause now if you want to give it a go otherwise let's get into the code here on the left is the Brute Force solution quadratic in time but let's instead focus on our linear solution we have a single for Loop iterating over the length of our Q tickets and we split the logic into two parts every person before K and every person after k for every person before K if they want to buy less tickets than k then we know we can add their exact amount of tickets to the time one ticket purchase is 1 second so for example we would add two and two to result cuz it's less than our amount of tickets at index K this is because these people before K will finish buying their tickets while K still has tickets to buy when they finish they will not take up any more time so for example after one iteration of RQ tickets the values will be 1 1 4 1 that's 1 second for each 4 seconds one more iteration and we have 0 0 3 0 one more second for everyone and that's 8 seconds after that the first two values are both zero so because they had less tickets to buy we would add the exact amount of tiet tickets that they had to buy which is equal to the number of seconds if instead they wanted to buy more tickets than k then we know we can add the amount of tickets or time it will take K to buy their tickets this is because they will each take up 1 second until K has finished buying their tickets and we can stop so for example after one iteration we will have 4 41 1 on the second iteration we will have 33 0 and the algorithm can stop notice how the first two took the exact amount of time that K took and the algorithm will stop there so in that case we can add the amount of time or tickets that it will take K to buy their tickets now it's the exact same concept for the people after K if they want to buy less tickets we know they will finish buying before 4K and go to zero so we can simply add the amount of time it takes for them to finish buying their tickets but the only difference here is if they want to buy more tickets than K in that case we will still add K's time to buy but we minus one we minus one because the question asks for the time for K to finish and at that point the algorithm finishes and of course we don't need to count any more time for example if this was our input after one part the amount of tickets left would be one and two one more pass and we would have zero at K you see how we added K's time minus one for the second person and it's of course over end time because we are iterating our tickets queue to find out each person's time and space is constant one variable which is our result and so that's our solution to this nice little logical problem time needed to buy tickets our final Q's question is perfect to wrap up our understanding as it focuses on the principal difference between q's and stacks and remember working with a Q is pretty similar to working with a stack except for that key operational difference in the order of removing elements from the DAT structure so the style of stack and Q questions will not differ too much and the decision on which to use depends on what we're trying to achieve in the question which this question is a perfect example of it's a simple question we want to reverse the first K elements of a given Q so if we have a Q of 10 items and we are given an integer K we want to reverse the first K items in that queue and you can do this however but the point here is to try and use a stack to solidify our understanding of the two date structures remember you can only use the functionality of that structure so removing from the front of a queue for example and popping off the top of a stack you can Implement your queue however you like import a queue or a deck or write it from scratch if you want to test yourself so give it a go now otherwise let's take a look at the code I've given two solutions here one uses a queue imported from the Q module and one uses the deck from the collections module the code is identical except for the differences in the functions of each of these classes let's focus on the deck example because it's iterable which makes our life a little bit easier this just means we can iterate over it for example using the Len function whereas for the queue we would have to use the given function Q size for this reason I think you will often be allowed to use a deck unless asked to create the queue from scratch using an array for example but that's fine because we've done plenty of that in our dat structures work so we're going to use a deck and treat it as a queue and we're also going to use our stack which we create an empty array to represent our stack and we append onto our stack the first K items from our Q using pop left to remove from the front of our queue so after the first of our three Loops this is what we have then we hit the second Loop where we use the fact a stack is last in first out to pop the items from the stack and append them back onto our Q so we have the items added back onto our Que in reverse order except now they are no longer the first K elements they come after n elements in our Q so we correct that with our third and final Loop where as we saw in the first question of this section we can pop the items off the front of our que and push them back into that same queue after that all that's have to do is to return our Que time complexity is of n due to our third Loop if our Q was 1,000 items long and we are reversing a k of three items then the final operation of popping the 1,000 items from our q and adding them back is the bottleneck K can never be bigger than n so this final operation is what gives us our o of N and space is O of K after the first for Loop we are keeping K items in our stack the Q is already given to us so we're not factoring that in and so that's it for our question reversing the first K elements of a Q and our Q section Al together our next SE section is binary trees and a quick reminder that a binary tree is a tree structure in which each node has a maximum of two children the left and right child not to be confused with binary search trees which is our next section and a binary search tree has some rules about the values of the nodes a lot of questions in this section will focus on the searching techniques breadth and depth first search go back and take a look at the DAT structures video to remind yourself how these work for example when to use the Q and stack for which traversal and let's have another quick reminder on the types of binary trees a LEF node is a node with no children so these last nodes a full binary tree is one where every node other than the leaf nodes have two children a complete binary tree has all levels fully filled where the last level can be filled or not a degenerate tree is one where each parent node has only one child node a perfect Bion tree is one where all nodes have two children except for the leaf nodes and the leaf nodes are all at the same depth level and finally a Balan tree is one where the absolute difference of the heights of the left and right sub trees at any node do not differ by more than one so with all that in mind let's get into our first question average levels of a binary tree is our first question in the binary tree section we are given the root of a binary tree and we are asked to return the average value of the nodes on each level in the form of an array answers with then 10 the^ of minus5 of the actual answer will be accepted we have this tolerance to handle minor deviations that arise from floating Point arithmetic without getting into the details too much as we've seen computers use the binary system base 2 to represent all data including numbers in binary only two digits are used 0 and one so when it comes to storing decimals there are some approximations so that's the question and we see we have the tree node class which is identical to the tree nodes we were working with in our data structures so let's take a look at how we can work this out here is the code and get used to this pattern for these tree questions because you'll be seeing it often this code performs Brett first search that's why I've added this orange badge here to remind us which one we're using breadth or depth most of these tree questions will involve depth or breadth as suchar which as the note tells us is better coded out using stacks and qes over recursive because it better demonstrates our practice and understanding of data structures and we know of course this question will use bre first search because we want the average value per level so we want to evaluate each level at a time so we begin by initializing our Q using a deck and inside we give it the root node breadth for a search we use a q depth for a search we use a stack why well because a q means we Traverse all nodes in the same level before going to the next level by nature of the way we pop items first first in first out we then also create our results array which we will return at the end and then we begin a w Loop which will iterate over the entire tree of n elements we continue looping as long as our queue exists because every time we reach a node we check its children and add them to the back of the queue so at the end of the traversal there will be no more tree nodes in our queue and we know we finished inside our Loop we want to process our tree level by level so we create our level array and we begin a full loop which iterates over all nodes in the current level and at this point I think it will be better to walk through the code to see why this works at the start we receive our root node one element in our que gives us a full loop in the range of one so we pop this node from our q and append it to our level array then the key here is we append onto the que the children of this node and so what will happen at each level remember one for Loop is one level is that each node will have its children added to the Q ready for the next level so on the next iteration of our wow Loop when we take the length of our Que in the four Loop we will for sure have the exact number of nodes at that next level in this case we add the 9 and the 20 nod no to our Q our full loop finishes and we add to the results array the average value of the nodes at that current level which is three at the root and then we would just repeat the same procedure with the next level a full loop in the range of two because we have two items in our que pop the nine off add it to our level array which we reset to empty at the top of our W Loop and then we would add Nine's children to the que 15 and 7 pop the 20 off and add it to our level array no children so next our four Loop finishes and we calculate the average of 9 and 20 in our level array and add it to our result the time complexity for this is of course o of n our search is iterating across the entire tree to calculate the average at each level and space is also o of n remember we want the worst case let's think of the last level in a perfect tree the last level will have exactly half the nodes of the tree and we know o of n / 2 simplifies to O of n so there's our solution for calculating the average value of nodes per level in a tree a nice intro to walk through in our tree section setting us up to answer later questions with more ease our next question tasks us with finding the minimum depth of a binary tree pretty basic question so shouldn't take too long even though we are asked to find the depth don't be misled into using depth for a search we want the minimum depth so instead of using depth for a search and potentially wasting a lot of time exploring a very long sub tree before moving on to the next sub tree it might be preferable to use breath first search where we can terminate the algorithm as soon as we find the first Leaf node so let's see how to implement this here are three solutions our recursive give this one a go if you want to practice and expand your skills otherwise for now we'll stick to the iterative and typically we use a while loop for these bre first search patterns to me it's cleaner and it helps us stick to one framework making it more memorable but the full loop version is there to help us understand that we can approach it differently and see how that's done so for the wild Loop version we're going to accept the root node as always return a minimum level depth of zero if our root is null as an edge case create our queue which will contain two pools two PS of the node and the current level so we begin begin with the root and a level of one so for each node in our breath first search we're going to check its children and add them along with their current level plus one to our Q the first node we reach with no children we know for certain we have found our minimum depth because we are searching each level at a time so fairly simple and I don't think we need to walk through the code here but let's quickly see the first example we begin with our Q of three as the root and the level of one inside our wow Loop we pop off this three node and the level one check its children add the N node plus one to the level into our Q so that gives us a two Port of 9 and two and do the same for the 20 node on the next iteration of our W Loop we pop off the 9 node along with the level value of two we check and see that it has no children and return the level of two the time complexity for this is of course Over N our bre first search processes each node and in the worst case we process all n nodes space is also all of n as again at the very last level of our search in a complete tree we would have up to n / by two nodes which simplifies to O of N and so there's our solution to finding the minimum depth and as we've seen this tree search pattern twice now as well as in our dat structures we should be able to reuse it relatively easily when facing the rest of these questions naturally our next question after finding the minimum depth is to try and find the maximum depth now the solution is going to be very similar to the previous question except for a couple of lines so definitely pause and give this one a go the left side solution shows us our remix of the previous question where everything is identical except for our condition upon which we finish our algorithm instead of returning a as soon as we find a leaf node we want to keep going until the queue is empty because we know at that point we've traversed our entire tree and processed every node at every level and the last node will for certain be on the last level because we are traversing in level order so we can return that last node's level because this solution was relatively easy due to the previous question setting us up nicely let's instead take a look at the recursive solution we have two ways of doing our recursive solution both are valid and essentially do the exact same thing the second solution is just written out in more depth to make it easier to follow and it also follows the same patterns we saw in our dat structures but let's take a look at the more concise recursive solution for now and if you're having trouble catching on then you can walk through the more detailed version in one sentence what we want to do is recursively compare the left and right subt trees at each node to find the maximum adding one at each depth level you see We Begin by calling max depth on the root node from there we want to find the maximum value of the two children we do this by taking the max of the max depth of the left child and the max depth of the right child and at each level we plus one representing the current level so this plus one represents the root level three node on the left side we take the max depth of nine again we take the max of the two children nine has no children so for both function calls we hit our recursive base case and max depth call will return zero we add one to account for the nine nodes level and so one will be returned back up to this Max calculation and that's the left side of our sub Tree on the right side we do the exact same thing on the Node 20 we take the max depth of the left and right child max depth depth of seven will return one because it has no children and the one comes from adding one to account for the Seven's level on the left side I've added the four so we can see exactly how it works when we have uneven levels we take the max depth of the four node and the max depth of the right child which is none this will give us zero on the left side calling the max depth on the four node will return one so the max between one which has returned from max depth on the four node and zero returned from max depth on none we'll take a Max of one add one to it and return two as the answer to our max depth on the 15 node the max between 2 and 1 is two we add one to that and return three and finally the max between 1 and three we take three and add one to it for the root level node giving us a maximum depth level of four 1 2 3 4 and so that's our recursive solution and the complexity in both cases for time and space is over n for the time complexity We Are iterating Over N elements in both cases for the space in the iterative case we need n space for our q and in the recursive solution we need n space for our cool stack in the worst casee equal to the maximum height of our tree and so that's how we find the maximum depth of a binary tree okay so our next question is not directly Elite code question but more of a core operation you should know and it could easily be part of another bigger sculped question we should know how to find the Max and Min node in a binary tree remember a binary tree is not ordered in value like a binary search tree so the solution is not as simple as going to the end of our right and left subt trees we need to Traverse all the nodes so give this a go because it shouldn't take too too long here is our code it's pretty simple we're going to do a bre first search over our binary tree again using a que and again using a w Loop conditional on the existence of this Q so the pattern is again the same this time however we're going to keep track of our max value node we can set it to zero for the sake of this example but of course if we had a question we need to be careful about the constraints because this could ruin our solution for example if all the values in the tree were negative so we initialize this outside of our wild Loop to keep track of the max node perform our search as standard adding children nodes to the tree and performing a check at the end to update our max value of course if we wanted the minimum value we would just change this to be a less than sign it's all end time because we are traversing all the nodes and all in space for our que a nice and easy one there for finding the Min and Max values next up we want to perform a level order traversal and return the nodes in that order that's our question level order simply means breath first search here as we see in the example we're printing 3 9 and 20 and 15 and 7 this is different from the traversals we have seen in the DAT structures practice like in order pre and post order the question here wants us to return each level in a separate array and if you want to hint you will remember that we worked with levels before in the average node value per level question so we can use some ideas from there so there's a couple things going on here and it's marked as a medium but I definitely think it's doable we are just performing breett first search as we have seen a few times now and printing the nodes at each level in separate arrays so definitely pause now and try to give this one a go of memory otherwise let's take a look at our solution as always the same setup for our search and again a pretty similar solution to our average node value per level question We Begin by taking care of the edge case which is an empty Tree in that situation we just return an empty array if we do have a route we initialize our queue using a deck and our tree list that we will return at the end we begin a while loop and inside we create our level array which we will add all the nodes from the current level to we do this inside the loop to reset it to an empty array at the beginning of each new level then we begin a full loop in the range of our Q we know our Q will hold the exact number of nodes at the current depth level because inside our Loop we append all the children of the current nodes so for example at the root node we append 9 and 20 but first of course we append the current node's value to our level array after that we append the level array to our tree and we begin our while loop all over again resetting our level list to be empty so let's quickly walk through one more level in our tree our full loop will be in the range of two because we have two nodes 9 and 20 so it will execute twice I being zero and one but we we don't need to use the loop Index this time we pop off the nine append it to our level array it has no children so we iterate to the next node which is the 20 append the 20 to the level array add both its children to our Q at that point the for Loop has finished so we append our level array to the tree and move on to the next level and no doubt I'm sure you've guessed it o of n for both space and time we are once more iterating over all the elements and storing them in our q but this time it will be our tree array that will take up more space towards the end of the solution when it contains all n elements and so that's how we Traverse in level order and return each level in an individual array a good question to see if you're getting the hang of breath first searching over trees especially given all the previous questions we have answered wrapping up nicely before our first depth first search question this next question same tree gives us the root nodes p and Q of two different trees and we are asked to return true if they are identical meaning the same value for all the nodes in all the same places give it a go now otherwise I will tell you a few hints same tree is our first binary tree question which we're going to answer with depth first search although it's definitely doable with Breet first search implementing depth first search iteratively follows the exact same pattern as the iterative Breet first search implementation although we initialize a stack instead of a q it's a fairly straightforward question and one final hint is not to confuse your left and rights take a look at example two it's not identical because the root nodes have a different left and right child so let's take a look at our solution now as we mentioned before a very similar pattern to our bre first Search We Begin by initializing our stack and typically we add the root node depending on the question of of course we might add something different or some extra information in this case we are adding both root nodes and just a quick note is that you should start to see the point of going through these questions with a very similar answer pattern it's to understand the core problem solving pattern and be able to notice how we can manipulate our pattern to achieve a working solution so in this case we've seen a similar approach before for example when we added the two Port of the node and the level to our date structure so this time we can extrapolate that knowledge and add a tuple of both root nodes to our stack we pop them off and then compare at each level where whether they are equal and then of course we add their children to the stack to repeat the process let's quickly walk through a false solution to see why these statements are required because with identical trees we won't get to see exactly how this works so in example three we append both root nodes with value one to our stack we pop them off both of them exist so this if statement doesn't execute neither of them are none and one is equal to one so we don't return false in that case we can append their children the reason is if both nodes are none both don't exist for example at to Lea node we might append none for the left and right child so in that case if both nodes don't exist it's okay to continue with our solution because this is identical on both trees however if this if statement does not execute we know either node one or node two has some value in that case if either node one or node two is none then we know one node is none and one node has a value so we can return false because this is not identical and finally if both nodes exist but the values are not equal of course we can return false in this example though we take the children of the root nodes and add them back to the stack whichever node we append second will be first to pop off remember the fundamental rule of a stack last in first out and that will be the sub tree we fully search first so in this case we've appended the right children the one and the two in a tupo and the left children the two and the one in another twole we pop off last in first out so the two and the one and the values are not equal so we return false so that's our solution nothing too complex time is all n linear because we have one Loop traversing all the nodes in the tree worst casee for identical trees we process all n nodes of both trees giving us o of 2 N which simplifies to O of n spaces of n or of H where H represents the height of the tree or in other words the maximum height of a sub tree because we go all the way down our sub Tree in depth first search for example here on the left we will continue appending and searching down the left sub tree so we will initialize our stack with the root nodes one and then in our depth for search we will then search the two nodes then the three nodes then the four nodes before going all the way back to the 12 node and at the last point of the maximum height of the subtree we would have ofh space used in our stack we can still call it all n because if we had a degenerate tree for example one single sub tree with a th000 nodes our space is n h at most can be equal to n and so that completes our solution for checking if two binary trees are identical our next binary trees question is pathome and this is a cool one because on a very high level it reminds me of pathf finding in applications like Google or Apple Maps given the root of a binary tree and integer Target return true if the tree has a root tolea path such that adding up all the values along the way equals our Target integer so in our real world maps example this could be a case where each node is a checkpoint like some Junction and our Leaf node is our destination of course this is a very high level comparison you wouldn't want any Leaf node destination but it's a cool comparison to make and remind ourselves that these are not just frivolous questions but we are learning skills so give it a go now otherwise let's take a look at our solution we immediately take care of our Edge case and return Force if there is no root node don't forget your edge cases very important next is our standard procedure and based on the question we decide to add our root and the value of the root in a tle and put this in our stack as the initialization you might think but wait the value is accessible via the node anyway but there is a reason for appending it to the stack that we will see later inside our wow loop as always we're popping off the values from our stack and the first of our conditional if checks is to identify if we have reached the end of our algorithm this is a common pattern you will see if you haven't noticed by now we typically check if our algorithm has finished as the first thing for example in our Edge case at the top as well as inside our while loop we check if the algorithm has finished before continuing to add the children to the stack the reason is it's more efficient and often times the operations that come after could render our successful case unsuccessful so we check if our node is a leaf node if it is and the value is equal to our Target sum well that's everything we need so we can finish and return true but so far we've only added the value of the current root node and we want the total path sum so let's see where that's coming from when we continue to Traverse our tree so if our success case conditional check is not true then we check for both children whether they exist if they do we add to the stack that child node and its Value Plus the current value from the root we have only one way to reach any node this is not a graph so it makes our solution much easier it means we can append at each stage the current value plus the sum of the values so far and that's why if one sub tree does not evaluate successfully we can continue our depth first search to a different node on a different level or on a different side of the sub tree and the next node we pop off will still have the correct value for example popping off the two after the seven does not evaluate successfully the path up until either the seven or the two has been the same giving us the same sum value so far and we will see this in the example we walk through right now so here's our first example and we begin at five and our Target is 22 we initialize our stack with the root node object and its value five we pop these off and we check if it's a leaf node and we've reached our Target get some it's not true indicated by this red X so we append onto our stack the children of the root 5 node in the second iteration of our wow Loop we repeat the same process popping off the node four and its value 9 it's not a leaf node so we continue adding its children which is just the 11 node in the third iteration of our wo we pop off that node 11 that we just added last in first out and the value which we've been accumulating which is now equal to 20 it's still not a leaf node so we continue adding the children of 11 to our stack at that point we've added the two node and the Seven node we pop off the seven node it is a leaf node but our current value is not equal to our Target sum and at this point as we mentioned earlier we can check a different traversal path and the value will still be correct so when we pop off the two node and a Target value of 22 we've reached the end of our algorithm at the seven node you might wonder well if we go bust meaning we go over our Target sum why don't we just stop the evaluation of that sub tree and we could looking at this example here however the constraints of the question tell us that we can have negative value nodes so if if we want a complete solution it's mandatory for us to continue our evaluation and let it do its thing as with most of these questions in this section we're using the same high level algorithm giving us overend time to check every node in the worst case and overend space for our stack to store our nodes and so that's our path sum solution diameter of a binary tree this question wants us to find the longest possible path between any two nodes in our binary tree given the root node for example in the first tree we are shown the longest path is from node 4 to node 3 giving us a diameter of three you can think of it as the number of links if that helps 1 2 3 and this is a rare case where the recursive solution might be easier to understand than the iterative let's take a look at both Solutions now and just a quick note on what both Solutions have in common both are performing depth first search to process each node and at each node we are calculating the maximum diameter found by considering the sum of the left and right subt trees in the iterative solution we have a few extra steps to find these depths in the recursive solution The Depths are returned back up the cor stack and once we have the deps at each node we can calculate the maximum updating our Global tracker to make sure that we always have the max for the iterative it's a good solution to go through because we are using multiple data structures one of those questions that you might need to sit down with draw it out and spend some time figuring things out by yourself we begin with our initialization a stack to maintain our nodes for searching each with a Boolean indicating whether it's been visited yet or not a dictionary to maintain the max height of each node subtree so from that node how high is the sub tree how many more nodes exist first further down and our Global diameter which is set to zero the second section is our iterative depth for search for each node if it's not been visited yet we push it back onto the stack as visited so we're visiting each node twice we also append its unvisited children if the node has been visited the heights of the left and right subt trees are taken from the dictionary or we set them to zero if it's a leaf node then we update the diameter based on the maximum of the current diameter and the sum of the left and right subt trees and we also calculate the max height and store it in the dictionary that's the code intuitively it works because for the traversal each node is visited twice once to explore its children and a second time to calculate the heights of the sub trees the way we push nodes onto the stack means that a node is only Revisited after its children and their sub tree Heights have already been processed that way we can retrieve them from the dictionary and do our calculations the diameter of the tree at any node is defined as the sum of the heights of its left and right subt trees which makes sense based on the question ensuring we capture the longest path so for example at the root node the max of the left sub tree is two and the max of the right is 1 add that together and we get a diameter of three each time a node is Revisited the potential diameter the left and right sub tree sum is calculated and compared to the max this makes sure we always have the max diameter we also store the max sube height of the current node so we can use this later when checking for a new Max diameter we calculate this as the max height of its left or right sub tree plus one to account for the current node if there is no children this will equal one and so that will eventually accumulate as we bubble up our tree to get the sub tree height so that's the code and our description it might be easier to follow when we look at how it works iteratively and there's a lot going on here I'm not going to go through this step by step but pause and have a look you can see that every time we pop off a node and it's not been visited we add it back on as true and the children nodes as false when we pop off a node that has been visited we can calculate the Heights and the diameter in this case for the node 3 it has no children so we know the heights of its subt trees will be zero and the max diameter will stay at zero but we add to our Max Heights dictionary the three node cross the one to account for the node itself and we continue iterating all the way until we've processed every node twice at the end we know for certain we have the max diameter and you can see our dictionary is complete there are no more nodes in the stack so we can break and return the diameter that's our iterative solution let's now compare this to our recursive solution we have the code which firstly calls depth depth is our helper function that will calculate the depth of the tree by recursively calling itself and simultaneously updating the diameter as for any recursive solution we have our base case for this solution it's when the node being passed in does not exist and we return zero if the node does exist we recursively calculate the sub tree height by calling depth on the left and right children this will return to us the sub tree height similar to our iterative solution we take the max of the left and right subt trees if the node exists the sub tree height starts at one if it is a leaf node these will both be zero and we plus one this will account for the current node for example like the node four the depth function calls on the two children will return zero as we see down here for itself does exist so taking the max of the left and right depth which which are both zero and adding one to it will return one and we will keep adding one to this value for each depth level as we search for calculating the diameter we take the max of the current diameter versus the sum of the left and right subt trees again this works because the longest path at any node is of course the height or the depth of the left sub tree plus the same for the right sub tree for example the longest diameter or path at node 2 is the depth of the left sub tree which is one plus the depth of the right sub tree which is also one giving us a diameter of two so for example at the full node when we calculate the diameter it's currently zero the left and right depth are both zero so the diameter is still zero and that makes sense there are no children at the two node when we calculate the diameter we take the max of zero ver the sum of the left and right depths this updates the diameter to be two and that also makes sense at the four node we only have two children giving us a diameter of two each child returning a depth value of one so calculating the max diameter at each node will let us keep track of the max diameter variable for our longest path which when the recursive calls finish will be returned and so that's our recursive solution both Solutions are over in time and space for the iterative solution time is over 2 in as we process each node Twice first unvisited and then the second time visited but this simplifies to of end and space is of end for the stack and the dictionary for the recursive time complexity is over n we need to visit each node once and spaces of n where n is the max height of the tree when our recursive cool stack is at its maximum for example when calculating the children of node four this time in my opinion I think the recursive is a better solution it's cleaner easier to follow and more efficient but of course choose the solution that you like the most and so that concludes our diameter question our penultimate Vries question asks us to invert a binary tree and this is one you might often hear people talk about or make jokes on for it being a difficult question and very different to the actual work you do as a engineer or developer for example if you were an engineer and you'd not done any data structures or algorithm practice you might feel anxious because the question sounds a bit difficult but now we've done all the previous work up until this point you'll find this surprisingly easy we're given the route and we want to invert the tree after that we return the same route pretty straightforward especially compared to the last question I'll give one more hint in a second otherwise you can pause now inverting the tree in this case is vertical because we are swapping each nodes left and right child at every single node in the tree the right sub tree becomes the left subtree and vice versa so that should tell you a bit about the operations that you're going to have to carry out so let's now take a look at how we do this seven lines that's all it takes we initialize our stack with the root for a depth first search traversal nothing new there for this question the bre first search solution is pretty much identical apart from the use of a que of course for this solution however we iterate over the stack popping the nodes off and at each point swapping around the left and right child we then extend onto our stack the pair of the children and there's two things here we could have explicitly checked if the children exist before pushing them onto our stack so in this case if we reach a leaf node we're pushing none onto the stack but it's okay because straight after we pop we check if that current node exists anyway so there's not much issue there and secondly we're adding both children at once so we use extend the extend operation means we're not adding the array into the original list for example when we extend the list with the four and five using extend the elements inside the array are added on to the original array but when we call append we'll be adding on the entire object itself and so that's pretty much it for our solution we'll continue to process the entire tree swapping children at each stage nice and simple the recursive solution is also there if you want to give it a go and an example of horizontal versus vertical inversion time complexity is all of n iterating across every node and overend space for our stack and so that's how you invert a binary tree our last binary Tre question is another medium called lowest common ancestor this will be a nice challenge for our final question given a binary tree find the lowest common ancestor of two given nodes in the tree where the lowest common ancestor is defined as the lowest node in the tree that has the given nodes p and Q as The Descendants simply put this is the lowest common parent so in this example one the lowest common ancestor of 6 and four will be the node five the lowest common ancestor of 2 and eight will be the root node three and we also have a special case where we allow a node to be a descendant of itself so the lowest common ancestor of eight and one will be one so let's take a look at our solution there's a lot going on here but don't worry we're going to go through everything again we have our two solutions iterative and recursive to switch things up a bit and make sure we fully understand depth and breadth first search our iterative Solution on the right will use breadth first search and our recursive will use depth for search as an opportunity to truly Master binary tree searching try implementing the opposite search patter pattern for each solution here let's first walk through the iterative here's our code and on a high level let's explain what's happening before we get into the action we have our queue to maintain our nodes for a search traversal our parent dictionary this will contain a map of each node's parent the key being the node the value being the parent for example on the end here we have the eight node and the parent one this will come in handy towards the end our first while loop is our traversal over all the nodes in the tree during this we populate our parent dictionary until it contains both the nodes that we are looking for p and Q at this point we know we have all the information we need to find the lowest common ancestor we've traversed and found both the nodes p and Q and we have our dictionary of all the nodes and their parents that we passed on our path for p andq so we stop our traversal by breaking from our first wow Loop no need to search any more nodes and before getting into the second section I think we should walk through the code up until this part as you see here we have our Q initialized with the root node and the parent dictionary with the root node and a parent of none on the first iteration of our W Loop we add threes children five and one and update the dictionary on the second iteration we doing a breath first search so we pop from the front of the queue taking the five node adding five's children six and two updating the dictionary and we do the same with the one node the same with the six node and the same with the two node at this point the final if check in our first while loop executes we have the node 6 and the node four in our dictionary p is 6 Q is 4 and that takes us to this second block of code here we initialize an empty set and call it ancestors this will store all the ancestor nodes of P so that we can check if Q has the same ancestors we do this with two w Loops one for p p and one for Q in the first while loop we add all the ancestors of P until we hit none so all the ancestors of P up until the very first root node that way we know for certain the lowest common ancestor of p and Q will be in this set the second W Loop is how we locate which of all these parents is the correct one the lowest common ancestor we first check if Q is already in ancestors if it is we know Q itself is the answer otherwise we check our parent dictionary for Q's parent updating Q if Q's first parent is in the ancestor set this is the lowest common ancestor if not we check the dictionary for the parent of Q's parent and we continue this way in the W Loop until we find the lowest common ancestor and return it as our answer there is another less intuitive way to do this which takes up less space which we will walk through after our explanation here so this column is our first W Loop you see the very first thing we do is add P to the set update P to its parent add the five to the set update P to the five's parent and finally add that which is the root node to the set and at that point the parent becomes none so we break from the first while loop on the right side we have our second W Loop Q which is four is not already in our set so we update Q to be the parent of Q which is two two is also not in the set so we update Q to be the parent of Q which in this case the parent of two is five finally this if check executes because five is in our set and we know we found our lowest common parent of six and four which is five let's now take a look at the less intuitive way to do the second part which takes up less space we use two pointers and initialize them to p and Q and what we're doing is iterating up their respective parents until the pointers are equal at that point we return the node as the lowest common ancestor so in the simplest case for the five node and the node one one iteration and they are both equal to their lowest common ancestor but there is a second case where one of the pointers reaches the root node and the other pointer is still somewhere in the tree when this happens the pointer iterates one more and becomes none when that happens we set the pointer to be the opposite of the target node P or q that we first set it to be this solution will work in two iterations Max meaning the pointer won't switch from the root node to the opposite P or q more than once and the solution of course won't Loop Forever This is because when we switch the node to be the opposite of the target the pointers will eventually Traverse the exact same total distance as each other this total distance will be their respective paths to the lowest common ancestor and any nodes between the lowest common ancestor and the root switching at the end ensures this synchronicity so I've included this solution in the notes also so if we set the first pointer to be at the six and the second pointer to be at the four and we have our dictionary so we can do our traversal in the first Loop the four goes to the two and the six goes to the five on the second Loop the five to the three and the four to the five one more Loop and the blue pointer becomes the parent of three which is none and five goes to the three node at this point we switch the blue pointer to be the opposite of the target node it was first initialized to so we set it to the four node and at this point the purple pointer goes up to none one more iteration the blue pointer goes to the two node and the purple pointer switches to the six the blue pointer goes to the five and at this point the purple pointer also goes to the five giving us our lowest common ancestor so that should demonstrate how both pointers will Traverse the exact same total distance their respective paths to the lowest common ancestor and any nodes between the lowest common ancestor and the root and here it is written out and fall so just focusing on the last two sections of this iterative solution both are all of 2 H time complexity where H is the height of the tree in the worst case for the pointers each one will Traverse the entire tree giving us all of 2 H for the ancestors set solution the first Loop in the worst case scenario will Traverse the entire height of the tree to collect all the parents and the second Loop doing the same so both will be of two h for time again just focusing on the last section for now but the difference here is the pointer solution is constant in space we just have these two pointer variables however for this first solution our space will be ofh for storing our ancestors set all the nodes in the max height of our tree for the entire solution however both iterative approaches are over of and space complexity for our Q storing the Q in the worst case will be the size of the deepest level in the tree which we've explained before as up to half the total nodes in a perfect tree this is because we are doing breadth first search and our parent dictionary could also contain all the nodes in the tree as for time the overall solution is O of n as we Traverse every node in the tree and as we said of of H time for these last two parts to find the lowest common ancestor which overall simplifies to of n since H is at most n so that's our iterative solution let's quickly check out our recursive solution the logic here is that we perform a depth first search and when we reach a leaf node we return none or if we reach P or Q we return p q and that's our base case which this first line does defining the action Behind these arrows at the end of the tree the leaf nodes or when we pass the target nodes four and six back up to their parents the next two lines are of course our recursive function calls which enable us to Traverse down the tree until we find this base case and the final few statements are where we determine the lowest common ancestor firstly if we receive values from the left and right subt trees we know this will be our lowest common ancestor so we return that node which is the root of the current function call just as we see here with the five node the next two statements are us returning towards our lowest common ancestor or defining the Return of the lowest common ancestor back up the co stack for example at the root node when we return the five because the right side is none on the other hand these can also Define the actions for us reaching our lowest common ancestor for example at the two node when we return the four because left is none so we return the right at the end time complexity for our recursive solution is all of n to process all the nodes and space is of H where at the worst point of the algorithm the recursive cool stack will be the length of the deepest sub tree the maximum height giving us o of H which is at most n for example a degenerate binary tree where every node has one child giving us overend space and so that's our recursive solution giving us a full evaluation of how we can find the lowest common ancestor in a binary tree wrapping up our binary tree section nicely our next section is binary search trees and a reminder that a binary search tree is a date structure which is a form of a binary tree it's an ordered binary tree where the ordering is such that every node in the left sub tree is less than its parent and every node in the right sub tree is greater than its parent in other words any node's left child is less in value to itself and right child greater in value so let's get straight into our first question where we want to search our tree to find a single node this is one of those quot operations that could easily be part of another bigger scoped question like the mediums you shouldn't have too much trouble with this one so definitely try giving it a go otherwise let's take a look at the code we're going to take the root node of the tree and the value that we're looking for while our node exists we're going to Traverse down the tree and update the current node if the node is too small compared to the Target we go right and if the current node is too large we go left eventually we'll find the equal node and return or we reach the end of the tree updating the current node to be the child of a leaf node which is none break from our Loop and return none as the question asks and remember what we said previously about checking the end of the algorithm towards the start of a code block this is another example and one more programming concept that we can also learn here is that we can directly use the root without creating this current node variable that's why we have these two solutions side by side in Python when we pass the root into the function here we creating a reference to the same object but a new local variable root inside our function this can then be reassigned without modifying or overwriting the original reference outside the function for example when we reassign this current node or root to be the left or right child so that's our solution time will be o of n because in the worst case we could search the entire height of the tree to find our node or break from the W Loop and return n and space will be constant because we're only keeping track of the root variable or the current node that's passed in so a nice introduction into binary search trees using the fundamental property of left being less and right being greater than to find a node based on the given value in our next question we have another another core operation which is inserting into a binary search tree it's marked as a medium but I definitely think it's easier than most mediums we've looked at inserting recursively in the date structures practice although the iterative is never too far off just a while loop or an extra date structure to store some information so now to contrast that we can look at the iterative approach and although it's easier than most mediums it's likely marked as such because there are two smaller scoped problems first we have to find the node's position in the tree a similar concept to the previous question and then we have to insert the node making sure to maintain the binary search tree properties let's take a look at our solution the first thing we do is create our new tree node with the given value we will insert this later if there is no route the tree does not exist so we can return the new tree node that's our new entire tree otherwise we can assign the roote to a new variable called current although as we've just seen before this is not necessary and then next in our W Loop we Traverse down the tree updating our current node to be the left or right child going left if the value we're adding is smaller than the current node and right if the value we're adding is greater again we saw this while searching for a node in the previous question we keep doing this until eventually we want to go left or right but we've reached a leaf node at that point we can just add the node as the right or left child so in the case of this first example here we are adding node five to this tree inside our wild Loop we go right because 5 is greater than four and on the next iteration we reach the seven five is less than seven so we go left but we can't go left by updating the current node to Seven's left so instead we add five as the left child of seven and that's our new tree pretty easy to understand solution and no need to update the root node like in this example our time complexity is o n where n is the height of the tree because in the worst case we Traverse Over N nodes equal to the max height of the tree for example if we want to add the zero value we would go all the way down this left sub tree and space is constant nothing is being stored except our current variable and the node we are adding and that completes inserting into a binary search tree nothing too complex our next question we want to convert a sorted array into a binary search tree so working with another dat structure which we have seen before and should be experts on by now the question says given an integer array nums where the elements are sorted in ascending order convert it into a height balance search tree meaning the depth of the two sub trees at any node never differs more than one so you see in example one based on our input nums we have minus 10 as the smallest value so that will be the furthest down the left sub tree and then minus 3 and so on building our height balance tree so despite being marked medium this is a bit of a difficult one but give it a go otherwise let's take a look at our code we have two different styles of a recursive solution but let's ignore that now and focus on our iterative we use Brett first search so the overall style should be very familiar and we're going to use some Concepts from our Aras section to complete our solution and here's a walkr of that example there's a lot going on here but don't worry we're going to cover every single step we begin with an edge case check if there is no input nums then there is no tree to build and we can return none otherwise we begin by initializing our tree we can use n the length of the array to perform a floor division finding the middle index and taking that number to create our root node this is necessary for ending up with a tree that is balanced in height and then we set up our Q for our traversal the item structure inside our queue here will be a two-pole of three elements the first element will be a node specifically the parent node the second element is our left pointer and our third element is our right pointer this sets up our mechanism for building our tree tree initialization and our bread first search initialization so using the array from the example we see we have five elements inside that gives us a midpoint using us floor division of two and at the two index we have the value zero so we can create that as our root node and the core mechanism inside our W Loop is that at each stage we're going to select the middle element of our array or our subarray and add it to the tree to maintain the balanc nature for example at the start when we just took the zero after that to set up the first iteration of our traversal to the queue we add the node zero which will be the parent node reference and then we add a left pointer at zero the very first index in the array and the right as mid minus one this will be the entire left half of the array the next two pole will add zero as the parent and the left and right boundaries as three and four this will create a subarray of the right half of the input array 0 to 1 being the left half and 3 to 4 being the right half this is what we're setting up in our que and of each subarray we take the middle value again to ensure we keep the tree Balan creating a node object with that value and adding it on in the correct position of the tree after that we split the subrate Again by appending the left and right sides of that subarray from the middle so it might not be clear with this example but if we take a longer array you might get the idea so there's 10 elements in our array using the exact same mechanisms in our initialization 10 / 2 gives us 5 at the fifth index we have the six value so we'll take that and make it our root node after that we take the entire left half of our nums and the right half so from 7 to 10 and from 1 to 5 these will be the first two two PS in our q and from there we do the exact same thing again we would take three which is the middle node and we would take eight making them the left and right child of six and then from that we add the left and right subarrays to our Q for each node so at that point we'll have four more two in our q and we continue this way again taking the middle node and creating our tree eventually the left pointer will be greater than the right because each time the bounds are adjusted to exclude the middle every time and as we progress and shrink the size of our subay eventually the subray will be empty or invalid when left is greater than right so we check this to prevent any errors or further evaluation and that's pretty much our code so let's go step by step through the first example and just a quick note that two different results are accepted the difference arises from the choice of the middle element when the array is split especially esally when there is an even number of elements to choose from so as we said we initialize our tree with the node zero which is the middle element of the array then we add the two TS which are the left and right subarrays into our que ready for our traversal on the first iteration we pop off this entire tle the parent is the node zero the left is zero and the right is one and we assign them all in this line here from there we figure out the midpoint taking the start and the end index of our subarray so in this case it's just zero add one and we perform a floor division on two the same way we did in our tree initialization that will give us a value of 0 and the element at that index in our input array is - 10 so this value is less than our parent node's value which is zero so we assign the node minus 10 to be the left child of our node zero and then we queue up the next two subarrays into our Q first in first out so the next element we pop will be this two pool with the three and the four these two boundaries will give us a midpoint of three pointing to the element five in our array this node's value is greater than its parent so we make it the right child of our node zero the next Tuple we pop off will not evaluate because left is greater than right so there's no more subarray to be evaluated here on the fourth iteration of our W Loop we will add the minus 3 node as a right child of minus 10 the next tupo will not evaluate on the sixth iteration of our W Loop We'll add node 9 as a right child of node 5 after that every tort in our Q will not evaluate because left is greater than right so our W Loop will continue pop these all off none of them will evaluate so we break from our W Loop and return the root of our brand new tree the time complexity for this iterative solution is o n each element in the input array is processed exactly once this occurs in our W Loop and space is o n the Q can contain up to n nodes in the worst case and we are also using n space to create our tree and so that's how we can create a binary search treat from assulted array an ni question that uses two dat structures in the problem next up we have an old favorite Tome it's made a return and this time in the form of a binary search tree given the root of a binary search tree and the integer K return true if there are two elements that exist in the tree such that they are equal to K and force otherwise for example node 2 and 7 are equal to our Target 9 so we return true so this is another question that builds on some previous Concepts we've encountered piecing together different parts of our knowledge tree and actually this will be a bit simpler than the erase version because the question is not asking for us to return the index but just whether it is true or false so let's take a look at the code We Begin by initializing our Q for our breath first traversal level by level we also create a set the set will hold all the values of the nodes we've seen so far and are traversal similar to the hashmap in the original question but no need for an index key value pairing then we Traverse over our entire tree at each point calculating the difference between the Target and the current node value if this difference is in our set we know we have two nodes that can sum up to the Target so we can break and return true the other case is where our Q is empty so we finished our traversal then we know for certain there are no two nodes that can sum up to the Target and we can return false so pretty straightforward and I don't think we need to go through it line by line however I've gone ahead and drawn out the first example from the question so pause and look over the details if you want a line by line walk through to help your understanding time is all in since in the worst case we Traverse all the nodes in the tree and the last one gives us our solution and space is all of n if we do have to Traverse every node to find our solution then every node will be stored in our set on top of that we also have our Q which can store end nodes and so that's our two sum solution for binary search trees lowest common ancestor of a binary search tree is our next question and we have just gone through this for a binary tree which is more difficult than a binary search tree since we did not have the order in so you will have no trouble giving this one a shot pause now and give it a go otherwise let's take a look at the code so this picture here defines the mechanism of what's Happening inside our W Loop but before that we check p and Q and quickly assign the smaller of the two to a variable named small and the larger to a variable named large and a quick reminder that P and Q are two nodes in the tree that are given to us and we have to find the lowest common parent in the tree so we begin iterating over the tree and we let the current node's value dictate the path of our search at each point starting with the root node we check its value if the current node's value is greater than our large variable whichever that is P or Q then we know we need to go down the left sub tree to find the lowest common ancestor for example here in case 1 p is2 and Q is4 the current node is six so for sure the common parent node we're looking for is on the left side in that case we update the route to be the left child and repeat the process on the other hand if the current node's value is not greater than the larger of p and Q but less than our small variable then we need to update the roote to be the right child as we see in case two if p is 8 and Q is 9 then 6 is smaller than the small variable 6 is less than 8 then we know we should check the right sub tree finally the other option is if the current node is not smaller than our small or larger than our large in that case it must be the common ancestor as we see in the third example if we don't find a node with a value in between the small and the large then at some point the code will update the node to be a child which is none breaking from our W Loop and returning none at the end the time complexity is O of H since in the worst case we go down a sub tree which is the max height of the tree then we either find nothing or find our solution and we finish this can of course also be n since H is at most n space is constant we have our small and large variables and that's it and so that completes our solution for finding the lowest common ancestor in a binary search tree a lot friendlier than the binary tree version minimum absolute difference is our next question we are given the root of a binary search tree and we want to return the minimum absolute difference between any two nodes in the tree so it's a familiar problem we've seen before except now we're dealing with it in a different date structure and I'll give you two hints before we get into the question one is that the minimum difference will always be between consecutive nodes that should help scope down the problem space and hint two is that processing in ascending order is the traversal that will give us the best solution left sub tree root right sub tree if you remember our date structures practice this is in order traversal so pause now if you want to give it a shot otherwise let's see our solution so as we just said we want to do an in order traversal smallest to largest and at each node We compare its value to the previous node so in our example here zero is the smallest node which will be the first we Traverse and eventually We compare the one node which is the next smallest value to the previous smallest the zero and find the difference to set this all up we create a m difference variable this will track the minimum absolute difference at each node comparison in ersal we also create a previous value variable this is for the comparison after we update the current node something we saw often in our link list questions the two values are set to positive and minus infinity since this will be outside the constraint of the question the first is positive since later we are updating the variable and we will look for the minimum or the smallest value so positive Infinity will definitely be replaced and negative Infinity for the previous value this is just a neat trick to avoid extra code in the first node comparison for when there is no previous value yet we'll see this in a second and lastly we create an empty stack this will contain the nodes for our ascending in order traversal then we begin our W Loop which will execute as long as there is a route or stack to process we have two blocks of code inside our W Loop the if block is for traversing down the left sub tree pushing nodes onto the stack from the largest to the smallest until we reach a leaf node all the way down the left sub tree when we reach a node which is none we know we've gone as far left as possible so we hit the second block of code in this block we pop a node from the stack which will be the next smallest node we do the evaluations calculating the M difference and updating the previous value before updating the root node to be the right child so seeing this in practice will make a lot more sense in the first iteration of our W Loop we append the root node one to our stack and update the roote to be the left child zero on the next iteration we do the same for the zero node updating the roote to be its left child which is none since zero is a leaf node on the third iteration our root is none so we hit the else block pop off the top of our stack and calculate the Min difference We compare the current Min difference against the current nodes value minus the previous nod's value we don't have any previous yet so this will evaluate to stay as positive Infinity after that we store the zero as the previous value and update the node to be the right of zero next on the fourth iteration of our W Loop we pop off the one node then we check the difference between the one and the zero node this gives us a new minimum difference of one we store one as the previous value the last node we've seen in our traversal and update the root to be the right child of one the 48 node at that point in iteration 5 we add the 48 node to our stack take the 12 which is the left child and add it to the stack and in the seventh iteration we evaluate the 12 node before evaluating the 48 node in the next iteration and then eventually the 49 node in the 10th iteration again left root right and of course along the way each time checking if there is a new minimum difference so now we can see that this works because the smallest absolute difference will of course come from two adjacent nodes when we search in ascending order also the in ordered traversal will naturally yield the absolute difference between consecutive values as the root node will always be bigger than the previous value eventually our stack will be empty and there is no no current node to process we've gone as far right into the tree as possible and checked every difference so we break and return the M diff variable which will be our answer time complexity is all n since we visit every node once in our traversal and space is all n for our stack which at the worst point will store the max height of the tree and so that completes our minimum absolute difference solution our next question wants us to balance a binary search tree we are given the root of a binary search tree and we are asked to return a balanced version of that tree balanced meaning the height of the left and right tree at any node does not differ by any more than one so give it a go now remembering that Medium questions typically Encompass two easy questions or two smaller problems in that case you might find this easy especially because we've gone over those two smaller problems in this section already so let's take a look at how to solve this we're going to do this in two parts first we're going to create an array of the original binary search tree sorted in ascending order and we've just seen how to do this in the previous question minimum absolute difference and this sets us up perfectly for the second half here we will create the balanced binary search tree from the sorted array we do this iteratively finding the middle element as the root of each sub tree using a q to manage the process we've seen this in the question which names the logic itself convert sorted array to badary search tree where that question specifically asks for a balanced binary search tree there's also a recursive way to do the second part which we have in that previous question also we have already gone through both of these blocks of code in detail step by step so if you're unsure of this solution go back and take a look at these questions and if you're still confused try taking pen to paper and drawing it out for this question overall time complexity is all of n the in order traversal processes each node exactly once the spite the nested W Loops those just help navigate the in order traversal for the converting of the array to the tree the algorithm processes each element of the array once and inserts it into the new tree space complexity of the entire solution is all of n the in order traversal uses n space to store elements inside the nodes array and at most storing the max height of the tree in the stack for the conversion the Q can at most hold nend elements in the worst case and end space for the new tree and that's the balance a binary search tree question a perfect example of using two previous questions or concepts to come to a solution for a harder question deleting a node from a binary search tree this is another medium and another foundational operation for binary search trees personally working through this operation here is what took me to the next level writing the code from scratch drawing out how it works writing out again off memory this really took my python skills and date structures knowledge to a very confident level we're given the root node of a binary search tree and a key or a value of the node that we want to delete while keeping the tree intact again there's two smaller scoped problems in this medium and this time we're actually told what they are one we want to search for the node to remove a core operation we've gone through a few times now and two if we find the node we want to delete it so this isn't just as simple as deleting the node we have to keep the tree intact so a final hint is that for the second part when we are deleting the node we have three cases from the simplest to the the most complex case one we're deleting a leaf node so it has no children case two the node has one child and case three the node has both children so give it a go it's definitely quite involved so don't be surprised if you spend a bit longer than expected otherwise let's take a look at our coded solution we can do this recursively or iteratively I prefer the recursive in this situation it's cleaner and in my opinion not too difficult to follow this is the one we went through in the DAT structures practice in a lot of depth so I won't cover it again however between the two Solutions the core mechanism will be the same for example the deleting of a node and rearranging of the tree and in the data structures video we covered all three cases of node deletion so definitely give that another watch instead now let's take a look at the iterative approach let's see how it works and compare it to our recursive this will be a good exercise so we have our two broader sections the first smaller problem is to find the node we want to delete and the second is to delete that node so this section here is US finding the node and for the iterative approach we need to keep track of the par parent when looking for the node so there's a slight difference there already of course in the recursive the parent is already accessible since the parent will be the node from which we make the recursive function call like in this line here so in a while loop as long as the current node exists so we've not reached a non-existent child of a leaf node and the value is not yet the one we're looking for then we continue traversing down the tree we go left if our value is smaller than the current node and right otherwise until finally we break from the W Loop if we find the value or of course we reach the end of the tree if we did not find the value we're looking for we return the root of the tree as asked since there is no node to delete the tree remains unaffected otherwise we have a current node to delete and we hit the second section here we have our three cases no children one child or both children if the node has no children and no parent then it must be the root node so to delete that we can just return none the tree no longer exists otherwise it's pretty simple we check whether this node is the left or right child of the parent and then we set that child to be none that's case one case two is for one child in in this line here we assign the child of the node we want to delete to a variable checking if it's the left or right child that exists again if the node has no parent it's the root node so we can just return the child as the new root node of that tree otherwise again it's pretty simple we change the child of the parent of the current node to delete so for example if six is the current node then we just set this child variable to be the right child of six the seven node we do this in this first line here and in the final line the parent of six is five five's left child is not equal to current instead it's equal to the right child so in our else block we assign the right child of the parent which is the five to be the child of the current node we want to delete so essentially we're breaking these two lines and creating a new one like this removing the six node from our tree and that's case two finally case three both children in this event we have to find the next smallest node we can find the biggest in the left sub tree or what we do here is find the smallest in the right sub tree we went over this function in the date structures video so in the recursive solution we reused that function and it might be a better idea to create a separate function for this because it makes the code cleaner and we can reuse this function elsewhere in our code so I've taken the example from the question here and I've added this 3.5 node so we can really see how things work so in this block of code here we want to find the smallest in the right subtree we want to Traverse down the left sub tree of the right child of the node we want to delete as far as possible so we begin with a successor parent of three and the successor four one iteration of our wow Loop and the successor parent will be four and the successor three 3.5 the left child of the current successor at that point there is no left child of the successor so our W Loop finishes and then we update the current noes value the one we want to delete to be the same value as the successor this is of course why we created new variables when looking for the successor so we can come back to the current and update it now that we've changed its value all that's left to do is to delete the successor node in this case the successor's parents left child is equal to the successor 3.5 is the left child of the parent successor so we update the left child of the successor's parent to be the right child of the successor in this case it will be none if the successor did have a child it must be the right child since we Traverse all the way down the left sub tree of the right child when looking for the successor in this W Loop here or in the else block the successor is the right child of the node we want to delete directly being this four node and this will update the four node to be the right child if it exists or none and so that's case three when we're done we return the root of the tree and that completes our solution time complexity is linear for case 1 and two we are just datting references this will be constant time but for case three we Traverse to find the successor which can be up to the height of the tree and we can also Traverse the height of the tree to find the node in the first section of the code and space is constant since nothing is being stored and so that's how we can delete a node from a binary search tree in our final binary search trees question we are given the root node and an integer K we want to find and return the kth smallest value in the tree the smallest starting at index one not zero and it's asking for the value of the node not the node itself self so be sure to return that pause and give it a go otherwise let's take a look at our solution you might be surprised by how easy this is for a medium and that's because all the concepts we've learned so far are coming together this is why leak code and interviewing is not really difficult we just have to see enough problems until we realize that the solving pattern is applicable and replicate the code for the question so in this example it's simple we start by finding the smallest value node and from there trse our tree k times to find the K smallest node well to find the smallest node is easy we've seen this before in this section as well as in the date structures practice along with the other traversal methods so we Traverse in order using the exact same code pattern a stack to store our nodes a w Loop which executes until the root is none and the stack is empty an if block for traversing down the left sub tree and the else block for popping nodes performing art operations and traversing right compare this to the Min absolute difference question and nearly everything is the same the only thing that's going to change is the operations we're carrying out no need for any extra variables all we're going to do is check if we've traversed in order K * from the smallest value node by checking the value of K minusing one from its value after each traversal so that's the conceptual approach and here's a step-by-step walkthr again essentially traversing all the way down the left sub tree from the route to the smallest node adding these values into our stack this will all occur in the if block and then we pop the nodes off the stack one by one reducing K by one for each node until K is equal to zero this will all occur in the El Block in the worst case scenario the algorithm needs to check every node when the K the smallest element is the largest element element in the tree requiring a full in order traversal of the entire tree additionally in a tree where we just have one single sub tree something that looks more like a link list the algorithm would still need to visit each node to reach the K smallest element in the first place are spaces all of n driven by the stack which can grow up to the height of the tree so n at Max is the height of the tree as we see in the example after we reach the smallest node and so with that we complete this question and the binary search trees section in our next section we're looking at heaps and I do mention it often but it's so fundamental to to answering these questions if you haven't already check out the Heap section in the DAT structures video you'll see we cover a couple different ways to create heaps and two different types of heaps the Max and Min Heap and just a quick reminder on what a heap is often used to refer to Binary heaps where each node has two children at Max we can Define it as a complete binary tree complete being each level is fully filled except for the last level and it must satisfy the Heap property where for a Min Heap every child node is greater than or equal to its parent and the reverse in a Max Heep essentially implementing a priority cue but again definitely check out the data structures video or other alternatives on how we can build this using an array or how we can use libraries to build this and all the associated functions with heaps and here is a quick reminder on some of these functions and their time complexities and in the material I'll link to some of this stuff for example there's a very good explanation on Heap fire and why it's linear so if an interviewer asks you can you implement this Heap using an array or the built-in method which they often will to test your limits then you'll have no problem and it heads up that every question in this section is a medium the code isn't necessarily complex or the the problems too difficult I think it's more so to do with the fact that heaps are a bit more involved than other dat structures like arrays for example so with that in mind let's see our first question K largest element in an array is our first heaps question where we are given an integer array nums and a single integer K we want to return the K largest element in the array a reverse of the last binary search trees question we saw since this is an arrays based question it can easily be done by sorting the array and return in the K index but we want to do this without sorting and using a heap is a very good way to go about this in this question I really want to cover a lot of areas on heaps to give us a good foundation for tackling the rest of the section so let's take a look at the code and here we have three solutions on the top right we have the most concise way to do this the Heap q n largest function internally uses a heap to find the K largest elements from the nums areay argument input it sorts the Heap in descending order largest to smallest returning a list and you can see from the definition of the Heap Q module that the N largest function returns a list of the N largest elements from the data set and the minus1 index at the end is returning the last element in this sorted list which will of course be the Kate largest element so here's a quick example we have an array of numbers from 1 to 10 unordered and if we print the N largest numbers passing in K which is a value of three we get 10 9 and 8 if I change this to five we'll get the five largest items and if we add the index minus one on the end we'll get the last item the K largest item so in this case the fifth largest item the time complexity for this is n log K and let's break it down the Heap construction takes all ofk time and there are two parts to this the initial construction and the heapify process adding the first K elements into an empty array o of one constant per element giving us o of K to create the Heap then we order and arrange these K elements into the Heap structure using heapify which is also done in ofk time and we can see from the documents that heapify is linear in time using no extra space without dissecting the inner workings of the heapify operation we can just say heapify is linear because we start from the bottom non-leaf nodes of the Heap SL tree and work our way up towards the root minimizing the number of compar and swaps needed if you want an explanation on the exact inner workings and exactly why it's linear I'll link some extra reading materials because there's a bit of maths involved and it needs some time to digest so you can go through it in your own time at your own pace but I wouldn't expect this level of detail in the interview so it's not the most necessary thing to learn so we initially create a heap of the very first K elements then we need to check the remaining elements the N minus K elements to make sure that our Heap contains the K largest elements so what the code does is for each remaining element we check and compare it to the root if the new element is larger than the root then we replace it and we re heapify to maintain our heap of the K largest elements the time complexity for each insertion into the Heap is log K in general inserting into heaps is log n since the height of a complete binary tree with n nodes is log n and a binary Heap is a complete binary tree then the height of a binary Heap is also log n since the tree is complete every level is fully populated with the exception of the last level then intuitively this leads to a tree height that grows logarithmically with the number of nodes therefore inserting into this tree / heat requires adding the element at the end and bubbling it up this is of course the process of checking the node value with its parent and swapping if necessary and in the worst case we swap the node all the way up to the root covering the height of the tree requiring log n operations so that gives us a Time complexity of of k + N - K * log K which in the worst case N is a lot larger than K so we can simplify this down to of n log K and spaces of K we have our heap of K length which we use to create a separate array which is also K length so all of 2K which simplifies to K let's now take a look at our second solution in the middle here we have the unoptimized approach where we create our own Heap using an array push all the items into the Heap using the built-in Heap Q Heap push function this will ensure that each value in the array is in the correct index to maintain the parent child Heap property by default this creates a Min Heap to create a Max Heap we have to do some tricks with negative values and it can get very messy so for now we'll stick to the Min Heap it works fine and the complexity will be the same so in this first for Loop here we're pushing all of the elements into our Heap let's take a look at how this first part works we create our Heap and then for every item inside our goms going to push it into our Heap passing in the Heap and the number at each iteration and when we print at the end you see we have our ordered Heap one being the root node a left child of three and a right child of two three has the left and right child of four and five two is the parent of 6 and 10 four has a left and right child of seven and eight and five has a left child of nine that's our Heap then in the next Loop we pop elements off the Heap until the size of the Heap is K we use Heap pop to maintain the structure of our Heap so if I change K to be2 then the length of our nums which is 10 minus 2 gives us a range of eight so we'll pop eight items off our Heap let's see what that looks like and here we are popping the eight smallest items off our Heap leaving us with a heap which is the size of K which is two containing the largest two elements and then we have 9 and 10 so in the final line of our code we can Heap pop one more time to return the K largest element the overall time complexity is all of n log n less efficient than in the previous solution the reason is heat push operation is n log time we've explained why in the first solution and we're creating a heap of all n elements so constructing the Heap is n log n whereas the first solution maintained a heap of K size so inserting every time was log K not to mention the initial Construction in the first solution was also a lot more efficient because we were heapify anyway in the second part we are removing n minus K elements from the Heap and each removal takes log n time we know why inserting is log n so why is removing log n well it's essentially the same reason when we insert or Heap push we use sift up or Bubble Up placing the item at the end of the Heap and swapping upwards towards the root which could require operations up to the height of the tree which is log n to remove or heat pop We Carry Out sift down also known as bubble down or heapify down removing the root node the first element in the array or Heap then we place the last element in the array at that first position and then we carry out the swaps downwards again up to the height of the tree giving us log n also so that gives us nus K log n for the nus K heat removal and then we have one final heat pop which is one more log n operation and of course SPAC is of n since we're maintaining a heap of n size and then finally we have our third Solution on the left which is a more optimized approach to create the heat manually with only K elements inside a hybrid approach to the two previous Solutions following the logic in the first solution but executing the code more manually similar to the second solution and this approach is something an interviewer might ask you to write out if initially you gave the first solution just to make sure you understand exactly what's going going on under the hood and not just that you know the N largest function gives you the N largest elements using a heap for example so we create our Heap based on the nums array with K elements inside and in the second line we use the built-in heapy function to turn this array into a heap so from the first approach we know that hopy is linear and it happens in place which is good for space but overall that doesn't really matter in comparison what does matter is this gives us ofk time which is a lot more efficient than n log n in the second approach with n insertions so after creating our heap of K length for each remaining element in the array so for n minus K elements if the element is larger than the smallest element in the Heap which is the root node we replace the root with this element and re heapify this is our second section here so we're maintaining our Min heap of the K largest elements using Heap replace where at each point the smallest element at the root is the K largest element we use heat replace which performs a heat pop followed by a heat push with the given element we know each of these operations heat pop and heat push is log K so together that's 2 log K and we do this for n minus K elements giving us plus n - K * 2 log K after processing all these elements we know the root will most definitely be the K largest element so we can return this in constant time and finish for this optimized manual solution that gives us an overall time complexity of all n log K due to the mathematical simplification and spaces of K since we maintain a heap of size K so that completes this third solution and the entire question we went over a lot there but it was a good question to cover a lot of different Heap operations and build that knowledge so that in future questions we know exactly what's going on and we don't have to go through the EXP every time a lot of knowledge that we can use later in this Heap section K closest points to the origin is the next question where we are given an array of points on a graph where points I equals X and Y so an index in the points list represents coordinates on a graph so points is a list of lists as we see here where each nested list contains two numbers and we are also given an integer K this represents the number of points from the list that we should return which are the closest to the origin 0 0 they also give us the formula for finding the distance which you should have been taught in any High School level math class so I would half expect a candidate to know this one but it's not a major issue the formula is just the square root of the summed squares of the differences of X and Y and finally we're told we can return the answer in any order and it's guaranteed to be unique meaning there won't be a case where multiple points have the same distance and we have to choose between these points for example if K is 1 and the points are 1 0 and 0 1 so knowing we will approach this question with a heap and given the distance function it becomes pretty clear how we are going to organize our data pause now and give it a go otherwise let's see how it's done so here's our code and there's a few different ways to approach this as we've seen in the previous question but I like this approach the most we begin with our empty Heap and what we do is Loop over all the elements in the points array for each point we calculate its distance from the origin the origin is of course 0 0 so the distance equation simplifies to the root of x^2 + y^2 if you remember from the last question I said the built-in Heap Q module creates a Min Heap by default and the way we create a Max Heap is to negate the values this will work regard regardless if the data is positive negative or mixed so negating the values will make the largest element in the data set the smallest and since the heapq library creates a Min Heap that places the largest element now the smallest at the root having a Max Heap and knowing the originally largest distance point is at the root is very useful to us especially since if we use the Min Heap the last element is not necessarily going to be the largest we'll see this Max Heap in action in a second but first a quick note that when we take this somewhat hacky approach to building a Max Heap we need to remember to flip the sign back at the end if we use that value so it can get a bit messy if we're not careful luckily in this solution we're not going to need that distance value it's only there to organize our Heap so going back to our code we're iterating across our points array and calculating the distance then we insert into our Heap a tort of three items using Heap push the distance and the X and Y coordinates when we use a tupo or a list instead of a single item with these Heap C operations they will always use the first element when making their comparisons so we set the distance to be the first item in this tupo so although we can use lists I prefer tups since they are mutable and therefore a bit safer to make our algorithm as efficient as possible we limit the size of our Heap to K we do this by checking at each Loop if we've hit that limit and if we have we use Heap push pop with the new tupo Heap push pop first pushes an item onto the Heap rehap ifies and then pops returning the smallest item from the Heat this is not to be confused with heat replace which we've already seen heat replace first pops the smallest element and then pushes the new element same operations but different order in this context heat replace would pop the root and replace it with a new value even though the root is the largest distance we don't yet know if the new value is smaller in distance yet so if we wanted to use Heap replace we would have to compare the root first and if the new distance was smaller then we could replace it of course we check if the new distance is actually greater because we have reversed all our values in the max Heap however we can avoid all this trouble with Heap push pop which adds a new element onto the Heap so the size is now k+ 1 and again of course it Heap ifies with the new addition so after heat push popping we know for certain the route will be the largest original distance so we can pop that off and continue after checking all n elements we have a heap of the K smallest distances so using a quick list comprehension at the end here we can return these points time complexity is all n * log K since in the worst case for all n elements we are doing a log K insertion and space is all k + 1 which simplifies to all of K for our Heap and so that completes our K closest points solution top K frequent elements another similar style heaps question given an integer array nums and an integer K return the K most frequent elements you may return your answer in any order so a very Brute Force way to do this might be to manually iterate over the array for each element and store the element and its frequency in a dictionary then maybe sort the dictionary based on the frequency values and append the top K elements to an array and return it but we are way past that now so I tried to solve this one with a heap and it shouldn't be too difficult given our practice so far otherwise let's see how it's done We Begin by using the counter class from the collections module this takes in an iterable like our input array nums and it creates a dictionary where the keys are the elements from the given iterable and the values are their counts or the frequency under the hood this iterates across the input array counting the values in one pass so it's linear o of n earlier in this leak Code Practice I would do this manually but we are getting more and more advanced now and if you already know how to create this manually I would definitely recommend using counter in your interview it shows you are comfortable with libraries which is a big part of software engineering similar to how we are using the Heap Q Library instead of creating a raw Heap and Heap ifying ourselves every time like in the DAT structures practice so after taking the count we have all the data we need to pick the K most frequent elements we do this using a heap of course and we iterate over the items of the dictionary remember we went through the different ways to iterate over a dictionary very early on so we iterate over the items to get both the key and value pair for each number and its frequency until the Heap is of size K we Heap push it onto the Heap this is a log K operation that will occur K times and again in our tle of the frequency and the number we put the frequency first since this is the value we want our Heap operations to use in their comparisons then once our Heap is of size k for the remaining n minus K elements to make sure that we have the top k frequent elements in our Heap We compare each element with the root node so we compare the frequency that we pop off from our dictionary with the first item in the Heap and the first item in that tupo which will be the frequency if the new frequency is greater than the root frequency we replace the number in our top frequency Heap we do this with Heap replace which will also heapify and maintain our Heap finally using a list comparison we return an array of the top K elements with just the numbers and not the frequencies and this is O of K to iterate across our Heap and append these numbers to the array overall this gives us a Time complexity of of n log K when n is large and K is small our bottleneck is this iteration we go across the N minus K elements and potentially we replace every element SPAC is over n dominated by our counter list although we also have a k length Heap and a k length results list at the end so that's top K frequent elements another K style heaps question and now we can begin to see a common style of question where heaps are most useful as well as a few problem solving patterns we can reuse to tackle these questions here we have our last heaps question and it's a bit different from the K type question we've seen so far we are given an array of CPU tasks which is essentially just a list of capital letters in the alphabet and we are also given a call in time which is an integer n each cycle or interval allows for the completion of one task these tasks can be completed in any order but there's a constraint identical letter tasks must be separated by n intervals due to the calling time so in the first example n equals 2 meaning we have to wait two intervals to execute a task of the same letter so the fastest way to execute in this example is to process a then B and then wait and repeat we have to wait because after executing a there needs to be at least two intervals so in one of the intervals we can execute B and in the second interval there's no other option but to wait if n is one then we can pretty much execute task after task as long as they're not identical so we need to find a way to get the minimum interval time and return it and quickly before looking at the code let's consider the logic first this will give you the intuition to write the code yourself if you want to give it a go if we have a setup like this with 3 A's 2 B's and 2 c's with the calling time equal to 1 the very most basic approach we can come up with is to process the tasks in random order this gives us the following process B then C then B then maybe do a and then we have to wait before doing a again then we do c and then a one more time this gives us eight intervals on the other hand if we approach this Solution by evaluating the most frequent tasks first then we can avoid the idle time in the previous Approach at the start a is the most frequent task so we begin with a then we can't immediately execute a again because we have a calling time of one so after that we have two a's 2 B's and two C's so we can take either B or C and in this example we'll take B then we have two a's which we can now process and two C's as the most frequent so we can just take a after that c is the most frequent so we process C and then at this point there's one of each task so we can just add them in any order and now we have the minimum possible interval time which is 7 so we've established this most frequent approach minimizes the total interval time so how can we do this with our date structures well to keep track of the most frequent task we can use a Max Heap where the root node will maintain the largest element and we're not actually concerned with the task letters themselves just the time this all takes so we'll be adding the frequency of each task which if you remember from the last question we found a quick and easy way to get this information so here's our Max Heap and don't forget we need to negate the values since our code defaults to A Min Heap three lots of a tasks and two B's and two C's so in step one we count up the frequencies and in step two we create the max Heap in step three let's create some variables that will need later we want to keep track of the time or the interval which is the same thing in this case and we begin at zero and on top of that we want a queue to process our tasks and handle the waiting time this will contain a tuple of the task count and the time at which the task will become available again to execute and finally in step four we're going to process our tasks the way we do this is by popping off the most frequent task the root node of our Heap so popping off this minus 3 means we've processed it in that case we need to reduce its value by one obviously it's a negative value so we'll be adding one another reminder to pay attention when working with Max heaps because the negation can make things a bit messy so we remove this task from our Heap add one to signify we've processed it reify and increase our time interval by one although this task is not finished yet we still have two more to execute so what we can do is add it to our weight queue as we said before we add a TP of the number of tasks left as well as the time the task is available to execute again there's a couple ways to do this but since we are keeping track of the time/ interval we are currently on the cleanest approach I found is to use this weight que with two pools where the first element is the task count and the second element is the current time plus the cooling time so we have two more tasks to proach process which will become available again at the time too after this we can just repeat the process pop off the next most frequent element which is this two or Min - 2 reduce its absolute value by one reh heapify increase our time interval by one since the task is not finished yet we add it to our weight queue adding it with the current time plus the cooling time and since we are at time interval 2 now the task we previously added has become available so we can add this back to our Max Heap ready for processing in this case the values are equal but we shouldn't forget to reh heapify and so that's one more cycle and that gives us the Logic for this problem pause and give coding it out a go now otherwise let's see it written up here's the code and in step one we collect the frequency of each task again using the counter class in step two we create our Max Heap iterating over just the values in the dictionary since we're not concerned with the task letters which will be the keys we add the task counts to the Heap negating the values to build a Max Heap then we heapify in linear time in step three we quickly create our time or interval tracker as well as our que for handling the weight times and finally in step four we process the tasks we do this with a W Loop which continues as long as our Heap has tasks or we are waiting for tasks in our queue to become available and in a way this resembles code similar to our tree sections where as long as we had nodes to search an our que or a current node to process we would continue inside our W Loop we immediately increase the time by one then if our Heap has tasks they will be available to execute so we Heap pop the most frequent of the route and we decrease its absolute value by one since we process the task then if the current task is not finished yet so we have more of that letter to process we add it to the weight queue with the time it will become available again in this final if block we check if the task at the front of the queue is available to process again if so we add it back to our heap of course we only check the front of the que since that will always be the next available task and one thing to notice here that we didn't cover in the intuition is that this W Loop condition will automatically process idle time if our Max Heap is empty but our weight qu has items even if those items are not yet available the W Loop will continue to execute adding one to the interval time representing idle time until the next task in the queue becomes available so that's the code time complexity is n log n since we have a heap of up to n elements representing all the tasks which we are iterating over and for each iteration we are performing heat pushes and Pops which are log n operations that in the end simplify down to n log n and spaces of n for our task count dictionary our Heap and our weight Q so with that we complete this question and our Heap section next up we have our graph section and a graph is just a collection of vertices connected by edges a powerful tool for representing data especially when scaled up for example Facebook's social graph to map your network of friends and interactions and even neur networks used in deep learning are at their very core just graphs as always I'd suggest to get comfortable working with the graph dat structure and all the associated operations before taking on the problems creating the graph inserting deleting printing searching and all the rest I've included here a reminder on the basics creating a graph using a dictionary or a hashmap what this looks like and how we can iteratively search both breadth and depth first if you used a different alternative to the DAT structures video this might seem foreign to you since of course there's many different approaches however hopefully this isn't too far off from the code of these traversals you'll immediately see that graphs are not too far off trees and even from the diagram they look pretty similar so when we Face these graph questions as we've increasingly seen as we progress through the leite code practice we can reuse a lot of the problem solving patterns and the code we've seen before so I'm not going to go through this slide since the code is from our date structures video it's just here as a convenient reminder for us instead let's crack on with the first question for this one I've added the details in the notes it seems that the elite code website is down right now but I managed to find some screenshots on the problem either way let's give it a go in the Clone graph question we're given the node of a connected undirected graph and let's pause there to see what this means so we're getting into the weeds a bit here but I've included this slide on the different types of graphs since the question mentions it a connected graph is a type of graph where there exists a path between any pair of vertices meaning it's possible to start at any vertex and reach any other by traversing the edges for the most part graphs will be connected it's not too often you'll see a disconnected graph question as for the directed graphs they can be strongly or weakly connected if they are strongly connected then by strictly following the edge directions we can again reach every vertex directed graphs will be considered weakly connected If Only By ignoring the directions of the edges can we reach any vertex from any starting position and of course disconnected if there is no chance whatsoever to reach some Vertes from certain starting points so now that we know what a connected undirected graph is let's go back to the question and here we're asked to return a deep copy of the graph we've already seen deep copies before basically a clone who has the same properties as the original object but does not share the same references in memory and that's summarized for us here in this diagram where the colors are representing if the object is the same in memory we're also shown what the node in the graph looks like this is a Java class so I've added the python here above so again nothing too complicated pretty similar to all the nodes we seen before where for example in a binary tree we would have a left and right child but in this case we just have all the Neighbors in a list and Below we're told we'll be given one node from the adjacency list specifically the first node and there's some text here to describe the input list but if we head over to the Whiteboard first we can quickly summarize it so this list of lists represents our input from the question and the list at each index represents the neighbors of a node in the graph and the value of that index is the value in the node so in our graph the value node one has neighbors of two and four the node two in the graph has neighbors of one which we've already added and a neighbor three the node three has neighbors 2 and four and the node four has neighbors 1 and three which we already have and so that's the original graph from the question represented in this adjacency list so that's the question pause now and give it a go otherwise let's see how it's done here's the code and essentially we're going to be traversing the graph from the given node breadth first although depth would work too we keep a dictionary called clones mapping each original node to a deep copy during ersal these clone node classes also have their neighbors is updated to maintain the graph structure and before getting into the walkthrough I put this code side by side with our bre first traversal framework so we can see just how identical it is something we saw often in the tree sections where we have our main traversal framework and we adjust it based on the question so we begin with an edge case check for an empty node followed by our queue for maintaining our nodes for the traversal here we have our clones dictionary which will keep track of the nodes we create this would be our traversal list in the main framework of course for trees this is not necessary since there is no chance of revisiting a node we have our Loop over the que popping the current node to be processed after we can carry out operations necessary for the question here we add the node to our traversal list but here we'll be creating a node clone of the neighbor in our dictionary we're also adding the neighbor vertices or the nodes to our Q in both these lines here and here so the core framework is there but we make some adjustments along the way like looping over the Neighbors in this question and we'll explain each difference as we walk through the code so let's begin at the start a standard deck with the first node passed in this CU will contain only original nodes so I've left the original nodes in black and the copies are in purple and we also have our clones dictionary again initialized with the first node this will be a hashmap where the keys are the values of the original nodes and the values of the dictionary are the Clone node copies so these two initializations here set up our traversal then we have our while loop which continues as long as our queue has nodes to process each while loop iteration is represented in black with the number by the side we pop off the node from the queue and we assign the clone from the dictionary to this current clone variable add at this point in the code the Clone will always be available to assign and we'll see why in a second so then we Loop over the neighbors of the original node this for Loop has two main responsibilities if the neighbor has not yet been visited so we do this by checking our clones dictionary we want to ensure it's given an entry so we can build the correct graph with the copies we also want to queue up this node for our search since it's not yet been processed and although we've created the clone of the neighbor we've not yet checked if itself has neighbors and so this leads us into our second responsibility of the for Loop for each of the current nodes neighbors we are processing remember these are the neighbors of the original node we want to add the same neighbors to the Clone and of course we want those neighbors to also be clones and we've just created the clone of the neighbor so it will definitely exist this happens outside the if block since we process every node exactly once so whether or not the neighbor is in the Clones list is not a concern here we just need to make sure that the neighbor is linked so these lines in red here indicate every iteration of our for Loop so if we take a look at our adjacency list here we see that one has the neighbors two and four so in this for Loop the first neighbor we see will be the two at this point 2 is not in our clones dictionary so we create the copy node and add it append the node to our que and right at the end make sure that the one copy has a neighbor of the two copy and we repeat the process with the full node in the next iteration of our W Loop we'll be popping off the two that we just added to the que assign the Clone to the current clone variable from the dictionary and inside our for Loop the first neighbor we process will be one as we can see in our adjacency list one is already in our clones meaning it's already been added to the queue and traversed so we don't need to Traverse it again we just jump to adding the node one clone as a neighbor of the node two clone and in the next iteration we process the three neighbor adding it to the clones dictionary since it does not yet exist adding it to the queue for searching and making sure the node 2 copy has a node 3 copy as a neighbor then in our queue we pop off the node four at this point all the nodes have been added to the Clone dictionary so we just need to update the neighbors and we do the same in the next W Loop iteration popping off the three and making sure it has the correct neighbors and at the very end we return the first node in our clones graph using the value from the node that was passed in to find it and if we quickly scan our code we can see that everything's correct one has neighbors of two and four two has neighbors of 1 and three four also has neighbors of 1 and three and three has neighbors two and four and they are all copies so that's our code and that's the walkthrough time is O of V plus e each node is added to the que and processed exactly once that's o or V for each vertex and for each vertex we are looping over its neighbors we are checking every Edge twice since we are checking every node's neighbors but this will boil down to give us o of e overall giving us o of V plus e and spaces o of V are Q has at most all the vertices in the graph and the Clone dictionary will also maintain all the vertices so that's how we can clone a graph a ni question to experience the traversal Concepts we've seen before but this time in the graph dat structure here we have some core operations on graphs something similar to easy questions we have find the largest node find a cycle in the graph and count the number of edges and we're not going to go through this line by line since they're not too difficult for example to find the largest node we just rework our bre first search ever so slightly adding a track variable and comparing the value at each node of course we just reverse the greater than operator to a smaller than to find the smallest node for finding Cycles we perform a depth first search and use a set which means no duplicates allowed we Traverse across the graph at each point checking if we have already visited this node pretty similar to our framework traversals where we check if a node is in our Traverse list to avoid repeating except this time we specifically return a Boolean based on the check and finally this one is really neat we want to count the number of edges and you might think the best way to do this is another traversal of the graph keeping count of the edges as we jump from node to node but actually we can just check the adjacency list so the dictionary that represents our graph and count the number of neighbors for each vertex so there's some useful core operations for us to reuse and I've linked some more here this should remind us to always look back and see how we can reapply and rework previous patterns to face the current question our next graph's question is another medium but I think this one should be a hard it's called cheapest flights with case stops there are cities each city is a node in the graph and we are given an array of flights which contains nested lists of three integers the starting from node the going to node and the price of the flight along with that we are given three integers The Source node number the destination node and K which is the max number of stops or layovers we can perform on our journey finally if there is no possible route between the nodes we should return minus one and we see here from the first example that the cheapest path from 0 to 3 is 700 going over the one node since we are allowed at most one stop if we were allowed more stops we could have gone from 0 to 1 to 2 to three which would have been cheaper let's now consider our Solutions the most famous shortest path style algorithm is dxas using it in this problem we would have to adjust it since we have this K condition and the solution is less clear and less efficient than this next one we will use Bellman Ford the Bellman Ford algorithm's primary principle is that it starts with a single source and calculates the distance to each node the distance is initially unknown and assumed to be infinite But as time goes on the algorithm relaxes those paths by identifying a few shorter paths hence it is said that bman forward is based on the principle of relaxation and by relaxing we simply mean updating the shortest path estimate to a Vertex if a shorter path is found via that edge so that was a lot of words but with this example hopefully we shall clear it up for our solution we're going to start at node Zer and we're going to check all the edges in the graph on each iteration finding the minimum cost of travel to the we visit since we are looking for the minimum price we begin with our prices list set to Infiniti so that when we check later if there's a new minimum it will for certain update and since we start at node zero we initialize the price to be zero since it costs nothing to travel from0 to0 and we're going to perform multiple traversals overall graph and at the beginning of every traversal overall graph we update our temporary prices table to match our main prices table during our traversal we make changes to the temporary table and when we finish we up update the main table based off the temporary table and we'll see why we do it this way as we work through it in the first reversal we see we can go from 0 to one and it cost 0 plus 100 so there's two key things here when we get the current price to reach a node we check the main table and when we compare the minimum cost of travel we do it against the temporary prices table since this could be updated multiple times in the same traversal so for now this cost to travel from node 0 to Node 1 is the cost to travel to node 0 which is zero checking our main table plus the 100 Which is less than the minimum price we currently see in the temp table which is infinity only when we finish one traversal which is one Loop over all the edges in the graph then can we update the original prices table the next Edge we search will be from 0 to 2 which is 0 + 500 less than infinity so we update the table and the last Edge we check will be from 1 to 2 so we're checking if we found a new minimum to reach two checking the price to reach one from the main table and pling to it this 100 the price to reach one is infinity so we already know the minimum price is not going to update since it's Infinity we know that in one Loop when K is zero it's impossible to reach two from one and what we can do in that case is if the from load at any point is infinity we can just skip the evaluation to make things more efficient since we know for sure it won't update so we finished our traversal and we can now update our original travel price table now let's take a second to consider how many traversals is necessary we're going to do k + 1 why well because think about the base case if K is zero we need at least one traversal to determine the minimum costs if there is a path that exists so one traversal gives us zero stops so extrapolating it out k+ 1 will give us the cheapest cost to making K stops so back to the problem and on the next iteration we see going from 0 to 1 will be the price of 0 plus the 100 well this already costs 100 so we know from this point forward any more number of stops will not change the price going from 0 to 2 is also 500 and this is also what we have in our temporary prices table so any more number of stops will not make that cheaper either this time however going from 1 to two which we calculate as the price to reach zero to reach Node 1 and then to reach node 2 is going to be 0 plus 100 plus the new 100 giving us 200 a new minimum for node two so we change our temporary prices table the current traversal is finished and we can update the original table and that's two traversals in total so we stop there and these are our final prices hopefully you can see why we need this temporary prices table now if K was for example no stops allowed and we directly updated One's price to B 100 in the main table so we have 0 for Z and 100 for 1 on the first reversal then checking 1 to two would give us a price of 0 plus the price to reach one from zero and then 1 to 2 0 plus 100 plus 100 giving us 200 which of course when we have no stops is the wrong answer here's the code for this and it's pretty much identical to our explanation so no need to repeat or walk through we have our prices table that updates at the end of every traversal all initialized to Infinity except for the source starting node we do our k+1 traversals at the beginning of each creating a new temporary prices table based off of what our original prices table is when our traversal finishes we update the original table to keep the temp prices table intact on the next traversal and we iterate across our graph checking every node and we really only have two cases first remember if the from node in ersal is infinity we can skip it since at this point in time it will be impossible to reach for example when we went from 1 to two in the first traversal so that's our first case and in the second if the new cost is less than the current cost in the temporary prices table just like we did in the walkthr again the cost is simply calculated as the cost to reach the current node from the main table plus the current cost to reach the next node The Edge we are currently looking at if this is true we update the temporary prices table with this new minimum value when we finish art reversal all that's have to do is update the main prices table and then return the answer we either return the minimum value to reach that destination or if that value is infinity then we know it's not reachable and we can return minus one like the question asks us the time complexity for this is O of K * e pretty straightforward we have K Loops we can ignore the plus one and for each Loop we check every Edge and space is overend for both price tables which in this case we use an array to represent so that's the cheapest flights with K stops question also included are two different approaches if you're interested one using a rework of Dess algorithm and another with a Brett first search approach which we've seen more than a few times now our last question in the graph section is called course schedule and I like this one because it reminds me of that Bill Gates story where in high school he was asked by the teachers to automate the school's class scheduling system and he jokingly said he put all the girls in his class even though he didn't speak to them so another benefit of knowing how to program in this question we're given an integer called num courses which is the number of courses a student has to take and this is zero indexed so a num course of two will be course z and course one we are also given an array called prerequisites which tells us which course we must take first before taking the second the order is a bit confusing I would have preferred to have it the other way around but the first element is the target course and the second is the prerequisite and in the constraints we see this is limited to one course prerequisite per course so prerequisites is a list of lists where each nested list has two numbers the prerequisite and the course and we need to return true if it's possible to complete all the courses so looking at example two for two courses total we see there is a circular dependency to complete course one we have a prerequisite of course zero and to complete course z we have a prerequisite of course one making this impossible so if you want to solve it I'll give you a hint now or you can pause and attempt it solo we can represent this problem with a graph of courses where each vertex is a course and the edge indicates a prerequisite so that's the hint and there's still a lot more involved so let's see how it's done we have two ways to approach this iterative and recursive we we'll walk through the iterative this time since I think it's easier to follow but definitely give the recursive a goal in the notes since the run time is a bit faster and before getting into the code let's first consider the question we have an num courses of five and this prerequisites list here mapping this to a graph and we get the following to complete course zero we need to complete one and two and to complete course one we need to complete three and four and to complete three we need to finish course four we can also see that 4 and two would be our base cases in the recursive no prerequisites needed transitioning over to to our code and we see we can use a dictionary to represent this graph in the first part of the code we build an adjacency list which means our graph we've already seen this before for example as an input in the Clone graph question each key in the dictionary represents a course and the values are its prerequisites for example course z has prerequisites 1 and two also since we have experienced the usefulness of python modules a few times now as we get more advanced I think it's worth mentioning that we can avoid pre-filling the dictionary with empty lists by using the default iary from the collections module this will prevent errors when we look up missing keys in the dictionary by returning an empty object or a base value of the type specified so after we build our adjacency list We Begin an iterative depth first search we go through each course since it's zero indexed we have no problem going through a simple range and for each course we look for Cycles a cycle or circular dependency will of course mean that the schedule is impossible and we've already seen how to check for Cycles in our core operations slide earlier so what this code does is if we begin at course zero we see it has a prerequisite of one and two we'll depth first search to the one which first has a prerequisite of three and then four depth first search to the three and that leads us to the four checking course fours prerequisites and it's an empty list meaning we know for certain we can complete course four therefore when we go back to the three we know three is possible and we go back to the one one is possible we already know four is possible so now we can complete one which takes us back to zero at zero we check course two course two also has no prerequisites it's an empty list so we know we can do two for sure and then we can also do zero the way we do this in the code is nicely written out for us to follow a stack as alwayss to maintain our nodes for searching and this time we add the graph node in a tuple with an empty set this is in blue to make it clear at the start of each while loop iteration we push the current course onto the stack with a set to track which nodes we visited on our search for the current course's completion so we have in Black our large for Loop here and in red is each iteration of this W Loop of course the very first W Loop in each large for Loop will be the course from the range that we are evaluating so at the very beginning we add course zero with an empty set and then we pop it off and check if it's in our visited set on the first while loop this will always be empty so we add the current course to the visited set and add the current course's prerequisites with the updated set and we continue repeating this process pop off the one check if it's been visited and add its children after visiting the one and updating the set this way we explore all the prerequisites of a course before moving onto the next course in our for loop as well as the prerequisite of those prerequisites if we encounter a course we've already visited on the same depth for Search exploration then the course is impossible and we return false and bear in mind we can have different depth for Search exploration paths so we can reach the four by visiting 0 1 and then jumping to the four directly or by going Zer to one then three and then the four at the end of each Loop we know for certain that the course is possible to complete without running into Cycles so we can set the adjacency list for that course to an empty list this optimizes the time of the solution if we have to check this list again removing redundant Explorations so at the end of this for Loop Pier no more nodes to search in our stack in the adjacency list we give the zero course no more prerequisites time complexity for this solution is o v plus e where V is the number of courses are vertices and E is the number of prerequisites are edges building the adjacency list takes all of e time since we iterate through all the prerequisites the iterative depth for search takes or V plus e time in the worst case because each Vertex or course is visited at most once in the outer for Loop which accounts for all V time and for each visited vertex we explore all its neighbors the prerequisites in the Inner Loop which is proportional to the number of edges e giving us overall V plus e and the space complexity is also V plus e the adjacency list requires V plus eace in the worst case where every course has prerequisites additionally the stack in the depth for search has a maximum depth of all the vertices as well as the visited set so they will each have vspace but overall we are dominated by the adjacency list giving us V plus e and so with that we complete this course schedule question and our graph section so that was the final section of this leak code practice and we are now finished we've gone over everything in the introduction so I'll keep this short by law of nature if you've made it this far you're ahead of 99% of people and you're over the hump of the hard technical coding skills but definitely continue working on these problems till they become second nature and don't forget to continue the rest of the work in this journey learning the ins and outs of software engineering as a field applying for jobs behavioral skills and all the rest and I would wish you good luck but if you've made it this far and completed all these questions and put in this much work and effort I have no doubt in my mind that you don't need the luck