data structures and algorithms DSA these words are very overwhelming for every college student right now with CEST topics patterns and courses I know it's very very easy to get lost but here's the truth you don't need to know everything in this video I will distill DSA into the most important Concepts and techniques all in just 10 minutes whether you're looking to level up your problem solving skills or build a strong Foundation this is a shortcut for understanding the various patterns that exist in data structures so so without any further Ado let's directly Dive In by the way if I'm subscribed to my channel don't forget to subscribe because I post a lot of similar content on DSA Java software engineering and life as a software engineer so I already made a video on DSs syllabus which is like an extensive version of this video where it talks about the language that you need to pick what are the things you need to learn in a particular language and then all the DSA topics extensively this video is more on the lines of understanding the various tricks and patterns the various problem solving techniques that exist so that you ensure that you have covered the basis and you don't miss out any topic so there are two things here one is the data structures and one is the algorithm so you basically use an algorithm with the help of a data structure so this concept should be very clear right from the start and within algorithms there are various sort of algorithm paradigms like dynamic programming let's say our two pointers let's say sliding window etc etc so now keeping this in mind let's jump on to the first op so now whenever you face let's an array question the first important technique that can be very useful to solve problems is the two- pointers technique some of the key problems from this can be two sum variations of two sum various variations of three sum Etc next up is fast and slow pointers which would be helpful for cycle detection in a link List middle node identification and Link list and efficient data traverser so the key problems from this section are link list cycle middle of the link list find the duplicate number Etc I mean I'm just giving you a list of key problems so that it help you to understand things and solve those problems according to the topic but I'm not saying that these are the only problems you need to solve no you need to solve more number of problems but this will be a good start to understand the various pattern and you will get all of these problems lead code GS for GS or any proper coding websites next up is sliding window so you should Master this technique for efficient array and string manipulation the some of the key problems are longest substring without repeating characters minimum window substring and sliding window maximum you should know to deal with matrices there are a couple of easy problems on matrices which are sometimes asked and there can be set Matrix zeros SP Matrix which a very famous problem and the rotate image next up is stxs and qes data structure so sometimes you can use stxs and qes data structure as an data structure to solve a bigger larger problem but sometimes there are specific problems which you only need Stacks to solve a very famous problem on Stacks is the histograph problem which you definitely need to solve any sort of parenthesis related problem like for example the valid parenthesis also can be solved with the help of stacks next up is hashing a very important topic again you should learn about the hash maps and hash set for C++ it would be an unordered set and an unordered map it helps in efficient lookups counting and handling duplicates the key problems are longest substring without repeating characters group anagrams Etc there is a video which I made where I list down all the important hashing problems so definitely go and check that out because that would be a good start for this to next up is a very very important topic that is recursion without recursion don't really jump into learning any other things by the way the order I'm mentioning this is the exact order which you can follow and this will really help you a lot because if you don't know recursion if your concept about recursion is not clear you're not able to write a recursive recursion properly then if you start let's say with trees or dynamic programming you're going to struggle because it's not just about dynamic programming algorithm it's because your inefficiency to write recursion so that is why I would highly recommend you to learn recursion properly you can pick any dynamic programming problem and try to solve it by recursion because dynamic programming is just nothing it is just storing the states of recursion by the way I have a very nice video on dynamic programming in around 15 17 minutes where I explain the basics of recursion as well as dynamic programming and that would be a good start so definitely go and check it out related to recursion you can also learn about a subset problems for example uh like printing the power set and then you know learning to print the permutations of a particular string all these things would be helpful another very important topic is closely related to merge sorting and that is merge interval so learn to merge insert and intersect intervals for scheduling and optimization a couple of key problems are merge intervals interval list intersections employee fee train this is a very important topic and you shouldn't miss it a couple of Link list problems are also important for example the in place link list manipulation reverse link list reorder link list swapping noes in a link list and this should hardly take a day these are very easy problems another key topic which people don't don't really talk about is a cyclic sorting so two very key problems from this section is the fine missing number and the fine First missing positive these are two very important problems and you shouldn't miss them bitwise manipulation again very important sometimes you need to use the concepts of bitwise manipulations as an helping hand to solve larger or more complex problems but sometimes there are problems which are just related on bitwise manipulation a couple of them I'm dagging out here single number counting BDS power of two etc etc couple of greedy technique problems which you need to solve as well and for that you also need to know how sorting works a lot of GD problems are based on sorting some of them might not be for example the gas station problem or the jump game problem they fall under the category of greedy now you should know about priority cues and heaps you should know how to code priority q and heaps from scratch although you don't really need it all the time but it's always good to have that technical knowhow now under this priority que there comes the concept of two hips which is slightly a harder version of the priority que but it is very very important the key problems are find medium from a data stream sliding window medium meeting room 3 ET I talked about merging a couple of minutes back and a very important topic that I missed from there was the keyway merge so in this type you have to merge sorted arrays Or List efficiently using priority cues couple of key problems are merge K SED list K smallest element in the metrix OR find K pairs with smallest sum you will find these problems on lead code next up is top Elements which is generally based on quick sorting for starting with this paradigms make sure that you understand the concept of quick sorting and how it works and why it works so this problem revolve around finding the top key element in unsorted collection efficiently a couple of key problems are the top K frequent elements K closest points to origin K largest element in Array and so on next up is a very very important topic that is B research I always say that b resarch is the easiest and most toughest algorithm because the algorithm itself is very simple as we are taught in schools and colleges but when you actually get a problem to solve you don't really figure out that hey we have to apply B resarch to this problem so there are two B resarch patterns that exist in my opinion loely one is the where you have to basically understand the concept of upper bound lower bound and you have to do a b search within an answer space couple of examples are aggressive cows painter partition problem Etc this is a very uh easy problem approach once you understand that this is a way to solve these type of problems it's very easy to grasp it but if you had not seen the problem at all then it might be a bit difficult right so basically these type of problems the problem doesn't scream that hey I'm a bind search problem to you so basically you need to know that okay this is the search space of my answer and within this I have to do a bind research and perform validations and update my low and high pointer accordingly another version of Bindy search is what I call the modified Bindy search where basically problems like search in a rotated sorted array finding the inflection point in a rotated sorted array single element in a sort array Etc comes into the picture so in this type of problems the array is nearly sorted but not exactly sorted but my research would still work next up is backtracking you could have also learned this with recursion but also you can learn it now as well so backtracking is solved using recursion only so basically you try to explore multiple Solutions and then if that doesn't work out you kind of backtrack and try out the next iteration very famous problems are end Queens word search Sudoku solver Etc and also when you are solving backtracking problems make sure you understand the time complexity of all the backtracking approaches they are usually exponential so it might be a bit tricky mathematically to understand but once you get your head around it it's very simple next up is trees trees are very easy topic but there are a lot of problems and parms to solve first you need to understand the pre-order in order postorder traversals and then also you need to understand the modest traversal which basically does it without a recursion this is something that people generally tend to miss but I would recommend you not to miss it and then in trees there are a lot of things but two most important ones are the B trees and the B search trees and there are specific problems related to that also ensure when you are getting any problem on trees try to figure out whether it's a binary tree or it's a binary SE tree people tend to make mistakes based on that highly recommend you not to do the same because both have very different properties binary s tree is a specialized version of binary tree where those in order traversal basically comes up in a sorted flavor so that is why it has a unique property to its own and that is why when it's a b search tree you can tackle the problem in a very different way again I made a video and I have a sheet on the important problems the 50 important problems on trees which you can obviously go and check it out after watching this video now also with trees don't miss out rice it will just probably take one day to solve and learn problems and tries there are just two three important problems basically they're called prefix trees for efficient storage and prefix matching so first problem obviously would be to implement a try or a prefix tree where you learn to insert search and delete Words efficiently using a try then you can try the word search two problem or the longest common pric problem so I've kept anid programming and graphs these are the two most s after and widely feared topics for the last so that by this time you're almost done with all the important topics of DS so again I have kind of divided dynamic programming into multiple patterns so we'll see them one by one the first one is the fibon sequence which is the easiest version and it's more like a one sort of a pattern which deals with sequential problems with overlapping sub problems some of the problems being climbing stairs how robber decode way Etc and dynamic programming first ensure that as I said that you should have your technical know about recursion very solid learn about memorization tabulation and then go for the space optimization this is the exact approach that you should follow in dyn programming having said that now let's move on to the 2D version of man programming where which comes under the subset some NEX problems so basically here use a 2d DP table to track subsets or choices the choices being one or zero that is to take or not to take some of the problems are 01 n problem partition equal subset sum Target sum Point change and these problems are mostly similar so if you understand one problem pattern other ones would be a CI workor then you can also apply this concept on string matching and transformation for example use a 2d DP table to handle subsequences or edit distances some of the important problems can be edit distances distance subsequences Etc next is Matrix DP which is also very similar version of 2D DP where basically you apply DP on a 2d Matrix some of the important problems are minimum part some minimal Square Etc next is a slightly harder version of the DP problems that is the partitioning problems so you have partition strings arrays or sets with certain constraints some of the important problems are palindromic partitioning burst balloons split a larges sum Etc also one of the important problems that comes under this umbrella is the metrix chain multiplication so don't forget to miss that that's a classical problem actually and then there are a couple of optimization problems based on DP for example the water break best time to buy and sell stock version four I would actually recommend you to solve all the versions there are six versions of buy and sell stock so I would recommend you to solve all of them and then there is the paint house problem which you can also do which is also a very nice uh DP problem so to learn graphs again I have divided graphs into these following patterns so before learning graphs you have to really know BFS and DFS these two algorithms very simple algorithms but all of the graph problems are actually based on either BFS or DFS and the best way to learn BFS and DFS is to actually solve problems so most of the problems are solved generally using BFS and under BFS there comes one is the quintessential vanilla BFS problems uh for finding shortest path where you explore layer by layer you uh find out the number of connected components some of the problems are number of islands very famous shortest path in the Min Matrix Word ladder Etc there are a lot of problems and again you will find all of these problems in my video dedicated on graphs I will attach the link to the video in the description down below or you can find it from my DSA patterns playlist then there's an important pattern called multisource BFS so it is basically doing BFS with multiple start points right initially at the queue you add all the potential start points and then you do sort of BFS and exam important problems are rotting oranges walls and Gates shter brid next up is a very important pattern which you really can't miss and a lot of students Miss is the weighted BFS with small weights where dixer really doesn't help one very classical problem is the 01 BFS but there are other nice problems too you would find that in my graphs also I have a lecture on graphs uh where I have taught you graphs and taught you all these important topics alternatively if you want to learn graphs you can actually go and check out that playlist it's a bit old but that would be definitely helpful next up is the D algorithm right for finding the shortest path D algorithm actually comes with the picture for helping you to find shortest part when there is a weight involved or a cost Associated for each Edge or each part some of the important problems are network delay time path with minimum effort and cheapest Light Within K stops next up is DFS which is the algorithm first you have to learn and then maybe you can solve a couple of problems like let's say flood fill plasic Atlantic flow Etc and after DFS you can learn topological sorting now see a lot of people solve topological sorting with the help of DFS but I personally find topological sorting with BFS way more easier uh if you want a video on that I am more than happy to you know actually make a detailed video on topological sort where I cover all the important problems and topological sorting with DFS but also you can learn with DFS because that's where you find most of the tutorials couple of important problems are sport schedule two alien dictionary very important minimum he trees so next was a very important topic Union find I would highly recommend you to check out my lecture Union find and see the adjoining problems that are there minimal spanning tree actually comes under the union find where you basically use a Cru algorithm and a couple of important problems related to that is let's say connecting cities with minimum cost cost to connect All Points Etc and the last important topic related to graphs can be graph coloring or Viper type graphs problem it's not very tough it's fairly simple and only a couple of problems are there in this pattern so maybe use graph biper Tite M coloring problem all these will come into this section also there is a problem about cycle detection in graphs in both directed and undirected so for the directed one you can take use of the topological sorting to the tech CLE so this is mostly it I'm not sure whether I was able to cover uh in 10 minutes as promised might go into 15 minutes but I think it does the job pretty well so basically with the help of this video you would understand that hey these are the topics that I really need to worry about and once you're done with this only then go to the advanced topics like segment trees fic trees you know SC strongly connected components all these things but this should suffice for you at this moment and it will also help you to device the topics when you need it right so if this was helpful don't forget to press the like button and comment down below what is the next DSA topic you want me to make a video on or I would be w't happy to make a tutorial videos on as well so don't forget to subscribe to my channel I will see you in some other video till then stay safe and goodbye