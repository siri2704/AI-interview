ready to crack the coding interview the neat code 150 represents the most important leak code problems you need to master carefully selected to cover all major algorithmic patterns that top tech companies test for in this course parth will teach you how to solve all 150 problems building your problem solving toolkit and preparing you to Ace technical interviews at companies like Google meta and Amazon Hello friends hope you're having a fantastic day today so in this course we are going to complete all 150 questions from the famous need code 150 list now I can guarantee you that if you understand all the pats and be able to solve all of these 150 questions you would be able to clear 99% of all the other technical interviews out there no matter how difficult or how prestigious the company is you would be able to crack that interview so in my opinion this course is going to be very important for your career and that's why I try to put my utmost attention on creating and curating this course now let me give you a brief background about myself my name is par vas and I have been working in the IT industry for close to 10 years now I have bachelor's and master's degree in uh computer science and I have started my career as a junior developer and made my way through towards a Solutions architect uh I have worked at companies like RBC Nokia Microsoft and currently employed by clex and I'm very passionate about computer science and technology I also run my own YouTube channel named destination Fang and I would really appreciate if you can go and support that channel as well because your support would motivate me to create more videos like this in the future so hopefully you can go and check out my stuff now I would also like to give shout out to need code the famous YouTuber who has actually come up with this need code 150 list uh he has put in tremendous effort in creating this list and sharing it with all of us so we can benefit from it so once again thank you need code for providing us with the list so this is going to be a very long journey that we are going to stay together so now without any delay let's get started with the need code 150 list so the lead code problem we are going to solve now is called contains duplicate we can see that this one is a lead code easy problem and also an extremely well-like problem the statement is quite straightforward that we are given an integer array called nums now we need to check that if there exist any particular value more than one times at least twice then we need to return true saying that yes there exist duplicates in the given array and if it does not exist we need to return false so let's try to understand this with an example suppose this is the input array we are given now we can notice that value four appears twice in this case which means there exist duplicates in this given input array nums so we need to return true in this case now if say for an example we are given one more nums array and all the values are unique or we don't see any duplicate values so basically in this case we can return false saying that there does not exist any duplicate values and the statement is very simple to understand let's see that what is going to be the most common root Force approach we can use to solve this problem we will take the first value and we will check against every single other value possible that whether one is present or not we identify that one is not present so in this case now we would move on to the next value two and once again repeat the same operation for three repeat the same operation and at the four we would realize that there exist one value four that is being repeated so basically found a duplicate so we will return true in this case and say for an example if we don't find duplicates and we return we reach to the end of the array then we can simply return false saying that there does not exist any duplicate values you straight away you can see that what is the issue with this approach well the idea is that for any particular n value or any particular work we will have to repeat the same operation for every single other values which means the time complexity is going to be biger of n Square which is definitely pretty expensive uh and there are ways to make it faster so the first optimal approach that comes to our mind is uh basically sorting if we can somehow sort the given input array then things would become much easier let's say that we are currently given an input nums and the values are scattered all across the place and we can find that there are some duplicate values over here as well uh if we sort this given input array then the sorted input is going to look something very similar uh and then for the sorted input all we need to do is just keep checking all the values with its like uh next value or previous value and uh over here after one we find Value number three which means it is not possible to have one in the remaining array because this is a sorted array same way for three we found value number five which means there is not possible to have another three inside the remaining array but for five because there there exist a duplicate it has to be very next to it we found a duplicate and we can simply return true in this case very easily now this is a much better approach than our brute for Brute Force approach but let's see that what is going to be the time complexity well it is going to be big of n log n because it takes n log n time to sort the given input array and the question is is there a way we can do something better and the answer is yes the fastest approach in this case is going to involve something where we need to keep track of all the elements that we have already seen and we should be able to access them quickly and these are the two uh basically conditions that we need to follow and for that the best data structure in this case is going to be a hash set that it cannot contain duplicate value values and it is it basically finds any particular element inside the hash set in B of one time so suppose this is the array we are given as an input now what we will do is that we will iterate over this array and for every single value first we will check that whether this value is present inside the hash set or not if it is not present we will simply just add it to the hash set and it move to the next value and repeat the same process so let's see that how would that work and let's say that this is going to be our hash set okay so first we are at Value number three currently value number three does not exist inside the hash set so we will simply add value number three and move on to the next value once again value number one does not exist so once again we would add value number one uh now four four also does not exist and now once again we would move to Value number one again at Value number one we would check that whether this exist inside the hash that or not and yes it does exist inside the hash that and we can check that in big of one time which is awesome so in this case we can say that because there exist a value that is already present inside the hash set that we are trying to add to the hash set which means the given array contains duplicate so in this case we can simply return true and say for some reason this value one is not present over here and let's say that this value is may be six so six currently does not exist inside the hash set so we will add six over here once again we are at Value number five five also does not exist so we will add five to the hash set and now we have reached to the end of the array so if we reach to the end of the array we can simply written false saying that there does not exist any value that is duplicated if we see time complexity in this case the time complexity is going to be biger of n why because we are simply iterating over the given input array once and for every single value even though we are checking that whether it's present inside the hash set or not it can be done in big of one time that is the power of hashing functions like hash set and hashmap and uh if we see space complexity space complexity is going to be biger of n as well because we will have to use one more hashset to store all of these variables but still this is much better compared to our Brute Force approach that had the time complexity of basically big of n squ so now let's see the coding solution for this one so the coding solution is going to be quite straightforward first of all we are going to initialize our hash Set uh that we are going to keep track of the seen numbers then we are going to iterate over every single element that is present inside the nums array and for each of those elements we are going to check that if our hash uh set contains that particular number or not if it does contain then we can simply return true saying that we have detected a duplicate if it does not contain that number already then we will just simply add that number say for an example if we end up iterating over every single element in the array and we reach to the end of the array which means there are no duplicates so we can simply return false let's try to run this code okay seems like a solution is working as expected let's submit this code and as expected code runs beautifully it beats nearly 90% of all the other solutions that are present on the lead code which is pretty awesome and uh the solution of this code is present in our GitHub repository so feel free to go and check it out from there thank you so the lead code problem we are going to solve now is called value anagram we can see that this one is a lead code easy problem and also an extremely well-like problem basically we are given two strings s and t now we need to return true if T is an anagram of s and false otherwise now what is the definition of an anagram basically if every single character that is currently present in T is also present in s then they are anagram of each other not more not less so let's try to take an example example suppose in this case we can see that currently s has the words cat and T has the word Tech now we can see that c is present on both uh so that's good same way a is present on both and same way T is present on both so we can say that in this case s and D are anagram of each other so we can return return true in this case now if we take one more example uh we can see s contains r t also contains R so that's good s contains a uh T also contains a but thing is currently s has M that is not present inside the T so in this case we can say that t is not an anagram of s so we can return false and basically this is what we need to return so let's try to see that what is going to be the most common brot force approach to solve this problem suppose we are given s is equal to rat and T is equal to T okay so in this case as part of the anagram what we'll do is we'll take a character inside the s for this we will iterate over every single other remaining character inside the T to make sure that whether that character is present or not if it is present we can remove it from here from both sides same way we will repeat the same operation for all the all of the different characters and we will come to the solution now if you see this approach would yield correct result but thing is if you see time complexity basically it's going to be B of n Square because for every single character present inside the S we will have to check against all the remaining character inside the T which can be quite expensive so this is like a bad approach now let's see that what would be the optimal solution in this case and the logic is that first of all we will have to check that if the given SNT if they are to be anagrams of each other basically their length has to be same so first thing we will check is that if the length of s and t if they are same that's good then only we will proceed if they are not same we don't even have to check that whether they are anagrams of each each other so this would eliminate like all the bad examples okay now let's see that what is going to be the logic for the given subsequent s and D let's say that the current s has the word card and the current T has the word uh r RC okay they are the anagrams of each other now we already know the pre-existing condition on what defines an anagram that the frequency of any particular character present at s and D are going to be same and no matter what what so this fact we are going to use to basically come up with a clever solution now first approach is that we actually use a hash map or second approach is that we basically use an array now why we are able to use an array in this case to solve the problem because we know for a fact that English language only has 26 character so we can actually initialize a character um an array with 26 size in it and based on the index position we would Mark like subsequent um positions within uh the characters so let's say that if we are dealing with character a then a has to be present on the first index of our array same way B has to be present on the second index of the array okay once we have an idea on how we are going to keep track of the frequency now what we need to do is that frequency has to match both on S and T So for that what we will do is we will start iterating over U for S and D at the same time we know that they are both at the same length so we can just use one one for Loop or one Loop to iterate over them for every single character that we find we are going and for each of them we are going to initialize values with values zero okay and now let's just let me just arbitrary Mark values like C A R and T So C A R and T these let's assume these are the values like actual values would be different based on their character positions I'm just putting it here so that it would be easier for us to visualize okay uh so first we have character C at position number s all we are doing is that whenever we find a character in s we are going to increment the counter within the array and if we find a character inside the T which means we find like a subsequent reciprocal character so then we are going to to decrement the counter uh and how it is going to work is first we identify character C over here so we are going to increment the counter to Value number one so let's just mark this as one subsequently at the first position the value is R so once again for R we are going to decrease the counter so this is going to become minus one okay now for a once again we are going to increase the counter based on this s and we are going to decrease the counter because this is also a so that this would become minus one so one basically overall this value would become zero after this change okay now next we have R so in this case we are going to increment R now notice the value of R is already minus one so we will turn it back to zero and this value is T So currently T is zero so this value would become basically minus one okay and last one is T so in this case notice that t is going to become uh zero so let's just Mark T as zero and this value is C so we will have to reduce the value of C so if we reduce the value of C basically this is going to become zero uh zero as well and now notice that after iterating over all of this we found out that every single character that was present inside the S is also present inside the T and what is the way for us to check it we simply iterate over the this given array once if we find for any particular character that there exists some value that is other than zero then we can simply written false saying that they are not anagrams of each other and let's take that as that example as well that let's say over here here inside the input let's say that this value is still card and this value is uh over here it's let's say r a t o uh so notice in this case this C would have remained one because we had uh C over here that was not present inside this T and notice that for this character o let's say that this is the character o this value would have been minus one so overall we would have like more than one values that does not contain values Z and we can explicitly say that because this is the case we can simply say that they are not anagrams of each other so this is a very fast and beautiful approach now let's try to calculate time and space complexity in this case time complexity is going to be bigger of n where n is the total number of characters present inside the uh s or T and in terms of space complexity well this is still going to be constant space complexity because even though we are initializing an array the maximum length of that array is going to be 26 characters only which is a constant space it is not continuously growing and it doesn't change with the given original input so that's why this is a beautiful time and space complexity and now let's quickly see the coding solution for this one so the coding solution is quite straightforward first we will check that whether the length of s and t are equal or not if they're not equal we can simply return false if that is not the case we will initialize our array called character counts that is going to be of size 26 then we will increment the count for every single C character that is present in s and decrement the count for every single character that is present in T and we can just simply update the character counts array that we have just initialized and after that all we need to do is to check that if in the character count array are there any other values that are not zero the moment we find a non zero value we can simply written false saying that s and t are not anagrams of each other if we do find all the values are zero and gut out of this Loop which means they are anagrams of each other and we can simply return true so let's try to run this code seems like our solution is working let's submit this code and the code beats nearly 45% of all the other Solutions which is pretty good if we see memory it beats nearly 80% of all the other Solutions which is awesome so once again the coding solution is present on our GitHub repository feel free to go and check it out from there thank you the lead code problem we are going to solve now is called two sum this is the number one problem on the lead code and we can see that this one is an easy problem and also the most like problem on lead code let's understand the statement basically we are given an integer array nums and we are also given an integer called Target now we need to return the indices of the two numbers within the nums array such that they are the sum of Target so basically they add up to the value Target and we are guaranteed that there is always going to be one solution and we can return these indices in any order so let's try to understand this with an example we are given an input ER nums over here and we can notice the values are 15 7 2 and 11 and we are also given Target value to be 9 now in this example we can see that the 7 and 2 sums up to Target value number N9 now if we see the index positions of the 71 um sorry 7 and two uh they are located at basically 1 and two position so we can return the answer as 1 and two or we can also return two and one whichever like sequence we want but basically this is what we need to return now let's understand that what are the different ways we can actually find the sum of these two values so first let's understand the Brute Force approach basically uh for the same example let's say the values we are given we are going to try every single permutation and combination so what we will do is currently this value is 15 and the target we wants to make is 9 okay so this value is 15 so we cannot use any other value to basically form the target value as up as N9 so we can just ignore this case okay now this value is seven so because this value is 7 the total Target we wants to build is 9 so what we'll do is we'll do 9 minus 7 so we will check that if the value two is present inside the remaining array or not and lucky for us the value two is present so we can just return basically the index positions of this these two now notice that um in the Brute Force approach what we are essentially doing is for every single character in the worst case we might have to iterate over all the remaining characters to see if any particular value is present or not let's take an example that if this value was to one then we would have to check that whether eight is present so for that we might have to basically go over all of them so the time complexity would have been big of n square that is a bad time complexity now let's see that if there is any particular way we can improve upon that and the answer is yes we if we do sorting basically things would become slightly better and easier uh how let's understand that for the same example if the values are 15 7 2 and 11 once again if we sort these values we would be left with value 7 uh sorry 2 7 11 and 15 now uh we are at Value number two Okay so notice that if uh the target we are going to we want to generate is 9 if we already have value S2 which means uh if we do 9 - 2 the answer becomes 7 now all we need to do is to check that whether 7 is present inside the remaining array or not same as our Brute Force approach but in this case because we know that this is already sorted instead of using linear search where we are iterating over all of these values one by one we can use binary search and that would help us alleviate lot of questions because in the binary search remember that we will find the middle value so let's say we find middle value is 11 in this case and from 11 we know the value we are trying to build is 7 so even if there were like 100 elements on the right of 11 they will all be smaller or sorry greater than seven so we cannot use them so we will just ignore the entire right portion and only limit our search to the remaining piece and we would be able to find the remaining value in essentially log end time which is exceptionally fast so this if we see like the Sorting approach of sorting the original input array things becomes quicker um and we can actually solve this problem in bigo of n log and time and this is the time to basically sort the given input plus log and time to find any particular character uh but the thing is we generically we can just write it big off and login as the overall solution now the question is is there a way to do things quicker and the answer is yes we can even do things faster if we use an additional data structure in this case and uh let's see what are the considerations for us to understand any particular data structure number one thing is whenever we see a value we are trying to basically determine that what is going to be the remainder so in order to quickly look up that do we have that remainder or have you already passed that remainder or not uh what we can do is we can use a hash map in this case now notice hashmap contains two properties first Val first thing is a key and second thing is an appropriate value now as part of the key we would put whatever the array uh item that we currently have so let's say that we are given uh once again this array as an example okay now in this case we once again need to return the Target value of let's say 9 uh so now in this case uh what the algorithm we are going to use is first we will iterate over any particular character inside the given nums array for that character we will see that what is the remainder value we are trying to generate so for this value number one we know that the remainder value should be eight the question is is8 present inside the hashmap or not if it is not present that's it we simply add this value one saying that it could be potentially uh a match for some future Target value that we are trying to generate and continuously we will keep on doing that so as a key we will add value one over here and as its appropriate value we are going to store the index position so index position for this one is going to be zero so we will store value zero over here now let's repeat the same operation now next value is value number seven so for if we already have a seven to be part of the two sum that we are trying to generate we will need to have SE 9 - 7 which means value number two as part of the hashmap but currently hash map does not have value number two so what we'll do is we'll simply add value number seven with its index position as one same way we have value number three if three were to be part of the answer we we need to find Value number six six is not present inside the hashmap so we will simply add three over here with its appropriate subsequent value that is index position number two now we are at Value number two for two we need to find Value number s and lucky for us seven is present with within this hashmap and we already know its subsequent value is one and we since we are already at two we know the index position of two as well so in this case we can return the answer as let's say three and one or we can also return like 1 and three whatever we wants but basically this is the index position of the values that basically sums up to total value number nine and this is the fastest way to solve this problem now let's analyze the time and space complexity time complexity is going to be much faster big go of and why because we are iterating over all of these elements just once and we are coming coming up with the solution because remember searching that whether any particular value is present inside the hashmap or not happens in big of one time which is significantly faster than everything else let's analyze the space complexity so space complexity is going to be biger of n as well because we have to use an additional hash map to store the results but needless to say this is much quicker than both our brute force and also our sorting approach so now let's see the coding approach for this one so the coding solution is quite straightforward first we are going to initialize a hashmap to store all the values and their index positions then we are going to iterate over the given input array nums and for each of the array we are going to calculate that what is the remainder value in a variable called complement then we are going to check that if that complement is already present inside the hashmap or not which we can do in big off one time if the value is present we simply return uh a new array that contains the value of the com that that particular key and the current I position these are the two index positions if we do not find that value we simply uh add this current number that we are iterating over within our hashmap using maput and uh in the end we simply return an empty array if no solution is f found but this wouldn't happen because uh in the problem we are already told that there is always going to be exactly one answer we are just putting this return statement so we don't get into a compile time error okay let's try to run this code okay seems like our solution is working as expected submit this code and we beat nearly 99% of all the other Solutions which is awesome and uh in terms of memory usage we can improve if we use some other solution but this is also needless to say a very good time and space complexity and this is the most popular problem so you must know it by heart uh once again the coding solution is present in our grub repository so feel free to go and check it out from there thank you hello friends vs Ed by a Fang company so let's not stop lead coding until we get there today we are going to do group anagrams lead code problem and this problem has been really popular at some of the companies where I want to get a job there are companies like Amazon Microsoft Facebook Apple Google airm Snapchat Goldman Sachs Uber Bloomberg Netflix instacart bite dance and Twitter have already asked this question so that's why I'm paying my atmost attention I hope you also enjoy the video so this is a lead code medium problem and basically we are given an array of different strings and we need to group The anagrams together now now we can return the answer in any order so which is good for us and we are also given the definition that what is an anagram anagram is a word or a phrase that is formed by rearranging the letters uh and then it turns out to be a different word so if we take an example suppose we are given a word like bat then we can say that these all are actually anagrams of this original word bad because the B A and T they are all occurring in all of them in the same number of occurrence that it it is present in this bat so now after understanding that what an anagram is let's try to see some examples to understand that what this question is asking us to do and what is the expected answer we we need to return if we take this first example essentially we are given s is equal to array of string that looks like this now over here I have clearly marked all the groups that can be potentially done in separate colors so you can clearly look at them uh but the thing is let's try to understand so first of all we are given this word e a t e if we see the what are the number of occurrences of characters there are characters e a and t occurring one times each now same thing happens for this word t e a t and for this word a t E8 which means we can conclude that all of these three words are actually anagrams of each other and we can group them together in one single group so that we are now we are done with all of these three elements now next item we see there are two words tan and net again t a n this all all three of them are occurring once these three characters for both of these values so we can also group them together now for this b a t bat we actually don't have any other value that we can consider it as an anagram so this uh particular string will be a group of itself which means in this case we can answer we can return an answer that looks like this and we can return this as an answer so clearly you would find that this answer actually the sequencing is done slightly bit different than what is the answer given in this output and the reason for doing that is that I wanted to show you that we can return answer in any order so that is the important part over here that that is specified in the question that we can return the answer in any order so that's why I ordered them differently but as long as the groups are correct we are good to go one better way to solve this problem is actually by using sorting and how we are going to use the Sorting is that we are actually going to create another array for every single entry that is present inside this original s and for all the elements that are present over here we are going to actually sort them in alphabetical order and then all we have to do is just we will have to iterate over this newly created array once and we only need to find that what are all the similar pairs or all the similar values and then we can simply return them as answer and that that makes our life much more easier let me quickly show you what I'm suggesting So based on this array we will actually C actually create a sorted array and the sorted array is going to look something like this so now we have created our sorted array and which we have derived from this original s now all we will have to do is we pick up any word or any uh string then we just have to compare with all the other strings and find that which strings contains the same value whichever string contains the same value we will take their values from the original string because we know that they're index values and then we can group them together so the idea is first of all we'll take this string AE then we find that okay this and this both of them so the strings located at position 0 1 and three they are all part of this original uh string that should be in the single group so we will group them together so in the answer we will mention e t and 8 as one group then again we will repeat the same process so we find this ant and ant so again we will group The whatever values located at this string at this index 2 and four and for we find the values 10 and net and in the end we will return this bet because it's the single one so this solution would work fine we will get our desired answer if we see the time complexity in this case the time complexity is actually going to be big go of n log n just to create this uh original sorted string multiply by K and this K is actually the biggest length of the string that we will have to compare and uh this would be the final time complexity so this is much bigger Improvement than our Brute Force approach which was giving us the big of n Cube time complexity now let's see that can we improve any further in this one as well okay before we come to the optimal solution we will have to ask a very important question that how do we determine that any two words are anagram of each other or not suppose we are given two words like A B C and C B A we can clearly see that they are actually anagrams of each other but how can we explicitly Define that yeah they are truly anagrams of each other well we can Define that based on the number of character repetion in each one of them that any character that is present in this ABC it is also present in this CBA in the exact same number of occurrences that both in in both the words so in other words uh a b and c is present exactly once in this particular word and it is also exactly once present in this particular word though the arrangement is different and that makes them anagram of each other now you'll ask that why am I dragging so long on this pretty trivial question that we already know the answer to well we are actually going to use it to our advantage and uh the good thing for us is that English language only has 26 characters so because English language has the 26 characters we are actually going to use it to our advantage we are actually going to create an array of all the values that are initially located at zero and that is going to be of size 26 now any character that we identify in any single string we are actually going to add it to our array and we are going to increase the value of that particular character sequence and then whatever the answer of that car is that array is we are going to put it in a string and then we are going to use it as a key for our hashing hashmap uh hashmap and then we are going to do some interesting things so let's let me quickly show you that what is the full plan suppose over here we are given an array that looks like this right now we need to we have this given word ABC so what we are going to do is initially all of these values they are defined as Zero by default but now we are given this ABC so first of all we take this a we increase its value to one again we get this B we increase its value to one again we get this C we increase its value to one now all the other values they are zero and so far so for this particular character we can actually create a string based on this given array of 26 words so string would be maximum of size 26 which means it is a defined finite number we which means we can create that we will get a string that looks like this 1 1 one and then uh remaining 23 zeros again we are given this word CBA a right so again what we are going to do first of all we identify this character C so we are going to Mark its value as initially this was zero so we are going to mark it to one again this B again we will mark it to one and again this a we will mark it to one all the other values would be zero so even for this one the string that we are going to generate is going to look like this 1 1 1 and 0 0 Z Now the idea is that we will create a hash map now inside this hash map as a key part we are actually going to keep track of whatever the string that we are building so let's just name this as string Builder that we are building a new string that would be our key now in both the cases notice that for this ABC and for the CBA this string value is is actually going to be the same that it would be 1 1 1 followed by 23 zeros in both the cases which means that it they both have actually same key value which means that over here okay this is 11 1 0 0 0 23 times but in both the cases as the value we are actually going to keep track of a list and inside this list we are going to store original words that were presented as an input for this original array string that we buil so over here first of all we will have an entry that looks like a b c and then we will have an entry that looks like CBA now we already have both the values that are that is part of the same group or they are an which is an anagram of each other would be in the list value which means that that makes our life much more easier that in the end all we need to do is just we need to return this whatever value we have stored in the list let's do this with one of the example that we have been following so far so I'm not going to show you the whole ordal with the array because that is to time consuming we are I'm just going to show you that what would happen in inside the hash Set uh hash map so this is our hash map now as a key we are going to have some string value so first of all we get this value eight so suppose for this value number eight we get the string that looks like looks something like this right whatever the value is now the same value is going to look for this T and for this 8 which means that these values e then T and 8 would be a part of the same value group inside this hashmap for the same key again same thing will happen for this Stan and net so even again for this stand and net suppose we get some value that string that looks like this right I'm just R drawing bunch of gibberish but you you get the idea and we will add an entry for 10 and net because they both will have the same number of occurrences of characters and in the end for bat we won't have any entry so we will have a new entry over here and where we will add the value back now in the end all we have to do is just iterate over all the values that are present inside this hash map and return it as our answer and this would be the optimal solution we are going to use if we see the time and space complexity for this one the time complexity is actually going to be bigo of n times whatever the maximum length of K is in terms of space complexity we are actually creating an additional hash map so that's why that is going to take some additional space but this is also going to be big of n * K where K is K is the longest length of Any Given string and n is the number of string that are present inside the given input so first of all we are going to check an edge case that if the given string is empty we are going to return an empty array list immediately okay if that is not the case we are going to initialize our hash map and we are going to take string as key and uh list as value also we are going to initialize our array of size 26 and we are going to name it as count once that is done we are going to run a for Loop across the given input string so first of all we are going to initialize our array with value zero after doing that we are going to iterate over this given string s and we are going to add all the characters inside this given array by adding their value from 0 to one after doing that we are going to initialize a string Builder to store the string value that we have retrived inside this character array now we are going to run across the count array and we are going to add all the values to string Builder also at the same time we are also going to add a hash before all the elements inside this given count array and that is something per language trick that changes for python you won't have to do it once this is done we are going to assign this new string that we created as a key for our hashmap we are going to check that if this entry for this given key already exist inside the hashmap if it does we are simply going to add whatever the string s that we are iterating over and if the entry does not exist we will create one value inside the hashmap and then we will add this value s for this given key and we are done for this for Loop now all we will have to do is return all the values from this answer map and return it in the manner that is asked inside this given question so we will have to return a list of uh lists let's try to run this code okay seems like our solution is working as expected let's try to submit this code and our code works as expected I'll be posting the solution in the comment so you can check it out from there Hello friends we are still not employed by a Fang company so let's not stop lead coding till we get there today we are going to do topk frequent elements lead code problem and if we see some of the companies where I want to get a job who already asked this question there are companies like Facebook Amazon Microsoft Google Uber Apple Bloomberg Snapchat Twitter Tesla Netflix by dance LinkedIn eBay and Tik Tok so that's why I'm paying my atmost attention I hope you also enjoy the video this is a lead code medium problem and also very well-like problem on lead code basically we are given an integer array called nums and we are also given a separate integer called K now we need to return the K most frequent occurring elements from this nums array and we are also told that we can return the answer in any order so first let's try to understand this problem with this example I have actually drawn it much bigger over here so this is the array nums that we are given and we are given K is equal to 2 which means we need to return top two elements that are present inside this given nums array right so if we see in this case well over here this one is actually present three times this two is actually present two times this three is actually present one time now if we see we are given that K is equal to 2 which means we need to return top two elements and clearly we can see that the top two elements in this case is this one and two so we can return return the answer to be uh 1 and two or we can also return return two and one because remember we are told that we can return answer in any case and this is the answer we need to return so let's try to see that what is going to be the approach to solve this problem now let me make one clarification there are actually two different approaches to solve this problem one approach or the first approach I'm going to show you in this video is actually sufficient for your interview any interview would be more more than satisfied with that approach but thing is the second approach I have is actually the golden key approach for any like top K element problems right any Heap problems you can use the second approach and uh I'm actually planning to make a separate video on that depending on whether you want to learn it or not so let me know in the comments that whether you want to learn the second approach if you do I'll make a separate video we are actually going to use the combination of a hashmap and a heap in order to achieve the top K elements so I have created a custom example over here and I have given the value of K is equal to 3 now remember whenever we need to Define that we need to return top K elements or top three elements and in in this case how can we Define that well we first of all need to iterate over this given given entire array we need to find that how many times any single character is occurring and depending on that answer we will have to iterate over that uh whatever the list we create where we have the number of occurrences for each character and then we can include this answer so one thing is clear that we need some way to store the information that how many times any particular individual character occurs for that we are actually going to use the hashmap in the hashmap as the key we are going to denote the distinct value of this given array and as its value we are going to note the occurrence of that particular character so first let me quickly create a hashmap for this given input which contains the distinct values and their occurrences So based on this given input this is the hashmap we can create now we need to select K is equal to 3 which means we need to provide top three elements now one approach to find the top three elements is that all the distinct values we have in this hashmap if we just simply create a sorted array and in the sorted array we sort the array based on uh the descending values which means the most occurring value to be first and then we put down all the remaining values we can actually generate a sorted array that looks like this and now for this particular sorted array we can simply return the top three elements so we can return the answer to be like four 3 and five easily and this is the solution that would give us the correct answer but thing is uh you would quickly and ask me that why did I mention priority Q over here because over here what I'm doing is I'm taking this hash map and I'm actually just sorting it and we are able to generate the array well first of in order to understand that first of all let's understand the time complexity of this approach the time complexity of this approach is first we need to iterate over the given one entire input for that it takes big of end time to generate this hash map after generating this hashmap we will have to create the sorted array that takes n log n time to generate that answer and this n log n is going to be the ultimate time complexity so the thing is this you would say hey n log n sounds reasonable but thing is uh from n log n suppose we have like 1 million uh distinct characters or 1 million characters and we are given K is equal to 3 which means that we would have done like 1 million * log 1 million work meanwhile the value of K in practice is supposed to be much smaller than whatever the input size is going to be so the other approach is that if we create a priority CU and remember the concept of a priority Q is that inside the priority Q uh basically we add the values and we remove the values just like any cues but thing is the values that we are entering they have some meaning behind them and depending on their Val valuation we actually store the value so whenever over here suppose this is the priority q and I have provided different uh weight to those elements if I want to create or if I want to enter an element that is in higher weight then I would get rid of only the lower weight elements and add those over here uh I would not be repeating everything so based on that concept what I'm suggesting is that rather than sorting this array we get rid of it okay so let me clean this up a bit and over here from the this actual hashmap that we have created we actually create a priority que and this priority queue is going to be of whatever the size we are given of the K value okay so K in this case is three so we are going to only have three values in our priority Q now for our priority Q first of all we are going to check that okay we only enter the values based on the number of occurrences they have and we only keep the higher number of occurrences so first we add the value number one over here because we don't have anything now we add value number two over here because we still have room and two has two occurrences then we add value number three because three has three occurrences and remember we are using the occurrence to add the value not the actual distinct value right this is the key part okay now we have this value number four four actually has four occurrences right and so far if you remember this one had one occurrence this two had two and this three had three occurrences now we have a value that is four that has actually Four occurrences which means it is greater occurrences so we are able to insert that that value inside our priority q and uh in that case we are actually going to get rid of the smallest value so smallest value in this case was one now we are not going to add four over here but we are also going to maintain the uh ascending order in terms of the values that we are being added so we'll just shift these values okay so two will come over here three will come over here and four will come over here and then we will have those subsequent values now after adding this we still have value number five that we need to add so five occurs three times so five occurs three times currently we have two occurring two times three occurring three times and four occurring four times now five occurs three times so five is able to enter over here because it occurs more times than this two and we can actually put five over here uh because it is also occurring three times and this three is also occurring three times so we are good up until this point after that all we will have to do is just convert this uh result into an array so for that particular array we are actually going to store the results and remember we can return result in any manner so we can like 5 3 4 or we can also return like 3 4 5 or whatever result we want to return we can return and this is going to be the solution if we see time complexity in this case the time complexity is actually going to be a bigger Improvement than our sorted array approach why because okay over here this takes big go of end time to generate this hashmap that process remains same but now from generating this hashmap to this priority Q it takes n log K * because we are only maintaining K elements this is the important priority and this is what your interviewer is going to focus on so in this case the time complexity is actually going to be big go of n log K which is good and in terms of space complexity well you must have guessed it correctly it's big of n because we are using couple of additional data structures we are using a hash M and we are also using a priority que and this is a very good time and space complexity and uh that's that is basically the ideal approach now let's move on to the coding first of all we are going to take care of an edge case that if the given K is equal to whatever the length of this nums is we can simply return nums that is not the case we are going to initialize our hashmap now we are going to iterate over all the elements that are present inside this given nums so we are going to run a for Loop and after the for Loop ends we are basically going to populate the values inside our count uh hashmap that we have just created now uh we are going to initialize our priority queue and inside our priority que we are going to assign the method of insertion so we are are inserting based on the number of occurrences uh based on this count hashmap so let's uh put the condition for that so now we have now everything is set up now all we have to do is just iterate over all the keys that are present inside this count hashmap that we have created and for every single key basically we are going to add that value to our Heap priority que and whenever the priority Q gets full to the size of this K we are basically going to pop the element and the element that will get popped is going to be the least occurring element so we are only keep keeping higher occurring elements inside our Heap and now we check that if the Heap size becomes greater than K we remove the value from Heap that's it so now all we have to do is just simply initialize a new array variable called answer and uh we are going to populate this answer array so we will run a for Loop for K times and we will keep on pulling the values from our Heap the end we can simply return the answer and let's try to run the code okay seems like our solution is working as expected let's submit this code and our code runs pretty efficiently and I will be posting this solution in the comments so you can check it out from there thank you hello friends we are not employed by a Fang company so let's not stop lead coding till we get there today we are going to do product of an array except self lead code problem if we see some of the companies where I want to get a job who have already asked this question there are companies like Amazon Microsoft Facebook Apple Uber Bloomberg lift Google Goldman X IBM Twitter Tik Tok and Linkedin so that's why I'm paying my at most attention I hope you also enjoy the video this is a lead code medium problem and also very well like problems on lead code uh basically we are given an integer array called nums and we need to return a new array called answer array such that every single value of that particular index position inside this answer array is actually equal to the product of all the other values that are present inside this given nums array except that particular I element so suppose we are given an input array that looks like this this case we will have to create an answer array for the answer and that would be of the same size of whatever this input array we are given now in this answer array suppose we want to enter the value at this uh second position or corresponding to the second index value what we are going to do is we are actually going to take the product of this value number 1 3 and four and whatever the product of these three values are we will actually put it as the answer for this value same thing we are going to do for this uh next value where we are going to take products of these two elements and this element but we won't take the product of this element from this original given input array and whatever the answer is we will actually put it over here inside the answer array uh in order to enter this first element we will actually have to do the product of these three values then the product of these three values is going to be 24 uh now for the second element we will have to do the product of this first element and this last two elements so that is going to be 12 uh for this third and fourth element we will uh again repeat the same process and we will get subsequent values like eight and six by doing the corresponding products and at the end we will have to return this as the answer array and uh basically this is what the problem is asking us to do uh even the name is also self-explanatory that we need to return the product of an array except self but we are given a very specific declaration over here that we need to use it in bigo of end time without using the division operator and why it is asking us to use uh solve this problem without using division operator because if we were allowed to use division operator suppose we are given an input we can just do the product of all of these value and we will get an answer called 24 and then all we have to do is for this answer array we will take this value 24 and then we will iterate over this input array and start dividing it with this 24 so even in the answer we will get if we divide 24 by 1 we will get the value as 24 if we divide 24 by 2 we will get value 12 if we divide 24 by three we'll get value eight so so on and so forth so it would become very easy for us to solve this problem so that is why they are explicitly asking us that we should not be using the division operator now the most basic Brad Force way to solve this problem is actually we take any single value and then we iterate over all the remaining values and do its product and put it in the answer array so we will create an answer array that looks like this we will First Take This value so we will iterate over this given nums array and for all these three values we will do its product and we will get the Valu 24 now again we will repeat the same process but this time we will be iterating over the second element so because we are iterating over the second element we will take this first value and we will take these two values and we will do that sum so we will get value number 12 and again we will repeat the same process so essentially this is bound to give us the correct answer and we would get it in this case but thing is this is this would not be the correct way why because if we see the time complexity in this case the time complexity is actually going to be big of n Square why n Square because we will have to iterate over this array for for every single character we will have to iterate once and even for any particular character we will have to iterate over all of the values again just to find their product number and that takes n Square time and we are explicitly told that we will have to solve this problem in we go of end time so let's see that what would be the way to achieve that okay so now for the better approach we will actually have to put down one intuition to use and the intuition is suppose this is the element we want to get the product for in the answer array so the idea is that we are actually going to take the product value of first two elements and we will take the product of this last element again if we take this portion this value number two we will take the product of all the elements that are present on the left of this value number two and we will take the product of all the elements that are present on the right of this product number this value number two so that is the idea that for every single location we will have to take product of all the values that are behind or pre to that particular level so we can call it as prefix and all the values that come after that value and we can call it postfix so now the idea becomes quite simple what we are going to do is we are going to have two arrays called prefix and post fix and we are going to iterate over this nums array once and for every single position we are actually going to keep track of all the values that come before it and after it and we are going to put down their ER values uh like their product values and at the end we will just do a multiplication between this pre and post arrays and then we will we should get our answer so let's see that that in action and also one more thing that because for this particular element that are at the edges uh so for this value number four there is nothing on the right side so like we can't do anything but uh for the Simplicity purposes we will consider that anything on the right side is actually one because anything multiplied by one Remains the Same and same thing we are going to do for this left Edge as well that because for this value number one there is nothing in the prefix so again by default we will treat this as value number one as well so that will help us in uh doing some counting right so let's see that in action so first of all for this value number one we we are calculating the prefix values so this one actually has nothing on the left but it only has one so we'll do 1 * 1 and we will get the answer as one now for this value number two actually all we need to do is whatever the left element is we we just need to do the product of all of them so the left element in this case is only one and we will just put it over here as well now in this case the value number three we will have to to do product of all these elements so one way to do it is to do this like 1 * 2 so do the product of all the these two elements but that is actually time consuming one better way to do it is that uh if we take this particular element value number two this already contains the product of all the values that are be present before that so why are we doing the effort of doing the product of this value number one and two that is this costing us additional resources the better approach is that we for this value number three uh we are over at this position all we have to do is we just take whatever the value we have stored over here which is the prefix of all the values before this value number two multiply by whatever this value is present and that would be the prefix sum for this value number three so what we are going to do in this case is we will take this value number two so we will take this value number two and we will take this value number one from here from the prefix array that we have already calculated and we will do 2 * 1 in this case we will get value as two so we will add two over here and again for this value number four again we are going to repeat the same process so now this time we are going to take the value before four that is three so we will take three and we will multiply it by whatever value we have already found in this prefix array which is two so 3 * 2 is actually going to be 6 so now we are done with this prefix array again we are going to repeat the same thing for the postfix array so this is The Edge value so we can simply do 4 * 1 so we'll add the value four directly over here now this is value number three for this value number three all we will have to do is just take product of this value so this is already four so we will again add four over here now for this value number two all we have to do is we will take the value this uh whatever value that is present over here three multiply by whatever value we have already calculated in the post fix over here which is 12 so we will have a value called 12 over here for this element number two and now again for this element number one we are going to repeat the same process so we will take this two and multiply it by whatever value we have we have calculated inside our postfix array and this is going to be 2 * 12 okay now we are done with both of our arrays now the task is actually quite simple now we will create our answer array and we are going to Simply do the multiplication of every single one of these values so this becomes 24 * 1 24 this becomes 12 this becomes 8 and this becomes oh I made a mistake over here this has to be 1 not four because we are actually doing the multiplication of all the elements that are present on the right side of this value so this would become six and this is the solution that we are we are going to do uh this solution actually works perfectly fine there are no issues with that if you see the time and space complexity in this case the time complexity is actually going to be biger of uh 3 * n why 3 * n because we will have to iterate over this n to first of all create this prefix array then we we have to iterate over end times to create this postfix array and then again we will have to iterate over both of them to create this answer array so we are doing like three times n work but in general we can write this as big of N and in terms of space complexity uh we are actually creating couple of arrays so we also have to do big off and as space complexity so the idea is can we do something better and the answer is yes there is one way to actually do this both prefix and postfix array in a single array and that to insert the answer array that we are planning to create okay so let's keep the same example and we want to find the optimal solution for this one well the idea is that rather than doing two separate prefix and postfix arrays we are actually going to create an answer array and we are going to add all the values and now we are going to do prefix and postfix multiplication inside the same answer array and let me quickly show you how uh first of all we are going to use couple of variables called prefix and postfix so let me uh add their values and by default they are going to have value as one now what we are going to do is uh first of all we are going to iterate over this given input nums and we are going to calculate the prefix for every single element inside this answer array and we are also going to update the value inside this pre function uh or pre variable and then again we will iterate in the reverse order and we will keep on updating the postfix values inside the answer and by the time we are done our answer array should have been completely filled out let me quickly show you that in the action so first of all uh for this value number one uh this is actually the prefix of uh every every value that is present behind this one and the multiplication of all of those values so because there is nothing over here we can consider this to be one by default so I'll not write it over here I'll just write over here that for this first element inside this answer array uh the nums actually does not have anything on the left side side left side so we can consider this to be one now we are going to we are at this second position for the second position what we are going to do is we are going to take the multiplication of whatever the value we have on the left side right so even on the left side we only have value one and even the prefix value is also one so far by default so we are going to add one over here again now we are at this value number two or three so for this value number three what we are going to do is we are actually going to take the the value that is before that which is two and we are going to multiply it with whatever the pre variable we have so we were also doing the same thing for this value number two as well but because both the values are one we were not getting any other result but in this case we will actually get a result of two and because we are getting a result of two the result of pre is also updated also being updated to Value number two um because it will help us to know further down for the next elements that what is the value of prefix now we are at this value number four so again we are going to repeat the same process we will take this value number three and we will take whatever the value of this prefix we have which is two so 3 * 2 the value is six so we'll add value six over here okay and now we are done filling up this prefix portion and we have taken the prefix of every single element inside this answer array now we are going to do the reverse order now inside the reverse order again for this value number four actually uh there is nothing on the right side of this value number four which means there is nothing on the post fix so we can consider it as one now because this is already one what we are going to do is whatever value we have calculated so far we are going to multiply it so if we multiply 6 by 1 the answer we get is six okay so so far uh for this value number four the answer is six now we are at this value number three for this value number three what we are going to do is we'll have to calculate everything on the postfix side so this value is four 4 so we are going to take value 4 multip by whatever value of this postfix variable we have which is 1 so 4 * 1 becomes 1 so now we have the value as four for this postfix so we are going to update the value of the postfix to be four and we are also going to multiply this four with whatever the value we already calculated for this value number three which is 2 so 4 * 2 is going to be 8 and this is going to be answer for this value number three that this is the product of all the numbers for this value number three except itself now we are at this value number two for Value number two we are going to take value number three multiplied by whatever the post variable we have post variable is actually 4 so 3 * 4 is actually 12 so we are going to update that value over here first of all so now we have the value 12 over here and we will have to take this 12 and multiply it with whatever value we have already stored over here which is 1 so 1 * 12 is also 12 and now again we are at this last position so again for the last position we are going to repeat the same process we will take whatever the value that is after this value number one which is two so we'll take this two we will multiply it with whatever value we have store inside this post variable which is again 12 so 2 * 12 and we this becomes actually 24 so we will do 24 and we will take 24 multiply by whatever value we have already stored inside this answer array which is 1 so 24 * 1 becomes 24 and this is the answer and if you look closely this actually becomes the complete answer that we are looking for and we have actually done everything in place without using any additional data structure or any additional array and we don't have to use basically any extra space so this is the best way to approach this problem and this is the solution that any interviewer would want to see if we see the time complexity in this case the time complexity is actually going to be bigo of 2N why 2 N because first of all we are iterating over from uh left to right calculating this pre variable and then we are iterating on the reverse order calculating this post variable and updating the values but still which is good if we see the space complexity in this case oh well space complexity is actually constant because we are not using any additional space for this answer array we are given inside this uh question statement that we have to create a new array so that we are any is going to create but apart from that we are only using couple of variables to store some data and uh that's why this is a very good approach now let's move on to coding of all we are going to create a new called result and by default we are going to set all the values as one we are going to initialize the two variable called prefix and postfix and we are going to assign the value as one for both of them okay now we are going to run our first for Loop to iterate from left to right and we are going to update the value of prefix inside our answer uh array so first of all we are going to update the value inside our result array and then we are going to update the value of our prefix variable so after this Loop ends basically we should have uh prefix values filled out for every single position inside our result array now we are going to run another loop and we are going to come in the reverse order and first of all we are going to update the value inside the result array so any single value inside the result is actually going to be multiplication of whatever the value we already had multiply by postfix variable also have to update the value of postfix variable we are good to go oh actually I made a mistake this should be pre only not prefix okay and after this second Loop ends essentially our result area should have been populated so we can simply return that let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs pretty efficiently compared to a lot of other Solutions so that's why this is really good approach I will be posting the solution in the comments so you can check it out from there thank you hello friends I'm A Cloud Solutions architect at Microsoft and my aim is to empower every single person to be better at technical interviews keeping with that goal in mind today we are going to do a very interesting lead code problem called valid Sudoku now if you see some of the popular companies who already asked this question there are companies like Amazon Apple Nvidia Uber Microsoft Facebook Google Bloomberg door Dash Goldman sax and Snapchat so that's why I'm paying my at most attention I hope you also enjoy the video so this is a lead code medium problem and also very well like problem on lead code in this problem basically we are given a 9 cross9 Soko board and we need to determine that whether this given sodoko board if that is valid or not now uh we are told that only filled cells needs to be validated according to following rules and we are given three rules to determine that whether the board is valid or not first rule dictates that each row must contains the digits between 1 to 9 without repetition this is the key phrase that there should not be any duplication first uh rule defines that every single row must have unique characters from 1 to 9 second row defines that every single column must have unique characters between 1 to 9 the third definition shows that uh the box of 3x3 or the subboxes in the grid must contains the digit 1 to 9 without repetition so this is little bit tricky but basically among the 9 by9 box we can make nine different 3x3 boxes where the values 1 to n should be present without any repetition now we are told that the Sudoku board in this case is partially filled and we need to only check the vs based on the filled items nothing more than that so it could be possible that we cannot be able to complete the entire Sudoku but given the filled elements if they are at least behaving giving these three definitions that are mentioned where every single row every single column and every single box they all should have 1 to n unique elements then we can determine that this Soko board is valid if it is not the case then we can determine that this is not valid so if we take a look at this particular example this is the example of a valid Soko box and what makes this Soko box valid is that that every single row or all amongst all the nine rows the filled elements are filled in a manner that there is no repetition between 1 to 9 now if we just see take one example say for an example for this first particular row if I add one more five over here then it make it completely makes the SoDo Cobo invalid because the elements five is repeated two times in this particular row we are not concerned with the empty cells because we can determine that that can have any particular value but if there is a five or any duplication present over here we can determine this to be invalid but let's just say that five is not present over here so we are good same way if I just put an eight over here in this middle portion then this column would be invalid and uh that would make this entire sodoko box invalid so that is also one more thing that we need to take care of and the third and little bit more complicated thing is the boxes that we need to be concerned with in this case so there as we can see from this image there are actually nine boxes present in any given Sudoku board and and we need to determine that 1 to n values are remain non duplicated for all of them so basically say for an example for this particular box now this box currently only has one value six which means this this box is valid because there is no duplication but if I add one more six over here which means then then the six is repeated two times so that would make it invalidated so basically we need to take care of rows we need to take care of columns and we need to take care of boxes for this particular problem to solve them basically I'm going to show you three different solutions one for the row one for the column one for the boxes and then we will find a way to combine all three of them so say for an example this is the row we are given right now we are only considering one row for now because same solution can be applied to all the remaining nine rows so that is a trivial fact so basically first we'll try to determine suppose this is the row we are given what is our objective our objective is to make sure that all the filled values over here they are unique between 1 to 9 and there is no reputation so the simplest way to do is is to create a hash set so if I create a hash set currently this hash set is empty maximum possible length this can have is going to be nine because there are only nine cells in any given row okay now the logic we are going to use is that first we are going to iterate over the row if the value there is some value we will try to first check that whether that value is present in the hash set or not if it is not present then we will add that particular value in the hash set and move on to the next element if the value is already present which means that there is a duplication we find and then we can simply return false that this given soku board is invalid so let's try to do that first we will have we are at position number one currently there is nothing in the hash set so there because there is no value we will add entry one over here and we can determine that this node has been visited or this cell has been visited for the row perspective and there is nothing wrong we find now this one is a DOT so if there is a DOT or if there are no values we can simply skip over that because that is none of our concern we are only concerned with the elements that are already filled now the next element is three so we will add an entry three over here because three was already not present this one is again empty this one is value number six so we will add six over here and then same way we will add two over here and these two cells are not empty so we have reached to the end of the row which means we can determine that this particular row is currently valid and there are no issues with that but sa for an example for this last cell rather than uh adding this value if we had one more value number three over here then what would happen once at this position when we add value number two over here now we are over here this one is a filled value because this is a filled value we will try to see that whether this value is present in the hash side or not since this value is already present this is a big no no and we found a duplicated entry which means immediately we can call this entire stoko board invalid because we find an in invalid row so that is how we are going to determine the rows now currently this one only had one row so we use just one single hash set say for an example we were dealing with nine different rows if that was the case what we would have to do is we would simply have to create nine different hash sets and uh basically for every single hash set we are going to repeat the same process so this is just repeating the same process for different set of inputs uh if the given soku board is let's say 16 by 16 we would have like had 16 hash sets but still the core concept would remain same now this the way we've solved for the box the same way we can actually solve for the columns again for the columns we are also going to create a hash set so say for an example this is the column we will create the hash set and we will repeat the same logic So currently this value number one is not present we will add value number one over here this three is not present we will add three same way we will add six and we will add two and now we are at the end of this column and we didn't find any duplicated entries so we can uh say that this particular column is valid and then we can move on to the next column and same way for the next column we would create a new haset and if any point in time we find duplicated entries so say for example for the second column we have two values one and one over here first we would add this one over here then the moment we move on to the next value and we see that hey in the hash set one is already present we can say that okay this particular column is invalid and that is why this entire Sudoko board is invalid so this is also a very simple thing to understand same logic we are using what we used for rows we are going to use for the columns the thing is for the box now for the Box this is a matrix kind of a structure okay and for the Matrix kind of structure again our main logic or the thing we need to achieve is going to remain the same that we need to make sure that there are no duplicated entries for the filled values between 1 to 9 so again even for the box we would be able to create a simple Matrix or or a simple hash set now for the even hash set we are going to apply the same logic and we would keep adding the entries uh until we find any duplicate entries and if we find duplicate entries we will call it invalid so this is a very simple thing to do but the tricky part is okay now say for an example we need to determine for rows and columns okay currently say for an example we are just ignoring the boxes for now we are only considering that how to solve this problem for just row and columns and we need to find that we don't find any duplication between 1 to 9 for every single row and every single column how we are going to achieve that we are going to achieve that in the same manner I explained earlier the only logic we are going to use this is that we are going to create nine hash sets for rows okay so for rows we are going to create nine hash sets every single row we are going to check for the duplicated entries if we find any duplication we can return invalid immediately if we don't don't find the duplication we will move on to the next row and we will keep on repeating the same process the same thing we are going to use for the columns as well that even for the columns we are going to create nine hash sets so uh again and we are going to repeat the same process to check that whether there are any duplicated entries or not and since there are none in this particular case we can simply in the end return the answer valid now remember we only solve this problem for the rows and columns okay but the thing is we need to take care of the boxes as well now for the boxes there is just one tricky part and the take tricky part is that actually for the boxes it is not as simple as the just the correlation between row and column uh because for rows we had the particular separate entries for every single rows that we can Traverse over them or determine them pretty easily even for the columns we have the direct way to identify that whether this is a column or not but when it comes to the boxes we need to establish a correlation between the set of uh different rows and different columns and how would we be able to achieve that okay so even for the boxes basically we need to create nine hash sets but thing is how do we Define which number goes where so basically these are going to be all the boxes that we need to create okay and these are the nine boxes but thing is how do we able to define the nine boxes the answer is quite simple we are actually going to do a division by three for any particular row value and any particular column value so that would be a very clear indicator on what box we need to choose and let me give you a quick demo so basically the idea is that okay currently this row position is 0 1 and 2 okay now say for an example if we do like 0 divided 3 What is the value we are going to get zero of course if we do like 1 divided by 3 What is the value we are going to do we are actually going to consider the floor value okay not the ceiling value so if we consider the floor value 1 divid 3 is going to be like 0.33 so basically in the integer it is going to be zero so these three values are going to represent zero same way these three values are going to represent zero which means if we are iterating over any of these cells we can say that we need to consider box number zero for that so that is pretty good same way if we are going over any other these three or these three values so okay this is going to be 1 one and one because if we divide divide them by three and same way this is going to be 1 1 1 uh if we divide them by three uh same way this is going to be 2 22 and same way this is going to be 222 now say for example we are at any cell amongst this particular box now we need to identify that which particular hash set to select now this one is going to be box number six so hash set number six we need to select okay but how do we Define this hash set number six is going to be the correct one and this is where we are going to use this formula where for any particular cell position we are going to do this formula where we are doing row divided by 3 plus we are doing three and plus we are doing column divided by 3 okay so this is the formula we are going to use to determine that what is the correct correct box number now suppose for this particular formula suppose we are at this particular box or this particular cell okay now if we take a look at this particular cell currently the row is going to be uh row number four okay row is four and currently the column position is going to be 7even let's apply this particular formula for this row and column position if we do that we are going to do 4 / 3 + 3 + 7 / 3 okay so in this case 4 / 3 is going to give us the answer number 1 + 3 and + 7 / 3 is going to give us the answer 2 if we do some of these three values we are going to Value we are going to get the value of six and the six is going to determine that the bo currently if we are at this particular position we need to check it against hash set number six this is the only complicated matter for this particular question if you are able to identify a way to find the correct box then this this is a very simple problem to solve and which we just did so this is the whole logic and basically now we know that how we are going to solve for row plus column plus box the idea is that for row we are going to use nine hash set for column we are going to use nine hash sets and even for boxes we are going to use nine hash sets and uh we already know how to determine what is the correct box we need to look at and based on that we simply need to check for the duplicated entries if we find any duplication we simply get rid of it if we don't find any duplication awesome then we can conclude this given sokode to be valid and this is the whole optimal solution now if we see time and space complexity for this one the time complexity is actually obviously going to be big go of n Square uh and why n Square because we are given n to be same for both rows and columns so that is why this is going to be biger of n Square if we see space complexity now this one is like a debatable question because we already know that we are going to use 27 additional hash sets the thing is why did we come up with this number nine because the we are given n is equal to 9 by 9 Matrix so we are given n is equal to 9 so that is why this 9 came in so basically space complexity is going to be biger of 3 n so in general we can write this to be big of n but if we are explicitly told that we are only going to use uh 9 boxes then we can also conclude this to be a finite number and this could also be considered as constant so if you do this discussion with your interviewer that you are going to look very uh clear in your Concepts regarding time and space complexity since this is already pretty long video and the coding is just a bunch of reputation so I am just going to explain you the code and then I'm going to paste this in the comments so you can check it out from there so first of all we are going to create an array of hash sets uh so first we are going to create an array for row second we are going to create for column and third we are going to create for the boxes uh and the size of this particular array is going to be uh the size of nine uh that is given over here and we are hard coding this value because uh we are basically told that this is going to be a 9 cross 9 s now after filling these values we simply need to initiate the hash set for every single one of them so we are going to just iterate over all the values and we are going to initiate initiate the hashtag to accept the character as the input now we are going to run two Loops uh first is to iterate over the row and second one is to iterate over the column and using the two inner Loops like one inside the other we would be able to iterate over the given input Matrix now the moment we are iterating over the given input Matrix first of all we are going to determine that what is the current character at any particular position or any particular cell now now if the value is is dot or if there is no value we can simply continue and move on to the next element but if there is a value we are simply going to first do these things first we are going to check that whether for this particular row or hash set is this value already present if the value is already present we can simply return false if that is not present we are going to add the value to that particular row hash set same thing we are going to do for the column that if the value is present we are going to return false if the Val is not present we are going to add that value to that particular uh subsequent columns hash set and then we are going to apply our formula where we are going to uh check for the particular box and then we are going to check that for that particular box if the value is present we are going to return false if it is not present we are going to return the subsequent correct value and basically if we get out of the loop we are simply going to return true that we did not find any place uh where where there was invalidity and we could have written false so now let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs decently fast compared to a lot of other Solutions in in terms of time complexity and also it is very convenient in terms of space complexity so I would be posting this solution in the comments so you can check it out from there also at the same time if you want to check all the solutions that I have done so far I have created a public repository where I'm putting all all of my answer and this is going to be a great resource for anyone who is trying to prepare for different Tech interviews so I would be pasting this link in the comments as well so you can check it out from there thank you hello friends vs not PL by a Fang company so let's not stop lead coding till we get there today we are going to do encode and decode strings lead code problem and as you can see this is actually a lead code premium problem if we see some of the companies who have already asked this question where I want to get a job there are companies like Facebook LinkedIn Google Square Uber Microsoft and Apple so all of my favorite companies have asked this question so that's why I'm paying my atmost attention I hope you also enjoy the video so this is the lead code medium problem and basically we are given a list of strings now we need to design an algorithm where we are actually encoding this given list of strings into a single string then we are told that that single string is supposed to be sent over a network and then when we get back to the machine we need to decode that given string into the original list of strings so let's try to understand this with an example so suppose we are given a string s where we are given bunch of different strings that looks like this so after this we will actually create an encoded string now this encoded string is combination of all of these four items and it is just a single string so let's say that this is the encoded string we have created now after creating this encoded string we need to write a function to decode the string as well and after we decode the string we should get a response that exactly looks like this and this would be the original decoded string we would get and this is what we need to return so we need to return the algorithm to encode the string and also an algorithm to decode the string so let's see that what would be the different approaches we can take okay suppose this is the original string we are given and we need to encode the string and decode the string the idea is we are actually going to use an extra character and where we are going to use an extra character we would put it where one string ends before other string starts and we will keep on repeating the same process and all we have to do is so that would be the way to encode the string after encoding the string when we have to decode we will just simply take that character and the moment we reach that particular character we would know that okay this is the place where one string ends so we would create a new string for that and then we will repeat the same process so let's see that in action so first of all suppose we take this character that looks like this hash right I'm just taking any random character uh the idea is you can discuss with your interviewer that what kind of character you can take so I take this ash uh now I do encoding string so the encoded string is going to be a then uh the moment I identify that the strings ends over here I would put a hash and I would keep a continuous string now I realize that okay this is a new string B so I would add a value B again I would put a hash now again this value is C again I would put a hash and again at the end I would find this value a b c and that would be the end of the string so now I have created an encoded string now if I want to decode the string uh the the decoding would work like this so first of all I'm iterating until I find that this is a valid string so valid string is a now I realize that okay this is the hash and hash is the character that I put it as an extra character as an encoding mechanism so I would remove this hash and I would treat this as a single string now I would again start creating a new string so again I find this value B the moment I encounter the string hash I would treat this B to be a separate string again I would encounter this value C and again I would encounter this value a b c and this is the way we will we are going to encode and decode the string and this solution would work as expected if we see the time complexity in this case the time complexity is actually going to be Big O of n why because we will have to iterate over all the characters that are present inside this given string s to and first of all encode and then decode so overall it would be 2 N but we can generically write it to be bigger of n now if we see the space complexity in this case the space complexity is actually not that much because we anyways we will have to create an encoded string and coded string and all we are doing is just using an extra space to solve this problem so this is pretty simple uh to me okay suppose this is the string we are given and the idea is we are actually going to add four bits that are going to store the length of Any Given uh sub substring and then we are going to keep on repeating the same process and we are going to create the encoded string so let me quickly show you what I'm suggesting first of all we would have an encoded string where first four character character is actually going to store the information that what is the next length of substring that is coming that we are going to iterate over so in this case this is actually length three so if we add it in binary represent as 0 1 1 so we are actually going to have 0 0 1 1 to be the length and then we are going to store these three characters as a b c okay now we are done with that again now this ends the first substring so now this is of length two so length two becomes 0 1 0 now we are going to do the same thing and then we are going to store this value ab and now this is also of length two so again we will repeat the same process and we are going to store the value of x and y and this is the encoded string what we have done basically is we have actually created block of four bits that keeps the information that okay in the next subsequent value these are the three characters that you will have to iterate over and that is how we are going to decode it so let's see the decoded string con action in the decoded string first of all we are going to iterate over this given encoded string now we iterate over these four characters and we find that okay value is actually three which means that next three characters are the characters of one of the substrings that we will have to separate so we will iterate over these three and put it in a substring and we will get a substring like a b c again we will iterate over these four characters and we realize that the value is actually two so because two we will have to iterate over these two elements and we would get the value a b now again we would iterate over this next four bits and we find that value Val is actually three uh two again so we will iterate over two more characters and we will get the value XY and then we would have a decoded string so this is also another way to store uh all the values now this solution also works as expected but I don't think that anyone is able to come up with this in the interview so I just showed you this approach just for the explanation purposes but actually I'm going to in the coding I'm going to show you the first approach that I Sol earlier so first of all we are going to do the encode function so let's take care of some edge cases first if that is not the case we are actually going to take a random variable that is not part of this uh original given string so we are given the condition that there could be 256 characters uh inside the aski character for this given string I so what we are going to do is we are going to take the 257th character as the character that is a separator between any two strings so first of all let's just create a string uh called the separate and we are going to assign the character 257 to it now we will start building our string now we will iterate over this given list of strings so first of all we are going to append the value of whatever the string we are iterating over and the moment the string ends we are going to add the separate character once this Loop ends basically we should have done with encoding our string now all we have to do is just delete the last character uh because that would be an additional room and once that is done all we have to do is just simply return this given this new string Builder we have created so now we are done with encoding our string let's decode our string if this given string s is actually of size uh whatever the located at 258 which means we are dealing with an empty string list so in that case we will simply return a new ARR list and we should be done if that is not the case which means that we we have a separated string so uh let's just assign a new character all we have to do is just return an array list where we are going to uh separate based on this given uh separate character and that's it let's try to run this code okay seems like our solution is working as expected let's submit this code and our solution is actually pretty fast compared to a lot of other solution it's not most optimal because I did not choose the approach two and uh let me know if you want to see the code for approach 2 as well thank you hello friends we are still not employed by Fan company so let's not stop lead coding till we get there uh today we are going to do longest consecutive sequence problem and this problem has been asked in Google Microsoft Facebook Apple uh Goldman Sachs Uber Twitter by dance so it's lot of companies and lot of huge ID companies that have asked this problem so I I'm going to pay my most attention I hope you also do it and uh I have I just have one request for all of you guys like uh my YouTube channel if you see most of the people they are not even subscribed and uh it takes lot of time and lot of effort to make these videos so I would really appreciate if you can just subscribe like uh basically we are given an unsorted array of uh integer nums and we need to return the length of longest consecutive elements inside the sequence uh also we there could be possible that there might be duplicates in our given unsorted array so we just need to take care of those as well and let's uh try to understand this with an example so the example we are given over here is and over here if we find that what is the longest consecutive sequence we can find the longest consecutive sequence we can make is 1 2 3 4 amongst these values and we can ignore just uh this 100 and 200 because there does not exist any uh consecutive sequence from those values so over here since we find four elements we can return the length of this as four and this would be our answer uh same way if we take another example over here we are given nine elements and all nine elements are actually part of the longest in longest consecutive sequence so in this scenario we are going to return nine so in the Bro Force approach we are not going to do anything clever we are just going to take the most basic approach that we can and try to find the longest con negative subsequence so suppose at any moment we are given an input like this we are given an empty list we can say that there exist zero longest common subsequence elements and suppose we are given an element like this suppose this is 100 we can say that there exist exactly one longest common subsequence element uh in this given input so that is a given right that even if with a single element we can at least Define that there exist one single longest common subsequence element now over here in this example since we know that there are at least more than zero elements uh in this given input and initially we are at this 100th position which means that we can say that the current longest consecutive subsequence we can find is one and now if we want to find a subsequence in the remaining group that cons that consist this 100 how can we do it like we can only do it in one scenario that in this remaining portion in this remaining element El if there exist element 10 1 if this exist we can see that 100 is also part of the or could be part of the longest consecutive subsequence so this and this would be our basic approach that at every single position we will try to find that whether the next elements could they be in the in the remaining input and if they do we will update our longest consecutive subsequence and uh whatever the maximum value we find we are going to return it as our answer so so we will also create another variable called current subsequence um and that would take care of what is the current subsequence that we are trying to find let's just name this current okay and initially the current subsequence is also at also one over here at this 100 position now we'll try to see that whether this 1001 exists in the remaining portion and it does not exist which means we will move forward so we'll move forward with the element 4 now for this element 4 we need to see that whether element 5 exist or not so element 5 also does not exist so we'll move on with this 200 for 200 we will see whether 2 2011 exists this also does not exist for this one we will try to see that whether two exist so two exist in the remaining array now because two exist the current subsequence we had was of value one we will update it to Value two now because this two exist exist we can not break right now we'll try to find more values so we'll again try to see that whether three exist and three also exist which is over here so again we will update this value to three again because three exists we will try to see whether four exist four also exist and it is present over here so we will update the current value of longest consecutive subsequence we have found to four now we will try to see whether five exist now five does not exist which means that four is the longest way of found so far and uh then we will try to update the value of longest consecutive subsequence we have found to whatever the current value is because uh previous value of this was one and now this new value is four but we are not done yet we are only check up until this one so now we will check for this two so again for this two we will and uh by the way we will re evaluate this value back to one because now we are starting with the new element so again for this two three exist so we will update the value to two and uh four also exists so we will update the value to three uh but we cannot update the longest common subsequence because four is greater than three and now we again check for this value number three so for Value number three four also exists which means that this value would become two uh for this value number three but we won't update and in the end we are going to return this four so this is our Brute Force approach like this solution works we get the desired answer but thing is we get the desired answer at a very bad cost like even if we just try to calculate the time complexity in this case the time complexity would actually be big go of n Cube why n Cube because we will need to iterate over every single elements at least once to find the longest common subsequence so that is n amount of work then suppose over here we are initially at this position 100 so we wanted to check that whether one1 exists so in order to do this check we'll have to also have to iterate over the entire Loop so then in that case we will have to do N More work and at any go any given moment suppose over here we identify that this for this one two also exist right and once we identify that two exist we will again check whether three exist again we will check whether four exist again we will check whether five exist so even to do these checks we will have to do N More work so again we will do n work so in total we are going to do n * n * n so n Cub work to solve this Brute Force approach and this is a very disastrous Solutions now one better approach we can think of is suppose that with the given input if we do some sort of modification can we come up with better solution in faster time complexity like of course we can uh so remember that what we are needed over here is that we need to find the longest consecutive subsequence of this given input and we are going to see with this custom example how can we modify the input and how can we come closer to solution so suppose in this given example rather than keeping the input just like this if we do sort the given input Things become much easier for us and let's see that what would be the sorted result okay so now we have our sorted result now in the sorted result we simply need to find that what is the longest common subsequence that exists longest cons netive subsequence that exist and it's pretty simple to find now because all we need to do is that at any point we know that the definition of uh common subsequence is that suppose we have we are currently at the value I then I + 1 would be a common subsequence then I + 2 would be a common subsequence and this is the only condition we have to take care of and the only other thing we need to worry about is having two duplicate values right next to each other if at any point we encounter to to duplicate values we simply ignore one of those values and move move forward so in in this example we are only going to do two checks uh with the sorted input first check we are going to do is at first position we are going to check that whether this position is exactly same as whatever the previous position we had if that is true we would skip over because we don't need to uh do anything with that because there are two consecutive two same values and if that is the case so which is the case in this scenario that both values are same which means we would skip over so we would go to the next element and now we are at this next element again we are going to check that the value we are currently at and the value before that if they are same or not so in this case they are not same if they are not the same we are also going to check one more thing that whether the current value of a of I so suppose this zero is actually a of I and minus whatever the value of a of I -1 so a of i - 1 in this case is -1 one so if difference between these two values if it becomes exactly one which means we can conclude that these two values are part of the longest common subsequence and uh we could update their value again as again like Brute Force we are going to use two variables one variable to keep track of longest common subsequence we have found so far and second one is to keep track of the current uh subsequence that we are working on so let's see that how how it would work and both both the values would be set up as one initially now initially we are at this zero and one pair and because they are sorted we know that they are always they are always going to be adjacent to each other so this is the only condition we need to worry once we identify that the both values are not same so in this case we can see that uh the current longest uh the current subsequence we have found is actually size two so we can update the value over here that this is this is two now again we check with this value now this value again again it's zero and it's the same as this one so we ignore ignore it we don't need to do anything now again we check with this value so this value is actually two now with this two if we put down this equation so 2 - 0 this is not equal to 1 which means that uh this two and zero are not part of the common subsequence uh if they are not part of the common SE subsequence we we check that now we can't update this current anymore so we check between the current and long longest common Subs sequence we have so far and the current is actually greater which means we will update the longest consecutive subsequence to two as well and now current we will put it back to one because we will repeat our our search again now we are at this position three so three and two are not same and uh 3 - 2 is actually 1 which is true which means we update our current so current would become two now we are at this four again 4 - 3 is equal 1 so again we update our current to 3 again we added this five so again we need to update our current so current would be updated to four uh because all of these values 2 3 4 5 they are in a common subsequence now we are at the 7 so 7 - 5 they are not equal to 1 which means we we can't update the current so we will need to reset the value of the current so before for resetting the value of the current we are also going to check that whether the longest common subsequence needs to update and this needs to be updated to value four because this this one was four before because of these four values and now we can set this value to one again at this position 7 and now we are at this position 200 so 20 and7 they don't have any correlation so we can't do anything about it and in the end at the end of the loop we are simply going to return return whatever the longest common subsequence or current subsequence whatever the maximum value value we have found between these two and in this case the maximum value we have found is actually Four so this would be our solution now this solution works pretty efficiently it's pretty neat and if we see the time complexity we can complete everything in just one single iteration so we are only doing uh n work but thing is the time complexity in this case would be go off and log n because initially remember that from this given input we will actually have to sort the array as well and sorting takes and log and time but overall if we still compare it with whatever the Brute Force approach we had brute force was actually big of n Cube so this was really bad time complexity and this is much more and much bigger Improvement Upon Our uh scenario now in the optimal solution we are actually going to try couple of things uh first thing we are going to do is we are going to create an additional data structure called uh hash set and in the hash set we are going to enter all the values that we have found from this array so suppose we create a hash set something like num set now in in this hash set we are going to add all of these values now because we have our hash set ready what we are going to do is uh when we are going to iterate over this hash set and we are only going to start checking for the longest consecutive subsequence from the elements that could be at the start of the ele start of the longest common subsequence and what elements can be start of the longest common subsequence quence well so if we take take this example we can actually see couple of uh uh common subsequences or consecutive subsequence one consecutive subsequence we can find is 99 and 100 which is at these two positions and second consecutive subsequence we can find is actually 1 2 3 and four now in the what we are doing in the Brute Forces we were checking at every single position that what would be the longest common subsequence we can find but thing is we can only find the longest common subsequence from the first element of the start of this uh consecutive subsequence same goes over here that whatever the subsequence we can find at this value number 100 the subsequence that we can find at Value number 19 and would always be greater than whatever we can find over here because this by itself is already a subsequence so we are going to use this logic like over here if we put this three to three four we will only find the uh consecutive subsequence of length two but this 2 3 4 would have would be three uh would be of length three and this 1 2 3 4 would actually be of length four so we can only find the maximum consecutive subsequence at the start of the uh any uh sub any subsequence not and not somewhere in the middle and the only way to check that whether we are at the start of the subsequence or not is by just checking one very simple uh condition that that at any point we check that whether the exact value before that value like one value before the value we currently are at if that exist which means that we are not at the start of the common subsequence let's take it by an example over here and let's see that what would be our approach so first of all we are going to be at this position 100 we are going to check that whether this 100 is start of any consecutive subsequence or not so we check that whether in this given num set does the value 99 exist now we know that 99 exists so because 99 exists 100 cannot be at the start of the common subse consecutive subsequence so we are going to IGN ignore this case we don't have to do anything with this 100 we come up at 99 now we come up at this 99 we check that whether there exist a value before 99 so 98 does it exist in this num set 98 does not exist which means that at 99 we can be at the start of any common consecutive subsequence so we start a subsequence at 99 and now we will uh initiate initiate our logic and in our logic we are simply going to check that from this 99 how many consecutive numbers we can reach so we are going to check that okay 99 by itself is a common subsequence of length one so we know that now from this 99 we are going to check that can we reach value number 100 so 100 we can reach and because we are using a hash set we can do all the operations in constant time so we are not adding any strain in our time comp complexity now we can find the value 100 so we can reach 100 which means that the whatever the longest common subsequence that we longest consecutive subsequence we found we will increase its value to two now again we will try to see that whether we can find 101 like 101 does not exist which means we would break out of over here and the longest common sub subsequence we have found up until this point is actually of length two again we are going to repeat the same process so now we are at this position four we check that whether four uh whether three exist in this set or not so three exist which means we ignore this four now again we are at 200 so we check that whether 199 exist so 199 does not exist which means 200 can be start of the any consecutive subsequence so we again check that whether 2011 exist but 2011 does not exist in this given example so we ignore this 200 as well because the longest consecutive subsequence we find that this value number 200 is always going to be one and we already have a value that is greater than one again we check at this position one that can one be start of any consecutive subsequence so we check that whether the 1 minus 1 so we check whether zero exist in this example or not zero does not exist which means one can be start so now we set our current uh subsequence to Value number one and now we check that from this value one how many other values we can reach to so first we check that can we reach the value number two yes we can reach value number two because two already exist so we update whatever the current subsequence we can find to two now from this two we check can we reach three again we can reach three so we will update the current value to three again we check that whether from this three can we reach four and yes we can reach four as well so again we will update the value of our four uh value of the current subsequence to four and from four we check whether we can reach five so five we can't reach which means we are at least able to reach this four so we are able to see that the current subse the longest current subsequence we have found is four and previous value was two so we will update this so this will become uh four and now again we are going to check the same thing for this value number two so that for Value number two does one exist and one exists so we will ignore this again we check for three does two exist two also exist which means we are going to ignore this three and now since we have reached the end of this hash set so we are going to reach whatever we found in the as the longest consecutive subsequence and this would be our answer now if we calculate the time complexity the time complexity would actually be bigo of n in this case because we are only iterating over the entire uh input just once uh through this hash Set uh so this this is a very efficient time complexity and if we see the space complexity the space comp complexity is actually big of and because we will have to create this additional numerical set and we are going to uh store and memory for that and uh let's see the coding I will be showing the hash solution in this code uh but I'm going to post both the codes in the comment so you can check it out from there so first of all we are going to check that whether we are given an empty list or not if that's not the case uh first of all we are going to create a hash set we are going to name it num set now we'll run a loop across the the given input and we are going to store all the values to to our hash set this is going to do two things uh it's going to eliminate all the duplicates values and it will only add unique entries in the hash set because hash set has a property that does not allow us it to store duplicate values now we are going to create a parameter to store the longest subsequence and we are going to initialize it with value one now we are going to run a for Loop across the given num set so so initially we are going to check that whether we are starting from the middle of any longest consecutive subsequence if that's the case we are going to ignore that uh number so if this condition is true we are going to uh continue and go to next element in the loop if this is not the case we are first of all going to Mark the current the number V are at as current number because this is the beginning of any uh longest consecutive subsequence we are also going to create another parameter called current sub that is going to take care of of uh the current maximum uh consecutive subsequence we can find and we are only in we are going to initialize it to one and now we are going to put a condition that while uh our hash set contains the current number + one while this condition is true we have are going to increase the number and we are also going to increase our current subsequence and after this Loop ends we need to check that whether we have found the longest common subsequence or not so once this Loop ends uh we should have our answer and the longest sub variable so we can simply return that let's try to run this code okay seems like our solution is working let's try to submit the code and seems like our solution works pretty well and uh it is faster than a lot of other Solutions I I will also post the the Sorting algorithm solution as well so you can check it out from the comments Hello friends bslo by a f company so let's not supp leete coding till we get there today we are going to do valid palindrome lead code problem and if we see some of the companies where I want to work at who has already asked this question there are companies like Facebook Amazon Microsoft Apple Bloomberg Spotify Adobe Tik Tok Google and Uber so that's why I'm paying my atmost attention I hope you also enjoy the video so this is a lead code easy problem and basically we are given the definition of what a palindrome is uh we are told that after converting all the uppercase letters into lowercase letters and removing all the non-alpha numeric characters if the string reads same as forward and backward then we can determine that any uh given string is a palindrome now we are given a string s and we need to return true if the given string is palindrome if if not we need to return return false so let's try to understand this with an example over here we are given a string that looks like this where you can see that there are some alpha numeric characters as well which we will have to get rid of this is only put there just to add some sort of additional complexity apart from that it serves no purpose this is the original string that we are given now if we convert all the uppercase letters to lower case and remove all the alpha numeric characters we will actually get a string that looks like this and if we see for this particular string uh if we start going from the front and even going from the back we will see that all the characters that are present from the front they are also present from the back in the same order so that is why we can determine that this string is actually a palindrome and we will return return true in this case uh we are given another example that looks like this over here we can also see that there are some alpha numeric characters which are the two space values so we will have a string that looks like this and over here if we try to see that whether this is a palindrome or not currently this r r matches a a matches c c matches but this e actually does not match over here and over here actually we have an A so that's why this is not a palum and we will return false in this case so let's see that what would be the approach to solve this problem now suppose this is the example that we are given and we need to determine that whether this given string is a palindrome or not the approach I'm suggesting is first of all we iterate over this given string we get get rid of all of these characters that are alpha alpha numeric once we do that then we will create a new string that is actually reverse of this original given string and now we have two strings in at our disposal all we have to do is compare both the strings if they are same we can determine that they are actually palindrome and we can return true if they are not the same we can return false immediately so let's see that in the action so first of all we are going to create a string from this original input string where we are going to get rid of all of the uh non-alpha numeric characters once we are done that now we are going to reverse the string so we are going to create a new reverse string from this original given string and we are basically reversing whatever this given input is in this case if we compare this given uh uh reverse string and whatever the string we are given they both possess the same value which means we can determine that this given original input is actually a palindrome and we can return true in this case so this is one of the solution where we can work with and the solution would work as expected no issues with that let's see that what would be the time and space complexity over here so the for the time complexity actually first of all we are iterating over this given string to remove all of the alpha numeric characters and then again we are iterating over this given string to create a new reverse string which means that we are essentially trading over this original string two three times and comparing it and basically we are doing bigo of n work but actually we are doing like big go of two times n work uh in terms of space complexity we are because we are creating this new original reverse string so that is why we are also consuming some space so that's why the space complexity in this case is also going to be big of n where n is the number of characters that is present inside this given string so this approach is okay it's Justified it works as expected but the question is uh can we do something better in terms of space complexity and even in terms of time complexity and yes that is a better approach and let me quickly show you how okay so for the optimal solution what we are going to do is suppose we are given an input that looks like this now over here we are actually going to use a two-p pointer solution and we are going to have a left pointer and a right pointer and initially the left pointer is going to be located at the leftmost position and right pointer is going to be located at the end of our string now at any given moment we are going to compare that what is the character value of left and right pointer and we are also going to check that whether this given left and right pointer if that is that like a non-alpha numeric value if that is the case we will just like uh increase the value of left or right pointer and uh if the if both the values are same essentially we will move the left pointer on the right side and we will move right pointer on the left side and we would keep on doing this process until left and right are adjacent to each other before right crosses the left and if we are able to reach to that point we can determine that this is actually a true and valid palindrome if that is not the case we will basically return false Falls at any given moment if we identify that left pointer and right pointer character values are not matching up so let's see that in action suppose this is the string we are given currently the left is located at this m and right is located at this uh small M but in both the cases we are only dealing with lower case English letter so even if we encounter an uppercase English letter we would convert it to lowercase English letter we would treat it like this so this m is equal to M so far we are good which means we will have to update the value of left and right pointer so now this left pointer is going to go to the next value which is over here and this right pointer is going to go to a previous value which is over here now at this position right uh we actually identify that this is not uh an alphabet so we would again update the value of right pointer and we would ignore this case and this time right pointer comes over here now because both of these are valid alpha numeric value we will try to see that what are their values and both are located a a which means they are same so if they are same again we are good up until this point again we will update the value of left and right pointer so now left pointer is at D and right pointer is actually located at this colum over here so because this is not an alpha numeric value again we are going to ignore this and we are going to update the value for right pointer so now right pointer would end up at the same position where left pointer is if we again compare the value both are going to be DD so again we are good up until this point now we don't have to do it but because in our algorithm we are specifying that we need to check before right pointer crosses the left and in this if we do one more iteration essentially right would come and left would come over here which means that they would be Crossing each other and which is not what we want so we have already concluded that all the characters inside this given string they are actually part of a palindrome and we can return true in this case and this is the approach we are going to take now if we see the time complexity in this case the time complexity is actually going to be big go of n only because we are completing everything in just single iteration uh we are having our left pointer move to the right side and we are having our right pointer move to the left side and uh we stop when they meet now in terms of space complexity we are actually uh doing it pretty efficiently we are only using couple of pointers to store uh in our space so that's why it's only a constant space that we are consuming and this approach is much better approach and we we will conclude this as to be an optimal solution now let's move on to coding first of all we are going to initialize couple of variables called left and right and we are going to assign the left to be value zero and right to be value uh to the end of the string so now we are going to run a loop that while left is less than right so now first of all we are going to check that if the current value on the left side if that is not alpha numeric uh we will have to update the value of left pointer same thing we are going to do with the right pointer but we are actually going to reduce the value for the right pointer and if we identify that both left and right are correct letters we are going to check their values and if they are not same we can return return false immediately if they are same we will continue updating the loop so if that is the case if the characters are not matching after converting them to lower case we can return false immediately and if that is not the case uh we would update the values of left and right pointer and once this Loop ends essentially uh if we get out of the loop without returning false we can simply return true now let's try to run this code okay seems like our solution is working as expected let's submit this code and our code is actually pretty efficient I would be posting this in the comments so you can check it out from there thank you hello friends we are still not employed by Fang company so let's not stop lead coding till we get there today we are going to do two some2 lead code problem where input array is sorted and if you see some of the companies where I want to get a job who have already asked this question there are companies like Amazon Apple Uber Google Facebook Bloomberg Microsoft and Goldman sax so that's why I'm paying my atos attention I hope you also enjoy the video this is the lead code medium problem and also a very well-liked problem uh this 2m 2 problem is actually very similar to the two some problem which we originally solved over here so you can check it out that solution if you want now let's understand this problem statement so basically we are given a one index array and this is only given one index just to add some additional complexity uh nothing more than that and we are also given an array of numbers now we are told that all the numbers they are already sorted in non- decreasing or ascending order now we need to find two such numbers that they add up to a specific Target and we are also given this target value as the input for our method as well now uh we need to provide the index values for those those two numbers as the answer so let's try to understand this with couple of examples so if we take this example one and two over here I have drawn it much bigger over here so first of all we are given a nums array like this and if you notice that the indexing is actually starts from one rather than starting from zero we are also given some Target Valu so in this case the target value is N9 so now we need to find any two values that sums up to 9 so we can clearly see that 2 + 7 = to 9 uh and in this case we need to return the index value of this 2 and 7 so the answer in this case is going to be 1 and two as the answer uh if we take second example over here we are given the target value to be six so clearly we can see that 6 is going to be the sum of actually 2 + 4 now remember we can also do over here like 3 + 3 but the thing is we cannot repeat the same character again so in this case the answer has to be 2 + 4 that equals to 6 and uh we need to return the index value so index values in this case is going to be 1 and three and this is going to be the answer so after understanding the the problem statement let's see that what are going to be the different approaches to solve this problem so the first approach that comes to our mind is a Brute Force approach uh in The Brute Force approach what we can do is we can simply take every single possible two pair that we can make and try to see that whether we can come up with the target value for those two pairs if we do get the target value we simply return their index numbers so in this case we we are given the target to be 11 now we can make different pairs that looks like this that first of all we'll take the first number and then we will make all the possible pairs we don't find any sum that comes up to 11 so we can ignore this one now we will start with the second value and keep on repeating the same process so the moment we do that when we do the sum of this 5 + 6 we get 5 + 6 to be 11 and this is the answer so in this case we can return their index Valu so in the index values in this case is going to be 2 and three and that is that would be the answer we can return return now this broad for solution leads up to the correct answer uh in terms of the index values that we are looking for but thing is this is not the most efficient way to do it because we have to deal with lot of different sub arrays or sub pairs so if we see time complexity for this Brute Force approach it actually it is actually big of n Square because for every single value we have to compare it with all the other remaining values and that is pretty disasterous so let's see that what is going to be the better approach okay so the next approach that comes to our mind is a binary search why binary search because remember we were originally told that this input array we are given that is a already a sorted array which means all the values that they are sorted in ascending order so we can actually use binary search to our advantage in order to find the target value pair uh the approach I'm suggesting is that first of all we take any value okay so the current value in this case is true right so if we have if two is supposed to be part of this answer let's imagine that two is part of this answer then two can two can only be part of the answer if uh the value 11 - 2 = to 9 if this 9 is somehow present inside this given input array we can clearly determine that 2 and nine can be part of the answer that leads up to the Target value 11 so all we need to do is uh once we identify the value number two we come up with the remaining value that is needed to generate the answer that is nine and then we can simply do a binary search in this case to see that whether 9 exist or not we can find this immediately in log n time because this array is already sorted so at any given moment all we have to do is just calculate the middle value and see on which side of this middle value does this n Falls and eventually that would lead up to the current correct answer so first of all if we see for this value number two 9 does not exist right so because N9 does not exist we can ignore the case for this value number two and we can Define that two is not part of solution that leads up to the Target value 11 now again we are going to repeat the same process now the next value we have is five so now if the value is five all we have to do is to see that what is going to be the remaining value and remaining value in this case is going to be 11 minus 5 so 11 - 5 is equal to 6 so now we only have to check that whether the six exist inside the remaining array or not and that we can do using the binary search in log and time so now what we will do is we'll try to find the middle value let's see that middle value in this case is 12 so 12 is greater than 6 so because 12 is greater than 6 we only have to compare between these three values so again the middle value is8 again 8 is still great greater than six so now we only have one value on the left of the eight and right of the five so uh which is already six so immediately we can find that value and because we find both five and six to be existing so 5 + 6 equals to 11 we can simply return their index values to be 2 and three so uh 2 and 3 is going to be the answer in this case if we see binary search actually works pretty better than our Brute Force approach why because if we see if if we try to calculate the time complexity in this case the time complexity is actually going to be biger of n log n why n log n because in the worst case we might have to iterate over every single character in order to find the target value and for uh us to find the remaining value we have to do log and work so again if we see this solution this solution is much better compared to a broad Force approach which had the time complexity of big of n squ uh now the question is is this the most optimal way to solve this problem and the answer answer is no there is still one more solution that can give us the answer on in big off end time okay so the optimal solution I'm proposing is actually using two pointers so suppose this is the array input array we are given and we are given the target value to be 13 right now we already know that uh 6 + 7 is going to be the answer but let's quickly see the approach I'm suggesting basically we are going to have two pointers left and right now remember all the values that are on the right side of this left pointer are actually greater than this value of Left Right and same way all the values that are on the left side of this right pointer is actually less than whatever the value at right pointer we had so the idea is originally we are going to do the sum of this left pointer and right pointer we are going to compare that sum to this target value now if the sum is actually greater than Target value which means we need to lower the sum how can we lower the sum we can only lower the sum if we move move this right pointer on the left Direction because remember all the values that are on the right that are on the left of this right pointer they are actually less than this right pointer so if we reduce the values automatically sum is supposed to go down and that would lead us to that would lead us near the target value right again same way if we identify that sum somehow is actually less than the target value if sum is less than the target value which means we will have to increase the value of the sum how can we inre increase the value of the sum by increasing the value of the left pointer because all the values on the left pointer are actually greater and right pointer will remain constant in that that case and if we keep on repeating the same process until we come up to the sum that equals to Target value eventually we would get the two pointers located at the correct position that would lead us to the correct answer uh how let me quickly show it to you and by the way let me also Mark the indexes in this this case as well so now we have our left pointer and we have a right pointer and we have the variable sum right currently left is equal to 2 and right is equal to 42 if we see sum of these two sum is actually going to be 44 44 is definitely greater than 13 so because 44 is greater than 13 we have we will have to somehow reduce the values so what we are going to do is we are going to update the right pointer to move one point to the left side right so now our new right pointer is going to be this one so now our right pointer value is 21 so 21 + 2 is still going to be uh 23 now 23 is again greater than 13 so because of that we are going to shift our right pointer again so now right pointer is at 12 12 + 2 is 14 14 is still greater than 13 so again we are going to switch our right pointer so now right pointer is at position number 10 so now the right pointer value is 10 so now 10 uh 10 + 2 is equal to 12 so 12 is not greater than 13 is actually less than 13 so now we will have to update our left pointer so if we update our left pointer our left pointer is going to become value number five right so now this value is 5 5 + 10 is again 15 so 15 is again greater than this value number 13 right so now again we are going to switch our right pointer to go one point to the left so now the right pointer value is actually 7 so if we do 7 + 5 7 + 5 actually gives us the answer to be 12 right so now this 12 is still less than the value number 13 so because this is less than the value number 13 again we are going to update the value pointer of the left pointer so now left pointer is at position number 6 right pointer is at position number 7 6 + 7 is equal 13 which is exactly equal to whatever the target value we had and that is the correct solution so now basically the positions of left and right pointer we simply need to return that as the answer so answer in this case is going to be three and four and this is the correct way to solve this problem now what is the benefit of this approach well if we see we are actually Computing everything in just single iteration we are not doing multiple repetitive work so if we see time complexity in this case the time complexity is actually going to be big off n which is a much better Improvement compared to our Brute Force approach and also our binary search approach uh if we see space complexity in this case the space complexity is actually going to be constant because we are not using any additional space apart from storing couple of variables which is also a good sign now let's move on to the coding so first of all we are going to initialize the two variable left and right now we are going to run over while loop that while left is less than right now inside the loop first of all we are going to check that whether the combination of left and right if that is greater than the target value so if that is the case we will have to reduce the sum which means we will have to reduce the value of the right pointer so right is going to become right minus one else if we are going to check that whether the sum is actually less than the target value if that is the case we are going to update our left pointer to go one step to the right that is not the case which means we are actually at the correct position so we can simply return uh the index values but remember we are presented with one index array so we are going to add one value to the left and right and this was just the additional small complexity they added to the problem otherwise it would have been too simple and uh basically in this Loop we are taking care of everything so we should have gotten the answer if somehow we get out of the loop without returning the answer we can simply return null that we are not able to find the answer and that should do the trick let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs decently efficiently compared to lot of other Solutions in terms of time complexity in terms of space complexity it's actually pretty efficient because we are not using any additional variable to store the sum uh and that's it uh let me I would be posting this solution in the comment so you can check it out from there thank you [Music] today we are going to do threesome lead code problem and it is a very interesting problem if we see some of the companies where I want to get a job who already asked this question there are companies like Amazon Microsoft Apple Facebook Uber Bloomberg Google Tesla by dance and Linkedin so that's why I'm paying my at most attention I hope you also enjoy the video so this is a lead code medium problem and also a very well-liked problem on lead code basically we are given an integer array called and we need to return the tripletes now we need to return the triplets such that the sum of all of those triplets is actually equal to zero and we are also given the definition that the elements has to be unique so i j and k is supposed to be the triplets then they should not be the same they should be different values we are also told that the answer set must not contain any duplicate tripletes so this is an additional set of complexity that we will have to take care of now let's try to understand this problem with couple of examples that are provided over here and I have actually broadened these examples so let's try to understand them so suppose this is the input array nums we are given we need to find the triplets such that uh the sum of each of all the triplets is equal to zero so if we see that in this example we can actually find the sum of these three values to be zero so first of all we are going to add these three entries into our answer that minus1 0 and 1 uh this triplet equals to zero so we can add that to our answer list uh second triplet we can find is the value -1 again -1 and value + 2 because -1 + -1 + + 2 is also equal to Z so again we can add it to our answer Set uh that 2 -1 and min-1 is the answer now apart from that we cannot find any more triplet so this this is the only answer we are going to return one critical thing to understand over here is that this minus one is actually using two times in two different answers that is perfectly fine but we cannot have an answer where we already have the value like min-1 0 and minus1 and again we have the value Min -1 0 and + one this should not be the answer so this is one of the conditions that is given uh second condition is that all the values of i j and k has to be unique so they are located at unique positions because we cannot use the same value again and again we cannot do something like 0 + 0 + 0 equal to 0 and return that as the answer of the triplet because in this case we only have one zero not three zeros so just keep all of these things in mind if we take a look at the second example over here we actually do not have any pair that equals to zero right so in this case we are only going to return an empty array as the answer and basically this is what the problem is asking us us to solve now there can be two potential solutions for this threesome problem that we are trying to deal with uh first solution is actually a twosome problem solution that is also another lead code problem where we use hashing to generate the solution for this toome problem uh second solution is two some two problem where we actually use two pointers to come up with the that solution and in this case we are going to see that how using hashing we can solve this threesome problem or how using two pointers we can solve this three threesome problem because both of this concept can be useful uh we can choose either one of them now I'm going to show you uh the theoretical knowledge of both the problems but I'm only going to show you coding for this two sum 2 problem let me know in the comments if you want to see the code for this two some problem as well and I can uh show it to you okay so first let's see that what is going to be the optimal solution using the solution we used in the twm problem now if you want to know more about Tome problem you can check out my video over here and that is going to give you much more clarity okay now let's get back to the our question so if we suppose this is the original input that we are given and we are trying to find a set of triplets that sum up to zero right which means we are trying to find three different values where I + J + K is equal to Z okay that is the whole idea the technique we are going to use is that okay suppose this is the first value right suppose if we consider I is equal to - 5 once that is done what we will have to do is we will have to try to find that if J + K is equal to + 5 if that exist inside this remaining array if that is the case then we would actually have a triplate called I + J + K that sums up to 0 because I is equal to -5 J + K is equal + 5 and now we simply need to see that inside the remaining array do we have a pair j+ K that is equal to+ 5 and that was actually the original question for this two some problem so that is how everything is linked internally the idea is okay that we can find it easily using a hash map or a hash set and then we would be able to get this answer the problem that would come in this case is that because we are trying to avoid duplicates and what would happen with this approaches that okay suppose if we consider I equal to - 5 right we would actually have an answer where the values of - 5 0 and + 5 exist as one of the answer and we are able to generate this okay so now we are able to say that okay this minus 5 we have already taken care of and we found the correct answer but if we look somewhere inside the remaining array we would also find another minus 5 so when we try to repeat the same logic basically even for this minus 5 we will also have the I is equal to- 5 and we will try to find J + K equal to + 5 then again we would have another answer that also looks like - 5 0 and 5 and remember these is going to be the duplicate value that we are trying to avoid so in order to make our lives easier what we can simply do is if we take this input array and if we sort this input array and because if we when we sort this input array we are going to have the same looking values right next to each other so we can only have a condition that the moment we find out that two adjacent values they are same if that is the case that if we find the two adjacent values to be the same then we are simply going to ignore that case and move on to the next value okay so now after this whole explanation uh let me clean this up a bit and uh create the sorted array so now we have our sorted array right now we are trying to we we will try to see that what could be the potential i j and k values now based on the I value we will also have to determine that what should be the J plus K value and based on the J value we'll also have to determine that what should be the K value right that is how we are going to do the things so first let's try to see that if I is equal to -5 if I is equal to minus5 we will have to find J + K is equal to + 5 if we have to find j+ K is equal to + 5 we'll try to start iterating over this remaining array again we are going to create a hash map or a hash set over here so let's create a hash set first okay now uh we are going to start iterating over all the remaining values okay so suppose this value is minus 5 so we'll try to consider J to be minus 5 if J J is equal to be - 5 then K has to be + 10 and now we are trying to see that okay we'll see that if this K is equal to 10 exists if that is the case we will return that if it does not exist we are going to add that value to our hash map okay okay so because K is equal to 10 does not exist we will have to add all the values to our hash map and remember there is a property of a hash set where it does not exist duplicate value so we will only have unique values inside over here so since J is equal to - 5 didn't work we'll try to see that whether J is equal to-3 works or not so if J is equal to- 3 then in that case we will need the K value to be + 8 plus 8 also does not exist and we can look that up immediately because of this hash set right now we'll try to find another value okay so if that didn't work we'll try to see that whether J is equal to Z works or not okay so if J is supposed to be zero then the value of K has to be + 5 okay that we can look up immediately and we would be able to find that K is equal to + 5 already exists inside our hashmap so immediately we found that we are actually going to have an answer list where we are going to populate the values of i j and k we found okay so we are going to add the values - 5 0 and + 5 immediately now we are going to repeat the same process for the all the remaining values right so and uh for every single value we will also have to create the new hash set and new i j and k values so we will empty this one okay now the new I value is actually minus 5 the thing is this is a track because we already had a value minus 5 that we already iterated over so we will not have to use this one and that is how we are going to avoid duplicates now suppose if next I value is minus 3 okay say if I value is min - 3 then J + K has to be + 3 okay so if J + K has to be+ 3 Let's see that what could be the potential remaining J + K values over here okay so over here currently J value is zero so if J value is zero then K value has to be plus three okay so we'll try to see that inside the remaining array whether plus three exist or not plus three does not exist but that is going to help us fill fulfill our hash so we are going to add all the entries to our hash map and uh we couldn't find K is equal to 3 so now we are going to try the new value of J J is equal to 0 so again because this Zer we already consider for J we should not be considering this zero so we can just simply jump over okay so now next value is J is equal to 1 if J is equal to 1 we will try to see that whether K is equal to two exist or not and K is equal to 2 already exist that we can clearly see over here so because it exists we are actually going to have J and K values properly set up and uh we are also going to add one more triplet to our answer that is minus 3 1 and two okay now we can ignore this one okay now current I value is zero okay if I value is zero then j+ K has to be zero okay so now we are we will try to find j+ K to be zero now inside the current method okay now this next value of J potential value of J uh this is the zeroth value so we'll try to add this value and by the way I forgot to clear the hash but it would be cleared okay now uh if J is equal to zero then K also has to be zero okay so currently K is equal to 0 does not exist inside the remaining array so because it does not exist we will try to jump onto the next value of J if J is equal to 1 can work or not so if we try to put J is equal to 1 it is definitely not going to work and we won't be able to find a pair J + K is equal to 0 so I is equal to 0 is also not going to work because I is equal to Z not going to work uh and U and we are we have already taken care of this zero so which means we don't have to see for this zero now we'll try to see that whether I is equal to work or not but the question is do we really want to check whether I is equal to work one is going to work or not because inside the remaining array all the values are actually going to be positive values so because these values are going to be positive values J plus K is always going to increase the value of whatever the sum of i j and k is going to be because I is positive so immediately we can stop our search and whatever the answer we have found we can actually return return that as the answer and that is the whole approach and if we see time complexity in this case the time complexity is actually going to be big of n log n that is to sort the array plus b go of n squ why because for any single I value we will have to find J and K value which means for every single one of them we will have to iterate over the entire list of all the arrays so that takes like B big of n square and that is the best we can do if we see space complexity space complexity is also going to be big of n because for this sorting operation it takes big off end time and plus we are also creating this hash so that also takes big off end space okay now we will try to see that what is going to be the optimal solution using the two sum two problem now if you want to learn more about this problem you can check it out my video over here and this is a very good explanation for that now uh we are going to use the same example as the input and as mentioned for the reasons explained before basically we are going to use the sorted array in this case as well so from this original input we are actually going to create a sorted array first so that is going to help us avoid duplicates now the again idea is that currently we are going to consider the one value to be I okay so suppose we are going to consider I is equal to Minus 5 if that is the case J and K value could be po potentially possible where J + K is equal to + 5 right and inside this remaining array we will have to find the plus 5 value so what we are going to do is we are going to initialize couple of variables uh so first is going to be left pointer and the second is going to be right pointer now every time we are going to do left plus right if left plus right is equal to 5 then basically we are good our life is set and we can simply add it to our uh j+ K values if that is not the case if we somehow find that left plus right is actually greater than five if that is the case then somehow we will have to reduce rce the sum of this left plus right how can we reduce the sum of left plus right by shifting this right pointer on the left Point left hand side why because all the values on the left of this right pointer are actually less than whatever this right value we had and uh if somehow we identify that okay this left plus right is actually less than the answer five if that is the case we are going to update our left pointer to go one step on the right side so then we would be able to increase the sum that we are trying to achieve and that is how we would be able to generate the correct J and K values so let's try to see the approach in action so suppose currently the I value is equal to -5 okay I is equal to - 5 J + K is equal to + 5 we are trying to find so once we have the J + K value we are trying to find we are going to initialize two variables left and right okay so currently our left pointer and right pointer we are going to be concerned with that and we are also going to be concerned with left plus right sum and uh how that is referring to whatever the value we are trying to find okay so currently the target value is 5 okay now the current left position is min - 5 current right position is + 5 so left plus right is equal to 0 0 is actually less than -5 so because 0 is less than Min - 5 we will have to update the value of our left pointer to go one step on the right so now the current left pointer is minus 3 Min - 3 + 5 so if we do - 3 + 5 the value we get is 2 2 is still less than 5 so because 2 is less than 5 again we are going to update our left pointer so now the left pointer is at zeroth position right over here uh and uh currently the sum we going to get is that okay this is 0 this is 5 so 0 + 5 is equal to 5 So currently left plus right is equal to 5 5 is exactly what we are looking for based on this uh remainder value we have created okay so now this left pointer can be assigned to this J value and right pointer can be assigned to this K value and we can actually populate our answer so inside our answer we are going to have the first entry called - 5 0 and + 5 as one of the answer okay now we are done with taking care of this - 5 so now we'll have to take care of this another value but again same thing this value is also Min - 5 same as the previous value so again we are going to ignore this case as well and now currently our I is going to be minus 3 okay so now if we put our I to be minus 3 uh our j+ K sum has to be + three in this case Okay so J + K has to be+ 3 again if J + K has to be+ 3 we will also have to update our left and right pointer So currently left pointer is also going to be at the position zero right is going to be position number five okay and we will also have to update this value as well that this has to be three okay now uh currently 0 + 5 is actually 5 5 is actually greater than three so because 5 is greater than three we will have to reduce the value of our right pointer So currently our right pointer is going to come over here so now the right pointer value is actually two okay so if we do 0 + 2 0 + 2 is actually going to be three so three oh sorry so now if we do 0 + 2 0 + 2 is actually going to be two 2 is now less than whatever the value of three is because of that we will have to update our left pointer to go on the right side now the moment we do that okay this value is also zero same as the previous value so because of that because we have already calculated this zero we are actually going to ignore this zero as the left pointer and our left pointer is going to come over here okay so now the value of our left pointer is actually 1 so 1 + 2 so 1 + 2 is actually 3 and three is what we are looking for that we already find the answer so we are also going to populate the values of left and right over here and inside the answer we are going to have one more entry called Min - 3 + 1 and +2 okay now uh okay now we have taken care of all the cases now again this value I is equal to Z if I is equal to 0 we will not be able to generate the answer and now in this case I is going to be one so that is going to be the positive value so because of that we are actually going to break out of it and simply whatever the answer we have found we are able to return that as the answer using this two pointer solution and even for if we see the time and space complexity in this case the time complexity is also going to be bigo of n² plus bigo of n log n why because we will have to do the Sorting operation uh if we see space complexity the space complexity is also going to be bigger of n that is going to depend on the implementation for the Sorting we are using uh so that is how we are able to generate the solution if you see in this case we are actually not using any additional H set so that is a plus benefit in my opinion and if you show both the approaches in any interview interviewer would be like more than happy with you so first of all we are going to sort the given input nums and we are also going to create a new variable called result to store the list of list that is needed over here now we are going to run a for Loop across the given input nums notice inside the for Loop we are only running it up until the point where the value of nums of I is actually Less Than Zero uh and the moment it gets greater than zero there is no point in continuing with the loop so we just simply ignore that now inside the loop we are actually going to call our two sum two function but for that we actually have couple of conditions that we are going to take care of so first condition is that if the given value of I is equal to Z or the starting position then we do it or we check that whether the two adjacent values of I and IUS one are they same or not if they are not same then only we call over two Su two function otherwise we ignore that particular inside the method we are going to call the two sum two method where we are going to pass in the value of the given input integer nums the current I position and the result uh variable and basically that's it once this for Loop ends basically by with the help of this two sum 2 method our result should have been populated so we can simply return the result now it's time to create the new two sum2 method first of all we are going to initialize two uh pointers called left and right now we are going to have our while loop that while left is less than right we are going to do some interesting things first of all we are going to have a variable called sum that is going to calculate the current total sum now we are going to check that if the given sum if that is less than zero if that is the case we will have to increase the value of the left pointer else if we are going to check that if the given sum is greater than zero if that is the case then we will have to reduce the value of our right pointer and if both are not the cases which means our current sum is exactly zero so first of all we are going to add a new entry to our result uh variable that we have created after adding the values to the result we will again have to update our left pointer until the point that whether the two adjacent values of left pointer they are same or not basically that's it this should have taken care of all the scenarios and uh this should be working now let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs decently efficiently today we are going to do container with most water lead cat problem and if you see some of the companies where I want get a job who already asked this question there are companies like Amazon Apple Google Microsoft Facebook Goldman sax bite dance Bloomberg Tik Tok Uber and Tesla so that's why I'm paying my atmost attention I hope you also enjoy the video this is a lead code medium problem and also very well like problem on lead code and like any lead code problem we are given some input and we are expected to get some results from this particular input but before we start understanding this problem uh first let's see this concept that I'm trying to explain okay so suppose we are given a container that looks like this and we are trying to see that how much water can we fill in this container well the logic is actually quite simple we can only fill water up until this point inside this given container uh anything more if we try to add water over here that water would simply spill out we won't be able to fill our water above this line so that is a given fact right that is a very simple explanation now if I ask you that how much water is present in this container so then in that case the answer is simple there can only be water up until this point nothing more than that so this case for this particular container rather than considering this container to be a container if we consider this to be a rectangle things becomes easy for us because we know that uh the surface area of rectangle is the amount of water we can store in this particular container and we know the formula to calculate the area inside any given rectangle suppose this is the height of the container and this is the width of the container if we are given these two values basically if we do H * W height crosses height multiplied by width we will get the amount of area and that would equivalent that how much water we can hold in any given container now let's try to understand another scenario suppose we are given a container that looks like this or we are given a container that looks like this in these two cases how much water can we store well the answer is again simple we can only fill water up until this point till the lower Edge on On Any Given container not more than that so now in this this case we are actually given two different heights for each sides of the given container right so suppose this side is H1 and this side is H2 and same goes over here this one is H1 and this one is H2 if that is the case if we try to calculate the area in this case the area equation for the water is going to change why because we are not going to use H1 over here because this is the higher side we are actually going to use H2 which is the Lower Side so in this case uh the area is going to be H2 * width for this particular container but for this particular container the equation is actually going to be H1 * width because this H1 is actually smaller in this case so these are the two concepts that you will have to understand and now let's go back to the problem okay so now in the problem we are actually given an array called Heights of length n and now if we try to plot this array of height in on a graph we can consider that based on the x-axis we can actually create a container and then we need to find that what is the container we can create that contains the most amount of water and then we need to return the amount of water that the maximum container can store now I know that the wording may sound confusing so it would be better by understanding with this example suppose we are given an array Heights like this so if we try to plot this array Heights on a graph we can actually get a graph that looks like this now in this graph you can see that there is a difference between lines and based on the these line differences we can actually create some sort of containers between any two vertices uh and the amount of water we can fill depending will depend on the lower side of the height rather than higher side of the height so in this case we can actually create a container that looks like this so if we try to consider this index number one and index number four uh the container we can create is going to look like this where this is the amount of water we can fill nothing more than that now remember as mentioned earlier that for every single time if we want to calculate that what is the amount of water we can find we need to calculate the area of the presumed rectangle and for that we need the height which we already have based on these values which we can derive from the array and we need the value of the width so width we can achieve by calculating the difference between any two places uh on the xaxis and uh these values we can determine depending on the index values of the given input array so it makes our lives easier uh so in this case if we try to see that some of the containers that we can make we can make a container that looks like this amongst these two values and then we can calculate its water so I'm just showing you for an example so in this case the minimum height is actually five so height is going to be five and the width in this case is actually going to be 2 so 5 * 2 we can see that okay there is 10 units of water we can put in this container if this was to be the be the container the thing is we are trying to find the maximum uh maximum water we can make amongst any given container so in this case the answer is actually going to be this container uh where the current height is s among 7 and 8 so we are going to choose 7 as the height okay so H is equal to 7 so okay uh it's going to be 7 times the distance so distance in this case Okay this value is 2 and this value is 9 so distance is also 7 so in this case 49 is the maximum unit of water we can contain and that is going to be stored between this container uh and basically I hope that this makes understanding this problem easier and after understanding the problem now let's focus on different solutions that we can achieve the first approach we have is a Brute Force approach and suppose this is the input we are given if we try to plot it on a graph we can actually create a graph that looks like this now the idea is we are actually going to check every single container that we can possibly make and depending on that we will try to see that what is the what container contains the most amount of water so basically we are going to have a two variable first variable is called area to contain to calculate the water at any given container and second is going to be the max variable that is going to be update its value whenever we find a better area or maximum water we can contain right so first we will start with this first index and we will try to see that okay what is the container we can make with between the index one and two we can make a container that looks like this what is the container we can make between 1 and three we can make a container that looks like this uh and say so on and so forth we will keep on repeating our uh graph after being done with this value number one we will ignore that and we will start focusing from value number two so from value number two we can make container that looks like this and then again a container that looks like this and blah blah so on and so forth and eventually we would find an answer in this case between this uh value number two and 7 indexes that if we make this container that is going to hold maximum amount of water and in this case the answer is going to be okay so for this area height is going to be four because that is the smaller among these two and the width is actually going to be 5 because 2 - 7 is 5 so maximum area is going to be 20 and 20 is the answer we are going to return so this solution would work as expected but if we see the issue with this solution the issue is actually time complexity why time complexity because for every single value we are comparing it with all the other values to see what is the container we can create and we are not doing things efficiently so basically the time complexity in this case is bigger of n Square which is very bad and we will have to do something better so let's see that what is the better approach we can get so for the optimal solution we are actually going to use two pointers to our advantage and we will try to see that what is the optimal container we can make so we are going to have a pointer left located at the first position and we are going to have a pointer right located at the last position the idea is both pointers are going to come towards each other until they meet or cross each other now every every single position we will try to see that depending on the values of left and right what is the container we can make uh and then we will try to calculate its area and after calculating the area we are going to compare the heights between left and right and whichever has greater height uh we are going to keep that height and then we are going to update the remaining counter so left counter counter will go on the right side or right right counter will come on the left side uh so let's see the solution in action and it will make more sense so basically uh initially first if we see currently the height at left is three and height at right is two okay so if we want to calculate the area we are going to calculate the smaller amount okay so currently the smaller height is actually two and if we see the width width in this case is going to be seven okay so current area we are able to calculate is 14 uh we are also going to have a variable called Max area so currently the max area we have been able to find is 14 okay so far so good now we will try to compare the heights between left and right okay so currently left height is actually greater so it is in our interest to move right counter one step to the left rather than moving the left counter okay so in this case right counter is going to come at come over here now again we are going to repeat the same process so now currently the height at right counter is six and left counter is three okay so now if we we will have to calculate the area again so we are going to choose the smaller value amongst the height So currently this is going to be three as the smaller height and width is going to be six okay so currently the area we can get is 18 18 is greater than 14 so we are going to update the maximum area maximum water we can contain to 18 uh now we are going to compare the height between left and right now in this case the height at right is actually greater than left so we are going to update our left pointer to go one step to the right uh now this left pointer is located over here currently the height is two again we are going to calculate the area so this height is actually going to become two and the width is actually going to become five so 2 * 5 is actually 10 uh so because 10 is less than 18 we are not going to update the maximum value we have been able to find again we are going to calculate the heights between left and right so again right height is greater so we will update the left pointer to go on one step on the right side uh now currently the height over here is seven and uh currently the other height is six so we are going to choose the smaller height so the height we are going to choose is going to be six uh six times the width is going to decrease okay so currently the width value we have is going to be okay this is uh okay this is left pointer so 3 - 1 4 okay so 6 * 4 and so this area becomes 24 24 is actually greater than 18 so because 24 is actually greater than 18 we are going to update the maximum area we are been able to calculate okay so this is 24 now again we are going to compare the heights between the left pointer and right pointer So currently right pointer is actually less so now we will have to update the uh value of the right pointer So currently this becomes our right pointer now this value is three this value of left pointer is 7even so again the height is actually going to be three and the width is going to be three as well so this is going to be 3 * 3 so this is nine we we don't need to update the max value again if we compare the heights the right is actually smaller so again we will update the value of the right counter so now this time the right counter is reaching at this value number one so if we calculate the this container this container the uh area is actually going to be 2 so uh 2 * 1 so 2 * 1 is only 2 so we don't need to do anything again we will update the right counter so currently the value of rout right counter is four and the left counter is 7even okay so we are going to have a container that looks like this so 4 * 7 uh sorry uh 4 * 1 is going to be 4 as well uh so then we in this case we don't need to update the max value and if we try to update the left or right variable again that they would cross each other so because they would cross each other now we can end up get out of our Loop so whatever the maximum result we have found so far that is going to be the solution we need to return so in this case the answer is actually going to be 24 as that this is the maximum units of water we can contain between uh basically this container this water container and uh that is the answer we need to return uh if you see the beautiful thing about this solution uh this whole solution gets completed in a single iteration uh between these two pointers and if we see time complexity in this case the time complexity is actually going to be big of n Only which is is much better Improvement compared to our Brute Force approach which had the time complexity of big off n Square which was really bad so we can avoid that if you see space complexity the space complexity is also really good because apart from using couple of pointers we are not using any additional space so space complexity is actually constant space which is wonderful and uh this is a very good approach and a very good way to learn two pointer problem and uh I hope you understood it now let's move on to the coding first of all we are going to initialize couple of variables so first variable is going to be Max and that is that we are going to initialize it to zero uh then we are going to initialize two pointers left and right and left is going to have the value of zero and right is going to have the value of whatever the length of Height's array is we run our while loop that while left is less than right now first of all we will have to calculate the width so width is going to be right minus left so now we have the width and we already have the height from this Heights array we will calculate the area so this uh equation should give us the area we are selecting the Lesser height amongst right height and left height and uh now we will see that whether we need to update the max value as well and now we will have to update our left or right pointer so we will check that okay if the current height of left is that is less than or equal to the right height we will update the left counter if that is not the case we will update the right pointer to go one step on the left side and uh in the end we can can simply return the max variable that we have calculated and that should be it let's try to run this code okay seems like our solution is working as expected and our solution runs pretty efficiently compared to a lot of other Solutions and I would be posting this in the comments so you can check it out from there thank you hello friends we are still not employed by Fang company so let's not startop lead coding till we get there we are going to do trapping rainwater problem today and uh if you want to see that what are the list of companies that have asked this question that comes later in the video so you can directly check it from there uh let's understand the problem statement we are given an array of array called n where all the integers are non- negative and any single integer represents actually the height at that particular position inside the array we are given that the width at any two positions is actually one so we can consider that and we need to see that how much water can we trap when it rains we know that it's going to rain a decent amount so we can we all the cells that could trap water would trap water and our aim is to see that what is the maximum unit of water we are going to store so let's try to understand this with an example uh over here we are given an elevation graph and all of those values are represented as uh bars inside the given graph and we notice that because there are some height differences uh due to the height difference there exist an empty space inside this given input and because that empty space exist uh rain water can actually fall in and be stored on those particular positions so if we see over here like this first position is actually zero but and suppose the rain falls can any water be stored over here well it cannot be stored because in order for water to be stored we need a vessel like this or like this or something like this where at least water can be stored like over here if you see water can be stored for all of these positions because all these three edges were covered with some sort of solid material same goes over here like over here we can only fill water up until this point because on the left side The Edge is only up until this point uh not more than that like though on the right side The Edge is actually higher but if we try to fill in more water or if rain falls and more water falls on top of it all the water is going to spill out and no what no amount of water is going to be stored so that is one key important part is to understand that how water is stored and second is that we need to iterate over this given input height and uh at every single position we are going to basically calculate that how much water can be stored due to this height difference so if we see in this example at this first position no water can be stored so like there is there is no water pointed uh with over here like this is a bar by itself and in this particular bar um this is the boundary that is a solid surface that cannot store any water and we cannot store any water on top of this one because all the water that gets stored on top of this one will also spill out because on the left side the boundary is actually non-existent now if we look at this third position over here actually because of there exist a height difference between these two positions we have a scenario something that looks like this where water when the rain falls on the left side we have a height of we have a bar of height one which is represented over here and on the right side we have a bar of height two which means that we are creating some sort of value over here where on the left at this particular position on the left side the bar is actually of one size so this is of one size and this is bar of two size so this is actually two size which means that there is exist an empty vacuum where water can fall in and water can be stored so this becomes our point and we can check that over here we can store one unit of water now the question comes that why can we only store one unit of water why can it we store more than one unit of water the formula is actually quite simple like at this particular position we see that on the left side there exist some height on the right side there exists some height so suppose this one is left height this one is right height there are two heights that exist at any moment and this by itself can have some height uh as mentioned in this input that there can be some height that can be located this position and suppose this position is actually the height we are currently at so we just name it as height okay now how can we determine that in this scenario in this scenario if we see those all these values so left height is actually one okay right height is actually uh two and the height we are currently at which is this position is actually zero and over here we were able to store only one unit of water so why we were only able to store one unit of water basically we were following this condition that first of all we need to check that what are the bar height difference between on the at any given position on the left hand side and and the at the right hand side and we need to take the minimum out of both of them because over here though on this right hand side the bar is actually of height 2 units because on the left hand side the bar is only of a a height one unit we cannot store water more than this height because the water is going to spill out now that is one condition now second condition is in this case we got lucky that over here there is no height at all so that's why we were able to store one unit of water over here so basically we can we can say that at any given moment the amount of water we can store in one unit is actually following this formula that the minimum of whatever the right height is whatever the left height is so whatever the lower value of both of these minus the height we are currently at and if this is greater than zero then only we can say that we can store some water at any given position like let's let's say for an example that why at this first position we cannot we are not able to fill out any water and if we see both if we see the if we see both the values so on the left at this particular position I'm re referring that on the left side the height left height we had was actually zero the height at current position was also zero and the right height was actually one so if we apply this formula we can clearly see that on the the amount of water we can fill we can or we can try to fill in this space is actually going to be minimum of these two so minimum of left height and right height is actually zero minus the height we are currently at so current height is also Z which means that we cannot store any water or we can store zero units of water at this particular position or at this F this first position because there exist height difference and same formula can be applied for all these places to calculate that what is the amount of water we can store like if we see over here the bar height is actually two now for this particular position if we want to check that what is the amount of water can be stored we know that over here we can store one unit of water and why we are storing one unit of water is because if we see the left height over here that is two now on the right side the right height there is no right height over here there is no right height over here which is greater than this one like this there is some right height over here but that is less than this height so there is no point in us to treat it as Valley up until this point but over here we know that the height is actually greater than whatever height we currently had over here so this right height is actually three so we are going to check so we are going to apply the same formula so we are going to check the minimum out of 1 and three uh sorry one minimum out of uh 2 and 3 so this is left height this is right height and we are going to minus whatever the height we are currently at so current height is actually 1 and if we apply this formula we get 2 - 1 so we get one which means that over here we can store one unit of water now let's try to understand this with another example and I'm spending a lot of time in this one because this is the actual Crux of uh the entire example so over here if we want to calculate that how much amount of water we can store we are again going to repeat the same process so what is the left maximum height we can find for this particular uh unit like the left maximum height we can find is two units uh so we can say the left height is two the right height is this one so right height is three and minus whatever the height currently we have at this position so this position we don't have any height so which is zero so if we apply the same formula we can get 2 - 0 so we can see that over here we can actually store two units of water and which is what is presented over here like that's how we can store one unit of water over here and that's how we can store one unit of water over here so at any given position for any particular element we are only going to need two things because height we are already given so we remember that in this equation we are actually comparing three items the right maximum height left maximum height and height we are currently at so height we we already know and our aim is to find that how can we find this right height Max right maximum height at any given element left maximum height at any given any given element and uh then it would be piece of cake to for us to identify that how much water can be stored at any particular position so we can have a Brute Force approach where at every single position we iterate over the entire left array and entire right array and we find that what is the maximum left height we can find at any given position we can also find what is the maximum right height we can find at any given position and we already know that what is the the height we are currently at and once we have both of this information we would calculate our result and uh we would try to calculate our output the thing is if this scenario is pretty Dar bad like at any single position so even over here we will have to iterate over the entire left uh array and entire right array in order for us to calculate these two values and yeah this is Brute Force so brute force is tend to be dumb like we are not doing anything clever over here so that's why we would end up with the time complexity of big go of n Square because at any single position we are going to iterate over the entire array to find these two values left height and right height now can we do something better over here and uh how can we find a better approach like so so for the given input example we can actually do something clever what we can do is uh whatever the input we are given we can actually iterate over it from the left side and at every single position we can see that for any any single element what is the left M leftmost value or left Max value we can store again we are going to iterate over the given input example on the reverse order and then we can find that at any single position what is the right ma max value we can find and then it becomes pretty simple for us we can just simply apply this formula on the entire uh input uh that were at any single position so at any single position we only need to find the minimum value of right Max and left Max minus whatever the height we are currently at and if this becomes greater than zero then we will add it to our whatever the output we have and this would be our answer so uh let's iterate over first uh on the left M side on this given input so on the first element the maximum left height can be zero over here it can be one again over here it can be one uh now over here this value is two so left Max Val left Max height at this position would actually be two uh this would actually be one but thing is we we already find a greater value so again we are going to keep it as two again we are over here this one is zero so again we the left Max height we can find is two over here this one is one so again this would be two now this is three which means that LE left Max height we can find is actually three uh this is two so left Max height we can find is actually three uh again three again three and again three so this this is how we can fill out this left Max uh table same way we are going to fill out the right Max table but we are going to do it in the reverse order so over here the right Max Edge is actually one and we are going to repeat the same process now we have both of these tables filled out it becomes pretty easy for us to find the solution and we can actually do it everything now this approach would work perfectly fine the thing is what is the issue with this approach like uh if we calculate the time and space complexity the time complexity for this one is actually bigo of uh n because we are every we are doing everything in just a single Loop and we are running this loop three times like first we are running this Loop so we are doing n work again we are running this Loop so we are doing n work again and then we are running the N work to find the output but thing is uh still time complexity is going to be big of N and the space complexity for this one is actually going to be big go of n as well because we are storing these two additional data structures so this is much better Improvement than our Brute Force approach where in the Brute Force we are doing everything in big go of n Square time uh so we are gaining significant improvements over here now this question has been really popular with a lot of different companies and if we just look at the number of companies that have asked this question and if we just see the amount of frequency that they have been asking this question I wouldn't be daring to skip this problem like even if you see up until 2 years almost all the the companies that are like one of the biggest companies in the world they are continuously asking this problem uh just look at the numbers like Amazon Facebook Goldman Sach Bloomberg Microsoft Google adob Uber Apple Tesla Lyft xedia Morgan Stanley swigy uh bite dance data breaks Walmart flip cart service now go these are the companies that pay you in gold bricks and getting job or getting employed at any of these companies at least for 2 3 4 is going to change your financial situation drastically like it's going to be 180° turn and you only need to clear the technical interviews just once like after that you are sitting on top of gold so if you are also dreaming to changing your life completely like make sure to focus your utmost attention to this problem and try to solve it as many times as possible because it has been asked in so many companies so that tells you something okay now for the optimal solution we can actually observe something pretty interesting in this uh given left Max and right Max that we have calculated the no if we notice in the given input this is the biggest bar of height that is possible and we know that at any moment at any location if you want to find the height the equation is this one that the minimum of whatever the left Max and right Max we have minus whatever the height at current position we have this is the equation to find the that how much amount of water we can trap at any given unit or any given uh elevation now the thing is if we notice in these two values left Max and right Max we are actually finding something pretty interesting and the interesting thing we are finding is that the tallest part that we have it actually divides the given input in two parts and it divides how that if we observe the left most left Max portion the left Max portion is all always less than whatever the right Max portion is up until this point up until this point number seven uh because notice all of these values in all of these values the value of left Max is actually less than whatever the value of right Max is and over here it's equal to right Max because of this particular uh tallest bar that divides two arrays and all on on the right side actually the r Max is less than uh left Max and we can see those things over here that over here these are all the values that are smaller than whatever the left Max there is because for these four values actually this particular the tallest bar actually becomes the left ma left Max element and using this we can actually use it to our advantage because remember at any moment if we want to find that what is the amount of rain water we can found we only need to find the minimum value of amongst this left Max and right Max which means that this tallest bar can actually be used in our help and we don't even need to calculate the this whole left Max and right Max array by itself we can actually use a very beautiful concept that is present inside the given uh array traversal problems and that is two pointer solution over here in the now in the two pointer function we are going to have two two variables left and right initially located at first and last position and at every single time we are going to check that whatever current element we have so whatever height at element left or pointer uh left and whatever the height at pointer R we are going to compare these two so suppose uh the height at left pointer is actually less than right pointer what we are going to do is first we'll check that whether the current left pointer we are at does it contains the left Max height and we are going to initialize the left Max variable to zero at the beginning and at any point we are going to check that whether we need to update the value of Le left Max so at for left Max we are going to check two things uh we are going to we are only going to check one thing we are going to check that whether the left Max should be the maximum value out of whatever the left Max we have stored and whatever the height of left we are at uh so this will always make sure that we have the most updated left Max value once that is done we only need to use one equation in this scenario and that equation is left Max minus whatever the height we are currently at uh of pointer L if this is greater than zero we can actually add it to our total so we can just say that total is whatever value we already had for total plus we can add this whole fun function to it and uh once that is done we will need to update our left pointer so on the left side we will move towards the right pointer and we will do left Plus+ and again suppose at any point we find out a scenario where the height at right is actually so height at right is actually less than height at left if that is the case we are going to repeat the same process uh let me use a different color but this time we rather than doing it for left Max we are actually going to do for the right Max so again we are going to check for right Max that what is the maximum amount we can find so we are going to take maximum of whatever the right Max we already have and whatever the current right height we are at uh and once that is done again we are going to use the same equation but rather than using left Max we are going to use right Max minus whatever the height we are currently at uh for this R pointer and uh if this is greater than zero we are simply going to add that value to our total variable whatever we calculate for this one and uh once that is done our to our right variable is actually going to move towards left side and we are able to achieve this because there exists some bar that actually divides the array in two portion because over here up until this bar always left Max is going to be minimum value and over here always right Max X is going to be minimum value and at any single position whenever we are at at any left and right we always check their heights which means that suppose uh we reach this right uh before still in the left side we will have to calculate all of these values before we get here and once we get to a point where left is actually greater than or equal to right then we can simply break out of the loop and whatever value we have stored in the total we can simply return that this this is a very beautiful approach and notice that we don't even have to use the full equation over here we are only comparing any one variable at any point in time left Max and right Max and uh every single time we are keeping track of whatever the left maximum or right maximum value that we have we have been able to find so if we if we use this approach if we use two pointer approach and if we calculate the time and space complexity basically the time complexity for this one is actually going to be big of n so that is same as it is because uh in any case we are going to Traverse over the entire input array uh but thing is we are only doing it once we are not doing it more than that and if we see the space complexity actually we are only storing couple of additional parameters uh like right Max left Max and we are storing two pointers left pointer and right pointer so we are not doing any additional data structure or we are not storing anything else which means that our uh space complexity is actually going to be big go of one constant time so this is really amazing solution uh compared to all the other approaches this is the most optimal approach so first of all we are going to initialize our two variable left and right the left is going to be zero uh right is going to be height length minus one we are also going to initialize a variable total that is going to be total amount of water that can be stored and we are going to initialize it to zero we are also going to have two variables left Max and right Max and left Max would be the first element in whatever the height we are given so height of zero and uh right Max is going to be the height of last element so we can say height of right pointer and now we are going to run our Loop so while left is less than right first we are going to check for the height difference and whichever side has the lower height we are going to work on that side if left pointer has lesser height we are going to work on the left side so we are first of all going to see that do we need to update the left Max we are going to check that whether we are at any Valley where we can store some value so we are going to check that if uh left Max minus what whatever the height we are currently at on the left pointer if that is greater than zero then we know that we are at a value and we can store some water over here uh so we will update the total amount of rain water that can be harvested to Total plus whatever the height difference we have found over here which means that left Max minus whatever the height we have found over here and uh once that is done we need to update our left pointer to move towards the right side and if that is not the case which means that we need to repeat the same process but now on the right side so first we'll try to see if we need to update the value of right max if we don't need and now again we are going to check that are we at the valley on the right side where we can store some rain water if this is greater than zero then we can update the total rain water and once that is done we will need to update the right pointer to move towards left Direction okay I think that is it once this while loop ends um our to the total variable should have all the uh entire result and we can simply return that and this should give the total amount of rain water we can Harvest let's try to run this code okay seems we made some small mistakes seems like our solution is working let's try to submit the code and you can see that our solution works pretty fast compared to a lot of other solutions that is because we are using the most optimal approach uh I'm also going to post this solution in the comments also I have created the solution where we need to use two separate arrays to store the left Mo left Max variable and right Max variable at every single any single position and uh Hello friends we are still not uplo by Fang company so let's not stop lead coding till we get there today we are going to do best time to buy and sell stocks lead code problem this question has a very real life practical application that is why it is very famous amongst it companies as an interview question uh if we see some of the companies where I want to work at who have already asked this question there are companies like Amazon Microsoft Facebook Bloomberg Google Goldman sax Apple Uber Snapchat Yahoo by dance do Dash eBay Netflix and Reddit so that's why I'm paying my atmost attention I hope you also enjoy the video this is the lead code easy problem and you can see that it has been one of the most like problems on lead code if we try to understand the problem statement B basically we are given an array called price where any single uh value inside this given array indicates the price of that particular stock and that on that particular day now we want to maximize our profit by choosing a single day to buy the stock and choosing a different day to sell the stock sometime in the future and our aim is to maximize our profit so if we try to see it with an example suppose this is the example that we are given where we are given six different prices for a stock and we are told that we need to maximize The Profit so I have drawn it on a graph over here so it makes things more uh easy to understand and we know that at any given position it shows that what is the price of that particular stock so initially the stock price on first day was price 7 now on the second day the price fell down to price one so we are not making any profit we are actually going down and we are losing the money but if we see over here so this day it's one and this day the price is five so if we see over here between these two days we actually made a profit of $4 again price price fell next day to $3 and then again price rise to $6 so over here we lost $2 over here we again made some gain of $3 and at the end the price was four over here again we lost $2 so the thing is if we just do it like this uh we don't get the maximized profits why because we are only seeing that what is the difference between every single day but if we see that if we do something if we buy the stock on this particular day which means that we are buying the stock when the stock price is at at one and if we sell the price when the stock price at six so which means if we sell when the stock price is at six we can actually make a profit of $5 this is the answer we need to return that this is the maximum profit we can make uh based on these stock prices let me show you that what would be the Brute Force approach and then I will show you that what would be the optimal approach so for the Brute Force approach one thing we can do is that we take every single position of buy and sell price price for these given stocks which means that we make every single pair so first of all we see that if we buy the stock at price 7even and we sell at Price one again we sell at Price five again we sell at Price three and so on and so forth what is the maximum profit we are getting and we will create a variable called profit and we will keep track that what is the maximum number we have find found so far once we are done with this value number seven we would ignore this case and then again we will repeat the same thing with value number five so we start buying uh so we start that our Buy price is at Value number one and again we start checking all of the comparisons that what would be the profit and eventually we would find a pair where buy value is one and sell value is actually six which means that we would gain profit of $5 and then we will return this as our answer like this solution would work as expected we will get the desired result but the thing is this is not the most optim optimal approach why this is not the most optimal approach because if we see uh the time complexity the time complexity in this case is actually going to be big go of n Square why n Square because for any single entry we will have to take a look at every single entry in the remaining array and we will iterate this process so that is why it is a very time consuming process and we need to find a way to do something better and uh let me quickly show you that what would be the optimal solution in this case so for the optimal approach what we are going to do is we are actually going to see that uh when do we get the maximized profit we only get the maximized profit when we buy at the lowest value and we sell at the highest value so this is the logic we are going to apply over here that uh we are going to buy the stock at the lowest value and we are going to sell the stock at the highest value but thing is it is not e as easy as finding like the maximum value and the minimum value because in this case maximum value is actually seven and minimum value is actually one we don't need to get the difference of these two value because if we do that we will get an answer of six but the thing is uh we are actually dealing with stocks so we can only buy stocks uh in the past which means that if we decide to buy a stock over here we can only sell it afterwards we can't sell it uh to some value in the before so that's why that is one thing we need to keep track of that we have to make sure that this linear property of buying and selling is maintained in this case so what we are going to do is we are going to have a variable called buy and that is going to keep track of what is the minimum uh value we have stored so far and we are going to see that at any given moment whatever the minimum buy value is if on that particular day we try to sell a stock what is the profit we are getting so let me quickly draw three variables over here so we are going to have three variables called buy sell and profit now first of all we are at this position number seven which means that we are buying the stock at seven and we can't do anything about it because we don't have any way to sell it uh so we will start with the second position so now on the second day the stock price fell down to one which means that if we can we have already bought this stock at Value number seven if we try to sell it at Value number one it really doesn't not give much progress but one thing we can do over here is that because today the stock price is actually low we can reduce that whatever the buying price is from 7 to 1 so we will do that so now the Buy price is actually 1 and uh we are not selling anything or we are not doing anything again now the next day the uh price is price of the stock is five so we'll try to do that okay what is the 5 minus one which is the minimum price we have bought stock so far and 5 - 1 is actually Four which is the maximum profit we have made so far and we don't need to update this buy value because we have already bought it at a lower price than whatever the current price of the stock is now we will move on to the next value so next value the stock price is actually three which means three is still greater than value number one which means we don't need to update this value number three but we will have to check that whether we are making any greater profit or not so again we will do three minus whatever this buy value is the buy value is 1 so 3 - 1 so the pro current profit we make is actually two but the thing is 2 is actually less than four which means we can we don't need to update the profit we have made so far now again we will ignore this case we will move on to the next value so the next value the stock price is actually at six so stock price is now at six and now again we will do 6 - 1 so 6 - 1 uh selling price would be actually five and because this is five and this profit is actually greater than whatever profit we have achieved so far so the current maximum profit we have made so far is five now again the stock price is at four so again the selling price on this day would be four and we don't need to update the buying price because the buying price is already at 1 which is lower than four and now we will do 4 Min - 1 so 4 - 1 if we do we still make profit but this profit is only $3 and $3 is actually less than whatever the maximum profit we have made so far now we are at the end of our Loop and now we don't have any more values to iterate over inside the given array which means whatever the result we have start stored inside the maximum profit variable we will just return that and in this case we will return answer as five and this answer would work perfectly fine this is like the most desired answer we need if we see the time and space complexity in this case the time complexity is actually biger of n why biger of n because notice that we are own completing everything in a single iteration uh in terms of space complexity uh for the space complexity we are not actually using any additional space apart from storing couple of variables so that's why space is also constant so that's why this is a very good approach we are solving this in big of N and B big of n time and big of one space complexity so first of all we are going to initialize a variable called Min and we are going to give it the first value of the given prices uh we are going to create a variable called profit to note down the maximum profit we can achieve and initially we are going to mark it as zero and then we will update the value inside our Loop so now we are going to run a for Loop across the given array now inside the given Loop first of all we will check that whether we need to update the value of Min or not so we will check that if the current Min value is less than whatever the value of I is then we will update the value of Min and also we will check that whether the current profit we can make by selling the stock on that particular day comparing with the Min value uh we will choose the maximum profit we can and once this Loop ends we simply need to return the whatever value we have stored in the profit variable let's try to run this code okay seems like our code is working as expected let's submit it and our code is actually pretty efficient it runs faster than lot of other Solutions and I will be posting this code in the comments so you can check it out from there thank you hello friends we employed by Fang companies of lead coding till we get there today we are going to do longest substring without a repeating character lead code problem and this is actually number three problem in the lead code and also very popular problem as you can see the number of companies that have already asked this problem so if I just check the companies where I want to get a job and I have already asked this question there are companies like Amazon Microsoft Facebook Bloomberg Apple Google Spotify Uber Goldman sax Yahoo Walmart eBay lift I dance Morgan Stanley and PTM so that's why I paying my atmost attention to solve this problem I hope you also enjoy the video so this is a lead code medium problem and also one of the most like problems on lead code basically we are given a string string s and we need to find the length of the longest substring without a repeating character inside this given string so suppose in this example we are given a string like this and in this case if we check that what is the longest substring without a repeating character that is this one a b c and the length of this is three we can also conclude this one as well this has also length of three and uh we can return either of them but the answer in this case we are going to return is actually three let's see that what would be the different approaches to solve this problem so suppose this is the input that we are given and let's see that how can we solve this in a Brute Force manner well the B most basic idea is that we can take this input and take every single substring that is possible and then check on all of those substrings that whether there are any repeating characters or not and whichever the substring with the longest length we found without any repeating characters we will just present it as an answer so if I just show you by an example in this case the number of substrings we can make is okay let's start from this a so from this a we can make a substring of a we can make a substring a we can make a substring a b a we can make a substring a b a t dot dot dot and so on and so forth we can make all of these substring next substring we will make starting from this value number B so from B we can make b b a b a t b a t m and so on and so forth so in this case the longest substring we would be be able to make is actually this uh one b a TM that is of length four and this is the answer in our case so even if we use the Brute Force approach eventually we would have found this substring by comparing all of the bunch of different substrings that we will we would have created and then we can we would have return four in this case but what is the issue with this approach well the issue is actually quite trivial that we are actually doing lot of unnecessary work and we are trying to find lot of different substrings even if if we just see the time and space complexity in this CL the time complexity is actually going to be big of n Cube why n Cub because we are going to do n Square work uh to find all the substrings and then we will have to do n work for every single one of them to find that whether they're exis a repeating character or not so this is a really bad approach let's see that what is the Improvement we can make to optimally solve this problem we are going to use very important concept called sliding window and in addition with two-p pointer what we are going to is we are going to have two pointers called left and right and these left and right pointers we are going to have them to follow a very important property and that property is that between these values of left and right all the elements has to be unique if at any moment we encounter that there is a duplicate entry which means that we will update the value of L to the point where the duplicate entry is mitigated or it's eliminated and then we will again keep on progressing with this right pointer let me quickly show you how we are going to do do that so first of all left and right both are going to start at the same position now we are going to make our right pointer move to the next element until the point where we find a place that is actually repeating so we are now our right pointer is at this position our left pointer is at this position so so far we have two elements in our substring and both are unique so because both are unique we are good go good up until to this point also at the same time we are going to have an answer variable where we are going to store the length of the maximum uh substring we were able to find with all the unique characters so so far initially this value was one but now we have found that there are actually two elements for this substring that has all the unique elements so far now we now we are going to update the value of our right pointer again so right pointer will come over here now again right pointer is here but at this point okay we need to check that okay among this A and B does a exist somewhere and we know that a exist over here now you will quickly ask me that okay in this case since we only had two elements and we were comparing this a it was really easy for us to identify what if we had like 10 elements like this and then we are comparing this a and we need to check that whether at all these 10 positions does this a exist or not and that would make things really inefficient and that would be big of n Square time complexity so what we are going to do is we are going to have a visited hash set and inside this visited hash set we are going to store all the characters we have found so far between lnr and and we are going to keep on adding until the point we find a repeating character so initially this only had the value a when we are at this point then we added a b so so far inside our hash Set uh we actually have a and b and now when this R pointer comes at this position a first of all we'll check that whether a exist or not and we realize that okay a exists inside this hash set which means that among this substring we cannot add this value a because a exist over here so now what we are going to do is we are going to remove a from this our set and we are also going to update our left pointer to remove this value a so okay we ignore this a and now our left pointer is at this position our right pointer is at this position so so far the values are b and a and now we are again going to add this value number a over here because this right pointer is here okay uh what is the length so far so the length is still two so because length is two we are not going to update in our answer because in our answer the length is also two now we are going to update our right pointer to come to the next element and when we update the right pointer it comes over here so this t t does not exist inside our hash set so we will add entry T over here and our we will update our answer as well so now the our answer becomes three now again we will uh update our right pointer to come to come over here so when the right pointer comes over here we will have an entry M so again we will add the value M over here inside our hash set because it does not exist before and we will also update our answer to be of length four so far now again we will add a Val right value over here so when we add the right pointer over here and at this moment this is a so we try to check that whether a exists in our headset or not and we can realize that okay a exist already so immediately because a exists now we will have to move this left pointer up until the point where we encounter this a so okay this B we can ignore this and we'll jump our left pointer okay left pointer comes over here and again this is a so again we will ignore this and then we will come for the left pointer to be over here which means that left pointer is going to be here and right pointer is going to be here and also at the same time we will have to remove the this b and a from our hash set that we were currently visiting So currently the entries we have is T and M only and then because this right is at this position number a so we are going to add an entry for a now we are going to uh update the and so far the length of this one is actually three so we don't need to update in our answer and then again we are going to update the right pointer so right pointer comes over here this is n and does not exist inside the hash uh hash set so we will add an entry called n over here and then this length is actually Four so answer is four so we don't need to update so far and then if we do try to do next to uh this right pointer we come to the end of the list and uh the string is empty now so because we are done iterating over the entire string now all we need to do is return whatever the answer we found in this case and the answer we found in this case is four and that would be our final solution so if we see the time and space complexity in this one it's actually really efficient so in terms of time complexity we are actually completing all of these things in a single iteration so it's actually bigo of N and in terms of space complexity uh we are using this additional hash set to store the value and uh the space complexity at any given moment is actually going to be big go of whatever the answer answer we have or whatever the longest increasing subsequence we have because remember at any moment we are only having that whatever the maximum number of uh unique characters in The substring we have uh the moment we increase the the moment we encounter repeating character we are actually getting rid of all of them so that's why the space complexity is going to be bigo of uh whatever the longest repeating character we have we have found so far first of all we are going to check couple of edge cases that if the given string is empty or if it only has one character then we will return so now we are going to initialize couple of variables called left and right and we are going to initialize its value to zero we also going to initialize a variable called answer and by default we are going to have the value as zero and we are going to initialize a hash set of characters so first of all we are going to run a while loop uh till the point where right reaches to the end of the string first of all we are going to initialize a character variable and to find the value of that particular index and then we will check that whether this value exist inside our hash set or not so if the value exists inside our hash set we are going to remove it from our hash set and we are also going to update the value of our left pointer and if the value does not exist we are going to add it to our hash set and then we are going to calculate that whether the current answer we have is actually greater than whatever the answer we had before and we are going to do right minus left + one and uh at the end we are going to update the right pointer as well and that should be it so when this both of these Loop runs and after it ends we should have our answer inside the answer variable so we can simply return that now let's try to run this code okay seems like our solution is working as expected let's try to submit it and our code runs as expected I will be posting this solution inside the comments Hello friends we not employed by Fang company so let's not stop lead coding till we get there today we are going to do longest repeating character replacement lead code problem that contains very important properties related to string based problems if we see the companies where I want to get a job and that have already asked this question there are companies like Google Amazon Uber adob Facebook Apple Bloomberg and Microsoft so some of the top tier it companies so that's why I am paying my atmost attention I hope you also enjoy the video so this is the lead code medium problem and basically we are given a string s and we are given an integer K now we are told that inside this given string s we can replace any character with any other character uh in the English language and we can repeat this operation K times now after repeating this operation what is the main purpose of this question is that we need to return the length of the longest substring that contains the same letter by doing this replace activity and we need to return that length Okay so now we'll try to understand this problem with this example so suppose we are given our s is equal to a b a b and we are told that K is equal to 2 which means we can replace any two character with whatever two characters we want so in this case we have two options either we replace these two B's with value number a then we will get a string that looks like a a a a or we can replace these two A's with the letter b and then we will get a string Our concern is we don't care what is the value of the string our aim is to find the longest uh substring that contains all the repeated character and we need to find the length of it in both the cases the length of these two is actually Four and this would be the answer we need to return so this is what the problem is asking us to do let's take one more example to make our understanding more clear so suppose our given s is equal to HP h p h if this is the case and our given K is equal to two again in this case so now if we see the options we have we can replace like these two PS with the value H uh so that will give us a string like h h h h h and so if we see the longest subring that contains the same letter the length in this case becomes five uh second option we have is that we choose any two H value suppose these two and we replace it with value number B if we do that we will get a substring that looks like this so in this case if we see that what is the longest length of the subsequence that contains the same letter it's actually four so this is four and this is five and we need to return the longest so that's why this is the most optimal way to approach this problem in this case where we we are going to replace these two P values with the letter H and we don't do this P operation so there are few ways to solve this problem and there is also a Brute Force way to solve this problem so first I'll show you the Brute Force way and then we will see that what would be the optimized approach first of all we identify that what is the thing that we want to find we want to find a substring and then we want to replace the characters and then we want to find a substring that contains the longest length with the same characters right so first approach we can take in the brute forces that we take every single substring that is possible so even if we just see that substrings that starts at a we will get substrings like a a b a b a and a b a b something like this again if we see substring that starts with B we will get b a b a b and so on and so forth so we would end up with bunch of different substrings then we will start this replace operation on all the substrings and eventually we would find some substring that will look like this a a a a or this B BBB and in any case we would be able to return the length as four like okay this solution would work and we will get the desired result but there are lot of issues with that even if we just see that for a single character we end up with like so many substrings and we still have more substrings to go to so this is a very inefficient approach and we should avoid doing it at all cost okay before we come up with the optimal solution first of all we'll have to identify that what is our need our need in this case is that we are given this string and we are told that we can replace any two characters inside this given string with any other characters because K is equal to two now we need to find a subring where all the characters contains the same value and because they contains the same value we need to return return the length of it so first of all we will have to identify that what is the substring where we can actually create all the characters of the same length so first of all let's see that can we apply this thing on on this whole substring for this entire string of all the five characters and this given K is equal to 2 so first of all we will try to identify that what is the number of occurrences in of every single character so a occurs two times B occurs once C occurs once and D also occurs one so which means that a because a occurs most of the time our logical or rational conclusion is to create a substring where all the characters are a because in that case we will actually have one additional character if we try to create all the characters with L with value b c or D obviously we are always going to fall short by one character because the value of a actually appears twice which means these three things they have less significance compared to this a because a is the most repeating character and why I'm putting so much emphasis on most repeating character because this along with this K and the length of the string or substring defines that whether any substring we can convert it to all the repeating characters or not let me show you how suppose in this case we consider all these five characters even if we replace any two characters in this case we have three characters to replace from if we replace any two characters no matter what happens we won't be able to create a substring where all the five values are actually a a a a a why because we only have the option to replace two elements and there are three different elements that contains different values so how come how we come up with this value that there are three different elements that contains different value than a well what we did was we took the length so length in this case for this substring is five so we took the length of this substring uh minus we subtracted the most occurred character so most occurred character in this case is a so length 5 minus a 2 and this we get three so at any case this value if that is greater than or equal to this value number K which means that this particular substring we cannot do anything about it we cannot convert into a valid or legitimate substring where all the values contains the same um same character but if we just shorten our search if we try to search in this these four characters okay now what is the breakdown of the number of occurrences of every single character well a still occurs twice B occurs once C occurs once but D is not appearing so we ignore this one now in this case the length of this is equal actually Four which means that if we apply the same formula that length minus whatever the maximum occurred value so maximum occurred value is still a which means that we do 4 - 2 uh so 4 - 2 is 2 and this 2 is actually equal to whatever the value of K is because this is equal to K and uh in this case we can Define that for this particular substring we can actually convert it to all the characters being Same by using this replace function and and if we just replace this value B and C we will get actually a substring that is all the A's and this is the answer so basically this is the critical part now remember that in order to generate this what are the things we needed we actually needed that what is the current length of the subsequence that we are following or what is the length of the substring that we are doing we actually need to know that what is the maximum occurrence of any particular character in any given subsequence and we also needed that what is the value of K based on it we were able to identify that whether any subsequence can it be converted to having all the characters to have the same value or not and based on this concept so formula we can create is that uh a valid subsequence is a subsequence where the length of the subsequence minus the most occurred uh character if this if this one is actually less than or equal to whatever the value of K is if this is true then we can see that this is a valid substring and the length whatever the length of this particular substring is uh that is also the length of the substring with which contains the most repeated characters let's see it with an example okay suppose this is the example that we are given and we want to solve this one first of all we are going to see that what is the formula that we have to use well the formula we have to use is that for any subsequent to be valid what we are going to do is we are going to do length minus whatever the max occurrence in that particular subsequence and we will see that if that value if that is less than or equal to K if that is less than or equal to k whatever the length is we can treat it as our answer and whatever the maximum answer we find so far we will conclude it as our solution we already know this formula now we need to see that how can we Implement that uh basically uh we are going to use a sliding window plus two pointer solution and inside this solution what we are going to do is we are going to have two variables called left and right to be initialized at the first position uh we are going to update the right value to the next element then we will check that whether the substring is valid or not if the substring is valid we will calculate that what is the answer we will update the answer again we will move the right value and again we will move the right value again we will move the right value until the point when the substring is not valid the moment the substring is not valid we can conclude that now we need to shrink our substring so basically suppose the r is now at this position we will have to update the value of left so we will ignore this element and we will move our left value over here and then subsequently we will keep moving on and every single time we will keep track that what is the maximum answer we have found so far which is the longest repeated character sub substring uh the length of it and whenever the r reaches at the end of the list or at the end of this string we can conclude that whatever the value we have stored in the answer answer we can return it as as the answer so now because we are using this two-p pointer approach we know that uh at any given moment what are the things we need well we need couple of things uh first thing we need is we need this length so length we can identify based on the difference between this left pointer and right pointer that gives us the length of the current Subs now we need to know that what is the maximum Occurrence at any given moment of any particular element so we don't know that right so what we can do is we can actually create an array of size 26 uh so one for every single character in the English language because we know that there are only 26 characters and whenever we find any value on the right side we will add that value to our array or if we move any character on the left side we will reduce that value from our array so at any given moment we would always know that what is the maximum value we have at uh any given position and let's see by an example that how we will complete this operation so let me quickly show you an example that how we will iterate over for this given example let me clean this up a bit so initially our left value and right value are located at these two positions we are also going to have an array to store the maximum occurrence of any single element So currently I'm just showing you the elements that are coming in uh but that that is the idea that we will uh keep in mind so first of all currently the value is p so we will add p over here and we will not notice that okay the occurrence of p is one time just this is for understanding purposes when we do the code it would be slightly different and I will explain it to you when we when we would be coding uh now uh so far this list has to be valid because there is only one character right uh now we will update the value of R so this is X and X is also present one times uh now we will see so current length of uh this string so now R is located over here okay so current length is uh actually two and what is the K value K value is also two because that is is constant so that won't change and what is the maximum occurrence of any character so far so maximum occurrence is still one as we can see over here so maximum occurrence is one so if we apply this formula uh 2 - 1 so 2 - 1 is actually 1 and 1 is less than or equal to value of K so that is true so because this is true we can see that the length of at least two uh characters uh can can be part of the answer so we will mention that in the answer now again we will update the value of R so now R comes over here because R comes over here we will update the value of Q over here and we know that it occurs one time uh again so the length so the current length is actually three and uh the maximum character is still 1 so we will do 3 - 1 so 3 - 1 is again 2 2 is still less than or equal to value of K so this is also true because this is true the current length can be part of the answer so we'll update our answer to have the value three now we will again update the value of our R so now R will go over here and this is X so for x x value we already have one uh as its occurrence now X has the occurrence two times so we will update the occurrence of maximum number over here called two times uh the length also increases so length will become four now again we will try to see that what happens with our equation so we will do 4 - 2 so 4 - 2 this is 2 2 is still less than or equal to K which is 2 which means that we can update the answer to the value four we will update the answer to be four now again we will update the value of our R now R moves one value to the right now this is y y is occurring one times uh now the current length is five and the maximum value we have is X which is two so so far we are good uh now we will try to do 5 - 2 so 5 - 2 is actually 3 which is greater than K which means that this condition is not satisfied so because this condition is not satisfied uh what we need to do is we need to update the left element so we will update the left element over here so now left comes at this place but because we are updating the left element we will also have to remove this one p over here so we will remove P from here and now uh we will update the value so now length will become four again maximum occurrence is still 2 so 4 - 2 that is 2 2 is still less than or equal to K which is good so so far we are good now again we will update the value of our R so now R comes at this place because R comes at this place the occurrence of X comes to three now because this comes to three we will update the value of Maximum occurrence to be three and we will update the length to be 5 now we'll do 5 - 3 5 - 3 is 2 2 is still less than or equal to K so because uh 2 is still less than or equal to K we can we can update our answer as well to the whatever length we have found which is five so we will update our answer to be five now again we will update the value of our r r comes over here now this is a a we don't have any entry so we will add an entry for a and we will call it as one now in this case the length is six length is 6 but maximum number of occurrence of X is still 3 which means that now we can do is uh 6 - 3 so if we do 6 - 3 6 - 3 is equal to 3 3x is actually greater than K which means this condition is not satisfied so now we will have to update the value of our L over here so now we will get rid of 1 x uh so because we are getting rid of 1 x the current maximum occurrence we have so far is 2 okay now our left is located at this position now the length uh is five and and uh the maximum we can make maximum occurrence is 2 so again 5 - 2 is still 3 which is greater than K so again we will have to update the value of our left so now this time left comes over here and we will ignore this Q which means the value of Q becomes zero so I I'll just remove that entry now again this time the length is actually Four and the maximum occurrence is 2 so 4 Min - 2 is still 2 which is uh which is actually less than or equal to K so because this is less than or equal to K we know that okay length four is our can be our answer but our answer is already five so there is no point in updating length to be four okay uh next what we are going to do is now this time we will have to update the value R so when we update the value R we actually reach to the end of the string and because we reach to the end of the string whatever the value we have stored in the answer we can return it as our answer so in this case the answer is going to be five uh from this sequence and we can mention that after doing two word replacement the maximum substring we can make that contains all the same characters inside this given or original string is actually of length five and that is the solution if we see the time and space complexity for this one the time complexity will actually be bigo of n where n is the number of characters that are present inside given s uh now you will think that okay in order for us to find the maximum occurrence actually we will have toate over this entire array and it might takes like there are 26 entries so we might have to do this work 26 times the thing is we are actually going to use a clever trick over here what we are going to do is at any moment we update our right point at that moment only we are going to update our maximum occurrence because remember our maximum occurrence can only increase when we update the value of our right whenever we update the value of our left we essentially decrease the whatever the maximum count we have which means that our maximum count is never going to go high so that's why by using this clever trick we can actually reduce the time complexity to be go of 26 * n to only big go of N and you will see it in the coding uh also in terms of space complexity uh we can conclude this actually two times we can either conclude this to be big of 26 because we are storing an array of 26 characters or we can consider this as big of one or constant constant space because this 26 is a finite number this not this is not an infinite number so that is why uh depends on your pro interviewer how he wants to treat it and uh that that way you can take it forward now let's move on towards coding now first of all we are going to create an integer array to store the occurrences and we are going to name it as occurrence now we will create few variables so first of all we will create variable left and right and we will initialize it to Value number zero now we will create a variable called answer and we will initialize it to zero as well also we will initialize a variable called maximum occurrence now we will run a for loop on all the characters of given string so first of all we will calculate that whether we need to update the maximum occurrence or not so now we will check that whether the current substring if that is valid substring or not so we are going to use an if condition first of all we are going to check that whether the length so in this case length is going to be right minus left + one so if the length minus whatever the maximum occurrence is if that is greater than K which means that uh if that is greater than K which means that the current substring is not valid if that is not valid we will have to update the value of left variable and we will also have to decrement the value that is located at current left counter on the given string once that is done for every single update we will have to check that whether our answer is the longest string or not so we will check that whether what is the value of our answer that should be it so after this Loop ends basically we should have our answer stored in the answer variable so we can simply return that let's try to run this code this should have An Occurrence okay seems like our solution is working as expected let's submit this code oh our solution is not working oh we need to decrement the value first before we update this left pointer so let's try to run the code again okay let's submit it again seems like our solution is working as expected so friends hope you are having a fantastic day today so once again we are going to do an awesome lead code problem that has been asked at tons of companies so without any delay let's get started so the lead code problem we are going to solve is called permutations in a string and we can see that this is a lead code medium problem and also extremely well- like problem on lead code the problem statement is very straightforward that we are given two strings S1 and S2 now we need to check that if any of the permutation of S1 is present inside the S2 string then we need to return true if that is not the case we need to return false now let's try to see see this with an example say for example we are given S1 is equal to value a and b and we are given a string S2 now there can be two permutations and combination of A and B It's A and B itself or either b and a now we can see that in this string S2 B A is actually present so because it is present we can actually return this as true saying that a permutation of ab or string 1 is actually present inside the string to now let's take one more example uh in this case we have ba a as partial permutation of the string one but we does not have anything like C or we have in this case we have AC but there is an X in between so we do not have any direct permutation of string one present inside the string two so in this case we can return false now even though we have a b and c all three present inside the string two but they are not present together so that is the main problem so now let's see that how can can we actually solve this problem and the number one approach is very simple Brute Force approach so for the Brute Force approach what we can do is we can take string one suppose the values are a b c and then we can take string two suppose the given values are once again b a x c d z something like this so we can take every single possible permutations of S1 and then we can che check that whether those are in any given moment present inside the string two or not so this is going to be very inefficient icient approach so we need to do something better now the question is in any given case suppose the string one is AB C then what are the different permutations and combinations possible in either case you can notice that instead of keeping track of all of these permutations and combinations we can say that currently for the string one we actually have three different characters and the frequency of each of the these three characters is actually one time so we have a present one time B present one time and C present one time so at any given moment inside the string two if we identify that suppose string 2 is let's say that x b a c d z something like this and if we identify that amongst any given moment we can identify these three occurring in any subsequence in the same amount of frequency so I'm not talking about order that a has to come before B has to come before c I'm talking about the frequency that at any given moment we wants to check that whether all three a B and C are present in the same number of uh occurrences which we can see over here that if we take a look at this portion we can actually see that we can also make another frequency map that contains once again characters a b and c and each occur one time so because there is a match in this regard we can actually say that this string one is actually a present inside the string two as one of the permutations or combinations so this is the approach we are going to use now in order to use this approach we actually need two things number one item we need is that we need a way to create a frequency map to contain that how many times any single character is present inside the given string one then we need to create the window of that exact same size and then iterate over every single possible Windows of the string two and once we do that all we need to do is just compare two different frequency Maps so what are the efficient ways for us to compare frequency maps and create sequ frequency Maps well there are actually two ways so number one way is that we can actually use a hashmap because in the hashmap we know that it is a key value based pair U data structure so as a key we can set up the character and as its subsequent value we can set up the frequency so once we have the hash map or frequency map for string one we can do that and same way the existing window we have for string two we can actually create a very similar frequency map uh for the string two as well so that is option number one the option number two is that we actually create an array with 26 characters and we create two arrays so one array is for string one one array is for string two for that specific window and let's assume that in string one uh the value is a b c so we can Mark a BC as 111 and for rest of the characters we can mark them as zero and this can be uh also an efficient way for us to check that what is the frequency and how many uh times it is present so same way for S2 we can also create uh an array so both ways will would yield the same uh space complexity so what I'm going to do is uh in the example I will explain it to you using hashmap but in the code we will use the array method okay now let's try to understand the approach I'm suggesting using couple of examples so suppose we are given our string map is equal to value a b a and we are given our string two as the values a b c d e f e x then a a b something like this okay now we know that what is the approach we are going to do for string one we will have to create a hashmap so let's quickly create a hashmap the idea is that string one hashmap map is going to look very simple that it only contains three characters that are a and sorry only two characters A and B now a is present two times and B is present one time now we have the hash map for string one now for the string two what we are going to do is that we are going to create an exact same size window and then we are going to keep sliding that window over from left to right and using that approach we would be able to solve this problem very easily so let's let me tell you what I'm what we are trying to do so initially the string two does not have a hash map uh so let's create a a frequency map for string two as well okay and I'm marking three values uh so now let's see okay currently uh this one does not have anything so we are going to consider these three values as our first window now we are going to create a frequency map and the idea is that we can keep on comparing the two frequency Maps or if you don't want to create two maps we you can actually start deducting values as well but in either case you will have to remember that what was the original state okay so that's why for our Simplicity I'm creating two maps so now for this a we have this a and it is occurring once once again we have this B it is also occurring once and then once we have C that is also occurring once but if we compare these two then uh we can see that A and B is partially there but C should not be there and the we are still missing 1 a okay so in this case this is not the correct approach so now we will have to migrate our window one step forward which means previously we were considering this ABC so now we will get rid of this a and we will treat as if this a is currently no longer needed and now we are going to be dealing with this particular window now the thing is when we are dealing with this window the question is do we need to create another same window for this new portion the answer is no we can actually do something very simple the idea is that whatever the value was present over here we can actually get rid of that value because we are moving to the next step inside our sliding window and then whatever the new value is we can simply add that new value to the hashmap so now we are going to get rid of a and we are going to add one another value D and we are going to Mark its frequency so D is also present once but once again this window also does not yield us the correct result and these two are still not equal okay so now we will have to consider this window so once again we will keep on repeating the same process we will get get rid of B once again we will get rid of B we will include value e again so now e is present one time but also this window does not work as well so now we are also going to get rid of this value number c now C is no longer present uh so but now we are going to include value number X so X is present one times but once again this is also not correct so we will get rid of D and we will have this window to consider so now we are going to get rid of D and we are once again going to add value number a one times now once again this is not the correct approach so we will once again get rid of value number D or sorry value number e and the new value is a so because new value is a a is already present which means we do not have to add a again so we can just Mark uh increase the value of a second time now uh currently we are considering this window but this is also not the correct window so we will also get rid of this one we will kick X out and then we will add value number B so adding value number B would allow us to add one more value B inside over here and now this is our final window but in the final window we can see that both string one hashmap and string 2 hash map are same the frequency of character occurring is exactly same which means we have found our optimal solution and we have we can say that currently one of the permutation of string one is actually present inside string two so we can return true as the answer in this case and in case say for an example this one was not b and this one was something else like character d so the moment we reach to this value and we have a string that looks like D1 something like this then there is no longer a window possible for us to move forward which means we have exhausted every single possibility in string to still we did not find the same set of frequency of character present inside the string one which means we can simply return return false in that case and this is the whole approach so this would be the optimal solution if we see time and space complexity in this case the time complexity is very simple it's going to be bigo of n because number one in order to create this hash map it takes us big of end time and then using a sliding sliding window we simply have to iterate over this given array so this is also big offen in terms of space complexity so this can be big go of one why because we know that there are only 26 characters inside the alphabet we are not dealing with any special characters or any extra Elements which means there is only a finite number of characters we can store inside our uh hash map or frequency Maps so that's why space complexity is going to be one so this is a very good time and space complexity which yields us very good results so now let's quickly see the coding solution for this one so first of all we are going to check that if the given string one is actually greater than string two which means we can directly return false if that is not the case we are going to initialize two arrays with the size 26 which we are going to use as frequency Maps then we are going to initialize the frequency map for the string one and also so for the first window of string two and the first window of string two is going to be the length of a string one okay then we simply have to slide the window through uh S2 and compare it with the frequency map of string one if both match then we can simply return true if that does not match we are going to keep on updating the window of the given string which means we are going to drop off the left side of the element and we are going to add the right side of the element and then we can simp once again keep on repeating the same process until the very last window if we do find that there is a match then we can simply return true at any given moment we find that uh we are able to reach to the very end then we can simply return false and we are creating a helper function to compare the frequency of two maps uh which is going to be just running four Loops across both the arrays and check that at any given moment whether the the frequency is deviating away from a single character or not not and then we can simply break out of that Loop okay so let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs extremely fast in terms of time complexity and also very efficiently in terms of space complexity so you can find this code in our GitHub repository and the link is in the description thank you hello friend we are still not employed by a Fang company so let's not stop lead coding till we get there today we are going to do minimum window substring problem and if we see some of the companies where I want to get a job there are companies like Facebook Amazon LinkedIn Microsoft Lyft Airbnb Apple Adobe Google Snapchat flip card bite dance Spotify Tik Tok Bloomberg Uber Pinterest and Goldman sax who have already asked this question so that's why I paying my atmost attention I hope you also enjoy the video so this is the lead code hard problem but it is also a very well-liked hard problem basically we are given two strings called s and t and we are given the lens M and N respectively for each s and t strings now we need to return the minimum window substring of given string s such that every character in t including all the duplicates that is the key part is included in the window that we have created from this s and if there is no such window then we need to return the empty string so if we try to understand this with an example if we take this example for instance uh we are given a string s that looks like this and we are given a t that looks like this now we need to return a substring in this given s such that this a b c is present now we don't care about the order of this AB BC they can be in any order in the new substring that we are trying to create but we need to return the smallest substring so if we see one of the substrings that where this a BC is present uh we can find a substring that looks like this if we see this particular sub string for an instance we can see character a b and c is being pro presented the thing is the question is is this the minimum window substring no this is not the minimum window substring why because there exist actually a smaller substring where ABC is also present and we can take one more substring that looks like this so this substring is smaller than this first one where also a b and c is also present though they are in different order but this is again not the minimum substring uh there is actually substring which is B A and C where all the values of a b c is present that is continuous substring of this s and this is the minimum substring where we can find all the characters that are present in T and we need to return this as an answer if we see couple of more examples over here suppose we are given s is equal to a and t Al also equal to a we can simply return return a as the substring because that is the only substring we can create now if we are given s is equal to a and t is equal to a a which means that there is no way possible for us to create double A from this single a so in this case we need to return an empty string so now since we have understood the problem let's see that what would be the different approaches to solve this problem so first of all I'll show you the Brute Force approach and if you directly want to check that what is the optimal solution I have already provided the time stamp so you can directly jump onto the optimal solution as well okay suppose this is the S and this is the TV are given we are looking for a substring inside this given s uh which contains all the letter of this T and we need to find the minimum length substring for that now we can clearly see that there is one substring hbpo which contains all of the elements of that are present in t but the smallest substring we need is actually OB BH which contains all the elements of this T and that contains the smallest length The Brute Force way to solve this problem is that we actually start creating every single possible substring out out of this given string s so we can create substrings like we will check that okay this can be a potential answer we will put it as a potential answer and we will Mark its length now uh eventually we would find a substring that looks like this o BH that is the correct answer and then we would return this answer as our solution so this solution will also guarantee to provide us the right answer but this right answer is actually very costly why very costly because we know that it takes bigo of n Square to actually create all the substrings and for every single substring we will have to check that whether it contains all the elements of t or not which means we'll have to multiply this by the whatever the length of T is which is uh let's say m in this case which means that we we are actually essentially doing we go of n Cube work to solve this problem which is very expensive okay suppose this is the example that we are given and we are trying to find that what is the minimum substring inside this given s where all the characters of this T is present so to optimally solve this problem we are actually going to use sliding window technique with two pointers so now I have presented the input in slightly different format and I have also created uh that what is the answer we are going to store because remember in the answer we need to return return that what is the minimum substring and for any minimum substring we need the left pointer and right pointer value and we also need the length and we will only choose the minimum length now initially we are going to have our left and right both pointers starting at the first position and now what we will have to check is that we are going to have our right pointer go on the right side until the point where we create a substring where all all of these a B and C are present the moment we do that we will note down that what is the answer we have found so far what is the minimum length what is the left pointer what is the right pointer once we do that we will start updating the value of the left pointer to go on the right side until the point when this condition is no longer true and we are not able to make ABC in the given left and right string and again we will update the process on our right portion and then again we will try to see that whether we can find a better substring or not so let's see this approach in action so now to achieve this uh approach what we are going to need is that we have we already have our two pointers left and right over here now we need to check that at any given substring whether this T is present or not so if we for every single substring try to check that whether the all of the characters of T is present or not it takes a lot of time one quick way to do it is that we actually create a hash map for all the characters that are present inside this value number T and inside the hash map we note that what is the elements and what are the number of occurrences they have so in this case for this T hash map we actually have three characters only and we have one occurrence of each of them so we are going to note it somewhere so it becomes easier for us to record now at the same time for any substring that we create we will also have to check that whether we have all the satisfied words inside our substring or not so again we are going to create a hash hashmap for our substring that we are creating as well and inside the substring hashmap we are going to keep on adding the values as we move forward now uh to check hashmap every single time is not a very good approach a better approach in this case could be that we already know that what are the number of unique characters we need inside this hashmap so why don't we just create two variables called the number of unique characters so we just name it as unique uh that are present inside this T hashmap from this given original input and whatever the substring inside the substring whatever the unique characters that we have already been able to create so let's just say thatth this name is create and we will keep track of it right I'll just show you that how we are doing everything when we keep moving forward on the uh with our example so initially a left and R both are at this position and currently we will note that okay a is not present inside our given substring so we will add an entry for a and so far we have received one occurrence so far right now uh originally this T hashmap had three unique characters so we are going to note that that there are three unique characters that we have to find in any given substring and so far because this current right position is at a we have already found one of the characters of the required occurrence right so we will note down that okay we have already received one of the characters now our right pointer is going to the next element because we haven't satisfied our full condition so now we identify that okay this value is actually B so we are going to add an entry over here inside our substring hashmap and we are going to say that we have found one occurrence of B and this one occurrence of B is already also required inside this given hash map as well so we can note down that okay out of this three required we have actually found two unique characters that are needed right we are good so far now uh next thing we are going to do is that again again over here we we are going to update the value for right pointer we encounter that this value is actually a so we are going to add one more entry to our required pointer so over here we have found two occurrences of a but that does not solve our problem because our unique and create are still not same so now we are going to update the value of our R again so now again R is at this position X X is not present over here so we will add an entry for X is equal to 1 but this x is actually not present in this key hash map so we can't do anything about it uh now again we were going to update our value of R so R is at this position now because R is at this position remember that this is the value of c c is actually one C was the remaining value inside this T hash map now we have three unique characters that were needed and we have already created three unique characters inside this given H so now we are going to treat this substring as our answer because remember we needed to have the values A B C and A B C are actually present over here this is a this is B and this is C inside this given left to right substring so we have found one potential answer so first of all we are going to check that okay what is the length of this one so length in this case is 0 1 2 3 4 so length is actually five and the left pointer is at zero position and right pointer is at four position and we are able to add this entry to our answer because we don't have anything before so that's why we were able to add an entry to our answer now we are going to update our left pointer until to the point when this condition is no longer true so now because previous value of left pointer was over here and now we jump to jump to this place so now left pointer is at here but the moment we updated the left pointer we will also have to remove the value of our uh reduce the value inside our substring hash set hash map so now a there is only one occurrence of a so far this condition is already true because both this three and three three is matching right now again we are going to update the value of our left pointer to one more character so now left pointer is over here now this B is actually zero so we are going to remove the entry for B now because we remove the entry for B we have only created two elements that are needed inside this substring from this position two to position four which is a and C we don't have B entry which means now we will have to update the value for right pointer until we find the B now lucky for us B is actually very next to this right pointer so now right pointer is over here and B is actually over here so B is one we will add an entry over here and now we have already created all of three elements needed uh rather than two and we are done with this case right so which means we can say that this uh new substring is also a potential answer and let's see that whether this substring is actually better than our previous answer or no how can we determine that remember uh the aim of this question is to find the minimum length of the substring so so we are going to compare the length of this one so length of this one is actually Four and the current answer we had was actually of length five which means it is in our interest to update the length over here and the moment we update the length we will also have to update the left and right pointer over here so left pointer currently is at two position and right pointer is at currently at five position now we have found a potentially better answer now again we are going to update our left value because we have already find the answer so now left comes over here which means we will have to reduce this value of a so again we are going to reduce the value of a so a is now zero so there are no occurrences of a because there are no occurrences of a uh in this new substring we we have only created two elements out of this three unique characters that we are needed and which we can see in this particular uh substring substring uh from this position number three to position number five that we only have C and B we don't have a now we are going to update the value of our right pointer now again when we update the value of a right pointer lucky for us we are actually able to find one a so we will add an entry inside our substring hash set that okay now we have found one character now we can say that we have created all three characters that we needed now this is also potentially a new substring and can this be a better answer so we'll check okay in our length we already have an answer of four uh inside our uh answer array that we have St and this is also an size of four so which means that there is no point in updating our answer we have we already have the same answer with the same length so we are we are going just going to go to the next case so now again we increased our value of left so now left is is again at this position so we will have to ignore this x because we already got rid of it which means that we have already traveled all the values so far and now we are at CBA now CBA again this is all of these three elements that were needed and we already have that and which means that this is also potentially a better uh a better substring that we have found and the length of this is actually three so because the length of this is three this can be a better answer so we will note it down so so this is three now left pointer value is four and right pointer value is six so we have found a potentially better answer since we have already found an answer and we know that this is a valid substring now we'll have to update the value of our left pointer so once we update the value of our left pointer we are actually going to ignore the C so now we get rid of the C inside our hash set now we are we also get rid of this L and now we have taken care of all of these elements so far now the we only have ba which means we only have two elements out of three that we we needed now again we will have to update the value of our right pointer so again we update the value of our right pointer over here we find that okay this value is actually c c occurrence is one we which means we have created this element actually three uh all of this is successful now the we check that okay length of this is actually three we already have an answer of length three which means there is no point in updating that uh now we will update the value of our left pointer we will ignore this B so if we ignore this B now we only have two elements out of three needed so because we have two needed we will have to update the right right pointer so now when we update the right pointer we are actually going to be at the end of our uh string and because we are at the end of our string we can actually break out of the loop and the moment we break out of the loop which means that whatever the value we have stored inside the answer we have the left pointer we have the right pointer so all we need to do is we need to return the substring so if we return the substring in this case we will have to return the substring that looks like this so the answer in this case is actually going to be CBA which is the minimum substring that we can achieve that contains all the elements of the T that are present over here and remember over here we are using hashmap and substring hash map to find the answer in order to make our lives easier we have created two elements to know that what are the unique characters that we need to compare in case because this was a string and we know that there can be only a finite number of unique characters which is 26 we were able to use this technique but your interviewer is for sure going to ask you that rather than having a string and having finite number of unique characters you are actually going to have millions of hash code characters or something like that in that case you will not use this technique and you will actually just simply have to check over the hash map or for every single substring that you are going to make so this is one of the approach where we can find the optimal solution and uh it works as expected if we see the time complexity the time complexity is actually going be go of whatever the length of string is plus whatever the length of T is and why we are able to achieve this uh time and space complexity because we are using this technique so that makes our lives a little bit easier if we see the space complexity the space complexity is also going to be actually big go of the whatever the size of s is plus whatever the size of T is and this also works uh because we are creating two additional hash maps and we need to take care of that space into account but overall this is still much bigger Improvement in compared to our Brute Force approach now there is one more approach to solve this problem uh that uh whatever the input that is already given first of all whatever we we create the same hash map we create for this element number T which means that we actually use the same hashmap that I have drawn over here to compare all the values of T but uh for this value number s actually remember that we only need to find the substring of characters that are present in t but so if that is the requirement why do we even bother checking this element X or any other element that is not one of these values so a better way to solve this problem is to create another hash map where we ignore this X and we only keep character inside this given string that are also present in the inside this given T and in this particular hash map we also identify that what is the index value for every single element so in this case we will determine that okay this a is actually present at zeroth position then again we have a b that is present at First Position again we will mention that there is an a that is present at third uh sorry second position and so on and so forth and then it will make our lives little bit easier and we can solve this problem but I don't think in the in an interview even if you show this approach they are going to completely reject your suggestion so that is why I am choosing this one let me know in the comments if you want me to solve the other approach as well where we are only going to use the unique characters that are also present inside this given t so first of all we are going to check some edge cases if the given string is empty or if the length of the given T is actually greater than length of s if that is the case we can simply return uh as empty string now if that is not the case we will create a hashmap to store the value of this T string inside the hashmap for all of its characters we are going to name it as map T now we are going to run a for Loop across this given string t and we are going to add all the entries to our map T after the loop ends we are going to create a variable called required that gives us the number of unique characters that are present inside our given map T hashmap now we are going to initialize bunch of different variables to keep track of different things so first of all we are going to initialize variable called left and right to keep track of our two pointers once that is done we will create a variable called create uh that defines that what are the number of variables that we have created so far uh that are also present inside the given T and we are going to initialize an uh integer array uh to store the value of answer and we are going to initialize the first value as minus one inside the answer where we are going to keep track of the length of current substring and we are going to have two more entries to store the value of left and right pointer and we are going to initialize those values as zero as well uh we will also create a hashmap to keep track of all the values that we have found so far inside the current uh substring and now we are going to run our while loop across the string s and we are going to run it until the right pointer reaches to the end of the string so inside our uh loop first of all we are going to add an entry to our hashmap for any particular given substring after uh adding a value to our substring now we will check that whether all the elements we have added in the substring is that element also present inside our map t as well if that is the case we can increment the value of number of characters that we have created in our uh substring that are also required inside our mapt as well if this condition is true we will update the value of our create variable now after updating that we will also have to check that whether the current substring if that is valid or not and by valid I mean that whether the required and create has has the same value if that is the case we will have to update the left pointer and we will have to shrink our uh size also we will have to add entries to our answer car answer array as well so we are going to run another while loop that while left is less than or equal to right and the required is and created are same we are going to check that whether we need to update our answer or not and we are also going going to update the value of the character uh C variable to help us in doing lot of other things and we are going to assign it the value of the current left pointer now we check if we need to update the answer after updating the answer value we will also have to remove the entry from our substring map because we are updating the left pointer and after removing the entry again we will have to check that whether the value of our uh entry that we just removed did it caused us to reduce our create variable which means that have we removed any entry which was also present inside our map t hashmap as well which was required for us if that is the case we will have to reduce the value of our create variable and it could P it could make us break out of this loop as well in any case we will have to update the left pointer so we'll update the value of left pointer and after that is done we are done with the inner Loop uh in the outer loop we will have to update the value of right pointer and that's it so basically after this Loop ends essentially we would have taken care of all the scenarios uh that are needed for this Loop and now we will work on returning the answer so for the answer we will have to check that if the value of answer of 0o is equal to minus1 which means that we are not able to find any value that were suitable to create as a valid substring if that is the case we will return an empty string if that is not the case we will return the value inside our answer array for this left and right pointer value which means answer of one and answer of two but we'll have to do write plus one why plus one because the indexing works from 0 to R so that's why we will have to add one more entry to our right let me try to run this code oh we made some mistake in generating the answer okay seems like our code is working let's try to submit this code and our code runs as expected and uh I would be posting this solution in the comments so you can check it out from there thank you all of ROP are having a fantastic day today so in this video we are going to do an awesome lead code problem called sliding window maximum this problem has been asked ask at tons of different companies it is extremely well like and also a lead code hard problem so without any delay let's get started now let's try to understand the problem statement for this problem we are basically given an array of integer called nums and we are also told that there is a sliding window of size K which is moving from the very left of the array to the very right of the array so which means sliding window is moving constantly now we are told that we can only see the K numbers of the sliding window and each time the sliding window moves one step to the right position now we need to return the maximum sliding window for every single sliding window that we have been able to find so let's try to see some example for this given problem so initially the window is going to be located at this position then window is going to keep on moving one step towards right which means this one is going to get eliminated and we would have a new window created like this same way this three is going to get eliminated and we would have a new window created like this for every single moment we need to return the maximum sliding window okay is that for this we will have to create another array where we are going to note that what was the maximum character for every single sliding window that we have we have been able to make so the very first sliding window is going to be this portion 1 3 and minus one which means the maximum value in this one is value number three so we are going to add value number three to our answer next this one gets eliminated from the given input array and then we will have a new window that appears of this size which means once again the maximum value is going to be three so we are going to mark three as the maximum value next for this window now we have this value number five that is going to be the maximum window for the current given input so now we are going to add five to our answer same way we will also have five for this particular window as well and we will add five once again now we also get rid of this element and now we have this window to look after so in this case we have a new maximum value that is six and then in the end we will have this last window where it contains seven as the maximum value and this is the answer that we will have to return in order to understand that what is going to be the maximum sliding window so this is what is expected of us to return for The Brute Force approach the way we are going to do is that we are first of all going to create create a window of size K so suppose even in this case we are given K is equal to 3 we create this window then we iterate over every single element and we try to find the maximum element so we found maximum element as three so we Mark that as the answer then we get rid of this one we create another window and once again repeat the same process until we reach to the very end and then we would be able to find the solution now in this case the answer works perfectly fine but the is is for every single element we will have to iterate over three different elements to find the answer and every single time we are creating a new window which means the time complexity is going to be biger of n cross K which is an expensive time complexity so let's see that how can we improve on this one uh one major Improvement that we can make for this our given input is that instead of every single time creating a new window what if we just use this logic of this existing window we already had and try to find the maximum value that we have already identified and then move forward and then play around with that maximum value that is one of the option and this is going to be an intermediary step that we are going to use in order to generate the optimal solution so that's why I'm explaining this approach the idea I'm suggesting is that let's say in this case or first of all we have a an element called Max this Max element is going to keep track of the maximum character that we currently have inside our array as the window okay and uh let's say that first okay currently we are at Value number one which means we can only start adding the value after we have reached to the index value to so any value before that should not be added to the answer or should not be treated inside our answer ARR but we can still keep keep track of the maximum element we have been able to find so far so the idea is that first the value number is zero okay currently maximum value is null so we can add the maximum value we have been able to find so far as this value one then we are at Value number one now once again this value is two so because two is greater than 1 so we will add value number two as the maximum element we have been able to find so far then we are at this uh third value that is- 3 uh sorry - 5 so once again the maximum element we have been able to find is two so we are amongst for this first window we will have to add one answer and that answer we can directly take from our maximum element so we can take value number two next we will have to add one more element so now we are at this value number six after at Value number six this six is definitely greater than the current maximum value we had so we can add value number six as the answer for this one okay and now once again we will have to add the maximum value so we can add value number six over here once again we find Value number seven so that is going to replace our maximum value and then value number eight that is also going to replace our maximum value so we can add value these values like this and build an answer so you must be thinking that hey this looks quite straightforward then why is it even this a hard problem the thing is we actually intentionally I chose an input like this because this is a very simple input where we don't have any particular uh issues but if we are given an input let's say now in this case currently we are going to put our maximum value as this value number three okay and then now we are iterating over for this first sliding window we will have to choose value number three but the thing is we are not sure which value number three we picked and in this case let's assume that this becomes a value number instead of this being four this is one okay so let's assume that in this case so far we know that this is the three that we added but it could also be this three and now when we do move to the next element which three do we have to remove because we are not keeping track of the index value of the maximum element and that's why when our sliding window moves we would be confused with this element so that is problem number one uh the second problem that we can think of is that we are not dropping the elements as we are moving forward so every single time we move forward we will have to drop all the elements that have already passed the given existing window which means uh the approach that we found is to use the maximum element is correct but the problem is that number one we are storing the value that is an issue because we don't know that what is the index position that can be fixed by storing the index position but second issue is that we are only too much focused on just one character meanwhile we should be focused on an entire window rather than just one character and the approach of a this window is very simple and very straightforward that at every given moment whichever the first element that entered inside the window would be the first element to be kicked out of the window when we move to the next window so using these two approaches what I'm suggesting is that instead of using a maximum variable just to store the value I'm suggesting that instead of this number one instead of storing value we store index values so index values will allow us to calculate that whether we are at the current window or not which means it would help us to kick elements out and second thing is that uh in uh instead of only using one variable because we are using a an an input of a window where we are continuously removing the previous Elements which means we are uh using the concept of first in first out for the current to maintain the current window which means we can have a Q where we can keep track of the values that are currently present inside the given window and we know the concept of Q is very simple it's first in first out so we can manage that on top of it inside the given existing window we don't have to worry about storing all the three elements we only have to worry about that what is the maximum element in any given window so what we can do is that for our given Q we will always keep track of the maximum element that we have been able to find at the very first location so that we don't have to iterate over the entire Q to find the value we can simply do a peak operation to see that what has been the maximum value inside the given sliding window and now this should be able to solve lot of the issues we were facing previously so let's understand the approach I am suggesting the logic is quite simple let's quickly take one example okay so let's say that this is the given input that we are dealing with and we are given that the value K is equal to 3 now I have created an array to store our answer and Ive also created a queue where we are going to store all the values of the given current window inside the uh ascending order and we are going to maintain the maximum value as going to be the very first element inside the cube that is going to help us out a lot uh once again I'm iterating we are going to store the index values inside the CU not the actual values itself so we can quickly navigate that what should be the current window size okay so I hope this these things makes clear and remember that since our given K is equal to 3 we can only able to start adding values after we reach to the index value two onwards okay and I'm also creating one more variable I just to understand that what is the current variable we are iterating over so let's say that currently I is equal to 0 we are iterating over which means this value now currently our Q is empty which means we don't have any maximum values so let's quickly add the add one value So currently our Q contains just one element that is zero and I'm also writing the corresponding value one just for our sake of understanding okay now we cannot add anything to the answer until this point so we are going to move forward now once again we identified index value number one that contains value number three so this value is actually greater than the current value of the index position we have inside the cube which means that we need to add this three over here so we are going to add value number one as an index value and which has the corresponding value three and we are simply going to remove this value number one or this index value zero all itself why because for any given window size that we are able to create it is always going to be that this is going to be the maximum element so why do we even keep the non- maximum elements inside the cube so the moment we are going to identify any maximum element we are going to iterate over the given existing queue to remove all the elements that are going to be smaller than that for that particular sliding window that is going to help us out a ton okay so now we got rid of this element okay now still we cannot add anything to the answer so now we are at I is equal to 2 position so currently this is value number minus1 so minus1 is actually not greater or smaller than the current maximum value we have inside the Q which means we are still going to add it inside the Q uh as index value number two which contains value minus one but we this would not be the first position and now since at this I is equal to 2 position is equal to K is equal to 3 which means we are at our first window now whatever the maximum element we have inside our Cube at the very first position we are simply going to Peak that index value and then go go back to our actual uh given input array and find that maximum element and put it in the answer array so now we are going to put value number three first okay now we are at index position number three so once again index position number three the value is minus 3 now what is the current maximum value we has we have inside our q that is index number one which means in our for our I position what is the sliding window it is value 1 2 and three which means the very first element inside the Q we have is still inside the valid window so we don't have to kick that that value out that is number one thing we need to check next we need to check the value for index I is equal to 3 so this value is minus 3 so because this value is minus 3 it is less than the current maximum value we have we are going to add it normally inside our Cube so we are going to add index position number three which is which corresponds with the value number minus 3 okay now and once again we will we will have to add the maximum value because now for every single value we are going to add one value inside the answer and once again for maximum value we are simply going to do a peak on very first element that is our maximum value and we are simply going to add it inside our Q okay now next we are at I is equal to position number four so now we are at I is equal to position number four for this one the window size is going to be 2 3 and four not one so one should be removed and currently in the very first element of the quebe we have value number one so which means we are going to remove value number one right here and now okay now after this we are going to compare the value that we currently have for this value number four that is this value number five and we are going to compare it with very first element so since five is greater which means the moment we identify that the five is greater we are going to check every single element that are smaller than five and we are going to remove all of them we don't need them inside the window because we are only keeping track of the maximum elements so now we are going to store index number four that contains value number five and after doing this we are going to once again add it to the answer so we are going to add value number five to the answer next is element number five that contains value number three so once again this particular value inside our Q index number four is still part of the current sliding window so now we are going to check the values so three is obviously less than value number five so we are going to add value number index number five or value number three inside our given Cu uh and then once again we are going to add value to the answer that is once again going to be value number five now we are at this position where the value is value number six and once again I just uh for our understanding we are dealing with this window so uh index values 4 5 and six okay now for this I is equal to 6 uh we will first check that whether four needs to be removed no it it can stay there for now now we compare the value So currently this value number six or the index I equal to 6 contains the value number six that is greater than the index position four that contains value number five so we are going to get rid of this one and we are going to check all the values that are smaller than six So currently all of these values were smaller than six and we are only going to store index number six answer number six once again marking six as the answer and lastly we are at I is equal to 7 so if I is equal to 7 then the valid Q or the valid window becomes five 6 and 7 index values so the current index value we have inside the Q is six which is still valid then we compare the value so 7 is greater than six which means we are going to replace six with value number seven and which also coincidentally have the value number seven and then uh because this is the maximum value we are able to find we are going to also Mark it to the answer and in the end we are just simply going to be done with our existing Loop and that's it this is the whole approach and this is the whole solution that gives us the desired answer in a single iteration on the given input array and all we are doing is just sometimes we are doing repeated work inside the que to change the value of the array but apart from that we are not doing anything so this is a wonderful approach to solve this problem and this is actually the optimal solution if we see time and space comp complexity for this approach the time complexity is actually going to be big of n because we are simply going to be iterating over this given input array once which is pretty awesome and pretty convenient um so yeah that's that's it and in terms of space complexity because we are using an extra Q so that is going to be big Off K because at Max this can be of size Q nothing more than that so let's try to run this code and U so now let's try to so now let's try to build the coding solution for this one okay so this is the coding solution first we are checking for some edge cases that if the given input is equal to null or if the given K is equal to less than zero then we can just simply return a blank and or an empty array if that is not the case first we add we initiate an variable to store the the length of the array then we also create a new value to store the result of the given array and then uh we are also initializing a DQ to store the Q values that we just discussed in the solution now we are simply creating an array to iterate over the given list very first we are checking that are there any indices inside the current window that are exceeding or that needs to be kicked out for that first we check that if the given Q is not empty and the very first element or the largest element inside our given Q if that is less than the value of I minus k + 1 if that is the case then we simply pull that element out if that is not the case then we simply iterate over all the values that are smaller than the given current value if we identify that scenario we simply keep on iterating all the values and keep on removing them then we simply have to add the value to the cube and we need to find the maximum value that is currently located at the very first location inside the cube to our array and we simply add it after the value uh I is I becomes greater than the value of K minus one that we just explained and in the end our result array should have been populated so we can simply add all the values and return that so let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs extremely fast compared to a lot of other Solutions uh once again the coding solution is present on the GitHub repository that we have created so you can go and check it out from there thank you thank you hello friends we still not employed by a Fang company so of lead coding till we get today we are going to do valid parenthesis lead code problem and this problem has been asked by some of the companies where I want to work at there are companies like Amazon LinkedIn Facebook Microsoft Bloomberg Spotify Adobe Google Apple Uber Tik Tok Goldman Sach Twitter Netflix twitch Tesla B Dan lift and Airbnb have all asked this question so that's why I'm pay my atmost attention I hope you also enjoy the video this is a lead code easy problem and also one of the most like problems on lead code uh and that is because this problem actually solves one of the very real life application where a compiler has to check that whether the code has valid parentheses or not and so that's why a lot of companies like to ask this problem as an interview question uh if we understand the problem basically we are given a string s that contains just these three types of parentheses opening parenthesis and closing parenthesis and we need to determine that if the given input is actually a valid input or not we are also given the definition that what counts as a valid input that if the opening brackets are closed by the same type of closing brackets and also we are told that the opening brackets must be closed in the correct order so let's try to understand this with some examples over here I have drawn bunch of different uh potential or examples and we will see that if they are valid or not so first of all if we see this example we know that okay we have two closing two opening brackets and we have two closing brackets we can consider this as a valid string so I'm just noting it as V now again in this case we have two different types of opening brackets and we have two different time types of closing brackets so this is also valid string now in this case uh this is an opening bracket this is an opening bracket we have corresponding closing brackets again we have opening and closing brackets and again we have opening and closing brackets so everything is in order and the same kind of brackets are open and correct in proper shape and size so we can consider this also as a valid format now if we come to this example example this is an opening bracket this is also an opening bracket but we only have a closing bracket for this original opening bracket so we can consider this as invalid option so we get an idea why it is invalid in this case we have three opening brackets and only one closing bracket so again this is an invalid uh string and in this case actually if we see the number of opening brackets and number of closing brackets they are actually same so we have one opening bracket and one closing bracket again one opening bracket and one type of closing bracket but this is still invalid why it is invalid because this bracket this curly bracket is actually opened before this particular round bracket so that's why it has to be closed before this round bracket closes and in this case this round bracket actually closes first before this curly bracket is being closed so this is very important property that we will have to keep track of and that is why we are told that we need to keep track of the order in which they are opened and closed and then only we can determine that whether they are valid or not so this is also an invalid uh formula so let's see that what would be the potential solution what so let's start from the very simple example and see that what would be the intuition behind building a solution suppose we are given an example that looks like this where we are given all of the brackets that are of the same kind and we are given some opening brackets and some closing brackets well we can clearly see that this is a valid approach and how we can determine is that we can actually create a counter and what this counter does it that any at any given moment we identify an opening bracket we are actually going to increase the value in this counter and at any given moment if we encounter a closing bracket we are actually going to decrease the value in this counter and at the end we have to check that whether the value inside this counter if that is equal to zero which means we can determine that the same number of opening bracket and closing brackets are present and then we can say that the string is actually valid if that is not the case we can say it is invalid so if we see that in action first of all we have three opening brackets so we will increment the value of this counter three times and if we do that we will get the counter value to be at three again now we identify a closing bra so now this value from three becomes two again we identify two more closing brackets so again it go it gets decreased two more times and then we get the final counter value to be zero and because we get this value as zero we can say that okay this string is actually valid string and the same number of opening and closing brackets are happening so this is one way to identify a solution but in this case the complexity is actually very simple why because we are only using one kind of opening and closing brackets in our original problem we problem we are actually told that there are three different kinds of opening and closing brackets and we will have to keep track of them also we need to keep track that in what order they were opened and closed and that order also has to be maintained so it is not just as simple as keeping track of counter that we create three different counters for all single typ one of them and then we see that at the end whether this value is zero or not we also have to keep track of that what is the order they were opened in and they were closed in for the optimal solution we we know we need to take care of two things first thing is we need to check that whether the opening and closing number of brackets are same for each three different types of parenthesis or not second thing we have to take care is that what is the order in which they are opened and closed so first let's tackle the first problem we know that for every single opening bracket there has to be a closing bracket and they are always in pair so now to quickly look them up we are actually going to use a hashmap now inside our hashmap we are actually going to have all of these closing brackets as the keys and their opening brackets as corresponding values so we are going to have three entries now we have to take take care of their order and number of occurrences so the idea is we are actually going to use another data structure called stack and the stack is actually going to be very helpful to us so let's try to understand this with an example that how we are going to use a stack over here suppose we are given an input that looks like this okay so I'm going to show you two examples um on how we are going to solve this problem so first let's take this example and the idea is that at any given moment we identify an Open Bracket we are going to add that value inside our stack and at any moment we are and going to encounter a closing bracket we are going to pop a value on from the stack and then we are going to see that the whatever the value we popped out if that is the same value that is for any given uh hashmap value we have inside the string for this that particular closing bracket so let's see that in the action first of all we identify these three opening brackets so we are going to add all of the entries inside our SE so first we will add a curly bracket then we will add uh these two brackets once we are done with this one now we have a closing bracket our hand the moment we identify a closing bracket remember we will have to pop the value out of our stack so we are going to pop the value out of the stack and the value we have popped out is actually this one now for this closing bracket we are going to see that what is the value of that bracket inside our hashmap and the value of that bracket is also like this and we are going to compare these two elements that whatever we took out from the stack and whatever we got from this hashmap and both are same so because both are same we can say that okay we are good so far and now so far we have actually uh taken care of these four elements and now we are on this element again this is also a closing bracket so because this is also closing bracket we will have to pop a value out and we are going if we pop a value out we will get a value that looks like this where that we are arrived from our stack and now we are going to check that for this particular bracket that we were iterating over what is the corresponding value inside the hash map so the key is this one and the corresponding value is this one so the value we found from our hashmap is also this one and they both are same so because they both are same we can say that okay we are good up until this point now we are iterating over this curly bracket so we again pop and also I have forgot to uh delete this value now again we pop out a value from our stack so now we don't have this value over here and we have a bracket that looks like this again for this closing bracket the value inside of our hash map is also an opening curly bracket and both are same so we are good up until this point now we are only up to last two characters so this is also an opening bracket the moment we identify opening bracket we will add an entry to our stack and now this is a closing bracket so again we will pop this entry out after popping this entry out so this is the value we popped out from the stack and then we will compare from our hashmap so the value is this one and both are same so we are now we are at the end of our string and because we are at the end of our string we are going to check that whether inside the stack we have entry any entry or not we don't have any entry so we can return true in this case and we can say that the given string is actually valid and this would be the answer now uh let's take one more example where the string is not valid and see that what we are going to encounter in this case suppose we are given a string that looks like this so in this case we have two opening brackets and one closing bracket so first of all we identify that this is the opening bracket uh we are going to add an entry over here again we encounter an opening bracket we are going to add an entry over here now we encounter a closing bracket the moment we encounter a closing bracket we are actually going to pop out the value from our St and the value we popped out is actually a curly opening bracket now for this closing bracket we actually have a corresponding value inside our hash map that looks like this one now these two are actually not same so the moment we identify that these two are not same we can immediately return that this string is actually invalid and the parentheses are not in correct order so we we are done with this one time complexity is actually going to be big go of n where the N is the number of entries present inside the string and even in terms of space complexity because we are using a stack and hashmap but we don't care about hash because it has finite number of uh entries but for the stack the values will be dependent on big of n as well on the number of in entries present inside the string now let's move on to coding so first of all we are going to initialize our hashmap and inside the hash map we are going to store the values for three different brackets that we are given okay we are done with this one now we are going to initialize our stack and we are going to name it as stack as well and now we are going to run a for Loop across the given string so first of all we are going to initialize a character C and that is to keep track of whatever the character we are looking over inside the given string now we are going to check that if the current bracket is opening bracket or closing bracket which means that if the key value is present inside this mapping bracket then we can Define that it is a closing bracket if not then we can Define it as an opening bracket so if the value is not present inside this ma bra bracket ke which means that we will have to uh push the current value inside the stack if not which means that the value is actually closing bracket and then first of all we are going to pop the value out of our stack and then we are going to compare it with whatever the value pair inside the map bracket we have and if the stack is empty we can return false immediately so in the else condition we check that if the stack is empty we can return false immediately if not we are going to pop out of the pop out a value from the stack and we are going to name it as top element and now we are going to check that whether that is the same value that is present for the map bracket value key and if the values are not same we can return return false immediately as well and if that is not the case eventually if we get out of the loop then we will have to check that whether the given stack is empty or not if the stack is empty we can return return true or else we can return false let's try to run this code okay seems like our code is working as expected let's submit the code and our solution is actually pretty fast compared to a lot of other Solutions uh so I would be posting this in the comments so you can check it out from there thank you hello friends hope you are having a fantastic day today so once again we are going to do a very popular lead code problem that has been asked in companies like Facebook Amazon Microsoft Google Apple and bunch of more so without any delay let's get started so the lead code problem we are going to solve is called Min stack and you can see that this is a lead code medium problem and also a very well-like problem on lead code the problem statement is very simple that we need to design a stack that can support push pop top and retriving the minimum element inside the given stop these four operations and it needs to run in constant time or B go off one time so we need to implement the minst class and these are all the methods that we need to implement now we know that how does a typical stack work stack op in Leo principle last in first out if we decide to push element number three then we will have an entry three presented inside the stack next we can push another entry called one then once again we will have entry called one then once again we can have Push another entry called five So currently we have three elements now inside the stack if we have to pop this element then the element five would pop out so let's quickly pop one element so then we will get answer number five then if we do pop once again we will have number one after doing that if we were to add two two more elements or push two more elements let's assume two and six so once again we will have elements 2 and six something like this then if we do top operation at this moment it it should return answer six because that is the top element inside the array and then if we do get min then it should return us the value S2 because this is the current present minimum element inside the given stack so these are all the operations that we need to do we need to solve all of these in big of one time which means we will have to do something different when we are designing our stack so what are some of the considerations that we can do the thing is this push method pop method and top method all of these three methods can operate in big of one time no issues with that in either case this get min is little bit tricky because we will we will need to know that what is the minimum element at any given moment now the very first thing that comes to our mind is that when we are designing the stack uh why don't we just have an extra variable called Min to keep track of the minimum value we have encountered So Far So currently this is an empty stack let's assume that we enter value number five so this has been the minimum value so far five next we add value number six so five is still the minimum value next we add value number two so once again we update this and add two over here once again we add value number seven so now currently the minimum value is two but now there is is one problem that you did not see and that problem is that let's assume that we decide to pop one element out so now currently seven is no longer here but once again the minimum V variable is still two because that is the minimum variable let's see let's say that if we do pop once again so once again two is now no longer inside the given stack as well so now if we do Min operation we don't know that what is the minimum value inside the array because we just overrode the value so if we have to check for the minimum value we will have to pop all the element ments out of the stack and then find the minimum value that is option number one which takes big off end time and if we don't do that we we basically don't have any other way so now to overcome this issue and to keep track of the minimum value at every single variable we can actually do things slightly differently so the moment we are storing the values inside the given array uh we are actually storing different nodes right for every single location now in this design of node we can actually have node have multiple items not only just its value so let's assume that this is our given node and so in the node I'm suggesting to add three values first value is the value of the node itself that whatever the value we wants to enter that is your integer value like 1 2 3 4 whatever he wants to put next is that what has been the minimum value up to this point inside the existing stack and if we keep on updating this value with every single entry inside the stack this would be pretty easy to maintain and last thing is the reference to the next node because uh in case we will have to remove or get rid of the element we might need to update the minimum value we have entered so far so let's see that how would this approach is going to look like let's say that we wants to add these values inside the stack okay so first we wants to add value number three currently the node is empty so because node is empty we are adding value number three uh what has been the minimum value we have added so far that is also going to be value number three and the reference ref to the next node is going to be null so we are not going to be concerned with that that this is the very last element inside the stack okay now we need to add value number five so we add value number five but what has been the minimum value is is so far so for that we can either check the minimum value of the next pointer using this next pointer so we check that what has been the minimum value of the next pointer at location number five that is value number three and what is the value of this current value we are trying to enter that is value number five so whichever is the smaller number which is three in this case so we will still Mark three as the minimum value we have been able to find and then we simply have a reference to the next node so reference to the next node once again I'm just marking as three but that that is simply going to be this node okay once again we wants to enter value number one so now at one what has been the minimum value up until this point that is this value number three so instead of using three because one is smaller so the smallest value so far is going to be one and the reference to the next node is also going to be this one same way now we wants to add value number seven but what has been the minimum value we have been able to find so far that is value number one and then just the reference to the next node and then in the end the value is zero so now the value is zero we are trying to see that what has been the minimum value up until this point that is one so compared to one Zer is smaller so then this is also going to be zero and then we simply have a reference to the next note okay so now this is what our stack looks like we are simply updating the node that we are storing the values in and now let's see each of the operation so I just mentioned that push operation can happen in big off one time because we are just simply pushing one node inside the stack uh let's try to do a pop operation so pop operation can also happen in big off one time because we are simply popping one element out so we will get rid of this element okay now once again let's try to do the top operation so top operation we need we can return seven immediately because that has been the latest value we we find and then if we do the get min operation this can also happen in big off one time because we can simply find the minimum value we have been able to identify so far so this is the logic on how we are going to solve this problem basically by simply redefining the way we are storing the values and then keeping track of the minimum value at every single position that is the whole trick and if we see time complexity in this case well time complexity we already know that that is going to be big of one and in terms of space complexity uh well this is debatable but I think it it has to be big off one because anyways we are being asked to create a stack so we cannot create extra space for that so first let's define the node for our given class where we are going to store three values first one is the value of any particular position next is the Min value and third is the reference to the next node and this is just a simple Constructor to store the values okay now coming back to our main class we are going to have a private node head and we are going to initialize our data structure here next we are going to have a main push method so whenever we need to push any single entry so if the value is very first then we are simply going to provide the value as it is then minimum value is also going to be the same value because there are no other entries inside the stack and then the next element would be simply null if that is not the case we are going to add a new node where we are going to keep the value as it is then for the minimum value we are actually going to compare it with the current value and the minimum value we have been able to find so far and that we can simply find uh using the next node and then as a part of the next node we are simply going to point to the Head node and this is going to be keep on updating with every single entry uh for the pop it's very simple we simply uh take the very first element that is currently present for the top we simply return the very first element and then inside the for the get min method we simply return the minimum value for the head and this is the whole solution let's try to run the code okay seems like our solution is working as expected let's submit this code and our code runs extremely fast compared to lot of other Solutions in terms of time complexity and very efficient in terms of space complexity so once again I will be posting this in our GitHub repository so you can check it out from there thank you hello friends hope you are having a fantastic day today so in this video we are actually going to solve a very popular lead code problem so without any delays let's get started so the lead code problem we are going to solve is called evaluate reverse polish notation and we can see that this is a lead code medium problem and also an extremely well-like problem on lead code the problem statement is quite straightforward but it actually has bunch of different conditions that we need to understand so we are given an array of strings called tokens now these strings represents an arithmetic expression in the reverse polish notation now we need to EV valate the expression and we need to return the integer that represents the value of the expression now let's try to see some of the conditions that we are given number one the valid operations are plus minus multiply and division so these are the four operations that we can we can imagine to expect in our uh string that is coming in now we are being told that each operand may be an integer or another expression so we will see this in in another example then we are being told that the division between two integers all always truncates towards zero which means we are always considering the ceiling value of ceiling value or sorry the floor value of any equation and then we are being told that all the inputs are going to be valid and there are not going to be any issues so let's try to see one example one very simple example so in this case the answer is going to be that the moment we identify an operator we will have to go back and take the previous two elements and if these two are whatever the numbers are we are going to be using that with this operator so we are going to be treating this as a we are going to be treating this as B and since this is a plus operator we are actually going to be doing a plus b so we need to return three as the answer in this case let's try to take some more slightly more complex examples first we are going okay so this is the number we move move ahead once again a number we move ahead we identify an operator so now we are going to be treating these two values as a and b so we are going to be doing a plus b so 1 + 2 so the P the answer of this portion is actually going to be three our equation looks like three and then three and then plus so once again we are going to be doing 3 + 3 so the answer is six so out of this operation we need to return six as the answer so this is the whole logic of what the problem is actually asking us to solve that whenever we are given the values we keep moving forward until we find either one of these three operators like plus minus multiplication or division the moment we identify these four operator we are going to be treating the previous two values as a and b and then apply this operator and then keep on repeating the same process until we run out of all the every single digits inside the given inputs and we are being told that the all the inputs are valid now after this extensive explanation let's try to understand the most simplest Brute Force approach so Brute Force approach is actually quite straightforward uh suppose we are given the values 4 5 plus and then minus and then 7 suppose these are the values we are given so idea is that we are going to keep on iterating one by one the moment we identify an operator then once again we go back to the previous two elements and we use it with that operator and then once again uh we identify okay so now this becomes nine and then minus and then 7 so once again we keep on repeating the same operation using the operator but thing is many times for let's assume that this if this is a very long string and we identify operator at very late the moment we identify operator once again we are going to be repeating the same process in order to keep find the values A and B so this becomes very tiresome operation so the idea is that we need to make it better and uh find some smarter ways to keep track of all the elements from the point we find the operators in the reverse order and also have an idea on how we can keep on moving forward with the given input array and start passsing the values so these are the two main considerations that we will have to understand so the idea I'm suggesting is that we can actually use stack to solve this problem so suppose this is the long operation that we are given now the idea I'm suggesting in using the stack is that at the very beginning we are actually going to be iterating the same way we are iterating all the values we find we are going to be pushing these values inside the stack the moment we identify the operator we are going to be popping the previous two elements and treating them as uh A and B and then applying that operator with that value and once again whatever the answer we find we are also going to be po pushing those answer inside the stack and then we are going to keep on repeating the same process until we identifi the operator and then when we reach to the end we should have our answer ready because we are being told that the given input is actually valid so let's see the solution in action So currently our stack is empty now we are at very first element number two so we are going to be pushing element number two inside the stack now we are element number three and once again element number seven okay now we identified an operator Plus so the moment we identified the plus operator we are actually going to be popping these two values out so if we do that we will have value 7 and three that we need to do the sum of so 7 + 3 is going to give us the answer 10 So currently the answer of this portion is going to be 10 so we are going to be pushing this 10 inside the stack and now look at the stack it actually contains the equation for this portion because sum of these three values is 10 that is present over here and then two was already here now we have 10 and two once again we identify multiplication sign so we need to do 2 * 10 so we get the value as 20 so now once again we are going to be pushing the value 20 because we already popped out 2 and 10 okay so now we have value 20 inside our array and now we once again identified value number eight and then once again value number 19 so let's push that okay after doing that now we identified symbol plus so once again for plus we are going to be doing 8 + 19 so the answer is going to be 27 okay so now we are because we popped out 19 and 8 we push 27 down and then we have this minus operator so last operation we are going to be doing is 27 minus 20 so the answer is going to be 7 so 7 is what we need to return in this case to solve the problem and this is the whole solution that I'm proposing using the stack look how beautiful it is look how at any given moment but by the moment we identified the operator we can actually find the previous two elements back and we can actually do the sum that needs to be done or some division uh subtraction whatever and this is how we can solve the reverse polish operation very beautifully using stack this is one of the most awesome way to use stack in the real life problem and that's why this is such a popular problem that we have seen in tons of interviews being asked so if we see time complexity in this case the time complexity is actually going to be big of n because we are going to be iterating over every single character just once nothing more than that in terms of space complexity we are using an additional uh stack so depending on how aart the characters are from any operation the size of Stack can increase or decrease but overall it is going to be big of n so which is good uh and uh acceptable time and space complexity in this regard so now let's see the coding solution for this one so the idea is quite straightforward first of all we are going to be initializing our stack then for every single token we are first of all going to check that if the given token is operator or not the moment we identify that if the given token is operator we are going to be popping two values out so first value we pop out is going to be our B and second value is going to be our a and then we are going to be applying our operator that we have found uh using this method so let's see couple of the helper methods first helper method is the is operator helper method where we are simply checking that if the given to to is equal to any of these four values and second one we are applying the operator where we are simply going to go over the given input values that is the string and then a value and B value and we are simply returning depending on the operator to whether do the addition subtraction multiplication or Division and if none of this case is there we are simply adding one extra argument but I don't think this is going to uh be called because we are being told that the given input is valid if that is not the case and we did not find that these are the operator by the way uh the moment we identified the operator we also do the calculation and whatever the result we found we once again push it down the stack if that is not the case which means the given token is not an operator so we simply push it down the stack but we first of all convert the value inside the integer because we know that this is going to be the integer value and once this Loop runs we should have been done with our reverse polish notation and whatever the value left inside the given stack would be the answer that we need to return so we can simply pop the very last element so let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs pretty fast in terms of time complexity which is pretty awesome once again the coding solution for this problem is present inside our GitHub repository so you can find it from there thank you Hello friends I'm A Cloud Solutions architect at Microsoft who like making these videos and today we are going to solve a lead code problem called generate parenthesis now if you see some of the popular companies who have already asked this question there are companies like Amazon Facebook Microsoft Apple Bloomberg Uber Lyft Google B Dan Spotify and Nvidia so that's why I'm paying my at most attention I hope you also enjoy the video okay so this is a lead code medium problem and also very well- like problem on lead code basically we are given an input number n and now we need to generate n pairs of parentheses so basically we need to write a function that generates all the possible combinations of well-formed parenthesis now these round parentheses I think they are called well formed parenthesis now we can try to understand these two examples but I'm actually going to take take it one step further and I'm going to show you four different examples to understand that what this problem is asking us to do okay now in this first example we are basically given n is equal to one pair which means we need to make make one possible pair and all the combinations of this well-formed parenthesis so obviously the answer is going to be quite simple we simply need to return like uh just one possible pair that we can make out of this one now suppose n is equal to 2 so now for n is equal to 2 we have the choice to take like two of these and two of these right we need to take four values uh so basically the number of possibilities we can make is that we can actually make a parenthesis that looks like this and we can also make a parenthesis that looks like this these are the only two possibilities we can have and uh this is what we need to return as the answer now things becomes a little bit interesting when we reach to n is equal to 3 uh so when we get to the point where n is equal to 3 the possibilities we can make is so these are the five possible pairs we can make when n is equal to 3 now notice that over here for every single piece we are using like three opening brackets and we are also using three closing brackets but we are just putting them in different pairs so that they generate the well formed parenthesis uh same way if we try to do it with n is equal to 4 the answer is going to be pretty huge so let me just draw it over here so these are all the possible pairs we can make when n is equal to 4 and basically we are using four opening brackets and four closing brackets and arranging them in different sizes so this is a very interesting problem now let's see that what are going to be the different approaches to solve this problem so now the first approach that comes to our mind is a Brute Force approach in The Brute Force approach what we can do is suppose we are given n is equal to 2 right if we are given n is equal to 2 there is one thing guaranteed we need to have four characters inside every single block of our answer why four characters because uh we are generating two pairs of parentheses so two pairs of parentheses is basically going to be four characters at least right so what we can do is uh now we have two options to choose from either we can choose an opening parenthesis or we can choose a closing parenthesis so what we are going to do is basically we can take every single possible pair that we can make of size four using these two characters and only the valid pairs we put put them in the answer so suppose we are given n is equal to 2 what are the different pairs we can make let me make just a few pairs so these are just some of the few examples that we can make for four characters using like this opening and closing par parenthesis for n is equal to 2 and over here we only need to find the legitimate pairs okay we can find one legitimate pair and we can find another legitimate pair and I think this is going to be the answer that we need to return so we will put these two in the answer and then just return them but if you see this Pro Force approach is extremely inefficient uh if we see like time complexity the time complexity goes sometimes into like 2 to the power of 2 N something multiplied by n just to check that whether the pair is valid or not and that is disastrous so no one is going to accept that so we will have to find a way to do something better so what we are going to do is we are going to do things smartly how we are going to do two things smartly first let's define our perspect purpose our purpose is to generate two pairs of opening and two pairs of closing brackets and they has to be well informed or valid now we need like two opening brackets so that is a given fact we need two closing brackets that is also a given fact now there are some properties that we can use at our advantage taking consideration the definition of being valid now what is the definition of being valid so basically if we are given n is equal to 2 there has to be a two opening parentheses and two closing parenthesis so that is one definition second definition for being valid is that we can only put a closing parenthesis if there exist an opening parenthesis before that again I'm repeating myself we can only put a closing parenthesis if there exist a closing parenthesis before that we cannot start our answer with a closing parenthesis because that wouldn't be valid uh third third thing that we need to consider is that we can only have that many number of open parentheses that is equal to the number of n now you are saying that why am I repeating myself because this is going to be the very important property that we are going to use uh so now once we know all of these things let's try to make some smart decisions on how we can actually generate the answer for valid parenthesis uh basically we are given n is equal to 2 over here right now we have option to choose like two opening parenthesis and two closing parenthesis so okay now what we are going to do is for our answer generation always we will have to start with us an opening parenthesis right now we we created the opening parenthesis that starts with this one now we are going to keep track of few values first value we are going to keep track of is the number of opening parenthesis right so number of opening parenthesis that we have used so far is one uh and what is the maximum we can use maximum we can use this two because that is the value of n we are also going to keep track of the number of opening parentheses we already know that is one right we are also going to keep track of number of closing parenthesis and so far we haven't used any closing parenthesis so that this value is zero and we can only add a closing parenthesis if the number of opening parentheses is greater than the number of closing parentheses because we already proved that over here now using this logic let's see that what is the sequence we can make okay so first we start with this value when we start with this value number of opening parenthesis is one number of closing parenthesis is zero now over here we have two options uh and those two options are uh we can either add one more opening parenthesis or we can add a closing parenthesis so let's see options in both of both of the cases the number of opening parentheses is going to be two and we can have this value to be two because we are given n is equal to two and in this case the number of closing parenthesis is still going to be zero because we have only used two open Gap parenthesis over here now in this case the answer is going to be a little bit different uh because the number of opening parenthesis is going to be one and number of closing parenthesis is also going to be one and this is also valid why because the number of closing parentheses can be one because we already had one open parenthesis so so far both of the cases are legitimate now again at this position we also have two more choices so over here we have the one choice to open and we have one choice to close now let's see both the options if we try to go one choice to open what we will happen is number of opening bracket is going to be three but that is not valid why because we are given n is equal to 2 explicitly so in this case we cannot go down this path so if we cannot go down this path we will actually backtrack and come back to this position now from this position we can only go towards the path of closing so if we go towards the path of closing so far the number of Open brackets we had is two and the number of closed bracket we had is one so that is still valid that is still legitimate now again from this position we still have two options we can either open or we can close if we try to open we cannot do that because number of open is going to be three so we are not going to go down this path uh if we go down this path uh basically the number of Open Bracket is going to be two number of closed bracket is going to be two as well and this is the exact condition we need because we are given n is equal to 2 so which means that there has to be two Open brackets and two closed brackets so we can put two conditions whether we can put like the combination of open Plus close is going to be four that is going to be the double of what is uh n or we can have like o is equal to 2 and C is equal to 2 both of them equal to two so this is also good so now we have reached this condition which means that whatever the path we actually make can make our ourselves into the answer so what is the path we took so first we started with uh taking the opening bracket then again opening bracket then again closing bracket and then again closing bracket so let's put this value in the answer right so we are going to create a new variable answer over here and and over here let's put one entry that okay two open two close that is good now let's start following the other path I'm going to clean this up a bit so it does not become any more distraction so now in this case okay currently we have one Open Bracket one closed bracket now again we have two possibilities so first possibility is we can open one more bracket or we can close one more bracket now let's uh analyze both the possibilities if we try to open one more bracket basically the number of Open brackets we are going to have is two let me clean this up a bit more and over here uh number of Clos bracket we had so far is still one so okay this is valid we can put this one now if we try to put one more closed bracket the number of Open Bracket we have so far is only going to be one but number of closed bracket is going to be two which is no a big no no why because we cannot have more closed bracket than the number of brackets we have opened because that would defy the possibility of having a legitimate scenario so we cannot go down this path so we won't and now again we have two choices is at this position we can H open one or we can close one if we open one then the number of open is going to be three that is not valid that is not good so we are not going to do anything with this one and we will not go down this path if we go down this path then over here number of Open brackets we have so far is two and number of close bracket we have so far is also two which is also the legitimate scenario so which means that this path is also going to be a path that we can add to our answer and uh let's see okay so currently we have okay we have one Open Bracket one closed bracket we also have one Open Bracket and one closed bracket and that's it now uh initially remember we only started with this one opening bracket and then we had two possibilities and we actually exhausted both the possibilities so we cannot go down further anymore now because we cannot go down further anymore uh we can conclude that whatever the values we find so far this is the complete answer and we can return this as the answer and basically this is the whole Crux of the finding the optimal solution now you must be asking that hey what we actually did was uh we did something s very important first we identify okay the one value then we had the final case so final case was that whenever the number of opening is equal to n and number of closing brackets is also equal to n this is our final case and then at every single position we had two options to either choose an opening bracket and closing bracket and keep on repeating the same process until we reach to the end and we had some parameters in mind so if you see we are actually using dynamic programming at its finest because at any single previously computed value that is being used to calculate that which path we need to take and whether we can take that path or not so we are basically using dynamic programming plus backtracking to solve this problem and this is going to be like an amazing way to explain this problem uh logically think that in the Brute Force what a disastrous result we were having and we actually brought it down to such like beautiful answer and then we are just presenting it so this is the whole power of uh using any like computer language so before we start implementing the generate parenthesis method first we are going to create our backtrack method uh that is going to be our helper method that we are going to use recursively now for the backtrack method it is not going to return anything uh but it is going to add all the values towards the answer and inside the method we are actually going to create a list of list that is going to store the answer we are also going to have a string Builder to keep track of the current values we have and the number of opening and number of closing brackets and also the maximum number of values we can generate okay so now first let's create the acceptable scenario so if basically the current length is actually going to be maximum * two uh which means that we can actually we have reached to our our answer and we can add it to our answer so this is the legitimate scenario now let's see say for an example we find out that uh uh the we have not reached the answer then what could be the possibility well first possibility could be the number of Open brackets uh that could be less than the number of Maximum brackets that is allowed if that is the case basically for the current uh string Builder we can actually upend an opening bracket so let's do that and uh after adding the opening bracket basically we will have to call the backtrack method again with a reduced value of one Open Bracket so let's do that so in the backtrack method we are going to call the answer and we are also going to call the current uh string Builder list we have but for the open we are actually going to add one value and for the number of closed brackets we are going to keep it as it is the max is also not going to be changed and that is awesome now there is also one more important thing we will have to do every single time we make a backtrack call and that is to delete one character that is located at the current length minus one because it is going to add an extra character so let's do that okay now same way uh say for an example if the number of uh closed brackets and they are less than the number of Open brackets uh if that is the case basically we can also add one close bracket to our self as well so let's do that and we are also going to to call the backtrack method and everything else is going to remain the same and basically this whole logic sums up our backtrack method now all we need to do is from our main method we simply need to create a list of list called answer so let's do that and then we are going to call our backtrack method now inside the backtrack method we are going to provide the value of answer we are also going to provide a new instance of a string Builder Pro going to provide the number of opening brackets that we have used so bar is zero number of closing brackets is also zero and the maximum number of opening and closing bracket we can have is going to be the value of N and after getting the answer from the backtrack method we can simply return the answer to be return the answer that we got and uh basically that's it yeah let's try to run the code okay seems like our solution is working as expected let's try to submit the code if we submit the code our solution beats lot of other Solutions it is really good in terms of time complexity and it is also really efficient in terms of space complexity as well so yeah I'm going to be very satisfied with the approach and uh now I will be posting this solution in the comment so you can check it out from there thank you hello friends hope you're are having a fantastic day today so once again we are going to solve an awesome lead code problem so without any delay let's get started so today we are going to solve daily temperatures lead code problem that is a medium problem and also an extremely well-like lead code problem so the problem statement is quite simple we are given an integer array called temperature that represents the daily temperature over a certain span period now we need to return a new answer from this given temperature array such that any particular item in that particular answers array should Define that how many number of days you have to wait in order to generate a warmer temperature compared to that particular day temperature so let's try to understand this with an example suppose this is the temperatures array we are given now in the input you can see that bunch of different values for every single day's temperature now if we see on this very first day the temperature is 73 which means how many number of days we have to wait in order to get a warmer day well a warmer day is right next which means if we just wait one more day we can actually get a warmer day same way for 74 if we just wait one more day we also get a warmer day because next day's temperature is 75 now at this 75 if we have to find a warmer day then we have to find a day that contains higher temperature than 75 which means this temperature 76 is higher which we can see that that is actually 4 days away so over here we will have to actually wait 4 days in order to get a warmer day same way for this 71 we have to wait 2 Days in order to get a warmer day at position 69 we only have to wait one day to get had a warmer day at 72 once again we will have to wait just one day because next day is 76 which is warmer at the 76 we do not find any particular warmer day subsequently which means we cannot find a warmer day so we are just going to mark this as zero that no warmer day exist in front of the value 76 and last one is 73 so since this is the very last entry we don't know what the upcoming temperatures looks like so we are also going to return zero and this is the answer array that we need to return uh that defines the temp days you have to wait in order to get a warmer day from any particular day okay so first let's try to understand a Brute Force approach to solve this problem the idea is very simple we simply go to a day and then we keep on iterating the array until we find the next day that has higher temperature the moment we find this one we actually find the difference between the index positions and what whatever the difference is we Mark that in the answer so for this first one we can mark first as the answer for the second one once again we are going to repeat the same process we are going to iterate over every single value inside the array till we find a higher value and which we find 2 Days Later same way we are going to keep on repeating the same operation and eventually we would have our entire answer array to be populated now this is the most simplest method but we can inherently see some issues with this approach the number one issue is that at any given position we will actually have to Traverse over maybe the entire rest of the array in order to find the optimal solution what if uh let's assume that this instead of being 50 Maybe This Was 80 and we don't have any particular solution in mind we would have still iterated over the entire array and then once again in order to find the lower temperature for this next element we would still have to iterate over the entire given array maybe this was 82 so in this this case this is an inefficient approach and if we see time complexity for Brute Force approach is going to be biger of n Square in the worst case scenarios so let's try to see if we can improve upon this time and space complexity or not the thing is at this given location at the very first moment we don't know that what is the temperature that is higher than this one because we have only iterated this one element right but what if we are at this element we can at least please predict that how many elements actually has lesser temperature than this and based on that we can immediately update their temperature and we can immediately say that for if we are at let's say value number 75 then at 75 we should be able to tell that 74 is only one day away from uh having its warmer day and same way at 74 we should be able to tell that 73 is actually just one more one day away from having a warmer day same way at 72 we should be able to tell that 69 is only one day away so how can we actually do that for that we will have to find some way to actually iterate the array in One Direction note that what the current temperatures are and based on that we will also have to check that what are the immediate temperatures that are actually smaller than this current temperature or greater than this current temperature so that we can mark their answers in order to do that we will have to use an extra data structure to store the values of all the temperatures for which we have not been able to find the warmer days second thing is for any particular temperature not only we will have to find the warmer day we will also have to find like the immediate warmer day so for this 745 is actually greater than both 74 and 73 but we should not waste our time marking this 73 as having a warmer day as 75 because there is 74 that is more closely associated with 73 which means we have to worry about the immediate before elements so we are traversing in One Direction but the at the very quickly we will have to understand that what was the last item we were at before moving to any particular previous elements so the best data structure in this case is going to be a data structure that contains the property of last and first out and the answer becomes very simple that we are actually going to use a stack to solve this problem now how how we are going to use the stack is actually quite interesting let's first understand couple of properties number one thing is we are using the temperature to compare the difference between any two given values which means we are dealing with the value of this given array but in the answer we need to store that how many number of days are apart between any two entities and that we can find using the index values why because at index value zero we have this value 73 and at index value one we have this value 74 which means 7 uh index value zero is only one day away from finding a warmer day because index value 1 minus index value 0o becomes actually value number one so this is how we are going to find the answer which means in the stack it would make more sense to store the index positions rather than storing the actual values but using the index positions we can very quickly look up inside the array find the answer and then subsequently Traverse the answer so after this long explanation let me walk through the solution that I'm proposing So currently we are at zeroth index the value is 73 currently we don't have any value inside the stack so we are going to add index zero inside the stack okay and now we are at index position number one the value is 74 the very first thing we are going to do is we are going to check that whether the value located at zeroth position which means the value located at temp of zero if that is actually less than the current index positions we are at so if that is less than the temp of one which is correct condition because this one was 73 and this is 74 which means 7 this value can be popped out of the given stack and we can actually Mark the answer for this one by doing the subtraction between the current element minus the index position that we just kicked out from the stack so this is going to be just one where we did simple equation 1 - 0 okay now we are going to put 74 in the stack but we are going to put the index value so now in the stack we have index position number one now once again we are at index position number two so this value is 75 75 is greater than 74 which means we can do 2 Min - 1 and the answer is 1 so we can store that that 74 is one day away from finding a warmer day now we popped out one from the stack now let's add ENT entry number two inside the stack okay now we are at this position 71 So currently 71 is actually smaller than 75 which means we don't for 75 we have not yet found a small a warmer day so we are going to add entry number three inside our stack as well next we are going to be at position number four which is 69 once again 69 is actually uh less than the current Top Value we have inside the index which means we haven't found a warmer day for this top element and we are going to add one more element uh that we haven't found a warmer day for okay now we are at position number 72 so 72 is actually greater than this value the value at index number four so we can actually uh find the answer for index number four so let me just go okay so this is for index number one Zer we have 1 we have for two we don't have for three we don't have but for four we found the value that is 5 - 4 so we can add one as the answer for index number four Once Again One the moment we pop out index number four we should not be pushing index number five yet because we still have to check that whether five is greater than index number three and yes it is once again greater so for index number three we are going to Mark the answer as two and same way for index number two we are also going to Mark the answer as uh so sorry for index number two we are still not able to be able to find the answer because this is 75 and this is 72 so we are going to have index number two still living inside the stack and then we will have index number five now residing in the stack now we are at index number six so this value is 76 76 is actually greater than 72 so in this case we can actually mark down the answer over here as one for this index number five and we can get rid of this index number five now once again this index number two is also smaller than index number six so we need to do the difference 6 minus 2 so we find answer four and we are going to populate answer four over here and then we have an empty stack which means there are no more values we need to check so we are going to add value number six inside the stack and then in the end U next value is value number 7even so 7 is 73 7 three is actually smaller than the current stack value we have so we are also going to add value number seven inside the stack and the moment we reach to the end we are going to fill out all the rest of the elements by zero that there are zero days that we have been able to find the answers for and this is what we can return in the answer so you see how using a stack we actually need to Traverse over just once on the given temperature array and then we have been able to find the answer which means this is a much better approach and this is the optimal solution compared to our Brute Force solution so let's try to see the time and space complexity in this case the time complexity is actually going to be big of n because we are simply iterating over the temperature array once now it could be possible that for some values we might have to go back and find the values that are smaller than that that where we are doing multiple operations inside the stack but that that number is going to be limited because we are being told that we can find out that how many values are there and uh we are only iterating over the values for which we haven't find the answer and uh in terms of space complexity once again in the worst case scenario this is going to be big of n because we are using an additional space additional stack to find the answer so the coding solution is actually quite straightforward first we initialize a number n in order to mark down the length of the given array then we initialize a new answer array of the size n we also initialize our stack that we are going to use now we simply iterate over the given temperatures array using the for Loop we first have a while loop condition that while the given St stack is not empty and the temperature that we are iterating over currently if that is greater than the temperature that is currently present inside the stack then we simply Mark the index value that is currently present at the very first element of the stack that we popped out and then we Mark the answer index by doing the subtraction of I minus the current index position that we have just been able to find by popping the element out of the stack and then uh we simply push down the element inside the stack and in the end our answer array should have all the answers so we can simply return that now let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs pretty fast compared to most of the other Solutions it is also decent in terms of space complexity and once again the solution is available on our GitHub repository the link is in the description so you can check it out from there thank you hello friends hope you are having a fantastic day today so once again we are going to do an awesome lead code problem and trust me this is an awesome lead code problem so without any delay let's get started so now we are going to solve the lead code problem called car f now personally this is one of my favorite problems and we can see that this one is a lead code medium problem and also decently well-like problem the thing is this is a very long description for this problem because it covers lot of edge cases and lot of conditions that you have to understand if you want be my guest and read the whole description if not let me just point out few important topics and then we will try to understand what the problem is asking us to do through an example that would make things much more simpler so first thing is we are being told that there are n cars going in the same destination along one lane road so it's a single Lane Road and we are told that the cars are not going to be overtaking each other this is not fast and furious this is lead code okay then we are also given a Target miles that we need to reach that is the final destination for our cars now we are given two integer arrays first one is position and second one is called speed so position defines that that what is the starting position for any particular given car compared to that Target distance okay and the speed is at what speed that particular car is running on so we are given both the values inside the car now we are being told that cars are not going to overtake each other but if they are close enough we can consider them arriving at the destination at the same time and any car arriving at the destination or set of cars arriving at the destination would be considered as car Fleet and now we need to consider that how many number of different car fleets actually arrive to the destination so I know that this was quite complicated and very extensive description let's try to make it simpler using some example so over here we are given a Target value of 12 that we need to reach and we are given the positions and we are also given the speeds of subsequent cars so here I have actually plotted a graph or a number sequence where this 12 is the Target that every single car is trying to reach now this C1 C2 these represents different cars and we can see that based on their positions inside the subsequent array I have already plotted them on this given line so this defines their starting position and subsequently this portion defines that what is the speed that is given to every single car okay and we are being being told that the distance we are trying to cover is 12 miles and the speeds are given in per hour basis so which means this car C2 actually Travers 4 miles in 1 hour okay so now we need to understand that how we Define car fleets so let's try to understand it one by one so we will try to go over that how every single car is actually going to reach to the Final Destination and we know for sure that no car is going to overtake one other so if one car comes closer to the other car we would consider both of them reaching to the destination at the same time and there would be part of one single Fleet so first let's see So currently this car C1 is located at position number 10 and its given speed is 2 mph we know that this C1 has to be the first car to reach to the destination because it is the closest car to the destination so the in the first hour this car is actually going to reach to the destination and it's going to take 1 hour but during this 1 hour period because how do we come up with this 1 hour because we calculated the distance from the current position to the Final Destination we are trying to reach which is 2 miles and its speed is also 2 miles so we can easy easily calculate the time uh that it takes to reach to the destination now for the C2 also subsequently the C2 would also reach to the destination in just just 1 hour so based on this we can conclude that both of this C1 and C2 are actually going to reach to the destination around the same time around at 1 hour mark which means C1 would be here and C2 would be right very close to it so these two cars are going to reach to the destination in around the same time which means this is going to be one of the fleet that is going to arrive into the destination so now we already took care of one Fleet so let let's just get rid of these okay and also let's try to understand that we have already spent 1 hour so during this 1 hour what would be the position of all of these cars so during 1 hour the C4 would have traveled 1 kilm so C4 would be here same way the C5 would have also Kil con completed 3 kilm because its speed is three so after this 1 hour this c5's position should have been at position number six but at position number six we can clearly see that C4 is already present which means after 1 hour the position is going to look something like this where C4 and C5 are going to be right close to each other now remember that the speed of the C4 is 1 and speed of the C5 is three but because C4 is ahead compared to C5 even though it has higher speed it is not going to overtake it and it is only going to reach to the destination when the C4 arrives but essentially both of these cars are also going to reach to the destination in around the same time and how much time will it take well currently this one is at position number six so it is going to take six more hours and we already spend 1 hours which means the C4 is going to take 7 hours to reach to the destination and because C5 is behind that and it is able to catch up to the C4 it is also going to complete and reach to the destination in 7 hours so after 7 hours the second Fleet that would have reach to the destination would be the cars uh that we just saw that is the car C4 and also C5 so they both will also reach to the destination in around the same time so this would be our second Fleet that is going to reach to the destination and now we already spent 7 hours which means after 7 hours this C3 would have been uh around here because its speed is just 1 m per hour so it would have covered the distance of 7 miles and then still it would have five more miles to go which means it would still take uh like around 12 hours to reach to the destination and in the end the C3 car would be the very final car that would reach to the destination and still this would also be considered a fleet in its own so over here we can see that actually we are getting one two and three fleets reaching to the destination so for this given input we need to return three as the answer and this is the whole problem statement now I know understanding this problem statement take took us lot of time because there were a lot of moving paths and moving cars that we had to understand but honestly this is an awesome lead Cod problem because if any interviewer dares to give you this problem this is not very difficult to solve but it's very uh peculiar for interviewer to explain also you will have to navigate through lot of different edge cases and then think about coming up with the optimal solution so now I'm not even going to be bothered to show you the Brute Force approach because that would be an ins insult to this beautiful problem so let's talk about the actual complete optimal solution that we can use in order to solve this problem and in order to generate the optimal solution we need to make some assumptions and we we need to do some calculations so what are some of the calculations we need to do number one thing that is most important is is that for any particular car we will have to understand that how much time it takes to reach to the end that is number one thing and second thing is cars can only reach to the Target based on the current sequence locations they are present in so even though if we see the car numbers over here this C1 and C2 are based are located at the correct space but the C3 is actually going to even though this is the third car this would this has to be the last car to reach to the end so number one thing we are going to do is we will try to find that how much time does it take for any single car to reach to the end we will try to store this information with the cars so we actually have couple of ways to store this we can either store it using a hashmap uh that would only make things more complicated because we don't need like a constant time access to that data and same thing can be achieved using a two-dimensional array as well so we will try to use it uh store it using twood dimensional array okay so in the two-dimensional array we are going to store the information for a subsequent car and how much time does it take to reach to the end that is number one thing number two thing we are going to do is that we will actually sort these cars based on their positions so number one car in that is going to reach to the destination is going to be the car that is closest to the destination position so based on the position size we are also going to sort them and once we have that we would be able to identify the answer quite easily so now first let's try to understand that how do we actually calculate how much time does it take for any single car to reach to the destination and that is a very simple calculation all we need to do is we need to calculate the distance between the current position and the destination position and whatever this distance is we need to divide the speed by that distance and that would give us the time on uh that it that that particular car would take to reach to the Final Destination okay so now the idea is quite simple so let's just do that so for C1 currently we can see that this is located at position number 10 and it needs to reach to the pos position number 12 which means the distance is 2 and the speed for C1 is also 2 m per hour which means it is going to take 1 hour for C to reach to the destination same way for C2 it is also going to take 1 hour to reach to the destination same way for this C4 it is actually going to take 7 hours to reach to the destination because the difference between 5 and 12 is 7 and the speed of C4 is 1 mph same way for this C5 the dist the distance is also going to be 3 U 9 km uh sorry 9 miles and then the speed is three so it is only going to take 3 hours to reach to the destination and last one is the C3 car so for C3 it's actually going to take 12 hours to reach to the destination now we have our this list ready now let's try to sort this given list based on the position of the cars which means once again C1 is at the correct position and C2 is also at the correct position both times are 1 hour and 1 hour then we have the car C4 and C5 so for the car C4 it is uh it is going to reach into the 7h hour mark and car C5 should reach in 3our marks if there were no cars ahead of it and the last one is the c0 car or uh I think C3 car so C3 car is going to take 12 hours to reach to the destination okay so let's quickly do a re recap what we did we found out how much time does it take to reach to the destination then we sorted all of these cars based on the position where they are compared to the start to the Target location so the higher the position the first it is going to be inside our L list and in order to store this information we are going to be using a 2d array now after having this information it becomes very easy for us to solve this problem because all we need to do is we simply have to check because we know for sure that this has to be the first car to reach to the destination at any given moment we realize that the speed of this is actually less or equal to the speed of its subsequent car then we can conclude that both of these cars would reach to at the same time let me rephrase I use the word speed but the the correct word should have been time so if the time it takes for the C1 car to reach to the destination is 1 hour and we see that for C2 the time it takes is also 1 hour which means C1 and C2 both are going to reach to the destination around around the same time just in the scenario where C2 is just behind C1 so we can conclude that these two has to be one single Fleet so this becomes our one of The Fleets now in the second scenario we have the time it takes for C4 to reach to the to the destination as 7 hours and the time it takes for C5 to reach at the destination at 3 hours which means C5 actually is much faster than C4 So eventually C5 would be close enough or just behind C4 before C4 actually reached to the destination let's try to once again understand using this plot because after the very first hour actually C5 and C4 would both be at the same place and how do we find out because we can see that the time it takes for both of them to reach to the destination so these two also has to be part of a simple Fleet now say this last for the C3 instead of this being 12 maybe this also took 3 hours to reach to the destination then C3 would have also been part of this Fleet because C3 would reach to the Destination 3 in 3 hours C5 would reach in 3 hours and C C4 is going to block both of them and cause both of these cars to reach at 7h hour mark because C4 is ahead compared to C5 and C3 so this would have been part of this Fleet as well but in this scenario because the time C3 takes to reach the destination is actually greater than the previous Fleet the largest value in the previous Fleet then we can conclude that this C3 is not going to be able to catch up to the C4 and C5 Fleet so this is going to be our second Fleet and in the end the C3 is going to be our third Fleet so that's all you need to do to solve this problem once we do have the comp the sorted work version of subsequent cars with the time it takes to reach to the destination we can actually very easily compute because for every single Fleet all we need to check is that what is the longest time it takes uh for those Fleet to reach to the destination so in this case for the C4 and C5 it's going to take 7 hours to reach to the destination so if this number would have been anything less than seven then it would have been part of this uh C4 Fleet but because it's not less than seven so this has to be a fleet on its own and uh that's it that's what we need to do and this is the whole solution so now you see how beautiful this problem is and how awesome the solution is like that's why this is really one of my favorite questions because it's a combination of math and data structures and then how do you make things more efficiently and how can you think about uh different scenarios and different mathematical equations and stuff like that okay so now let's try to understand the time complexity it is going to be bigo of n because we are going to be simply iterating over the given input array bunch of times but still it is going to be big off n but you forgot one critical thing that is we will also have to do the Sorting operation and that is actually going to cause our time complexity to be big of n log n and if we see space complexity well for the space complexity is actually going to be big off n Square because we are using a 2d array to store the information of the cars uh to its subsequent time it takes to reach to the destination overall this is also a very good time and space complexity now let me in the comments if you want also want to see a solution using a monotonic stack because this is pretty popular problem for that so if you want I can also show a solution with that but I think this is a good enough solution for your interview your interviewer is going to be more than happy and now let's just quickly see the coding for this one so the coding solution is quite simple first of all we create an integer n uh to store the length of the given input array and then we initialize our 2D array that we talked about where we are going to store the information about cars and its subsequent time it takes to reach to the end then we are simply going to iterate over the given input array and we are going to populate our cars D 2D array that we just created where we are going to Mark the positions of the car and also we are going to calculate that how much time does any single car takes to reach to the destination then we are going to do the most important operation where we are going to sort the given cars based on the current positions of the given cars once we have that now it is very convenient to solve this problem we are going to initialize a counter zero that this is going to calculate the fleet uh on what time it is going to arrive and then we are going to have another variable where it is going to keep track that what was the previous time for the car to reach to the end then we are simply going to iterate over the given input uh 2D aray cars and we are going to check that if the value of any particular given car is actually greater than the previous time which means that is a new Fleet being created so we are simply going to a create a new Fleet or add the value to the counter and also we are also going to Mark the previous time of the last car that just came in and that's it in the end we can simply return this counter that we have created that was keeping track of all every single Fleet and now let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs decently efficiently in terms of time complexity extremely efficiently in terms of space complexity and once again the code is present inside our GitHub repository so you can go and check it out from there thank you hello friends hope you're having a fantastic day today so once again we are going to do an awesome lead code problem that is extremely popular at all sorts of it companies so without any delay let's get started so the lead code problem we are going to solve today is called largest rectangle in a histogram this is a lead code hard problem and also an extremely well-like problem now the statement is quite simple and straightforward we are given an array of integer called Heights that represent the histograms bar height and we are also told that the width of every single bar is one now we need to return the area of the largest rectangle that we can make inside this given histogram so this is all we need to return and now let's try to understand this with an example so for this we can make a rectangle that looks like this now the area of this rectangle is going to be two because the width of this portion is 1 and the height of this portion is 2 so 2 * 1 is going to be two so same way there are multiple different options we can have in order to generate the area but we need to find the maximum area and in this case the answer would be retrived using these values where if we make a rectangle like this using these two bars so now in this case the area is actually going to be 10 why because the height of this portion is five and for this one the width is 2 so 2 * 5 is going to be 10 so this is what we need to find and this is what we need to return so Brute Force approach is actually quite straightforward and very simple now one thing we can do is that we can take this one single rectangle uh starting at position zero and then we can see that what are every single possible areas we can make so one area would be like this second area would be like this the third area would be something like this uh fourth area would be something like this and so on and so forth and eventually we do all every single possible combination uh based on every single position of the given rectangle bar height and then eventually we would find a solution like this that contains the most optimal approach and this solution would work fine we would be able to eventually find the answer but this is going to work in big of n Square time because at every single time we are doing lot of extra and overhead work so what is the most common thing we can imagine well number one observation we can make is because we can see that the height for this zeroth index is two at the moment but the moment we want to consider this first index as in combination with this two then the maximum height we can imagine is only going to be able to one which means we are only at the higher height until we encounter a height that is lower than our current height and whenever that happens we will have to start considering the lower height and we need to understand couple of things if we want to calculate the area we need two items first item is the height so we already know that which height are we going to consider based on on the lower height compared to all the other possible Heights that is uh number one observation second observation is we need to consider the width so w so width we can simply calculate based on the current index position where we have or we can also keep track of that where did that height started existing that in terms of finding the right side boundary of any particular rectangle we can only find it until we find a lower height that reaches so there are actually three examples we can see very easily first example is at this position number two or this uh initial first position where the current height is two and the current height is located position number zero but the moment we try to consider the next element we will have to get rid of this height too because now it is no longer in the existence which means the maximum area we are being able to generate using this bar two is only going to be two okay now next thing another example is we just saw with the value number five that with value number five we can only say that we can use rectangle five or bar five until we reach to this index position number four and then so which means maximum area that this bar five can make is going to be of width two and height five so total is going to be 10 same way for this six six comes into the existence at index number three but since the height at index number four is actually lesser than the index number three which means this six only remains in existence just for one single bar so the maximum area we can make over here is all is only going to be of size six and this is the whole logic this is the whole meat of the solution now after understanding this we can actually make a suboptimal solution using the same very simple approach and then we will try to improve upon that solution so the sub sub optimal solution that I'm proposing is that at every single position we identify that what its right side boundary is and what its left side left side boundary is so what is the maximum height and width we can make and based on that we can do all sorts of calculations and then find the solutions very quickly so let's try to see this solution in exist in action the idea is at this position the maximum left side height we can make is two the maximum right side height we we can make is also going the maximum width we are able to achieve is one which means the maximum area we can generate is only going to be two for this position number one the maximum width we are able to achieve is going to be six because this one remains in existence throughout this whole process and the maximum height we can achieve is only going to be one so over here maximum area we can make is only going to be six now at this five the maximum left side we can go is only up to 2 because it starts at position two the maximum in terms of right we can go is only up until position four or before position four so up to two and three so width is going to be two so over here we can make the area 10 for this height six we can only make the maximum height as six same way at this position number two the maximum we can make is actually going to be this much where currently the width is going to be uh 4 and the height is going to be two so so maximum area we are able to generate is 8 and same way at this three the maximum we are able to generate is simply going to be uh just just this one because one before that is actually in the Lesser height so we can maximum area we can make using only or or the entire height of this area is going to be three and in the end we can simply return return 10 as the answer so what we did is for every single element we tried to see that what is the left limit what is the right limit and what is the total area we are able to generate and then we can very easily store the answer now this solution would just be good if you provide this solution in an interview it might even work but the thing is there exist a better solution where if we just use stack to keep track that what is the current index position and until what previous index positions we are maintaining that height then we can very easily solve this problem why we need to use the stack because think about it for every single position we are only going to have that position in existence until we find another bar with a lower height which means the moment we find another bar with a lower height we can actually go back to the elements that are already present inside the stack with the higher height and calculate the area that's it that is the whole logic so now let's try to see the solution I'm proposing in action so now let's just quickly initiate our stack now inside the stack we know that this is going to operate in the in terms of last in first out principle and one the other thing is we can actually keep track of the bar Heights but then we would also have to find that what was the initial position of that this particular value so rather than a better approach is that we actually store the index values and using the index values we can quickly look up that what has been the bar height at that position in big go of one time because we already know the index position and then we would be able to also calculate the width depending on the current index position and the existing index position inside the stack so let's try to see the solution in action so initially stack is empty okay and we are also going to have a variable where we are going to store the area so let's just mark this one as Max Max area that we have been able to calculate so far okay so initially stack is now we are at this index position number zero so we add index position zero inside our stack okay and currently we know that this height is two now next thing is we iterate over to the next element and we identify that currently we are at index position one so the height at index position is actually less than the height we currently have on the element that is already present inside the stack which means this position of this element two is no longer relevant because we found out a value that is lesser inside the in in its existence which means this only exist until this portion so we will try to we will pop this element out and we will calculate the possible area that is that this element has been able to generate So currently for this first position this has been the area it is able to generate that area is going to be two that is the height and multiplied by width that is one so the maximum area we have so far is two okay now once again uh we are going to add value number one inside our stack saying that currently one so the the height of this one is also one and currently we we will only pop one out when we either reach to the end of the array or so or end of the Heights or we find some place where the height is actually zero and then we have some more elements okay so this is always going to be relevant in this example now we are at index position number two so notice what happened at index position number two the height suddenly increased compared to what the height we already have which means this one is still valid so because it is still valid we are going to keep it inside the stack not popping it out and we will add one more element five or the this index position two on top of the stack because now this is also relevant so far so we are going to put two inside the stack so its subsequent value is bar height five then we are next we identify height six which means this five is still relevant so because five is relevant we are once again going to add value number six on top of the stack or soorry not value number six but the index position of six which is value number three so we put value number three inside on top of the stack and the height is six now we suddenly encounter the value uh at index position number four that is height two so any single value that has greater than two height has to be popped out of the stack because now that is no longer relevant which means first of all this six is now no longer going to be relevant because the height is six and currently this index position is three and notice that the index position for this bar height two is four which means depending on the index position difference we can actually calculate the width for which this six was relevant so six was currently relevant for width one so currently let's pop six out if we pop six out currently this three is no longer present we know that this was relevant for one width which means width was one and the height was six so now the maximum rectangle we have been able to find is of size six which is greater than the previous maximum we had so we are going to update that okay now are we done no because this is two and this value is five which means we would still have to pop one value out if we pop one value out in this case now notice that the height at this position is two and the height at this position is four so because this is a greater position compared to over here so what is the width we found the width is actually two and what is the height we have is five so this is the height and also let's get rid of this two from our existing SE okay and now this area is going to become 10 so let's just add an area 10 now once again uh we this we have this element one and currently this element is two so 2 is greater than 1 so because 2 is greater than 1 we are not going to pop one out because this one is still relevant so we are just going to Simply add two on top of one so let's just quickly add this index position number four with the height two okay and now currently next one we found the increase inside the height which means this two is still relevant because this two is relevant we are simply going to add an element five on top so we are going to add element five on top now adding index position number five now we reach to the end of the array which means the moment we reach to the end of the array we will have to start popping every single value out compared to its current position so currently we pop value number five out which means what is the height over here the height is three what would what would be the width width would only be one because it is only relevant for this one portion because currently we are at the end of our Loop so the area we have been able to calculate by popping this uh value number three out is going to be three now currently three is less than uh value 10 which is the maximum area we have so we are not going to update the maximum area okay now we are going to next uh pop out element number four so if we pop element number 4 out it has been relevant for this much portion of the time which means currently we have 2 multiplied by 2 so the area is going to be 4 4 is also less than 10 which means this area is also not relevant and last one we will have to pop element number one out that has the size one or the height one so for this height is going to be one and this has been relevant since position one until the very last position so this has been relevant for the width five oh sorry for the width six since the very first position it has been relevant so now because this has been relevant since uh position six so the maximum area we have been able to generate is also going to be six but still it is not greater than the maximum area are so after the end of this Loop we can simply return the max area to be 10 and that's it that's the whole answer now if we see time and space complexity in this case the time complexity is going to be bigger of N and the space complexity is also going to be bigger of n so the coding solution is actually quite straightforward first we have a variable called Max area where we are going to be storing the maximum area we have been able to identify so far then we have our stack that we initialize and we also have VAR n the for the to store the length of the given array then we have our for Loop to iterate over the given array now first we check for a condition that if the if the given I is equal to n which means we have already crossed or every single element then we can mark the current height as zero because this is to take care of the last element if that is not the case we simply take the value of the given subsequent height height from the heights array okay now we have have our while loop where we check that while the given stack is not empty and the current height that we have been able to identify for any given I element is less than the current height that is already present inside the very first element of the stack then we will have to calculate the area for that uh where we simply calculate the height based on by popping the element out of the stack and then we calculate the width by uh subtracting the value of the current I minus the current element that is that was present inside the stack minus one and then we calculate the max area where we compare two elements based on the given Max area that we have been able to identify so far and the given current height and width multiplication or the current area that we have been able to identify whichever is greater we are going to keep it that and in the end after we run out of this while loop we are still going to put push the current element inside our stack and by the time we are done with all the elements we should have our maximum area being populated with the correct value and then we can simply return that so now let's try to run this code okay seems like our solution is working as expected let's submit this code and once again our solution runs beautifully extremely fast in terms of time and space complexity so once once again the solution is present in the GitHub repository the link is in the description so you can check it out from there thank you hello friends hope you're having a fantastic day today so now we are going to do an awesome lead code problem that is extremely popular and you are guaranteed to encounter this question in one of your interviews so without any delay let's get started so the lead code problem we are going to solve today is called binary search and we can see that this is a lead code easy problem and Al one of the most like problems on read code now the thing is you are always going to be using binary search in your interviews but this is not going never going to be the direct question because this is a technique that you have to master so let's understand that what the problem statement is asking us to solve we are given an integer array nums which is sorted in ascending order which is great and we are also given a Target value that we need to find that whether it's present inside the given array or not if it is present then we need to return the index position of the target if it is not present we need to return minus one and we are also being told that we must write this algorithm in B go of logarithmic and time complexity so let's try to understand what is being asked us to solve suppose we are given an input array like this we are given the target value to be 9 so in this case we can see that N9 is currently present inside this given array and it is located on index value number four so in this case we need to return four as the answer because 9 is present now same in the same problem suppose we are given that uh 10 so 10 is currently not present inside the array so then we need to return minus one so this is what the problem is asking us to solve it is very simple to understand so Brute Force approach is quite straightforward suppose we are given the values uh like this and we are being told that we need to find Value number four inside this given array so all we need to do is we can simply start iterating over this given array one by one and keep on going until we find the value of we reach to the end of the array so in this case since we did find Value number four we can return the index position of this value and we can see that Brute Force approach works as expected but thing is if we see time complexity for this Brute Force approach this is simply going to be big go of n uh and we need to do things smartly and for that we need to take care of the property that is currently given to us uh in this array that this given array is actually sorted so if we use the sorted portion property of this given array we can actually solve this problem in logarithmic time so let's quickly see the optimal solution so we can see that N9 is currently present inside this array now how we are going to use the log the sorted property of this is by doing binary search so what binary search means is that we are going to take this entire array as whole we are going to find the middle pointer of this array and using the middle po pointer we will compare that whether this middle pointer is smaller than our Target array or is it greater than our Target array if this middle pointer is smaller than our Target array which means the target array has to reside on this portion of the given input array so we can basically eliminate all of these three characters because they are no longer relevant and if it is the other case then we in that case we can eliminate these three characters as well so we will keep on doing that until we either reach the target value or we run out of the values to search for and uh in this case we are going to initialize our array with having a starting pointer and ending pointer So currently starting and ending are going to live at the edges and this is going to allow us to find the middle pointer so in this case we can see that the target value is N9 the middle pointer we are able to identify is located at Value number six so we need to check that whether this value number six if that is greater than or less than so we can see that six is less than our Target value so because 6 is less than our Target value we can say for certainty that the target value can never reside on the left hand side of our uh given value six which means we will have to migrate our start pointer once again back to six and repeat the same operation so now our starting pointer is going to live over here ending pointer is still going to live on the same place and now we are trying to find the middle pointer okay so we in just one single iteration we eliminated three characters and this this is the pure definition of logarithmic time complexity so once again for this uh we are going to find the middle pointer and middle pointer is going to be uh find at Value number 11 so now the next middle pointer is value number 11 11 is actually greater than Target value which means that the target value can never reside on the right side of the this 11 so we can eliminate this character and now we only have these three values 6 9 and 11 and we are going to Mark 11 as our ending pointer so now once again we repeat the same operation and try to find the middle value the middle value is N9 in this case and 9 is actually equal to Target which means the index location of this nine uh I think it's four so this this is what we can return in the answer and you see that we were originally given seven different elements but within just three iteration we were able to find that where does the middle point where does our Target value is present inside the aray or not if it was not present let's assume that maybe this was value number 10 so we realize that we find the middle pointer and now uh this is also not uh the target value we are looking for so now we are going to starting pointer and ending pointer living next to each other and once again if we try to find the middle pointer we would not be able to find it so we could we could have concluded that now the target value is not present so in both the ways using binary search is extremely efficient you are going to be seeing the B inary search in lot of different problems uh across your entire technical interview journey and also across lot of lead code problems so you must Master this technique if we see time complexity in this case the time complexity is going to be big of log n because that's what we just did and space complexity well we did not use any extra data structure or any extra space apart from storing couple of variables so this is going to be a constant space complexity as well now let's quickly see the coding solution for this one okay so very first thing we are going to do is initialize couple of variables first one is the left pointer and second one is the right pointer then we are going to run a loop that while left is less than or equal to right we are first of all going to calculate the middle middle pointer that is going to be the sum of left plus right divided by two and then we are going to check the conditions that if the given middle pointer is equal to the Target value then whatever the index position is we can simply return that if that is not the case and we find out that the given middle pointer is smaller than the target then we need to update our left pointer to come to the middle pointer if that is not the case then we need to update the right pointer and that's it basically in the end uh we should have refined the Target in this Loop if the value is present if it is not present we can simply return minus one so let's try to run this code okay seems like our solution is working as as expected let's submit this code and our code runs 100% faster than all the other solutions that is because our code actually runs in constant time or the number of test cases are very small so that's why and once again the solution of this code is actually pasted in our uh repository GitHub repository so let me quickly show you that where all of the solutions are present you can see on this GitHub repository we have over hundreds of different lead code Solutions these are the most popular most ask and most important lead code questions and if you're preparing for your technical interviews for sure this can be a great resource for every single one of you so you can go ahead and check it out uh also I want to show you one more extra resource that is uh this sheet that I have created so we you can see that over here I have a couple of list first list is 130 most popular and most like technical interview questions of all time over here all of these questions are separated based on topic and I have also included that how many times these questions were asked at any particular company and what is their difficulty level is it easy medium or hard and for every most of the questions you can see that there are solutions available as well so if you want you can go and check it out on top of it need code 150 is one of the most best resources for technical interview preparation so I also started working on solving need code 150 so I can get better at lead code and also I can create videos that might help other people as well so over here once again these are all the questions separated based on the topic and difficulty level majority of them are solved and the rest would be solved soon so you can go and check it out so uh the both the links are in the description I hope you find this resource helpful Hello friends hope you're having a fantastic day today so now we are going to do an awesome lead code problem so without any delay let's get started so the lead code problem we are going to solve today is called search in a 2d Matrix now we can see that this one is a lead code medium problem and also an extremely well-like problem on lead code also really popular among stop tier it companies basically we are given an M cross n integer Matrix and we are told that it contains two important properties first property is that each row is sorted in non decreasing order and next thing is that the first integer of each row is greater than the last inte of previous row which means even the columns are also going to be sorted in an increasing order now we are given an integer Target and we need to return true if the target exist inside this given Matrix and false if it is not present inside the Matrix also we are told to solve this problem in we go of logarithmic M cross n time complexity so now let's try to understand this with an example suppose this is an M cross n Matrix we are given where m is equal to 3 and N is equal to 4 and we are told told that Target value is three so now let's first quickly assess the properties we can see that every single row is in sorted order and we are also being told that the last element of any particular row is smaller than the next element inside this uh next row and so that eventually makes the columns sorted as well okay and we can see that in this case this three is clearly present inside this given M cross in Matrix so we need to return true that saying that the three is present but but if we are being asked the target to be like something like 37 then that is not present so we need to return false okay so let's try to quickly see that what are the different approaches we can take to solve this problem for The Brute Force solution we don't need to do anything since this is an M cross and Matrix all we can do is just simply iterate over the given Matrix one by one in a normal sequence which which can be done using two loops and then try to see if the target value is present or not if the target value is present return the true immediately and if we don't find and we reach to the end of this given uh list or given Matrix and we don't find the target value then we need to return false this Brute Force solution would work as expected but the thing is the time complexity is going to be bigger of M cross n because we are iterating over all of these 12 characters that are present inside the Matrix so we need to speed things up number one thing I'm suggesting is that we know the target value we are trying to find is three we also know that the entire rows are for sure sorted we also know that all of the columns are also sorted so one approach we can take is that we compare the columns and based on the column values we check that under which row should this target value be presented so so we can clearly see that when we compare the first element in this column versus the first element sorry first element in this Row versus the first element in this row we can see that the target value three lies somewhere between column 1 and uh sorry Row one and row two which means if the target value is present it has to be present inside this first row so once we find that information after that all we need to do is just simply do a binary search in this operation so now we only have one row that we need to worry about so now we can actually solve this problem using a simple binary search where all we have is a starting pointer and ending pointer the target value we are given is three so we first try to find the middle pointer middle pointer in this case is going to be five so this is not the target value and the target value is less than the middle pointer we find which means Target value has to reside somewhere over here so once again we repeat the same operation we update our end pointer and then once again we do the binary search we find the middle pointer and then we simply return saying that yes true the given Target value is present inside the given list so let's try to see that uh what is going to be the time complexity in this case so time complexity would be inside the given corresponding row we will have to do an log n cross M work so this solution would give us the desired result but the thing is we are doing an intermediary step in between to solve this problem so let's try to see that do we have a more optimal solution than this one as well and yes we actually have a better optimal solution the idea is we already know that every single rows are sorted we also know that every single columns are sorted which means the last value of any row is always going to be less than the first value of the subsequent row so logically instead of treating this as a 2d Matrix if we just try to understand this in a onedimensional direction we can actually see that this is a perfect example of completely sorted one 1D array that is currently represented inside the 2D environment and we can plot all of these 12 values inside this given graph this is just a one dimensional representation of this 2D array and we can see that this is a fully sorted array now if we have to find the target value let's say three in this case the solution becomes quite obvious all we need to do is just a normal binary search and we can we should be able to find the result but thing is we don't want to create an additional array we wants to do the binary search treating as if this 2D array was 1D array in this one so once again we can also do that for that all we need to do is just we might have to play around with the starting and ending pointers so initially our starting pointer is going to Res reside over here and our ending pointer is going to reside over here we will need to find the middle pointer so now if we have to find the mid pointer the 16 is going to be the midp pointer so compare 16 with our Target value and we can see that the uh Target value is actually smaller then the midp pointer we find which means we will have to update our end pointer to come one value before the midp pointer because this is also not the target value so once again now we have our new starting pointer uh starting pointer is the same and we have our new ending pointer once again we are going to find the mid value mid value in this case would be value number five once again we can see that because this value number five is greater so once again we are going to update our endp pointer so endp pointer is going to be over here start pointer is going to be over here once again we do the binary search and we should be able to find the target value to be value number three and that's it this is what we need to do and this is the much better approach then root Force approach and also a step Improvement on our better approach that we saw time time complexity for sure it is going to be bigo of log n m cross n and we are not using any extra space so space complexity is going to be constant space which means this is a really good approach and now let's quickly see the coding solution for this one so first of all we are going to Define our M and N based on the given Matrix value we are also going to initialize two variables left pointer and right pointer left pointer is going to be at the very first position inside the given Matrix right pointer is going to be on the very last position of the given Matrix then we are going to run over while loop during the while loop first thing we are going to do is to find our midp pointer after finding the midp pointer we will also have to point that mid value inside our given Matrix because remember the midp pointer is a single 1D value meanwhile the uh we are given the 2D Matrix so that we can do by doing the division of midp pointer with the value 9 and and doing the modulo or with nine or finding the remainder value so this is going to give us the exact value of the mid what the midp pointer should be uh in a 2d array and then we simply do our binary search and based on that we update and manipulate the uh left pointer and right pointer values and in the end if we do find the target value it should have been returned through here if it is not present then we can simply return false so let's try to to run this code okay seems like our solution is working as expected let's submit this code and our code runs 100% faster than all the other Solutions which is pretty awesome this is also an excellent use of space complexity as well so once again the solution is present in the GitHub repository that we have created and the link is in the description you should be able to find it from there Hello friends hope you are having a fantastic day today so once again we are going to do an awesome lead code problem that has been asked at tons of companies and it's actually a pretty fun question to solve so without any delay let's get started the problem is called Coco eating bananas this one is a lead code medium problem and also a very well-like problem on lead code basically we are being told that Coco loves to eat bananas now Coco is a very famous gorilla and we are given two items we they are given a piles array where which contains that every single element in in this array represents the number of bananas that that particular pile has and we are told that there are guards who are typically protecting the bananas but they have gone out for H hours so we are given two these two items as an input now Koko decides to eat her bananas per hour eating speed of K and each hour she chooses some pile of banana and then she eats K bananas so whatever the speed we decide she tries to eat that if the pile has less than K bananas then she eats all of them and will not eat any more bananas during this hour and the most important thing is we need to return minimum integer K such as she completes all the bananas within each hour and we need to make sure that this K is the smallest element possible because Coco likes to eat slowly so let's try to understand this problem with an example so over here we are given piles this represents that pile one has 30 different bananas next one has 11 and next one has 23 and so on and so forth and we are being told that the guards have gone for 6 hours okay so now we need to figure out that in this 6 hours what should be the speed of banana eating for Coco in order to complete every single banana in each of the pile and also at the same time make sure that she tries to eat in the slowest speed possible now one important detail is that at any given moment M Koko can only eat bananas from only one of these piles she cannot jump around between the piles from hour to hour so let's say that currently we have the speed of banana eating at 50 per hour then let's assume that in the first hour she decides to eat 30 Bananas which means she still has time to eat 20 more bananas but she would not go to the next pile to start eating them she will only eat 30 and then wait for 1 hour and during the next hour she she will go to the next file and once again start eating bananas but once again she still has room to eat 39 more bananas but she would not move to the next element okay so maximum hours we have is six that is number one thing now let's see that what are the some of the options that we can consider for for assumption we take the largest number in this pile that is 30 and we say that Coco eats 30 Bananas per hour so then in how many hours will she complete eating all the bananas so during the first hour she would complete this pile then during the second hour she would complete this pile and so on and so forth in every single hour she will complete each of the piles and then uh she would have still completed her banana eating in 5 hours so less than six but the thing is question is can we go smaller than 30 that is also a question we need to find the minimum number so let's say that in we try the second smallest element that is 23 per hour then how many hours will it take for Coco to complete all the all the bananas so if we do 23 hours so K is equal to 23 then logically in the first hour she will complete 23 bananas so she would still have seven more bananas left in this pile to complete so during the second hour she will also complete seven more bananas then during the third hour she will complete 11 bananas then during fourth hour she will complete 24 then fifth then four and then sixth hour she would complete these 20 bananas and then by the time of 6 hours she would have completed all all the bananas in every single pile and her speed would be 23 which is significantly less than the previous speed that we were considering that was 30 let's try to consider one more speed okay let's say that uh instead of 23 can we go smaller than 23 so let's try 22 okay so if we try to do 22 then this pile would take 2 hours this pile would take 1 hour this pile would once can take 2 hours and then these two piles would also take one one hour so if we do total sum of this this actually becomes seven so that is greater than six which means speed 22 is no longer feasible for Coco to eat bananas so minimum speed she can use in order to complete all the bananas and at the slow slowest speed possible would be 23 and this is what the problem is actually asking us to solve well brood food approach is actually quite simple because we know for sure that uh the maximum value has to be the maximum value that is currently present inside the given piles because we are being told that the inputs are valid and legitimate which means that if she eats the speed at the maximum number of bananas that are present inside the all the piles then by that limit she should be able to complete every single one of them but that is not going to be the ideal scenario maybe it might would have it might have been ideal If instead of over here instead of this H being eight we only had 4 hours to finish then we have to eat at the speed of 11 but that is not the case so what is the minimum range okay so maximum range that Coco needs to eat bananas is going to be the maximum value so 11 the minimum range can be value number one okay that let's say that in this case we actually have uh Su of all of these values we have 28 hours if we have 28 hours then then if she eats one banana per hour then also she can complete this entire pile but that is not that is also not the case so we find our maximum and minimum ranges so logically what we can do is we can simply take every single range and then try to go over to see that if that range satisfies the property of uh completing the banana eating and then we can come up with the answer so we already know the logic let's say that with one we can complete it would take us 28 hours to eat all the bananas but 28 is greater than eight which means one would not work so we try to do it with two if we have to do it with two once again it's going to take let's say 15 so it's going to take 15 hours but this is also greater than 8 so two is also not going to work so so on and so forth if we repeat the same process we would find the answer for in this case uh that this is the number of banana she needs to eat in order to complete the entire pile so logically this solution works as expected okay that is number one thing uh Brute Force approach but the thing is the time complexity in this case would be bigo of n where n is uh n is the number of the sum of all the bananas that are currently present inside the combination of all the loops but we will try to do things slightly faster so let's try to see that what would be the optimal approach in this case now for this given example I have a actually calculated the speeds from 1 to 11 uh for every single hour the banana eating speed and I have marked that at that particular speed how many hours will it take for Coco to complete eating all the bananas and the important thing in this case is we need a value where we reach value number eight at the very first time the moment we hit very first time that is the minimum speed Koko should eat bananas at in order to complete all the banan within the given hours for which guards are away for so logically we can make one very important distinction over here that with increase in the value of K we can see that the our value of H reduces significantly in sorted and descending order which means we can see that there is a descending property over here that is being maintained now the question is we need to find the minimum value but the lucky thing for us is that we actually can use the the benefit of this property of uh this value being sorted to our advantage what we can do is instead of using the Brute Force approach where we were starting from K is equal to 1 and then just going in the linear fashion for every single bananas until we hit value number eight we can actually use binary search in this case in order to complete this problem now let me show you that how doing binary Sear would be the greatest things in slice bread in this approach because we we have our minimum range we have our maximum range which means we can we know for sure that our answer has to lie somewhere between this because any value above 11 will always yield us the result as four we can go even with a speed of 50 and still it is always going to give us the result as four which means the important thing is that once we have our left and right pointer or the minimum and maximum values so let's mark them so currently we have our left pointer and we have our right pointer located at these two positions our aim is to find the minimum value in this K that represents that H becomes 8 for the first time and the logic is quite simple we we take L and R we we try to find the midp pointer so we check that for this particular one what is going to be the midp pointer I think midp pointer is going to be this value number six so for Value number six what is the total number of hours that we can use in order to generate the answer so we can see that this value is six six is actually less than value number eight which means this is one of the legitimate scenarios but the question is is this the minimum value we can reach 8 no because we will need to find the value that equals to 8 at the very first moment so then once again now we are going to bring our right pointer One Step before this one and we will have a right pointer on this location once again we will try to do the mid mid operation so now if we do the mid operation we realize that mid pointer is actually this one so this is actually hours is equal to 10 which is greater than the target hour we had that was value number eight which means we will have to increase the speed in this case so since we have to increase the speed we will have to update our left pointer so we will update our left pointer to come over here now we have two values left and right located adjacent to each other but we will try to find the midp pointer in this case so in this case if we try to take the advantage of the ceiling value we will find midp pointer to be value number four okay and then uh this refers to Value number eight which means this is exactly what we are trying to find but thing is we are not sure if this is the smallest value or not so for that what we can do is we can simply check one value adjacent to it before it to see that if that that value is actually greater than or less than value number eight if that is less than 8 which which means we might have missed some values where eight started forming which we did not so in this case we know for sure that this has to be the smallest value of banana eating speed that we can use in order to finish all the bananas within the given 8 hours now we all know that how to calculate hours for any single pile for that we simply have to iterate over the given array see that what are all the bananas are and at that speed how many bananas can be completed in that particular aisle so that for that calculation we can simply use a helper method to complete that and basically this would yield us the complete result in order for us to find the answer so now this is a beautiful solution for an awesome problem and uh it contains one of our very near and dear uh species so that's that's always pretty good so now let's try to find the time and space complexity in this case time complexity is quite simple it's going to be big go of log n in order to complete the binary search and if we will also have to do some computation in order to find that how much time it takes to eat all the bananas so let's say that that becomes bigger of H but thing is that calculation is always going to be finite why finite because we uh we know that the number of given input size n is going to be finite and we will have to iterate over all the elements in order to calculate that so that operation in itself is going to be biger of n so in this case uh you the total time complexity is going to going to be big go of n log n because for every single pair that we can make up until this log and time or the to till that optimal period we will have to find that how many hours it takes to calculate the results which is going to be much faster than our Brute Force approach because in brute in The Brute Force approach we anyways we had to do this big of n work but we had to do it for every single possible value of K so we were actually getting big of n Square result and if we see space complexity well in this case I just draw this additional uh data structure for your understanding but actually apart from storing few variables here and there we don't have have to use any extra space so this is also going to be big go one so this is a beautiful time and space complexity to solve this problem now let's see the coding solution for this one so here is the solution so first we so first we are going to initialize two variables left and right now for the right pointer we will have to find the maximum value inside the inside our given piles so we are going to do that with using a for Loop then we are going to run our binary search Logic where we are going to check that while is while left is less than right we are going to find a midp pointer and then we are going to call our helper method to check that whether we can finish finding uh the given piles using the given midp pointer or or the speed that we have been able to find with the given H hours in the input now let's understand the logic for the can finish helper method first we are going to mark that the initial hours are going to be zero and then we are going to compare that in order to complete this piles how many hours it's going to take so we are going to check that if the number of speed is going to be greater than any particular pile then we can finish it in 1 hour if not then we need to increase the hour if the number of hour are less than or equal to the given value H we can determine that that speed can actually finish all the bananas then we need to check that whether the right pointer is equal to Mid if that is not the case we need to find that left pointer is going to be mid + one and in the end whichever is the left pointer has to be the answer so this solution would work as expected and now let's try to run this code okay seems like our solution is working awesome let's submit this code code and our code runs pretty fast compared to a lot of other Solutions in terms of time complexity it is really good in terms of space complexity as well so once again the solution for this code is presented in our GitHub repository so you can check it out from there thank you today we are going to do find minimum in a rotated sorted array and if we see some of the companies where I want to get a job who already asked this question there are companies like Microsoft Amazon Uber Facebook Apple Bloomberg Google and Tik Tok so that's why I'm paying my atmost attention I hope you also enjoy the video so this is a lead code medium problem and basically we need to find the minimum inside a rotated sorted array now you will ask that what does a rotated sorted array means we are actually given some definition of what a rotated sorted array is if you want you can iterate over this definition but thing is let me quickly show it to you by an example basically we are originally given a sorted array now for this sorted array if we take the rightmost element and put it on the leftmost position and all the other subsequent elements we flip it one side on the right side we can determine this to be rotated one time so if I take this original sorted array and if I rotate one time so one time rotated array is going to look like this you can see that this five that was originally at the rightmost position has been flipped to the leftmost position and all the other values we put shifted them one position on the right now if I rotate this one more time So eventually I would I would have rotated this array to two times basically the result I would get is going to look like this that where the first two values are four and five and then we have 1 2 and three now over here this four that was originally over here that came to this place now we can rotate it like three times four times as many times as we want like we can only rotate it up until five five times because there are only five elements now uh basically in any rotated array we need to find that what is the minimum value that is present in it so if we try to understand this with an example over here we are given some array uh where the original version of array was 1 2 3 45 that got rotated three times and we were given this as the input now if we see the minimum value in this case is one so we need to return one as the answer we are also given one key important detail that we have to find that we must try an algorithm that runs in bigo of log and time so that is the key part first let's see that what is going to be the Brute Force approach to solve this problem well the Brute Force approach that comes to our mind is that why don't we start iterating over the given array we have a variable called Min or answer or whatever you want to call it and then uh we start iterating over all the subsequent elements one at a time and whenever we find a lower value basically we update that in the Min variable So eventually when we start iterating when we would have completed iteration we would find the value one to be the lowest value that we can find inside this array and that we are going to return return as the answer this solution leads us to the correct answer there are no issues with this one but why this brute brute force solution does not work in your interviewer interviewer or anywhere else is because this solution actually happens in big go of end time because we are iterating over all the N elements and we were explicitly told that we need to solve this problem in big go of log and time so that's why this this Brute Force solution won't work now whenever we see log and solution immediate thing that comes to our mind is that we are going to use binary search right and that is true that we are going to use binary search in this case but before we do that let's make some logic clear well the key part of the logic we have is that if we compare the left and right element for any given array if the array is completely sorted which is the case in over here that the entire array has has been completely sorted there are no mismatching pairs right so because this array is completely sorted if we compare the leftmost element and rightmost element or any element with its left element uh basically we would find that the value at the left element is always less than whatever value at the right element we have like if we compare these three variables and if we compare the right variable to B over here basically again in this case the right is three and left is one so we can conclude that this whole portion is sorted if we have the right variable located at this position uh basically we we have the value of left to be one and right to be five again left is less than one so we can conclude that this whole portion is actually sorted so the lowest value that we can achieve in this whole portion between this left and right is going to be whatever value that is located at the leftmost position now whenever we compare the left value and right value and we determine that left is actually greater than right if we find that left left is actually greater than right we can determine that the minimum value exists somewhere between left and right we don't know that at what position minimum value exist but thing is we need to achieve to the direction where we can actually find left is less than right because remember over here currently the value of left is three and value of right is two so in this case left is actually greater than two whenever we have to find the minimum value we will have to move in a Direction Where We will reach to conclusion where left is less than right and in order to achieve that what we are going to do is we are going to compare the value of the left to the middle pointer that exist and depending on the value of the middle pointer we would determine that the minimum value if does it exist on the left side of the middle pointer or on the right side of the middle pointer and depending on that we will update our value of left pointer or right pointer so let me show you with a broader example what I'm trying to say so I have drawn a big example over here and first let's uh assign our initial values of left and right right so we have the values of left and right set up for us now we know that we need to reach to a position where left is less than right if that is the case then we will have some interesting results right but currently if we see the value of left is two and value of right is one so left is actually greater than one so now we will have to move in some Direction so now what we are going to do is we are going to find the mid value and also remember we are going to have an answer variable that is going to store the lowest value we have been able to find So Far So currently the value of left is two value of right is 1 right so we are not going to do anything in the answer yet now we are going to find the middle pointer so the current middle pointer is going to be at position number four why because left position is 0er right position is 8 so 0 + 8 is equal to 8 divided 2 that gives us the middle value and middle value in this case is going to be the four right so the value that is located at the fourth position is six now we need to compare the values between left and mid left and mid if we compare left is two and mid is six so 2 is less than six now remember whenever we identify that the left value is less than whatever the value we compared we can dictate that every value in between is actually greater than the value of the left which means that no value amongst these values can be the answer or can be the minimum value because remember we already know that on the right hand side the value is actually less than left and because of that we will have to update our migration on the right side and also remember whenever we compare the value of left value with the mid value whatever the lower value is we are going to store it so currently the lowest value we have been able to find is two so we are going to store two as the answer right now we are going to switch our left pointer to go on the right side of the mid so now let me clean this up a bit bit so now this is going to be our new left pointer and this is going to be our new right pointer again we are going to compare the value of left and right so left is actually greater than right right so now we will have to find the midp pointer midp pointer in this case is going to be left plus right divided by two so current value of left is five right is 8 so 13 divided by 2 if we put it uh floor value we will get the value of six so six is going to be the middle pointer in this case so now we have the six to be the middle pointer now we are going to compare left with the middle pointer and now in this case left is actually less than middle pointer which means that answer cannot lie between left and middle pointer and again we will have to update the value of the left pointer also for this leftmost value we will compare that whether we need to update the answer or not so answer currently we had was two and this is seven so we don't need to update the answer and we are good up until this point okay now again we determine that this value is not the answer now our left pointer comes at this position our right pointer comes at this position again we are going to compare the values of of left and right so currently left is actually less than right and that is the ideal scenario that we found that left is Les actually less than right which means that now left is at the correct position to be the lowest position that it can be uh before it iterates or it takes override and now because of this one uh we are going to update uh we are going to see that whether we need to update our answer or not so current answer we had was two and because left was less than right we are going to compare the left value with this answer value and uh the left value is actually zero so we are going to update the answer to be zero and in this case this is the correct answer that we are able to find and we are going to return that uh let's try to understand the same thing with another example so in this case left is over here right is over here currently uh left is actually greater than right so because of that we will have to find the middle value so middle value is going to be this one so now if we see currently the left is actually greater than middle value as well which means we cannot determine that the left and middle portion is actually completely sorted we can only determine that the middle and right portion is completely sorted so in this case we are actually going to update the value of the right pointer and we are going to determine that these are all the values that are not part of the answer so we can just simply ignore them and we will not do anything for these values so now currently our right pointer comes over here now because of that we are again going to repeat the same process then we will try to find the middle value middle value in this case is going to be eight right so we are going to compare left with the middle value so left with the middle value if we compare left is actually less than the middle value if that is the case we can determine that no value over here is the m minimum value so we can simply ignore that and now our left value becomes this one our right value becomes this one and now if we compare left is actually less than right left is less than right that is the ideal scenario that we were looking for which means that now left is at the correct position where the value is actually minimum and in the answer we are going to denote the value to be zero and that is going to be the answer we are going to return now if we see time complexity in this case the time complexity is actually going to be big go of log n because remember during any single iteration we actually removed the half of the candidates that we are we were trying to search for and that is why we are actually using binary search in this program to solve this problem and that is the logic we are going to use uh and now let's move on to the coding so first of all we are going to initialize three variables left right and answer now we are going to test for an edge case that if the nums array only has one element basically we can return return that as the answer okay if that is not the case we are going to run our while loop that while left is less than or equal to right first we are going to check that if the current left and right position makes the array completely sorted or not and that can only happen if the value at number of left is actually less than whatever the value of nums at right we have and if that is the case we are going to see that whether we need to update our answer or not if that is not the case we will have to calculate the middle pointer so first we are going to initialize a value called mid and we are going to calculate the middle pointer after calculating the mid pointer we are again going to check that whether we need to update our answer or not now we are going to see that which way on the midp pointer do we need to take the jump so if uh we if we find out that the current value of left is actually less than or equal to Mid value then then we will have to update the value of left pointer to the right side of the mid and if that is not the case which means we will have to update our right pointer basically that's all we have to do for our binary search operation after this Loop ends we can simply return whatever we have stored in the answer and now let's try to run this code okay seems like our solution is working as expected let's submit this code and our code is actually pretty fast compared to a lot of other Solutions and I will be actually posting the solution in the comments so you can check it out from there today we are going to do search in a rotated sorted array and if you see some of the companies where I want to get a job who have already asked this question there are companies like Amazon Microsoft Facebook LinkedIn Bloomberg Apple TiK ToK by Dan Google Goldman sex Uber and eBay so that's why I'm paying my at most attention I hope you also enjoy the video this is a lead code medium problem and also a very well-like problem on lead code basically we are trying to search an element inside a rotated sorted array now if you notice this is very similar to one of the previous videos we Sol recently and you can check it out that over here now uh we are basically given an array called nums and we are also given a Target value and we need to check that whether this target value exist inside this nums array or not if it does we need to return the index of that Target value now the special part about this question is that the the nums array we are given is actually a sorted array that has been rotated certain times so it sounds confusing at first that what does a rotated sorted array means so you can either read this definition that has been provided over here but uh let me make it a little bit clear for you uh basically a rotated sorted array is that initially an array is a fully sorted array which is the case over here you can see that all the elements are sorted and they are all in ascending order and the thing is whenever we rotate one time basically we take the rightmost element we put it on the leftmost side and then we flip all the elements one side or one position to the right and that is how we rotate and uh rotate a sorted array so if we consider this to be the original array suppose we rotate it one time we will get a result that looks like this where this five that was originally on the rightmost position came on the leftmost position and all the other subsequent value we jumped it one step on the right side if we rotate it two times again the four and five would come on the left side and all the values would be shifted two times on the right side if we rotate three times basically all the values would be rotated three times and we would get an array that looks like this so the idea is we are given a form of a rotated sorted array the thing is we don't know that how many times it has been rotated or what not we are also given some Target element and we need to see that whether this target element exist inside this array or not so suppose uh this is the array we are given as the input and we are given Target is equal to uh three if that is the case then in this case three exists inside this array and its index value is zero so we need to return zero as the answer and this is what is being asked for this problem so now let's see that what are going to be couple of different approaches to solve this problem the first approach we have is a Brute Force approach in The Brute Force approach what you can do is suppose this is the ARR we are given and we are given the target value to be zero well if we see what we simply do is we start iterating over this a uh 1 by one and every single time we iterate until we find the value that exists if the target value exists inside this array whatever its index position is which is three in this case we return that as the answer and if we somehow reach to the end of this array and we do not find this target value we simply return that okay the target does not exist right the thing is this solution is not the most optimal solution why because the time complexity for this solution is going to be bigo of n meanwhile if we read read the problem statement we are explicitly told that we need to complete this in bigo of log and time complexity and this bigo of n is just just not good enough okay before we come up with the optimal solution first let's understand couple of Concepts regarding the sorted arrays right for the sorted arrays uh if we compare any left element with any right element uh if we at any point identify that left is actually less than right and we know that this given array is a sorted array right and this left is actually less than uh right so if that is the case all the elements between this left and right will be sorted in ascending order that is one of the properties of a sorted array we already know that now uh the tricky part we have is that the array we are given is actually rotated so the thing is we will have to take care of this rotated part as well and we don't know that how many times it has been rotated so suppose we are given an array like this this has been rotated few times right now whenever we compare the left element with the right element initially uh we can clearly see in this case that left is actually three and right is actually two which means left is actually greater than right and remember we already know that when left is less than right we already know that all the elements in between they are actually sorted and if we are trying to find some Target value that falls between this left value and this right value we can immediately find that Target value suppose we are given the target value to be 3 we know that left value is zero and right value is five so because of that this target value has to be somewhere between this 0 and 5 because it it can only exist between 0 and 5 because this portion is sorted three cannot be outside of the scope the thing is we cannot say that for certain in this case because over here currently if we see left is actually greater than right which means we can determine one thing that this whole portion is not sorted but thing is we already already know that a chunk of this portion is sorted which is this that 3 45 this is sorted in ascending order again same way this 012 that is also sorted in ascending order why because this was a rotated array right so the thing is what now we are going to do is we are trying to find some Target value right so our aim is that suppose we are given the target value to be four right now we are trying to find the value four the thing is for this rotated array the idea we are going to use is that when we determine that left is actually greater than right which means that this whole portion is not sorted right that is the key part this whole portion is not sorted but some chunk of this portion has to be sorted and that we can determine by defining some middle value so in this case suppose we put down a middle value so suppose we have a middle value that is zero right now with this zero what we are going to do is we are actually going to compare this left with this middle value if we compare this left with this middle value left value is equal to and middle value is equal to zero so if that is the case left is actually greater than middle value so since that is the case we are we won't be able to do much over here and uh basically what we will do is now again we are going to compare this middle value with this right value So currently middle value is actually zero uh the right value is actually two so middle value is actually less than right which means because this was the rotated array we can determine that all the values between this middle value and this right value value is actually completely sorted this is the important property that we have to Define that this whole portion is completely sorted because of that now we will see okay our Target value is actually Four uh the current middle value is zero current right value is equal to two which means four does not fall between 0 and 2 because it does not fall between 0 and two we can concretely say that four cannot be part of this particular chain so immediately we can ignore all of these cases and now what we do is we will shift our right pointer to One Step before mid why because we were certainly able to say that this sorted property of this rotated sorted array help us determine that four is not part of this one all the elements between these portions were between 0 and two now we are going to move our right pointer over here so let me clean this up a bit so now currently our left pointer is here right pointer is here right now if we see left is equal to 3 right is equal to 5 if that is the case left is actually less than right and this is what the golden thing we wanted now we can clearly determine that this whole portion 3 45 that is completely sorted because this is completely sorted all we will have to do is just use binary search uh in order to find the target value so what we are going to do is we are going to compare uh the middle value so middle value in this case is four four is actually exactly the target value we are looking for so we will return the index position of four which is one in this case as the answer and the answer over here is going to be the one that we are going to written now after explaining this whole thing let me quickly go over one of the examples to see that how we will solve optimal solution using binary search okay so now as mentioned we are actually going to do the binary search operation on this rotated sorted array right and the target we are trying to find is the value number zero now now we are going to use our two pointers so first pointer we have is left that is located this position number three and right pointer is located POS this position number two in this case currently left is actually greater than right which is not what we want so now we will have to determine that which portion of the array sorted and based on that where this target value could lie so we are going to compare with with the middle value so in this case the middle value is going to be seven right so now we have this value number seven that is located as the middle value okay now for this middle value we are going to compare it with left and right value So currently if you see left is actually less than middle value and this is what we wanted the moment we identify left is actually less than middle value we can clearly determine that this whole portion is completely sorted okay now we will compare the target value we are looking for with the values of left and mid so if we see the target value is actually outside the scope of this left and mid which means that Target value cannot exist between these places immediately we can determine that so we will ignore all of these cases and now we will have to update our left pointer to go on the right side of the middle pointer so we will do that so now we will have our left new left value the located at this position and the new right value located at this position now we are again trying to find the value zero okay now immediately over here we can see that left by itself is actually zero so that makes our life much more easier and we can simply return the index value of this left to be five as the answer and in this case we are going to return answer as the five and basically all we are doing is we are actually using the middle value to determine that which portion of the array is sorted depending on that and based on the target value we decide that which way we will have to make the jump and then we get our desired answer if we see time complexity in this case the time complexity is actually going to be big go of log n Only why because uh remember in a single iteration we were able to get rid of all of these elements immediately which means every single iteration we are doing like half we are getting rid of half of the elements so that is why the time complexity is log n and that is what we wanted if we see space complexity in this case the space complexity is actually going to be constant space because we are not using any any additional data structure first of all we are going to Define couple of variables left and right okay now we are going to initialize our while loop that while left is less than or equal to right and inside our Loop first of all we are going to calculate the mid pointer now we are going to check for the condition that if the given value of mid if that is is equal to Target if that is the casee we can simply return the index at Mid okay if that is not the case now we will have to first of all Define that which portion of the midp pointer is actually completely sorted so first let's put the condition that if the given value of left if that is less than or equal to whatever the value of mid is if that is the case we can Define that the values between left and mid is completely sorted right so now all we will have to do is we will have to see that where Target lies does it Li Li between left and mid value or it lies somewhere else so first we are going to see that what if the target lies outside of left and mid value if Target lies outside basically we will have to update our left pointer to go mid + one and we will continue with our journey if that is not the case which means Target lies between left and mid and if that is the case we will have to update our right pointer to come between left and mid so we will do right uh equal to Mid minus one okay now we take care of the scenario that the numbers of left is not less than or equal to Mid which means that the values between mid and uh right is actually sorted and if that is the case again we are going to repeat the same process first we are going to check that whether the target value is outside the scope of mid value and right pointer so if the value is outside of the scope which means we will have to update our right pointer to search on the other portion of the array so right is going to become mid minus one and if that is not the case which means that the values lies between uh mid and right value if that is the case we will update our left pointer to search between uh mid and right so left would become mid + one and basically this uh loop should take care of the scenario and we would be able to find our answer and uh just for the sake of uh putting something outside so we don't get a compilation error we are going to return minus one but our answer would have been returned by this now let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs pretty efficiently compared to a lot of other Solutions and uh I would be posting this solution in the comments so you can check it out from there thank you hello friends hope you're having a fantastic day today so once again we are going to solve an awesome lead code problem but now we are also going to learn a very popular Advanced data structure in this problem so I'm going to pay my atmost attention I hope you all so enjoy the video so the lead code problem we are going to solve today is called time based key value store we can see that this one is a medium problem and also a very well like problem on lead code the problem statement is actually quite a long basically we need to implement a Time map class but there are a lot of conditions in order to implement this time map class so we need to design a Time based key value data store that can store multiple values of the same key but based on the time stamp so so depending on what at what time stamp what key value we received we need to store that and we also need to retrive the same key value pair depending on the certain time stamp the value that that we have been provided now number one we need to initialize the object for the time map uh data structure that we are trying to create and we also have to set two methods first one is a set method where we are providing three values first one is the key second one is the value associated with that key and third one is the time stamp associated with both of these keys and values now next one is a get method where we are providing the key with for which we want to get the value and we are also providing the associated time stamp so by based on using the combination of these two we should be able to find the value associated with this particular key the other thing is if say for an example for this time stamp we don't have the value associated with the key then we need to find the closest Value that was present at that particular Tim stamp and for some reason we don't find any value for the key then we need to return an empty string so let's try to understand this with an example basically we need to create a data structure and that data structure needs to store three items first item is the key that is going to be the unique pointer second value is the associated value with that key plus the time stamp now the the other thing is is that typically we usually see that Keys tend to remain common in data structures like hashmap and uh other like hashing based algorithms but in this case we can have multiple keys with the same value but the only difference would be time stamp so in this case the value would not be truly unique because the entire value portion is actually combination of Value Plus time stamp so let's try to understand currently we have an empty data structure now let's try to enter the values uh path as the key and the VAS uh that is my last name as the value and we are also providing the time stamp at one so at time stamp one we enter these values which means in our data structure we should have the key as p and we should have Associated value as vas and the value this was located at Value number one now let's say for some reason during the time stamp number two once again I provide the value path I also provide the value is let's just say uh J and um that's it the time stamp is two now once again I'm going to store the value p and this time the associated value is going to be J but this is located at time stamp number two now once again I have another value path once again the value is K and once again the time stamp is three so once again I'm going to have another entry in my data structure for path the value Associated is K and the time stamp is three now say that I do do a get operation for the get operation I provide the value s key PA and I also provide the time stamp to be2 so in this case the answer I should be receiving back would be value number J because J was the value stored for this path key at time stamp number two so this should return a j as the answer let's say once again I do another get operation this time I provide the value PA as the key and as a time stamp I provide value number now you must be wondering that hey we don't have any value stored at Value number seven as part of the time stamp because we currently only have three time stamps that is 1 2 and three and for each one we have a subsequent values stored inside our data structure so in this case the idea would be to find the closest value for this particular one so the the uh floor value associated with this time stamp which is going to be value number three because three is the first value we can reach from time stamp number seven and for this the value Associated was K so we are going to once again return K as the answer for this one now let's say that for some reason I do a get operation for let's say John and I provide the time stem to be five so once again I don't have any entry for John so this should return us an empty string uh and once again I can do a set operation I can add value number John I can add the uh associate value as Cena and I can associate the time stamp to be six so now in this case the value going Val once again we are going to have a new entry called John and Associated value Cena so this is the whole idea of the type of data structure that we are trying to design now let's try to see some of the possibilities with this uh type of data structure that we are trying to con convey now think for a scenario that if we only had to design a data structure where we are simply dealing with a key and its Associated value there is no such concept of time stamp let's just say that if this is the case how would the things things might behave the idea would be quite simple we can simply Implement a hashmap inside the hashmap we typically store values based on the key and its Associated values and we can store all of these values one by one uh based on the distinct key values and we can simply uh complete all the operations in big of one time like in search and deletion searching and whatnot so this is uh very very easy way for for us to store the values now in the same example what I'm suggesting is that instead over here as part of the key once again we use hashmap but now for this uh hash map in part of the value rather than storing just the value as it is we actually store an instance to another um hashing solution solution and this hashing solution should have another block like this that contains two values first one is the value and second one is the time stamp and based on this it should be able to store all the values that we need and we should be able to find particular time stamp on that particular value and we can we can return all of those values and this is actually the whole solution that we need to build up the idea would be that we are actually going to use the combination of hashmap to store the standard key and it's Associated Association to store another hashing hashing solution and we all can understand that why are we using hashmap to do that because hashmap does all the operations in big off one time plus it's a hashing solution if we identify at any point that there is uh an existing key we can do that operation in big off one time and also for the associate value we can actually directly have have multiple values but in this case we we don't need multiple values we need a separate hashing solution for that I'm suggesting to use a tree map why are we using a tree map well first before going down deeper into understanding that why are we using tree map first let's understand that what a tree map is so tree map is actually built on top of a hash map that is number one thing it so it tree map contains a very similar property where once again we can have a key value pair operations and we can store bunch of different values but the other thing is that tree map is actually contains a property of binary search or logarithmic time uh valuation storing property so how does it do that well actually tree map is built based on red black trees now let me know in the comments if you want to understand more that how does red black trees work because in itself it's a very interesting to topic to learn and it has many practical use practical use cases and applications basically what red black trees allows us to do is that instead of normally having a single hashmap where we are only dealing with simple key value in tree map we are dealing with three values we are dealing with a key we are also dealing with a Value Plus we are dealing with an extra bit that stores the value of a color and storing the value of this color actually allows us to identify at any given moment whenever there is a conflict this color has to be the Difference Maker which we can actually use to find that what was the value Associated at that particular time so I know it's sounds confusing but it's actually very simple to understand because this property actually allows us to store all of these values in a binary search Manner and we all know that how does a binary search work that typically we can go in any particular direction direction to find the value we want and in this case the particular direction or the color would be dependent based on the time stamp that we fetch the value at and that's it this is the whole solution so let's try to run the solution uh with some example and then you would it would make more sense to you we know that we need to we need two items we need our hashmap and we need our tree map now the thing is for hash map we are simply going to have key as part of the uh key that we are coming in as an input as part of its value we are actually going to store the subsequent tree map instance so as we the tree map instance would be unique for every single value and inside the tree map instance the unique part is that we need two items one is key and second one is value so as part of the key we are going to store the time stamp and as part of the value we are going to store the associate value that we are given in the input so let's say that first input we have is key is path so I'm just marking it as p uh associate value is vas so once again I'm just marking it as as V and the time stamp is value number one so in this case currently we don't have any entry so we are going to create a new value P associated with PA we are going to have Associated tree map that we have to consider so this instance of the tree map would be marked over here okay so let's just say that this is the instance of tree map okay and inside the instance of the tree map we are going to store one as the value that we have or as the key because this is the time stamp and its associate value we are going to store value number vas now let's say that once again we received the value for the same key path and now this time the value is H and the time stamp is three so once again for this same path we already have the entry so we already have this one now we all we need to update inside the existing uh St stamp so for this one tree map once again we are going to have another entry three and now this time the value is going to be H so we store the value H over here once again we get another entry path once again the value is let's say x and the time stamp is five so once again we we only have one entry inside our hashmap we have the time stamp to be five and we have the value X associated with that now let's say we receive another value John now uh the value is Cena and the time stamp is 7 so we don't have entry over here so we are going to create a new entry John now we also have to create a new instance of the uh tree map so we are also going to do that for the John and over here we are going to have our time stamp and value time stamp in this case is going to be 7 and value Associated is going to be Cena and this is how the whole solution would work now let's say at any given moment I want to do a get operation if I try to do get uh path at time stamp number seven So currently I will go over here because this is the key for PA now once again this would take me to this tree for this tree map I don't have value number seven uh but I have something closest now the thing is all of these keys inside the tree map are actually stored inside some sort of a binary search tree or a red black tree which means finding that where does value number seven exist should only take us logarithmic end time and not actually end um end time in normal hashmap it would take so in this case we can find out that seven is not present but seven is not present we can also find out that what is the largest value present that is value number five so Associated value is X so for this operation we can simply return X as the answer that hey this is the value Associated uh closest to this particular time stamp and same way if we get another entry let's say get uh John and for John we also get time stamp to be nine so once again we can just go to John we go to it's sub subsequent tree map for this tree map the largest entry is seven the associate value is Cena so we can return return Cena as the answer and that's it this is how we can use the combination of tree map and hashmap to store all the values now let's try to calculate the time and space complexity in this case the time complexity is going to be bigo of log n for the set operation and also we go off log n for the get operation and why log n because tree map operat in logarithmic and time complexity because it's a red black tree and I'm also repeating because this is a very popular concept so that's why space complexity so space complexity is actually unique to calculate it's going to be big go of K so K presents number of unique Keys multiplied by number of total values that we are being given so K multiply by n because we only need one hashmap to store all the unique keys but per unique key we also have to create multiple tree Maps so that's why space complexity is little bit higher but time complexity is extremely fast and this solution actually is being used in many application such as cache or some sort of like High Time functioning time based data structure that you are trying to trying to design so that's why this question remains a good good amount of popular okay so let's see the coding solution for this one first of all we are initializing our private hashmap where we are going to store the value of the key and it's Associated tree map as its subsequent value now uh let's initialize our tree map with a new hashmap now for the set method we are given three values as an input first one is the key second one is the value Associated and third one is the time stamp so for that we are actually going to store the value inside our hashmap and we are going to check that if the key is not present so then in that case we need to create a new entry for key and its subsequent tree map if that is not the case then we are going to Simply put down the value inside our time based on the time stamp and the value inside the tree map okay after creating the new instance so this is the set method for the get method we are simply checking that if inside the what is going to be the key portion for the tree map for that we need to do map. get key so that is going to give us the value of the the value that we are looking for inside the tree map and we are going to check that if the tree map is equal to null for that particular entry then we can simply return null if that is not the case then we need to check that what is the flow timestamp associated with the current Tim stamp that we are given and we can check that if we don't find any entry we can simply return null if we do find an entry that is closest to that particular time stamp or that time stamp exactly then we can simply return that value and this is how the solution Works let's try to run this code okay seems like our solution is working as expected let's submit this code okay our code runs pretty good in terms of time and space complexity there can still improvements be made but uh this is going to be good enough solution so once again the solution is present inside our GitHub repository so if you want you can go ahead and check it out from there thank you Hello friends I actually have a great news for all of you guys uh I just want to give you a quick update that I got a job at Microsoft and I will be starting next week I'm going to make a whole separate video on the whole interview process and how I get the job it's a really crazy story so I hope you like it uh and now let's get back to this video so we got a job at Fang but we are not going to stop making lead code videos because it's pretty fun for me uh so today we are going to do median of two sorted arrays lead code problem and if you see some of the popular companies who have asked this question there are companies like Amazon Apple Goldman sax Microsoft Google Bloomberg Uber Facebook LinkedIn and by Dan so that's why I'm paying my at most attention I hope you also enjoy the video so despite being a hard problem this is a very well-like problem on lead code basically we are given two sorted arrays uh nums one and nums 2 and we are told that they could be of different size so the size can be respectively M and N that is given over here now we need to return the median of these two sorted arrays we are also told that the overall run time time complexity should be big of log of M plus n the solution I'm going to show you today is actually going to do even better than this big of log of n plus n I'm actually going to solve this problem B of log of minimum value of either M or n so before we understand this problem any further first let's see that what does a median mean so a median is basically any single position inside any given array where everything on the left hand side and everything on the right hand side is actually of same length so whatever the amount of element it has on the left side the same amount of elements it has on the right side now there could be two cases there could be like odd numbers or there could be even numbers and for each one of them I'm going to show you how to calculate the median so suppose if we take this first example in this first example we can clearly see that we are given three elements and based on the definition of a median everything on the left and everything on the right has to be same so if we consider this element number five five is the position where uh the left of five is there is one Element and the right of five is also there is one Element so in this case five is going to be the median for this given array uh now if we take a look at this one in this example things are a little bit tricky because this is an even number so in the even case we actually have two elements in the middle uh who form the middle portion such that their left portion and right portion Becomes of equal size so in this case for this particular middle portion the left value has one element and the right value also has one element so both of these are part of the median but thing is in the median there cannot be two values so if such case arises which is for even numbers we are actually going to do the average of them so in this case we are going to do 3 + 4 / 2 which is 7 ID 2 so we get the answer as 3.5 which is the median for this particular array if we take this example again this is simple uh this value number five again this falls in the middle so because of that we are going to note five as the answer because there are two elements on the right and two elements on the left now again for this case we have the value this four and six that creates the Middle Point such that the left values and right values Becomes of the same length so in this case uh the median is going to be 4 + 6 / 2 so again we get 10 / 2 so the answer is five and this is the median for this kind of case now after understanding what a median is first let's see these two examples so it makes things more easy so in the first example we are given two arrays nums one and nums 2 we can clearly see that they both are sorted array like this one only has one element but still it's sorted right uh and now we need to find the median of these two arrays so if we find the median of these two arrays if we combine these two arrays we will get an array that looks like this uh that is sorted right because we need to find the median of two sorted arrays so this is the combined array in this case two is going to be the median because that is the middle point where one there is one element on the right and one element on the left same way for this one if we try to see the length of this is actually 2 + 2 so the total length is four uh now if we make a combined array the combined array looks like this and uh in this case if we want to find the median of this one we will actually have to do an average of these two middle portions so we'll do like 2 + 3 divided by 2 so we get the answer as 2.5 and this is what we need to return as the answer uh so let's see that what are going to be the different approaches to find the median of two sorted array the first solution that comes to our mind is a Brute Force solution in The Brute Force solution the idea is actually simple if we just combine these two arrays and create like a combined sorted array we get an array that looks like this now once we have this combined array all we have to do is just find the median so in this case the median is going to be this value number five because on the left hand of the five there are going to be exactly five elements and on the right hand of the five there are also going to be exactly five elements and this five is the answer we need to return uh so this solution would give us the correct answer this root Force solution but the issue with this solution is that in order to create this combined sorted array we will actually have to complete this solution in big go of m + n time so that is a linear solution and the thing is that is not what we want we actually want a Lo logarithmic solution so let's see that what is going to be the approach for the logarithmic solution okay so before we come up with the optimal solution first let's try to understand some really important concept suppose we are given two arrays that are X and Y we are told that they both are sorted in ascending orders now we know that their length is actually respectively five and six in this case so the total number of elements we have is actually 11 if we do like 5 + 6 okay so now here we are trying to find the median of two sorted arrays and thing is the median how we are going to find is that okay currently we are given these 11 values so these 11 values they're combined of these two now this 11 we can actually create two partitions how we are going to create two partitions so the logic we are going to use is that every single time whatever the combined sum is we are actually going to do like + 1 divided 2 so in this case the value we will get is 11 + 1 so that is 12 / 2 so 12 divided 2 the value we are going to get is 6 uh so now first partition we will have to do is of six elements and second second partition we will have to do is remaining elements so remaining elements in this case is 11 - 6 so that this is going to be five elements right and whichever is going to be the maximum element of this six so maximum element of these six is going to play somewhere over here in the middle and that is going to be our median now the thing is how can we Define that this maximum value is going to be the median what are the properties we are going to take for the six and five value partition that we are trying to create and the answer lies right in front of our eyes that the sorted property has to be maintained so what does the sorted property has to be maintained means it means that all of these six values that we are trying to create on the partition they all has to be less than or equal to the values of the five on the right hand side okay so that is a very important property for us to understand uh I am speak telling this again that all those six values that we have on the left hand side they have to be less than or equal to all the the values on the right hand side why because we are trying to find the median of two sorted arrays if they are not sorted then it's like a big mass for us right so because this is the sorted properties maintained now what we are going to do is we don't care about finding these five values all we are going to put our focus is to finding these six values now these six values they can exist anywhere inside this X and Y it could be possible that we take like three values from X and then we take three values from y and that is how we create the six values it could also be possible that we create like we take like two values from X and four values from Y and that is also how we create this these six values no matter whatever the logic we are going to use we will always have to be certain that all the elements on the leftand side they have to be less than or equal to all the elements that are on the right hand side and using this property we are going to come up with some very interesting results so the idea we are going to use is that first of all uh we we are going to take whatever the Lesser value we have in terms of length among both arrays So currently in this case the Lesser value of length we have is of array array X So currently for this x the length we have is five right so what we are going to do is we are actually going to do 5 + 2 so 5 + 2 we get value of 2.5 if we take the ceiling value we get the value to be two which means that now we are going to take two values from this x so if we take two values from this x we will get get the values x0 and X1 that is on the left side of the portion now if we take two values from the X which means total we are trying to find like six values because remember we are trying to find like the two partitions one partition is six second partition is five and all the six values has to be less than or equal to these five values so because we are trying to find the part partition of six values which means we took two values from the X so we are going to take four values from y now if we take if we create a partition like this what is going to happen happen well all the remaining elements they are going to be on the right side of the partition So currently the remaining elements we have so now we have our two partitions right now these for these partitions again we will have to make sure that this property is maintained so how can we check that okay over here we are 100% certain that this X1 is always going to be less than or equal to whatever the value of this X2 is why because we are told that this x array is already sorted same is true for this y array that this Y3 is always going to be less than or equal to this y4 this property is always going to be there so there are no issues with that but where the issue comes the issue comes uh to the place where we don't know that whether this X1 if that is less than or equal to this y4 same way we don't know that whether this Y3 if that is less than or equal to this X2 so in either case we are going to do the following first we are going to take take the smaller value then we are going to find that what is the partition we are trying to make depending on the starting and ending value So currently the starting value over here is zero and the ending value is four okay so we will if we do that we get the value of two now we are going to take two values from here if we take two values from here then we will have to check that what are the remaining partition for y and how many values we are going to take from y So currently from y we are going to take four values now for all of these values we are going to check that whether this X1 is smaller than this y 4 and same way whether this Y3 is smaller than this X2 uh once the moment we find both of them to be matching uh great if we don't find anyone to be matching suppose we find out that this X1 is actually greater than this y4 if that is the case then what needs to be done well the idea is simple because this is a greater value and this is a smaller value which means that this X1 has to go on the right side and this y4 has to come on the left side now you will ask that why both of them has to happen simultaneously well if both of them does not happen how are we going to maintain the number of elements that are needed because currently the number of elements that are needed are six on this side and five on this side so we have to make sure that we maintain that property so how can we do that we can do that by shifting this ending point to come on this side and rather than uh keeping like both of these values we might only keep one value over here and we will try to keep four values from here and same way if we find that this Y3 is greater than X2 again and we are going to repeat the same process by Shifting the starting point on the right side and keeping repeating the same process so let me quickly explain the whole process with some examples and then it is going to make things a lot easier to understand okay so now suppose this is the example of X and Y values we are given I have calculated the total number of elements we have which is 11 in this case which means as explained previously uh the left open partition that we will have to make that is combined of X and Y elements that has to be of size six now for this x partition what we are going to do is depending on the starting and ending value divided by two we are going to calculate that how many elements are needed in the EXP position and based on that we would calculate that how many elements are needed in the from the Y side or from the Y side of array based on this formula of like 6 minus whatever the value we achieve from this Exposition and then we will try to compare the values so first of all okay currently this value is zero this value is 4 if we do like 0 + 4/ by 2 we get value as 2 so now which means that inside this x portion we are going to take two elements which means for this y p portion we will have to take four elements from this y so now because this is the left portion we are going to take the leftmost two elements in the inside the left array which is 0o and three in this case and from this y portion we will have to take four elements which means we are going to take the first four elements over here once done that basically now we have our left partition setup so now because we have our left partition setup we can automatically create our right partition from the remaining values which are now we know for sure that this three is always going to be less than this five because they both belong to X array and same is true for these two the thing is now we are going to do the cross comparison So currently this three is less than 13 which is great that we don't have to do worry about anything the thing is for this 12 12 is actually not less than this 5 12 is actually greater than which means that because we have some element inside this y array which is greater we will have to move this one on this side and we will have to move this value on the left hand side so now what we are going to do is because we will have to add more values from the X we are actually going to shift our starting point so where we are going to shift our starting point the idea is that previously we had the values of s + e equal to uh 0 + 4 / 2 like okay this value so we we had the Middle Point as uh 4 / 2 is equal to 2 so now because this is a binary search we are actually going to do like 2 + 1 for the starting point so now our new starting point comes at position number three okay so now this is the new starting point this is the new ending point now again we are going to use the same logic so now for this x partition few things have changed so currently our starting position is three ending position is 4 divid 2 which is 7 by two so we get the value 3.5 but we use the ceiling value so now from this x portion we will have to take three elements so if from the X portion we will have to take three elements which means even from the Y portion we will have to take three elements so let's do that so this is how the two parations are going to fall now this time now again we compare okay so this five is less than 12 so which is good now this 8 this eight is still greater than six so again we will have to move one element from this uh to the right hand side so again we are going to update the value inside our X pointer to move the S element to the next side so how we are going to do it okay currently this value is three this value is 4 so now again we are going to repeat the same process so we get the value okay 3 + 4 / 2 so we get the value of 7 / 2 which is 3 okay so now we get the value to be 3 3 + 1 so this is going to be the new start point so currently our start and end point they both fall on the same position so this is the start point this is the end point now again for this x partition let's see that how many elements we are going to need so we will have value 4 + 4 ided by 2 so 4 + 4id 2 is going to be 8 divided by 2 so the value is going to be four which means we are going to need four values from the X partition so from the Y partition we are going to need two elements so let's do the math and now let's create the new partitions okay so these are the two partitions we have now let's compare okay so 6 is less than 8 great 2 is less than 11 great so now we have created two partitions such that on the left hand side we have six elements on the right hand side we have five elements we were able to calculate that using the total elements we had the sum we used was total + 1 iD 2 so 11 + 1 / 2 so we get six elements on the left hand side now from these six elements because the total length was odd so because of this was odd so what we are going to do is from this left portion we are going to select the maximum value now you would say that hey do we need to calculate all the values on the left portion to calculate the maximum value and the answer is no why because all we have to do is check these two values whichever is greater value is going to be the maximum value on the left portion because all of these values are sorted so amongst first four values this is the maximum value and same way among these two values this is the maximum value so if we compare the maximum value between these two basically we will get our desired answer and in this case the answer is going to be six and because this was the odd case this six is going to be the median that we are looking for and this is going to be the correct answer now let's take one more example with odd case and see that how things work out over here suppose this is the second example we are given I did some math so total number of elements we have is 12 which means that if we want to calculate that how many elements we need in the left portion basically we are going to do like 12 + 1 divided 2 so in this case we get the answer to be 6.5 but we choose the ceiling value uh which we choose the floor value which is going to be six now for this x portion uh we are going to do like starting plus ending divided by two so first currently the starting and ending positions are this one so we get the value to be now which means we are going to take two elements from the X portion so if we are going to take two elements from the X portion we are going to take four elements from the Y portion so let's do that these are the two partitions that we have created again let's compare the values so first 8 is less than 6 no that is not true 8 is actually greater than six the moment we find 8 is greater than six we will have to move this eight on the right hand side and we will have to move this six on the left hand side so let's do that process so in this case now what we are going to do is we are actually going to update our end value to come on this side so again previously what was the end value the previous end value was position four now the new end value we are going to create is we are going to find the middle value so the middle value currently 0 + 4 depending I'm talking about these like starting and ending values so 0 + 4 divided by 2 so this is the middle value is 2 so for this ending value we are actually going to do 2 minus one so now let's update our ending position so our ending position is now going to come at this position number uh one okay now again we have the updated value of starting and ending values so now let's try to calculate this x portion and Y portion again so for now this time this x portion is actually going to be 0 + 1 divided 2 which is going to be like 0.5 but again we are choosing the floor value so we will get the value to be zero which means we are going to take 0 values from this x portion so if we taking zero values from this x portion which means that we will have to take six elements from this y portion which is okay cool no nothing wrong with that okay so now we have these two values now let's do our partition so now we have created our two portions now in this case because from this x portion we are not going to take any values we currently have zero values right now the thing is previously we have been comparing like this the thing is currently in the EXP portion we actually have zero elements so if we have zero elements how we are supposed to compare with this one the idea we are going to use is that every single time we are going to compare that we are going to consider that this like first value is actually negative infinity and this last value is positive Infinity so the minimum and maximum value possible on each one of side so in any case we come up to this Edge case where we need to find we don't have any values on one portion we can we don't get stuck so we will try to consider this to be negative Infinity value now negative Infinity value is always going to be less than whatever value we have so it's always going to be less than 15 which is great now we compare these two values so 7 is actually greater than zero so because 7 is greater than Z now now what we will have to do is we will have to move our uh s to go on the right side and we will have to try to bring one element from this uh X portion so let's do that do that so now we are again going to update the values of our starting and ending values now this time we will have to update the start value to go on the right side So currently the starting position is zero the ending position is one okay so the new start value we will have to find the middle value so middle value is going to be 0 + 1 / 2 which is going to be 0 we have already established we are trying to taking the ceiling value so the new starting value is going to be one so let's update that and now we will try to recalculate the whole thing now this xos the number of X element is going to be 1 + 1 / 2 it is going to be 1 so we are going to take one value from this x position which means we are going to take five values from the Y position so let's compare X and Y positions so now we have our two partition setup so if we compare the 0 with 7 the 0 is less than or equal to 7 that is correct if we compare the 6 with 8 8 is 6 is also less than or equal to 8 which means that this is a correct partition amongst left and right values now in this case the com combination value is actually even for left and right case so because this is even value what we are going to do is we are going to pick the maximum value from this one so maximum value from this one is going to be six and we are going to pick the minimum value from this portion so minimum value from this portion is going to be seven now again same logic we are only going to compare these two values to find the maximum value so in this case we will get that value to be six uh in order to find the minimum values we are going to only compare these two values and in this case the value we are going to get is 7 so now we are going to do the average of these two so we will get the value of 6 + 7id 2 which is 13x 2 so 6.5 that is the answer and that is the median we need to return return and that is the whole logic behind using this technique every single iteration we are updating the values of uh s uh starting and ending point only in the array that has the smaller length uh so in this case both the times x had the smaller length so we are only working on that and depending on that we are generating our answer and we are able to find successfully the median value so if we calculate the time complexity in this case the time complexity is actually going to be big go of log of minimum of M or n and in this case whatever the minimum value is we would be able to find the median easily see space complexity in this case the space complexity is also going to be big go of one constant space why because in order to store like the portion we don't have to store this whole things we are only concerned with four elements like the minimum of X the minimum of Y maximum of X and maximum of Y and uh using these four elements we can do all sorts of magical things so this is a very good time in space complexity and this is a very tough question in my opinion so if you are able to crack this in an interview all the companies would be like more than happy to have you as the candidate so first of all we are going to compare the lengths of nums one and nums 2 the idea is that whichever has the smaller length we are going to keep it first so uh if not we are just going to call it recursively again with different inputs now we are going to initialize two variables called X and Y and uh we are going to assign the length of respective numbers remember X is the smaller length and Y is the greater length we are also going to assign two variables called start and end uh so start position is going to have the value zero and end position is going to have the value of whatever the value of x is now we are going to run our while loop that while start is less than end now first we are going to calculate that what is what should be the X portion so we are going to name it as X part once we calculate the X portion it's easy to calculate the Y portion okay now we are going to calculate four important characters uh those four characters are left value of x right value of x uh left value of y and right value of y now each one of them we are for every single left portion we are going to see that if that subsequent like X part or Y part if that value is zero we will have to put like minus infinity or plus infinity for those values if not we will put whatever the uh subsequent value we can find from this nums array so let me calculate those four values now we have our four values that we are going to need now we are going to compare that if the X left and Y left if they are both less than y right and X right if that is the case which means we can simply return we have found the correct portion and depending on whether the total number of values are odd or even we can simply return the answer and if that is not the case we will have to update our start and end variables so first let's calculate for the correct case now we will have to calculate that whether the sum of these nums one and nums two if they are odd or even so if they are odd value we will simply pick like the maximum value that we have on the left portion and if it is like the even value we will pick the maximum value from the left portion and minimum value from the right portion average of both of them and if that is not the case which means the value is odd uh so in that case we can simply return the maximum value if that is not the case we will have to check that which one uh end we will have to update so first we will see that if the given X left if that is greater than y right which means we will have to update our uh end value to come before mid or else we will have to update our uh start value it's basically it we should get our answer this way if we don't get our answer we can simply return zero outside the loop so we don't get a compilation error let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs pretty efficiently compared to a lot of other Solutions and I would be posting this solution in the comment so you can check it out from there thank you hello friends we are not employed by Fang company so let's not stop lead coding to together today we are going to do reverse linkless problem and uh essentially this is a very easy but very important lead code problem as it has been asked at bunch of different companies so this problem has been asked in companies like Amazon Microsoft Apple Bloomberg Facebook uh Google Nvidia Adobe Uber and also IBM eBay PayPal other companies like Goldman sex and then bite dance and a few other companies so I'm paying my atmost attention I hope you also enjoy the video Hello friends I got my results back from the from my go old man sax interview and I didn't clear it which means that I have a long way to go and I still have to do lot of work on my coding and Lead coding skills this is a lead code easy problem and it is one of the most like problems on lead code uh basically we are given a head of a singly link list and we need to reverse the given list and then we need to return the reverse list so problem statement is quite easy to understand and even if we see the example the example is also quite easy to understand understand basically we are given a list like this 1 2 3 4 5 and we are at this position and we are given this head value of this link list and basically we need to return the reverse list so in this case the reverse list is going to be 5 4 3 2 one so essentially we are just iterating over in this direction and this is what we need to return now the thing is there happens to be little bit more complexity because we are told that this is a singly link list so in singly link list all the elements are just stored in a single manner which means that this element only knows that what elements comes after it it does not know that what is the element before it that is pointing to this position so this is the concept of a singly link list and we'll see that how can we solve this problem okay so we need to reverse the link list and we are told that the link list we are given is actually a singly link list the thing is that what is the property of a single link list that the link the every node in the given link list actually has the value of that particular node and also has the pointer towards the next node inside the link list and whenever we encounter that next node is actually pointing towards n null value we can determine that this is the end of the given single link list the issue over here is that we know that at any single position what is the value after it using this next pointer but we don't know that what was the value before it there is no way for us to identify this particular item which means that our aim is to find that how to reverse this link list and in order to reverse this link list what we can do is rather than pointing towards the next pointer we can if at any given position for all the nodes if we just point it towards the reverse Direction and basically start our link list traversal from the last node uh we can simply return the reverse link list immediately and this is the approach we are going to take now the question comes that how at any point we can actually uh originally we were pointing on this side how can we start pointing on the reverse direction from any single node and in order to do that what we will have to do is we'll have to keep track of the previous character or previous node as well and apart from keeping track of the current node so the approach we are going to use in this case is that every single position suppose we are at this element so this is the current element we are at right from this current element we know that how to get to the current do next which means that how to go to the next element we already know that know that the question is we don't know that how to go back so what we are going to do is we are going to keep track of a previous character or previous node that will always be behind this current node so in this case this would become our previous node and all we will have to do is that over here the current do next is actually pointing towards this node 3 so rather than current. next pointing towards this node we are going to have current next Point towards the previous element and we are going to do iteratively for all the values so initially at at the beginning this would be our previous and this would be our current so over here the this value will be pointing towards this on this side so null value now again we will switch our values for previous current so this would become our previous and this would become our current and again we will flip the value and again we will repeat the same process so this would become our previous this would become our current again we will flip the direction and at the end this would become our previous and if we see the previous do next element it would be a null sequence so we would know that okay this is the end of the original link list so this has to be the start of the new link list and then we can just start iterating over which means that we would have taken care of all of these pointers and now we can simply return the reverse link list in this fashion and this would be our answer so if we see the time and space complexity in this matter the time complexity for this one would be big go of N and the space complexity would only be bigger of one because at any given position all we have to do is just keep track of couple of variables nothing more than that and that that should take care of all the scenarios so first of all we are going to create a new list node and we are going to name it as previous and we are going to initialize the value as null and we are also going to create a list node called current and we will have it start at the head value okay now we are going to iterate over the given link list so while current is not equal to null we are going to keep running in the loop and inside the loop uh essentially we have to uh flip the values between current and previous so what we can do is current uh dot next would be our previous node and then for the previous node we will have to flip it to current node and for the current node we will have to go to the next node in the original single link list so for that we will have to create a temporary variable so let's create a new node and we are going to name it as Temp and we are going to store the current. next node over here and now for the current node we are going to point it to this temp because notice because remember over here we are updating this current. nextt value so that that's why okay and uh yeah I think this is it after this Loop ends uh we should have our link list derse so we can simply return the head as previous uh variable and uh this should be it let's try to run this code it seems like our solution is working let's try to submit the code okay our code actually runs 100% faster than all the other solution because it's running in constant time and uh I would be posting this in the comments you can check it out from there thank you hello friends we are still not employed by a Fang company so let's not stop lead coding till we get there today we are going to do a link list problem called merge to sorted list so this problem has been asked in Tech giants like Amazon Facebook microsof roft Apple Uber Google uh Bloomberg by Dan which is Tik Tok and then companies like Yahoo linken indeed and Roblox and also IBM plus uh recently in news Twitter so I am paying my atmost attention I hope you also enjoy the video this is a lead code easy problem and it is also one of the most like problems on lead code uh if we understand the problem problem statement we are basically given the heads of two sorted link list list one and list two and we need to merge these two link list in one single sorted list so this is the important part that it has to be sorted and in the end we need to return the head of the merge link list okay let's try to understand this problem with an example so over here we are given two list list one and list two and we can see that both of them are increasing in ascending order and now we need to create a merge list from this so this is the merge list that has been created Even If You observe the merge list the ascending uh property is maintained so which means that the merge list is also sorted and how it is sorted it basically it has taken values from whichever the nodes that had the smaller Valu so in this case these first two values were one one so we can put any choose from any one right now the second Val so and now we are done with this value one and one over here now we need to take care of this 2 and three so when we compare this two and three we find that okay this value number two is actually smaller so that's why we add a two node over here and now we are done with this one and now we still have to compare this three with this four because remember we are not done with this three yet so we identify that this three is actually smaller so in this case we are done with this three and we add the three node over here in our merge list now the values are four and four so again we just enter the values four and four and now we should be done with all of them and this is the new list that we have created and in the answer we need to return the head value so we would be returning this value as the part of the answer so this is the expectation of the problem let's see that what could be the potential solution so let me dra quickly draw just one more list and we'll see that what should be the approach let's see that what should be the merge list at the end so I'm denoting this as M now uh we are going to compare two values at any given moment and uh we are going to have two pointers so let's say left one and left two we are going to keep track of them so over here both the values are same so we can enter any value so we will add one over here and then again one over here because both the values are same so you can put condition to choose any one now we are done with both of them and because we are done with both of them we'll have to update the values of this L1 and L2 so we are going to update its values so now this becomes our L1 and this becomes our L2 again we do the comparison now this case we find that okay this value is actually smaller so because this value is smaller we are done with this element essentially we will add that value to our merge list and because in the list two we found that that value was smaller we will update the list two pointer to go to its next element so we'll do a jump like this and now this becomes our list two and again we'll compare list one and list two elements so in this case we find that value at list one is actually smaller so we will add it to our solution soltion and uh again we are done with this one now so we will update the left one pointer so left one pointer would fall over here and now again we will compare both of these values so in this case we find that okay this value is actually smaller so we'll add one more node to our merge list 4 and again update the value of list two so list two actually goes over here and this is done so this is list two and now we compare this value with this value so over here we would find that okay this five is actually smaller so now we will have to update the value five over here now because we have updated the value five over here if we do a next jump for this list one we identify that this node is actually null so the moment we identify that there exist a null node there is no point of us moving forward in this direction because we are done and essentially whatever the remaining values are still pending in the L2 they Direct needs to be appended on uh this merge list why because so far all the elements we have entered they were entered based on the some sort of relative uh comparison but once we are done with uh one Loop there is nothing for us to compare so because there is nothing for us to compare whatever is the remaining portion we can directly add over here so we uh over here we only have one node 8 so we'll directly add the node 8 over here but even if we had some other nodes over here they all would be directly appended without any issues I hope this makes sense and this actually would be our final solution uh now what are what would be the tricky part in this one the tricky part in this one would be that because in this merge link list we are iterating over here so at the end we would be somewhere at the last position and remember we need to return the head node so what we will what we will do is we are going to use a trick we'll create some dummy node and this dummy node would be actually as the head node we will just assign some random value whatever one two whatever this does not make any difference and the next value of this would be pointing to the merge do next and that would be the trick so at the end we will just return the next value of this dummy node and then that would be the start point of our merge list so if we calculate the time and space complexity in this case the time complexity would be Big O of n actually because uh we have we will have to iterate over all the nodes that are given in both list one and list two so actually it would be bigo of m + n where m is the total number of for nodes given in list one and N is list two but in general we can write it as big go of M plus n and in terms of space complexity we are only using couple of extra parameters to store the value and anyways we will have to create this merge list so we wouldn't consider that to be an additional space being used so we can see that we are actually solving this in constant time and this would be the uh most optimal solution so first of all we will create a list node and we will just call it as dummy and uh for this dummy node actually we are going to use this dummy node to keep track of the first element inside our merge list now we will create another list node and we will call it as a merge list so just let's just call it merge and and we are actually going to initialize it with dummy value and now uh we are going to run a v Loop now we are going to run a while loop up until the point that when we have elements in both list one and list two so at any point we encounter that list one or list two either of them is empty we are going to uh break out of this V Loop and inside the V Loop we will have to check that which one is a small smaller value and suppose list one is uh smaller than list two value so in that case we will have to add it to our merge list so now we will add uh the value to merge list but we are actually going to add it to the next element inside the merge list and you will come to know that why we are doing it so let's just do that and now we will we will also have to update the value of list one so this should be list one and now let's update the value of list one okay and if that is not the case which means that we will have to add the value from list to and after we break out from the loop we will actually have to uh see that which list still has values remaining because remember at any point we en null in any either list one or list two we break out of the loop which means that there could be still uh more elements that needs to be appended to this merge list and that should be taken from uh whatever the list that is still not empty so we will just put a condition if list 1 is equal to null if that is the case we know that we will have to append the value of list two and if that is not the case which means that list two is empty and list one still has elements so we will add list one to our merge list and once that is done uh we need to return the head of this merge uh link list but the problem is that now we are actually at the end of this merge list so how can we get the head of this well actually we can get the head of this is by using this dummy node that we created because remember that dummy is actually the start value of one and dummy. next would be the value of merge. next so that's why we actually have to create this additional node and uh in the return we are actually going to return dumy do head and uh oh sorry dummy do next and this should give us the head value so let's try to run this code okay looks like we made some mistake oh uh we are not uh we are not updating the value of merge element because at every iteration the merge node also needs to go to the next element because we are already adding a one value to this merge link list so now let's try to run the code okay seems like our solution is working as expected let's submit this and our solution is actually 100% faster than all the other Java Solutions [Music] so Hello friends we employed by Fang company so let's not stop lead coding till we get there today we are going to do reorder list lead code problem and solving this one problem is actually equivalent to solving three different lead code problems and I'll show you how in this video so if we check out the list of companies that have asked this problem uh there are Tech giants like Amazon Microsoft Adobe Facebook Bloomberg Uber Google Yahoo Apple eBay lyt and xedia and these are some of my dream companies so that's why I'm making these videos I hope you also enjoy the video so this is a lead code medium problem and basically we are told that we are given the head of a singly link list and we need to reorder this link list and return in a different manner so let me quickly Show You by an example that how do we want to return it so suppose we are given a link list like this that 1 2 3 4 this is a normal link list we are given and now we need to reorder it in a manner that one node we take from this left to right direction and the another node we take from this right to left Direction Al so in this case the first node is going to be this one this node number one and now once we have taken this node from this left to right direction the second node we are going to take is from the opposite direction so second node in this case is going to be this value number number four so second node would be the value number four again since we are we have taken node from the end of the list so next node we are going to take would be this one the value number two so again we will take a node this value number two and now uh at the end we will continue in the reverse fashion and the next node we will take would be value number three so this would so this is the sequence we would need to return in this case uh after all the nodes that we have taken now let's take one more example so again again in this case we will iterate we will take one node from this left to right and one node from this right to left so the first node would be node number one uh second node would be node number five then again next node would be node number two then again next node would be node number four and then again uh next node would be node number three so in this case this would be the sequence that we will need to return as the result suppose this is the link list we are given and we need to reorder this link list so what is the approach we are going to use basically we need to understand that what are the things we need well we need the all the nodes that are going from left to right and we are also need all the nodes that are coming from left to right but the proc critical part is that this is a single link list which means we don't have any way to move in the reverse order so what we are going to do is first of all we are going to create a reverse link list and then we are going to merge it with this original input and the second link list we are creating we are going to create it smartly so this is the input we are already given right so we already have our first link list that we need to create which is this one um what we are going to do for the second link list is for the second link list actually for this original given input first of all we are going to uh find what that what is the middle of the link list so in this case the middle of the link list is going to be this node number four and the sequence starting from this note to 4 to 4 56 this is going to be the middle of the link list right so in this case the first link list we have is and for the second link list we are going to choose it from this middle node so the second link list would be okay now we have for both of our link list first and second what we are going to do is we need all these nodes in the reverse order so we are going to uh for the second link list we are going to flip it in the reverse order so now for the second link list we are going to change it in the reverse order so the second link list we will have would be like okay okay and once this part is done for the third part we are going to merge this first and second link list so first of all let's see that what are the first and second link list we have okay so this is the first and second link list we have uh we are going to merge two link list until the point when when we get the second node to reach to this null value and how we are going to merge the list is that first we are going to take the node from L first node first link list then we will take the node from the second link list again we will take a node from the first link list again we will take a node from the second link list and we are going to keep iterating it until the second reaches null so let's see that in the action so first node would come from the first link list so this would become our first node uh second node would come from the second link list so this would become our second node again we will repeat repeat the same process uh and in the end we would add this value number four and then we realize that we have already reached to the null value for the second link list which means that there are no other nodes to be added in the second link list which means we would stop adding even from this first link list and we would not add the all the remaining entries and this would be our answer and we can simply return this one so this is the solution we are going to use and notice that in this solution we are actually doing three different activities so let's see that how to do each one of them first of all we need to find the middle of the link list and I have already solved this problem so you can check out check out that particular solution over here let me quickly go over the solution that I was I had already proposed so suppose I have a link list like this and if I wanted to do two partitions of it all I'm going to do is I'm going to create two pointers one pointer is slow pointer and second pointer is fast pointer for the slow pointer it is going to do one iteration uh to the next element and for the fast pointer we it is going to do two hops to the next pointer and whenever this fast pointer reaches to the end of the list this slow pointer would be at the middle position inside the given link list so let me show you how initially the fast pointer and slow pointer both would be at the same position uh then a fast pointer would take two jumps and slow pointer would take one jump so fast pointer would reach over here and slow pointer would reach over here again both of them are going to take subsequent jumps so slow pointer would reach over here and fast pointer would reach over here now again slow pointer would take one more jump so slow pointer would reach over here but if fast pointer takes two jumps we already reach to the end of this list which means that whatever the position of this low pointer is this is the uh part where we need to do a partition and this would be the middle of the link list next thing we need to do is that we will need to reverse the second link list so suppose we are given a link list like this so I have already solved this problem as well you can check out that solution over here and the idea is that we are going to have uh three two different pointers one pointer is previous pointer and second pointer is current pointer and at any point we are going to have the current pointer point to the previous element so which means because this is a single link list all the nodes are pointing to the next element rather than them pointing towards next element we are actually going to have uh any single node point to its previous element and then this would become our head and then we we would have reversed the linkless so let me quickly show you how initially we would have our current pointer over here and our previous pointer over here so now right now this current do next is pointing to the next element uh so first of all we are going to create a temp variable and this in this temp variable we are going to store the value of this current next so current do next we stored okay so temp variable is currently over here now we are going to have this current variable which is pointing to this next element rather than pointing it to next element we are going to have it point to this previous element so now this four rather than pointing to this five it is going to point to this previous element so this would be null in this case okay and now once this is done we are going to have this previous pointer jump to the current pointer so now this previous pointer would come over here so this is the previous pointer because we have already updated the value of this value number four and then the current pointer we are going to take its value from the stamp variable so current pointer would also end up over here so this would also become the current pointer once we have this uh done now in the next node we are going to repeat the same thing so first of all the stamp variable we are going to jump it to the next element so this uh so this would become the temp variable again the for the current variable we are going to point it to the previous element so now this five is going to point to this node number four rather than pointing to this node number six so we are breaking up this connection and then for the temp uh for the current variable we are going to flip it to this temp variable so again current is going to be ending up at this position so this is where current is and this is where temp is and then we will update the value of the previous node as well so this is where the previous node is so once this is done again we will repeat the same process and then we will Point U when the previous element reaches over here to the last node we are going to return this as the head so in the answer we would have reverse the original list so we would have a so we would have a link list like this and then once this is done all we need to do is now we we have two separate list we will need to merge them okay uh so for the merge of two link list you can check out that solution over here and let me quickly show you here as well we will start taking one node from each of the given list and uh first node would be node number one second node would be node number six then third node would be node number two and next node would be node number five and then we will take node number three and then we will take node number four from this list and now we realize that the second. next is actually null which means that now we don't need to take any more noes from any other link and we can whatever the answer is we can simply return this as our answer and this would be the final solution that we are going to use so let's see that what would be the time and space complexity in this case so for the time complexity we are actually doing three different things so first thing we are doing is that we are actually splitting the link list in two parts so that takes big go of and by two time plus second thing we are doing is we are reversing the link list which takes big go of end time and third thing we are doing is we are merging two l linkless which take B of end time so in general we can say that we are doing B of end work and uh in terms of space complexity we are actually using an additional uh link list this second link list to store the values and over here we are actually storing like half of the nodes which means that we need we will require B go of n by two additional space so generically we can write this as big of n as well and this would be the time and space complexity let's see that what would be the implementation first of all we are going to check that whether the given head is equal to null if that is the case we can simply return immediately and if that is not the case we will start with our implementation so first of all we are actually going to uh find the middle of the link list so let me create two list nodes for that now once we have our slow and fast list nodes we are going to run a while loop that while while either fast is equal to null or fast. next equal to null we will uh move slow and fast pointer up until that point once this is done uh we will have a new link list uh starting from this low end point and we will have to reverse that link list so uh in order to reverse the link list we will need a previous node so we will create a new list node called previous and we will assign it to the value null we will also have a current node node and we can initialize it to the value of slope and we will have a temporary node now uh we will run this Loop while the current is not equal to null so first of all we will store the value of current do next into temporary variable and after that we will uh exchange the values of previous and current node so current. next will get the value of previous node and previous node will come at the current node and current node we will need to move one step forward so we will assign it to the temp node where we initially store the value of the previous current. nextt and after this second Loop runs we should have our second list the slow list that we created to be reversed and now all we need to do is merge our first list and our second list so let's create couple of list nodes and we will create a list node called First and we will assign it to the value of the head and we will also create a list node called uh Second and we will assign it to the value of the previous node we will run a loop that while second. next is not equal to null so over here we will need to uh take the values from the second node and put it behind the first node so we are going to use the temporary variable for that so first of all in the temporary variable we are going to store the value of first. next and after that for the first do next value we will take a value from the second node and for the first node we will get the value of whatever the temp value we have we had already stored and after that is done we will repeat the same process for the second node as well so first of all we will create that temp to set up as second. next and then we will have second do next to point to the first node and in the end we will have second node point to the temp node and once that is done our code should be working as expected where we would have updated the value of this uh original given list node in this case we don't have to return anything because the return type is void we only need to update whatever the given input is so let's try to run the code okay seems like our code is working as expected let's submit the code and our code is actually pretty efficient and it runs faster than most of the other Java submissions so which is pretty good thing to do I would be posting this in the comments so you can check it out from there also on the GitHub I have created a repository of all the questions that we have solved so far uh and uh I have made it public so anyone can access it I will be posting this link in the comments as well so you can check it out this link and it can be helpful to a lot of other people so far we have around 60 to 70 questions and uh we we are growing it by the day [Music] Hello friends we are by Fang company so let's not stop lead Cod until we get there today we are going to do remove nth node from an end of the list Pro problem and this problem can be asked in many different ways and uh if we see the some of the companies that have already asked this question it's really nice uh so companies like Facebook Amazon Microsoft Google Bloomberg Uber Apple by dance Goldman Sachs and Salesforce they have all L this problem and uh they are some of my dream companies that I want to work at so that's why I'm making these videos I hope you enjoy them let's try to understand the problem statement this is a lead code medium problem and uh the title of the problem actually is self-explanatory that essentially we are given the head of a link list and we need to remove the nth node from the end of the list and then return its head so this is the whole problem if we try to understand it using an example in the example originally we are given a list called 1 2 3 4 5 and over here we are given that n is equal to 2 so we need to remove second node but remember we need to remove the second node or nth node from the end of the list so in this case this would be the first node at the end of the list and this would be the second node at the end of the list so we will need to remove this four and once we remove this four the answer would be something like this so this is what we need to return and uh in this case we will need to return this head pointer and then automatically it will Traverse towards the entire uh link list okay so let's see that what would be the most basic solution to solve this problem suppose we are given a custom example like this and we need to return remove second node from the end of the list now in this case this would be the first node from the end of the list and this would be the second node from the end of the list so we know that we need to remove this value number five but thing is uh the we don't we are able to know it because I have drawn in the over here and it is very evident to us but actually we don't know that what is the length of this given list so because we don't know the length what we need to do is that the answer is quite simple first we need to identify that what is the length and then we need to based on this given value n we will need to determine that what is the element that we need to remove and then it becomes easy for us to remove the element uh so what we are going to do is we are going to use a two pass approach and inside the first pass we are just going to have a variable called n l l and this L is to take care of the length of this given link list so in this case we would find that okay length is equal to six because there are six node present in this given example now once we know that there are six node present and our given n is equal to 2 we will need to remove the fifth node why fifth node because the node we need to remove that is going to be determined based on the formula that uh total length minus whatever the N is given + one why + one because we are using one index uh calculation over here that this last element this uh Sixth Element is also the first last element remember that this is the critical part that this is the first last element which means this is the second last element and because of that uh if we see over here that this L is equal to 6 this n is equal to 2 so 6 - 2 + 1 is becomes 5 and that's why we determine that we need to remove fifth note if we don't do this + 1 essentially 6 - 2 would be 4 and we don't need need to remove fourth node because fourth node is actually third node from the end of the list so that is why I gave you this long explanation now uh in the first pass we determine that okay this is the node we need to remove that this fifth node we need to remove so all we need to do is in the second node in the second iteration we are just going to iterate over this given list again till we reach the fifth node so the moment we find that okay our current node is fourth node which means that the next node is fifth node right so all we need to do is that whatever the fifth dot next is pointing So currently fifth dot next is pointing to this value number six we are going to append this value to this fourth. next so rather than over here this four pointing to this five we are going to remove this link and we are going to make this 4. to6 which means that this five is automatically removed from this given input list and that would be our solution but the moment you present the solution your interviewer is going to say that rather than using two pass syst suppose we want to complete this whole thing in just a single pass in just a single iteration then what should be your approach and this is the critical part so let me show you that what would be the most optimal solution let's use the same example and inside the same example uh first let's try to understand couple of things over here suppose over here in this case we are told that remove n is equal to 1 so how can we determine that n is equal to 1 is which element we can determine that okay this is the first element from the end of the list why because the very next element of this one is actually null and this is the key point which means if we are given that n is equal to 2 so which means we need to remove the second element from the end of the list so how can we determine we can determine it by saying that okay currently if we are at this position the second node from this one so next to the next node would be a null node and if that is true we can can determine that okay this is the second node from the end of the list and this is a very important property that we need to identify so basically what we are going to do is we are going to use two pointer system over here and inside the two pointer we are going to have a back pointer and a front pointer and the position of this back pointer and front pointer is determined based on whatever this n is given say if our back pointer is going to be at this position which means our front poter needs to be two steps ahead so two steps ahead from this back position would be 1 2 so this is where our front pointer would be at the beginning right and now since we have both of these positions set up uh all we need to do is just keep iterating to the next element and we are going to iterate until we find that this F or the front element is actually at this null position so let's see that what would be the the uh different pointer situation so now our back pointer has come to this position and again our front pointer is going to come to this position because back pointer jump from here to here and front pointer jumped from here to here again we front is not at null so again we will have to do one more uh iteration so now the back pointer will come over here and the front pointer will jump to one more step and front pointer will come over here again front is not null so again our back pointer is going to take one more jump and our front pointer is also so going to take one more jump so front pointer will come over here and over here we've identified that this front pointer is at null position so oh this is the critical point now this front is at null position so we have identified that okay now this back pointer is exactly uh enough spaces behind it that the whatever the next node is that needs to be removed and that is what we we are going to do so over here we identify that okay this back is at current correct position now what we need to do is currently back do next is the point that we need to remove so what we are going to do is simply we are going to uh point this current back do next so current back. next is this five value we are going to point it to whatever the back do next do next is and this would be the solution because back what would be the back dot back uh next do next it would be this one so rather than this four pointing to this five we are going to break this link which means that there is no way for us to reach to this five and now four is directly connecting to six and then we need to return the solution now we need to return the head of this link list so we are going to use the same point we are going we have been using so far that initially we are going to create a dummy node and this dummy node is going to act as a placeholder and that is going to store this head value and we are going to return that in the solution and let's see that what would be the time and space complexity in this case so for the time complexity it's only going to be Big O of L where L is the given length of the link list and in terms of space complexity we are only storing couple of parameters so it would be constant time and so we are not using any additional space so first of all we are going to create a dummy node and uh inside this dummy node we are going to give it some random value we are going to create dummy. next equal to head and we are using this dummy node as a placeholder now let's create our two front and back uh list nodes okay once that is done now we will need to bring the front node n steps ahead of the back node so we are going to run a for loop after this Loop ends the front and back are at the current position so now we only we need to run a while loop till the front element is not equal to null and uh all we need to do is just increment the value of front and back elements and once that is done now we are at the correct position for back to remove the next node so we are going to do back do next equal to back next do next okay and now we have removed the node that the nth node from the end of the list so we can simply return the head of the list and this should be our solution let's try to run the code okay seems like our code is working let's try to submit the code and our code runs pretty efficiently I will be posting the solution in the comments so you can check it out from there thank you [Music] so the problem we are going to solve today is called copy list with random pointer and if you see some of the popular companies who have already asked this question there are companies like Amazon Facebook Bloomberg Microsoft Apple adob Google bance eBay and Uber so that's why I'm paying my at most attention I hope you also enjoy the video this is a lead code medium problem and a very well- like problem basically in this problem we are being asked to copy a link list the thing is this link list is actually kind of a tricky link list it's not your common link list so if we know by a definition the link list that we understand has a structure that looks like this and uh the last pointer points to a null value so this is a typical structure of a normal a link list but the link list that we are given in this case is actually kind of little bit of tricky it is a link list that looks like a structure that that is something like this where in this structure uh we have the these two parts common so uh the green values uh over here are defined as the regular linkless pointers where we have a value and we also have a pointer that refers to the next item inside the link list the thing is at times we are also given these random pointers in our link list as well and the purpose of these random pointers is that they can point to anywhere and basically uh we need to keep track of all of this and uh on whatever the given link list that we are we have been provided we need to create a deep copy of that particular link list so this is what is being asked in this problem like if you cannot find or if you try to understand you can read this problem statement again uh by pausing the video right now or you can see some examples that I have shown over here so let's take a look at the first example as I was mentioned that this is not your typical common link list you see in this link list we are given one value for every single item but thing is with this value rather than having just a single pointer that points to the next element which is defined over here as this next pointer we are at times also given this random pointer as well that can point to any direction and we need to keep track of that and we need to create an exact copy so inside the input we are only given the head of the link list and uh this is the original link list structure behind the scenes and uh in the output based on this given head value we need to iterate over this entire link list and after iterating we need to create an exact copy of it so the if we see some structure of this given link list it is going to look somewhat like this so in the output basically we need to we are initially located at this position this is the head of the link list and we need to find a way to iterate over this entire link list in the exact Manner and create a deep copy so what does a creating a deep copy means means that if some node does not exist in our copy then we would create a new node take all of these values exactly as mentioned and put these values inside our new node and Mark it as the uh node in our sequence and then in the end we need to return the newly created uh link list so basically we are going to create like five different nodes uh every single node is going to look pretty much similar to this and they are all going to have a structure that is common over here and basically we are going to return return this as the answer so this is the whole ask there are few other examples given as well but they are not as important they are just kind of simple so I think you get a general gist of what are the things are being expected now we have already done similar questions like this and even say for an example if this was just a random uh link list it would have been too easy for us to solve this problem because we what we could have done is we initially start with the first position so with this head position and just keep on creating a new link list based on whatever the values we are iterating over right now because we we have a very 13 path in any link list where the first node is the value so we can just copy whatever the value this have so say an example this as value number five we can just copy this value as value number five and this as value number six we can also copy value number six and if this as value number 10 we can also copy value number 10 so these things are easy to do it is also easy to iterate to the next node inside the link list because we are directly given the pointer and using that we are also going to do the same thing and basically in the end when we reach to the null value we have reached to the end and simply we can return this as the answer now copying is not as simple in this case because we are dealing with a structure that looks like this where there could be potential possibility of cycle what do I mean by potential possibility of cycle say for example we are given these two nodes the values are 7 and 8 and we know for sure that this node is going to point over here and this node is going to point into the null value these two things are fact but it could be possible that this these two random nodes so this random node points over here and this random node points over here now if we try to iterate over this like a different version of this link list what is going to happen is that okay currently we are located at this head value so what would happen in these cases well the thing that would happen in these cases is that over here rather than coming back to this point we would from we might end up creating a whole new node with the same value 7 and we will try to iterate over this value and this uh over here again for this particular seven the value is pointing towards 8 so we might create a new node 8 and then we keep on repeating so basically because there exist a cycle over here we it is possible for us that while creating the copy we could end up in an infinite Loop and that could be disastrous so we will have to avoid that in any single cost okay so say for an example this is one of the input that we are given and we are trying to convert this and trying to create a deep copy of this basically we are given this as the head node right and now we need to iterate over this one now but the thing is in this case if you see uh there is the cycle present amongst these random nodes so this is a cycle and if we don't take care of it we will actually keep on ending it in an infinite Loop now the thing is uh in order to detect any Cycles we actually have a great way of doing it in all the graph problems right but thing is you would say that why am I mentioning graph over here because clearly this has been shown as a list or a linkless kind of a problem the idea is that rather than treating this as the linkless problem we can actually treat this as a graph problem where uh every single items can be treated as the form of vertices and edges because remember in the graph the two most important items are vertices and edges so for the vertices we can actually consider these input nodes of the link list as the vertices and for the edges we can actually consider uh these like next edges so the white edges and also these purple edges to be considered as the edges now in this case the edges are going to be directed and also unweighted now after doing this after treating this and trying to consider this as graph thing becomes much easier for us to keep track why uh so I have actually drawn this figure where I am visualizing this given input as a graph now in this case if we treat this as a graph it becomes very easy for us to copy and maintain uh why because the logic we can use in this case is that any single node we can actually create a visited directory or a hash set or a hash table where we keep track of all the nodes that we have visited so far so that way it is going to be great for us to keep track of everything and once we are done with all the nodes we can simply return the coped nodes so the logic we are going to use is okay let me make this little bit smaller okay so now let's try to iterate over this given node and we will start iterating through its head so this is the head pointer and every single time we are going to keep the same logic that we use in any single graph problem that first we will check that whether that particular node has been visited or not if it has been visited we will skip it if has not been visited uh we will add an entry over here and we will create its clone node and we will keep on repeating the same process now for every single node we have its edges so basically we are going to go in depth for search Manner and in depth for search manner we are going to go over all the neighbors of any single node and keep on repeating the same process and also because we are repeatedly doing the same thing we are actually going to do this recursively there is also an iterative way to doing it but thing is I like recursive better so I'm just going to show you the recursive way but remember there is also an iterative way and if we see this uh diagram basically there are just few functionality so these white edges they refer to the values of the next pointer and also these purple edges they refer to the values of the random pointer and uh let's start iterating so first okay first we are at this head pointer so we are at this node number seven 7 is not present inside our visited hashtag so first we will add an entry 7 over here and now let's just create a new node called seven so we will create a new node okay seven has been created now what is the next node of the new node this is the random pointer so where the random pointer is pointing towards it is pointing towards null value so if it is pointing towards the null value we do not need to add it to our visited set because remember null is not a new node but it's just like the end of the list so we'll just keep track of it so okay this one is like the null and also if we see in this case the next pointer we need to go over is the next Edge so next Edge is pointing towards value number 15 so we will check that whether 15 has been visited or not 15 has not been visited so we will add entry 15 over here now we will start visiting the 15's first Edge which is the random pointer so if we go depth for search recursively okay so this 15th uh random so let's let me just create a new node 15 over here and uh this 15th random Edge is taking towards node number 10 so 10 has not been visited we will add an entry 10 over here and we will also so create a new node for 10 and in this case uh the 10th next node or the node in sequence is the random pointer So Random pointer is pointing towards 13 so 13 has not been visited so we will go over 13 node so we will create a new entry called 13 over here in this case awesome so now we have all four of our noes set up and we have also iterated towards the random pointers so now at 13 when we iterate over the random poter of 13 it takes us back to the node number 15 and because this is taking us back to the node number 15 which means we will check that okay whether this has been visited or not yes 15 has already been visited which means we are in a cycle so we we need to break out from there so basically we do not care and we will not get ourselves involved in this one because we have already created a copy of 15 so because we have created a copy of 15 in this case so rather than creating a new node for this particular random node we will simply point it towards this 15 that we have had already created and uh that is how everything is going to work and then uh we basically have taken care of this cycle without getting secluded in the infinite Loop because we use the visited haset and then uh for every single node there is still the next node remaining that we need to Traverse over which is simple to do because for next node it is only pointing towards the next node and in this case from 15 after completing this sequence when we go to the next node okay this one is pointing towards value number 13 13 we already created a new node so we do not need to create anything we simply need to add the entry over here to point it towards the correct direction same with 13 next node is going to be 10 that is also good and in the end this 10 is going to point towards the null value and this is how our traversal is going to be completed and we would have created an exact deep copy of this particular link list with random pointers without doing any extra work and uh this is like a wonderful approach so all we did is we treated link list as graph and this is a great way to understand that how can two different data structures can be interchanged and uh we can use trick of the one uh data structure in the other data structure so I know this was a little bit complicated to understand but if you just like try to put some thought behind it uh things would make much more sense and uh if we see time and space complexity in this case the time complex is actually going to be big go of v+ e so V + a is the number of vertices plus edges why because uh this is a graph problem so this is what we we have to deal with and uh in general in this case rather than treating is as V plus e we can actually treat it as big of n where n is the number of nodes given in the input and in terms of space complexity in order to use the recursion we will have to use big of n space so this is a decently good time and space complexity well I just need to make a quick remark if we use the iterative approach the space complexity would become bigger of one and that case first of all we are going to create our visited hashmap and inside our hashmap we are actually going to do things a little bit trickily so as it's key we are going to keep the values of the old node and as it subsequent value we are going to cre keep the new copy newly generated copy that we have created so at any given moment we encounter any already visited node we can simply return its copy rather than creating a new node every single time so this copy random list method is also going to be our recursive method so first we will create a terminating Edge case that if the given head is equal to null we can simply return return null if that is not the case first we will check that whether the current head value we are at has it already been added to our visited node and if it has being visited we are simply going to return the subsequent reference value that we have stored inside our visited node hashmap if say for an example this is has not been visited so in that case we will have to create a new node now as a new node we are assigning it to the value of the current head value that we have received as an input and as its random pointer and next pointer current values are null but we are going to populate these now once this has been done since this is a new node this needs to be put inside our newly uh inside our hashmaps now notice in this case the head is the existing node that we are taking as an input and this node is the new node that we have created which means we are storing the copy as the value inside our visited node hashmap and as a key we are using the older value so now for this particular node we have taken care of the value of that particular node but thing is we haven't taken care of the uh next pointer and also the random pointer so we will do that in order to do that we will actually have to call the for the next pointer we will actually have to call head do next value and we will have to call our recursive copy random list method again so let's do that and same way for the random pointer we will also have to uh do the same thing basically once this has been completed we simply need to return the node let's try to run this code it seems like our solution is working as expected let's submit this code and our solution runs pretty efficiently in time complexity compared to a lot of other Solutions in terms of space complexity there can still be improvements made uh but I guess you can figure that out I'll be posting the solution in the comments so you can check it out from there thank you today we are going to do a very interesting lead code problem called add two numbers and if we see some of the popular companies who have already asked this question there are companies like Amazon Apple Bloomberg Microsoft Facebook Google Uber PTM TCS bite Dan Goldman sax and Airbnb so that's why I'm paying my at most attention I hope you also enjoy the video this one is a lead code medium problem and also very well- like problem basically we are given two non-empty link list that represents two non- negative integers or two non- negative numbers now we are told that these digits are actually stored in a reverse order and we need to find the sum of these two Val so this is the whole problem basically we are given just two numbers N1 and N2 and we need to find the sum of them so N1 plus N2 what is that going to be and we need to uh the tricky part in this case is both of them are given in form of like link list so we are given link list one and Link list two that's represents both the numbers and we need to add them and just create a answer link list and we need to return the head of this link list so let's try to understand this with an example and that would make things more clear so suppose over here we are given two link list L1 and L2 now notice that the numbers represent are over here are 2 43 and this one is 465 but we are told that these are actually stored in the reverse order which means that the least significant number that in a number system can be actually comes in the first position which means that the actually this one represents the number 342 if we want to put it in the decibal system same way this one represents the number 564 and now we need to do sum of these two values and whatever the answer is we need to store it in a similar link list kind of a fashion in reverse order so the logic is going to be quite simple let's try to understand this with an example so basically in this case the two link list are 2 4 and three so this one is link list one and linklist 2 is going to be 4 6 and 5 now if we want to do some of these two and store it in the result basically the answer is going to look something like this so first of all we are going to do some of these two values 2 and four so the answer is going to be six we can put six directly over here now in this case the value of 4 and 6 so if we do 4 + 6 basically the answer we get is 10 so 10 We cannot put directly as it is because we can only store one single character in this kind of a block which means we can only store zero over here and one is going to be a carry that will be forwarded over here so let's just add one carry over here so it's going to be 1 + 3 + 5 so it's going to be 8 and the answer is basically uh 806 but again since we have stored it in the linkless fashion the answer has been stored reversely but the actual answer is going to be 806 and basically this is what we need to written so this is a really simple problem to understand so say for an example these are the two numbers we are given I'm also noting them over here uh 708 and 503 and we need to do some of these one what is going to be the most most simple logic that we are going to use now given the fact that we are given these two as link list one and Link list 2 the logic we are going to use is just a simple arithmetic nothing more than that the most basic approach that we have studied in second grade this is what we are going to do we are just going to do simple arithmetic so the idea is that we are going to have a variable called carry that is going to keep track of that whether there is any carry that exist or not for any single pair of some that we are going to do that is one thing second thing we need to iterate over is uh until the possibility of whether we run out of both of these link list because it could be possible that this link list could be only of length three and this link list could be of length four we might have an additional variable over here uh something like 6 and basically this value is going to be 653 but sum is going to be amongst these values and this value is going to be by itself so we are only going to concern about this Value Plus the carry in case we need to do it but since this is not the case we are not going to do it but I'm just letting you know that these are the possibilities that could exist now we know till what points we need to run we know how to start and we know what are the values we need to do the sum so the logic is going to be that we are simply going to create a new dummy node so every single time we are going to create a new node now in this case I know the answer is going to be this so I I directly created this but typically it we will only be creating just one Domin okay at a time and then we would do sum of these two values and initial carry value is going to be zero so initially this carry value is going to be zero okay now let me get rid of these numbers they are causing some confusion so first we are doing 8 + 3 8 + 3 is going to be 11 since 11 is greater than 10 10 we are only going to put one over here and we are going to change the value of the carry now uh carry can only have two values either 0 or 1 why because the maximum possible number we can get amongst two digits is always going to be 19 why 19 because uh the maximum two digits could be 9 + 9 and we could have a previous carry that could be one so even if we do some of all of these It could only lead it lead up to the value of 19 so there can only be two possibilities for the value of carry so I'm just letting you know these things now uh in this case we have this value one okay now we we are going to move to the next value so if we move to the next value basically this is 0 + 0 but the value of carry is 1 so it's going to be 1 + 0 + 0 so the value is going to come one over here now again in this case since we have already used this carry and we do not have anything the carry value is going to go back to zero again now we have the value 7 + 5 7 + 5 + 0 so that is going to be value 12 but the 12 is still greater than 10 so we are only going to put two over here and we are going to have a carry that we need to go over and now notice in this case even though we ran out of both of these link list and we do not have any more values to iterate over we still have carry that is not zero so again we are going to add one more node over here and we are going to add the value of carry in this case and that is going to be one so in this case the answer is going to be 1 2 1 1 and this is like the numeric sequence if we go in this direction but since we are only needed to return the link list we can simply return this link list as the answer and this is the whole logic so the problem is really simple to solve easy to understand and nothing more complicated time complexity in this case the time complexity is basically going to be big go of maximum of either length of M or n where m is the length of this one and N is the length of this one so whichever is the maximum value we need to iterate those many steps so first of all we we are going to create a new list node called dumy node this dumy node is going to act as a placeholder for our actual answer now we are also going to create a new list node called answer and we are also going to have a variable called carry and the initial value is going to be zero now we are going to run our while loop and inside our while loop we are going to keep on running until we have values in either L1 or L2 or the value of carry is not zero inside the loop first of all because these are list nodes we will have to to create two integer variables called X and Y where we will store the value of the subsequent list one and list two variables if they are not null and if they are null we are going to store their values as zero we're also going to initialize a variable called sum and we are going to do x + y we are going to calculate the value of carry so for that we can only do sum divided by 10 and we will get the answer now for our answer node we will have to add the value of the sum that we have calculated but it could be possible that the value of the sum could be greater than 10 and we only need to store a single digit between 0 to 9 so what we can do is we can uh inside the answer do next we can simply store the value of uh the sum modul by 10 and now for the present pointer we will need to update the pointer inside the answer list so we are going to move to the next element and same way we will also have to update the value of the L1 and L2 do um to move to the next nodes but we will only do it if they are not null basically that's it this is the whole meat of the operation and now all we need to do is we simply need to return the value of the dummy. next because dummy. next points to the first value where the answer node starts recording all the values let's try to run the code we are making a mistake so inside the sum we are not actually adding the value of the carry so we will also have to do that okay seems like our solution is working let's submit this code and our code runs decently efficiently compared to a lot of other Solutions so this is a very good approach and I would be posting the solution in the comments so you can check it out from [Music] there Hello friends we are downloed by Fan company so let's not stop lead coding till we get there today we are going to do linkless cycle problem so basically it is a problem to detect cycle inside the link list and this problem has been asked by a bunch of different companies so let's see that what are my dream companies that have asked this problem uh it contains the companies like Amazon Microsoft Shopify Goldman XX that we recently got rejected at uh Google Bloomberg Apple Facebook Yahoo plunk and eBay so these are some of the companies that I'm really interested to get a job into and uh that's why I'm paying my at most attention I hope you also enjoy the video so this is a lead code easy problem and it is really simple to understand basically we are given the head of a link list and we need to determine that whether this link list contains a cycle or not now first of all we need to understand that what is the property of a link list B basically inside the link list we are given two items first item we are given some data point that represents that particular node inside the link list and we are given the information about the next node inside the given link list and that is how link list keeps on progressing so we will keep this in mind I like hopefully everyone should be uh familiar with this one and now the question is that we need to determine that whether inside our given link list does there exist a loop or not so suppose we are given a link list like this and we in this case we can clearly see that there exists a loop between this four and this two the question is that how do we detect that there exists a cycle and uh first solution that comes to mind mind is the solution that we have been using at different graph and uh some other problems so basically what we can do is at any moment we are given this head position so what we can do is we can create another data structure uh called hash set and inside this hash set we are going to keep track of all the visited nodes uh that we have passed so far and what we are going to do is initially first of all we are going to check that whether at any given node we are currently at if that exist inside this V visited hash set or not if it does not exist we will add it to this visited hash set and we will keep moving forward so at any moment if we encounter the same node we can clearly determine that there exist a cycle so in this case first of all we will check that whether this one exist in the visited headset it does not exist so we will add one over here then again we check for two two does not exist so we will add two over here then again we check for three three does not exist so again we add three over here and again we check for four so four also does not exist so we will add all four entries now from this four the next value it points to it actually points to this value number two and whenever we check that whether this two exist or not we can clearly see that two exist over here and we can immediately say that because we came back at a node that we have already visited before inside the hash set we can determine that there exist a cycle and in this case we will return true that okay yes there exist a cycle over here and uh that would be our solution now this solution is perfectly fine it works okay if it we calculate the time and space complexity the time complexity in this case is going to be big of n because we are iterating over all the nodes just one one time and the space complexity in this case would be big of n as well because we are using this additional visited hashset uh to detect that whether there exist a cycle or not the next thing that your interviewer is going to do is he is clearly going to ask that solve this problem without using this additional uh item uh additional space and the space complexity should be big of one so let me show you the most optimal solution where the space complexity would be bigo of one and time complexity would be big go of N I have a short announcement I have recently created a GitHub repository uh the link is in the description and I will quickly show it to you as well so this is the repository that I was talking about and I have left it public so anyone can access it it contains list of solutions of all the lead code problems that we have solved so far uh so you can click on any problem and you can go to its solution and it will contain the Java solution for that particular problem that is acceptable at lead code our aim is to see this list growing and uh I would be posting all the solutions that I solve and uh hope it helps other fellow coders and uh our aim is to get into Fang and hopefully this can be a big stepping stone towards that direction basically what we are going to do is we are actually going to have two point that iterate over this given link list and we are going to have a slow pointer and a fast pointer and the aim is that at any moment this fast pointer is always intended to stay ahead of the slow pointer and if we identify that this fast pointer actually reaches back to this slow pointer we can determine that there exists a cycle let me show you how so what we are going to do is we are at this head position so we are going to first of all initialize our slow pointer and our fast pointer at these positions so uh slow pointer would be at the first position and fast pointer will always start at the second position now we are at this position we are going to have one more condition that slow pointer will always do one jump so slow pointer will always do slow plus one so it will always go to next node but for the fast pointer we are actually going to have fast pointer do two two jumps so fast pointer is going to do fast pointer plus two nodes two node jumps and let's see that how things will turn out in this case so initially we are at these positions now this first pointer makes a makes two jumps and slow pointer makes one jump so their corresponding position change so slow pointer will reach over here and meanwhile fast pointer actually made two jumps so fast pointer will end up over here now the in the next case the slow pointer again is going to make one jump so slow pointer will reach over here and this fast pointer is going to make two jumps jumps so fast pointer will make one jump over here and second jump it will reach over here so in this case fast pointer will also reach at this place and slow pointer also reached at this place so over here we determine that this value at this fast is equal to value at the slow node and because we identify this condition this can only happen true if there existed a cycle somewhere and because there existed a cycle we are able to determine that okay there exist um like this fast and slow reach at the same point they met at the same node so that's why there for sure there has to be a cycle uh what happens if there does not exist a cycle so so say for an example in this case uh again let's just go back to this scenario that okay this is the list list we are given and that does not exist a cycle and let's add one more node over here we'll just uh name it number five and this is the whole link list we are given now in this case again this is the slow pointer this is the fast pointer and we are always going to have a terminating condition that either if slow reaches at the end or if fast reaches at the end at any given moment we reach to the end of the list and we find that the value of this slow or fast pointer is actually null if that is the case we can determine that uh we are able to successfully Traverse over the entire link list without detecting a cycle and that would be our final solution so in this case uh slow is here fast is here let's make one jump so again so now the slow would be here and fast would actually be here now again let's just make one more jump so in this case uh slow would be here but fast would have already crossed this potion so fast would be somewhere over here the node is null which means immediately we can determine that because we find that the fast pointer was at null value that there does not exist a cycle in this case and we can uh we will return false in this cas scenario so this would be the most optimal solution for this problem it is very easy and very trivial to understand as long as you get this trick and if we calculate the time and space complexity the time complexity would be bigger of n because in any case we will have to iterate over all the nodes in terms of space complexity apart from using couple of uh additional variables we are not using any more space so we can say that the space complexity is actually constant time we go of one and this would be the most optimal approach okay so first of all we are going to check that if the given head is equal to null we are going to return false so this would be an edge case that we took care of now we are going to create two list nodes uh one is for slow and we are going to initialize it to the head position and second one is fast and we are going to initialize it to uh next POS uh the second position okay now we are going to run run a while loop that while slow is not equal to null or uh fast is not equal to null we are going to keep it rating over and we are going to check that if the fast. next element if that is null we can also return false immediately if that is not the case if at any point we identify that the value at fast is equal to value at slow if that is the case we can immediately say that there exist a cycle and we can return true otherwise we'll have to update the counter so slow would be slow. next so because we are incrementing slow by one value uh but for fast we are actually in incrementing fast by two values so fast would be fast. next. next and uh that's it and if at any moment we are able to get out of the loop we can always return false and uh this should be the solution let's try to run the code okay seems like our solution is working let's try to submit the code oh okay we are going to check that if fast is equal to null or fast. next equal to n okay seems like our solution is working and it's actually pretty fast it's actually uh it runs in 0 millisecond so 100% faster than all the other solution and even in terms of memory usage we are beating out most of the people because over here we are actually ending our Loop early uh by using this these both these conditions and uh again inside the GitHub I will be providing the solution to all these problems so you can go and check it out over here I will be posting this link in the description and hope this video helps uh all the other communities that I feel so dear for and uh not stopping till we get into Fang see you next Hello friends hope you're are having a fantastic day today so now once again we are going to do an awesomely lead code popular I can't speak so let's get started with the question so the lead code problem we are going to solve today is called find the duplicate number we can see that this one is a medium problem and also extreme well like problem on lead code the problem statement is quite simple we are given an array of integer called nums that contains n + one integers where each integer is in the range of 1 to n now we are told that there is only one repeated number in this nums array that we are given as the input so we need to find that what is that repeated number on top of it to make things more compelling we are given two conditions that we must solve the problem with without modifying the existing array so that is option number one and second one is we must solve this using an constant extra space so we don't want to use any other data structure so let's try to understand if this is the input we are given currently this input contains seven element and we can see that in this case we are given values one up up until six but the values there is one value that is being repeated and the repeated value right here we can clearly see is value number four so in this case we need to return return four as the answer that four is the repeated character that we have been able to find so really simple problem statement now let's quickly try to understand the Brute Force approach and then we will build our Solution on top of that so the Brute Force approach is actually very simple to understand we can just simply create a new hash set and inside this new hash set we will first check that whether and the entry we are trying to iterating over if that is already present inside the hash set if that is the present that has to be the repeated element if that is not the present we can move on to the next element so first we find Value number six it's not present so we add it to six then we find Value number three once again we find Value number one once again we find Value number four and value number two so so far none of these values were present inside the hash set so we added them next we identified value number four so four is already present inside the hash and we can check that in big off one time which means because this is already present so in this case we can say for sure sure that four is the repeated element so this solution works well in big of end time which is great but the issue is we are actually using an additional data structure to store the value of this existing array so this is this is basically not allowed so over here space complexity is going to be big go off n so this is not a good solution let's try to see a better solution where we can actually make changes to the existing array that we are already given once I know that we are not supposed to do that but this is one of the way where we can find the solution very easily the idea is that at any single index position we try to go to its subsequent uh index value and keep on repeating the same process So eventually it should be able to lead us to the repeated person so in this case we can see that if we go to element number six um on the position number six we actually have value number five located which means we are going to swap the values so the value we are going to swap over here is that five would come on this place and six would come on this place so in this case we would have on position number zero element number five located and so on and so forth so we would keep on swapping the elements so now this one will become six even eventually this one will become four and this one will become uh four as well So eventually we would be left with element four hanging someplace so the moment we identify that we can say for sure that four is the repeated character now the problem with this approach is that in terms of swapping the elements we can actually complete this Pro problem in B go of one space complexity but we would be actually modifying the input array so this is also not a legitimate solution I mean the solution is legitimate the other thing is if you can find this solution in any of your interviews the interviewer would be more than likely to be happy with this this approach but the thing is now we are we are trying to find the most optimal solu solution without modifying the array for that we are actually going to take use of a very popular technique that we have seen in a link list so in any particular link list whenever we had repeated characters we actually were able to solve that whether we have a cycle inside the link list or Not by checking a very popular algorithm and that algorithm is called a tortoise and hair algorithm where we simply take use of two pointers one is a fast pointer and the other one is a slow pointer and we iterate fast and slow pointer over the link list until the fast pointer either reaches to the null value or we identify that fast pointer and slow pointer meet at some position so let me quickly go over the solution uh and then we will understand that how can we utilize that fact for our approach so the idea is that let's say that currently I have I am given one particular link list right and the values are quite straightforward the thing is I realize that in this particular link list this value number four once again points back to Value number two so which means in this case I can actually point value number four back to Value number two so in a sense I can say that value number two is actually present twice or it is the repeated element now I need to identify that whether there is a repeated element or not the idea in for a typical link list is that you start with a fast pointer and slow pointer both at the same location fast pointer is going to do two jumps at a time meanwhile slow pointer is only going to do one jump at a time so during the first iteration fast pointer is going to end up over here during the second iteration slow pointer is going to end up over here okay now we are going to keep on repeating the same process so during the next iteration fast pointer is going to go to four and once again go back to two so fast pointer is going to end up over here but meanwhile at the same time slow pointer is also going to make a jump so slow pointer will end up with one jump over here during the next iteration fast pointer would end up over here and at the same time slow pointer would also end up at the same position so the moment we realize that fast both fast and slow pointer are at the same position which means we can see for sure that there is a cycle inside this given link list so now the thing is this only confirms that there exist a cycle inside the link list but we don't know for sure that what is the repeated element so so repeated element in this case is value number two but the thing is there is a very easy way to find that repeated element as well where we identify that fast and slow pointer met at this particular position right uh at uh value number four so the thing is what we are actually going to do is that instead now currently fast pointer is just going to stay inside the loop but we will need to have slow pointer to come outside the loop somehow so let's say that our slow pointer comes out inside of the loop it is right now over here and fast pointer is now inside the loop now we are going to have fast pointer just hop one element and slow pointer also hop one element if we do that actually the funny thing is that mathematically the fast pointer and slow pointer both would end up exactly where the repeated character lies or exactly where we are able to identify the cycle and we can see it over here and we are going to see it in couple of other examples so you can understand that my hypothesis in this scenario is correct so now currently we are only going to do one jumps because we have already identify the the element now in this case okay currently this F is located over here this slow pointer is located over here if slow pointer makes one jump slow pointer reaches over here if fast pointer makes one jump fast pointer is going to end up over here and this has to be the repeated character because we identify both a slow and fast pointer ending up at the same place so now trust me this solution works we will try to understand this with couple of examples but first let's understand that this solution was actually really good and simple that it worked for a link list in the input we are actually given an array so how do we deal with this one the idea is actually quite simple uh and what I'm suggesting is that instead of treating this whole array as set of an array we are actually going to make use of the idea of our second example where rather than swapping the values we will just try to create the links and how we are going to create the links based on So currently let's say that in this index number zero this is the zeroth value so we are going to treat it as node zero and this has value number six so we are going to assume that zero points to node number six then six has node number Val five so six points to node number five and this using this logic we will try to visualize this as a linkless type of variable okay so let me just show you what I mean and then it would make much more sense so let's assume that okay currently we are at zeroth index So currently our zero index now it is pointing to index number six okay index number six now in this case is pointing to index number five five is once again pointing to four four is once again pointing to Value number two two is pointing to Value number one and one is once again pointing to Value number three and once again again three is pointing back to Value number four so rather than doing this we can just say that three is pointing back to the value number four and in this case we know for a fact that four is the repeated character because this is where the the cycle starts so now let's just start running our algorithm we are going to have our slow pointer and fast pointer both start at the same position slow pointer is going to make one jump meanwhile fast pointer is going to make two jumps once again repeatedly same thing is going to happen that fast pointer is going to make two jumps and slow pointer is going to make one jump so let's also quickly do that so now currently we have our slow pointer over here our fast pointer over here once again fast pointer makes two jumps so fast pointer ends up over here slow pointer ends up over here okay uh once again fast pointer is going to make two jumps so now fast pointer is going to cross inside the loop so fast pointer would be one this is would be the first jump and this would be the second jump so fast pointer is going to end up over here same way after making one jump slow pointer is also going to end up over here which means we identified the place that both fast and slow pointer met okay now because fast and slow pointer both met at this place we know for sure that both fast and slow pointer are currently inside the loop we will have to find a way to break for Value number or slow pointer outside the loop so we are actually going to start slow pointer at the beginning of the loop and now we are simply going to do one jump just like we saw inside the link list example so slow pointer will take take one jump fast pointer will take one jump once again slow pointer will take one jump and fast pointer will take one jump and once again when slow pointer takes one jump fast pointer will also end up at the same position and this index position has to be the repeated character and we found the culprit that we were looking for so this is the whole approach to solve this problem if you want you can take as many examples as you want this distance and where the place where both fast and slow pointer meets up uh distance from there to the starting pointer is always going to remain same and this is going to allow us to find the duplicated item without using constant without using extra space or without modifying the existing array so this is a pretty good equ question to open up your mind and open the horizons of what can be different possibilities how can you start understanding that what type of solutions can be there so that's why this is pretty popular among stop tier companies so if we see time complexity it's pretty obvious it's going to be big of n because we are simply going to iterate over the given array like couple of times one to find the uh matching point and second one to find the the duplicate number okay and space complexity we know that this is going to be biger of one and uh now let's quickly see the coding solution for this one so the coding solution is actually quite simple and straightforward uh we are going to have our two variables fast pointer and slow low pointer initialize at the very first element then we are going to find the intersection between two points so we are going to turn over while loop that while slow is not equal to fast and then we are going to have slow pointer make one jump meanwhile fast pointer is going to make two jumps once that is done and we do find the intersection now fast pointer is inside the cycle so slow pointer we are going to kick it out of the cycle by marking it initial position as zero and then we are simply going to check that while slow and fast are not the same we are going to a slow pointer iterate one step and fast pointer also iterate one step in the end we can simply return either slow or fast because both are at the same position so we will try to run this code okay seems like our solution is working let's submit this code and our code runs extremely fast compared to lot of other Solutions and it's especially difficult for a popular question like this so yeah you can imagine once again the coding solution is going to be present inside our GitHub repository so feel free to check it out from there thank you hello friends hope you're are having a fantastic day today so now we are going to do a very popular lead code problem called lru cache and this is a very well- like problem and it is a lead code medium problem now this problem can be asked in two maners this is a very popular system design con constraint as well it's very simple for a system design but still it is there and also uh it is a lead code problem so it can also be asked in your technical interview so I ask you to put higher attention to this problem because it can be asked in two different types of interviews now let's understand the problem statement basically we need to create a data structure that follows the constraint of a least recently used cach so first let's understand that what are going to be the constraint for the least recently used cach the simple thing is purpose of cash is to store some values let's assume that currently we have this cach and we can store three values inside the cash so the idea is that first I add value number one then I add value number two and then I add value number three now because value number one was the very first value that I entered or it is the least recently used item in the cash because relatively number two and number three have been used after being after number one was being used so number one is the least recently being used value so if I have to add value number four inside the cash I need to kick out one and I need to add four over here but in this scenario now the least recently used item is going to be value number two and if next element is five I need to enter Then I need to kick out two and add value number five but currently now this three is the least recently used but say for an example for some reason I ask this cash that hey get me this value number three in this case now this three is no longer the least recently used value now the least recently used value is going to be this value number four so in case if I have to enter value number six in this case now again I'm going to kick out value number four and add value number six over here this is the constraint of least recently used cach and this is what we need to implement but now let's go back to our problem statement and understand what exactly being asked us to do so number one thing is we need to create a class lru lru cach class where we need to implement few methods number one method is a capacity method so the capacity method defines that this is going to be the size of cash so in this case currently our capacity is three and this is what we come up with okay next one is that we need to create a method that gets any particular element from the key uh from our existing cache now the thing is the value we are storing inside the cache is actually a key value pair uh kind of the thing so in the input we would be given values like 1 one so in this case uh the value we need to store is uh key value pair that is 1 one this is the whole node where one is defined by the key and its subsequent value is value number one okay now uh in order for us to put the value now if we have to add a new value inside our cache then we are given some more constraint number one constraint is that we need to update the value of the key if the key already exist okay so that is number one constraint number two constraint is that if the key does not exist then we need to add the whole key value pair inside the inside our existing cache and for some reason if we move out of the capacity then we need to evict or we need to kick out the least recently used key so the same thing that we just saw in the example okay so now let's try to understand this whole scenario with like a slightly broader case and we will try to understand that what are the things we need and what are the constraints we have and how can we actually start implementing these methods now for all of you I must know that the moment you heard that we are using key value pair the number one thing that comes to your mind is that we are actually going to use hashmap and you are exactly correct in order to store all the values inside the cache we are actually going to use the hashmap now the thing is in the in the hashmap the typical structure is that we have a key and we have Associated value now in this case the node we are trying to store the node is actually structured as a key value pair in itself and this is going to be the value and the key is going to be the same key that we are being given inside the node that we are going to use but one different thing we are going to do is that instead of storing let's assume that currently the the value of this node is that key is one and value number is five if this is the value we need to store we are going we are not going to store it like this that number one as the key and value as number five no this would be correct but we will not do that instead what we would do is we will see that what is the pointer location of this node and we are going to store the pointer location that points to this particular element and it would be the same thing because we are using the hashmap so accs is always going to be big off one we can always find this value in big off one time but this is going to be greatly helpful for us in order to maintain the order in which the elements came in this is the most important part because we are not only storing the values inside the hashmap and Kicking the values out of the hashmap we also need to keep track of that what was the least recently used item which means at the same time we will also have to keep track of that which was the most recently used item because of the get operation you understand my point that what I'm trying to say because remember we need to implement three methods number one method is a capacity now capacity is really easy to make sure because that is the that is going to be the size of our hashmap that we are going to implement so we will never be able to exceed our capacity that is number one that is has been taken care of second method is the put method okay put method is also relatively easy that I just explained that we as a key we are going to store the key as a pointer we are going to store the node that we are going to point next method is the get method this is also very easy because we know that in the get we are being asked that hey uh this is the key and fetch me the whole value now inside the hashmap it is really easy to fetch out values we can do that operation in go off one time let's assume that currently we have a value like two and uh its subsequent pointer that points to the value of 2 and five in the node if we are being asked to fetch this value we can fetch it very quickly in B of one time but the problem is when we have to for this put operation when we run out of the capacity then it in that scenario we will have to do an eviction now for this eviction we need to keep track of that what was the least recently used element that we that we came up with and in this case first instinct is to use a simple Q because let's assume that for a second we don't have this get operation okay let's assume for a s simple second now what would happen is currently we have our hash map now inside the hashmap we need to store the values of key value pair okay and what we are going to do is let's assume that the current capacity is three okay so let me add three blocks same way the current capacity of the Q is also going to be three now number one thing is first value we are trying to enter is 1 one so let's assume that I'm entering value 1 one over here same way the very first entry I'm going to enter inside the que is going to be one because of the key second value is 22 once again second value is two next value is 3 3 once again the value is three now let's assume that there is value number four I'm trying to insert what value should I evict it's very simple the very first value that entered inside the Q has to be the first value that gets kicked out of the Q so this is very simple to implement but but the problem is that currently this sequence is fine but the moment I apply the logic of get and now in this scenario let's assume that I decide to get value number two okay let me add this value number four before okay so let me go ahead and quickly do that uh okay I added value number four over here I also got rid of one and I adjusted the flow of 2 and three okay so now I adjusted the flow of 2 and three and four and now I have already added the value number four now the thing is I apply get operation currently in this scenario the least recently used element is value number two that is very simple to understand but now if I do get two immediately two becomes actually the most recently used element because I just access two so now what would be the new flow of the Q is that it's going to be two 4 and three and now suddenly three becomes the least recently used character and in this case if I have to kick one value out I can also kick that out basically if I want to add value number five in this case now I need to kick value number three out now the question is you must be thinking that hey even with the Q we can actually implement the same thing what we will do is whenever we are being asked to run a get operation all we need to do is we first need to find the value that is currently present inside the existing Q move it to the very first element of the queue and shift all the other nodes one step forward and then then also this logic would work but that would be a suboptimal approach why because hashmap is going to run in bigo of one time no issues with that Q typically it is going to run in beo of one time because we are simply popping elements out from the be from behind the scenes but when we have to do the get operation we need to iterate over the entire Q in order to find the position of that element and that operation takes big go of end time and if we see the problem statement we are very explicitly being told that the functions get and put must run in on an average B off one time complexity so we need to take care of that scenario so now let's just break down the same problem and try to come up with the thinking that what are the things we need what are the things we have and what how can we make the solution better this is the approach you should be thinking in your actual interviews as well and that is why I created this whole 10 minute Preamble of the whole things that we are now going to come up with the optimal solution so in this case once again I we already mentioned few things that we are using hashmap in order to store the values now you will understand that why instead of using hashmap to store just the values why am I storing the pointer of that particular value now it will come to your sensus okay what I'm suggesting is that currently remember we need to keep track of two items number one item is what is the least recently used item number two two item is the moment we use the get operation we also need to keep track of what is the most recently used item and there is going to be all of these bunch of different element that fall between each other but basically the moment we are accessing any particular element that becomes most recently used element the moment we want to kick out any element we kick it out from the least recently used element which means we need a data structure where we can actually work on both sides of the cube to either enter the value or remove the value and we need to do it in Fast and efficient manner and for that the very simple thing is one of the most basic data structure that is a link list but this is not a simple link list we are actually going to use a doubly link list and how this W link list is going to help us to do solve all of this uh issues let's think about it so now let's understand that suppose currently this is our hashmap where we are storing all the values let's assume that this is our W link list okay and currently for our hashmap once again the capacity is three now why why are we using pointer instead of actually using the value that will come to your mind very quickly so number let me just add few values okay number one number two and number three these are the three values and let's assume that for these three values I'm marking as pointer 1 pointer 2 and pointer three as the three nodes that contain all the all the information now once again I'm marking these three nodes over here point pointer 1 pointer 2 and pointer 3 okay and currently inside our W link list as well because we added value sequentially in the same sequence we are going to have okay so this is our least recently used item and this is our most recently used item okay now the very first item we have in the least recently used is going to be pointer one or the value one or the node one okay you can think of it all of these things so basically value one and one same way second is going to be P2 basically value number two and two and third one is going to be pointer three that is going to be 3 and three now the thing is where this pointer would come into useful is when we have to change the positions because same logic will come to your mind that hey in the Q why we were not using Q because in order to find any particular element we had to jump through all of these places and that was causing big off end time but in this case we have the additional benefit that because we have the hash map based on any particular key location we can directly find that what is where is that particular value is located inside the existing Cube and all we are concerned about is to storing least recently used and most recently used values so now we are going to start manipulating these values so let me just clean this up a bit and now we are going to start working our magic now let's assume that currently we need to add add value number four in this case okay so we are going to add value number four over here once again now the logic is quite simple we are simp because least recently used value we already know that that is P1 we are simply going to get rid of it but now what we need to do is we simply need to say that whatever the value that is because we removed the least recently used value which means we removed the head of the existing link list so the moment we remove the head of the existing link list automatically the second value becomes the least recently used value so now we have P2 that is least recently used currently next value is going to to be P3 and then we are going to have value number P4 as the most recently used value so let me update those values so p 3 and P4 okay currently we have these values Associated and subsequently we have pointers that point to those correct values now let's assume that for some reason we decide to access value number three okay we create another operation that is get operation get three now the moment I do get three operation suddenly now even though three is in the middle what I will in order to do the get three operation first I'll do that whether key number three exists inside the hashmap or not yes is it exists if it exists all I need to do is I need to fetch the value of the three so I can simply return that but at the same time I can go to this Pointer's location and I can say that hey whatever your pointer location is now you need to jump to the head of the uh or sorry to the tail of the link list because currently now you are the most recent recently used value and that can happen in bigo of one time because it's a w link list so we are just going to use the same logic and now in this case P4 becomes our second or like second least recently used value and P3 becomes most recently used value and we are able to find this value because we are using pointer so we are avoiding the scenario where we have to iterate over every single value inside the link list and saving up on the time okay now for the same scenario let's assume that instead of uh this now we are trying to add value number uh five okay so if I want to add value number five I need to kick out least recently used value I already know least recently used value is P2 and in the P2 because I'm storing the whole node it contains the value as two and two so all I need to do is that whatever the head position has the node I just need to go to that key position and the moment I go to the key position I simply delete or remove that key so now I'll get rid of this two okay I'll also get rid of this two over here now I my least recently used is automatically going to adjust that is going to be P4 and P3 and now there is going to be P5 is the most recently used because I can easily manage that and in this scenario now once again I need to enter the value five and P5 over here and that's it this is the whole logic of least recently used test case scenario and uh you can add as many nodes as you want the logic will remain same and now let's try to understand time and space complexity time complexity pretty simple to calculate we are using Okay so let's assume for capacity it doesn't matter because it is like a we are just allocating some value so this does not take part in the time and space complexity scenario now let's assume for the get operation so what we what are we are doing for the get operation if we want to get any particular value get three let's assume we are going to check that whether this key exist inside the hash map or not yes it exists now we can easily fetch the value from the pointer there is no issue with that but at the same time we will have to mark three as the most recently used value and that can also be done in big of one time and this hashmap can also operate in big of one time so get operation now works in Big of one time awesome now let's take care of the put scenario once again for the put scenario we will also have to repeat the same thing basically uh let's assume that now we have this value number six we need to add we realize that the capacity is full so because capacity is full we are going to go to the hash map first take whatever the head position is find what is the key associated with that because it stores key and value both and this key contains the value number four so go to Value number four kick value number four out add value number six over here and that's it you solved the problem and now this operation also happens in big off one time so this is the whole approach Ro now let me quickly go over the code now let's look at the code for our problem lru cache uh so first thing we are going to do is we are going to create a static class node where we are going to store the definition of the node that contains the values key and value on top of it we are going to keep track of the previous node and the next node for any particular node and this aligns with our W link list concept we also have a simple Constructor to store the value of keyn value that comes in as the put method now we have some variables that we need to Define so first variable is the capacity next one is a hash map now inside the hashmap as a key we are going to store the integer value of the node but as its subsequent value we are actually storing the pointer of the node and we are pointing it to the element that we needs to put in that this comes along as we understood during the explanation and then we have two dummy nodes that are head and tail where head is going to keep track of the most recently used and tail is going to keep track of the least recently used element and then we can simply manipulate those values next thing is uh for this is the method in order to instantiate the capacity so it is a very simple method all we are doing is just creating a hashmap of the same size on top of it if we have to Let's understand the logic for the get method in which we are given the key as an input so first thing we are going to check is whether this key exists in the hash inside the hash map or not this we can do it in big of one time if it doesn't exist exist we can simply return minus one if it do exist we can simply return the node value that is that is perfectly fine but before that we need to create or we need to put it as the most recently used value so we need what we are going to do is we are going to instantiate a temporary node that is going to be associated with the given key and for that we are now we are going to remove that from our W link list and we are going to put its position as the at the head value and both remove and insert at head values I have created helper method for those so this is the remove method and this is the insert at the head method these are just very basic uh pointer manipulations inside our existing link list now going back to our uh get method now in this scenario and in the end once this uh node has been mentioned as the most recently used node then we simply return the nodes value so that fulfills our get method next let's understand the logic for the put method that is slightly more complicated we are given the two input values for the node that we need to put in now first thing we are going to do is we are going to check that whether this existing key already exist and if it does we simply need to update the node associated with that so if it exists all we need to do is just assign a temporary node whatever the value of the new node is assign that to the existing value for for our existing hashmap key and then we need to remove that node pointer and insert it at the head because now this becomes the most recently used head used value if that is not the case and we need to enter the new value all by itself so first we are going to check that whether we are running out of capacity or not if we are running out of the capacity we are simply going to remove the last element that exist at the tail so that we can simply do it in big off one time because we can already always find that what is the value Associated or at the least recently used using our W link list and then we can simply remove that value and then we can simply add a new in either case now we simply need to add a new node inside our existing hashmap and after adding this new node we need to add this new node at the head because now this becomes the most recently used value so I know that this code looks simp like little bit complicated but overall the simple logic Remains the Same now let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs pretty fast compared to lot of other Solutions in terms of time complexity and also great in terms of space complexity so once again I will be posting this code inside the uh GitHub repository that we have and you can check it out from there let me know in the comments what do you think about this video do you think is there anything else I could have done to make it better I'm always open for the feedback so thank you so much for that and [Music] Hello friends we by F company so let's not up lead coding till we get there today we are going to do merge K sorted list problem and this is one of the most asked link list problem and uh if you just see that the number of companies that have asked this question is really huge uh there are companies like Facebook Amazon Microsoft Google Apple bite dance uh LinkedIn Bloomberg Tik Tok and uh more companies like Uber Goldman Sach lift Twitter Yahoo wish pler Tesla Roblox Pinterest Airbnb so these are my dream companies so that's why I'm paying my utmost attention I hope you also enjoy the video this is a lead code hard problem and it is one of the most like problems on lead code but in my opinion this should have been a medium problem and I'll tell you why now if we understand the problem statement basically we are given K distinct link list and each each link list is sorted in ascending order in the answer we need to merge all the link list that are given in one single sorted link list and then return that merge uh link list so this problem is very similar to a previous problem we did merge to uh sorted list so you can find that solution over here and if we see the example for this case uh basically we are given bunch of different link list and all of them are sorted so uh if we see this first first example we are given link list like and now we need to sort all of merge all of them in one single link list and that single link list needs to be sorted so if we see the answer the answer in this case is going to be that okay the smallest values are 1 one so they will always come first so it would be 1 1 then we will have 2 3 4 4 so 2 3 4 4 and then we will have five and six and this would be the answer that that we need to return in this case that is the combination of all three uh link list basically in the Brute Force what we can do is uh we are given few distinct number of lists so it could be like list one list two list three all the way up to list K these are the list we are given in the input what we can do is whatever the number of nodes they have we can take all of those node we can combine all the nodes we can put it in a giant list let's just name it as merge list in the merge list initially we put all the values together once and then all we need to do is if we just sort this given merge list uh then the sorted list would be our answer and basically that's the that's the whole solution this solution would work perfectly fine and we then in the end we can just return whatever the sorted list we have found uh okay what could be the issues with this problem like I I won't find too many issues because this is also a decently good enough solution if we see the time and space complexity in this case the time complexity is going to be bigo of n log n why n login because initially we will have to do big off n work to iterate over all the nodes inside the given link list different link list and merge them together uh so that takes big go of end time and plus it takes big go of n log end time to sort the given uh list so overall we will write them as big go n log n and in terms of space complexity the space complexity in this case is going to be biger of n because we need additional room to space to store one additional parameter uh of all the merge list before we sort it let's see that what could be another solution so in terms of the second solution uh suppose we are given three different list like this in this case k is equal to 3 because we are given three distinct values what we can do is at any point we can denote three different pointers to each location let's name them L1 L2 L3 and what we are going to do is our aim is to find the minimum value we already know that for these three values all the values are already in ascending order so the approach that comes to mind is okay let's just create our merge list and inside the merge list at any point we are going to compare all the values between this L1 L2 and L3 and whichever is the small we are going to pick that one so in this case Okay the smallest value is one so we'll pick one over here and then we will update the value of L1 okay so this is already done uh L2 and L3 will still remain same so now we have these three values that we need to compare so the smallest value is two so again we will update the L2 and uh this we are done uh so now we have these three values to compare so now again we'll add value number three and then we will be done with this one and we'll update the value of L3 so let me just do it do the whole thing and uh hope you you would be able to understand that what how how am I doing it okay so this is how we will progress and this would be our final merge list so we can simply return this one so this approach also works fine uh there is there are no issues with that if we see the time and space complexity in this one the time complexity actually becomes so suppose if we consider that all the elements in this L1 L2 and L three the total number of nodes are given n so we can say that the time complexity is going to be Big O of n times whatever the this K is given so in this case k is three so we can do n * K so it's going to be n * K and this would be the time complexity so why n * K because remember in order for us to enter any single element we will have to do K work we will have to compare all these three elements and at any point we find the smallest element we will have to update that value so suppose if if K is equal to 1,000 then we might have to compare 1,000 elements as was at once so that adds a little bit of complexity to it so is this approach good uh this approach is okay but not very good because as I mentioned that if we are given million elements as k then uh basically what we are doing is just big of n Square work while we already know that even in Brute Force we are able to solve this in big of n logn so why do we need to do n Square work okay so there is no point in doing that uh let's let's see that what would be the most optimal solution okay so suppose we are given three list like this and I know you are thinking that why I only put two elements in each list I'll just show you why uh basically what is our aim our aim is to find that all the nodes that should be merged and that merg merge list has to be in ascending order right we need to maintain this ascending order so one of the best thing that should come to your mind is that is there any data structure that already exist where no matter how many number of elements you put inside it whenever you start taking the elements outside they should be following this ascending order property and yes there exist a predefined element or data structure that can do it and that name is actually Heap so if we maintain a Min Heap in this case uh so the if we add all the values inside the Min Heap and then we start taking values or the nodes outside of the Min Heap it is actually actually going to give us the sorted list uh where it is the combination of all the merg elements let me show you how so let's create a priority q that will represent this Min Heap okay and now let's start adding elements one by one so first We'll add four and seven okay next element is three so the moment we need to enter three we will have the priority Q is going to fix by fix itself so it's now is going to be 3 4 7 okay now we need to enter eight so eight we can enter over here now this this node we have to enter is one so again when we need to enter the one the priority Q is going to adjust itself so now the solution is going to be 1 3 and the last node we need to enter is 11 so this we have all the elements inside our priority q and now because we have this priority Q set up what we can do is now we can start pulling all the values from the priority because remember the property of priority Q is that all the value values are entered at the back and they gets out from the front uh so now we will create a new merge list now inside this new merge list all we need to do is just keep on adding all the elements that are coming out of this priority CU so sequentially we will be adding 1 3 4 7 and all those elements and this would be the final solution that we need to return return and we can simply return return this as our answer and this would be the most optimal approach like this is there are other approaches that work in the same time and space complexity but why this would be an optimal approach because your interviewer would like to hear that okay you are aware about this Min Heap concept and you can use priority Q when needed so this sounds reasonably fine if we see the time and space complexity in this case the time complexity is going to be biger of n log n why n log n because uh in order for us to enter all the values inside the priority Q it takes a log and time and uh we need to do it for all the these n elements and in terms of space complexity the space complexity is going to be big of n because we need to use this additional priority q and uh let's see the coding so first of all we will initialize a priority queue and uh let's name it Min Heap so now we are going to run a for Loop and we are going to iterate all the list and all the nodes and we are going to keep on adding those inside our Min Heap and after adding the value to the Minh we will have to update the value of list as well so we'll do list is equal to list. next okay so after this Loop ends uh all the noes should be inside our uh Min Heap and now what we need to do is take all the elements out out of the Min Heap and put it inside our merge list so first of all we are going to create a dummy node uh that would act as a placeholder for so that we can call uh our head when we when we need it and this is the same trick we use in previous videos as well so you might be aware of it once this is done we will create our uh list node called merged list and for the merge we are going to uh assign the first value as d so that in the future we can call this dummy node to find the head of this merge list and now we simply need to run a loop that while there exist an element inside the Min Heap we will have to add all those elements to our merge list and once this is done all we need to do is just return the dummy. next and this should be our solution let's try to run the code okay seems like our solution is working as expected let's submit the code and our solution works pretty efficiently as you can see and I would be posting this solution inside the comment so you can check it out from there thank you and my aim is to empower every single person to be better at technical interviews keeping with that goal in mind today we are going to do a very interesting lead code problem called reverse nodes in a K Group if we see some of the popular companies who have already asked this question there are companies like Amazon Microsoft Apple Bloomberg Google Tik Tok Facebook bu Dan Uber Snapchat PTM and Tesla so that's why I'm paying my at most attention I hope you also enjoy the video so this is a lead code hard problem and also very well-like problem on lead code basically we are given the head of a link list and we are also given another value integer value called K now based on this given head of the link list we we need to reverse the nodes inside the given link list k at a time and we need to return the modified list there are also some additional parameters given which states that basically if we have the number of nodes that are less than K we do not need to reverse them let's try to understand this with an example if we see in this case we are given a link list and we are given the value K is equal to 2 now if we understand the problem statement basically we need to reverse the nodes inside this given link list K times at a time so in this case two nodes are given so we are going to reverse two nodes and then keep on repeating the same process so the idea is first we are going to reverse these two nodes whatever the answer is we will store over here then we will reverse these two nodes and again we will store that answer over here and since this one is only one node and we are given the value K is equal to 2 we are not going to change anything over here so if we see the answer in this case basically if we just reverse the these two nodes the reverse node is going to look like this 2 and one then we have the nodes 3 and four which are the two next K nodes or next two nodes so again we are going to reverse them and since this is only the single node we will not reverse them so this is going to be the modified reverse list that we need to return as the answer if we see basically we are reversing K nod at a time and at any point we identify the nodes less than K we do not do anything now the most basic thing we can do to solve this problem is first of all we need to check for the edge Cas scenario the HK scenario is that if the given number of K is actually greater than the number of elements present inside our link list if that is the case basically we don't need to modify the given input link list and we can return the answer as it is uh why we can do it because the given K is equal to 6 and we are being asked to reverse K nodes but in this case since K is greater than the given number of nodes present there is no way for us to reverse all six nodes which means we don't need to modify the answer as at all and we can simply return as it is let's now let's try to think about some logical scenarios suppose our given value is equal to K is equal to 2 3 something like that if that is the case what is the approach we will take the approach is quite simple first we will take these two nodes we will do the reversing function for all the remaining ones we will repeat the same process after we are done reversing these two elements which means first we will do like a reversing function and then for all the other nodes So currently this one would be pointing towards this three now for this new newly created list we would be able to repeat the same process if we repeat the same process now this time we will reverse these two nodes and again if we keep on repeating the same same process we will only be left with just a single node where which only contains one value which is again less than the value of K which means we don't need to change this portion if we see logically this becomes a very good candidate for a recursive approach why recursive approach because essentially every single time first of all we were considering all of these five nodes uh to do like K = to 2 once we are done iterating these two nodes we can get rid of them and now our input shrinks to the three nodes and then again we will repeat the same process and then again if we get rid of these two nodes we only are left with just a single node and then we need to repeat the same process which means recursively this is going to be a very beautiful approach to solve this problem now we already know the overall framework on how to solve this one but one key important piece of information missing is the reverse uh function that we need to perform in order to perform the proper reverse function first let's identify that what is the methodology we are going to use okay now let's try to figure out that if this is the given input link list we are given we are simply trying to reverse this whole link list we are not currently considering about the K values because we already know the solution so if we want to reverse this entire link list what is the approach we can take well let's try to see that what are things we have we currently have a headp pointer that points to the first value inside our link list now we since we need to do the reverse link list basically the reverse link list is going to have a new head and this would be the head of the reverse link list so we will also first of all we need to create a new node called new head and initially new head value is going to be null so let's just create a new head I'm going to mark it as NH and currently the value is null okay we will also need to find some way to iterate over the given input existing link list for that what we can do is we can create a pointer node and this pointer node we are going to initially assign it to the value of the head pointer and then we will use the pointer node towards to move towards the next values so let's just create a new pointer node in this case after creating these two values we will need to at any given position keep track of the next node because for the pointer node we will need to iterate to the next element at the same time using the pointer node we are going to manipulate the values of the new head VAR variable because we are reversing the link list so we will need to create a new variable called Next node and initially the next node value currently is null just understand for the sake of understanding that this is null and now we don't need the head node so after initial set up or initially setting up everything let's see that what would be the approach to reverse the given link list okay now first thing we are going to do is since we need to keep track of the next node we will first assign the value so we will keep keep the next node to be the pointer do next okay we set up the value of next node to be pointer do next so at this position the next node is going to be here okay now we also need to keep track of the value of pointer. next but the thing is since now we are trying to reverse the link list basically the pointer. next is going to point towards the new head so let's mark that so pointer do next should move towards the new head okay so currently the new head value is null uh keep it that way for now now we need to update the value of the new head so for the new head is going to be the existing pointer we are at so existing pointer currently is one so in this case the new head is going to be the value of one okay so let's just mark this value so new head is going to be the existing pointer value and in the end we need to move move this pointer to the next element how would we be able to do it using this next node because we already updated the value of pointer. next so we will need to move for the pointer to the next value which is going to be pointer is going to move to the next node so NN and this using these steps we would be able to reverse this link list easily so now after the first iteration this is the current setup we have that new head is located at one currently the pointer is located over here and new node is also here but during the next iteration the values will be updated so now let's update the values again so now okay new node becomes to the next value so this is going to be our new node now at the same time pointer do next points to the new head so currently this pointer two is pointing towards three which rather than pointing towards three now this two is pointing towards one so we are going to have a configuration So currently the new head value is one and we are going to have two point to the one this is the current logic we have okay at the same time new head is now going to move towards pointer which means that rather than new head having the value of one it is going to have the value of two so let me write this in a little bit separate manner so if I do that basically currently the new head is going to be the pointer value and the pointer do next we already Define it to be the previous new node which is going to be one okay so now this is the setup we have and also now pointer moves to the next node so next node is three so now pointer again moves to the next node so pointer is here next node is here again if we repeat the same iteration basically the next node is going to be pointer. next so this is going to be the next node now pointer. next is going to become the new head so pointer. next is currently pointing towards the uh value number two uh sorry value number four but rather than pointing towards value number four pointer do next is now going to point towards value number two at the same time new head is going to become pointer so now let's just make this changes as well now in the end we simply need to move pointer to the next element so now pointer will move to the next element and in the end if we repeat the same process again basically the next node will end up at null and we will have the new head to be value number four and since the next node is is null we cannot do anything so we can break out of the loop here and whatever the next head is we can simply return that but at the same time we reverse the given entire link list and this solves Mo the major concern of our Pro problem so now we already know that how to reverse nodes okay so after understanding all the small pieces now let's let's see that what would be the optimal solution basically for the optimal solution we have two options first option is that we use the recursive function and then things becomes much easier for us basically we take these two elements we apply the recursive function where we basically reverse them and after reversing we update our value and again repeat the same process for these three remaining items again we reverse these two items and then we keep the last item and then basically using the recursion and the reverse function we would be able to solve this problem quite easily now for the recursive approach if we see time and space complexity basically the time complexity is going to be biger of n because we need to iterate over the given input uh twice why twice because first we need to check that whether for the given input if the given value of K is greater than or not or less than or not and then secondly we need to do it for the reversing the K noes if we see space complexity the space complexity is going to be biger of one where sorry we go of n where we will use n space for the recursive stack so the next question your interviewer is going to ask you is that rather than using the big of n space complexity can you solve this problem in big of one space complexity so that is also very simple to do uh basically all we need to do is that at any given position first we will try to see that whether the given K elements exist or not if they exist then we will simply r reverse them and we can simply use like couple of while loops and do this iteratively and iterative uh the logic is going to remain the same but first we are only going to check that whether the number of K elements are present or not if they are present we are going to Simply apply our reverse function and after keep on reversing the values uh eventually we would be able to find our answer as needed and iteratively this is the answer we need to return return if we see time is space complexity in this case the time complexity is actually going to be bigger of N and the space complexities in this case is going to be biger of one now for the coding solution part of this particular reverse nodes in K Group portion actually I made a blender before I recorded the whole uh video explaining the code but I forgot to use my microphone and that's why I didn't record any any of the voice now I'm not going to do the whole thing again I'm I can just go through the code and then I'll post this code in the comments and also I can post this code in the GitHub uh repository that I have created and provide links for both of them so basically you would be able to see the codes now in this particular solution basically we are using the iterative approach by which we will have a better space complexity and uh definitely we need to we need a way to reverse a link list so I'm creating a helper method that takes in any list node as an input and a k value and return the the reverse linkless uh new head so this uh these are all the steps that we discussed in the uh explanation part of the video and we keep on repeating the same process and this is just just the helper method okay now let's move on to the main method now inside the main method first of all we are defining uh few of the variables that we need to keep track of different things so basically we have a variable pointer to that will iterate over the given entire list we are also keeping track of a k tail variable and what this K tail variable does is that whenever we are done iterating like any set of K nodes uh and we are planning to go to the next step so if we see on the left side of the screen suppose we have done iterating reversing this 1 and two node which means we still have nodes 3 4 and 5 to process so K tail would be pointing towards this node number two and we would be able to do certain things with that uh that we will see next in the code now first of all we are going to initialize a while loop that while the pointer is not equal to null which means this is the loop that runs over entire given link list now inside that first of all we have a counter and we also have pointer located at the head position we first check that whether uh the current count if that is less than K we will move the pointer towards the next element and keep on updating the value of K and now we would be at the position if the count is equal to K which means we are at the position where uh currently we will need to reverse the the nodes that are between those values so say for an example initially count would be zero at this value number one and count count would be two at this value number two and basically uh we need to reverse like these two values so we will use our reverse function and after in this condition is only there for the first case scenario because if we see in the output the head is always is going to be the reverse portion of first K nodes all the other K nodes doesn't matter so that is why this is to Define that what is going to be the new head value and then this checks that whether the K tail if that is not equal to n if that is not equal to null which means that the KT value is actually going to the going to point to the new reverse node value and that is why we are using the K tail variable and in the end we just update the K tail pointer and also the head pointer and keep on iterating the while loop so basically using the combination of these two we are able to solve this problem and in the end we are simply returning the new head so we will check that if the given new head is equal to null if that this is the scenario this will only happen if the given K is actually greater than the number of values present inside our uh link list and in that case we simply need to return the old head and if the new head is not null we need to return the new head value and this is the whole solution I hope the solution makes sense and now let's try to run this code so our solution seems to be working let's submit this code and if we submit this code our solution actually runs 100% faster than all the other solution and that is because the run time is actually 0 millisecond and even if we see in terms of space complexity this is really good so this is a very good solution uh again I will be posting this in the comments so you can check it out from there or you can check it out from the GitHub Hello friends we not employed by a Fang company so let's not stop lead coding till we get there today we are going to invert a binary tree lead code problem and if we see some of the companies where I want to work at who have already asked this question there are companies like Amazon Facebook Google Apple Bloomberg Microsoft Uber Goldman sax and Linkedin so that's why I'm paying my at most attention I hope you also enjoy the video so this is the lead code easy problem and also very well like problem on code basically we are given the root of a binary tree and we need to invert the tree and return its root back so let's try to understand this with couple of examples first of all we'll take this example so over here we are given a tree that looks like this where this two uh 1 and three are part of the tree where one is the left child and three is the right child so if we invert this tree we will get an answer that looks like this where two Remains the root because it is the root node but this three that was originally the right child will become the left child and this one that was originally the left child will become right child and this is what we need to return let's take a little bit more complicated example so over here we are given the root to be four now we are given that the left child and right child of this four is actually 2 and 7 and further down we are given more left child and right child for this 2 and 7 as well now if we invert those all of them we will actually get a result that looks like this where four Remains the common uh this seven that was originally the right child will become the left child and this two that was originally the left child will become right child and same thing will happen for these Leaf nodes as well and this this is the answer we need to return in the answer this is what the problem is asking us to do let's see that what would be the different approaches to solve this problem before we come up with the optimal solution let's understand a very important concept suppose this is one of the kind of a binary tree we are given and we need to invert this tree well if we see where here we are given a root node then again we are given some left child and we are given a right child now further down for this left child and right child they also have the children of their own and they also form a bigger binary tree so at any given moment suppose we are given this root node we are given this left child and we are given this right child so if we want to invert this tree all we have to do is whatever this right child is and whatever this left child is if we just swap them or if we invert them basically we are at least done with this root level and with this left child and right child level now again if we further break down that uh suppose this is the left child now we are treating this left child as a root so suppose now this is the root and this is the left child and this is the right child for this route so again if we want to invert them what we can do is we can take whatever the left sub tree and right sub tree is so in this case for this root the left sub tree is going to be this the right sub tree is going to be this if we swap them essentially we have taken care of up until this level for this uh inverting part and same way we can keep on repeating the process so now this becomes our root again we flip these two values and even for this level we have taken care of inverting the binary tree so this is what exactly I'm suggesting in us to do in order to solve this problem that we we starts breaking this given input into bunch of smaller inputs and start inverting binary tree in that manner so the idea is that for every single time uh we will have a root node we will swap its left and right child then again for if there exist any left and right child we will repeat the same process and keep on swapping those values which means that we are actually doing uh doing the changes recursively recursively we can actually solve this problem pretty efficiently uh let me quickly show you how suppose this is the input we are given and we are trying to invert this binary tree recursively so what we are going to do is suppose we will take initially this as the root node and for this root node we actually have a left child and we actually have a right child so what we are going to do is we are going to swap its values and we are going to swap the entire left sub tree and entire right sub tree then at any given moment as long as we have some nodes we are going to keep on treating them as different root nodes and then we will keep on Flipping their values or their children's values and at the end we should have a completely inverted binary tree so let's see that in action so first of all this is the root node and this is the left and right sub tree so what we are going to do is uh we are going to swap the values so we were we will have a tree that looks like this okay so so far treating this as root tree we have actually swapped these left subtree and right sub tree and we will get a tree that looks like this where you can see that this value three and two they are actually inverted but their subsequent children values they are not inverted and we will still have to repeat the same process so let's see that in action so now again uh what we are going to do is we are going to treat this three to be root child and we are going to repeat the same process with the six and seven so if we invert them we will get a tree that looks like this now we are going to treat the seven to be the root node if we treat the seven to be the root node actually it does not have any children which means we don't need to flip any more values now again we will treat the six to be the root node if we treat the six to be the root node again it does not have any more children so we can skip that now we will treat this two to be the root node so if we treat this two to be the root node it has children so we will have to swap their values and we will get a value that looks like this and we would have taken care of both of them now again this five and four does not have any children which means we can't do anything about it and then in the end this is going to be the answer we need to return so we can simply return the root value and basically we would have inverted the entire tree recursively so that is the approach we can use as an optimal solution there is also one more way to iteratively approach this problem but thing is I believe that for threee kind of problems the it the recursive approach is better than the iterative approach let me know in the comments if you want to see the iterative approach as well and I can make a separate video on that if we see the time and space complexity in this case the time complexity is actually going to be biger of n where n is the number of nodes that are present inside any given tree because we will have to iterate over every single tree to invert them now if we see the space complexity well at any given moment because of the recursive function we might have to store bunch of different node values and that would depend on the height of the tree so basically the space complexity is going to be big of H where H is the given height of any binary tree so because we are going to solve this problem recursively first let's create the terminating condition that if the given root is actually null we can return if the given roote is not null we are going to make the recursive call for right and left values so for right tree we are going to make the recursive call to the same function with the right child thing we are going to do for the left sub tree after that we are going to replace the values of left and right sub tree uh so now that should have taken care of all the cases and now we can simply return the root value and that should be it so let's try to run this code okay seems like our solution is working as expected let's submit this code and our solution is actually pretty efficient it's actually 100% faster than all the other solution and that is because the run time is actually 0 millisecond I would be posting this in the comment so you can check it out from there thank you hello friends we are still not unlo by a f company so let's not stop lead coding till we get there today we are going to do maximum depth of binary tree lead code problem and if we see some of the companies where I want to get a job who have already this question there are companies like LinkedIn Amazon Microsoft Google Facebook Apple Bloomberg and Uber so that's why I'm paying my atmost retention I hope you also enjoy the video so this is a lead code easy problem and also very well-like problem on lead code if we understand the problem statement basically we are given the root of a binary tree and we need to return its maximum depth now we are also given the definition of what a maximum depth is it is basically the number of nodes along the longest path from the root node down toward what's the farthest Leaf node that is the depth of the tree and uh if we try to understand this with an example suppose we are given a tree over here that looks like this in this case the maximum depth is going to be three why because the nodes at the root level is currently at position one or height one uh the root at this level is at depth two or height two and root at this level is actually at depth three so in this case we need to return three as the answer because three is the maximum depth we can get from this root node so let's see that what would be the different approaches to solve this problem okay suppose this is the input we are given and we are trying to find the maximum depth for this particular given tree suppose this is the root of the tree if you want to find the maximum depth for this tree the answer is going to be four because of these two nodes uh we can see it clearly over here that over here the value is one this is two this is three and this is four and this is the answer we need to return the question is before we return this answer we will actually have to build some intuition behind it and the intuition is suppose at this position number five if we want to determine that what is the maximum depth over here well what we can do is we will check on the left side we will check on the right side and whatever has the greater number of nodes on either side we will actually take that as maximum depth and we will do it plus one well in this case the six and seven both are located at the same position six and seven none of them has any children which means that over here we can determine that this is actually one and this is also one so on the left side and on the right side both values are actually one so what we can do is we can do 1 + 1 so 1 + 1 will give us the answer that the maximum depth has at position number five is going to be 2 so in this case okay we have found the maximum dep over depth over here to be two well if we take this value number four well at this value number four it does not have any more children if it does not have any more children which means we can determine the maximum depth in this case is going to be one well now we have these two values that now based on these two values it becomes pretty easy for us to identify that what is the maximum depth at this position number two all we will have to do is we will take whatever the maximum value amongst these two is maximum value is actually two so what we can do is we can do 2 + 1 and 2 + 1 is actually going to be three so we can determine that three is going to be the maximum depth we can achieve at this node number two if this was to be the root of the given tree and for this position number three the maximum depth we can achieve is only one because it does not have any more children uh so that is a given fact now we have these two information now it becomes pretty easy for us to identify that what is going to be the maximum depth at this position number one and uh we all we will have to do is take the maximum amongst these two values so maximum value is going to be three and all we need to do is just plus one so if we do 3 + 1 we will get the answer four and four would be the correct answer in this case and that is what we are going to return so the maximum depth we need to find we can simply do it by using this method well now if you see for this particular solution we are actually able to achieve this solution but what we are doing is that at any given position we are seeing that what is the left Ma max value or right max value and whichever is greater amongst either one of them we are taking that and we are adding one one now again we are repeating the same process that we are taking the left Max and right max value and again we are adding one so which means that in order to solve a bigger problem we are actually solving a smaller problem and then again a smaller problem so basically we are doing recurs we are doing it recursively and that is how we are going to solve this problem using recursion which is very powerful and it is highly used in different kinds of tree tree problems so that is how we are going to solve this problem and this would be the optimal solution we can use uh if we see the time and space complexity in this case the time complexity is actually going to be big of n because we will have to iterate over every single element in order to get the answer and if we see the space complexity in this case the space complexity is also going to be big often because we might have to store all the values inside our recursive function and uh this approach is actually very good it works as expected there is also one more approach which uses stxs and that does not not use recursion it actually use uh iterative function so let me know in the comments if you want to see the stack solution as well and I can also explain that but for now if you show this recursive solution in any interview the interviewer would be more than happy uh so let's move on to coding now so first of all we are going to take care of a edge case if that is not the case we will have to call our recursive function first of all we are going to have an integer called left Max that is going to take care of the left sub tree for any given root position and we are going to call our recursive function again and same we are going to do for the right sub tree as well we are going to create a parameter called right Max and in either case all we have to do is simply return whatever the maximum value we we are able to find and then we will add one to it and and this should be it uh once we get out of the loop our solution would be done so let's try to run this code okay seems like our solution is working let's submit this code and our code runs as expected and it's actually pretty fast compared to a lot of other solution so I would be posting this in the comment so you can check it out from there thank you hello friends so now once again let's do an awesome lead code problem that is going to solve all of your problems so without any delay let's get started so the lead code problem we are going to do today is called diameter of binary tree we can see that this one is an easy problem and also a very well- like problem the problem statement is quite straightforward we are given the root of a binary tree and we need to return the diameter of the tree now the question is diameter of a tree is the length of the longest path between any two nodes inside this tree and we are told that this path may or may not pass through the root but it's going to pass through the root okay now the length of the path between any two nodes is represented by the number of edges between them so let's try to understand that how does a diameter of a tree is being calculated let's say that we are given a tree like this so in this case what is the longest path we can make well let's just give them the number so 1 2 3 4 and five these are the numbers of this given nodes so we can see that the longest path over here is this one so 3 2 1 and then five this is one path second longest path is once again 4 2 1 and 5 so in either case the longest path we are able to make contains three edges this is going to be the first Edge this or this either one of them then this is the second Edge and this is the third Edge so the answer is going to be three that this is what we need to return now the problem statement is quite easy to understand but the thing is how do we actually calculate the diagram um and if we start iterating over every single path and then try to find the answer then this becomes lot of complication so we need to avoid that and if you look at it from the other way at any given moment or at any given node the diameter of that node is nothing but the height on the left hand side so left hand height and the height on the right hand side that's it this is all a diameter is and we can see that in action over here that that the the height on this left subtree is actually going to be two because it this is the first level and this is the second level and the height on the right Su tree is going to be one so if we do 2 + 1 the answer is going to be three so this is what we need to calculate now we need to understand that how we are actually going to be able to calculate that for any given binary tree and for that we simply have to iterate over any given tree nothing more than that now iterating over the tree is actually quite simple and we can use the common logic of recursion in this problem now for recursion you know we need two items first item is a base case so base case in this case is going to be that if the current node if that is equal to zero which means we have reached to the very end and now we cannot go anywhere further so then we start to do the backtracking this is the first uh base case now the the what is going to be the recursive equation or recursive scenario well recursive scenario is quite simple that at any given moment or at any given node the height or the diameter of that node is actually going to be the sum of the left diameter and the sum of the right diameter and same way even at subsequent left node the diameter at that node is going to be sum of the left diameter and right diameter and that's how we should be able to calculate the answer we are looking for so in this case the height on the left hand side is going to be two the height on the right hand side is also going to be two so the longest path we are going to be able to make is going to be of size four and we can also see some examples of that so one of the longest path starts from this node and then once again to this node and once again to this node and then once again to this node and once again to this node if we see the number of edges included this is the first Edge this is the second Edge this is the third Edge and this is the fourth Edge so this is exactly what we are looking for in terms of finding the answer so we all we also found out the recursive solution that the diameter at any given node is going to be the sum of the left node or and plus sum of the right node okay and then we can have a recursive function to iteratively call sorry recursively call our entire tree and then uh return back the answer so this is actually going to be the whole solution we are simply iterating over the tree calculating the height and whatever the sum of the height is we simply return that if we see time complexity in this case time complexity is going to be big of n where n is the total number of nodes that are currently present inside the tree because we will have to iterate over every single node and in terms of space complexity well this is also going to be B of and because we are using the recursion and in order to store the recursive stack we might use B of n space so if you want you can also do this problem iteratively and in the iterative solution we actually don't have to do or use the stack but the only reason I'm using the recursive solution is because uh it's good to do it like recursively it's small amount of coding and also looks cool okay so now let's quickly go to the coding so the coding solution is quite straightforward uh we are going to initialize our variable maximum diameter and we are going to have our method diameter of the tree from which we are going to call our get height method for left and right sub tree for the given root element okay now this our get get height method is our recursive method so let's quickly see what is happening the as a part of the base case we are having the scenario that if the given node is equal to null we need to return zero if that is not the case then we are going to find the height left height and the right height for both we are going to recursively call the get height method with the left child and with the right child now uh for every single position we will have to check that have we reached a new maximum diameter so for that we are going to do a simple equation of the current maximum element or maximum diameter we have been able to find uh if that is greater or if we find that the current left and right side sub tre's height is greater than the current maximum diameter we have been able to find then we need to update the max diameter if that is not the case then uh we can simply leave the max diameter as it is next we need to return the height uh that we have been able to find so in the end we are simply going to return 1 plus the maximum value of either left height or the right height and why are we doing 1 plus because at any given root node we also have to consider the node by itself before propagating the height to its previous level so that's why this one plus is there okay with every new level basically we add one value to the height and uh this is the Sol solution let's try to run the code okay seems like our solution is is working as expected let's submit this code so our code runs 100% faster than all the other Solutions and that's because uh the code actually operates on a very simple principle and uh it runs in 0 millisecond so that's why it's 100% faster uh it's nothing magic now once again the coding solution is present inside our GitHub repository let me quickly show it to you that this is the GitHub URL where we have actually stor hundreds of lead code questions and their answers uh these are some of the most popular questions in the entire world these questions has been asked at tons of different companies multiple times so for each of the problem you can go ahead and see we have the Java file for that you can go and find the lead code link you if you do don't find you can also find the subsequent video solution and also a list of most most as problems at the Fang companies which is this list which contains lot of import lead quote problems they have been differentiated based on the topics and for each of the topics I have provided that how many times they have been asked at different top tier ID companies so there are 130 of most fabulous questions that I have been able to find then also I have solved most of the need code 150s problems and they are also provided over here so this both of these resources are amazing [Music] so the lead code problem we are going to solve is called balance binary tree now we can see that this one is a lead code easy problem and also one of the most like problems on lead code the problem statement is quite straightforward that we are given a binary tree and we need to determine that whether it's a height balance binary tree or not so the question is what does height balance tree means it's actually quite straightforward height balance tree means that at any given moment the height of left sub tree and the height of right subtree if they do not difference more than one so which means that there is the maximum difference of heights is like one or zero if that is the case then we can say that this one is a height balance binary tree okay or balance binary tree but if we identify so let's try to understand in this case currently this one is our root note now if we see the left sub tree we can see that the height of this left sub tree is two for the right sub tree the height of this right sub tree is three which means the difference between left left and right sub tree is no less than or equal to one which means this one is a balance tree or like height balance tree but in the same scenario let's imagine that if we had one more nodes like this then the height of this right side binary tree is going to be four meanwhile this left sub tree is still going to two so if we do the difference of the height we get the answer as two which is definitely greater than one in this case we can say that now this binary tree is is not a balance uh not a height balance binary tree okay so this is what we need to determine now this is like a very straightforward problem basically at any given moment we need to do check that for any given node what is the height for both left and right sub tree and this we can calculate very easily by simply traversing over the given Tree in like any BFS or DFS fashion and once we do the traversal at any given moment we will you have to keep track that for any particular root node what is the height of its left sub tree what is the height of its right sub tree and if the moment we identify that the difference is actually greater than one then we can clearly say that this is not a balance tree if we identify that we iterate over the entire tree and we did not find that the height to be greater than one at any given moment between left height and right height then in that case we can say that this one is a balance tree so that's it this is all what we need to do the approach is quite straightforward forward and the idea we are going to use is that we need to Traverse over the given binary tree so for traversal we know that there are iterative methods and recursive methods let's try to do it recursively so recursively we are simply going to iterate over the given tree we need two items for the recursive case first recursive condition is the base case so base case is going to be that if the given current node is equal to null or zero then we have basically exhausted every single child that we can visit for that particular tree so we we we can do that uh what is going to be the recurrence uh call that we need to make at for the recurs recursive level that we are going to check that for any particular root node first we are going to Traverse its left child and then we are going to Traverse Its Right child uh so that is also good now while traveling the moment we enter a new height or a new left child or a new right child we are going to have a counter that is going to keep track of the left height and we are also going to have a counter that is going to keep track of the right height we are going to update it uh sequentially with every single level that we are increasing and during every single update we are simply going to check that if the difference between left height minus right height and we are going to do an absolute difference so uh we don't care about which one is greater as long as the Delta is uh greater than one the moment we find this one we can see that this one is an invalid or not a proper balance height balance binary tree and if we reach to the end we can say that this one is a height balance binary tree and we can return this answer very easily and very simply so the approach is quite straightforward if we see time and space complexity in this case the time complexity is simply going to be bigger of n where n is the number of nodes that are present for the space complexity because we are using recursion we will have to induce or create a new recursive stack so that might increase the time complexity to Big go often and if you try to do this recursively you can also do this in big of one space complexity as well but I don't think like any interviewer is going to have any issue of you using recursion because that is a great way to save some time and now let's quickly see the coding solution for this one so if we see the solution it's quite straightforward we need to get return a Boolean answer that whether the given tree is balanced or not and in input we are given the root now first we check for our base case that if the given root is equal to null we can simply return true if that is not the case we are going to calculate the left height and we are going to calate the right height for that we are going to use a helper method called get height and we are going to pass in the root value now inside the get height method we are also going to check recursively that whether if the given node is equal to null we can return zero if that is not the case we are once again going to recursive recursively call the same method for the left child and for the right child and at every given instance we are simply going to calculate the maximum height we have been able to find both for left height and right height and we are going to add plus one so this is going to give us the height at any given left sub tree and right sub tree that we are going to fetch values over here then we are simply going to have our math. absolute formula that if the difference is greater than one then we can simply return false if that is not the case then we simply need to uh say that yeah the this given uh true tree is balanced so that's it this is the whole solution we can simply uh run the code and then I think I think it should be working fine okay seems like our solution is working okay let's submit this code and our code runs 100% faster because there are very few test cases so this is pretty awesome now once again this whole solution is actually posted on our GitHub repository that you can find over here now this GitHub repository contains hundreds of very popular every single lead code problem that you can imagine and for each and every problem I have also provided that uh what is the lead code problem statement for that particular problem what is the Java solution and for some reason if you cannot understand the solution on your own you can actually go to the video solution as well I have provided the link so this is a great resource for anyone trying to prepare for lead code or DSA problems uh the other thing is I also want to show you one more resource that I have created or not the lead code one but the document that I have been able to uh curating now this document contains two very important list first list is the most popular and like technical interview questions of all time now over here I have created a list of 130 questions for each of these 130 questions I have divided them based on the topic that you need to prepare and I have also provided the key important information that how many times that particular question has been asked at what type of company so this will help you in couple of ways now number one you would be able to understand if you're targeting any specific company you can find that how many times that question has been asked at that company uh number two based on just looking at the question you can understand that how important that question in general is so some questions have been asked like literally hundreds of times by many top tier companies so you should be able to identify that as well and each of the topics are distributed based on like easy medium and hard lead code problems so that is one option second one is the need code 150 list that I'm currently working upon so this is like the 150 most asked questions list created by NE code that is an addition to Blind 75 now this is also a very pretty and very important list once again all the questions are based uh differentiated based on topics we can also see that uh for most of the questions I'm trying to go through them and generate solutions for them as well so yeah uh if you want you can also check out this resource maybe it can be helpful with your prep uh Journey okay Hello friends we are still not employed by a Fang company so let's not stop lead coding till we get there today we are going to do same tree lead code problem and if we see some of the companies where I want to get a job who have already asked this question there are companies like LinkedIn Amazon Google Bloomberg Apple Microsoft Facebook and Uber so that's why I'm paying my atmost attention I hope you also enjoy the video so this is a lead code easy problem and as the name suggest same tree the problem is self-explanatory but let's go over it that basically we are given two roots of a binary tree called p and Q and we have to write a function to check if they both are same or not so let's try to understand this with couple of examples that are given over here over here here we are given this two trees p and Q and in this case we see we can see that both of these are one both of these are two and both of these are three so we can say that okay they are actually same and we can return return true in this case but for the second example if we see the p and Q values over here for one one is same so root values are same but if we see over here this is actually two and this is actually two despite being the same value the positioning is not same because this is actually the left child of this given P tree and this is actually the right child of this given Q tree which means that these two are not same so in this case we will return the false and this is what we have to achieve so let's see that what would be the different approaches to solve this problem so solution of this problem is actually quite simple and if we see the approach one we are going to use an iterative approach in the iterative approach what we are going to do is we are going to iterative over both of these given trees in the same manner and we are going to keep on checking subsequent uh nodes of every single position at any given moment if we identify that any single node does not match we can return false immediately and if somehow we can reach out to the end of the tree and iterate over every single nodes we can return true in this case so let's see that in action uh so first of all we are at this P for this p and Q tree currently we are at this root position so so we will check that value and both of them are actually one which means we are good so far now we are going to iterate over on the left side so on the left side this value is actually two and this value is also two so again we are good now again on the left side this value is actually three and this value is also three so again we are good so far now we go back and now for this position number we also have a right subtree or so we will check that right position this is five and this also has a right position which is also five so so far we are good now again we go back back to this root node uh we still have this right side that we haven't traversed so this node is four and this node is also four so again we are good and at the end this node is six and this node is six now we don't have any more nodes to go back to so essentially we have traversed over all the nodes inside given both the trees so we can return return true in this case and this is the approach we are going to take uh let's see what would happen in a scenario where trees don't match up so here I have drawn that example as well that over here all of these nodes are same uh but actually this node and this node these two are not same so because these two are not same the moment we iterate over all of these nodes and eventually we would reach to these positions we can return false immediately in this case so this approach would work is expected and if we see the time and space complexity in this case the time complexity is actually going to be bigo of n why bigo of n because we will have to iterate over every single node inside the given tree for both uh p and Q trees in the space comp complexity would be be go of login that is because this is a binary tree well in the second approach we are actually going to solve this problem recursively and the idea is at any given moment we have to identify that whether two given two trees are same or not the thing we are going to do is we are going to compare the root nodes if they both are same we will have to compare their entire left sub trees uh that they have to be the same and also we will have to compare their entire right right sub trees that as they they also have to be the same and if that is the case we can Define that tree to be the same but if we take a look at for the left sub tree again we are going to repeat the same process that even for the left sub tree we are going to compare the root nodes if they both are same then we are going to compare their left sub trees and their right sub trees to be the same so essentially we are doing the same thing repeatedly for different kinds of input and recursion is the best way to approach that uh and also your interviewer is going to uh expect you to do this recursively because that would be more efficient way of doing it uh so let's see that in action so the idea is at any given moment we are going to compare the root node so over here root node is same because root node is same we will have to check that whether the left sub tree is same and right sub Tre same or not so first we'll do the left sub tree so now for the left sub tree we have these two trees for p and Q respectively so again we will check the left node so left node is this two and this is also two so they both are same now we we are going to check the left sub tree and right sub tree again so this both of these are three so they are we are good now we will have to check the right sub tree so right Sub sub is also five and five so again we are good now again so far we have calculated the entire left portion but we haven't calculated the right portion so now we will do that so again for the right sub tree this value is four and this value is four so again they both are equal so we are good so far and then these values are six and six so again we are good so far now we have Tred over every single node recursively that is the important part and we have found all the values to be the same so because they were same we can return true in this case and everything is good and at any given moment suppose we identify that any single node does not contain the same value as its counterpart then the moment we are comparing these two values we can return false immediately and that would be the solution for this problem if we see the time and space complexity in this case the time complexity is also going to be big of n because we'll have to rate over every single value and the space complexity is going to be bigo of log n so the time and space complexity is not different than the iterative approach but recursive approach just is a lot less coding and I will also be showing that in the code so first of all we are going to check that if the given p and Q both are null if both are null we will have to return true because essentially they both are same if that is not the case and if any of either P or Q is null and the other one is not null then that case we will have to return false and if both values exist then we will have to compare their values and if both values are not same we can return false immediately if that is not the case we will have to iterate our left and right sub trees of a subsequent p and Q trees so now we are going to make our recursive call and that's pretty much it let's try to run this code okay seems like our code is working as expected let's submit this code and our solution runs pretty efficiently it's actually 100% faster but that is not the case because run time is 0 millisecond that's why it's showing 100% faster I will be posting this in the comment so you can check it out from there Hello friends we are not employed by Fang company so let's not sop lead coding get there today we are going to do SUB tree of an another tree lead code problem and if we see some of the companies where I want to get a job who have already asked this question there are companies like Amazon Microsoft Google Facebook Apple Bloomberg and Tesla so that's why I'm paying my atmost attention I hope you also enjoy the video so this is a lead code easy problem and basically we are given the roots of two different binary trees called root and sub root now we need to check that whether there exist a subt of this original roote root tree where the structure is completely same as whatever the sub root binary tree that we are given if that is the case we will return true if that is not the case we will return false so let's try to understand this with an example basically we are given two different binary trees called root and sub root now over here uh we can see that the structure of the sub root which contains the root value is four a left child as one and right right child as two where one and two does not have any more children of their own the same structure is also present in this example as well uh and because it is a sub tree of this original root binary tree we can return true in this case now let's take one more example to make things a little bit more clear so in this second example we are also given two different binary trees now if we see the structure of the sub root we have a node four it has a left child and right child of one and two respectively and they don't have any more children of their own now if we see this original root we can also see a similar structure and I'm focusing on the word of similar not exact same because in this case we also have four 1 and two present but thing is notice that this two actually has another node or another left child zero that is present over here which is not the case in this scenario so because this is not the case we cannot say that these two are same and these two are actually not same so in this case we will return false and basically we are trying to see that whether one tree is a sub tree of another tree or not so that's why uh the name of the problem is sub tree of of another tree it is self-explanatory and now let's see what are the different approaches to solve this problem so this is the root and sub root we are given now over here we are trying to see that what would be the optimal solution for this problem and basically we can clearly see that uh the answer in this case is going to be true because this 9 1 and 2 is also present as a sub Tree in this original root tree so that's why we we can return true in this case the thing is let's see that what is going to be the strategy well the idea is we are actually going to to iterate over this given root Tree in BFS fashion now if you don't know what BFS is BFS is basically breath first search and you can see more details about that in this video I have done previously now uh let's focus on the problem at hand so the idea is that at every single time we are going to iterate over this root node and we are going to iterate in BFS fashion which means we are also going to iterate its neighbors for every single node now at every single time we are going to compare it with the sub root tree and the moment we find a match we are going to iterate both the trees in BFS fashion so let me quickly show you what I mean by that so first of all in this root tree we are I'm going to iterate over this root number five now this root number five is not same as this root number N9 so which means I can't do anything over here I have already trated this value now I'm going to iterate it children so first of all I'm going to iterate over this root value eight so this eight is again not same as this nine so we can ignore this case now we are at this position number nine so this nine is actually same as this nine so because these these two values are same now I'm going to do BFS traversal for both of the sub root and root trees now from this nine if I see the BFS traversal basically I'm going to go to the left child so left child in this case is one so again I'm going to see the same thing and even in this case the left child is also one so yeah I'm good up until this point now I'm going to go to the right child this is two and the right child in this case is also two so yeah again I'm good until this point now I'm not going to stop my traversal I'm going to keep on iterating till I find all the null values so in this case this one does not have any children uh left or right so in this case I'll encounter null value so I'll try to see the same thing over here so over here this does not contain any sub child of its own as well so this is also null so I'm good up until this point now if I try to see this portion so this also this is also null and this is also null so because all the values are same and I found no other children that I can iterate over in this case I can simply return true now uh there are two ways to do this problem uh I can do it iterate l or I can do it recursively and uh if you know my videos I like the recursive method better so I'm going to show you the recursive solution now let's see one more case where uh the answer is going to be the false so suppose for the same example uh we do everything right but over here this two actually has a sub Child Called let's just say 7 over here now because this two has a sub Child Called seven now the moment I am done iterating these values and I don't find anything I'm good up until this point but now at this portion at this node two I'll find a value seven over here but when I try to find the same value over here I won't be able to find and because I won't be able to find I'll return false now the time complexity is actually going to be B of M + n y m plus n because we will have to iterate over all the nodes that are present inside this given tree root and sub root and M is the number of length of all the nodes that are present over here and N is the number of length of all the nodes that are present in the sub root and if we space complexity well basically because we are doing it recursively we might have to iterate over all the values and the space complexity in the worst case could be M plus n as well and uh now let's move on to the coding so before we start working on a sube method first of all we are actually going to have to create a new method where if we pass in the value of any root node and sub root node it can determine that whether both values are same or not so first let's do that so we created an is same method which takes in the value of two tree nodes now first of all we are going to check that if both values are null which would be the terminating case for our recursive call so if both values are null we can simply return true now if that is not the case we'll also have to check the scenario where one value is null and other value is not null if that is the case we will have to return false now there is also one more thing we'll have to check that and that is the value of this s andt so if the value value of s and t if they are not the same we can return false immediately and if everything is not returned by this point which means that the value of s and t is same so now we will have to check the left sub tree of s and left sub tree of T and same thing we'll have to do for the right sub Tre of s and right sub Tre of T so let's do that now from our main method is sub Tre method first of all we are going to check that if the given root is null if that is the case we can return false immediately so if that is not the case we will have to call our s same method for this root node and sub root node so let's do that and if we get the answer to be true we can return true immediately okay so if this does not return true which means this current root and sub root they are not the same if they are not the same we will have to iterate over this node root or its left child and right child to see if they are same with the sub root or not so let's do that so now for that we will have to call this is subtree Method again and we are going to run BFS on this three node route let's try to run this code okay seems like our solution is working let's try to submit this code our submission failed let's try to diag oh oh in this is same method we will have to check that whether the answer of both of them if that is true or not so we'll have to use and condition let's try to run the code again okay seems like this is working let's submit this code again okay and now our code runs perfectly fine it's faster than a lot of other Solutions and I would be posting this in the comments so you can check it out from there thank you hello friends we employed by Fang company so of lead coding till we get there today we are going to do lowest common ancestor of a binary sear lead code problem and if you see some of the companies where I want to get a job who already asked this question there are companies like LinkedIn Facebook Amazon Apple Google Microsoft Uber raddit and Twitter so that's why I'm paying my atmost attention I hope you also enjoy the video this is a lead code easy problem and basically first of all we are given the definition that what a lowest common ancestor means the lowest common ancestor is defined between any two nodes p and Q such as that the lowest node in given tree uh that has both p and Q as The Descendants where we allow a node to be a descendant of a itself as well we are given a binary search Tre and we are also given two nodes in that binary search tree and now we need to find the lowest common ancestor between those given two nodes uh so let's try to understand this with this example basically we are given a binary search tree over here and we are also given the value of p and Q to be 2 and 8 so subsequently if we see over here 2 is located at this place and 8 is located at this place so the most common element or the immediate common common element that we can find is is actually six in this case so that's why in this case we are going to return six as the answer because that is the lowest common ancestor between the node 2 and 8 uh if we take one more example in this case so over here we are given this p is equal to 2 and Q is equal 4 so p is located at this 2 and Q is actually located at this four now if you see in this case actually this four is a descendant of this uh two so that's a given fact but we are remember we are also told that we allow a node to be a descendant of itself as well so in this case uh since this two and four so four is already a descendant of this two and two is already a descendant of it self so in this case we will have to return this two as the answer and uh that is what is given over here we are given one more example where we are given only two nodes for this given binary tree so the binary tree looks like this 2 and one and in this case we are given the value of this P to be two and Q to be1 so again we can see that in this case this two is already a descendant of itself and this one is is actually a child of two so because of that one is also a descendant of this two so in this case we will again return this two to be answer now I hope that this makes uh understanding the problem more easier and now let's see that what is the approach we are going to solve this problem okay first of all I'm actually going to show you a bunch of different binary search trees and for all of those binary search trees I have created some p and Q values and we are going to see that what was the lowest common ancestor and why that was the lowest common ancestor right now we already know that important property of binary surgery and that is that for any given root value everything on the left sub tree of that binary surgery is actually less than that and everything on the right side of that binary Surry is greater than that we already know this important property and we are going to take it to our advantage based on this given root value or any root value and with subsequent p and Q values so if we see over here in this case the given value of p is actually six and if we start traversing through this binary search tree immediately we would find the six to be present over here so because we find the six to be present there can only be one possibility that this Q or whatever the value of q that would either be on the left side of the sub tree or right side of the sub tree but we already find the value to be six over here so immediately we can return six to be the lowest common ancestor because anyways this value of Q is somewhere supposed to fall inside the remaining binary Surry and in this case it is on the right side of the sub so we will return return six as the answer this makes sense right now the next example uh again we are given the same thing we are given this value P to be 11 and Q to be 9 so we know that this p is over here and Q Q is over here 11 is going to be answer but let's uh let's go ahead with our algorithm so first of all we'll start iterating over this root so the root value is actually 8 now for this root value we are going to compare it the with the values of p and Q right in this case the value of p and Q both are actually greater than this 8 so because both are the greater than this eight uh we know based on the property of binary searchy that they are meant to fall somewhere on the right side of this given binary searchy so we will start iterating over the right side of the binary searchy to either find the values of P or Q or if we can't find we will try to find the lowest common ancestor so when we start iterating over on the right side of the sub we will ignore this left side of the sub we don't care now this value is 11 this value is 11 is actually matches the value of this given P so immediately whether when we whenever we find a match with either P or Q we can return that to be the lowest common ancestor immediately and in this case this is going to be the answer because uh this nine is meant to be somewhere below this binary search tree and in this case it is immediately right here present so we will return this 11 to be the answer which is the lowest common ancestor let's take one more example which is very similar so in this case this value is p p is equal to 3 and Q is equal to 1 now again based on our algorithm we will start traversing over this binary cery now the first value we Traverse whenever we compare its value with this p and Q immediately we find a match with this P to be over here so because we find a match over here do we really need to trate over this given binary sear Tre well the answer is no why because we know that this Q value is somewhere going to be down below and that is always going to be this descendant of this P so again we are going to return the values three as the lowest common ancestor uh so far it makes sense that whenever either we identify the value of p and Q we can return that to be the lowest common ancestor immediately but what happens if the case is little bit different so in this case I'm G I have given the value of P to be 6 and Q to be 9 right again let's start with our algorithm so we'll start iterating over this binary searchy so first of all this value is actually five so because this value is five we'll try to see that okay we will compare it with this value of p and Q right so actually this five is less than p and less than Q both p and Q are greater than this root value so immediately it is meant to fall somewhere on the right side of the sub tree so now we'll start iterating on the right side of the sub tree we'll ignore these two because we don't need them now again this value is seven so let's compare this 7 with this value of p and Q well if we compare this seven this 7 is actually greater than this p and this 7 is actually less than this Q right right so we can conclude that this seven actually falls somewhere in the middle because uh on for the seven on one side 6 is meant to be because 6 is less than 7 and somewhere on the other side 9 is meant to be because 9 is greater than the seven based on the property of a binary searchy and if we utilize that to our maximum Advantage we can immediately determine that the seven is the common point between the 6 and 9 where on one side six resid so six resides on the left side over here and nine resides on the right side of the sub tree so on the right side of the sub tree this is where nine resides so we will return seven to be the answer in this case and this is the approach we are going to follow so every single time for any given tree we will start iterating over that tree and we are going to compare its value with p and Q based on that we will decide that whether we go on the left side of the sub tree or right side of the sub tree the moment we find a match between p and Q whatever the value we found if we find that we will return that to be the lowest common ancestor if we don't find a match and if we are in a situation where uh this value of p is on the left side of this any root value and Q is on the right side of any root value then immediately we can return that value to be the answer and this is the approach we are going to take to solve this problem and uh this is the optimal way to solve it now there are two ways to solve this problem we can either Solve IT recursively or we can solve it iteratively now I like recursion better but iter iterative method will also work as expected in this case now for the recursion if we see the time and space complexity the time complexity is actually going to be big go of n because we'll have to iterate over all the values in the worst case scenario and for the space complexity the space complexity is actually going to be big of n as well because we will have to run maintain the runtime stack for this recursion method well uh one good thing in iterative method is that for iterative method the time complexity is still going to be big of n but for the space complexity we can actually use a constant space complexity for the iterative approach but in the coding because I'm trying to improve my recursion I will be showing you the recursive method but just remember that iterative approach would be the better option in this this case so we are going to use the same method as our recursive method and first of all in this method as an input we are given this root value we are given the value of p and Q so first of all because we don't need to deal with this tree node we will actually have to deal with this integer value so we are I'm going to initialize three variables uh called the parent value U P value and Q value and uh I'm going to assign the values based on this uh whatever the input we get now we will have to check that whether this parent value uh if that is the common point between p and Q or either p and Q falls on one side or other side of this binary tree if that is the case we will call our recursive method again so first of all we are going to check that if this P value and Q value both are greater than uh this parent value if that is the case which means we will have to iterate on the right side of the sub tree so we are going to call the iterative method on the right side of the sub tree if that is not the case we are going going to check that whether this P value and Q value both Falls on the left side of this parent value uh so again we are going to do that so if both P value and Q value are less than the parent value which means we will have to search the left side of the sub tree so we are going to do that okay if that is not the case which means that whatever this root in root value we are at that is either P or Q value uh which means we can return root immediately that's it uh that should be working let's try to run this code okay seems like our solution solution is working as expected let's submit this code and our code runs pretty efficiently compared to lot of other solution in terms of time complexity I already mentioned you that the for the space complexity this recursive solution is not the most optimal but I want to practice recursion so that's why I did that you can find an iterative solution that works as well and I would be sub uh I would be posting this in the comment so you can check it out from there thank you hello friends we are not employed by a Fang company so let's not s Lead coding at then today we are going to do binary tree level order traversal lead code problem and if we see some of the companies where I want to get a job who already asked this question there are companies like LinkedIn Amazon Microsoft Facebook Bloomberg Google Apple and Uber so that's why I'm paying my at most attention I hope you also enjoy the video so this is a lead code medium problem and basically we are given the root of a binary tree now we need to return the level order traversal for this binary tree and we need to return the nodes values now we are also told that we need to return them in left to right fashion and level by level basically we are given a binary tree over here now for any binary tree basically we always have two things we have a root node or a parent node and that parent node has some children nodes so and furthermore this children node can have children of their own as well so every time a new set of nodes are being added at the bottom essentially we can define a new level being created so if we see this example over here essentially this is level one this is level two and this is level three and we need to return the nodes levelwise from left to right so let's try to understand this with this example over here where we are given three levels so this is level one these two nodes they are located at level two and this two nodes they are located level number three so in the answer first of all we are going to return this node three because this is the only node at this level there are no other nodes now at the second second level we have two nodes 9 and 20 and we need to return them in the same sequence of 9 and 20 and in the third section we have two notes 15 and 7 first we'll return 15 and then we will return 7 and that is the answer we are going to return in this case uh let's see that what would be different approaches to solve this problem so when it comes to tree traversals there are mainly two subcategories first one is a depth first search and second one is a breadth for search well in the depth for search we actually expand upon the depth of Any Given tree and then we keep on iterating over all the nodes while in the bread for we actually visit the root node first and then visit its children and then keep on repeating the same process so in this portion for depth for search there are three further subcategories in order pre-order and post order which I'm going to show you first and then I'll explain you how breath for search work and in this problem actually we are going to use breath first search to solve this problem so during the in order traversal basically first we visit the left side of the tree then we visit the root node and then we visit the the right node so first of all for this root node we will keep on expanding until the left node exist so left node exist over here and then left node again exists over here which means this is the first node we are going to visit so we start our visit traversal at four now four does not have any more children which means we can't go downwards anymore which means now we go back to the root node so root node for this four is actually two and then we again expand on the right side for this two we still have right side five that we haven't visited so we will do that now again we have visited all these three nodes so now we are done with these now we again go back to the root node which which is one so we visit one and then again we repeat the same process left root and right so again we go on the right side so this is the strategy for in order traversal now for the pre-order traversal basically we follow the principle of root left and right node and this is the way visit the node so first of all we are going to visit the root node which is one in this case then again we are going to visit the left node which is two then again we are going to visit the left node which is four then again we are going to visit the right node which is five again we come back and now in this case we again go back to this root node which is three then again we go to the left and then again we go to the right so this is the strategy for using a pre-order traversal now for the postorder traversal basically we follow the principle of left node right node and then root node so first of all we are going to visit up until left node exists so this is the leftmost node so we are going to visit that first so we start our traversal at this position number four then we visit the right node which is five and then we visit the root node which is two in this case now after this we actually don't visit this node one because for this road node one there exist a right sub tree that we haven't visited so we again go to the right side and again this also has a left node which is six so then we visit the node six in this case then we visit the node 7 and then for after visiting the six and seven then we visit its root node which is three and in the end after visiting all the nodes we visit the main root node which is one and this is going to be the traversal strategy for the Post order traversal so when it comes to breath for search we actually expand upon its neighbors or its children for any given tree rather than going in depth in any one particular direction so for if we see for this particular tree the breath for search travol is going to look like this so first of all we are going to visit the root node which is one in this case then we are going to visit its children so its children are actually 2 and three so we are going to visit this node 2 and three now for this left child again it still has children of its own so we are going to visit them first so we are going to visit this node four and five and then for this node three it has childrens of its own as well which is 6 and 7 now in this case we cannot further expand because this four 5 6 and 7 does not have any children of their own so we are done with the traversal basically we have iterated over all the notes that were given but if you see these notes and the fashion we have visited them it actually gives a very interesting perspective for the problem we are trying to solve well first of all we are visiting the node that is located at this position number one then we visited its children which are actually located at this level two so first we visited the level one node then we visited all the no nodes that are present at level two and then we visited all the noes that were present at level three if we had any further noes then we would have visited them that were uh for the notes that were located at this level number four so this breath for search is actually a very good solution for the problem we are trying to solve where we we are trying to see that what would be the level order traversal for any given tree basically we are anyways iterating the nodes in particular levels so all we will have to do is just simply make tles of the levels that we are visiting and the nodes we are visiting at so that is how we are going to optimally solve this problem now we are going to use the same tree that we have been using so far and we are going to see that what would be the answer so first of all we will have to create an array list where we are going to store the answer now at any given position whenever we start iterating over this tree and whenever we jump to a new level we are going to create a new node inside our array list uh so first of all we are at this level one right so now for this level one we are going to create a new node over here which is this one and for this level because this node is located at level one we are actually going to create an entry over here now for this one we are actually going to iterate over its children we are going to call its children 2 and three now with because these are children of this node one they are actually going to be located at level which is whatever the level of this one is + one so the level of this one is actually 1 so 1 + 1 is going to be two so these nodes they are actually going to be located at level two now the moment we identified a new level we are actually going to create a new node inside our array list so over here we would have created this new node now in this new node because we visited these values 2 and three we are going to actually add the value 2 and three over here now again we will have to further go down for this level 2 and three and remember that initially we only had this one node and we visited its children now again we have a node and we are visiting its children and again we have a node and we are visiting its children and suppose these had if the new notes we would have visited their children as well so basically we are doing the same work for different set of inputs where initially this was a child but now this becomes a parent for these nodes so we are basically doing recursion nothing special in this so now from from this level two whenever we will call these left and right children basically where what we would have done is we would have increased whatever the value of level was for this value to + one so this was located at level two which means these nodes they are actually located at level three so now again we created a new level so because we created a new level we are going to create a new entry inside our array list and then all the values located at this level we are actually going to store them in this portion of our array list so now we are going we are first of all we are going to visit node 4 so we are going to add node four over here then from this two we are going to visit Its Right children which is this node five so we are going to add five over here now we still have nodes that we haven't visited so now we have this node three so we are going to first of all visit its left children which is this node 6 and this is also located at level three because this three originally was located at level two so this is also at because this is at level three we are adding it in the third portion or third placeholder inside our array list and then in the end we are going to visit this node number seven as well at the end now this does not have any further children so we are good up until this point and we can stop our traversal and return this new error list that we have created as the answer so this is the approach we are suggesting and if we see we did the breath first search traversal and basically we did it recursively now we could have done it iteratively as well no nothing special in there uh so you can discuss with your interviewer what is the strategy you want to use and nine out of 10 times your interviewer is going to ask you to do this problem recursively because it's Lo lot less code uh if we see time and space complexity in this case the time complexity is actually going to be big of n where n is the number of nodes that are present inside this given Noe and if we see space complexity well uh basically we will have to create recursive we will have to make recursive calls and that takes uh some space and that space is actually dependent on height of the given tree so space complexity is actually going to be big of H where H is the height of the tree now first of all we are actually going to create a list of list where we are going to store the answer and we are going to declare it as a global variable because we are uh going to create a new method for our recursive call so first of all let me create this Global variable called answer now we are going to create a new public method which is going to be uh acting as our recursive function and it does not return anything we are going to name it as order and as an argument it is going to take any tree node and the level we are currently at and now inside this method first of all what we are going to do is that whenever we are at any position or whenever we are creating a new node basically we are going to add a new entry to our answer after creating a new value for a new level now all we will have to do is whatever this re node is based on its level value we will have to add that value to our answer now after doing that basically all we will have to do is for any single given node value first of all we are going to check that whether it's left child and right child if they exist or not if they exist basically we are going to call the same order method with this left child and right child and we are going to increase the value of the levels that is all we need to do for this order meth so now from this main method first of all we are going to check for an edge case that if this given roote is null if this is null we can simply return the answer and if this given root is not null basically we will have to call this order method with our root information and the current level that we are at and now at the end we simply have to return whatever the answer we get let's try to run this code it seems like our solution is working as expected let's submit this code and our code is actually pretty efficient compared to a lot of other solution and I will be posting this in the comment so you can check it out from there thank you so the lead code problem we are going to solve is called binary tree right side of view now we can see that this one is the lead code medium problem and also an extremely well-like problem on lead code the problem statement is actually quite straightforward we are given the root of a binary tree now we need to imagine that as if we are standing on the right side of the binary tree and then we need to return the values that we see uh from the right side and we need to return the top to bottom values so let's try to understand this problem currently we have a binary tree over here now imagine yourself that as if you are standing on the right side of the binary tree so from the right side of the binary tree uh you can uh see only this portion of this given binary tree which means currently you are only looking at these four nodes and all of because this node is cover being blocked because of this one and these two nodes are also being blocked by because of this one okay so in this case what is your right side view or right your right side vision of this tree well first we need to return return the answer in top to bottom manner so first we are seeing node number one next we are seeing node number three next we are seeing node number six and lastly we are seeing node number seven and this is what we need to return as part of the answer now let's first try to understand that what the answer looks like in each of these three different scario so we have a clear understanding on what is being expected from from our side so if we take a look at this first tree well the answer is going to include this is going to be the first node this is going to be the second node this node would be blocked so we would not be able to see it and then once again this node would also be blocked so we will include this node so these are the three nodes that we are dealing with okay next uh in this particular scenario we can see that we need to return the right side view the thing is hey there is no node on the right side of the tree so well in that case we can still see the left side of the uh node as well so we are going to include this node and we are also going to include this node in our answer okay and in the lastly this scenario is slightly tricky so of course this node is going to be part of the answer but then at this particular level we will have to include this node once again at this particular level this one is the right child and this one is the left child but still because we are standing on the right side we need need to take the value that is closest to us on that particular level so once again this node and then lastly on this last level we don't have any particular nodes so we are going to use this node now in each of these three scenarios we can see one very clear distinction in terms of answer that is we are seeing that at any given level we will have to take one node from that particular level we are going to select the node that is the last node in that particular level that is the same case for this one because this is one level there is only one node so this is the last node over here we have two nodes but we are only going to consider the last node once again we are only going to consider the last node over here as well this one there is no explanation needed this one is slightly trickier example where we can Okay so this one we understood why we take it amongst these two nodes we are closest to this one so we are taking it amongst these two node even though these nodes are close to each other we are once again closest to the right side node so we are going to take it as part of the answer and this one once again is still the last node at that particular level so we are able to establish that for any particular binary tree the right side of the view is simply going to be doing the level order traversal and finding that the what is the last node at that particular level so in E either case we simply have to do a level order traversal now level order traversal for trees typically refers as breath first search so we know how to do breath first search it's a very common and popular um tree traversal techniques if you don't know what breath for search is let me just quickly explain we are at the root position so what we are going to do is for root position we are going to put it inside a q now we know the property of a q that it is a first in first out type of scenario for each level we are going to iterate over all of the children that it has and if it has the children we are going to put them on the queue as well and once again repeatedly we are going to keep on subsequently doing the same thing with their children as well so logically we would be iterating over in one particular level by level across the entire tree and that is called breath first search so let's try to see our solution in action so in this case let me give values to these particular nodes and we know that the answer in this case is going to be 1 3 6 and 7 but currently let's say that this is our Q now now in our queue we are going to keep track of two things number one that uh what is going to be the last element at any particular nodee and number two that uh for every single level we will have to keep track of that at what level these particular nodes belong to okay so we can very easily track that because every time we add a new child we can just mark it as like a new new level that we are adding inside the queue and apart from that we can simply move forward as it is So currently the first value is going to be node number one for node number one because it has children so we are going to add node number two and node number three inside our uh array as well uh inside our Q as well once again for both node number two and three they also have the children of their own so for node number two they have four and five so we are going to add four and five for node number three they have six so we are going to add six and lastly we are going to have uh no value number seven that is the child of node number six so once again I'm let me just add one more entry over here seven so now we can see that I have color coded every single different level uh based on all the elements for that particular level and uh in that particular color coded pattern we need to find the last element so this is basically going to be by default last element so we are going to add this to our answer next we have two values at that this particular level so we are going to pop this element out because you don't care this is the last element so once again we are going to add that to our answer once again we have three elements over here we are going to pop each one of out and the moment we reach to the last element we are also going to mark it as the answer and then this is also the last element at this particular level so once again we are going to mark it as the answer and that's it this is the whole solution now at first glance it looks complicated but all we are doing is just doing the breath first search in a common fashion and trying to find the the answer now in this case since we are standing on the right side of the binary tree we are selecting the last element but same can be said that if we are given a question where we need to find that what is going to be the left side view where you are standing on the left side of the binary tree same logic is going to apply the only thing is now you are going to be dealing with the first entry that pops up inside of your queue for every single new level and that is what you need to put it in the answer so basically these are like two questions in just one question by just changing the direction of where you are standing if you see time complexity in this case this is going to be big off n if you see space complexity this is also going to be big go of n because we are using an extra uh extra Q to keep track of all the elements that we have iterated so far uh overall this is like a decent time and space complexity because this you have to go through this in any of your tree programs unless it's a binary tree and you are trying to search an element so now let's quickly see the coding solution for this one okay so this is the coding solution first we are going to initialize our new array list to store the answer and we are going to name mark it as result we are also going to check for an edge case that if the given root is equal to null we can simply return the result if that is not the case we are going to initialize our q and inside our Q we are going to populate the very first element that is the going to be the root node now we are going to iterate over the tree in the breath for search manner by by stating that while Q is not empty do this so first we are going to Define that what is the current size of the given Cube then we are simply going to have a for Loop to run over the given que where we are going to keep on pulling elements at every single position and we are going to Mark the last node of the current level inside the result that we are we are going to populate okay then we are going to check that for this particular given root value do we have any left child and do we have any right child if we do add the left child and right child to the current Q as well and this is going to iterate over uh the entire binary train bre first search Manner and we would have our result array list populated as well in the end we can simply return results and this is the whole solution so let's try to run the code okay seems like our solution is working as expected let's submit this code and our code runs pretty fast compared to a lot of other Solutions uh few things can be improved in terms of uh space complexity but anyways this is a good enough solution I would be posting this in the GitHub repository that we have created the problem statement is called count good nodes in a binary tree we can see that this one is a relatively new problem a medium problem and also a very well-like problem on top of it this has been asked at tons of different companies so let's pay uh some attention that what the question is asking us us to solve basically we are given the root of a binary tree and we need to return the number of good nodes in a binary tree the question is what the heck is a good node well a tree node is deemed good if in the path from root to that particular tree node X there are no nodes with value greater than x if that is the case that node is a good node so let's try to understand this with an example currently we have uh we can see that there are five different node or six different nodes in this particular tree now we are being told we need to find the good nodes uh the definition of a good node is that path from root to any particular node if that particular node is contains the maximum value then it is deemed good node so let's try to see what are the good nodes starting with the root now root in itself is a good Noe because path from root to root root is the biggest value so we find one good node okay now let's consider value number one what is the path between root2 value number one this path is one the largest number on this path no which means one is not the not a good node then let's consider the path six so for six the path is five then 1 and then six so in this case six is the largest number from the direct path through the root which means six is also good node so let's mark that once again now we found everything we could let's try to move to next value number five so is five a good node yes five is also good node why because the definition of five is that from root2 that particular X there are no nodes with value greater than x so in this case the nodes we have is value number 5 1 and five so there are no other nodes that has value greater than five which means five is still a good node so we will also Mark this as good then we will jump to Value number seven so once again the direct path from 5 to 7 is this one so in this case 7even is the largest node so seven is also a good node and next value is once again seven so once again even in this path 5 7 and 7 there are no values greater than this seven as well so 7 one is also a good node so in this case in total we found 1 2 3 4 and five good nodes amongst these six nodes so we need to return return five as the answer and this is what the problem statement is asking us to solve so now let's try to understand the logic on the solution we can build for this particular problem the logic is quite straightforward that we need to iterate over the given Tree in some fashion and we will have to keep track that around this iteration what has been the largest value we have been able to find so far keep track of it and using that particular value we are going to make some important judgment calls so the logic we are going to do is that we will have to iterate the given Tree in depth for search fashion why depth because we will have to keep track of the entire path from root to any particular node so for that we will have to go into the depth for search order now what are the considerations number one thing is first we are going to check the root or at any given position because first we are checking the root then we are checking for its left uh entire sub tree and then write entire sub tree same thing we are doing at every single level that first we are checking that for this particular route whether it is the largest number after understanding this we are checking its left sub tree and then right sub tree so basically we are doing the pre-order traversal in this case and pre-order traversal is quite straightforward the logic is root then left and then right tree so we are once again going to do a pre-order traversal in this case in depth for search fashion we are going to keep track that what has been the maximum value we have been able to find inside the current path if the current node is uh equal to or greater than the maximum value we have been able to find so in this case we are going to deem this node as a good node so we are Al we also need a variable to store the good node as well so let's assume that okay we are going to have our count variable to store all the good nodes we have been able to find so far and this is the whole solution we need to create so let's try to understand or let's try to iterate over our given solution and let's just arbitrarily give some values to these particular trees or these particular values so in this case we can see that uh these are the different values now let's start with value number three three in itself is a good note because we are doing the depth for search pre-order traversal we are going to take care of the root first okay now we took care of this root now let's take care of the left child so left child is once again one so once again even at the left child position we will have to follow this uh position of root left and right so once again uh now left child in itself is a root so we have value number one what has been the and also we have our maximum value we have been able to find on the current path so maximum value so far has been three this value is one so current node is not greater than maximum value value which means this is not a good node now we will need to check for the left pointer so left pointer is once again three so three is same as the maximum value on this path we have been a able to identify so we are going to mark this three as the answer that we have been able to find so far now uh three is also going to be a good node so we are going to add our count of good nodes now we are going to do a backtrack now for the backtracking once again we have a right node that we haven't checked so we are going to take care of the right node as well well the value of the right node is five So currently at this particular position the right node is actually greater than the maximum value we have been able to identify so we are going to store uh once again count this five as a good node as well apart from doing that we will also have to update the maximum value we have been able to identify but this particular node does not have any subsequent child nodes of his own so because it does not have any child node there is no point in updating the value of the maximum node but say for an example if we did had one more child like this uh where we need to check for the value of this node number six then this five would have been the maximum value we have been able to identify so far but that is not the case once again coming back now we took care of five and we took care of three it does not have any children we are going to do the backtrack we already took care of one which means now we have to taken care of this entire left child once again in our pre-order traversal uh we took care of the root very first then we took care of the the left child so this is the entire left child portion of this route now we need to take care of the right child so once again we are going to do the same thing we are at position number four so we are going to first check that whether four is a good node or not so in this path the current maximum value we have been able to identify it was value number three so four is a good node but in this case because we are checking for the subsequent children of four we'll have to update the maximum value we have been able to identified along this path to Value number four so this is the maximum value we have found so far next value is value number two so two is not is less than the maximum value we found so two is not a good node so in this case we found in total four good nodes so we are going to return four as the answer and that's it this is the whole solution that we need to return basically we need to understand that why we need to use DFS in this case because we are going in one particular direction we will need to keep track of the maximum value at any given track and we also have to do the pre-order traversal for because we are following the principle of root then left and then right and you can do this recursively or iteratively it's up to you uh we will see that in the coding if we see time complexity it's pretty straightforward it's going to be big of n because we are iterating over every single value in terms of space complexity if you use the rec recursion method it will take big of and if you use iterative method it would not take big ofen and uh let's quickly see the coding solution for this one okay so uh we are going to use a helper method called count good nodes to keep track of the no good nodes we have been able to identify and we are going to pass in the root value we found so far now this count good nodes is actually going to return an integer value that defines that how many number of good nodes we have been able to identify for this particular uh root node then we are in in the initial input we are just returning like the minimum value POS possible because root in itself has to be greater than that so root is going to be the first good node okay now we are going to check okay that uh we are taking in as an input the tree node and the maximum node so far we are checking for an edge case that if the given node is equal to null we can simply return this zero if that is not the case we need to initialize our count to zero then we are going to check that if the given current node value is greater than the maximum value we have been able to identified if that is the case then we are going to update the counter to one and we are also going to update the maximum so far to the current node that we just found out once again we are going to repeat the same process for the upcoming subsequent uh left child and for upcoming subsequent right child and we are going to add the values of the left child and right child to our existing count value as well so whatever count they come back with we are going to add them to our existing count and in the end whatever the final count we found we are going to return that and that would be return as part of the answer for this one so that's it let's try to run the code okay seems like our solution is working as expected let's submit this code and our code runs 100% faster which is pretty awesome because this has to be some of the fastest code because that run time is also not 0 millisecond so we are doing something really awesome over over here uh once again solution is posted on our GitHub repository so feel free to go ahead and check it out thank you hello friends we are not Ed by Fang company so let's not stop lead coding till we get there today we are going to do validate binary search lead code problem and if we see some of the companies where I want to get a job who already asked this question there are companies like Amazon Microsoft Bloomberg Facebook Uber Google Apple by Dan lift LinkedIn and Netflix so that's why I'm paying my at most attention I hope you also enjoy the video this is a lead code medium problem and one of the most like tree problems on lead code basically we are given the root of a binary tree and we need to determine that whether that given tree is a valid binary search tree or not we are also given the definition that what a valid binary search tree is basically uh for any given tree if this note value or the node value uh so if this is the value of the node basically every single value that is present on the left of the node should be less than whatever this node value is and every single value that is on the right side of the node should be greater than whatever this node value is so if that is the case and that is true for the entire given tree we can Define it as a valid binary search tree so let's take couple of examples that are shown over here so in the first example well basically the node value we have is two so the and in the left sub Tre only have one value that is one which is less than this two and on the right sub tree we only have one value again which which is three which is greater than uh this node value to so in this case we can consider this to be a valid binary search stre and in this case we will return true but if we take a look at the second example so in the second example we are given this root value as five uh so this value node value is five that is okay uh if we see on the left sube we only have one child and that is the value is one so this is again less than whatever the value we have for the node value now if we see on the right sub tree the value of this is actually Four so four is again less than five so because this four is less than five and remember that we have the definition of valid binary search tree that everything on the right sub tree should be greater than whatever the node's value is so in this case this value is actually not greater than the value of this root node so in this case this is not in valid tree so in this case we will return false and uh this is what we have to define basically now based on the definition we can Define that what a valid binary search tree is that for any particular given node if it's left entire left sub tree if that is less than the that node and if it's entire right sub tree if that is greater than that node we can Define that to be a valid binary sarch tree well if that is the case uh the first intuition that comes to our mind is that for any given node value what we can do is we can check its left child and right child if the left child is less than it and right child is greater than it if that is the case we will keep on repeating the same process for all the subsequent left child and right child with it root node and in in the end if we reach to the end of this tree we can return true immediately saying that this is a valid binary search tree well uh let's try to apply that same logic for this particular example basically we are given this node five so this three is actually less than five and8 is actually greater than five so in this case this portion is actually valid now again for this three this one is less than it and four is greater than it again this portion is also valid and uh same is true for this 8 6 and 9 as well so in this case we can Define this to be a valid binary search tree and we can return true in this case saying that this is a valid binary searry but the thing is this solution is not the most optimal way to solve this problem and let me quickly show you why because based on the same logic for this five uh this three and 8 again okay this is less than this is greater than so so far this is valid again for this three this is 1 and four so this is less than greater than again this is valid but now for this eight this is also 2 and N so this is less than greater than again this is valid so all three portions are valid by definition we would treat this to be a valid binary search tree and that would actually be a false positive why because uh remember that by the definition for this uh node everything that is on the right side of this tree should actually be greater than this node 5 but in this case this two is actually less than this five and because of that particular case we will need to return false in this case but thing is based on our previous method we would have written true so let's see that what would be the actual optimal solution to solve this problem so the idea for the optimal solution in this case is that we are actually going to do in order traversal on the given binary tree to determine that whether it's a valid binary search tree or not uh well if you want to learn more about different types of te traversals you can check out the video over here now let's get back to the question at the end so basically what the idea I'm suggesting is that if we do in order traversal in any given tree basically the idea for in order traversal is that first of all we visit the left sub tree then we visit the node and then we visit the right subtree also this in order traversal is a depth for search kind of a traversal where we are actually going in the depth first and then we are visiting the different nodes so in this case the traversal that we are going to do is that first of all we are going to do the go for the left sub tree so for this node left node exist again for this node left node exist so first of all we are going to visit this left child then uh this child does not have any more children of its own so now we are going to visit its node so we are going to visit this node three and then again we are going to visit Its Right child which is four in this case after doing that we are going to visit the node and then we will keep on repeating the same process so let's see that what is the path we are going to take for this in order traversal well for this problem basically the path we are going to take is that first of all as mentioned we are going to visit this node number one so first node is going to be one then going we are going to visit node number three and then we are going to visit node number four in the fashion of left node node and then right Sub sub node then we again we are going to visit the node so we are going to visit node number five now we are start we are start going to keep on iterating on the right sub tree so even on the right sub Tre again we are going to follow this method of left node and right so for this left sub Tre now this becomes the the root node or the node and this also has an left subtree existing so first of all we are going to visit this node number six then we are going to visit node number eight and in the end we are going to visit this node number nine so this is the in order traversal for this given binary uh tree now the thing is if you see this uh traversal basically everything is going in uh increasing order and this whole thing is actually sorted and this is the property of this in order traversal that we are going to make use of and we are going to solve it optimally the idea is uh for any given tree that we are presented with we are going to do an in order traversal and during the inorder traversal basically the only thing we have to keep track of that any given node that we are iterating whether that node is actually uh greater than its previous node or not if it is not greater than greater than its previous node immediately we can return false so in this case because this was a valid binary search tree we were able to get an in order traversal that is complet in increasing order and all the previous nodes they are actually Less in value compared to its next subsequent node and this property is maintained throughout the entire Journey now uh let's see one example where this is not the case so in this example we can clearly see that this node two is at the correct place and this is not a valid binary search tree so let's see the in order traversal over here in this case the path is going to be the next node we are going to visit is actually two and if we compare this node two to its previous value the previous value is actually five five is actually greater than this two which should not be the case and immediately at this point only we can conclude that this is an invalid binary search tree we will return return false immediately in this case and that is the answer we are going to use now actually there are two ways to do in order traversal for any given binary sear tree there is an iterative way and there is a recursive way if you know me I like the recursion better so I'm going to show you the recursive way in the coding but it can be also done eratively as well and the tricky part in this problem is to identify that we need to solve this problem using in order traversal if we see time and space complexity in this case the time complexity is actually going to be bigger of n where n is the number of nodes that are present for the space complexity uh we are using recursion and we might have to uh store uh n characters in the worst case scenario first of all we are actually going to define a global variable called previous to store the value of the previous element now let me create a new in order method that would be our recursive method so now I have created a new in order method that returns a Boolean answer and we are taking just a root value as the input now first of all we are going to create the terminating case that if the given root is equal to null we are going to return true if that is not the case first of all for the in order traversal we will have to call the leftmost function or leftmost value so we are going to do that so uh first of all we are going to see that if the answer for the root dot left if that is uh false we will return false if that is not the case we will move on towards our next condition okay so if we did not return false from our left side sub traversal then we are going to check our condition so the condition we are going to check is that whether the current root value if that is less than or equal to the previous value if that is the case which means that we have actually found an invalid binary search tree so we can return false immediately so if we don't return false by this point which means the previous value was actually less than whatever the current root value we have which is a good sign so now what we are going to do is we are going to update the value of our previous uh variable so that is going to be the current root value and then after that we are going to call the right side sub tree as well so uh we can simply return the in order uh for the right sub tree now from our main method all we will have to do is we will set up we will have to set up the value of the previous character uh so initial value is going to be the null and then we are going to call uh this uh in order method okay seems like our solution is working as expected let's submit this code and our submission runs pretty efficiently compared to a lot of other Solutions and that is because the code runs in 0 milliseconds uh I would be posting this in the comment so you can check it out from there thank you hello friends we are employed bying company so let's not up elete coding till we get there today we are going to do K smallest element in binary search lead code problem and if you see some of the companies where I want to get a job who already asked this question there are companies like uber Amazon Microsoft Facebook LinkedIn Apple Google and Bloomberg so that's why I'm paying my at most attention I hope you also enjoy the video so this is a lead code medium problem and basically we are given the root of a binary search tree and we are also given an integer called K now we need to return K's smallest value from all the given values inside any given binary tree so let's try to understand this with couple of examples that are presented over here so this is a binary search tree we are given and if you notice the important property of binary search tree where uh for whatever the root node everything on the left sub tree is less than that root node and everything on the right sub tree is greater than that Ro root node that is present for this BST so that is the definition of binary sey I'm just making it clear and now for this example this is the binary searer we are given and we are also given the value of K to B1 which means we need to return first smallest value so in this case the first smallest value or the smallest value is going to be this value one and this is what we need to return as the output let's take one more example so in this case again we are given a binary search Tre and we are also given the value of K is equal to 3 which means we need to return third smallest value if we see in this case this one is actually the first smallest value uh same way this two is the second smallest value and same way this three is actually the third smallest value so in this case we will have to return this three as the answer so I hope that you have understood the problem by now now let's see that what is going to be the optimal approach to solve this problem okay suppose this is the binary search tree that we are given and we are trying to find the K smallest value at any given position so the idea I'm suggesting is that for this particular binary search tree if we make the sorted array of all the values and we sort them in increasing order then whatever this array we have created that is already sorted uh based on this it becomes pretty easy for us to find the K value how all we have to do is just look up in this array and we we will be able to find the value let me quickly show you what I mean so for this particular binary search tree if we see the sorted path where the first value is one then we have the value three then we have the value four and then we have 5 8 and 9 and this is the sorted path that we have we have been able to generate now once we have this value it becomes pretty easy for us to find any K position uh how uh suppose we are given K is equal to 2 we can immediately return second smallest value which is the second value in this case which is the value number three if we are given K is equal to 5 then we simply need to return this value number 8 uh if we are given K is equal to 3 we can simply return this value number four so now you you get the idea that once we have this sorted path it becomes pretty easy for us to find any Cas position so all we will have to work on is that from this given binary search Tre how can we actually create create the sorted path and if you know or if you have followed my previous video you know the answer the answer is actually in order traversal so let me quickly show you the optimal solution using in order traversal for this problem okay so in order traversal actually a depth first search kind of a traversal which means that first of all on the left side of the sub we go to the leftmost position then we visit its node or its root value and then we visit its right subter and we keep on repeating the same process so so let's see that what is going to be the path in this case so path in this case is first of all we are going to visit the leftmost element which is one so we'll visit node number one then we will visit node number three then we will visit node number four based on following this left node and right formula after that uh we will visit the node again which is five and then we will be on the right side of the subtree so again on the right side of the sub tree we will have to follow the same path left node and right but in this case since this right side of the sub tree does not have any left children so we won't be able to upd or Traverse any left value but we would be able to Traverse the node value so again we will travel the value eight and then in the end we will Traverse the value number nine so in this case this is the path we are able to generate from this uh given input binary search tree using this in order traversal and if you see this path this is actually increasing order and this path is actually sorted which is very good for us so suppose we are given the K is equal to 3 so if k k value is three we can simply return four immediately if we are given K is equal to 5 then again then we can return this value number eight immediately as mentioned earlier and this is the approach we'll have to take to solve this problem optimally uh now if you want to learn more about different kinds of tree traversal check out my video over here now let's see the time and space complexity in this case the time complexity is actually going to be big of n where n is the number of nodes that are present inside any given tree and if we see space complexity the space complexity is also going to be big of n to accommodate our in order traversal there are actually two ways to solve this problem one is the recursive way and second one is the iterative way now since you know me I like the recursion better and even in the coding first of all we are going to create our recursive method called in order and that is going to return an array so I have created the in order method that takes in a root value and also that takes in an array list now first of all we are going to check the terminate in case so if the given root is equal to null we can simply return uh whatever the array value we have if that is not the case is first of all we are going to call the uh in order function again and we are actually going to call for the left sub tree so we are going to call with the root. left child and we are also going to pass in the value of whatever the array we already received uh once that is done we are also going to add whatever the uh node value we have so we are going to add the value for that particular root and uh in the end we are also going to call the in order method again for the right side of the sub because remember for the in order we are actually following the method of left node and right so with this time we are going to pass in the value of the right side right side and we are also going to pass in the value of the whatever the array we have created now once this method runs simply we need to return this array list that we have been creating okay now from the main method uh first of all we are going to create a new array list called nums in order to populate this we are actually going to call our in order method and we are going to pass in the value of the root and we are also going to pass in the value of a new array list since that is done all we will have to do is basically from this array list we simply have to return whatever the K minus one position element is because remember this K is actually one index meanwhile the array list we have been creating that is zero index so that is one tricky thing that we will have to take care of uh let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs pretty fast compared to a lot of other Solutions it is also very efficient in terms of space complexity as well and I will be posting this in the comments so you can check it out the solution from there thank you hello friends we are still not employed by a f company so it's not stop lead coding till we get there today we are going to do construct a binary tree from pre-order and in order traversal lead code problem and if you see some of the companies where I want to get a job who have already asked this question there are companies like Microsoft Amazon Bloomberg Apple Uber by Dan Google Facebook and Linkedin so that's why I'm paying my at most attention I hope you also enjoy the video now this is a very hated lead code problem and let me show you why this is from the solution tab of the lead code problem where people have Express their views very abruptly some people are saying why God why some people are saying that it's time to leave for himalay some people are saying that if you get this question they do not want to hire you and things like that there are many other comments the thing is we do not want to focus on the negativity let's try to see that what is the approach to solve this problem and then we are going to see that how can we be able to solve this problem if we encounter this in any interview because our aim is to get into Fang not just dream about it now this is a lead code medium problem but in my opinion this should have been a lead code hard problem now let's try to understand the problem basically we are given two integer arrays called pre-order and in order and basically they are the pre-order traversal of binary tree and in order traversal of the binary tree now based on these two arrays that we are given we need to construct and return the original binary tree so let's try to understand this with an example so over here we are given as an input we are given two different arrays pre-order array and in order array now somehow if we iterate over this pre-order in order array there is only one combination of binary tree we can make and which is this one so that is the example that is given over here now let's see that what is going to be the different approach to solve this problem but before we do that the important thing in this problem is is to understand that what is a pre-order traversal what is the inorder traversal and how can we use that properties to our advantage so first of all I'm going to show you pre-order and inorder traversal how it works so first of all we are going to learn about pre-order traversal and basically preorder is a DFS kind of traversal which is depth for search if you want to know more about different kinds of traversal you can check out my video over here now let's focus on the pre-order traversal for now so basically in pre-order traversal first of all we visit the root node then we visit its left sub tree and then we visit Its Right sub tree and we keep on doing that until the nodes exist so let's see that for this given example what is going to be the path that we are going to follow so first of all we are going to visit the root node so in this case the first node we are visiting is going to be node number five then we are going to visit its left child so left child in this case is three so again we are going to visit node number three and then again we are going to visit its left side because remember it's root left sub tree and right sub tree so left sub tree still exist over here so we are going to visit node number one now left sub tree does not nothing more exist in the left sub tree so now we will start visiting the right sub tree so now we will visit the node number seven now after visiting the node number seven now there is nothing exist over here so again we are going to go back to the root because we still have to visit Its Right sub tree so we when we start visiting the right sub tree again we are going to follow the formula of root left and right so root node in this case is going to be eight so now we are going to visit node number eight after that we are going to visit node number six and then we are going to visit node number n which is the right sub tree and this is going to be the traversal path that we are going to take now let's see that what would be the in order traversal in the same manner so again as mentioned the in order is also a DFS kind of traversal but in this case the methodology we follow is that first of all first of all we visit the left node then we visit the root node and then we visit the right node so for this given example what we are going to do is first of we are going to go to the left node all the way possible so left node in this case is one so first node we are going to visit is going to be node number one now for uh now we can't go left anywhere anywhere so now we are going to visit its root node so root node is in this case is going to be three and then we are going to visit Its Right node so right node in this case is going to be seven after doing that after visiting all three nodes now we don't have any more nodes to travel on the left sub tree so now we are going to visit the root node as mentioned over here because we have already taken care of this left part so now we are going to visit node number five now again we still have values that we need to visit on the right sub tree so again we are going to take on the same initiative so now the first thing we are going to visit is going to be the leftmost element for this right sub tree so leftmost element in this case is six so we are going to visit the node number six over here after that we are going to visit the root node which is eight and then in the end we are going to visit the node 9 over here which is this one so this is how in order traversal works so after understanding both the values and and both the different traversal mechanism let's see that what would be the optimal solution and how we are going to approach that okay suppose this is the binary tree that we are given that we need to iterate over and we are given the pre-order and inorder traversal for both of them so in that this case the pre-order traversal for this tree is going to be and the inorder traversal in this case is going to be now once we have both the values let's see that what is the approach we are going to take so if you closely observe both of these values for pre-order and inorder traversal they both have something to offer the thing they have to offer is that this pre-order allows us to determine that what the root of any section of the tree is and this in order allows us to determine that what is the left sub tree and what is the right sub tree of Any Given tree how let me quickly show it to you so if we see this pre-order traversal the first value in this case is actually the root of the binary tree which is five over here which you can clearly see that the five is the root of the binary tree so well that is interesting information but thing is this alone is not helpful if we see with this in order traversal for this five if we see the left side of this five there is only one entry over here which is three and if we see in this tree actually this three is the left sub tree of this entire tree where the root is five now if we see on the right side the values are 6 8 and 9 which is these three items and this is actually the right sub tree of this original given tree where the root value is five so now we actually have something meaningful that we can use if we keep on repeating the same process now for this pre-order traversal again we see okay so the next value is three so three is already the left sub tree now if we again break it from this in order traversal for this in order traversal we only have three value over here we have nothing on the side we have nothing on the right side because the right side value is actually five which we have already identified the that is the root of this original value three which means we can determine over here that for this three it does not have any values on the left sub and right sub because the very next value of this three is actually five which was already the root of this value uh three so now again we have some meaningful information so so far let's backtrack the information we have found so far that let me create an answer value over here where we have already found that okay the first value is five uh the leftmost value or the first left value of left sub child of this value number five is actually three and for this three it does not have any more children so now we can add the values null null over here okay now we are done iterating up until this point but we still have some more notes that we need to iterate over so based on this preorder traversal now the next node we have is8 so now we know that the current roote we are iterating over is actually 8 okay so we have this value 8 now from this uh in order traversal we actually have these three values where this eight is actually in the middle because remember this in order traversal allows us to determine that what is the left sub tree and right sub tree of any given roote so in this case if the root is8 then the left sub tree is going to be the value six and the right sub tree is going to be the value number nine so we are going to use it to our advantage now uh for this value number six again we are going to try to see that what is on the left of six and right of uh six but in this case since we don't have any more information for this value number six the left value is five which was the original root which we have already iterated over and this next value is eight which was the origin the root of immediate root of this value number six which we have already Tred over so now we can determine that for this six we don't have any other value so which means that we have two null values so again now let's and same thing we can determine for this nine as well that for this nine the leftmost value is actually eight and the in the right there is nothing over here which means this nine also does not have any more children so now let's again backtrack based on the information we have found so far so now on the right side the value we got was eight that was the root we iterated over and we found that information based on the pre-order traversal after finding this eight now we started iterating over the left and right children of this eight so left children was six so we iterated the value six now the six did not had any more children so we had the values null null over here and now then we had the value Number Nine and Nine also did not have any more children so now again we had the two more null values over here and this is the actual binary tree that we were able to create based on this original given pre-order traversal and inorder traversal and that is the solution that your interviewer is expecting and that is what is needed for this problem as well now there are actually two ways to do this problem there there is an iterative way and there is a recursive way if you know me I love the recursive solution so I'm going to opt for the recursive solution basically what we are going to do is initially we are going to find the root value and then we going to find the left sub tree and right sub tree now again we are going to pick one value so we are going to pick the left sub tree so now even for the left sub tree we will have a root value and it's left child and right child and again we are going to keep on repeating the same process and we will be continuing to building our answer and same thing we are going to repeat for our right sub Tre as well so basically we are taking a bigger problem and then dividing it into a bunch of different smaller problems I know this looks really messy but you get the idea of what I'm trying to convey over here and let's see the time and space complexity in this problem so time complexity is actually going to be bigo of n where n is the number of nodes that are present inside any given tree because we will have to iterate over both in order and pre-order traversal and originally it's going to be 2 N traversal but thing is generically we can write it to Big of n if we see space complexity well space complexity is also going to be big go of n because recursively we might have to iterate over all the nodes and it worst case scenario it could take big of n space this is a wonderful time and space complexity given that how complex this problem was and based on the pre-order and in order traversal we were actually able to build the solution for the binary tree now let's see the coding so before we start coding we will actually have to Define that how we are going to use this pre-order and in order array well we are going to use this pre-order array to determine that what is the root value for any subsequent positions and once we have the root value we are actually going to use this in order array to determine that what is the left sub tree and right sub tree for any given route and once we have both the information we are actually able to build our tree now the thing is if you clearly understand that for this in order array we will have to look up at information much in much broader fashion than compared to this pre-order array uh so what we can do is in order to iterate over this in order array rather than iterating it just by considering this to be an array we are actually going to create a hash map where we are going which is going to allow us to iterate over this in order array pretty fast and uh so let me Define two Global variables over here first of all once you have these two information now from our main method first of all we will have to iterate over this in order array and then we will have to populate this in order index map that that we just created so let me quickly run a for Loop uh now we have our hashmap ready to go now we will have to create a separate method where we are going to call the recursion so first of all let me create a new public method so now I have created a new method called array to tree uh that returns a tree node and as an input and I I'm taking the pre-order array uh the left portion and right portion uh and now we are going to create this uh recursive method now before I do that I will also have to initialize the values for this pre-order index and also for this in order index map so that I'm going to do it okay now back to our uh recursive method so for recursion first of all we will have to create a ter terminating case and the terminating case in this case is going to be that if the value of left is greater than the value of right if that is the case we break out immediately and we will return null if that is not the case first of all we will have to Define our root value and root value we are going to Define from our preorder array so uh our root value is actually going to be the whatever this pre-order index value that we have uh and then we are also going to uh increment the value of this pre-order index as well so uh this is the root value and after that we are going to increment the value of pre-order index now since since we have a root value we are actually going to create a new tree node uh called root and for this root node we are going to assign the value that we received over here originally the value of this pre-order index is zero which means that the first value we are getting from this pre-order is the main root of the tree uh once we get that value we will have to create the left sub tree and right sub tree so we will have to call this uh array to tree method again and we are going to populate the value for left and right child so for the left child we are again going to call this array to tree method uh inside the input first of all we we are going to provide this pre-order array as we found as it is now for the left sub Tre we are going to keep the value same for the left value but for the right portion the value is actually going to be different and that is going to be different based on whatever this root value we had so in this case for the first value for this pre-order array the root value is actually three so now for the left part we already have the value but for the right part we are going to have to provide all the values that are present after this root node so we are going to do that so for that now our uh in order index map is very helpful now we have both the information ready to us now we are uh now we are going to call the right subre in the same manner but in this portion we are going to treat whatever the right variable we had already uh but now we are going to change the left variable so left for the left aable we are actually going to use whatever the value we had for the root value and we are going to do it + one and uh as the right limit we are going to keep whatever the right limit we originally had and after this recursion ends and after this function ends we simply need to return the root variable okay so now our recursive method is ready to go now all we will have to do is from our main method we will have to call this uh recursive method that we just has created that should be it so we are we are calling this pre-order method but we are providing the pre-order array and as the left uh position we are providing the value zero as the rightmost position we are providing the value of whatever the pre-order length is minus one and uh that should do the trick now let's try to run this code it seems like our solution is working as expected let's submit this code and our code is pretty efficient compared to a lot of other Solutions I would be posting this in the comments so you can check it out from there thank you hello friends we are not employed by Fang company so let's not stop lead coding till we get there today we are going to do binary Tre maximum path some lead code problem and if we see some of the companies where I want to get a job who have already asked this question there are companies like Amazon do Dash Facebook Microsoft Google bite dance Tik Tok Snapchat Twitter Apple Uber and Linkedin so that's why I'm paying my most attention I hope you also enjoy the video so despite being a hard problem this is a very well-like problem on lead code uh basically we are given the root of a binary tree and we need to return the maximum path sum for that particular non-empty path so we will have to understand couple of terminologies over here uh we will have to understand that what a path sum is and before we understand that we will have to understand that what a path is lucky for us we are given definition of both of them so a path is a binary tree SE sequence of nodes where uh each pair of adjacent nodes in that particular sequence has an edge connecting them and we are also told one very important thing that any single node in that sequence can at most appear once we are also given the note that it is not necessary that path has to go through the root of the node okay so over here I have drawn a couple of different trees and I'm going to show you some examples of what a valid path is and what an invalid path is so first of all this is a valid path and for that we'll have to understand that why this path is a valid path because all the three nodes that are connected in this particular path they are adjacent to each other they all have an edge connecting to them and they all appear at most once and nothing more than that now this is also a valid path and this is also a valid path this is also a valid path and this is also a valid path both paths are valid as well and the path that looks like this this is also a valid path and the path that looks like this this is also a valid path now let's see some examples of an invalid path suppose I start my journey over here I go up I go down I go to the left child and then again I try to go to the right child again this is an example of an invalid path because this node appears twice as well now we know many examples that what a valid path is now let's see that what the problem is actually asking us to solve after understanding the definition of a path we are going to understand the definition of a path sum basically it is the sum of all the nodes that are present inside this given path so that is actually quite simple to understand and the problem is actually asking us to find the maximum path sum that we can make out of given binary tree so now I have drawn three different trees to understand the maximum path sum for each one of them so first of all for this particular tree the maximum path sum is going to be this path and why because all the nodes are positive and if we take the sum of these three nodes it's actually going to be 5 + 4 + 9 which becomes 18 and this is what we need to return in the answer if we take the second example things are not as easy as the first one why because we are dealing with a negative value over here so in this case even if we try to do the same path that we had drawn over here this won't work because the sum of this is actually going to be which is not the most optimal path we can achieve the most optimal path in this case is going to be this one with and the sum is actually going to be 5 + 4 = to 9 and in this case we will have to return nine so in this case the maximum path actually is going to be this one between these three nodes why though there is a positive value over here if we were to include this positive value the path we would make would looks like this and that would actually go through this root value which has the value of -11 which actually brings the total path down or total sum down so that is why it is not in our best interest to include this node and that is why the maximum path in this case we can achieve is amongst these three nodes where the sum is actually going to be 10 plus + 8 + 2 = 20 and that is what we need to return now before we come up with the optimal solution I'm going to show you a few different concepts with various examples so first of all we have an example of trade that looks like this where in this case all the nodes are positive which means things are a little bit easy for us and our aim is to find the maximum product sum we can achieve right so the idea is at any given portion we have the root information now from this root information what we are going to do is we are going to see that what this left sub tree has to offer and what this right subtree has to offer and then addition of all of them should give us our maximum product sum so in this case this left subtree does not have any more children it only has one node which means it can the maximum value it can contribute towards the maximum path sum is going to be five so we have the value three already from this root then we gain this five from the maximum path sum and then again we gain this two from this right sub tree so the total maximum path sum we can achieve is going to be 10 which is the answer in this case and since all nodes were positive it is in our favor to include all the nodes so that is one way to do it right and this is a very simple example so we are able to understand it quickly now let's try to see that what would be the approach in a little bit more difficult uh scenario so suppose we are given a tree like this in this case we actually have a negative value so if we apply the same logic over here this left sub child has minus 5 to offer this right sub has plus2 to offer and this root value is actually three so maximum path sum based on the previous logic would actually become zero if we just do sum of all the values but that is not we are going not what we are going to do we are also going to check at any given moment that whether the value that is being contributed if that is less than zero or not if that is less than zero immediately we are going to discard this value which means that we are not going to consider this minus5 to be part of this maximum product sum and in this case what we are going to do is we are going to do this 3 + 2 because both values are positive so in this casee the answer we are going to get is five so we gain one more important thing that whenever we see minus values we are going to ignore that from our maximum production because they don't add any more value over here now one more thing we need to consider what if we are we have multiple nodes and then what should be our approach in that case Okay suppose we are given an example like this in this case what should be our approach well we we want to find the maximum path sum so again we are going to repeat the same process we are going to see that for this root node what is this left sub tree has to offer it has to offer maximum five value so we are good up until this point for this right sub Tre actually we will have to calculate that what is the maximum value it can offer and how we can do it we are actually going to take this root value because that is going to be the part of this right right sub tree for sure so we already have value as8 over here now from this eight we actually have two options to be included for our maximum path sum we can e either do 82 or we can do 81 so in this case obvious choice is going to be two because two this value two is actually greater than this value one so in this case we are going to ignore this one and we are going to keep this 2 which means that we can do 8 + 2 to be 10 so in this case we can determine that this actually has the value 10 to give towards maximum path now the question will come to your mind is that why in this case we only choose value 10 and why not we choose value 11 well what if in under what circumstances can this value become 11 it can become 11 if we include all these three values to be part of this maximum path sum but we already know that this goes through the root value which means that uh if we were to include all these three values uh to make the value 11 it won't work because then the path would look like this it would go from 5 to 3 okay so far we are good then again through 8 now from the is 8 we cannot include both one and two because suppose we try to do it we include this one and then we try to go back to two we come up at this eight again and we know that that cannot be part of a path sum so that is why we only have the option to choose either one or two so that is the important important detail over here that is why for when we were calculating the maximum contribution this right sub can make we can we only had two options either we could do 8 + 2 or we could do 8 8 + 1 but not both of them so just remember that that is why I showed you this example so in this case the maximum contribution we can get from this right sub tree is going to be 10 so now let's calculate the maximum path sum in this case so the maximum path sum is going to be the root node is 3 plus this left sube can contribute value five and plus this right sub Tre can contribute value 10 so the answer is going to be 18 and this is what we need to return in this case so so far we have understood we had gained very good understanding of many different cases now let's consider one more case where the Things become little bit more interesting and why it becomes interesting because so far we are under the impression that we have to take this root value as part of the answer but what if that is not the case what if we encounter some possibility where this root value does not need to be part of the main uh maximum path sum that we take then how do we approach that so let me quickly show you an example for that as well okay this is the last complicated example now in this case we are again going to apply the same logic to find the maximum path sum but we are going to do some interesting things so first of all we have this root value to be minus 3 right now we are going to see that what is the left most contribution it can get it can get three as as the contribution in this case now again for this portion we are going to see that what is the rightmost contribution it can get the rightmost contribution it can get in this case is going to be this 8 + 2 so 8 + 2 is going to be 10 so far right now if we see over here here actually this is not the most optimal way to approach this why because this path actually gives us the maximum path sum so let's see that how can we actually determine that well when we are traversing we are actually going to have a variable called path to keep track of what is the current maximum value we have found so far and whether do we need to include a new root and new root in this case is going to be the condition where we actually refrain away or move away from the original route we were using because if we were to use this root node there is no way for us to use all of these three nodes uh so that's why we are what we are going to do is we are first of all going to see that if we use this current root what is the maximum value we are gaining so the maximum value we are gaining in this case is going to be 3 which is this one + 10 which is the contribution we can get from this right sub tree so 3 + 10 and let me get rid of this maximum path sum for now so 3 + 10 plus whatever the root value so root value in this case is minus 3 which is in this case the total value is going to be 10 but now when we are traversing or when we were calculating the maximum contribution we can gain from this uh right subtree where the root node is actually 8 the value maximum we can gain from over here is actually going to be this value 8 plus it has the left its left sub Tre is contributing value one and Its Right subt is contributing value two which both are positive values and their total is actually 11 so this is 11 and this is 10 then why are we so Keen to keeping this root to be part of the optimal solution we should not put it in the maximum path sum and we are this is exactly what we are going to do then we are going to choose A New Path and this New Path the value is 11 so then we are going to have a maximum path Su variable where we are going to keep on updating the value and we are going to update the value to be 11 and now it does not have any further more nodes to check for and then we are going to return this 11 to be the answer and at any given moment whenever we find that the new path we are getting that gives us better answer than whatever the previous answer we were getting then we would update the New Path and we will update the value of the path variable so that is one tricky part that we have to understand in this question and now let's see that after understanding all the concepts now let's see that what would be the way to solve this problem uh the idea is uh let me clean this up a bit now I'm going to use the same example to quickly walk through this problem uh so first of all we are at this root position what is the left contribution we can get which is two the the right contribution we can get in this case it's going to be 10 uh we actually calculated all of them uh now the sum of these two is these three is actually going to be uh 10 only but when we were calculating that uh we had this path variable where we actually calculated the value of this to be 11 and we updated this path variable and then we are going to have this maximum path value where we are going to keep track of the maximum path we have found so far and in the end because it does not have any more children we are going to return the maximum path to be uh 11 and this is what the answer we need to return so basically we are taking a bigger problem and then we are dividing it into bunch of different parts that for this root we are actually see trying to calculate this left sub tree and right sub tree then again for this root value we are again in this Left subra Right subra which means we are solving this problem recursively and that is how we are going to approach it and also let me show you the time and space complexity so time complexity in this case is actually going to be big of n why big of n because at any given moment we will have to iterate over all the nodes that are present inside this given tree and the space complexity is going to be big go of H where H is the height of the tree so first of all we will need a separate method called Max gain to calculate that what is the maximum value we are gaining so for that we are going to create a new method that takes in uh node as an argument we will also need a maximum sum value so we are going to initialize it as Global variable and we are going to assign it to the most negative value possible so okay now let's start implementing our Max gain function so first of all we are going to have the terminating case that if the given node is equal to null we will return zero if that is not not the case we will need the values of left gain and right gain for any any given tree node so we are again going to call the recursive function for that we are going to create a variable called price New Path that we are actually going to calculate by using the node Value Plus whatever the sum of left gain and right gain is now that is done we are actually going to calculate the max sum we are going to compare it with whatever this new path we are calculating and once that is done basically all we will have to do is simply return uh the node value with whatever the maximum value is amongst this left gain or right gain from this Max path sum method we will have to uh call this Max gain function so let's do that after all the calculation we are simply going to return whatever the max sum we are able to achieve okay and now let's try to run this code seems like our solution is working as expected let's submit this code and our solution is actually pretty efficient and faster than lot of other solution and I will be posting this in the comments so you can check it out from there so today we are going to do serialize and deserialize binary Tre lead code problem and if you see some of the companies where I want to get a job who already asked this question there are companies like Amazon Microsoft moft LinkedIn Uber Google Facebook do Dash Tik Tok Apple Snapchat Splunk and Goldman Sach so that's why I'm paying my at most attention I hope you also enjoy the video Hello friends the reason I have not been uploading in recent days is because I just had twin baby girls and uh so yeah that's the update and now let's move on to the video so lead Cod thinks that this is actually a hard problem but in my opinion this is not a hard problem it's actually very creative problem uh basically we need to serialize and deserialize the given binary tree now first we'll have to understand that what does serialize and deserialize means well uh serialization is the process of converting the given data structure which is Tree in this case and we need to convert that into a sequence of bits so that it can be stored in some memory or file buffer and then we can transmit it across any network now in this problem basically we need to design an algorithm where we are actually serializing and deserializing a binary tree so serializing means that first of all we are finding a way to convert the given binary tree in some sort of uh bits and in this case we are told that we need to convert it in strings so we are familiar with that and then deserialize means that we need we are given the string and we need to write an algorithm to convert this string back to a binary tree so we'll have to do both the things and if you see this problem this is actually very similar problem that we did earlier with strings uh this is the solution of that problem so go and check it out first we are also given a clarification that we can be as creative as we can with the serialization and deserialization process so we can have different way of serializing the tree and different way of deserializing the tree as long as we maintain the tree data structure uh so let's see that what is the approach I'm suggesting and you can also come up with your own own own creative approach well basically in this problem we are only given the root of a tree and then somehow we will have to go over the entire tree and then uh Traverse it convert this given root and all of the entire tree into a string and after we have converted it to string we will have to find a way that suppose if we are given the string as the input how can we convert from the string this binary tree as well so we are doing both the processes so the important thing in this case is that we will have to Traverse over the given binary tree there are mainly two strategies to Traverse over the given binary tree DFS and BFS and I have explained this very carefully in the previous video you can check it out over here so basically in this video what I'm suggesting is that we actually go with pre-order approach with using DFS to serialize and deserialize this given binary tree and I will be showing you that what is the process We are following so first of all we are going to serialize this given tree which means we are going to take this binary tree and we are going to convert it to a string now as mentioned earlier we are going to use the pre-order traversal for that so if you are not familiar with the pre-order traversal basically we visit visit the root node first then we visit the left child of this root node and then we visit the right child of this root node and that is how we are going to end up creating the string from this given binary tree so let's see that in action so first of all U let's create a variable called s or string where we are going to store the string value so first of all we are going to visit the root node the root node in this case is one so we are going to add an entry called one over here now we need to visit the left child of this root and then we need to visit the right side of this roote now remember this is actually a DFS policy see so in the DFS we go in the depth first so first of all we are going to visit the left child so left child in this case is two so we are going to add an entry that two is the left child over here and then again for this two because we still have left child left so we are going to visit that so for this two the left child in this case is actually Four now for this four we don't have any more left child and we don't have any more right child which means that first we try to visit the left child for this four there is no left child so we enter a value called null over here and then for this four again there is no right child so again we add value null over here saying that for this four the two left child and right child is actually a null value now after that we still have nodes left that we haven't visited for so now for this node two we have this node five and it's right so again we are going to enter the value five over here after entering the value five we are again going to check the left child and right child for this five so left child in this case is null and again right child is also null so we will add two more entries null null again and now we go back so now we have visited all of these nodes but the thing is we haven't visited the right portion of this original root node so again we'll have to iterate over the right sub tree so right sub Tree in this case is going to be three so we add three over here now for this three again we don't have any more children node so again we add two null values so this is the answer in this case that we have to return for this given tree that this is the string value that represents this given binary tree now let's see that what would be the D serialization process so now we are going to work upon the Der serialization so basically we are going to convert string into binary tree so the idea is this is the string we generated from the serialization process now again we are because we are using pre-order traversal we are actually going to apply the same logic so we are going to treat the first node to be the root node then the next node would be the left sub child of this root node and the next road is going to be the right sub child of this root node and we are going to keep on iterating this process in in reverse order so the idea is that first of all okay we identify this node so this node is actually our root node okay so root node is actually one in this case now again this two is actually the left child of this root node so because this left child exists the the next node is again going to be the left child of this node two so again we are going to create a node four that is left child of this node now now for this four the next two nodes are actually null null so because we encounter two null values which means this four does not have any more children so we can just ignore that okay now we still have a node five which means that this five is actually the right child of this two because we have already visited the left sub tree of this two so now because we are done with the left subtree now we are visiting the right sub tree so we are going to create one more entry five over here as the right sub Tre again we have two more null values which means that this right sub tree is done now we don't have any more values okay now we still have values which means that this actually refers to a root node where we haven't visited the left and right sub tree because remember that this is the left sub tree we have visited for this two and this is the right sub tree we have visited for this two but we haven't visited the right sub Tre for this original one so now we are going to do that so now we are going to add one more entry three over here which is the right sub of this original given one and this three actually has null null values which means three does not have any more children so we won't be adding any more entries over here and we can just ignore that now we have reached the end of the string so because we have reached the end of the string we have created the binary tree that we are supposed to create and we have completed the deserialization process and we have converted this string into the binary tree so this is the approach we are going to take if we see the time and space complexity in this case for the serialization process the time complexity is actually going to be a big go of n because we have to iterate Over N characters that are present and the space complexity is also going to be big go of of n because we will have to create a string where we are storing all the N values now for the Der serialization process again the time and space complexity Remains the Same now we will have to create two methods uh for serialize and deserialization so first of all we are going to work on serialize process so I'm actually going to create a new public method uh that returns a string uh where recursively we can apply the pre-ordered traversal and as an input it is going to take the root value and we we are also going to pass the string value now inside this recursive function first of all we are going to find the terminating case so if the given root is equal to null and simply add the value to the string as null if that is not the case which means that root still has some value and it could have left sub tree and right sub tree so now we are going to call the recursive function so first of all we are going to add the value to our string now we are going to call the left sub Tre and right sub tree so we are again going to call this recursive serialized method again we are going to repeat the same process for the right sub once the ends we are simply going to return the string now from our main serialized method all we have to do is just call this recursive serialized method and return whatever the answer we get we are going to pass in root as an entry and we are going to pass in an empty string so now we are done with our serialized method now let's work upon deserializing method now again for the deserializing process uh first of all we will have to create a recursive method to iterate over this given string data and then we are going to convert all the string values into binary tree so we are passing a list of strings in this case for this recursive deserialized method and now first of all we are going to work upon the terminating case if the given node is null we can simply remove the value and then we can return return null okay if that is not the case first of all we are going to note the whatever the value of this current string is we are going to treat is as a root node and then we are going to call the left sub tree and right sub tree so we are going to create a new tree node called root so whatever the current value of the string is we are going to treat it as a root node then after adding the root node we are actually going to remove that value okay now for the left value we are again going to call this uh recursive deserialize method and that should be it after this ends basically we should have a root variable so we can simply return root from this main method first first of all we will have to create a an array of string where we are actually splitting the string based on the comma that we initially created after doing this we are actually going to convert the string array into a list of strings now we will simply return whatever the answer we get by calling this recursive method that should be it now let's try to run this code okay see seems like our solution is working as expected let's submit this code so I'll be trying to see other faster approaches and see I can uh show make a future video on that but so far you can find this code in the comments so you can check it out from there thank you hello friends we are still not Ed by Fang company so let's not stop lead coding till we get there today actually we are going to learn about a new data structure and we are actually going to learn to imp ment a try or a prefix tree and if you see some of the companies where I want to get a job who already asked this question there are companies like Amazon Google Twitter Microsoft Oracle Apple Facebook Goldman Sach Uber and Bloomberg so that's why I'm paying my at most attention I hope you also enjoy the video so this is a lead code medium problem and basically we are going to implement a try over here or a prefix tree so first of all in the problem statement we are given the definition that what a try is and actually I'm going to show you very eloquently that what a try is and how it works but let's understand the definition first basically a try is a prefix tree which is a tree data structure that is used to efficiently store and retri keys in a data data set of strings uh there are bunch of different applications of this try data structure and I'm going to go over all the applications soon as well now if we see that what is needed in this problem basically we need to initialize a try object first of all then we need to create three different methods which are mentioned over here so first method is the insert method which does not return anything and basically we are only given the input as a string word and we need to insert this word in inside this new try object that we are initializing after doing that we could be given a search method where again as an input we are given a string called word and we need to return true or false which means that whether if this word exist inside this try object that we have created we need to return return true otherwise we need to return return false and there is also one more method where again we are returning true or false uh and the name of method is starts with where we are actually given a string and the name of the string is prefix but basically we need to check that whether this prefix actually exist as a part of any existing word inside this TR object and if that is the case we need to return true if that is not the case we need to return false so here is an example that we are given so suppose we are given as an input where actually uh first of all we are creating the try we are inserting this inserting some word we are searching for some words we are doing the start with operation and uh this is the explanation so basically we initialize the try object as mentioned then first of all we insert the word Apple so okay so currently Apple exist over here now again we search for that whether Apple exist or not and because it exist we return true as the answer again we search for with the word app but thing is remember so far we have only inserted the word Apple app does not exist as a whole word so that's why we we return false again we search for starts with method for this word app and remember because this apple this app is actually a prefix of this Apple so we return true in this case and so on and so forth we can do bunch of different uh operations so this is what is needed now let's understand what a try is okay so first of all let's try to understand that what a try actually is basically a try is a tree like data structure but it's a little bit different and a different variant of a tree now if we know for any single tree the basic properties are that every single tree has a root nodee now this root node has some subsequent children nodes there could be a number of different childrens and those children can have some children of their own and their links actually found some meaningful relationship so that is what we are going to use uh to generate this trry but we are actually going to generate this try to store different string values uh per character that is the important property per character so it makes us easier to understand or find different words or different strings and there are a number of applications of a try let's try to understand try with some example so first of all as any different tree we are actually going to have a root node right now suppose for this root node what we are trying to do is we are of course we are trying to add some different string value so let's take a string value suppose the first string we are trying to add is the actually the word uh Fang so if we take this word Fang first of all we will have to add the word f because remember I already told you we are going to do it character by character then we will add a a n and G we are going to add it in this sequence so in order to do that logically speaking for this root root is going to remain common but thing is first word we will have to add is fan but the thing is first we will check that whether is there any children of this root node which is actually F if that is the case we are actually going to leverage that but this does not have any children so if this does not have any children we are actually going to create a new children F now again with this F there is no children that is a so again we are going to create a new children then again we are going to create a new children and then we are going to add the values of N and G as well after adding this we have actually created a root inside this Tri data structure which represents this word Fang that we were originally trying to uh create after creating that we will have to find some way to identify that this Fang word has actually ended so what we are going to do is we are actually going to create a special character or a special node over here which we are going to denot ASE an end node which defines that the word has actually ended over here right after doing that let's try to add one more word so suppose rather than Fang we are trying to add the character mang so let's try to again add mang over here now for this mang first of all we are going to check that whether this m exist as one of the children of of this root node so m is also no children so first of all we are going to add m m and then we are going to add subsequent characters and we are going to link them with this uh path after that in the end we we are actually going to add a special character and denote that the word has actually ended over here so let's do a quick recap basically what we have done so far is we have actually created two separate branches uh where if we go depth first search diving in those branches we would actually find those subsequent words uh in those particular branches so it makes uh pretty efficient for us to identify any string and to see that whether it exists or not and predict that what the person is going to copy now suppose we are I'm trying to add the next word fan now for the adding this next word fan what we are going to do is first of all we are going to check F exist or not so F exist over here so because F exist we are actually going to leverage that so now we are not going to add any entry over here again this a also exists as one of the children of f so again we are not going to add any entry over here now this n so n is not a children of this original a so we are actually going to create an entry over here so we have we will create an entry over here uh and we are actually going to name it as n and now since this word ends over here we are actually going to create this end node over here so again remember if we go depth per search in this direction we will actually be able to find this word Fen and that is the whole purpose of a try now let's try to add one more word uh which is men oh sorry ma a a ma so if we try to add this word Ma so first M also exist over here a also exist and a also exist so because these three exist we are actually not going to break this link and create this end word over here or we are not going to do that uh actually we are going to keep this as it is because this MAA is actually a prefix of this original word mang that we have already added to our try and that is why a try is also called a prefix tree so now the word makes sense that why a try is called a prefix tree and basically this is what we are trying to implement there are a bunch of different applications of a try and let's see some of the applications that are really cool in real life real world so before we start implementing the method first of all let's understand that what are different applications of a try so applications like autocomplete where you type something and it automatically gets completed or understood by by that particular product uh that is implemented using try so features like Google Chrome Amazon where you try type few words and then it automatically understands that what you are trying to do and automatically gives you the answer uh that is implemented using that all the spell checks or all the dictionary related mechanisms they are also imped using some versioning of a try games like word search word puzzle word they are also implemented using a versioning of a try and uh features like predictive text search or expected text search that you type something it automatically expects that what could be the next potential words you typically you see that in YouTube Google all the time uh they are also implemented using tries so these are only few but very powerful applications of a try and there are hundreds of them I haven't mentioned them so that's why TR is are important to understand now let's move back to our question and start implementing those three methods so first method they are asking us to implement is an insert method where we are not returning anything but we are inserting different strings into our try so for this example we are actually going to implement these four different types of strings into our try and uh we will see that what would be the logic behind it now as mentioned earlier that every try actually has a root node so again with our try we are also going to have a root node now from this root node the idea we are going to use is that whatever string we are trying to insert first of all we will check that whether the first word that we are trying to implement or the first character we are trying to implement if that is present as one of the children of the existing uh root node or not if it is Children of that particular root node we would keep on branching for that particular uh child and keep on updating the number of characters that we are trying to implement if it does not exist we will actually create uh create a new node or a new brand and we will add that entire word into that Branch now as mentioned earlier the moment we reach to the end of that particular node we will actually have to create an end node to denote that this word actually ends over here so let's start implementing what is being asked over here so first we are trying to implement the word Apple so a does not exist as any of the children of this root node currently it has no children so we will have to create a new node so first we are going to create a new node for Apple okay so let me create a new node a and then I will keep on appending all the remaining characters and after adding all the word because this word ends at this e I'm actually going to create a special node and I'm going to denote it as an end node so that that is to for us to understand that this word actually ends over here and we don't need to move any further okay now next word we are trying to implement is G and also remember one thing I forgot to to tell you that this root can have potential 26 different children right uh and this 26 different children can have 26 different children of their own so the mechanism we are going to implement to find that whether a node contains any particular children or not is actually going to be used based on some key value mechanism and because it's a key value mechanism uh the whole operation of searching that whether any node or anything if that is a part of any children of that particular node or not that is being done in constant time so that it helps us understand helps us to maintain the consistency and speed of our data structure now let's move back to adding the word Google to our try so for the word Google we don't know have any uh children that is starts with G so we are also going to create a new node over here or New Branch over here where first character is G and then we will add all the remaining characters as previously mentioned at the end of the word we are going to create an end node okay now Things become little bit interesting with this word Amazon so for this word Amazon uh when we start checking that whether this a is a children of this root node or not we find that a is already a children so we will keep on updating the value over here that okay we have already find a word or a character that is already a children and then we will keep on moving to the next character so first this a is already present so we ignore that now next character we will we want to find is M so for this m we will try to see that whether this a contains any children that starts with m but thing is currently this a only contains one children that starts with p and not M so we will have to BR create a new Branch over here so let's create a new Branch so new Branch starts with m and then we will add all the remaining word characters over here okay and now the the next word we are trying to implement is amazing for the amazing uh okay we already have a children of this root that starts with a so we have taken care of this m is also present as one of the children okay now a is also present as one of the children of this m okay so that is that is also good now this Z is also present over here now for this I I is actually not present as one of the children of this Z so we will actually create create a new branch over here uh that starts with i and then we will add this n and G over here and in the end we will create or we will add the end node over here and now we have actually inserted these four characters as or these four strings into our try and if you see uh we can find each one of them by going in DFS Motion in any particular Branch so first of all this gives us the value Google this gives us Apple this gives us amazing sorry Amazon and this gives us amazing so that is how tries typically work now let's move on to the next method that is being asked so for the search method for our try we will be actually given a word as the input and we will have to check that if that word exist inside our given try we will have to return true if it does not exist we will have to return false so let's start implementing the same method and actually we are going to use the same that we have create we have created okay so let's use the same try that we have created earlier and we will try to see that whether these four strings uh do they exist inside this given uh try or not so let's understand the logic behind it uh well if the string exist basically all we will have to do is first of all we will check that okay whether the first character if that is the one of the children of this root node or not if that is the children we would keep on checking its children for this next subsequent words and try to complete this entire word if we are able to complete this entire word without this uh try breaking or not able to find the children if we reach to the end we can conclude that this word exists if we cannot come to the end we will conclude that this node does not exist so first of all let's try to see in this example so for the first word is a so a exist over here as one of the children so we will ignore this one now next word is m m also exists so we will again ignore this one the next one is a again this word exist now z i n g uh they all exist in this particular fashion so this word amazing exist inside this given try so because it exist we will return return true as the answer in this case right now let's try to search for this word good now for this word good the first character is G so first character is G present over here so okay we are good up until this point next character is o o is also present again o is also present so we can ignore first three character of of this good now for this next o we do not have a children that starts with value D so because of that uh we do not have any new Branch over here that starts with d so we can actually conclude that the word good does not exist in this case and uh because it does not exist we will return false over here okay now let's try to search for the word googler so again for this word googler Okay g also exist o exist o exist G exist L exist and E exist okay up until this point all the words exist but when we try to search for the next word we actually encounter that okay This is the End node of our try or of our DFS search for this particular direction so because it is the end word we will actually WR return false over here because this word has not been completely searched because it does not exist inside our tribe and we are actually able to do it pretty quickly and pretty efficiently okay so now next word is app so let's try to see that whether this word app exist inside our try or not so first of all we check for this word a a exist over here then this word p p also exist and P also exist right so we are a good up until this point and our mind will say that okay because this word exist we need to return true but thing is that is not the case the idea we are trying to do in the search method is that we are trying to see that whether the whole word that is given as the input exist as only a word inside this given try but for this app if we try to see the next node the next node is actually the is L and E so there are still some characters that exist inside this given uh GFS path that we are traversing and the next node is actually not the end node so because the next node is not the end node and there are still some more nodes that exist this app is actually a prefix of original word Apple but not the whole word as it is so that's why in this case we need to return false as well and this is the important thing that is differentiating between this method search method and the next method we are going to implement now if we see the time and space complexity in this case the time complexity for this method is actually going to be big of n where n is the number of characters that are present that we are trying to search in any given word if we see space complexity for the space complexity we are actually not using any additional space so that is going to be the constant space complexity for this case which is pretty efficient in my opinion so now let's understand our starts with method and we are also going to use the same try that we have created before right and we are going to S see that whether whether the the words that starts with these characters are they present inside our given try or not so again this is very similar to the search method uh where we are going to iterate over word by word or character by character for any given word and we will see that whether that is present inside our try or not if that is present we can return return true if that is not present we will return false so let's see that in action so first of all U we have this character a so a is already one of the children of this root node so okay we are good up until this point then we have m m is also a children over here and then we have a so a is also a children of this one so we can conclude that because this word ended we do not have any more and things to search for and all of the characters they were present inside this given try we would actually return true in this case they're saying that the word that starts with a M A is actually present as one of the uh children or one of the branches of this tribe now let's try to search for this word APK so a exist and P exist but thing is for this P we do not have any children that starts with k so because of that this K is not present uh we can actually return false in this case saying that uh we do not have a word that starts with Apk as the prefix inside our try and remember because we are searching through prefix that is why this is also called prefix tree so yeah mind blown right M mine as well now let's try to search the word good well there is Google but that is not good but I think is Google is pretty good yeah so that's why it's one of my dream companies but let's try to search that so okay this is g o o so go o is present over here but this D is not present as one of the children of this o so because of that we will also written false in this case okay now we have this word Apple so apple is actually the entire word that is present over here and if you look at it we do have a word that starts with the word Apple even though it ends at Apple but thing is also it starts with apple right so and the name of the method is actually starts with so why don't why should not we return true in this case so this will also become true that okay word that starts with apple is present inside our given Tri and that is the logic we are going to use to implement the starts with method again very similar to the search method just a little bit different variations uh now if we try to see the time and space complexity in this case the time complexity is also going to be big of n that is where n is the number of characters that are presented inside any word that we are trying to search if we see space complexity the space complexity is also going to be big go of uh one or constant space complexity because we are not storing anything in our text deck this problem is asking us to implement insert search and starts with method but before implementing these three method first of all we'll have to Define that what a TR node is this is only a tri class so we I would be creating a separate class called TR node now in this TR node class first of all let's go over some basic methods that we are going to use that will enable us to do lot of things uh first of all we have defined a finite number of cases R which is 26 because any single node can only have up to 26 distinct children because each children represents a character inside the alphabet now uh every single trodde has a certain set of links and links are defined by the children of that particular node uh we also created some more methods so let's go over them uh so one method is contains key method where we pass in a character and we get the answer that whether any particular link or any particular node does that contain that particular character as one of its children or not and we can get the answer in a constant time complexity because remember we are using array indexing uh and the in maximum possibility of indexing can be 26 and we can get the answer immediately same we are uh we have a method get where we provide the character and we get the answer that whatever the value of that particular character is inside any of the children of any trode we also have a method put where we provide the value of a character and the node we are trying to put it as and we also have set end and is end method uh that is to Define that whenever we run out of uh words that we need to put in in any single Tri block or any single Tri Branch uh the last node is going to be is is and node and we will Mark its value to be true uh so now let's start implementing the TR node so first of all we will be we will have to create a TR node uh route so let's do that now since we have our root node uh first of all for this public try method uh we are going to initialize the root after doing that first of all let's start working on our insert method so for our in insert method uh we are going to have a root node now we are going to iterate over the given input word we will Define that what is the current character we are at now first of all we will have to check that whether the given node we have if that contains that uh particular key or not so if if the given node does not contain that key we will actually have to create a new entry over here so we will use our node. put method and inside that we are going to pass in the value of the current character and we are going to pass in the we are going to create a new try node for that and then we are going to update the nodes value and once this Loop ends basically the last node we are at we will have to set its value to be the end node so we are going to Mark its value to be the set end value and uh which would basically so it defines that this is the last note uh before we work on the search and starts with method remember both search and starts with method they are pretty similar to each other so we are actually going to create a supporting method uh called search prefix once again we are going to initialize the node to be the root node and now we are going to iterate over the given word so now we are going to check that if the current node does it contains the given character or not if it contains the given character uh we can actually uh set the value of node if it is not present we simply need to return null and that's it and if we somehow reach to the end of this Loop we can simply return whatever the node we have we are at now uh from this our uh search method basically what we are going to do is first of all we are going to initialize our TR node and we are going to pass in the value of the word now we simply have to return return that whether the current node we get in the return and if it is not null and it is end we can simply return true and same thing we are going to do for our starts with method so again for our starts with method we are again going to call the search prefix method and uh basically all we will have to check that uh whatever the return value we get if that is not equal to null if that is not equal to null we can simply return true and uh that should be it let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs pretty efficiently compared to a lot of other Solutions and it is also very uh much efficient in terms of space complexity the thing is I was not able to come up with the solution on my own I actually had to use a lot from the solution tab so I just want to make it clear uh so yeah everyone has to go through it and uh I will be posting this in the comments so you can check it out from there thank you Hello friends we are still not Ed by F company so let's not stop lead coding till we get there today we are going to do design add and search words data structure lead code problem and if you see some of the companies where I want to get a job who have already asked this question there are companies like Amazon Google Microsoft Apple Facebook bance Twitter Uber and lift so that's why I'm paying my atmost attention I hope you also enjoy the video so this is the lead code medium problem and as the name suggests that we are actually designing a data structure where for this data structure we have to support that we can add new words through this data structure and if given any string we we can actually find the previously added words or strings as well so we are being asked to implement the word dictionary class now in the word dictionary class first of all we'll need to initialize the word dictionary object and then we need to create two different methods first method is ADD word method that that takes in a string word as an being done it adds the word to our data structure um that we can use to match it later and then there is a Boolean method called search where again we provide a string word as an input and that returns true or false if that word has been previously added or not uh we are also given one more condition that for the search method there could be dots provided as inputs where we can conclude dot to be any letter so if we are given the word something like bad that is already already being added and then we are are asked to search for the word using B do d uh actually these two words we can consider same because this dot we can consider it to be a so let's try to understand this with an example uh over here we are given a bunch of different ad word ADW and search word mechanisms and uh this is the explanation provided so basically first of all we initialize the object word dictionary now for that uh first we add the word bad dad mad uh we all we add all three these three words now first of all we search using pad so pad is not present so we return false then bad is present because we have previously added it uh then we are also given a word which is a d so this dot can actually mean anything uh and if we see we already have a word like bad and dad that both and even mad that all three of them they actually match with the string so we can return return true in this case as well and we are also given one more search criteria where we are only given B dot dot which means for the these two dots we can conclude any other word and since we already have a word bad added U we can conclude these two to be similar and we need to return true in this case so before we start the solution first let's understand that what a try is uh well uh if you want to check the full explanation you can check out my previous video over here uh now let's move back over here so basically a try is actually a form of a tree whereas any given tree uh it has a root node now this root node can have many subsequent children and each children can have some children of their own uh and based on that we actually use try to it search store and iterate over Different Strings uh and for any given strings we actually use it uh character by character to store distinct values inside this given try and based on the based on per character we actually store it in a manner where it becomes pretty uh fast for us to find that whether any particular parent node contains some character as one of its children or not and then we iterate in some particular fashion uh in DFS fashion to find uh any words so suppose these four are the strings we are trying to add so let's uh initialize our try data structure so first of all we are actually going to have a root variable now for this root variable we are going to store all of these values one by one so first let's store the value hello as mentioned that for any given string we are actually going to go character by character uh so first of all we are going to take the character H and we are going to see that does this root node has a child that is actually starts with H it does not so we are actually going to create a new node over here and this node starts with H now we are going to add all the values of subsequent characters because they don't exist so I'm going to add append e uh L L O and after adding all of these values actually we are going to have an end variable that denotes that this word has actually ended over here so so far if we iterate in this direction in this given try we can form the word hello and when we reach to this o we can we will actually encounter a special node that denotes that this is actually the end node and if that whenever we identify that we can conclude the word has actually ended now uh let's add this word high so if we want to add word high basically first of all we will check that whether this H exist or not so H already exist as one of the children of this route so we do not need to create a separate Branch for this one but the thing is for this particular h i does not exist as one of its children so we are actually going to create a new Branch over here I and we are going to denote that this is this represents this word h and then because this word ends over here we are actually going to denote an end node over here uh let's add one more word uh that is pop so if we want to add pop again P does not exist so we are going to add or we are going to create a new branch and we are going to add all of these values and we are going to add the end node now this next word is pond so again we are going to use the same methodology so p and O exist as the children so first two characters we are done with now from here we will have to create a new Branch so we will do that and after that we will add our end branch and this is the logic we are going to use to implement our uh insert or add method to add different strings inside our word Implement data structure and this is the logic we are going to use that first of all we are going to check that any character exist as the children of the root or not if it exist we are going to leverage that particular Branch if it does not exist we are going to create a new branch and then we will keep on making separations and based on that things becomes pretty easy for us to find different wordss okay so for our search method suppose this is the try that we have actually created and these are the words we have added uh let me quickly go over them so first word is pen if you look at this direction we have the word pen then we have the pot so p is common so then there is a branch out and we get the word pot as well same we have cat C and bed in the similar sequence and uh these are the words we are trying to search so couple of words are just regular words uh then I have added some examples with the dots in it so because they are more complicated ones so we can understand that so let's start let's quickly start to go over and uh see that what would be our search policy for this given uh try that we have created so for for this character part first first letter is p so from this root we are going to see that does there a children that contains the character p and yes we have a child that contains the character P So based on that we will keep keep on iterating in that direction so next character is O so we have o as well and the next character is T so we have t as well now we don't care about this end node because as long as we are able to generate the word that we were given we are good up until this point so over here we will actually return return true to be the answer that yes this word is present inside the tribe that we have created uh second word is pots so again for the pots we up until this pot we are going to go in the same Direction but this s is not present as one of the children of the spot and because we encounter an end node over here so we can uh drop out immediately and we can return false in this case that yeah we don't have any character that matches the word pots now this is little bit interesting example so for this do AR the policy we are going to use is that whenever we encounter a DOT to be a character we will actually have to iterate over every single possible route using this dot to be the character and see that can we make this a r to be part of that sequence or not so let's uh quickly do that and let me clean this up a bit for this do ar ar the strategy we are going to use this for this particular dot we are going to consider it uh that every single child of this root can be used over here and then we will try to see that whether uh is there any place where second character is actually a so first we go down this path okay so P we consider p as dot right then we check that okay this is e and this is not a so we cannot go on this path okay now we backtrack now we keep this P to be dot now again we try to repeat the same process this is a and this is O so again this is not the path we are going to choose this that is going to lead us to this answer uh we come back now okay we are at this position again we check this a child so this child is actually C we consider C to be the dot okay now from the C the next character is actually a and all over here the next character is also a so that is good good sign for us so now we can continue in that direction so now from the this a we will try to see that is there a child that is actually R and yes from this a we also have a child that is r and since we reach to the end of this word we can return true in this case that yes this AR is present inside this try that we created okay so yeah that's a wonderful news uh now let's focus on the next example so next example is do do T so for the dot do T actually we are we will have to Branch out even more so for this second do do T what we are going to do is again we are going to repat the same strategy we will have to go over every single child that is possible so first we'll consider this P to be the first dot uh so this dot is this P okay now from this P we will also consider uh two child to be separate dots so for both the Childs uh okay this is going to be the first dot uh so we are good up until this point but this value is actually not t this is n so we will have to backtrack from this e we do not have any child so we will again backtrack and we will come back to this P to be one dot now from this P we still have one more root that we haven't considered so we will consider this o to be the second Dot and from this o we actually have the last character T present and uh that matches the string do dot so if we go down this path uh we will be able to generate this word and uh that's why we will also return true in this case as well and the same thing we are going to repeat for this eyy uh strategy so for this ey what we are going to do is first of all we are going to consider this to be the dot we will see okay this is e so that is good but we this is not y so again we cannot go down this path uh again this is dot this is not the path this is not the path this is not the path so this ey is actually not present inside this entire Tri block that we have created so over here we will return false but before returning false we will actually check every single possible route to see that whether we can find a match or not okay so that is how we are actually going to implement the search mechanism uh basically the only tricky part is to take care of the dot values apart from that it's pretty simple now let's talk about time and space complexity so for the add function the time complexity is actually going to be bigo of n that depending on the number of characters that are presented inside the input and also for the space complexity it's also going to be big of and depending on the size of the input for the search mechanism Things become little bit tricky over here the time complexity is actually going to be big go of 26 * n why 26 * n because remember for any given dot there can be 26 child of any particular root element that we might have to iterate over and again in the bottom we might have to keep on repeating the same process right so basically the maximum time and space complexity we might have to go over is going to be uh n * 26 but since 26 is a finite number we can also consider this to be bigo of n Only okay and for the space complexity it's also going to be the same is going to be bigo of 26 to the power of n so for this problem we are being asked to implement three things word dictionary add word and search method but thing is before that we will actually have to define a trodde so I'm going to create a separate class for to defining a trodde where every single trodde has uh different set of children and we can easily quickly look up those children because uh we are actually using hashmap to Define them okay now from our main method first of all we are going to create a new try node so now to implement our word dictionary first of all we are actually going to create an instance of this try now for this add Word Method first of all we'll have to create a node uh so we are going to create a TR node uh we are going to run a for Loop across the given word if the current node if that does not contain any children with this character then we will have to create a new entry inside our node and if the entry exist for this given uh character uh we are actually going to go to the next element and in the end we are going to Define node. word to be true so before we start our search method we are actually going to create a helper method called search in node uh that is going to take uh the input word and the try node as the input and that is going to help us to iterate over the given TR node uh so first of all we are going to create a for Loop to iterate over this given word and inside this given word we are going to iterate over character by character so I'm also going to create a new character variable so first of all we are going to check that if the given node or does its children contains this word or not if it does not contain then we are going to check that whether the given character is dot or not and if that is the dot then we might have to iterate over all the subsequent characters of this node once we determine that the children does not contain this character CH we are going to check that whether the CH is actually a DOT or not if that is dot then we are going to run a for Loop across all the the children for every single uh character value and then we are going to define a new trodde called child and basically we are going to call this search in node method iteratively for the next character in that particular word because remember we are already eliminating the dot character and uh providing its child as the trodde and we will keep on repeating this the uh we will keep on iterating this process and we are going to return true if that is not the case and if this given CH character is not a DOT then uh in that case we can return false immediately uh somehow uh this CH is actually a child of this node if that is the case then uh we simply need to iterate over the next value inside this given node and in the end we simply need to return that whether the node do word is present or not and remember we are storing this node do word value inside our uh this add Word Method as well so the moment we identify a matching word it would return true otherwise it would return false now from this our search Method All We will have to do is we simply need to call the uh recursive search in node method that we have created and as the input we are going to provide the value of the word and we are also going to initialize a new TR node or we are also going to provide the TR node that we initialized earlier and that's it uh let's try to run this code okay seems like our solution is working as expected let's submit this code okay seems like our solution worked as expected um it was not the fastest solution in terms of time complexity but in terms of space complex City it was pretty efficient I would be posting this in the comment so you can check it out from there thank you hello friends we are still not Ed by a Fang company so let's not stop lead coding until we get there today we are going to do word search to lead code problem and if you see some of the companies where I want to get a job who already asked this question there are companies like Amazon Uber Microsoft Google Snapchat Facebook Apple Twitter Tik Tok Bloomberg Spotify twitch and Airbnb so that's why I'm paying my atmost attention I hope you also enjoy the video so this is the lead code hard problem and basically we are given an M cross and Matrix of characters now and we are also given a different list of string called words now we need to return all the words that are present on the given board we are also given one more thing that each word must be constructed from the letters that are adjacent to each other so and we are also given the definition that what adjacent cells are basically any cells that are horizontally or vertically neighboring to each other we can consider them to be a part of the consecutive sequence series and we can use them to create words so let's try to understand this with an example over here over here we are given a 4 cross4 Matrix and for this Matrix we are told that these These are the list of words we need to check that whether they are present inside this given Matrix or not so if we try to just look at this example basically we can see that this first word oath is actually present over here where O A T and H they are uh creating or forming this word and if you see they are all sequentially adjacent cells to each other so that's why we can use them to form this words and see whether it's present or not so in the answer first of all we are going to add the word oath as one of the answer then if we look at the answer we can also find this word uh e to be present so e a t a that is present in this manner and again though this is on the left side this is not the conventional way to write it but still based on the adjacent cells we can actually form this word itat and that's why this eat is also going to be part of the answer so we will add eat in the answer as well now for this to p p a p and drain these two are not present inside this given Matrix so we will not include them in the answer and this is the answer we will have to return so basically it is one kind of a word search game or word search puzzle so that is why the name is word search 2 and this is the little bit of Advance version so first we'll see that what is going to be like a basic very trivial approach and then we will try to improvise using uh different set of data structures okay so most basic idea we are going to have is that we will start iterating over all of the characters that are present inside this m cross n Matrix and then for every single character we are going to see that whether that matches with any of the starting words or not if we find a potential match then we will try to find the subsequent character and the neighbors of that particular character to see if we are able to generate any exact word or not and the moment we do that we will actually put it in a new variable called answer and that is how we will be able to generate our answer so let's try to see this in action so first character in this casee is X so X matches with this character over here in the in the given set of words so next we will have to see that whether any neighbor of X is actually y or not neighbor of X is actually h and a we do not find y over here so because we do not find y over here this x does not lead to anywhere so okay we can mark this as visited that does not lead to any answer next character is H so H matches with this first character uh and then we will have to see that whether B exists as one of the neighbors of H and B also exists as one of the neighbors neb of H and then the subsequent character o also exist as one of the neighbors of B so in this case this HB o is actually a complete word we are able to make based on subsequent characters that are pro present adjacent to each other inside this given Matrix and because of that we are going to create a new variable called the answer and in the answer we are going to add the the value HBO over here now we will start iterating over this a so again a is the starting point over here and next character B and C we are able to generate this pair using sub sequentially iterating over and uh if we see over here we can also generate this ABC in this fashion now this character is y so again Y is not part of starting character of any other word so we cannot do anything about this our next character is again C that we have already visited so we don't need to visit this and next character is z z again is not the starting point of any of these characters so in this case this is the answer we will we are going to have and we can return this one this solution works as expected there are no issues with this one but if you just see we only have a 3x3 Matrix and for every single character in the worst case scenario we might have to iterate over every single word uh and check that whether it matches the starting word or not we can maybe simplify using a hashmap but the thing is this is still going to lead to a very bad solution in terms of time complexity this is going to be disaster for because for every single character we might have to iterate over every single word that there is and uh once we find a match then we will have to iterate Over All the neighbors of that particular character as well so that leads to nowhere so let's try to see that where we can find a better time complexity and uh the solution to achieve a better time complexity is actually using a new data structure called try now I have already extensively worked on try and you can find all of those Solutions over here uh check out this video if you want to learn that what a try is and what are its applications now let's see that how we are going to use try in this case to improve our uh performance okay so the previous example we see basically what we were doing is we were retting over every single character and then we were trying to see that whether that character matches the first element or not and sequentially we will have to check every single word that was present and if we find a potential match then we will have to check all the neighbors to see if the next consecutive element is present or not and that was the major reason that why we are having a disastrous time complexity so in order to improve that if we can find a some way to eliminate this uh checking procedure that for every single character we might have to look up all the elements or all the words that are present because imagine if there are million words present we might have to check million times and then that is going to be very disastrous uh the idea we are going to use is that whatever the words that we are given we are actually going to convert these into a try and because we are converting them into a try for any character searching that whether it is the starting point of any word or not becomes pretty easy for us and we can actually do it in nearly constant time uh because in the try it is very fast and efficient to find that whether any word exist or not and if it exist uh it is very easy for us to iterate over that particular word or not so first of all let me quickly create a tri block based on these three words uh the tri block is going to look like this so based on the word that we were previously given we actually created a tri block and now using this Tri block we are going to make things pretty easy for ourselves basically we are going to iterate over in the same fashion for the given Matrix but this time we all we will have to see is to look up in this try that whether the current character if that is any children of this given root node or not and if that is the case we will keep on iterating so first we find this character to be e e is not part of any children so we can we can ignore that next one is f f is actually part of a children so okay now we have found f to be part of the children now we will have to see that what what is the next character in The in this uh Tri block so this next character is a so we will have to see that whether any neighbors of this F is actually a or not so we are we will have to check on three sides and we find a match over here that this is a okay now again next character is a again this neighbor is actually a okay now this character is n so again neighbor of this a is n present over here and again the next character is G so G is also present over here and since we have reached to the end node inside our try because of that uh we can conclude that the whole word was actually present inside this given uh Matrix and we can return true in this case and we will add it to our answer list so inside the answer list the first word we are going to add is Fang that uh is present inside this given Matrix so see how easy it is for us to find this these things okay now the next character is r r is not children of any of these root nodes uh next one is T T is also not a children is not a children these these are all visited now this g g is actually a children so now it becomes easy now we will have to start iterating over Okay so we are at this position G now the next element is o o o the next element is O and O is also a neighbor over here okay so which is good now the next element is O again O is a neighbor over here so which is good now this next element is g g is also neighbor of this o right so we are good up until this point now we have to to find this L now if we look at this G we do not find L to be a neighbor of this G so because of that we will actually have to roll back and we cannot move forward with this path so now we will be have we would have visited this G and we that did not lead us to anywhere so again we will start with our routine uh procedure okay now this next character is o o is not starting point of anything T is also not starting point of anything G is we can we have already used it now now this is again G so again G is the starting point of this one next character is o o is present over here next character is o o is also neighbor of this one next character is g g is neighbor of this one next character is l l is neighbor of this one and next character is e e is the first character and because we reach to the end character over here we can conclude that Google is also present inside this given Matrix and we will add it to our answer so we will add one one another entry called Google okay and now next uh again this character is l so L does not lead to any children of this root node and F does not lead to any children of this root node so in the answer we are going to return this Fang and Google to be the answer and this this would be the most optimal way to solve this problem remember because we used a tri block it things becomes much more faster for us and we can immediately look up that whether any single character that leads to an answer or not okay now let's do the tricky part we will have to do the time and space complexity analysis so for the time complexity analysis it's actually a little bit tricky the first thing that is a given fact is that we will have to iterate over every single character that is present inside this given M cross n Matrix so that's a given fact suppose that the total number of cells that are present are actually M so now okay we already know that that is whatever the time complexity is going to be the factor of M now for this particular M imagine that for any particular character what is the maximum work we will have to do in the worst case scenario well the maximum work we can do we will have to do in the worst case scenario is that any particular character suppose this F is this F matches this character that is present now for whenever we find a potential match we will have to look for the next element in all three directions of that particular word so suppose this o has we was a potential match we will have to iterate over all four directions in any given case so for any single cell we might have to iterate over in the all four directions and for all four directions the number of traversal that we will have to do for each one of them would depend on the next three or the next remaining three characters because remember for this Google suppose we find a match this o to be a match now the moment we find this o to be a match again we find this o to be a match so now because we find this to be a match we do not have to look for this particular element we will have to look at the remaining three positions so then we will have to for any single character we will have to look look in the four directions and for all the subsequent elements we will have to look in the remaining three directions and that we will have to do depending on the length of that particular word so for the remaining three elements we will have to iterate over to the length of that so that's why 3 to the power of L minus 1 and why minus one because for this first character we are actually looking looking in the worst case scenario in all four directions and for all the subsequent length parameters so suppose for this particular Fang for this F we might have to look in four directions and for this a we only have to look in the remaining three directions because one adjacent cell is already F so that we we do not have to look at so this is going to be the time complexity so if I write the final time complexity it's actually going to be big of M uh into 4 * 3 to the power of L minus1 and that is the final time complexity this is a very difficult time complex it analysis uh so yeah it gives you an idea that why this problem is pretty popular if we see space complexity that is pretty simple space complexity depends on the total number of words that are present so suppose we sum that up to bigo of n where m is the total number of characters that are present in the OR initial word list uh so after doing this time and space complexity analysis now let's move on to the coding before we Implement our solution we are actually going to create our class try node in the class solution we are going to Define couple of global variables now inside the find words method first of all we are going to initialize our Tri block and we are going to add all the words to our Tri block after creating the trodde now we are going to start working on backtracking uh starting with each cell in the board so first of all let's create uh the board variable and now we are going to initialize couple of Loops to iterate over this full board uh Matrix so now for every single position inside this given Matrix we are going to check that whether that is actually any of the children of this root TR node that we have created and if that is the case then we will create a helper method called backtracking where we are going to iterate over the all the adjacent cells of that particular row and column position and also uh that particular entire DFS traversal for that particular uh Branch inside our trodde after this Loop ends basically we should have populated our answer inside this answer uh variable that we have created so we can simply return that and now let's create our backtracking method so this is going to be our recursive method uh first of all we are going to Define couple of variables first of all we are going to check that whether the current node is actually a word or not if that is a word we can immediately add it to a result okay if that is not the case we will have to start doing our traversal so how we are going to do our traversal remember whatever the current row and column is we cannot use the same word again so we are actually going to mark this as hash in a way for us to identify that uh that is the node we have already visited now for any given row and column we will have to iterate over all of its neighbors so we are going to use couple of variables to our advantage now with the help of row and column offset it becomes pretty easy for us to iterate over all the neighbors of Any Given node so now we are going to run a for Loop and we are going to iterate over all the neighbors of given row and column position first we check that whether our new row and new column if they are going out of bounds or not that is the case we just simply ignore that otherwise if we are at the correct neighbor we need to check that whether that neighbor is actually subsequent character uh that we have already stored in our try or not and if that is the case we are going to call our backtracking method again now our after our exploration ends basically we will have to uh put back this hash to its original position and that should be it there is one more optimization we can we can do and that is to incrementally remove the leaf nodes which means that whenever we identify that the current nodes children if that is empty then basically we can just remove that from our parent that should be it let's try to run this code we'll also have to update the value of the node in the else condition okay seems like our solution is working as expected let's submit this code and our code runs pretty efficiently I will be posting this in the comment so you can check it out from there thank you [Music] so the lead code problem we are going to solve is called K largest element in a stream now we can see that this one is a lead code easy problem and also an extremely well-like problem on lead code the problem statement is quite straightforward we need to design a class that where we can find K largest element inside a stream and we are told that we need to find the K largest element in uh in terms of sorted order number not the K distinct element this is just to avoid confusion now let's see the requirements for K largest class basically we need to implement two methods first method is K largest method where as an input we are given an integer K and we are also given an integer array called nums now among these integer array nums we need to return return that whatever the K largest element is so suppose the given K is equal to 3 we need to return that what is the third third largest element inside this array second one is an add method where we are continuously adding value to a continuous stream and in that continuous stream we are able to re represent or return the K largest element in that continuous Stream So with every new value being added we can determine that this is the largest element inside the current K array so for both the case let's try to understand this with an example suppose this is the array we are given as an input and we are being told that K is equal to 3 we need to find the largest element okay so logically we can see that over here here the largest element is seven second largest element is six and third largest element is five so in this case we need to return five as the answer that this is the largest element now say for the same example this we took care of the K largest element uh method the first method now for the second method the add method basically let's say that we are given K is equal to 3 okay and this is a continuous Stream So first we add value number one currently we don't have any large value then we add value number two and then we add value number five now so far what is the third largest value inside this continuous stream so the answer is going to be one then we decide to add value number four so once again what is the third largest stream currently so third largest value would be value number two so we will need to return to let's say we add value number uh three So currently what is the third largest Stream So in this case the third largest element so far among these five element is value number three so we need to return this so basically in both the cases we need to find that for any particular given input what is the K largest element now for the for this uh add method you would say that hey we need to check for for every single time so how can we do do that the idea would be to design a data structure where at every given moment we should be able to quickly identify that hey currently by adding this value to this particular data structure the K largest value is going to be either 1 or two or dip three depending on the number of elements that are currently present inside our existing stream so let's try to see that how we can actually uh solve this problem okay so if we see the Brute Force solution for this problem Brute Force solution is actually quite straightforward let's say for given input array we can simply start iterating over every single value in order to find the maximum value we found so far then we can repeat the same process to find the second maximum value and then we can find the third process to find the third maximum value and that would basically yield us the result of let's say if we are given K is equal to 3 the this approach is very slow basically it yields in be of n Square time complexity so we definitely don't want to do that so that is one option second option in this case is let's say that for the same given input if somehow we decide that we can actually sort this given input then it becomes very easy for us to find any K largest element so let's say in this case the sorted array is going to look like just all the values from 1 to 7 and in this case the K largest element let's say our K is equal to 3 which means we need to pick the bottom third value uh in the answer and we can simply return this one so the Sorting solution would work fine but the thing is in order to create like from this non-sorted array to sorted array it's going to take n log and time so but this is still a much bigger Improvement compared to our Brute Force approach and this is actually what we are going to take into account in order to solve the problem but the thing is not only we need to create like an a data structure where we can store the sorted value and find or calculate the result but for our add method because we need to continuously check for any particular existing value that is being added into the stream that what the k largest element is so for every single time doing the Sorting would not make much sense rather with addition of every single value we need to keep track of all the largest values that we currently have so far and for that what I'm suggesting is that we actually use a very popular data structure called Heap that is specifically designed to store or identify K largest or k smallest element the approach I'm suggesting is that for this particular Heap we actually create a Min heap of the size K okay and what does Min Heap means is that it it stores the values in like the minimum order uh in its sequence so let's say currently in our array we have values like two uh and four and then uh one something like this one so this is currently not SED but if we try to put those these values inside the Min Heap it is going to store values as one and then uh two and then four so basically uh we will have sorted values that are being stored and adding every single new value inside the Min Heap only takes logarithmic time so log n time so the idea would be that if we just have a Min heap of size K that is number one scenario and number two condition is that whenever we find a value that is actually greater than the current value we have then we are going to pop this value out and then whichever value X we found we are going to push this value inside our uh array and this should allow us to find the K largest element very quickly let's try to see the solution I'm suggesting in action and then it would make much more sense so so currently this is our given input array we are trying to find the third largest element so what I'm suggesting is to create a Min heap of size three okay currently this Min Heap is empty now we have value number four so we simply add value number four then we have value number five so remember because this is a Min Heap if there is like the uh low value it needs to be at the very beginning okay so then we add value number five once again we have value number one so currently value number one is actually smaller than both four and five so we will min Heap automatically would readjust itself and we would have values 1 4 and five stored in this manner once again okay so now it let's say if up until only this point we want to find out that what is the K largest element all we need to do is just simply check that what is the the very first element present inside the Min Heap and that is going to be the K largest element so not only this Min Heap is going to allow us to calculate the K largest element for given input array it can see subsequently applied in order to use for our add method as well and that's why this one U uh one data structure is going to solve both of our problems so now currently the K let me just put down the answer over here okay that currently the minimum value is one so that we can can find and this answer is for the add method and at the same time we will find this answer over here for the K largest as a okay that will come in when we reach to the end of this given input now once again we have value number two So currently two is actually greater than the very first value inside our Min Heap which means two should be our should be in our Min Heap and we are going to pop the smallest value inside the Min hiip so now currently we have values 2 4 and five once again the answer is going to be two because this is the third largest element we found so far in this stream next we have value number six so the moment we want to add value number six which means uh two is definitely clearly smaller than value number six which means six needs to be added but with ADD addition of six four and five also needs to be readjusted so now four five and six so so far up until this point this point the third largest element is going to be value number four okay once again now next element we need to add is value number three but currently three is actually smaller than the current value we have inside the Min Heap which means we don't need to do anything we can just simply skipe over three as it would not be part of the solution next is value number seven so for Value number seven once again we will have to do the Readjustment so four would be kicked out and five and six would be adjusted to have five six and seven currently our inside the stream the value is going to be five and the answer is also going to be five that five is the third large third smallest or sorry third largest element inside the given array so just by simply using Min heap of size K and then having the logic that if the value we are trying to add if that value is actually greater than the current very first element inside the Heap we will need to kick this element out and insert this value inside the Heap then the solution would work perfectly fine if we see time and space complexity in this case the time complexity is going to be bigo of n log n because for every single element we will have to enter it into inside the Heap so that's why the time complexity is n Logan if you see space complexity it is going to be bigo of K where K is the the K element we are trying to find because we are initializing a new Min heap of size K and for those who don't know Min Heap also means a priority Q so that that's the logic right there so first of all we are going to initialize our priority q and integer K uh a couple of private variables to store them then we are going to have our K largest method where we are going to store the values of K and also in initiate a new Min heip instance uh with the size k then we in for every single element that is currently present inside the nums we will need to add that value uh inside our nums array so for that rather than doing anything else we can just simply use the add method and now let's quickly also see the add method where we first check that if the current Min Min Heap size is less than k then we are simply going to add the value inside the Min heap if that is not the case then uh we are going to check that if the given current value is greater than the current very first or smallest value we have inside the Min Heap then we will have to kick that value out and then we will have to add the new value we are currently at inside the Min Heap in the end we simply need to do a peak operation or the very first value element that is present inside the M Heap and that is going to be the K largest element for us and that's it basically so now let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs pretty fast compared to a lot of other Solutions which is pretty good it is excellent in terms of space complexity as well and once again the coding solution is present on our GitHub reposit so you can go and check it out from there thank [Music] you so the lead code problem we are going to do is called last stone weight now in my opinion this is one of the most awesome problem I have seen we can see we can see that this one is an easy problem and also a very well- like problem the problem statement is that we are given an array integer of stones that defines the weight of every single stone that is currently present okay now we are playing a game with these Stones now during the each turn we choose the heaviest two stones so this is the important part we choose the heaviest two stones and then smash them together now the question is there can be two possibilities one possibility is that uh either for two stones X and Y either both are of same weight or both are of different weight which means one is heavier than the other if both are of same weight then both stones get destroyed okay because we are smashing them together both Stones get destroyed if that is not the case and if we realize that one stone is heavier than the other then the stone with lesser weight gets completely destroyed and the stone with higher weight has a new weight that is like y - x so whatever the difference between weight is between two weights and then we are going to keep on repeatedly going to do the same process uh until the end of the game where there is only one single Stone left and then we are going to see that what is the stone of what is the weight of that particular Stone and that's why the name is last stone weight now let's try to understand this with an example so it would make more sense currently we are given an array where every single value represents the weight of uh stones at that particular position what is what are we being told that we need to find the two heaviest Stone during every single iteration So currently two heaviest stone is stones are going to be 8 and seven So currently 8 and seven are not equal to each other which means when these two uh Stones get smashed this seven is going to completely be destroyed and this uh Stone 8 is actually going to be only of size one because we will have to do 8 - 7 okay uh following this particular condition so once again if we do that currently we have this seven gets completely destroyed and we have this element number eight that is now being turned into element number or stone weight size one so now the new array we have is values 2 4 1 1 and 1 and three once again we are going to repeat the same process so find the two heaviest stones that are four and three once again both are not same so once again uh if four and three gets collided we are going to left with one stone that weighs 1 kg and this Stone number three is going to get destroyed so the new array we are going to get is going to look like this where the values are 2 1 1 1 1 okay so once again in this case now this two and one are both are the stones so they both are going to be crashed against each other so if we do that once again this Stone will get completely destroyed this one only Becomes of weight one so new value is going to be one amongst these two and then these uh three ones we already had okay so now once again we are going to repeat the same process now two heavy stones are both contains the same weight if the weight is same both gets destroyed so in the next iteration we are only left with two stones one and one and once again if we try to uh smash these two stones together both will also get destroyed so we will not have any Stones left in this case so we will need to return zero now let's say in the same condition let's take one more example where we try to have some weight inside the stone so let's say the values are now in this case currently the two heavy stones are this 8 and six if both gets uh uh uh smashed then we will have values with 2 3 and four six will get destroyed so once again the two heavy stones are three and four so once again if both get smashed then this three is going to be destroyed and we are going to be left with values two and one if these two get smashed together then this one is going to get destroyed and last Stone will only be left with size one and this is what we need to return as the answer so basically this is what the problem statement is asking us to solve The Brute Force approach is actually going to be quite straightforward where at every single iteration we will first have to find the two heaviest Stones once we find the two heaviest Stones then doing all the remaining work is not that much complicated then we can simply find the difference between them and then once again create a new array and then once again uh try to repeat the same process until we are only left with just just one stone or no stones at all so Brute Force approach would yield does the correct result but the issue is for every single time if we have to find the two heaviest Stones uh for each of the remaining array basically we are going to be doing big off n Square work just to find the two heaviest stones and once we do that solving this problem is very simple and very easy to do so the question we will have to focus on is that how can we improve upon the scenario where finding the two heaviest Stone becomes very convenient for us at every single iteration and for that the idea is whatever the in given input array is we will actually try to create a priority Cube or a heap where we are going to store all the values and we are going to set up this Heap to be of Max Heap type so max Heap means that whenever you try to add the values inside the Heap it is going to store the maximum element first and then uh smaller elements later which means it is going to store all the values ins inside the descending order okay this is the this is the whole concept of Max Heap so that's what we are going to use in this problem and let me quickly show you that using Max Heap this problem becomes really easy to solve the idea is that first currently we are simply going to iterate over every single values and start putting them one by one inside the max heap if we do that we will get a sort of uh I would say a value that is sorted in decreasing order so very first element is going to be value number seven and then we will have value number six and once again then we will have all the subsequent values uh in the same decreasing order and this is the input we currently have so once after finding this input in order to find our X and Y values we simply need to pull these two values in and after pulling these two values all we need to do is find that if they are of same size then destroy both of them and move forward if they are not of the same size find that what is the Delta between them and whatever the difference is try to put that back inside the max Heap keep on repeating the same process until we are only left with just one element and let's try to see the solution I'm proposing in in action so once again in this case currently this is our Max Heap and currently these are the two largest elements seven and six we will try to pop them out and we find that the difference is going to be one okay so currently this seven and six has been popped out and we have element number one that needs to be added so in order to add element number one it will be added uh in the back side of the Heap so we will uh let I will not draw a new Heap I will just keep on adding one values okay and these are just empty shells so don't just ignore them now once again during the next situation we are going to find the two heaviest elements that are four and three once again the difference is going to be one so once again now we no longer have values four and three inside the Heap and we are just going to add one more element one at the end of the Heap next two heavy elements are two and two so because both are same so we are simply going to ignore them and not add any other values now the two heavy elements inside the given Heap are one and one once again both are same so uh we are going to delete both of them and don't do anything and lastly there is only going to be one stone left that is going to be of size one and this is what we need to return as the answer so you realize that after storing all of this information inside a heap that is a self balance ing data structure that automatically sorts itself with new elements being added how easy this problem becomes so once we start once we implement the Heap this problem is very simple and we know that insertion inside the Heap takes log n time and we will have to do it for n given input so it's going to take n log n to store all the values and complete this problem so this is going to be the time complexity if we see space complexity that is going to be bigo of n because we are say we will have to create a new Heap to store all of these values so there is no other way to move around that but still this is a very good time and space complexity now let's try to quickly see the coding solution for this one okay so first of all we are going to initialize our Max Heap and this is how we actually initialize it using the priority q and in the comparator class we are mentioning that only the maximum element has to be at the beginning of the Heap then we are going to add all the values inside our Max Heap and then we are going to continuously remove and smash the two heaviest objects until we are only left with just one element and for that we we find our y as the very first element inside the Heap we find our X as the second element inside the Heap we simply have a condition that if X is not equal to Y then we are going to add an add the element that is the difference of weight between Y and X elements back inside the Heap and keep on repeating the same process while the size of the Heap is greater than one and the moment we reach to the end we are simply going to check that if the Heap is empty we are going to return zero if the Heap is not empty we are going to pull the last remaining element inside the Heap as the answer and that is going to be the heavy last remaining stone weight uh of our original input of stones that we were given so now let's try to run the code theme sare solution is working as expected let's submit this code and our code runs 98% faster than all the other solutions that in itself suggests that we are doing something really good and really right so once again this coding solution is present inside our GitHub repository you can go and check it out from there thank [Music] you so the lead code problem we are going to to solve today is called K closest points to origin now we can see that this one is a lead code medium problem and also a very well- like problem on lead code the problem statement is quite straightforward we are given an array of points that represents points on an XY plane or a graph and we are also given an integer K now we need to return the K closest point to the origin now we are also given that what is the mathematical equation to point the distance between any two points and that is the ukian distance formula so that is X1 - X2 sare + y1 - Y2 square and square root of the whole thing so we need to say that okay say for an example if this is the input we are given we can see that there are bunch of different points presented to us now I have plotted these points on this graph and we need to return the K closest point to the origin so origin is going to be this point 0 0 so origin point is always going to be 0 0 and we need to use use the ukian formula so let's say that we are given K is equal to 2 so we need to return that what is the second closest point to the origin so we can see that in this case this is going to be the first closest point to the origin and the second closest point is going to be this one so we need to return uh this value uh 2 and 1 as the answer as this is the second closest point to the origin now in order to calculate the distance between any two points let's say that we wants to point calculate this distance between this 1 one point and 0 point so the mathematical equation is going to be uh 0 minus the whatever the x square is that is x - one so 0 - -1 and the square of this one plus once again we will take y1 - Y2 so 0 minus uh this one is 1 so 0 - 1 and the square of whole thing and then we are going to do the square root of this whole thing so that is going to give us this distance that since in this case we are given K is equal to 2 we need to find the second closest element uh in order and return return that as the answer so in this case the answer is going to be two and one that we need to return so that's it this is the whole thing that what the problem is asking us to solve so Brute Force approach is actually quite straightforward in The Brute Force approach what we can do is we can simply start calculating all of these distances that are currently given to us and then after calculating all of these distances we will have some random values because for sure we are not going to get exact values because we don't know which one is the closest which one is the farthest let's say we find some random values like let's say that this one is three this one is two this one is one I'm just giving some arbitrary values okay so something like this then once again amongst these values we will have to find that what is the second closest Value so once again for that we will have to iterate over the given array and find the second closest value in order to do that it will it can still take big of n Square time in the worst case scenario so we will have to do something better so here now for the optimal solution I have just put down like every single point uh denoted as a number and for that number I have calculated that what is going to be the distance from the uh origin point for that particular value and I have marked all of these values over here now say for an example just for understanding per sake we will try to now on understand that this one as if it does not contain a square root okay this is just going to help us understand that what the solution is look like and how we can use max Heap in in this case to solve the problem the idea is that we are going to create a Max heap of size K and inside the max Heap we will uh always try to First add the value inside the max Heap and the moment we realize that the size is actually greater than k then we will have to pull the last added element outside of the max he okay we are only going to store the K values so in this case we are trying to find the second closest point to the origin so K is equal to 2 so let's say uh let's quickly initialize our Max Heap and inside the max Heap currently we don't have anything now in the max we are only going to store two elements okay I'm just adding one more element over here because this is we will put put down the buffer value to see if we exceed the size of the max heap if we exceed we are going to pop this element out okay so now let's try to populate our Max Heap with the theory we just mentioned so first we have value number 7 so we are going to put value number seven then we have once again value number seven so we are going to put value number seven once again we have value number two so once again we are going to we will have to adjust the input so it's going to be 7 and then seven and then two but we exceeded our place because uh we only want to store two elements so we are going to kick the seven out and we are going to leave this is as it is then we have value number five so once again this needs to be readjusted so values are going to be seven and then five and then two but once again we exceeded the number of input so we will have to kick the seven out now we only have value number five and two once again we have value number six so six would come over here because this is a Max Heap so we are following the property of descending order coming to the first so the maximum value is being is going to be stored very at the very top and then um once again we will have to kick the six out because we only wants to keep K is equal to 2 elements lastly we have value number three so once again first we will do the Readjustment so values are going to be 5 3 and two but once again this five is access so this will also be kicked out and then we are now done with all the values and now we only have these two values inside our Max Heap and the very first element inside the max Heap has to be the K closest element to the origin and which we can see because this is the end point and the distance is square root of three and we can see that this is actually the second closest point to the origin after this one so this is what we need to return as the answer and uh this is the whole solution so basically the important portion in this one is that first it this problem looks complicated because we are dealing with like XY graphs and I don't know I know many people After High School haven't even dealt with this one plus you might have forgot about the ukian distance equation but don't worry these are all just the constant matter so all we need to do is number one we are going to iterate over the given input and we are going to find that what has been the ukian distance from every single point to the origin using a simple mathematical formula that is X1 - X2 s + y1 - Y2 squ and the square root of the whole thing okay after doing this one we simply need to initialize our Max Heap to the values or size of K and we are simply going to do the operation that we just mentioned in the end we can simply do Max heap. Peak operation and that is going to provide us the K closest point to the origin and that's it this is the whole solution so now if we see time and space complexity in this case time complexity is actually going to be big go of n log n because it takes log and time to enter values inside the Heap and we will have to do this end times plus we will also have to spend some time calculating the distance from the origin to that particular point but that is going to be constant effort that needs to be done for n values so we can simply ignore this one because it is no longer relevant because we already have a higher time complexity component space complexity once again we will have to create an extra Heap so that is going to be big of K so now let's try to see the coding solution for this one so the coding solution is actually quite straightforward we are first of all going to initialize our Max Heap and inside the max Heap we are going to store the values based on the distance from the origin to that particular element and that is going to be done based on using the ukian uh distance formula from the origin and once we have that those value sorted then all we need to do is just simply add those values inside our Heap now inside the Heap we will first add the value then we will check that if the size of Heap exceeds the value of K we are going to pull the very last element we entered inside the Heap and that's it now in the end we simply need to collect the clo K closest point from the Heap so for that we can simply create a result uh uh array 2D array and we can simply run from I to the K and we will try to find the element and then we will pull it inside the result and then we can simply return that as part of the result so that this is the whole solution now let's try to run the code okay seems like our solution is working as expected let's submit this code and our code runs pretty fast compared in terms of time complexity and extremely good in terms of space complexity so once again the solution is present in our GitHub repository so if you want you can go ahead and check it out from there thank [Music] you so the lead code problem we are going to solve today is called K largest element inside an array and we can see that this one is a lead code medium problem also extremely well-like problem now in my personal opinion this should have been an easy problem but anyways they have put it as medium so let's be let be it uh we are given an integer array nums and we are also given an integer K basically we need to return the K largest element that is currently present inside the array now let's try to understand this with an example suppose this is the input we are given we can see that there are bunch of different random values present at the random location now let's say for this problem we are given K is equal to 3 which means we will have to find the third largest value value that is currently present inside the given array now we can see that the largest element is seven so that is the first largest element six is the second largest element and four would be the third largest element so in this case we will have to return four as the answer as the third largest element now let's try to find that what are the different approaches we can take to solve this problem first approach comes to our mind is a Brute Force approach where the idea is quite straightforward we simply iterate over the given input array simply 1 by one and in order to find the maximum value then once again we iterate over in order to find the second maximum value and we iterate over the third time to find the third maximum value until we reach to the K maximum element and we return that this value as the answer obviously you can see that we are doing lot of repeated work with the Brute Force approach and the time complexity is going to be big of n multiplied by K so that is not a good approach let's try to find the second solution now second solution is quite straightforward that for this given input if we somehow sort this given input then finding the K element is very easy because then we will know that after sorting this the largest element is going to be for the the first one and then we will be we will have values stored something like this one where we can easily find that which is the third largest element in just like uh just like that so uh sorting will take bigo of n log n time and then finding this element will only take big go of K time or just like this would be instantaneous because it's an array okay so overall this is a good approach works fine but the issue is we are explicitly told that we need to solve this problem without sorting so let's try to see that how can we actually solve it without sorting for that we actually have two options first option is that we find the most optimal way to solve this problem that is using a priority CU or a heap that is one way and second option is that whether we use a quick select algorithm so let me know in the comments if you want to see the quick select approach uh I can also make a video on that in the future but in this time we are simply going to use a heap the idea is we need to find the K largest element so we are actually going to store a Min Heap where we are going to store all the values in a Min Heap fashion which means in a ascending order okay so the very first element inside the Min Heap is going to be the smallest and then all the other values are going to be larger than that next thing is we are going to have this Min heap of size K so we are only going to store K values at one time and third thing is that in this particular Min Heap we are going to have a condition that let's say if a new value we are trying to add if that value is X if that value is greater than the very first value we currently have present inside the Min Heap then we are going to kick this value from the Min Heap out and try to put X inside the Min Heap so Min Heap once again is going to maintain its sorting property and it is going to keep all the values inside the Min Heap or ascending F fashion so let's try to see the solution in action so let's initialize our Min Heap So currently the given K is equal to three so the size of the Min Heap is only going to be three very first element is value number four the second element is two so once again we are going to uh store the values inside the ascending fashion so two and four next element is six so six would be added over here okay next value we are trying to add is value number one so once again one is a smaller value so if one value is smaller than current Max minimum he Heap then we don't need to do anything we can simply skip over why because we know that in this particular fashion the Third largest element is actually going to be the very first element inside the Heap and that is still going to remain two so we don't need to add value number one uh and we can simply skip over now we are at Value number seven so 7 is greater than the very first value inside the Min Heap so we will have to kick this value out and then we will have to put seven in but seven would not be put in the place of two once again we will do the operation of self adjusting the Min Heap so values are going to be 4 6 and 7 once again after adding seven we have value number three so once again three is actually smaller than value number four so we don't need to add three once again we have value number two two is once again smaller than value number four which means we don't need to add two as well so after the end of iterating over the entire array the very first element inside the Min Heap has to be the K largest element which we can see over here that this four is the third largest element inside our array and that's it so this is how easy it is to solve this problem using a Min Heap and we can simply come up to the solution very quickly very easily without any delays so let's try to calculate the time and space complexity in this case the time complexity is going to be that we will have to iterate over every single element and for that we will have to insert the values inside the main Heap or do some sort of checking so for end times we will have to do log n work so it's still going to be the N log end time uh it's still same as sorting but the thing is rather than sorting we are using a priority Q to take care of the values inside the priority fashion inside the Min he fashion if we see space complexity in this case space complexity is going to be biger of K where K is the size of the given K element we are trying to find because we are initializing a new Min Heap to store the value so it makes absolutely good sense to store this one so we can see that this one is a really good time in space complexity to solve this problem and once again as a general rule of thumb whenever you find any question where you want to find K smallest element or k largest element or k biggest element something like this whenever you see Ki try try to see that if you can use a heap to solve this problem and almost 99% of the time you should be able to solve this problem okay so now let's quickly see the coding solution for this one so this is the coding solution we can see that this is very simple and short coding solution basically we first of all initialize our priority Q or Min Heap and then we have a for Loop to iterate over the given input nums that is provided to us where we are simply going to add these values inside the Min Heap 1 by one then we are going to check the for a condition that if the size of Min Heap is greater than k then we need to pull the very first element that is present inside the Min Heap and that's it basically so in the end we should have a Min Heap that only contains the K largest element at the very first position that we are going to do a peak operation in return and let's try to run the code okay seems like our solution is working as expected let's submit this code so our code runs faster than lot of other Solutions and uh this is a really good approach so I will be posting this solution inside our GitHub repository [Music] so now we are going to do one of my favorite problems on lead code that is called task scheduler we can see that this one is a medium problem and also very well like problem now I just have one request for you I really want you to pay utmost attention to this particular problem because if you can understand to solve this problem there are lot of important lead code Concepts that would enshrine in your brain so please please please pay utmost attention now let's get started with the question uh basically we are given an array of CPU tasks and each task is represented by a letter uh somewhere between A to Z then we are also given a cooling time n now we are told that each cycle or interval allows the completion of one task okay that's fine and then we are told that task can be completed in any order but there is one small constraint regarding this interval n that we are given and that is that identical task must be separated by at least n intervals due to cooling time okay so let's try to understand what it just mentioned with some examples and basically we need to return the minimum number of intervals required to complete all the task so let's try to understand this with an example in this case we can see that we are given three tasks that we need to complete first task is a second one is B and third one is once again a we are also given the cooling down period of two now how does this cooling down period affect the our task is that identical task must be separated by n intervals so let's assume that during the first window we start to complete task a okay so we got rid of this task once again we got rid of this task as well task B now the thing is we only have one task remaining that we need to complete but if we try to complete task a over here and if we see the difference between the this interval and this interval then we can see see that the difference is only going to be one but the thing is it has to be separated at least by two because that is what the cooling period is because once again I'm repeating both a and a are identical task we are told that identical task must be separated by at least n intervals n in this case is two which means two identical task has to be separated by two intervals currently we only have it separated by one interval so we will actually have to add one more interval over here where we are not going to do anything so this would be an idle period where we are just going to stay idle just to complete that one more interval and now we have one and one two intervals completed after we completed task a and then once again we can complete the remaining task a so totally we need to return the minimum number of intervals required to complete all task and in this case we can see that we took one 2 then this idle third and then this completing A4 so in total we took four uh intervals to complete this task let's try to understand this with couple of more examples next example is once again we are given n is equal to 2 now in this case we have three identical task we have three A's and 1 B so one logical uh solution would be we can start with task a once again we go to task B now we know that the cooling period is true which means we cannot use a task a once again we will have to stay idle so we got rid of this one okay now once again we can do task a but after completing task a once again the next task we need to do is once again task a for which we have to have two idle Cycles so since there are no other task remaining we are going to remain ideal for two more cycles and then we are going to complete task a so if we calculate in this case we need in total seven intervals to complete every single task in this input and same way in this approach we would actually need uh in total eight intervals how because we are given Three A's and three b's so logically we can do task a then we can do task B and then we cannot task do task A or B once again so we will do an idle scenario once again we would do a once again we would do B and once again we would do idle and once again we would do a and once again we would do B and then we don't need to stay idle because we completed all these six of the task so that's what the problem is is asking us to solve I know understanding this problem is quite tricky now first let's try to understand the Brute Force approach now logically the most simplest Brute Force approach would be to try out every single possible com permutations and combinations so we start with task a then once again we try to find that what is the next task that is not a once again we identify task B once again we Mark task B once again we try to identify that is there any other task that we can do that is not a nor B in within this two window period we cannot find anything so then we decide to go idle once again we repeat the same process and once again we keep on finding the next task so this is a very slow approach and we are doing lot of repeated work just to do this one because number one we are not sure that how many number of rotal tasks are available number two we are not sure that what is the frequency of every single task so we cannot we cannot know that during any particular interval cycle how many number of tasks we can accommodate that is a one huge problem with this Brute Force approach and this problem is what we are going to solve and exploit it in order to make this algorithm much much much faster so let's try to understand that what is the optimal solution I'm suggesting but for optimal solution first we will have to build up some logical understanding on how we can improve our solution okay so for that once again let's take our favorite example where we are given 3 a and 3 BS and once again we are given our n is equal to 2 logically most efficient matter for us to solve this problem would be that in the in any particular given input first we need to find out that what is the character that occurs most number of times and we always have to start with that character in order to complete it in the fastest manner possible so logically in this case both A and B occurs three times so what I'm suggesting is that first approach we can take first smart approach is that we can actually take an entire uh input run it through some sort of like array or hashmap and create a frequency map and in this frequency map we are going to make sure that every single time any particular character how many times it appears that is number one thing next we will need to learn that what is the maximum time any particular uh value repeats and then we will need to Pro store the values in the decreasing order so once again we will need to find some way to sort this frequency map so for that one of the very good approach we can take is that we can actually create a heap where inside the Heap we can store the information that how many times any particular character appears and we can actually store its information so let me just make this this slightly different and we are going to have B appear two times okay so now it makes sense that a is three times and B is two times okay now one more logic I'm suggesting is that we actually take understanding of this scenario that what is this n represents so basically this n simply represents that how many number of computations we can do back to back on separate characters during any particular interval size but the interval size has to be n + 1 why n + 1 because remember we want let's assume let's go back to our very first example now let's try to understand this logically first let's say we add value number a okay then we add value number B okay now how many more operations we can do where we can basically either either there can be two options number one option is that maybe we have some other value that is not a and not B that we can add over here that is one option if that is not the case another option is that instead of adding this another value we will need to add an idle value over here and then the whole cycle of once again reaching out to character number a would reset because then we would have covered the two destination from this our original value one a that we were looking at which means that in order depending on the value of n we would actually have to consider the scenario of n + 1 as part of one cycle because in one cycle we can only take unique characters during that one cycle and if we have less unique characters than this one cycle then we will have to use idle cases so which means if we have unique characters we can simply reduce the values of those unique characters so in this case we got rid of this 1 a and then 1 B so we are basically reducing the values let's say if this one was C then we could have just reduced C but we don't have C so we still have a so which means repeated characters would only be decreased by one during one n plus one cycle and if we have unique characters we will try to fit as many unique characters as we can inside this N plus1 Cycle so this is the second Improvement we are trying to do of applying n+ one uh Cycles so let's understood that uh number one we already know that we created our hash map uh sorry we created our frequency map then we created a heap to store the frequencies that are coming in and next we are going to be marking the scenarios based on N plus one Cycles now these are the three improvements now I'm suggesting fourth Improvement and that's why I'm telling you that this problem is such a mind-blowing problem because you are making improvements after improvements after improvements in order to make the efficient algorithm and that's why you are learning lot of new things so that's why I'm paying my my at most attention coming back to the question so understand in this case that so far we are keen on understanding that how many number of A's are present and how many number of B's are present and how many number of C's are present the thing is apart from storing this value inside the frequency map we don't have any other information that we need that we need to utilize for all we can do is that we already we are already tracking the values based on the Cycles we already have a heap to store the values in sorted order now instead of storing these characters we why don't we just store the frequencies because in the end we simply need to return that what are the total number of intervals we are going to need so in the Heap we can actually store the frequencies the idea is we are going to be traveling in the cycle by manner so cycle in this case is this is two so there there is going to be cycle of Threes okay and we know that how many number of unique characters are present inside this given input because inside the Heap we only have two distinct frequencies so that's why there are only two unique characters present so this becomes our way to understanding that there are only two unique characters we know that in one cycle we can only iterate over just unique characters and reduce their frequencies for rest of the time we will have to put the idle slots and what I'm suggesting is that we initially start our Heap this way then we are going to run in the cycles of Threes with every single cycle we are going to pop the elements out of the Heap to make sure that whether Heap is empty or not if he Heap is empty if there are no values inside the Heap then we will simply add idle values uh till we make n+ one so why don't we why do we even make idle values we know that after removing all the elements of the Heap basically for this cycle we still have some elements that for which we haven't calculated the frequency and if there exist some frequency which means the entire n + one has to be part of the answer and then we simply have to reduce the frequency by one and once again repeat the same process so this is the whole solution I'm suggesting now let's me let me quickly show you the optimal approach let's walk through the optimal approach and then we will see the coding solution so if we see the optimal approach now it is going to make much more sense once again let's take our example and we have 3 A's and 2 B's and we have n is equal to 2 okay uh logically we have our Heap So currently inside the Heap we only have values three and two that is the frequency map and notice that this frequency map is actually sorted based on the uh ascending order property then once again uh for n is equal to do which means we are going to do the cycles of value three okay so let's try to do the first cycle of value three during the first cycle of value three we are going to pop one element this three out of our Heap currently we have and we are creating a temporary list to store the value of Heap and then we are going to reduce it out of the temporary Loop okay so currently this is three we popped one element out currently this is two once again we popped both the elements out and we realize that currently our Heap is completely empty there are no values inside the Heap so if Heap is empty then we need to check that what was the value that we took out from the temporary Loop we took out the values three and two which means we will have to reduce these values and reducing these values are going to be 2 and one which means we the temporary list is not zero so in this case because temporary list is not zero and our Heap is empty we know that during the first cycle we will have to do three intervals so we are going to Mark 3 that we have completed so far so we are going to have a variable called interval where we are going to store the values so we so far we have completed three variables once again notice that inside the temporary list we first had values three and two but we reduce the frequency by one after reducing the frequency once again we are going to populate this value 2 and one once again back into the Heap once again we are going to run the operation so once again in our temporary list we are going to have values two and then value one coming in and and we are also going to have a heap becoming empty now Heap is empty we try to reduce the frequency so reduced frequency is going to be 1 and zero now after reducing the frequency we realize that there are still some values present which means this entire interval we are also going to consider so it is going to be 3 + 3 so far after this once again we realize that this value is zero so zero value we kick out from the temporary list we put the value back inside the Heap So currently Heap only contains value number one okay so now after containing value number one we will try to pop value number one out currently Heap is empty but we we are not going to add three so far because this might be the last character which is the case because in the temporary list we identify that there is only one if we do like a reduce operation minus minus then this becomes zero which means temporary list does not have any value and Heap only had one value so we are simply going to add that value that we take out from the Heap uh or take out from the temporary list so in this case we need to make minimum seven intervals to complete each of these cases and let's try to walk through these seven intervals so of course our given n is equal to 2 so first we are going to do operation a once again operation B and then we will have to do idal operation once again we are going to do operation a operation B and our idal operation so now so far we have taken out two A's and 2 BS and in the end we simply have our operation a we need to do so total we need to do seven intervals in order to to complete this problem and this is the solution I know I went over a lot of things but I hope that this made sense that what I was explaining if we see time and space complexity in this case well time complexity contains lot of steps so number one step is we need to build frequency map that takes B go of end time plus we will need to iterate we will need to generate the Heap so that takes bigo of n log end time then we will have to run our while loop iteratively till we reach out till we complete every single cycle that is once again going to take bigo of N and then we will have to subsequently do the number of total number of intervals that are that we are going to be able to make and that can in the worst case scenario it can be big of n Square so in total we can say that our time complexity is still going to be big of n square but this is much more efficient approach compare compared to our brute force that would have yielded us B of n cube of cube time complexity so that was that was going to be horendous if we see uh space complexity well we are using frequency map and we are also using Heap and plus temporary array list so basically we are using B go of n extra space and this is still in my opinion a good enough time and space complexity so here is the coding solution first thing we are going to do is for given input task we are going to run across and create a new frequency hashmap where we are going to store the frequency for every every single task or every single character once we have frequencies we are going to build our Max heat based on the frequency uh so we are going to initialize our priority CU to store the integer values of the frequency sizes and we are going to add all of these values from our frequency map and they would automatically sort be sorted in descending order next thing is we will need to process every single task so initially we are going to have our Val variable time set up as zero then we are going to have a condition that while our given Heap is not empty we we will need to do the following so first thing is that we will need to initialize our temporary list that we mentioned that we will have to create then we are going to run a for loop from I is equal to 0 to I is less than n + 1 which means this is going to be one of our Cycles so this is going to be our cycle logic where we are simply checking that we are going to check if the max Heap is not empty we are going to keep on pulling every single value out from the temporary list and to the temporary eror list and we will keep on repeatingly doing it until our given uh Max Heap is either empty or we complete the N plus1 Cycles in either case we will have to add n plus1 items uh depending on this then we will have to reduce the values from the frequencies so because we are popping values out from from our temporary uh from our Heap which means currently they are stored inside our temporary are list so we are going to reduce the frequency and keep on checking that if the frequency is greater than zero we are simply going to add that value to our Max he if the value is equal to zero then we are not going to add it to our Max next thing is we will need to update the time and the time update is going to be quite straightforward that if the given Max Heap is equal to Mt then we simply need need to update the size uh by m n + 1 if that is not the case then we will need to update the size or update the time based on the temporary variable size we had which means that was the uh additional values we found inside our uh temporary array list that got popped out of Heap and in the end we simply need to return the time and this should provide us all the intervals we had so this was a brilliant question a brilliant solution now let's try to run the code okay seems like our solution is working beautifully let's try to submit this code and our code runs pretty fast in terms of time and space complexity once again the coding solution is available in our GitHub repository and the link of the GitHub repository is in the description so feel free to check it out from there uh thank you so now the problem I'm going going to solve can be asked in three different ways in three different interviews it can be a data structure and algorithm type of lead code problem it can be a system design problem and it can also be ask in lowlevel design problem so I'm going to do my best to explain in as much detail as possible I hope you pay utmost attention to this particular [Music] problem so the problem we are going to solve is called design Twitter and we all know what Twitter is this one is a lead code medium problem and also a very well-like problem let's try to understand the problem statement basically we need to design a simplified version of Twitter where users can post tweets follow and unfollow other users and it is able to see the 10 most recent tweets in the users news Fed so the Twitter class we need to create should we should be able to init initialize the Twitter object then we need to create these four methods first method is post tweets where we are providing in the user ID and tweet ID that composes a new tweet with a new tweet ID uh by the user then we need to create a link list type of structure for get news feed where depending on the user ID we provide it retrives the 10 most recent tweet IDs in the users news feed now for this uh uh 10 most recent tweet IDs we are given some logic that each item in the news feed must be posted by the users who the the user followed by the users themselves okay so you can you should only be able to see the tweets that of the people that you are currently following that's basically what it's trying to say and this is the important part that the tweets must be ordered from the most recent to the least recent the latest one should come in first in your feed so you need to maintain that timely order and then we are being asked to create two simple methods that is follow and unfollow where you provide the IDS of follow and follow e and basically follower should stop should start following with the follow method and they should stop following with the unfollow method so let's try to think and document all the things that we need to create okay number one thing is we need to create a Twitter class now in this particular Twitter class we need to Pro generate four methods now logically first let's start thinking about each one of them one by one so let's take the small problems first because if you can't uh solve the hard part solve the easy part first now for the following and unfollowing logic basically we have two sets of users so let's say that I current I am currently a user okay now I am as a user my name is par and that's it now there are bunch of different users just like me that I'm currently following and they also have their own white buckets of being users and they might also follow me back some might do some might some might not and they may also be following bunch of different more users as well so one logical conclusion would be that we wants to make sure that the moment for we I provide you that any particular user uh let's say PA and then I provide another user let's say uh John Cena so I should be able to see immediately that whether PA follows John Cena or not and I would like to do this in the quickest manner possible so the only way to do that is that if for any particular user I create some sort of hashing solution like a hash set or a hash map where I provide the information of every single user that this particular user path is currently following and in this hash Set uh then it becomes very easy for me to find that whether any particular uh user ID is being followed by this user uh username path if that is the case then I can quickly add and remove those entries so that way I should be able to to tackle both follow and unfollow methods because then it becomes pretty simple for us to identify that but in order to accomplish that we will have to first take in few accounts or few considerations number one thing is how we are going to configure our user uh details like what are the items we should be putting in inside the user class uh and for each user because we are trying to create like a separate hash set so how should that work so we also have to think about that we are trying to fix it using the users and for every single user having a hash set of all the people that that particular user follows so for that what I'm suggesting is that we first of all create a separate user class and in this particular user class that number one we have the user ID and then we also provide two methods first one is a follow method and second one is an unfollow follow method where both both the things this follow and unfollow method does is exactly to look up inside the hash set for that particular user and identify that whether there is a connection or not in order to do that we also need to have a hash set where we are going to store the values of all the users that are currently that currently this user is following that's it so this is what our user uh class should look like because we are taking care of the IDS and we are also taking care of follow and unfollow method now after tackling the issue of follow and unfollow we need to also understand the logic of post tweets and get news feed so now the next lesser complicated portion is post tweets so now once again now let me deviate slight bit of side from the uh users and also go into the issue of Twitter or tweets so what for any particular tweet what are the different items a tweet needs so number one thing a tweet has to consider is basically what you are trying to tweet right of course so in this case we are we are being told that we are just posting an integer associated with that tweet so basically a tweet ID we are only post we are only going to be posting the Tweet ID on what information is there and that is sufficient okay so every single tweet is going to have a tweet ID that we have to take care of next thing is uh remember when we are trying to generate the news feed we need to provide the top 10 most recent news or most recent tweets in order to do that we we have to identify that for these top 10 news feeds based on the time we need to have some way to keep track of the time stamp that this tweet has been tweeted so for any particular tweet we will also to keep track of the Tim stamp that at what uh time did we created that tweet that is number second thing we have to identify third thing is we have to associate that what was the user who created this tweet so in order to do that we can actually have the Tweet ID or we can have a post method basically on the user class where we can simply create a tweet and this post method should call should call this tweet method or this tweet class where we are simp simply providing all the information we have uh in order to create a new tweet and that's it so now this tweet also has an access to the user ID and this user ID and this tweet ID becomes our connection points to separate the tweets depending on per user basis because remember when we get to the level of generating the news feed we will have to generate the news feed based on the people I'm currently following who have tweeted so I need the information of the user and I also need the information of the tweet and I also need the information of time so combination of these three attributes should take it take place into my tweet class as well and next thing is for for our tweet uh typically tweets are generally stored in like a uh link list sort of fashion because even for the generate news feed we we have to create the link list so the ideal scenario is that even for any particular user that is currently uh generating a tweet we also provide a link to call to the next tweet that this user also has made so when we get to the coding portion this thing would make much more sense on how we are configuration this configurating this user account and this tweet account now let me come back okay now uh and also let me do a quick recap so far we have created the users class and we have also created a tweet class uh in the users class we are storing all the necessary information that we need for the user so things like user ID and then things like uh tweet that the this user makes and then uh what the hash said to store the information of all the people that this particular user is currently following we also have the Tweet table where in the Tweet we have the Tweet ID we also have the user ID because we need to know that for any particular tweet what user was associated with that and anyways we are also having a post method that deals with the tweet uh tweet class we have on our side remember there there needs to be there needs to be a connection in this case Okay so that's why need it needs to make sense once again coming back for our tweet class and also uh this is also going to be a time bound event so we are also going to store time for each one of this one now coming back to our main Twitter class okay we already took care of follow and we already took care of unfollow methods we also took care of uh how how we are going to post Tweet method so basically if we see the structure of the post Tweet method in the original question description we are simply providing the user ID and we are also providing the Tweet ID that this particular user is posting same thing we what we can do is even for our post Tweet method we can simply uh provide in the values of the Tweet ID and the user ID and we can now we can associate all of these things together now comes the tricky part and the tricky part is that uh last thing is we need to be able to generate the news feed okay so in order to generate the news feed what we will have to do so let's first try to understand logically what is being asked us to solve we need to provide the top 10 or the most recent 10 tweets that were being made by all the people who I currently follow okay so all the people who are followed by me okay now this makes sense now let's try to visualize it currently uh I'm the user and for this particular user path I'm trying to generate the news feed this path is currently following 10 different people and all of these 10 different people they are also users on their own now these 10 people whenever they tweet something they would have a tweet associated with their user ID okay and that Association can be linked through the combination of user ID class and the post class because remember even in the user ID class we are actually calling a method to to create tweets and we can actually store those tweets inside the user ID so user ID knows that any for any particular user ID what are the different tweets that that user has made and let's say that some users just made one tweet some user made B bunch of different tweets and then some user made um few more tweets something like this so now we can go we can go to any particular user that is option number one through this user we can find all the people I'm currently following that is second step through finding all the people I'm following I need to find all the tweets that they have made that is the third step after fetching so let's say I identify thatth so far all the people I follow they have in total made 50 different tweets now among these 50 tweets I want to find that what has been the top 10 or let me use okay most recent 10 uh tweets that has been uh generated so for in order to find the recent 10 tweets the logic is quite simple I put I take all of these 50 tweets I create a heap now we all know the concept of Heap or Heap or a priority Cube now inside this Heap or priority Cube I store the values based on the time they arrived in so the value that came in at let's say Time 1 second and the value that came in let's say at time 3 second so the 3 second should come in before 1 second and this process can be easily maintained and manipulated by hi because it's a comparator type of data structure where you can compare between any two values and store the values in some sort of sorted format so in this case the Sorting is going to be done based on the time that it came in and it is actually going to be in the descending order so the value that came in at the latest time should be uh at the beginning and the value that came in later should be towards the end of the Heap and then once I have entered all of these 50 values inside my Heap then uh in order to generate the news feed I simply have to fetch or I simply have to pull the top 10 values and that should be able to generate the entire tweet so now I have some sort of rough way and idea to solve all these four methods remember once again uh let's try to reiterate and the reason I'm doing this repeat repetitively again and again is because this question is extremely important and I really want you to understand the whole logic and the whole thought process because we are using a great number of combination of data structures to to achieve what we want okay so for the unfollow and follow method we are currently simply using the combination of that for any particular user user is associated with a hash set of all the people that that currently user is following and then we can very easily follow and unfollow people around okay in order to post tweets we are simply relying on the concept or the connection between uh user and a tweet and we are combining everything based on uh the user ID and tweet ID and even in the Tweet we are also associating the time associated with that particular tweet so we can very easily put it inside the hashmap and the last thing is in order to generate the news feed we are working with a heap and we are also working with iterating over any particular user and for that user we are going across all the people that this user is currently following and after finding that information going to those followers and trying to find all the tweets that they have made put that those tweets inside our priority queue or a heap and then only fetch or pull top 10 out of this particular Heap and that should give us the the generated news feed in a linkless fashion but we still are missing one key portion how would in order to do these operations how would we know that for any particular user what what are all the users associated with that or how for user ID what is the user ID class and then what is the information being followed so we need some sort of mapping structure over here as well and for that what we are going to do is we are we will first of all have to create a hashmap where inside the hashmap we know that this is a key value based data structure so as part of the key we are going to have a user ID and as part of its value we are it is going to point to that particular user class or the user object that we have created and once connected being connected to that particular user then we should be able to find Associated uh people that are being followed by that particular user and the tweets that are being made by that user and by going to those followers we can also find their tweets and all all of those things so we are in now in total you know we are actually using like five six different data structures we are using a hashmap we are using a hash set we are using priority que we are using uh what do we can link list and we are using like all sorts of practices to make everything work together so this is a brilliant question in my opinion this question can help you in lot of different ways and that's why I spend so much time explaining all of these different concepts and different scenarios uh I hope you understood my explanation if you still face some issues just write it down in the comment and I will be more than happy to answer your questions but now I think it's time that we start seeing the coding solution for this and it would start making more sense that why did we do what we did okay okay so this is our Twitter class and uh we first of all initialize a static time stamp initialize the value at zero and then we are simply going to update the value by one uh so we can uh keep track of the time now let's try to understand how does our user class looks like as specified we are going to have an ID for any particular user we are also going to have a hash set where we are going to store all the people that are currently being followed by this particular user ID and we are also going to make a reference to the Tweet or the Tweet class now let's see that for this particular user we are also initializing a Constructor where we are simply providing the value of I and we are also creating a new hashset for any particular user plus we are also adding the value of this particular user in the hash set because a user should follow themselves so that's a simple value and then as a head of the Tweet or the very first element inside our tweet link list we are simply marking the value as null okay now for the follow method we are simply adding the value to the hash Set uh this follow hash set that we have created for the unfollow method if the value does exist we uh we are simply removing that value from the hash side so follow and unfollow are pretty simple from the point of view of our uh user class and then we are also making one more method called post where we are providing the ID and we are creating a new instance or of a new tweet associated with this new ID that is being provided and then we are marking the new tweet that we just created as the head head of the new tweet so we are just this is just an intermediate step but basically the Tweet head is going to be the new tweet that we just created now let's talk about the second class that was our tweet tweet class that we talked about number one we are going to have our tweet ID or just like ID for this then we are going to be dealing with the time stamp and since this is a link list type of structure we are also going to have one more node pointing to the next tweet in line we are also going to have a Constructor where we simply provide the ID of the tweet and then we are going to Mark add the value we are also going to update the Tim stamp and we are also going to point the next value to the null uh notice that we we are already pointing to the Tweet method using uh the user class that we have created so we should be able to tweet for any particular user now we have since now we have both of our classes ready now we are going to generate a user map where we are going to have an integer ID as the as part of the key and we are going to have Associated user as part of its Associated value and now we are going to be working on our Twitter class so first of all we are going to initialize our uh initial initializing our hashmap that we just created and then we will start implementing all the methods that we talked about one by one so first method is post Tweet method where we simply have a user ID and we simply have a tweet ID so first thing we are doing is we are going going to check that if in our user map uh do we have this user ID as part of one of the users that we have created if we don't have it then we are first going to create a new user after creating a new user we are going to put that value inside the user hashmap that we have created and let's say that so now we we do have an existing user uh and in either case if we have whether we have an existing user or not we would create an existing user once that is done for that existing user we will try to find its information and then we would call the Post method inside the user that we have created uh that is this method I'm talking about where we are creating a new tweet okay so this is how the post Tweet method is going to work next logic is that we need to retrive 10 most recent tweets uh in the users news feed so this is a complicated task for that number one thing we are going to do is uh have a link list where we are going to be storing the news feed we are going to check that if for this particular user ID if we don't have it as part of the news user ID we can simply return a blank news feed if that is not the case we will first have to create a new hash set to store the information of all the users that are being followed by our user ID that is provided as part of the input so we uh find that information we also we also create a new Heap or a priority queue where we are going to store the information based on the timing so the value with higher timing would come in before uh and the value with lower timing should be should stay on the backend side once we have all the data structures ready then we are going to first of all go through every single users that we are currently following for this particular user ID and iterating over each one of them with will get all the tweets that they have created so we are going to go over the Tweet link list that they have created and if the given tweet is not null we are going to add those values to our tweets so now we have uh tweets being populated uh and once we have those then we are simply going to uh have initialize a counter on top of it we are simply going to check that while the count is less than 10 we are going to go over all the tweets we are going to add all of those tweets to the news feed that we have created and we are going to be updating the counter and how we are going to be able to do that because remember inside our tweet Heap that we have created all the values are sorted in chronological order uh based on the most recent time stamp and then uh once we simply check that if we find that the weather count is 10 then we can simply uh get out of the loop if that is not the case uh and if the tweet. next is not equal to null we will simply add that value to the to our tweet Heap as well and that's it in the end we can simply return the news feed so we took care of the two most complicated problems and then uh working on the follow and unfollow method is quite simple and straightforward for follow method we are first first of all going to check that if the person who is trying to follow someone else does that person exist or not if that person does not exist we will create them same way if the person we are trying to follow if they also does not exist inside our hashmap we would create them and once they both exist inside our hashmap we are simply going to call the follow method for any for our user and we are going to have like follower and FY setup same way in the reverse order we would simply call the unfollow method and uh then that user would no no longer be followed and that's it that is the whole solution I know it looks complicated that we have to play we have to create a user class and then we have to create a tweet class and then we have to create a Twitter class and then we will have to generate all of these four methods but if you try to think it from the perspective of like regular logic that if you are the developer of Twitter and you are trying to improve the system or you are trying to implement it how would you do that so then you would gain much more beautiful insights from this problem so let's try to run this code okay it seems like our solution is working beautifully let's submit this code and our code runs pretty fast compared to a lot of other Solutions in terms of time complexity it is also excellent in in terms of space complexity as well once again this solution is present inside at our GitHub repository so the link is in the description feel free to go and check out that GitHub repository I know it is going to be really helpful and uh let me the comments if you find this question interesting did I explain it well did I mess it up or whatever your thoughts are okay thank you hello friends we are still not employed by a Fang company so let's not stop lead coding till we get there so the lead code problem we are going to solve today is called find medium from a data stream it is a very nice problem and if you see some of the popular companies where I want to get job who have already asked this question there are companies like Amazon Apple Uber adob Bloomberg Google Spotify Microsoft Facebook Nvidia by Dan LinkedIn and bunch of more so that's why I'm paying my Outpost attention I hope you also enjoy the video so this is a lead code hard problem and also very well-like problem basically we need to find the median from an incoming data stream now in this problem uh basically we are being asked to implement the median finder class now in this median finder class we need to implement these three methods where the first method is the median finder method by itself second one is a void add number which means that if with this method is being called uh it will add an integer called nums from the data stream to our data structure and third one is the find the median that we need to basically find the median now let's come back to the problem statement first we are given the definition that what a median is median is the middle value in an ordered integer list now this is the tricky part we are being asked to find the median from an ordered integer list which means that the input whatever the input comes let's say the input comes like 11 3 5 something like that we still need to find the median as if the input was 3 5 and 11 so this is the tricky part like most of the people would not realize that the the wording ordered integer is there and then they will get confused so now we have get that uh sorted now we need to see that what is the definition of the median is basically median is the middle value and if the size of list is even then which means there is no middle value in that case we need to find the median as the uh average of two middle values and we are given some examples but we are going to see this in much broader examples um so first let's try to understand this with some uh existing example suppose we are given a stream that looks like this 1 2 5 11 15 uh 16 something like this what would be the median in this case well if we go based on the definition currently well this stream is actually an even stream which means that there is no exactly one middle value uh we are currently seeing two middle values in this case and also notice that for this whole thing I actually set it in ordered motion already so uh we are going step by step so first this is an ordered list uh that is an even list and it has two middle values so in this case the median is going to be the average of these two values so which turns out to be 5 + 11 uh 16 ided 2 so the answer is going to be 8 in this case uh so second uh again let's suppose that uh once again the list is ordered list so 1 2 5 8 and 9 in this case we are given we are dealing with odd numbers now for these odd numbers the middle value is quite obviously clear and that is going to be value number five and again the ordered property is still maintained in this example as well so in this case the answer is going to be simply value number five uh now let's take one notch a little bit more complicated what would be the median in this case uh since this is odd number we know that we need to find the middle value but in this case this is not in order so first we will have to put this in order so that is going to be 1 3 5 8 and 15 and in this case now since it is easy to calculate the middle value it is going to be five so this would be another scenario now with these examples you at least got one broader idea that how to deal with the median finder class like uh when we need where we need to first of all uh create a method to find the medium uh second we need to create a method to add the medium and third we need uh an object of this medium finder class so basically we need to focus on these two items the most now the most important part in this one is uh first we will have to see that what would be the actual problem is going to look like so actual problem is going to look something like this where there can be multiple uh options so first let's say that it selects and uh the option is that you need to find uh the median but currently if we see our list uh or our input data stream let's just mark this as input data stream currently in our input data stream there are no values which means if we call out this find median function basically it is going to return zero so this this time or return null value actually not zero so let's say that this Returns the value null okay now again we we are calling add number method uh so if we call add number method and we we say that okay add number five so in this case currently in our data stream there is there's only one value that is five now we call add me uh I add number method again and we add value number six so now our data stream has value number six once again we call the add number method and we add value number uh two so in this case currently our data stream has value number two and then if we call the find median method which means we will have to find the median now in this case ideally this find median method should give us the answer according to all of these examples we saw so basically first for this uh data stream it's 5 62 so we are going to put it in the ordered list that is going to be 2 5 and six and the answer in this case uh needs to be returned as value number five so five is what we would return over here for the find median now again there can be bunch of more uh operations to be performed same way so let's say that again we add a number uh and this case this time we add the number 11 so our data stream is going to a value number 11 now if we want to find the median then again there would be an additional bit of uh changes so it would be like this would be our sorted data data stream and the median is going to be 5.5 and this is what we will return so basically it will keep on changing now our job is to do this in the most efficient manner okay now in this array list what we are going to do is uh from whenever our main me method whenever we see add number uh method being called we are going to Simply push one number down this data structure so let's say we got numbers coming in as 6 8 2 1 5 okay this is the sequence of numbers that came in and then we encountered the find median method now again since this is a Brute Force approach we are going to take this step by step in the very preliminary fashion so first thing that we would do is that we need to find the median of this array list but currently this array list is not sorted so because this is not sorted we are going to Simply sort this now sorting uh an array or array list actually there are a bunch of different ways uh but typically this can be achieved in N log n time if we use something like quick sort or merge sort but we are not even going to bother implementing those quick sort or mer sort what we are simply going to do is call collection. sort method so if we call collections do sort method in any programming language basically it sorts the given array for us uh in N login time so after that we are going to have a sorted array and the sorted array is going to look something like this uh it's going to be 1 2 5 6 8 and this sorted portion took us n log n time okay now for this one two uh now finding the median it becomes quite simple because we know that for array uh fetching takes biger off one time and also putting the value takes biger off one time we already know the size of the array so in this case the si uh the array size is going to be five so because array size is five we know this is odd number and since this is odd number we need to find the middle value so middle value has to be located at position number uh three or in if we see in the array it has to be uh sorted array and uh the index value has to be two so because this is 0 1 and two and whatever the value is located over here we are going to Simply return that and that is going to be our answer so let's break down uh how does our Brute Force solution compare to everything we have done uh so far so it actually seems to do justification because if we see in this case the finding median uh is being done through two processes first processes that we are sorting the given input and uh second process is that we are actually finding the median by doing the average depending on the odd or even value now this case is a constant operation so this can be done in big off one time but the Sorting is actually a little bit tricky and this takes n log n time so overall the finding median is going to be done in N log n time and uh adding number adding number is actually quite quick so that that is being done in big of one time so if we see the total time complexity in this case the total time complexity for this BR Force approach can be considered as uh n log n and that is not so bad but we want to do it in much faster manner uh so we we will have to strive for something uh that where we can store or where we can save in in terms of time complexity well optimal solution uh is actually comprised of couple of different components and what those components are uh first we will have to find the room that where we can actually save in terms of time complexity so we are currently uh taking care of finding median by using for sorting the given input and second one is finding the actual median now this portion is quite easy so we can ignore this one uh this portion is the trickiest and why this is the trickiest because uh we actually have an incoming data stream uh that is generating bunch of different random numbers and we are taking these random numbers and creating them in a beautiful sorted list and this sorted list is then being used to find the median depending on the middle values now since we already know that the input that is coming in is coming in at 1 at a time so if the input is already coming at one at a time why can't we design a structure that automatically sorts itself and we are not going to need to care about the Sorting property so we already took care of one portion of it and what would be that automated sorting mechanism data structure is well you already know it it is actually called a heap or a priority CU where depending on the how you configure it or how you set up you can actually configure it to have in uh either in increasing order or decreasing order so no matter the sequence of numbers that are coming in at random eventually this is always going to be in the sort manner so if it is always going to be in a sorted manner then it becomes very easy for us to basically find the median because we already know that how to find the median from a sorted property now uh there are a couple of tricky Parts over here and first let's break break those down uh currently we have already decided decided that we are going to use Heap now what are the trade-offs with Heap well the first trade-off is that if we want to insert any data basically the insertion takes bigo of log end time right uh so that is adjustable because it is maintaining the Sorting property so how it does it is that let's say that you have this initial Heap that is being created and currently this Heap is empty now you have this one uh incoming value 15 coming in so 15 comes in so it currently because there are no values it puts 15 as it is now let's say that there is one more value coming in and that is value number 16 so now for this value number 16 Heap is not just going to append it uh anywhere in the um in the in the sequence it is going to see that okay uh let's assume that this is actually a Min Heap which mean which means that the topmost value has to be the minimum value and all the other values would be greater than that so in our Min Heap basically uh we need to make sure that the first value Remains the smallest and everything is sorted in uh increasing order so in this case because of this is a Min Heap it is going to put 16 over here and 16 is going to stored over here now suppose uh we have another value coming in and that is value number five now this value number five is actually lesser than 16 and 15 both so in this case it is actually going to find a proper bucket or a proper place for five to be stored and that is uh that it is going to do using the binary search and we all know that binary search takes log and time so that is why first it is going to do the binary search to calculate that where to this five it calculates that okay currently the five is the lowest or the minimum value so that is why it is going to put five at the beginning and it is going to take care of all the other values so basically our Heap is going to look like 5 15 and 16 and because of this property there is this log n time penalty that we have to pay but this log n is actually much better than n log n because we are only doing it once so that is the tradeoff now I hope I was able to explain you that how does a heap work uh once we have that sorted now let's see that uh will this make any Improvement to our problem well of course it is going to make significant improvements to our problem uh currently let's say that let's assume we are using a Min Heap uh again using the same example let's say that we have our data stream now in our data stream assume that we have all the values coming in uh at random so the random values that are coming in at the moment are uh going to be let's say 1 15 3 8 9 11 13 okay this these are the random values came in but we have a heap and we have a Min Heap which means it is going to take care of all the values in the sorted manner so sorted manner is going to be now in this case since we have seven digits or seven values stored inside our Heap which means that this is odd number so because this is odd number we need to find the middle middle value now this is the tricky part we know that with array uh it was actually easy to fetch any value from the middle because we were able to do it in big of one time constant time but that is not the case with the Heap uh so fetching the middle value it is actually going to take big of n ided by two time because we are doing it sequentially uh one by one to reach to the middle middle point so in that case since it is taking that much time can we do some improvements to actually find the median quicker so now we know that what is the issue with the typical ordered list basically inside the ordered list despite having all the values properly set up using the Heap it will still take us time to reach to the middle pointer and we want to basically make this process much faster so how do we do that well one simple conclusion is that breaking this Heap into two portions and how do we break this Heap into two portions is that first we are going to have uh a Max Heap Heap now what does a Max Heap means Max Heap is going to be this portion of the given existing list uh and if you notice one property in this portion is that every single element at the end of this Heap is always going to be the maximum value compared to all of its peers and this is the only value We Care same way we would have another a partition being made inside our Heap and that is going to be this remaining portion now inside this remaining portion we can actually call this Min Heap and why we are calling it Min Heap because the only value that is of concern to us is this middle pointer we don't care about all of these values we only care about this value because this is going to be the minimum value compared to all of its peers and if for an example if the current Heap size or if let's say that Max Heap and Min Heap we will try to to make make them uh exact equal in terms of the number of uh elements that are currently present so let's say that uh in our current data stream if the values are even basically in that case Max Heap and Min Heap they are going to have even values and in our data stream if the values are odd then uh in our case our Max Heap is going to have one more value compared to our Min Heap and that's it so if the values are even or if Min Heap and Max Heap are same in the size then uh the median value is going to be the combination of or the average of this Max and Min Heap uh and if it is odd basically we simply need to return this Max Heap value or the max element confused don't be let me let me show it to you with an example suppose uh this is our current or a current data stream what would be the ordered list first let's just try to understand so median in this case again that is quite easy to find the median is going to be this value number three that is the middle value and why we came up with this value number three because once again uh this is the the total number of elements are in the odd number so that is why it is easy to find the median now let's see that how would my Approach work so first let me quickly create a Max Heap and a Min Heap uh so I'm just first giving you the end result that how they are going to look like and then we will go go step by step on how to implement that okay so end result is going to be that this Max Heap is going to have all the values that are greater than the very first element inside the max he so max Heap is going to look something like this uh 3 2 and 1 uh actually it's going to be 1 2 3 but I'm giving you more general idea so that the you visually it is more interesting that the very first element is the element that we are looking for so in this case this is going to be that and if we see it with the original list basically we are taking care of these first three values same goes with the Min Heap what is what are going to be the values so the values are going to be simply four and five why because the very first element is going to be the minimum value compared to all the other values now again going back to our equation of uh the values being equal or one value being higher than the other so in this case currently if we see the number of values in our okay this MH is not the best abbreviation in our Max Heap okay Max Heap and Min Heap So currently in our Max Heap the number of elements are three in our Min Heap the number of elements are two because Max Heap has one greater element the whatever the value of Max Heap is or the whatever the value of the very first character in the max Heap is is going to be our median and in this case if we were to ask the find the median we can simply return the answer as three now let's see that how step by step we are going to maintain this property so first we have our uh Max he and then we also have our Min Heap now the property inside the max Heap is that the very first value has to be the biggest value compared to all the other values uh and the Min Heap is that the very first value is going to be the smallest value and also there are one more property that every single value inside the max Heap is always going to be less than or equal to the in Heap nothing more than that so first we are going to enter enter the value inside the max Heap and that is this very very first value 15 52 so first we ADD 52 over here uh currently Min Heap does not have anything we took care of this value now the second value is value number two first we are going to check the size difference between Max Heap and Min Heap and what the side size difference is going to tell us is that whether the value should be added to Max Heap or Min Heap so if we were to add this value number two to Max Heap then the size difference between Max Heap and Min Heap is going to be uh value two so because this is greater than one we cannot have them which means we will have to push one value to the Min Heap but the question is which value and that is the interesting part so we know the property that every single value in the Min Heap has to be greater than Maxi because of this one uh so if we enter value number two in the Min Heap will it make sense no absolutely not which means first we will have to push the maximum value that is currently present inside our Max Max Heap to the Min Heap uh so the first we are going to have value number 52 being pushed over here and then we are going to have this value number two being pushed to our Max Heap uh I hope this makes sense uh if not try to rewatch the video for this portion and you will understand what I exactly said so now we already get took care of value number two as well and also remember because we have both the values at the same time if we want to find the median it becomes quite easy we can do it in just constant time at any given moment because let's say I tell you that after these two values there is a find median uh uh command you can do it quite easily you can just say that okay 52 + 2 50 4 54 divided 2 I think it's going to be 27 and 27 is the answer you can find it quite obviously so that is why this approach is very fast now again going back to our example now this value number three we need to push in uh currently both of the Min Heap and Max Heap the sizes are same which means the value has to be entered into the max Heap because Max Heap can have one more value than the minan Heap so three we know we have to put push it into the max Heap now what is the property of the max Heap that very first element in the max Heap has to be the greatest element or the biggest element compared to all the other values so in this case because 2 is the small animal element we are going to adjust our Max Heap so first element is going to be three and second element is going to be two now we took care of this value number three as well uh now we have this value number five to take care of again five has to be added to the Min Heap so if we should we add five directly to the Min Heap or should we compare add it to the max Heap we are going to check the very first or the biggest element inside the max Heap the biggest element of the max Heap is lesser than the value of the that we are trying to enter which means five can easily enter our Min Heap so since we are entering five into the Min Heap we also wants to maintain a property inside the Min Heap that the very first element inside the Min Heap was always going to be smaller which means 52 we will have to move on the side and value number five we will have to put together because up until this point even if you see that what are the elements so the original elements were 52 2 3 and 5 if we just want to put them in a single ordered list the value is going to look like 2 3 5 and 52 and we are only concerned with these two values three and five and which we are able to make sure or use using this Min Heap and Max Heap so that's why we are going to get rid of all of this uh this was just for explanation purposes but you get the idea that what we are trying to do now again once again we we have the value number uh 11 that we are trying to enter so for this value number 11 it has to go to the max Heap uh what is the property of the max Heap that the very first value has to be the biggest value So currently the value is three so because three is smaller so 11 will go over here in the middle uh in the very first value so we are going to get rid of these two and the value is going to be 11 3 and 2 and currently what is the is going to be the median value the median value is going to be uh value number 11 the biggest value of our Max Heap but question is can 11 stay there of course not why not because every single element inside the max Heap has to be smaller than every single element in the Min Heap and currently we have value number five that is actually smaller that is residing in the Min Heap so that should not happen so once again we will have to first before adding 11 over here first we will have to add value number five over here and then uh since the size differences between Max Heap and Min Heap is greater than one so 11 would rather going there it would enter over here and in this case uh the values are going to look like that uh 11 and 52 okay now we have the very final element seven that we need to enter so where should seven go again uh this already has one element greater so we know for sure that 7 has to go to Min Heap but uh seven we we are going to compare seven with the very first element so uh 7 is greater than five which means seven can easily go into our Min Heap and uh since 7 is the smallest element we will have to make adjustments before we enter seven over here so the values are going to be 7 11 and 52 so in the end we are going to have our two Min he and Max Heap So Max Max Heap is going to look like 5 3 and 2 and the Min Heap is going to look like 7 11 and 52 and now if we are being asked to calculate the median it is quite obvious we are just going to do addition of 7 + 5 so our value is going to be 12 divided 2 and the answer is going to be six and this is the beauty of Heap and this is why this problem is a hard problem but also very popular problem uh let's calculate the time and space complexity so again for the time complexity uh first we need to find that for the max Heap and Min Heap so insertion takes uh log and time and essentially we are going to be inserting values in the min max Heap Min Heap sometimes from Max Heap to mean Heap and sometimes from mean Heap to Max Heap but in either case we are going to be achieving that in log and time so essentially we are doing login four times and then uh for the one time we also have to enter the value from the data stream to one one of the Heap so essentially we are actually doing the log and operation five times so if you want to be very specific you can mention five log n to be the uh exact uh time complexity and plus in order to find the median this operation is actually constant so big that is being done in big off one time so this is a very good time complexity now let's calculate the space complexity so space complexity is basically going to be bigo of n uh where n is the number of values that are currently present inside the incoming data stream so here is the coding solution uh first of all we are creating our class called median finder where we have our two priority Set uh first one is a priority Q named low that is our Max Heap and second one is one is our Min Heap now uh we need to create a method to add number basically to add number we are first of all adding it to the max Heap then we are balancing the both the heaps and then we are checking that uh if they both are maintaining the proper sizes or not uh if not we would pop the element uh and move it to the other Heap and in the end it becomes quite easy to find the median and that is essentially you just uh check the size if the sizes are equal then you do the average of both the lowest and the highest value and divide it by two otherwise you take the value from the max Heap and return it as the answer uh so let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs decently efficiently and uh I would be posting this solution in my GitHub so this is my GitHub repository and you can find bunch of different solutions over here and it would it is going to be quite useful uh good luck so the lead code problem we are going to do today is called subsets and we can see that this one is a medium problem and also a very well-like problem on lead code the statement is quite straightforward that we are given an integer array called nums and we need to return all the possible subsets of this given array so possible subsets means every single possible values or combination of values you can make out of the given array so let's say that we are given an input element like this and we are trying to determine that what are all the possible subsets that we are going to be able to make so we know that for any given n value we can make 2 to the power n subsets so in this case we should be able to make four different subsets let's understand that what these subsets are going to be so first subset is going to be quite obvious that is going to be an empty uh array nothing more than that and because that is a subset of this by default because if we remove both of these values still we have an empty array which we are able to generate using this next way we can also generate values just one same way we can also generate value just two and same way we can also generate value one and two so logically using this logic we should be able to try to understand that what is the way we can approach this question and what I am suggesting is that this is nothing more than a decision making algorithm where at every given step you are making the decision on whether you are going to include that element in your answer or you are not going to include that element in your answer and based on that you should be able to come up with these four answers so let's try to let me try to explain you my Approach using this example and then we will try to understand this for a bunch of different other examples let's say that currently we are we are given these two these two elements as part of the input now the in order to generate the very first subset we have two options and let's say that we are also iterating over this given input array in this fashion so the moment we iterate over this input array one the very first option we have is that we should should we include this one in our answer or should we not include one in in our answer so let let's generate those subsets so if we don't include one we come up with an empty list if we decide to in include one then also we are going to be able to generate uh subset like this one same way uh next we have the option that after this one now the next element in the loop is two so once again we have the same option that whether we should include this two in the answer or we should not include this two in the answer so let's say that if we decide to include this two in the answer then then we are going to be dealing with values 1 and two then once again we still have one more option that is because remember we are trying to build the subsets so with every single value we iterate to the next we are also going to calculate the possibility by removing the previous value so let's say that we decide to remove this one completely then also we still have one more option that should we include this value number two inside the answer or not so once again we will have one more subset like this and then we have reached to the end of our Loop so we don't have any more options so this logic gives us the correct answer of all the number of subsets that we can make where what we did is at every given step we checked that whether including that value or not including that value would result in some sort of subset marking those subset in our answer array list we are going to create and this answer array list is going to be list of list because it's this array is also going to contain bunch of different array values and where we are storing the value of every single result that we are calculating so once again let me try to go and explain this for a broader scenario the solution I'm proposing and then it should make you absolutely clear on what is the approach we are suggesting basically at every single step we are going to make a decision to whether to include that element or not and every single answer we generate it is a it is one of the subsets so let's say at this very first position we have two options whether to include one as the part of the answer or not to include one so let's see both possibilities if we don't include one we have an empty list if we include one we have one value that is value number one let's say we decide to go down the path of including value one once again we have two possibilities whether to include value two or whether not to include value two if we decide to include value two we are going to have 1 and two if we don't include value two and go to the next element we are going to Value 1 and three and that's it now these are all the elements we have so we won't be able to go any further but we still have a decision to make which is over here that after this 1 two do we need to include three or not include three so let's include three so that is going to be this decision 1 2 3 if we don't include three then that then it is just one and two that's it now once again now we took care of all the possibilities with value number one now let's try to work on value number two so once again we have the possibility of including two or not including two we already calculated if we don't include two then it is going to be an empty list so let's include two now so by doing that we are going to have one uh decision tree like two now at this two once again we have two possibilities include three or not to include three so let's decide to include three then we are going to have value one uh two and three and that's it now if we don't include three we already calculated that possibility over here and last one is value number three so once again for this value number three we have two possibilities whether to include this one one and two we already calculated all of these by including one and including two if we don't include one and two then we have we only have one possibility that is to have value number three and that's it so these are every at every single decision that we are able to generate we are able to see that what are the values being generated by those decisions and all of these are actually the answers or the subsets that we need to record and that's it this is the Crux of the the entire problem uh and the whole solution so we can see that we are being able to generate in total these eight values and these eight values are actually the answer we are looking for now let's try to think about that how did we generated this answer the logic is quite simple we do this recursively and using backtracking and how do we do backtracking and recursively let's understand this with first of all what is the recursive pattern so we know for recursion we need we need two items first one is a base case and second one is a recursive function so base case is quite obvious that whether we have ex executed all the possibilities uh or we we completed every single elements so both of these base cases works perfectly fine because at every step we would be able to record generate an answer so this is our recursive function that whether we exhausted all the possibilities or we we don't have any more elements that we need to Traverse over now what is the recursive function it is also quite obvious that as long as any particular elements exist then once again record both possibilities of including that value and not including that value as part of the answer after doing that once again do a recursive call back to the same function in order to check that if you include that value then also what are the remaining values persisted call back the recur the function with those values once again if you don't include that value what are all the remaining values persisted once again do a call back operation and if there are no other values left then basically just do a return call so this uh recursion would be able to generate the answer now why do we need to do a backtracking and that is also quite obvious because what we are doing is that we are building a decision tree so let's say that we are given this values 1 2 and three so once again for we first check all the possibilities for this value number one so we check their value number one then we check value for 1 2 and 1 3 and once again we check for Value 1 2 and 3 and after at this moment we will once again have to go back and see that did we miss out any particular element or any particular possibility that we did not check so so far we did not we checked all the possibility over here we checked all the possibility over here once again we do a roll back once again we check did we check all the possibilities yes we did so once again we do a backtracking and go to the next element and and once again repeat the same operation and that's why backtracking is the backbone of this problem that allows us to solve this problem flawlessly and pretty smoothly so this is how we are going to be able to use uh solve this problem using backtracking and recursion uh and this is these two typically go in hand in hand whenever you try to solve some problem using backtracking most likely doing it recursively would make much more sense we already know what is going to be the time complexity in this case that is going to be big of n * 2 to the power of n because that is all the possibilities we will have to check now let's quickly see the coding solution the coding solution is quite straightforward uh first of all we have our subsets class where we are receiving an a nums as part of the input then we are generating a list of array list to store our result and then we are going to call our recursive method that we have created that is called generate subsets now we are passing in the current index the starting index then we are passing in the nums array and we are also passing in a variable to store our result uh and also we are passing in a new array list or the current array list that we are going to be creating that we would be adding at every single subset iteration now let's see our helper method so first of all the moment we enter inside our sub uh subset we are first of all going to add whatever the current array list that we have been able to generate it so far as part of our result as as a new instance of the array list and then we are going to have a for Loop that is going to Simply iterate over every single index position inside our nums array where we are going to check for the following first of all we are going to add the current value as part of the current iteration that we are building which would be added into the array list or in into the result in the next iteration of the uh recursive call then once again after adding the current value we are once again going to call call the current value as part of the result um or sorry as part of the recursive call and this is our recursive function and after that once that is done we are going to be removing the current element in the next iteration why because let's say we are dealing with five elements then at every given instance we need to remove one elements after we have we are done iterating every single possibility at that value so this is that step and that's it so by the end of this array every single value should be populated inside of a result uh array list that we have been able to create and uh at the end of this sub uh recursive call is done we are simply going to return that value so let's try to run this code seems like our solution is working as expected let's submit this code and our code runs 100% faster than all the other Solutions and also it is excellent in terms of uh memory utilization as well so once again the solution of this code is available on our GitHub repository so you can go and check it out from there thank you hello friends we are still not employed by a Fang company so let's not stop lead coding till we get there today we are going to do a very important lead code problem and uh I have provided the introduction of what are the things to expect from this video uh we are going to solve the combination sum problem and uh first of all I'll be showing that what are the top companies that have recently asked this question from lead code premium uh we'll understand the problem statement we'll also find the optimal solution and we will also determine that what would be the intuition behind it uh we will create an example and we'll walk through it and uh at the end I I'm going to write a Java code I'm going to explain it thoroughly that uh how we come up to it and uh also we will be explaining the time and space complexity so first of all uh these are the top companies that have asked this this problem recently and uh if we see from past 6 months to a year um it's eBay go Google Goldman Sachs and these companies and in pretty recently Amazon has asked this question 20 times in its interviews Facebook has asked this question 18 times in its interviews so I highly highly suggest you to take a look at this problem understand it completely and uh then uh practice it as much as you can this is a medium problem and we are given uh distinct integer called candidates and we are also given a Target integer and we need to return all the unique combinations of candidates where we can reach up to the Target value now this is little bit tricky part to to find all the unique combinations uh for this target candidate because uh let's try to understand this with an example so over here we are given the candidates as uh 2 3 6 and 7 and we need to reach the value number seven so we can clearly see that s is already present over here so we can return this one the thing is we need to return return all the unique combinations so one unique combination is seven uh second unique combination and also we also one more thing we can use the same number uh from the can candidate unlimited times so if we apply this Theory then we can find another value that can reach to the sum of seven then that would be 2 + 2 + 3 if we do that this also sums up to seven so we need to return uh a list where the two values are 2 2 and three and the second uh element is just seven and this would be our solution for this given problem okay let's try to understand this problem with a custom example and it is really important to create your own custom examples because it shows that you have the ability to think out of outside of the box and you can create test cases on your own it is a really important skill to have for any engineer and especially Fang Engineers so we are given three candidates two five and six and we need to see that what are all the combinations we can get out of these Comin uh candidates to achieve the target value eight now just by looking at it we know that the two combinations we can create is uh 2 2 2 two this is one combination and the second combination we can create is 26 uh and this would be our answer the thing is let's see that what would be the most in most basic solution we can come up with and what would be the intuition behind it and based on that we would be able to create an algorithm uh that would solve this problem so initially we are at this position zero now at this position zero we have three possibilities from which we which direction we can go uh we can either go to this value number two we can go to the value number five or we can go to the value number six the because these are the three candidates that we are given and also we should not forget that the target value we want to achieve is eight okay so keeping this in mind we need to go and pick a side where we need to go further and uh keep going so again let's just go on One Direction for all the cases we can so over here we are at two now remember that we can use same element infinite times which means that there can be one possib is 22 of course there can also be one possibility as 2 22 of course the thing is uh notice that we need to put a constraint for the number of decisions we are making and the constraint is that if at any point the the direction that where we are fetching all the candidates if the sum of those can they can either be less than uh Target they can either be equal to Target or they can be greater than Target these are the three possibilities we can have if it is less than Target which means that there is still room for us to find the potential combination which means we can keep further going on that direction if we are already at Value number eight or value whatever Target we are we can directly put this value in the result but if we and which means that we have found the combination so there is no point in going further after we have already found the combination because all the elements they are only going to add up to whatever combination we have which means that we won't be able to find another Sol condition uh combination with the same numbers that were used to achieve this equal to and the third option is that the value could be greater than 8 if it is greater than 8 why are we keep on going or to do more iterations and uh putting more more strain in our computer there is no point in doing it because we could have infinite op options and if we do it this would be like the most wor this would be like the best way to deplete the resources of our company so we don't want to do that so now since we have kept these things in our mind now let's see that what how can we use them over here so so far the sum we have found up until this point is only two but thing is over here we have two candidates and the sum we have found so far is four which is still less than eight uh this is six again still less than eight now over here we can have one more possibility as uh 2 2 2 and two and if we do the sum of this this is eight which means that this is actually equal to whatever the target value we had so we can add this to our result combination we would have that we have already find one value in our result and we will just add it as uh 2 2 2 two this is one combination that we have found so far the thing is we are not done yet because we still have other candidates that we need to look at and uh we need to check the possibilities the thing is we have concluded at least one thing so far and that thing is we can't go further down on this path because all the values would be greater than eight and which is not what we want so the only way we can go is actually we can go back and see that have we missed out on any combination so over here the next possibility we can get is we have already used two as our candidate for this value 2 2 2 so the next possibility we can over can have over here is uh it can be 2 2 2 and five or it can be 2 2 2 and six so let's do sum of all the combinations so some of these combinations would be um 11 and some of these combinations would be 12 notice that both are actually greater than the value of our Target which means that we can't go further down at any of these positions and we have exhausted all the possibilities up until this point so since we have already exhausted the possibilities up until this point the only way we can go is we can go back at this position two we have exhausted all the possibilities that can have one we found the answer and the other two we found that it cannot be part of the combination which means that we have already exhausted all the possibilities for this value 2 to2 as well which means that we can't go down but we can go up so over here have we exhausted all the possibilities so far no there are still room there are still other possibilities that we can check so let's do that so one possibility we can have over here is our 222 which we already checked the next possibility could be 2 2 5 and the next possibility would be 2 2 2 6 so Su of these values is actually 9 and some of these values is actually 10 Again both are greater than whatever the target value we had which means that it we cannot go for down so we will go back we went back over here we check that we we went through all the possibilities which means that we are done over here so we can't go down any further on this path but we can go up so if we go up we ask ourselves a question that have we ex explored all the possibilities this at this position no the possibilities we could have is 2 5 2 six so let's take this value first so at 25 the current sum we have is 7 7 is less than whatever value we have as our Target which means that we still have possibilities the possibilities we can have is uh 2 5 5 or 2 5 6 notice that over here we only had two possibilities where we can calculate it from we did not had the possibility of 2 2 5 why because we already calculated it for this portion over here remember in the previous iteration we already calculated for this scenario which also shows one very important property and that property is that out of our candidates uh whatever the candidates we are given if we are at any particular position or any combination of positions uh so whatever value we have as last we can only use that multiple times or we can use the values that come after it we cannot go backwards because we have already exhausted those possibilities in an iteration before this as I showed you earlier that this we have already explored over here and this 2 to the 5 uh 2 five we are exploring at this position two which means that the only combinations we can make up after this point is either 2 5 5 5 something blah blah blah or 2 5 6 6 6 something something like this but we can't make like 2 2 2 five because we already checked that over here so and this is a very important property that we are going to use okay at this point the sum we can have is 12 which is greater than 8 so we can terminate over here we can't go down any further and over here the sum would be 13 again we can terminate over here we can't go down which means we have to go back so we come back at 25 we say that okay we have explored all the possibilities over here we go to go back to Value number two another thing is at Value number two have we explored all the possibilities no there is still one possibility pending which is 26 so at 26 uh this value the sum would be 8 again this is really critical because we have found a pair that equals to whatever Target value we had which means that we will add this combination to our result list so over here we will add another entry 2 six and after adding this we have explored all the possibilities after this point which means that we would go back now at this position two we have explored all the possibilities it could have and because we have explored it we will again go back to our zeroth position the thing is we are still at zeroth position so can we stop now no we can't stop because we still have a whole lot of possibilities that we haven't touched so far because remember over here we still have this five and six pending so let's see that what could be the possibilities over here now at five again we can only have two possibilities as explained earlier we could have either 5 five or we could have 5 six so let's do the sum of these values so 55 the sum is actually 10 and 5 6 the sum is 11 both are greater than 8 uh which means that we can we can terminate over here so that concludes that at this position five we ran out of the possibilities we went up at this position we are done so again we go back we go back at zeroth position we check that have we any do we have any other options uh where we can explore and yes currently we are at Value number six so six is again less than our Target 8 so we can go further from six the thing is at six we can only do 6 six um we can't do any any other combination because those we have already checked so far which means that 66 the value is 12 so 12 is already greater than 8 which means that we can't go further from this which means we can't go further we go back uh at six we see that have we explored all the possibilities yes we have explored all the possibilities which means again we go back to this position zero so at this position zero we check that now have we explored all the possibilities yes initially we check all the possibilities for the value two again we check for Value five and again we check for Value number six which means that even at zeroth position we are done so our base case has satisfied now whatever we have stored in our result parameter result list so far we can simply return this and this would be our final solution and this is actually the optimal solution that we can achieve notice over here that we are doing lot of repetitive work at any position we were calculating the different uh possibilities we can have we are picking a possibility we are exploring in uh that direction a depth first search uh we kept on exploring once we found a terminating case once we found a ter once we found a terminating case we would go back to a point where we can still explore for more possibilities over here again we would further go down uh to additional possibilities we would find a terminating case again we would come back and eventually we would come back to the zeroth position from where we started and uh after the calculation we will return our return the result so this at any point we are coming back from where we originally started this is actually called backtracking this is a really important Concept in uh Computing uh computer programming and uh I just showed you that how can we use it and that is why because this concept is really important it has lot of um very practical applications and that's why you see that why all those big companies like Google Facebook Amazon uh Goldman sax they were interested in asking this question to their inter uh to their candidates because they want to know that are you familiarized with very important things that are really critical and uh can you go down that path and uh yeah so since we have found our optimal solution I did not mention explicitly that I was showing you the optimal solution but the thing is I told you that this is the intuition behind it and once we knew the intuition we just need to find a way to implement it in a computer programming the way to implement this you must have guessed it correctly that we were doing so some so much repeative work again and again and if we were using it somewhere and we had some terminating uh conditions that either if the value is equal to or greater than our Target we would termin it which means that we were using uh recursion at it its best uh over here so yeah this is basically our solution so let's calculate the time and space complexity the uh time complexity for this one would be bigo of n to the power t now first let's determine that what this n and t means n is actually the number of uh candidates and the least value for this one and T is actually uh the total amount because imagine that what is what could be the longest sequence we can have at any given position well suppose our Target value is eight and our candidate candidate is one which means that we would do 1 + 1 + 1 up until eight times till we get the value eight which means that we need to go in One Direction eight times and at any position we can have multiple options or we can make multiple decisions and from further down we can go ahead which means that we need to do this work n to the power T times until we find the solution so that's that's why this is the time complexity so first of all we'll create our result list and now we'll create a list to store the current combination okay now uh we will create a backtrack method and uh in this would be a recursive method so initially we are going to provide the target result combination uh zero as the starting point and the candidates array and uh after whatever the result we get back from the uh recursive call we simply need to return whatever we find in this result list so let's create the recursion method okay so first of all we are going to create the terminating cases so so if uh Target is equal to zero which means that we have find a combination that sums up to the Target value so we can just simply return it to uh simply we can simply add the combination to our result if this is not Thea case we need to return uh we need to check that whether the target is uh less than zero which means that we have already surpassed our Target and we need to break uh so we can just return null if both cases are not true which means we still need to look for our combination so uh we will start by checking in our combination from the position start and we will go until we still have candidates now inside the loop first of all we will add whatever candidate we are currently looking for in the our combination list okay after that uh we can do our uh recursive call and as a Target we will have Target minus whatever candidate value we found and start would be e position and I think that that would be it uh yeah one more thing we will have to remove the entry from our combination list because we will be doing back tracking when we uh move towards the next value and I think I think this would be it let's try to run the code this should have worked but I don't know why it's not working so we'll just enter the value manually oh it should be Cy dates okay our solution seems to be working let's try to submit the code and yeah our solution works perfectly fine and I will be posting [Music] now the lead code problem we are going to solve is called permutations and we can see that this one is a medium problem and also an extremely well-like problem the statement is quite straightforward that we are given an integer array called nums of distinct integers and we need to return all the possible permutations that we can make and good thing for us is that we can written answer in any order so first let's try to understand this with few example let's say that in the input we are only given one element then we can only generate just one permutation so this is what we need to return but if we are given more than one element let's say one and two then we can actually generate two permutations in this case first permutation is going to be the same value as it is in the second permutation we are going to have the values being flipped around between two and 1 so these two are the permutations that we need to return let's take one more example suppose in the input we are given the values 1 2 and then we can basically calculate that we should be able to make six permutations in this case why because for any particular given numbers you can make n factorial permutation so in this case we are given three elements so three elements is going to be 1 multiplied by 2 multiplied by 3 as in 3 factorial so in this case the answer is going to be six now let's see that what are all these six elements are going to be well so these are all the six permutations we can make now logically the this is nothing more than a decision making element or decision making algorithm because over here we can see that if we have to make permutation of this element let's say that I have three blocks where I can fill in values now let's say for some reason I decide to put three in the first block then I know that I still have two values where I need to fill out something but thing is I can only fill out between this value 1 and two not this value three so once again I can repeat the same process and let's say randomly I decide to pick value number one so now for this last element I only have just one possibility and that is to fill in this value number two and this the moment it reaches to the length of this previous one we can determine that this is one of the permutation that we can store as part of the answer now after storing this we need to check that whether keeping this three over here at the beginning are we leaving out or done being done with all the permutations no there are still possibility of permutations left let's say that we decide to eliminate eliminate this value number two over here and this value number one over here now once again keeping this three on this place once again we have the option that instead of selecting one uh we can actually select two over here then we will have one over here and this would be a new permutation so visually this is very simple to understand that how does this function but thing is implementing this is slightly tricky so what I'm suggesting is that we actually use the same algorithm that we just saw but we apply it using the logic and possibility and concept of back tracking Plus on top of it after using the backtracking I also suggest that we use a recursive approach to recursively recall the same function with different inputs and why am I suggesting this is because number one uh we already know that we are repeating the same process all we are doing it is that the input we are given we are picking one value in we are marking that particular value with one of the values and for that let's say that over here we have one so once again now we have two possibilities first possibility is that on this place for the second place we can fill in the value two or we can fill in the value three once again let's say if we decide to fill in value number two then we are only left with just one possibility for this last element that is this value number three and the this whole path defines one of the permutations so this we will be able to mark as the answer and then if we go decide to go down this path once again the values are going to be 1 3 and 2 so this is going to be our second permutations and once again we can mark this answer as well so now let's say that what are the things we need to solve this problem and how we are actually going to be doing that I just explained that we are going to be using backtracking plus recursion so let's say that what do we need for our backtracking function the idea is quite straightforward that we we will keep on going in One Direction until we reach to the length of the given input once we reach to the length of the given input we will Mark that uh entire path and as part of the one of the answers and we would put it into our list of list that we have created to store our answers or results once doing that the idea is to once again do a backtrack and after doing the backtrack once again see that what is the potentially different path that we could have taken and once again once we reach to the answer we basically store that answer now there are two critical Parts in this case that we will have to consider number one thing is that we will need to know at some point that what are the values we have already calculated and what are the values we have not calculated so far so what I'm suggesting is that let's say you decide to put one over here then I would need some sort of way for my computer to tell me that this one is already part of the function so for that I'm suggesting to use a used array or like array named used and the moment we add any particular value inside the current consideration for our recursive function we are going to mark this used function as true or false so this this would be my used array of Boolean values and currently I would Mark that this is true which means I'm currently considering one then once again let's say that now I have I know that through my used array I only have two two more possibilities left because this one has already been filled so for the next element I'm going to consider this value number two and once again I'm going to mark this value two as being used as one of the decisions after doing that once again I'm going to mark this value three and then we are I'm going to mark this three as being used but the thing is because I reach to the end of the list so the moment I reach to the end of the list I can mark this answer 1 2 and 3 and after marking this answer I can actually go back and I can go back in time with my recursive function and say that over here instead of using two now I have decided to take another path where I'm going to be considering three as part of the input and in order to do this one I will need to constantly update this used array that is number one thing second thing is in order to calculate this path I will also need to have an a current array or array list to store this path as well that these are the values we are currently iterating and the moment we identify that we have reached a new answer then for the next iteration of the recursive call I simply need to regenerate the entirely new array so I know my solution might confuse you a bit but let me just give you this uh with like using two examples so let's first quickly take the example of simple one and two values okay logic is that we are going to have a recursive function that is going to store um so for the recursive function I did not explain but basically for the recursive function we need two items so we need a base case and we need that what is going to be be a recursive call base case is quite straightforward that the moment we identify that our given current n or the current length of the given input is equal to the original n of nums then we we have ident we have found the correct path in this case we would Mark the current path inside the answer and after marking that we would we would basically return so this is going to be our base case now for our recursive function the idea is quite straightforward that we are going to pick one element right now and through that one element we are going to be marking the used array for that particular element to be true and then we are going to call the recursive function once again with the remaining portion because we still haven't identified all the values once we identify all the possibilities uh and we receive an answer back then we are going to eliminate the last element we had inside of a recursive function to be turned out to be false and keep on repeating that in order to calculate other possibility so let's first see for this example the idea is that first of all over here I have two possibility let's say I Mark number one element as being used and I have a current list where I'm going to store that what is the current path I'm taking okay I took one now I'm once again going to call for the next element so now I call for the next element that is obvious choice two so I Mark two and now I know that my length of this current has reached to the uh n so I'm going to mark this as part of the Answer 1 and two after doing this once again I'm going to do a backtrack call during the backtrack call I'm going to mark this one as not being used and two is not being used and then uh I'm going to be iterating over this given input in this fashion so I already took care of this element and now I'm going to start taking care of this element so now I have my two as being used now I have my current new current instance being created where I'm starting the path from Two and I'm going to go down to the next PATH so I only one possibility that is to add value number one so I'm going to add value number one over here mark one as being used and because this n is correct so once again Mark the another answer as 2 one and now I have my answer that I was looking for so after this I realize that in my existing loop I already en be done through all the elements inside the given input so which means now whatever I have in the answer I can simply return that so now if you want you can directly go to the coding approach if you already understood what I meant if you didn't understood then let me also do the same iteration for this path as well and once again repeat the same procedure so logic is we are going to be iterating over every single element one by one that is number one thing next thing is the that uh we are going to have our current uh list or the current values we are retting over and we are going to have a used array where we are going to be storing that which are the elements we have already used so far in the current iteration and we are are going to be updating the values one by one so let's say that in the current path I add value number one so I'm starting the path from value number one after one I decide to add uh value number two as an input so once again I do that and after this two I add value number three so the moment I add value number three my length is equivalent I'm so I'm going to store The Answer 1 2 3 after storing this now once again uh I I do a recursive call so I basically break out so which means I will have to remove the last element I added still keeping one I still have one more possibility that I haven't tested so once again I'm going to mark three as being visited so now I'm going to take one more path and by the way this is going to be a new instance where currently the nodes I have visited are 1 and three and next time I'm going to be visiting the value two because that that that element is left over here so once again I'm going to be marking two and I'm going to have one more uh possibility 1 3 and two once again uh now I do a backtrack so back tracking would make sure that I took care of three over here I took care of two over here and all of these things are done so now my used AR need is being backtracked to all the way to the beginning so now once again I'm going to repeating the same process but now this time with value number two and keep on doing this recursively until we reach to this very last element three where we have all of the six possibilities calculated and this is the whole solution so now let's quickly see the coding solution and that would make make much more sense now first thing we are going to do is that we are going to create a new array list which is going to store our results so now you can see that this one is an array list that stores different array list inside then we are going to initialize our used Boolean array uh in order to keep track of that what are the current elements we have already used and then we are going to have a helper method called backtrack where and as an input we are providing our result that we have calculated so far then we are going to have a new array new instance of an array list where we are going to be storing the current elements we are iterating over next we are going to be passing in the given input nums and lastly we are going to be passing in the new array used array that we have created now first we are going to be checking for the base case that if the current size is equal to the length of the original given array then we are going to add the results of the current array list inside the new instance of a new array list and we are going to be doing us a simple return if that is not the case then we have our for Loop that we need to iterate over so very first thing we are doing is that we are starting for from the zero and iterating I until we reach to the end of the array then we are first of all checking that if the given I value is not used then we are going to be adding that value inside the current uh path that we are iterating over so we added that then we are going to be marking that particular element as true inside inside our used array and after that we are going to be calling our backtrack for method recursively where once again we are simply providing the results that we have calculated so far the current path which now contains a newly added element and the nums input and the used array that now contains that the current element is being used and that's it basically this should ensure that all the work gets through and the moment the list size is correct then we would start adding those values inside the result but the thing is after the backtrack call we will also have to remove the lastly used elements so we are going to be doing that and we are also going to be removing that value the very last value that that we had in our current list so we are always updating that in order to calculate new possibilities and this is the whole solution now I know it's hard to visualize but coding is very small and also you can understand that how to generate it on a pen and paper so you can just work around with different examples and it would make sense to you now let me quickly run this code okay seems like our solution is working as expected let's submit this code and our code runs super fast compared to all the other Solutions which means this is an excellent approach now I know using an extra used array might hamper with our space complexity but this is still a much faster result so now I will be posting the solution in our GitHub repos osit so you can check it out from there thank [Music] you now we are going to be solving the problem subsets 2 now this is very similar to our original subsets problem but there is a slight difference now we can see that this one is a medium problem and also a very well-like problem the problem statement is that we are once again given an integer Erin nums that may contain duplicates so we need to return all the possible subsets plus we are told that the set must not contain duplicate subsets so there is only just one tiny bit of difference now let's first understand that what does a different subset means so let's say that we are given an input array like this then the number of subsets it can contain is going to be 2 to the power of n so where n is the given number of elements so in this case we have two elements so we can that 2 to the^ two which means four subsets we we should be able to create and these four subsets are going to be an empty list a subset only containing value number one a subset only containing value number two and a subset containing value number uh one and two that's it so this is the whole solution but the thing is I know we just solved this problem in like our subsets problem so if you want you can check it out from there the thing is in this case the only difference is that let's say that we are given a value like this where it the input may contain duplicates then this changes our equation a bit because in this case we need to only return the unique subsets so in this case if we want to create the number of subsets definitely we can create 2 to the power of n subsets the issue is that we can create a subset we can create like an empty subset then we can create a subset with just one but once again if we try to create a subset with this two let's say then we can also create a subset like this this two and if we were to put both of these in the answer then there would be duplicated entries so we only need to just pick one so that is number one thing there can be one more duplicate in this case and that duplicate could be that we can create a subset like this value 1 and two and we can also create a subset like this where value is 1 and two so if such kind of situation occurs then we need to take care of that scenario so basically making sure that whenever we have duplicated entries we just have to keep keep them aside or not consider them for the current part of the subsets now we all know that what was the strategy we used in order to calculate the subsets let's say that we only have just two values given and we are trying to generate the subsets logic is quite straightforward we are going to be using the backtracking on top of it we are going to be using recursion now let's what is going to be Logic for our backtracking that that while after calculating every single path for every possible subset then we are going to be doing a backtracking and once again repeating the same operation what do what do I mean by that let me just explain so first of all we are at the empty list position now over here we have the possibility to include this value one or or not to include this value one same way we have the possibility to include this value two or not to include this value two let's say that we decide that we are not going to include both of these 1 and two so in this case we can create a subset like this like an empty list and we will mark this as part of the answer so let's say that this blue line indicates that we already marked it as the answer now once again after marking this answer we still somehow needs to go back and revert our operation so in the previous choice we decided that we are not going to select this value number one but now let's say that we do decide to go ahead to select this value number one so once again we are we can create a subset where we are only selecting the value number one so once again this is also part of the answer so I'm marking it with a blue line but after doing this once again we will have to do a backtrack and see all the possibility so we already exhausted all the possibility of selecting one and not selecting one but thing is we haven't exhausted all the possibility of selecting two and not selecting two along with this one so let's say that along with this one we have the possibility that whether we select two or not select two so we not selecting two we already calculated but now we are calculating one more possibility where we are selecting two so we have values like one and two okay after doing this we can do a back trck we did we check all the possibility at one once again we check everything so far the thing is we haven't checked the possibility of only considering two so once again we are simply going to be considering two and this is going to be our backtracking mechanism on top of it this is also going to be a recursive function that I just explained where for the recursion we need we need two items we need a base case and we need a recursive function so for the base case it's quite straightforward that whenever we create or we make any single decision we simply add it to the answer and this is our base case after this for the recursion we go back to the next recursive call with that selected value or not selected value and once again repeat the same process for the next upcoming remaining elements inside the array so this already makes sense we already do this but the only issue in this case is that we simply don't want to consider let's say that we are given values 1 2 and two so now in this case once I'm making the decision let's say I put down the empty array then I put down a list with one right now at this one I have two possibilities first possibility is that I'm going to be considering this two and second possibility is I'm not going to be considering uh this two so let's say I decide to consider this to then I should be able to create an input array like this or like a new subset like this once again let's say that I go to an and let's for a Simplicity let's assume that this value is currently three okay not two so if this value is three then I create one possibility where I'm considering two I can also create one more possibility where I'm not considering two which means there can be a subset like this 1 3 but in this case rather than this value being three this value is also two so it's the same value so if I try to do this possibility in this case then I'm just stuck I'm left with only this value so what I can simply do is that I can take the given input let's say the given input array is like this but it it right now it is already sorted but it is possible that this may not be sorted we could have given values like this so once again we if we want to do the solution what I'm suggesting is that whatever values we are given we simply sort those values so let's say we get a nice looking values like this after sorting all we simply do is we check that at any given moment the whenever we calculated a possibility with this two now we are trying to calculate another possibility we just check that the current element we are considering for the possibility if that element is same as the previous element then we just don't consider that possibility that's it this is the whole solution so now what would happen in this case we will have an empty list we will have value with with one now we will have one more subset with one two now after this one two we still have two possibility whether to include this two or not to include two so let's say that we do we decide to include two so then we still have one more subset like this so we also consider that after this one we are doing the doing our backtracking by removing the last element added uh we do the backtrack we don't need to calculate this one because we already know that it's the same element we go back to one we check all the possibilities with this one so now we are at this position number two so we decide to include two only this is a new subset we added to the answer now after add this two we have the option that whether I'm going do we need to add this value or not to add this value so this value is quite straightforward it's 22 it's a new subset so we haven't calculated that so we can simply add this one now after calculating this once again we go we do a back track now at this backtracking location now our time is to move to the next element and not consider this one but once again while making a decision for this one we check that whether it matches the previous element yes it matches the previous element if it matches the previous element what is the point of considering this for the uh subset so we are not going to do that and that's it this is the whole solution and if you see the coded approach it would make much more sense plus you already know that how does the calculating subsets work because we already saw that in the past that uh the whole explanation and the whole nards I just re explained the whole thing and I also explained that why we are adding this tiny logic to our already beautiful solution now let's quickly see the coding approach so very first thing we are doing is creating a new array list where we are going to be storing the results then we are simply sorting the given input array and then we are calling our backtrack recursive helper method where we are passing in the new result where we are going to be storing the array list of lists and we are passing in the new instance of the array list to store the current list that we iterating over then we are going to be passing in the in given input nums and we are also going to be passing in the starting index where we are looking at so initially we are starting from the index zero so we are just going to pass in zero now let's see our helper recursive method first thing we are doing is whatever value we have in the current list we are adding it into the answer so during the very first call we are adding just an empty list into the answer as well next we are iterating we are running a for loop from the start to the end of the given array plus we are just checking for a very simple condition that if the given input I is greater than start and the current element is equal to the previous element if this is the case we simply continue if that this is not the case then we simply add the value to the to our current array list then once again we call our recursive function after the call comes back from the recursive function we remove the very last element added inside the the current array list and then we repeat the same process until we are done with the entire for Loop and this should populate our results completely so now let's try to run this code seems like our solution is working as expected let's submit this code and our code runs beautifully faster than all the other Solutions and also best in terms of space complexity so once again the solution is present at our GitHub repository so feel free to go ahead and check it out uh till then thank [Music] you now we are going to be doing an awesome lead quod problem that is called combination sum two this is the subsequent question to to our original combination sum problem with some slight tweaks now we can see that this one is a code medium problem but in my opinion this can be categorized as hard problem sometimes as well because combination sum in itself is slightly tricky to understand and we can see that this one is a very very very popular lead code problem also being asked at tons of companies basically we are given a collection of numbers called candidates and we are given a target number now we need to find all the unique combinations in the given input array such that the sum of those values is equivalent to the Target value there can be more than one results so we need to consider all of them now we are told that each number in candidates may only be used once in the combination and we need to make sure that the given solution set must not contain any duplicate combinations okay so now let's first try to understand this with an example we are given this candidate array and we are given the target value to be five now next thing is that we need to generate the unique sets now let's see that what are all the combinations that can generate this value five we can see that we have value four and we have value one so four and one is a combination that can sum up two value number five so that this can be one of the potential answers next one is we have value 2 1 and two so once again we can generate value like this and this can also be an answer next value is that we can do 322 this is also one of the subset that can generate the answer but now there is one trick one problem over here we also have this three that we can utilize with this two to once again generate the target value five the thing is that value is also going to be 32 which we have already entered in our result so we should not be reusing the same set in our results because we need to make sure that this answer becomes unique so if we by considering these elements we can only generate these three values or these three sets that combination to the total value five so we need to understand that this is how we need to solve the problem so now let's try to see that what could be the potential solution over here now the logically the very first thing that it would make sensus for us to do is that instead of treating all of these weird values side by side randomly it would make much more sense to number one sort the given input area why am I suggesting to sort ing the given input array that has two reasons number one reason is that let's say that we have some values like let's say 10 and 15 and then so on and so for like 100 other values okay and we are given the target value to be five so the moment we reach to a value 10 then why do we even have to check possibility for all of these 100 values if we have already sorted the results we know that all the values sum is always going to be greater than five which means it is going to be shortening the reach we will have to search for that is a good benefit second benefit is that it will allow us to handle the duplicates in a more elegant manner so what I'm suggesting is that let's say that in this case we have the values 1 2 2 3 and four this is the input we are given now what we are doing is that logically it's very simple we are just simply making decisions and what is the decision we are making we are iterating over the very first element okay so let's say that we are currently passing through value number one we know that the the target has to be five but our current sum that we have made so far is just value number one so we will need to add some some more subsequent values so let's say we decide to add value number two down this current path so now the sum is three still less than five so once again we decide to add value number two so after adding this value our sum becomes five so the moment our sum becomes five whatever the values we were currently having as part of our path this is one of the potential answers so let's mark this as part of the answer okay that we currently have have found one of the combination 1 to2 as part of the answer after doing this there is still more possibility that we could have some other value that we might have missed on so we will have to backtrack and once again see for other possible answers so let's say that we do a backtrack at this position number two and once again um this now the now the problem comes because this next element is already two and we just did a backtrack but thing is we already considered this two so now we will have to consider value number three okay so let's say if we try to do this one this current sum becomes six so the moment current sum becomes six we know that this is no longer a viable solution which means we will have to do a backtrack because this solution is leading to a value greater than five and once again we will have to repeat the operation for all the other remaining possibilities so we remove value number two so once again now with this value number one there might be some other solution with one and three that we could make so we try to add value number three after this value number three the current value is four after four we add value number four over here so doing this also brings brings our sum greater than five which means we will have to do a backtrack we do a backtrack and we get rid of this value number three now at this value number one we still have possibility to check for Value number four there is still one more decision we haven't made so let's see we do this one the sum of this is actually which means we found another set that corresponds to our correct result and our correct Instinct so we are going to mark this as part of the answer as well now once again we know that we took care of all the things we could using this value number one so now we are simply going to go to the next element and not even consider one because we ran through all the possibilities we could with value number one so we don't have to worry about it now at this value number two let's say let me just clean this up a bit now we are making a new decision tree a new decision path where we have two once again we go to the next element that is once again two after doing this we go to the next element that is three so now this sum in total becomes seven so seven is greater than 5 if 7 is greater than five going down this path two does not make sense so we are going to ignore that ignoring this we now we are going to be going with three so we have we are at this juncture and we found that current sum is five which means this is one more potential answer that we will have to record so let's mark this one okay marking this we are not done yet because we will still we may still find another results we don't know so we go to this next element 2 to 4 but this also leads to result number six which means we calculated all the possibility at this current two as being the very first element where we are calculating now the thing is next element is also value number two and we can see that with previous element two we already calculated all the possibilities so if we had a Target value let's say in instead of over the over here instead of five if we had a Target value four we would have a potential value 2 two that is being generated by this two already so we don't have to do anything over here and also if we try to go down this path let's say that we ignore my advice for now and we say that current we took care of this one we took care of this two this two is still valid and legitimate so now we have this value number two once again we go down to the path so we find Value number three as the next potential match and this matches so should I add it to the answer no why should I add it because I already calculated this one so what I'm suggesting is that once we have the sorted list we simply check that for any particular element that we are trying to iterate over in the recursive manner using our backtrack function and recursive function we first check that whether if it is the same element as the previous element if that is the case we already already calculated all the possibilities and added to our answer so we can simply ignore that so now we we are going to be ignoring this three as well now we are left with this element number three so let's try to make possibilities with this three and we are just going in one direction we are not going in the opposite direction because we calculated all the possibilities so with this three the only possibility we have is to add value number four the sum is going to be seven so greater than four which means this leads to no result so we already calculated all the possibility as three as well now next is the only element four once again if we calculate the possibility uh there is only going to be just element number four which is not five so we cannot put it into the answer after this we are done with all the elements in our input and this is the answer we need to return so now let's do a quick recap what we did we calculated that what was the backtracking function and we also calculated that what is going to be a recursive approach for recursive approach we need to add items we need a base case and we need a recursive call or recursive function we know that what is going to be our backtracking logic that at every possibility the moment we either reach to uh the target value is equal to five or Target being greater than five in either case we are e if it is five we are going to be adding it to the answer if it is greater than five then we are going to be going to the very previous element that we were iterating over and remove that from our current list and follow along with the remaining possibilities that is option number one for our recursive the logic is quite straightforward base case is going to be that uh the total Su of the current elements that we are retting over it's either five or greater than five if that is if it is equal to five we add it to the answer if it is greater than five then we can simply just move forward or jump to the next element uh and for the cursive function we are simply going to go in a normal uh normal fashion by adding the current value and removing the current value from the given input array and just uh calling making a recursive call by adding a new value that is next inside our given array so if we see the coding solution it would make much more sense and this is in my opinion a very beautiful solution so I hope you understood what I was trying to explain now let's quickly see the coding solution for this one so here is the coding solution first of all we are generating our result where we are going to be storing the list of array list then we are sorting the given candidates array plus we are have we are going to have our backtrack recursive method where we are going to be back doing backtracking and also making recursive calls so now let's understand our backtrack method so first we are passing in the result list that we just created we are also maintaining a current list we are also maintaining the candidates array that we are iterating over on on top of it we are we have provided our Target and we have provided our start values okay first very first thing we are doing is checking that if the given Target is equal to zero then we are going to be adding the current list uh inside our result and we are simply going to do a return uh from our current recursive call if that is not the case we will run our for Loop where we are simply going to iterate over all the values that are currently present inside the candidate very first thing we are doing is skipping the duplicates so we are checking that if the current candidate is same as the previous candidate we can simply ignore that value next we are also doing an early uh termination if the sum becomes negative because at every given moment the moment we see a new I value we subtract that I value from the given current Target element and uh the moment we realize that this is going in into the negative we are simply doing a break operation now if that is not the case we add the current value to our current array list that we are maintaining then we once again make a recursive call with the current value which contains one more value right now and we provide the target minus candidate I because we are subtracting the value from the Target that we need to achieve and we update it with the next element inside our for Loop and that's it now once we get a result back from our backtrack we simply remove the very last element and we once again do uh the same operation for other possibilities that we are yet to calculate so this should this approach should work now let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs pretty fast compared to a lot of other Solutions which is pretty good so once again I would be posting this solution in our GitHub repository so you can go and check it out from there thank you Hello friends we are still not employed by a Fang company so let's not stop lead coding till we get there today we are going to do word search lead code problem and if we see the number of companies where I want to work at who have already asked this question there are companies like Amazon Twitter Microsoft Uber Bloomberg Facebook Tik Tok Snapchat Google Apple Samsung Roblox Goldman sex bite dance and eBay so these are really popular companies and this problem is really popular because it has very real life applications we have all played games like crosswords and verle on our phones and on the newspapers and different kinds of stuff so that is where this problem is associated with and we are going to see that how to solve this one so that's why I'm paying my atmost attention I hope you also enjoy the video so this is a lead code medium problem and basically we are given an M cross and grid of characters called board and and we are also given a string called word now we need to see that if this word can be created based on whatever the number of characters we are given on this board and if it does we need to return true else we need to return false also we are given a note that the word can be constructed from letters sequentially adjacent cells where adjacent cells are either horizontally or vertically neighboring and we are also told that same letter cell may not be used more than once in order to create that word so let's try to understand this this with an example over here we are given this big board and on this big board we are told that we need to find the word a b c c e d so if we see over here on these marked values so this starts with the word a the neighboring word is b the neighboring word is C again we are told that we can horizontally or vertically see the words so uh if we go vertically downwards we see another C and then we find another e and at the end we find D which is also adjacent to e which is this letter and this is basically part of this given board so in this case we can return true now suppose if this word we we if we were not able to construct this word we would not return true and we would return false so let's see that what would be the optimal approach to solve this problem well we have actually solved similar problems like this in the past using DFS and backtracking and this is what we are going to do for this problem as well let me quickly show you how Okay so suppose this is the custom example we are given and we need to find the word spider to see that whether it exist on this given board or not and the idea is actually quite simple what we are going to do is first of all we are going to take the first uh character inside this word which is s and we are going to iterate over this Matrix until we find this first character the moment we find the first character from whatever the places then we will keep on trying to find the next letter uh the next words inside this word h to see if it exist in the neighboring node or the neighboring cell of the board inside this given Matrix and if somehow we are able to reach to the end of this word we can we can return true if we don't reach the end of the word and we actually reach the end of The Matrix we can return false so the idea is actually quite simple and there are just few tweaks we will have to use in between so first we'll start iterating over this uh Matrix trying to find this word number s now uh this is not s this is not s over here we find the first value as s so because this is the first value as s now we will have to try to see that whether this P exist or not in the neighboring node of this s we can clearly see that P exist uh so but before doing that what we are going to do is we are actually going to mark this node as visited so one way to do is is to use some visited hash set and store all the values but that is just causing strain on and to have an extra memory usage rather than doing that we are going to actually modify this input and we are going to mark it something like hash or something which is an invalid value and it can never be there so which means at any point we encounter that this value is Hash we don't need to go back to that place now we will start iterating over the neighbors of this s so neighbors of s can be these three three places if we try to look at these three places and we are looking for the alphabet P so p is present over here which means that so far we have found S and P now we will update our value to I and we will try to look for I in this P's neighbor also we will go we will mark this node p as like hash so we don't come back to this place again now this P has only two neighbors because this neighbor s has already been visited because its value is Hash so we can't do anything about it now we are looking for this letter I and we find the letter I over here which means again we mark this as hash we will update the value of word we are looking for the word we are looking for now is D we'll try to find the neighbors of I uh and in the neighbors of I okay we don't find anything over here this is not D and this has already been visited which is Hash which means that there is no neighbor of I that contains this value D which means that now we are we are we haven't found the word so far and we still have Matrix to go to that we haven't visited so far which means that now we we will backtrack from this I to the position we were originally at which means that from this I we came from P from this to this P we actually came from s and now we can say that okay even in this s it does not lead to lead to us to find this word and then we will again process proceed with our search so again we will we are trying to find this letter s again and not the D because we did not find anything in the route which means that now okay this p is not s this I is not s this T is not s so we are good so far now at this position we find the uh letter s which means that okay this s has been found now in the neighbor of this particular cell we will have to find the the letter P and we are going to mark this S as hash as to as a way to identify that this has been visited now we are what are the neighbors of s these four are neighbors of s s and the one value we can find where the P exist is this one so again we will repeat the same process we will mark this as hash we will try to find the word I I we will find over here so again we will mark this as a hash and we will try to find D in the neighbor of this I so we find D over here so again we will mark this as hash we will go update the word we are looking for now we will try to search for E inside this these uh Neighbors and uh we can find it over here again mark this and then try to find this R so R we actually find in the neighbor of this one and this is the correct R which means that now we are able to reach to the end of this word list and we can return true in this case saying that okay this actually exist inside this given board and uh we will be good so this solution works perfectly fine let's see the time and space complexity with this one so for the time complexity actually the time comple it is a little bit tricky to find why because the time complexity is actually big go of n which is the number of cells so for every single cell we will have to iterate at least once so n is given but then we will have to repeat the same process for three times to the length of L in the worst case scenario why three times to the length of L because notice that at any single position suppose we were at the at this position number D and we need to see that okay whether the next value e exist or not so we need to check three places not this one because this of this already has the value hash which means we won't check this one but we in Poss in theory we might have to check at all three places and imagine if all three of them had the value e we might have to explore the paths on all three of them in order to find the next value R so that is why at every single position n we actually have three different options to see that whether this word exist or not and this L is actually length of the given word so that is why this is the time complexity in terms of space complexity uh we actually need to store the value inside our space until the time we reach to this entire word so it would be big of L uh where L is the length of the word that is given and this time and space complexity works perfectly fine and uh I hope this solution makes sense to you let me quickly show you that what would be the coding for this one so for this uh word search problem we will actually have to create a backtrack public method that will call itself and recursively we will try to achieve its answer so there are some variables that we will need in both the in this Boolean exist method and also in the new backtrack method that we are trying to create so let me Define some variables uh that are Global and that we can use in both the methods and the variables we are going to create is to store the value of this board and we will also need the row and column size of this given board character array now we have these we will assign values to all these three variables from these given input end points once we have this we will have to iterate over this board uh character array so we are going to assign two for loops and for both the for Loops we are going to have the I and J value iterate up until the point of this rows and columns and inside this um for Loop we will call our backtrack method now inside this uh for Loop we are going to call our backtrack method and we are going to have backtrack method return a Boolean rly uh either true or false and uh inside the backtrack method we are actually going to pass in the values of the current row position current column position word we are trying to find and the index value we are currently at so for the index value we would initially start with the position zero and we would increment it every single time inside our backtrack method and if at any case this returns true we can simply return true in this case and somehow if we are able to complete this Loop and get out of it without returning true which means word does not exist so we can return false once this is done now we will create our public Boolean method called backtrack now first of all we will check that what is the condition where we will need to return true so if at any point we identify that the index value is actually greater than or equal to word length which means that we have already found that uh the current word already exist inside our given character array so we can return true in this case so now we will try to find the terminating conditions and inside the terminating conditions first of all we will check that whether the row and column position are they going out of bounds or not if they are going out of bounds we can return false immediately if that is not the case we will try to see that the current value we are looking at inside our board if that Bo that value is not in sync with whatever the index value of the word we are looking for if that is not the case we can also return false immediately so if any of this these conditions are true we can return false immediately none of these conditions are true which means that the current index value actually matches the value of that row and column position inside the board and now we will have to iterate over the neighbors of this current uh row and column value inside the board so in order to iterate over the values of the row and column we are actually going to have two uh arrays called row Direction and column Direction and that will help us navigate all the neighbors of any particular cell also before moving to the next element we are going to Mark the current row and column position to have a value called hash so we avoid checking the same element twice okay once this is done uh we will also have an A Boolean variable called uh return and uh initially we are going to initialize its value to false because basically we are going to call the backtrack function uh for all the four neighbors of the current cell so for that we will keep track of this R uh Rat variable and we are going to run a loop to iterate over all the directions and we will add the values of these row Direction and column direction to subsequent row and column positions inside this recursive call to our backtrack function we will also update the value of the index because we can determine that we have already find the word inside the previous index and that's why we are calling the next index where value to be searched inside the neighbors of Any Given row and column position and also at any point if we identify that the answer of this return function is actually or this return variable is actually true we can break out of that particular element immediately and we don't have to check all the other neighbors so we will put that condition as well once that is done uh basically we are done with the check in part now the only thing we need to do is we will have to uh update the value of the row and column position to whatever the value that was originally there and in the end we can simply return whatever the answer we got for this R function this is pretty much it for both our backtrack method and also our main method and this should be able to solve our problem let's try to run this code okay seems like our solution is working working let's try to submit this code and our solution works as expected and uh I would be posting this in the comment so you can check it out the solution from [Music] there so the lead code problem we are going to solve now is called palindrome partitioning we can see that this one is a medium problem but but in my opinion this should have been a hard problem we can see that this is a very well-like problem now let's understand that what is uh being asked us to do we are given a string s and we need to partition this string s such that that every single substring of that particular partition becomes a palindrome and we need to return all possible palindrome partitionings of s so it sounds a little bit awkward but let's try to understand this with an example first let's understand that suppose we are given a string s such that the values are a b c so we can see that in this case uh if we have to partition string there are bunch of different options we can have a partition that is completely like this or we can do a partition like a b and c or we can do a partition Like A and B C something like this one right there are bunch of different ways for us to partition any given string but thing is in this case we need to find partitions such that every single partition becomes a palr now we all know that what is the definition of a palindrome suppose we are given a value like this AB a in this case this AB a is a complete palindrome why because if we write it from left to right or right to left in both the cases the answer is just going to be a a so same way this uh let's say if this is the input we are given and if we have to partition it in such a manner that every single substring of that partition becomes a palindrome we only have one possibility that possibility is if we partition it used by using just individual characters because an individual character in itself is a palindrome because uh let's say if we only have one value you can read it from left to right or right to left in both the cases we are going to be left with the same value so this is the only answer we need to return return in this case but let's say that we may have been given some other options let's say that our given string s is equal to Value such as a then a and b okay uh let's say our given string s is equal to values a a and b so now in this case uh we we will have two options in order to generate the partition first partition is going to be quite straight forward that is taking on individual characters because they are palindrome and their own and combination of these characters actually form uh in such a manner that every single character is a palindrome in itself but we can make make one more distinction or one more answer in this case where if we create a partition of these two values a a as one partition and we create another partition of this individual character B then also this becomes a valid partition of the substring such that every single portion of the partition actually forms a palindrome because this A a is a palindrome and this B is a palindrome in itself so this is what the problem statement is actually asking us to solve now let's try to understand some Logic on how we can actually solve this problem uh well if we just have to solve it using pen and paper what is going to be the first logic you are going to apply well the very first logic is that we will start iterating over this given string character by character comparing every single character with the previous characters that we have we have been able to find so far to determine that whether using the combination of previous characters are we able to generate palindrome or not not if we are able to generate a palindrome we would mark it as one of the partition and then we will keep on moving forward so let's try to understand the approach I'm suggesting let's say over here we start iterating over at this very first element a now for this very first element a the moment we come to this element a we have two choices one choice is that a in itself could be a palindrome so we Mark a as a palindrome and same way there could be another possibility that we may find some value where this a could be potentially part of some future palindrome that we are yet to discover so let's leave this possibility open for us uh for the moment okay now if we decide to create a partition based on a then once again we have the option to move forward with a single a or the next element so let's say that once again we decide to move in with a single a and create another partition which uh this is the first partition and this is the second partition okay and uh one once again we move to the another value and for this next value we encounter value B so once again we create a partition in its own now the thing is when we reach to this B we realize that now we have reached to the end of our array so far all the values we find inside uh or all the uh partitions we did for our given string s all of these values are palindromes because let's say that in order to determine that whether any particular string is a palindrome or not we are actually going to create a mage method that checks that if the given string is a valid palindrome or not okay and this string is quite straightforward they are the values of itself so we know that all of these values are correct palindromes and we are also storing some current array list where we are keeping track of all the current values that we are iterating over one by one so we realize that this is the correct sequence of partition that generates a palindrome so we are going to mark this option inside as part of of our answer after marking this we we are not done yet because once again I mentioned that there could be some potential ways or some potential other uh paths that we are able to generate which could lead us to more palindromes that we are yet to discover so once again let's try to apply that same logic in this case so now once again we already explored this path okay now what we are going to do is we will do a backtrack operation once again to the very first character to make sure that maybe we did not miss out some palindromes that we could have found so let's say that we instead of just creating a single value partition from this single value we actually decide to do a partition of two values uh so creating a partition of two values would give us value a a once again we check that if is this a valid palindrome or not and yes this is a valid valid palindrome so we are good to continue to the next element for some reason if we identified that this was not a correct palindrome let's say for some reason that this value given is X so then this ax is not a correct palindrome if this is not a correct palindrome then it does not make sense for us to continue down this path of partitioning so then we would uh choose a different path where after this ax we would actually include B in our decision making as well but that is there is no need to do that so let's leave it as it is right now so after leaving it as it is okay so we created another partition at this moment AA the answer is valid legitimate so we are keeping it as it is after keeping this as it is now we decide to go to make another partition that is this value B so once again we create a single partition of just one value B this is also a palindrome and with this B we reach to the end of our list so after reaching to the end of our list we are also going to be marking this uh sequence that we found as part of the answer as well now let's try to clean this up a bit and now once again we will we are yet to explore more possibilities that we haven't found so we will also try to do this one now for the more initially we took down a possibility where we are only partitioning the string based on just one value then we partitioning partitioned the string by using values a a and then also it worked out now we are going to partition the string based on considering all three values so let's say that we just create a partition that is a a and b this become this is definitely not a pent plus we reach to the end of our list so now we are done with our search with a starting all the possibilities from this current value a now we are yet to identified more possible palindromes that we are yet to identify so let's say that in the very first beginning when we made this partition now we will continue down this path but previously we went down this path uh that was this answer over here now we will try to choose a different path and in this different path what we are going to do is with this a now we are going to pass the button onto the next element and now we will say that hey next element if you want to do or try some partitions let's check those so once again from this a we can create another partition like AB but definitely this partition is not a palindrome so if this is not a palindrome then it does not make sense for us to continue down this path and anyways we are running out of elements in this case but let's say if we had some more elements over here let's say some more element like C so do you think it would make sense for us to create a partition such that a b and next element to C check like this no because we already know that this is not a sub palindromic sub uh substring so why even bother checking so then in that case our logical step would be to include c as part of one of the possibilities as well but once again this is also not palindrome so now we can be done with this so this is the simplest approach we can take to solve this problem now we all know that what we did we use the backtracking option to basically uh go through go through all the possibilities that we can in order to generate or find sufficient answer now let's try to understand that what has to be the logic of our backtracking function this is going to be a simple function that uh takes the current partition that we are dealing with and based on the partition from the input string it is is going to have a starting index for the next partition that we are going to check with and with the starting index of the next value we should be able to understand that are we at the end of our uh string or not and whether we can conclude the current partition to be over or not on top of it with every single value we are going to check for any particular uh substring that we are generating that whether that is a palindrome or not and in order to do that in order to accomplish all of this we will actually use recursion now for recursion we know that we have two items that we need first one is a base case and second one is a recursive function base case is quite straightforward that if we I previously mentioned that we are going to have a variable called start to keep track of the next index that would be the starting point of the next sequence of palindromes let's say that we created a subsequence like this a a as one of the palindrome then start index would be living over here with value number two as that is The Logical starting position so we are going to check that if for the current list we come to a place where the starting index is the length of the given string then we are going to be marking that current index as part of the answer and returning or coming back through our recursion so we identified our base case for the recursive function we will have to do two things first thing is that for every single new Partition we make we will have to check that whether this is this one is a a valid palindrome or not if let's say that that is a valid valid palindrome then it would make sense for us to uh call the recursive function once again with the next value in line and creating the current partition as it is now I know it sounds confusing but if you just understand that or try to walk over the solution that I presented then it would make absolutely beautiful sense to you that what I'm suggesting and on top of it uh for the recursive function we are also going to be updating the current index value that we are iterating over let's say that we iterated over AA so then we will have a recursive function starting with value number B and once again we will try to repeat the same process combination of all of this should give us the answer but thing is this is not just enough once we receive a call back and we will have to check for other possibilities where first we check for the possibility of a only then we may have to check for the possibility of a a so in order to do that we will have to do backtrack and for the backtrack the simplest thing is to remove the very last element we added inside our current array uh or current ARR list and once again repeat the same operation so basically combination of backtracking and recursion is the way to move forward in this case now let's try to calculate the time and space complexity well time complexity is difficult and tricky to calculate in this case because we don't know that how many number of potential partitions we can make so at the end of the day the this is simply a decision making algorithm and in the decision- making algorithm at every given step let's say that we created a partition like this a now we will have to check whether to include this a or not to include this a as part of the partition so at every given step we are checking for or to whether to make that decision or not to make that decision so basically we have 2 to the power of n possibilities where n is the number of characters given and for every single character we will have to repeat the same operation so it's going to be n multiplied 2 the^ of n possibility and that's why this is a very expensive operation and if you go through the lead Cod problem we are all we are only given like up to from 1 to 16 as part of the range of n uh for the length of the string because they also realize that they don't want to put much load on the lead code servers so now let's try to quickly see the coding solution for this one okay so the very first thing we are doing is that we are generating a new result array list that is going to store different array list inside it uh to store our answers then we are going to have our backtrack method where we are passing in first of all the result array list we created then we are also passing in the current list we are iterating over passing in the given string that we are given as the input and we are passing in the starting value of the next pointer that we should uh consider for the partitioning this is the starting pointer that I just mentioned okay okay now first of all let's see in our recursive function we are going to our base case where we are first checking that if the starting value is the length of the given string which means we are actually reached to the end of the string so we can add the current result we are iterating over inside our result array list and we can simply do a return call from the iterative stack and now let's che check our recursive case or recursive function so for that we are in we are basically iterating over from the starting index till the end of this list and we are updating the value and here I mentioned starting and ending pointer this is just simply so that we can check that the given palindrome or the given sequence of element uh partition we are retting over if that is a substring or not we can simply make that call so first thing we are going to check is that if the given current substring is it a palindrome or not for that we have created a palindrome method where we are doing nothing but we are simply iterating over from both hands like starting pointer and ending pointer if at any given moment we identify that they both there is a mismatch we simply return false if that is not the case and we complete the whole uh iteration then we can simply return true saying that this current substring is a palindrome okay after determining that the current set of partition is a palindrome we are going to add that substring to our current list that we are maintaining and once again we are going to recursively make call by with the same values except the next index position that we will have to iterate over and that is going to be our end + one you can also Define this end instead of n to be I as well I just put in end for it so that it becomes better readable for our is palindrome method and once we get a result back from our backtrack method we are simply eliminating the last value we inserted inside our current list because we still have to explore more possibilities and this is our backtrack function basically so now let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs pretty fast compared to 98% of all the other Solutions which is exceptionally good once again the solution on of this code is present presented on our GitHub repository so you can go and check it out from there thank you hello friends hope you are having a fantastic day today so in this video we are going to do a very popular lead code problem that is going to be pretty nostalgic for a lot of people so without any delay let's get started the title of this problem is called letter combination of a phone number and now many of the the iPhone users won't know it but in the past phone actually did use to look like this where if you have to type any messages you will need to do it according to the keys that are present over here with the corresponding numbers and people were so good that they were able to do it without even looking at it but anyways now coming back to the question this is a lead code medium problem and also an extremely well-like problem on lead code also has been asked at tons of popular companies so let's see that what does the problem statement ask us to do uh basically we are given a string containing digits from 2 to 9 because notice that in this problem we are only given the characters uh from A to Z present between the letters 2 to 9 now inclusive now we need to return all the possible Char letter combinations uh based on the given digit numbers and that that it can be represented uh for our convenience we can return them in any order so let's try to understand this with couple of examples suppose we are given as an input just character number four so how many characters does this character number four can represent well only three characters uh so if we have to return return this the answer is going to be g h and I as the answer that we need to return return but let's assume that instead of that we are given the input as like four and six then what should be the answer so we know that four can represent g h and I and six can represent m n and O so the answer is going to be the combination of both of this ghi and M so the answer would look something like where you can see that currently we have nine entries and they are combination of all the characters from these two entities and that's what we need to return return so this is the whole problem statement so let's try to see that what is the approach we can take to solve this problem now number one thing is that currently we are only given that we are only given characters between 2 to 9 as an input and nothing else so first thing we need to do is that we will have to create a mapping so that based on any given input location we can actually identify that if the character 2 is given we know that it can only have the possibility of storing ABC same way if character number nine is given then it only has the possibility to store four characters W X Y and Z and same way we can store this in any such fashion so that just look up needs to happen in bigo of one time so we actually have two options to do that number one option is that we can actually create a hashmap and inside the hashmap we can store all the entities and based on the key we can Mark as the digits and their subsequent values we can we can mark all of the entries so that is option number one this will yield in big off one time complexity whenever we have to do the lookup second option is since we know for sure that we are only dealing with characters between 2 to 9 nothing more we can also create an array and inside the array based on the index positions we can store the values so let's assume that because in the array we have values like 0 1 and then two and all or so on and so forth so for 0 and one we can store as an empty strings because anyways they are not going to be part of our inputs and starting from position number two we can start storing values as a b c and stuff like that now this is only for our convenience purposes so that we can quickly look up what element we are trying to find now this is the pre-work that needs to be done in the solution so that we can do it in the efficient manner now let's see that what is going to be the optimal approach to solve this problem suppose as an input we are given the characters 2 and three that we need to return return now we know that two is represented by ABC and three has been represented by DF that we actually take this given input 2 and 3 then we break this input based on all the digits it it currently has so first we get the digit two for digit two whatever the characters that it can represent we create three decision trees based on that so currently it can represent a b and c so we create three separate decisions tree and now since this is not the answer because we need to return the combination or the potential combinations that can be there so this is just a part of the answer that we have created so far but now we will have to complete the comp combination portion so in order to do that the number one thing we will need to do is to keep track that how many number of characters are currently present or how many number of digits are present and how many are pending so now three is pending so we will append three with each of these decision trees and we know that three is currently represented by these three values so once again for each one of them we are going to have three separate decisions tree being made notice that currently at the this very first location to we only had one entry per character inside uh our representation but the thing is in the input we were given 2 three 23 which means we were dealing with two character letter but in the uh in the problem we are so far we are only at half of the step where we only have just two which means after creating this possibility we still have to wait to add the values to the answer until we find this part where now the index position matches the total number of inputs that we are given the moment this condition matches we will need to add it to our answer list so because over here we only had one characters but now we had two characters and even in the input we were dealing with two characters we are going to add D A or a D in the answer same way a e is going to be part of the answer same way AF is going to be part of the answer and the good thing about this is because this the same operation being done multiple times so we can actually keep on doing this the moment we find out that this is one of the potential pair that we have already added to our answer we can actually backtrack to see if a still has any more values that it needs to add to the answer and yes AE still needs to be added so we will add AE once again we will backtrack to a and once again this AF needs to be added so we will do that once again we would backtrack to two now we have completed all the path with a so we will repeat the same process with b and this is the whole answer we need to return return now I know what I just explained might have confused you a bit so that's why I'll when we do go into the coding section I will explain the whole thing in much more clarity but this is the whole approach basically we are simply using recursion and backtracking to solve this problem because repeatedly we are doing the same operation and we know that for uh this we need to have an terminating case so terminating case would be that the moment we identify that one path or one combination contains the same number of characters as the number of input that is given or the index values then we need to add it to the answer and once again do the backtrack keep on repeating the same process until we have exhausted all the sub possibility and uh whatever the answer we found we need to return that okay what would what is going to be the time and space complexity in this case the time complexity is only going to be the number of potential combinations that can be made which means the number of uh characters that are given so let's assume that this currently has 3 * 3 six characters so whatever the value is so we need to do square of the number of given input for every single digit so in total it is going to be the number of combinations that are currently present that is going to be the time complexity for the space complexity because we will have to create an another array uh that contains all the mapping from the characters 2 to 9 we will have to store that but that is going to be limited scope so instead of calling this as big of n we can actually treat it as big of one because the space is space complexity is not going to change so now let's see the coding solution okay so first of all we are going to initialize our string array where we are going to mark first couple of entries as blank and then we are going to mark all the values so this is going to allow us to iterate over all the digits to the letters and then let's start our code actually for the problem statement for this method letter combination where we need to return return a list of strings as the answer so first we are going to initialize a combination string that we are going to return as the answer and this is going to be the blank array list so far now first we are going to check for an edge case that if the given number of digits is equal to null or digit do length is equal to zero then we need simply need to return combinations if that is not the case we are going to call our backtrack method and we are number one thing we are passing this uh list that we have created we are also passing the input digits that we we have received we are passing an empty string that is going to be considered as the current combination that we have so far and we are passing in zero as the current index values that we have processed so far okay now let's see this backtrack method how does it work so number one thing we are checking is that if this given current index location if that is equal to the digit length which means we have a an answer that we need to add to our current combination so we are going to add all the answer that we have found in the current combination to our combinations uh array list that we have created if that is not the case we are first of all going to differentiate the letters for every single index position so let's say in the input we are given value number two then we would have ABC as the uh letters passed on and then we are going to run a for Loop across every single letter but now this time we are recursively going to call back the method backtrack we are passing in the same combination same digits but for the current combination we have added the current combination plus the current letter we are working on on top of it we have also updated the number of increase value or index value so if in the previous iteration if we would have passed in value number two in the next iteration we would have passed in value number three and that's how we will be able to start storing all the combinations in the current combination uh string that we have created and this is is it so let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs pretty efficiently compared to a lot of other Solutions which is Awesome by by the way you can always find this coding solution in the GitHub repository we have and the link is in the description so you can check it out from there thank you [Music] okay so now we will attempt to do a very scary question that is called n queens now in my opinion this is one of the most toughest and most interesting problem I have seen uh basically this one is a lead code hard problem and very justifiably uh it is also an extremely well-like problem and let's understand the statement the n Queen puzzle is a problem of placing n Queens on an N cross N Chess board so if if we are given let's say 4x4 chess board we will have to place four different queens now we know that every single queen can iterate in three directions let's say that if I decide to place a queen over here then this queen can control these squares these squares and these squares because Queens uh iterate in all three directions So based on considering a formation such that that I am able to place four different queens and without these Queens intersecting with each other on a given n cross n board and I will have to make sure that I populate all the N queens now let's see that what else is being asked for this problem statement that uh we are being told that we are given an integer n that defines that what is going to be the size of the board we are dealing with now we need to return all the distinct solutions to the N Queen's puzzles and good thing for us that we can return the answer in any order now there is also one more um just a quick note that each solution contains a distinct board configuration on a place where the Queens can be placed let's say that if I decide to place a queen over here then next Queen might be placed somewhere over here because I need to avoid uh hits by this queen so there can be one of one solution or two solutions or three solutions no matter how many solutions are there where I can place all Four Queens on this four Cross Four board I will have to put all of those Solutions inside the answer next thing is uh we are being told that where we are placing the Queen We Will mark it as cube and where we are not placing a queen we will just mark it with a DOT so let's first try to understand this problem with this given example of a four Cross Four board the idea is we are trying to place four different Queens on this board and we will have to explore all the possibilities we could in order to generate the answer now this is going to be a very long video so I'm just warning you beforehand I don't want to take any shortcuts and I want to make sure that I understand this problem and you understand this problem so now let's get started uh basically let's start one by one let's say that I put the first queen nely on this very first location if I do that which means essentially I'm eliminating all of these squares for any other Queen to pursue or and use it as for their configuration let's say I do I put this queen now in order to put the second Queen I have two options so let's say randomly I just pick this option okay so once again after picking this option also these squares are now being controlled by this queen uh next thing is if I want to put another queen there is no place for me to put the third Queen because this entire row has been covered because I put this queen over here so let's try to revert that let me try to put this queen somewhere else okay so let's say if I don't put this queen over here then uh all of these squares would become empty and once again let me just try to put this queen on the second position and then try to see so let's say if I put this queen over here once again these squares gets controlled by this given Queen and now I only have one option in order to put the third Queen so I can put third Queen over here but that controls this option which means once again I cannot put Four Queens over here so once again I will have to go back and go back I exhausted all the possibilities for the second row which means I still have to ex uh exhaust more possibilities at the first row by changing the position of this queen so let's try to do that operation for that I will have to clear the board and basically do a backtrack operation let's do that and now I'm trying to place Queen over here now which are the squares being controlled let me just quickly Mark each one of these to make sure that I don't uh create any confusions now for the second row I only have one possibility where I can place my queen so let me do that and let me also Mark all the items that are being impacted by this queen okay now for the third row I only have one option so let me also Place one Queen over here and once again exhaust all the possibilities and now for the fourth rope I only have one choice where I can place the queen and that is this empty Square so now we can see in this case that we are able to place all Four Queens on a four CR four Cross Four grid so this is one of the potential solution so we will actually have to mark this entire solution and place it inside our answer array so the thing is let's say that we create a list of list that is going to store all the answers uh how we are going to take the snapshot of this is that we are actually going to create an array that is going to represent every single Row for this given entire section and for each of the row we are going to mark it as this that we are going to store string values where for the first two elements we don't have a queen so we are going to mark them by dots and then we do have a queen so we are going to mark it by Queen and then we are once again going to mark Market by dot once again we are going to do the same process so Queen and then dot dot dot once again for the next element repeat the same process so basically Three Dots and then a queen and for the last one we are going to have dot Queen and dot dot so uh dot Queen and dot dot okay and so this becomes one of our answers I think is this is not the whole answer we could still have more potential answers so let's say we explored one possibility let's try to explore another possibility and remember once again we are doing the backt trck operation going back to the very initial call we already exhausted these two possibilities for the position of Queen so let's try to explore more paths let's say if Queen is over here then once again let's repeat the same operation we are going to eliminate all the squares being controlled by this queen the option is to place it over here once again eliminate all the options once again we can place a queen over here and for the last one we can place a queen on this position so once again this becomes another one of distinct answer because notice the positioning of Queens are different compared to our previous answer so once again we are going to note this entire answer now don't worry I will not put you through the painful process of going through the whole thing let's say that I just paste this answer over here uh as part of the next array list inside our answer where we are going to return the list of array list okay and now let's say we we try to explore the very last option for the Queens once again for the very last option we are going to be placing the queen over here if we try to do this one basically this solution would not work because uh we would not be able to find appropriate Queen positions in order to fill it out so notice that in this case once again we filled out all these four possibilities because we placed a queen over here if we don't do that if we decide to place a queen over here then once again we are eventually going to fill out all of these possibilities so these are the only two distinct ways through which we can place all Four Queens on this four across four grid and this is what we will have to return as part of the answer so this is what is being asked us to solve now the thing is uh let's see how we can actually solve this problem so notice at the very beginning when I selected a queen over here immediately I did not started rejecting this option basically what we can do is that at every single position we have two options to make that whether we can place a queen over there or we can not place a queen over there now we will have to explore both the possibilities and in this case we will proceed in column by column area so we will try to put the queen on the First Column based on that we will it will determine the position of the second column and then third column and then fourth column so initially the idea is going to be that for the very first column on the leftmost portion or the very first value we will try to Place Queen and let's say that after placing this queen our logic would be that we will have to find an empty space in this particular section where the squares are not being hampered by this queen we can completely ignore this entire column the moment we Place Queen at one of the position so our jumping is going to be based on column by column level and at every single column for all the N values we will we have to determine that whether it is a a sufficient place to place a queen and the moment we find the very first opportunistic moment where we can actually place the queen once again we are going to repeat the same operation for the next subsequent column and once again we will try to find an appropriate cell where we can actually place the queen so there would there could be two options one option is that let's say that we are able to identify some place where uh in if we just take a look at this example basically in this example if I place a queen over here we we exhaust all the possibilities now there are no place for us to place a queen which means immediately it should come to our brain and also in our program that placing Queen over here is not a good idea that is option number one option number two is that placing Queen over here is not a good idea so we are going to do the backtrack operation and after backtracking we will first try to remediate our this this uh uh mistake and we would instead of placing Queen We would place at the second possible place and once again try to repeat the same operation but eventually this will also not yield as a correct result and eventually we would keep on backtracking to our very first decision and through the very first decision we would try to make sure that okay instead of placing the queen over here let's try to explore other possibility and then this would lead us to our correct result so that is number one thing on we can understand that how we are actually able to find the answer the logic is quite straightforward we are simply going to do a recursive backtracking call in order to determine that whether the given path is a correct sensible path or not but this is not as simple as it sound because there are lot of computation and lot of things we will have to understand and break down for our program to that how it it is going to work so let's quickly understand first that what is the what is going to the recursion we need to do in this case to complete the problem well we know that for recursion we need two items number one item is that a base case and second item is that we need uh a appropriate recursive function base case in this case is quite straightforward the moment on the c4th uh column we find an appropriate location for the queen we know that we already crossed all of these uh columns and then we reach to the column four where we are able to find an empty slot for a queen to be put in so which means this has to be the complete correct path that we are able to generate in order to fill the answer and that that is exactly what we are going to be storing as part of our base case so what we will do is number one we will need some way to keep track of all the path that we have taken so far because uh by doing that we are doing two things number one thing is that when we do reach to that happy path scenario for our base case we can actually add the path that we have stored for so long for the positions of queen as part of the one of the values for the answer so that is number one thing number two thing is that using this path let's say at some moment we decide that we cannot go further anyway then once again we can just say that this path does not Le yield to the correct result if it does not yield to the correct result we can simply do a backtrack operation and through the backtrack operation we will try to explore other paths so just same way we saw over here that this Q location was not working out so we tried to see for this Q location once again that didn't work out so once again we updated from our Q location this one to this one and then we we Tred to identify that whether this is the correct path or not so we made some judgment calls through our recursive function on what are the things we are trying to achieve basically don't get confused we are just doing exactly the same thing that that I showed you on the through the throughout the entire graph the only difference is we are trying to do it recursively and we are trying to follow both the things that what is going to be the base case where we need to break out of the recursion and store the value to the answer if we are not able to do that then we will also have to do the recursion using the correct path we current path we are choosing in order to solve the problem now there are also few more things that we will have to understand first thing is that at every given moment whenever we are checking for potential candidates we will have to understand that whether this path we are taking if that is the correct path or not because let's say that in this case I place a queen over here which means I am eliminating these elements that can ever be used for the potential Queen so now when I am at the column two I once again going to check all of these positions one by one and in order to check that whether they are good candidates or bad candidates for my queen to be placed over here I will need some method to basically do a validation that whether I can place my queen on this square or not and the only way I can check is that that is to check my current path that I have currently iterated over and see that this particular cell has it been impacted by any of the queens that are that I have previously placed and by doing that uh we can actually make sure and find the potentially good values for our Queen so let's say that we identified potentially good values for our Queen so we did this operation for this First Column then once again we repeated the same operation for this next column once again we are going to repeat the same operation for this third column so logically we are just redoing the same thing that we have done in the past but for the different input and that's where the second requirement for our recursion comes into the place because remember recursion needs two items first one is a base case and second one is a recursive function so as part of the recursive function whenever we are moving to the new column we are simply updating the value of the column plus we are also updating the value of where we have stored the queen in the previous value inside our current path so this will allow us to do the backt track and also allow us to move to the next value inside The Logical iteration of our recursion on top of it that's why this is a hard problem because there are lot of on top of it that you will have to understand at every given moment once we reach to the very end in the current path we are not keeping track of all the items of the board we are just simply keeping track of the position of Queen uh that we have uh placed so far in each of the columns so once again we will have to have a method where we are actually generating the board based on the positioning of the queen so remember that ugly board that we were seeing like that contains dot Q dot dot then once again like dot dot uh do q and this type of like more score type of structure we will also need a method to generate this as well and this is the solution basically this is the optimal solution in order to solve this problem we are using backtracking we are using recursion for recursion we have a base case we have a recursive function we are keeping track of the current path we are at we need to have a method to check that whether the given path path is valid or not uh to place the queen based on the previous Queens we have placed plus we will need a method to generate the board that we need to generate in order to solve the problem and in the end we need to store everything in an answer where in the answer we are actually storing the bunch of different arrays as part of the AR array so it's going to be a an array list that contains multiple array list and if we see if we try to calculate time and space complexity in this case well it's really difficult to calculate the time complexity but let's try to understand the time complexity logic in this case if you can uh understand this then your logic to solve time complexity is going to be pretty beautiful logic is quite straightforward that for every single column we are iterating over all of these values and we are doing it for each of the columns which means basically we are in the worst case scenario we are iterating over each each one of the elements so basically uh and the number of elements we know are n to the^ two and at every single element we have two choices to make whether to include that element or not to include that element which means we are actually doing 2 to the power of n multiplied n or 2 to the power of n Square work uh for this one and we will have to repeat the same operation for each of the columns because remember that in column one there are four possibilities that can lead us to different paths which means we will have to calculate this for each one of them so we will also have to do this operation end times so time complexity is horrendously bad and that's why if you read the problem statement on lead code we are only being told that the value of n can only be between 1 and 9 nothing more than that we are dealing with a very small number of finite Solutions because if you try to do this with million values we need quantum computers in order to solve this problem okay now let's quickly see the coding solution and I hope my solution made sense to you okay so the very first thing we are doing is that we are we only have value n that we need to return so first of all we are creating a blank board uh of n cross n size and we are marking all the values as initially as dots because we don't have any Queens placed at the moment we are also initializing a new array list of list called result where we are going going to be storing all the result and then we are going to be calling our backtrack method this backtrack method is going to do the backtracking and also recursive function for us in the input we are providing the new board that we just created plus the starting index of the very first value that we need to iterate over and the result array list that we have just created in order to store all the answers now let's understand our backtrack method so very first thing we are doing is uh this is our base case that if the current length of our column is equal to the length of the board which means we have placed the Queens correctly on all four columns or all n columns so the correct current path or the current version of board is is subse is suitable enough for us to place it into the result but thing is we are not directly placing it into the result we are actually calling a construct method to construct the board we want in the subsequent Manner and first let's just see the construct method okay so in the construct method we are just passing in the board on top of it we are checking that what are all the current positions of the queen that we currently have and we are just adding those values as part of the Q apart from that we are not doing anything else and we are simply returning that to the result okay next thing is uh so let's say we add the appropriate result over here then we have our for Loop which we which allows us to iterate Over All the values inside our given input where we are starting the value from zero we are going until the length of the board and we are just doing i++ very beginning for every single board position we are checking that is it a valid place where I can place my queen and this e valid method is doing nothing but checking that based on the previous paths that we have calculated whether we have any particular Q or any particular Queen placed before that is either in the row of that particular queue in the column of that particular queue or in the diagonal of that particular que if that is the case we simply need to return false that this is not a valid position where we can store Our Queen if none of this cases are true then only we will return true saying that yes this is a valid place where we can actually place our Queen so once we find a valid place we update the position of our board to mark that value as QBE or queen and then once again so this is what this we are updating the current path and then once again we are going to be calling our current recursive method with the new recursive call where we already updated the current path of the board and we also call in with the next index position or the next column we will have to iterate over and we will keep on repeating the same process once we receive a call back from our board we will also have to explore other paths that we haven't explored so far and that's where this recursive call comes in where remember first we are marking this current position as q but next we are marking this current position as a DOT that this is no longer a cube and we are exploring other paths and this is the whole solution now let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs 87% faster than all the other Solutions which is pretty good comparing that how difficult question this one has been also in terms of memory usage our code is pretty good and in terms of like much better than lot of the other Solutions once again the solution of this code is present on our GitHub repository I highly urge you to go and check it out and try to solve this problem if you can solve this problem I don't think any backtracking problem would be a cause of concern for you okay thank you Hello friends the problem we are going to do today is one of the most versatile most asked question in the history of uh lead code questions like if you just look at the sheer numbers of the amount this question has been asked and the range of companies this question has been asked it like it's just mindboggling uh whatever your dream company might be in the entire world this and if they do good technical interviews they must have asked this question probably at least 2 three five 10 times uh to their candidates if I only had 10 minutes to prepare for a technical interview I'm going to choose this question at at the top of my choice like just look at the the the companies over here like Amazon Microsoft Bloomberg Facebook Google LinkedIn Oracle Apple bite dance which is basically Tik Tok door Dash Yahoo PTM uh Walmart Tesla Samsung so I doubt that there are any companies left that didn't ask this question and the question we are going to do today is number of islands and uh I'm going to pay my utmost attention to this problem now in the input problem we are given a grid of M cross n uh as a 2d binary Matrix and uh in this particular grid we are uh the all the cells are filled with either values of one or value of zero and whatever the value that represents as value of one actually represents land in the real life and all the values that are marked as zero is actually water and uh we need to find that what are the total number of islands inside this particular grid now based on the definition we know that uh suppose if we have uh some sort of body of uh land something like this and if it is entirely covered by a body body of water we can say that this particular body of uh land is actually an island and uh we that is what we are trying to find in this given problem now we are also told one more thing that at the edges of this particular grid like all of these values this is also water which means that suppose we are given uh an input like this where uh all of these values are zeros and we only have just one single one over here this we can also conclude as an island because uh on these three sides of the island is already water and on the outside is also water because we are told that everything on the outside is also water so just keep keep this in mind that if we find some place at the edge of the grid we still consider it to be surrounded by water if all the other side inside the grid is also water and our aim is to find that uh how how what is the maximum number of islands that are present inside the given grid now this problem is actually pretty simple like if you if we just see over here like in this particular input if we try to find uh for this example one that how many number of islands there exist actually there only exists just one Island and that is uh this one because notice this that these all ones are actually able to be connect with each other because they are adjacent to each other uh if for any particular cell uh suppose this is marked as one and this is a part of land and uh any cell ajacent to this cell is also marked as one we can say that both of these are a common part of land because there does not exist anything in between they are right adjacent to each other and this is what we are given over here so in this example we only we can only find one Island now if we take the second example we can see that there are actually more than one Islands so this is the first island that we can find this one is by itself uh and if we see all four sides of it uh this is zero this is z this is 0 and this is Zer so this is also an island and these two ones they are also an island so in this example we actually have three uh three distinct Islands okay suppose we are given a custom example like this and I have mentioned in my previous videos that it it is really important to come up with your own custom examples because it shows that you can think on your own and you can create test cases on your own it's a really important skill for any computer engineer to have now suppose this is the grid that we are given and and uh this blue line indicates the body of water we have outside of our original grid so this is just for uh understanding purposes I'm just going to get rid of it now so it does not become an issue and I can explain the problem better so we know that there is water outside now the most basic approach is that we starts traversing through the entire Grid in some manner like there are B bunch of different ways to Traverse through the the given grid and we try to see that at any moment if we find one which means that so far we have find a body of what uh land now since we have found this one we need to see that what are the different Islands we can create and we can create bunch of different Islands if uh all the values are relate are connected with one like no matter how many number of values are connected with any single one we would Mark all all of them as just one Island as long as they they are connected with each other and basically what we are doing is we are trying to find separate set of ones understand what I'm saying we are I will repeat we are trying to find separate set of ones so in this example if we just see that how many different sets we can find like we can find this one set of one we can find this another set of one and we can find this third set of ones and over here we only have one individual element but still that is a set on its own like even if we only have just one acre of land it's still a piece of land which we can consider as Island so that is what we are trying to find and uh let me just revert back okay so now we know that what we are trying to find the most basic approaches we starts traversing through the given input array and uh we start traversing okay suppose we Traverse the first row we don't find anything okay now again we start traversing over here we don't find anything now at this point we find that okay there exist an element one over here the moment we find that there exist an element one over here we are going to call our function and basically what that function is going to do is it is going to iterate Over All the adjacent cells and it is going to keep on iterating till we exhaust all the ones that are connected with this one so till we exhaust all the sets that are associated with this particular one so let me just go back a bit and uh this is the approach we are going to take that initially currently we came to this particular item we find that okay there exist a one over here now because there exists a a one we need to find all the ones that are connected with this one so what we are going to do is we are going to mark this coordinate and once we have this coordinate location first of all we are going to uh increase in the number of islands we have like initially we the number of islands we have is zero now we because we find at least a single one which means that we have found at least one Island so we will update the the number of islands we have now since we have already updated the number of islands uh and we have we already have coordinates for this one first of all we will mark this one as zero so let's mark this one as zero okay and now from this coordinate we will try to find all of its neighbors to see that there exist any adjacent ones so over here we find that uh okay this one is also one and this one is also one so we are going to repeat the same process uh and remember we are not going to update our Islands in this case because we are still connected with whatever the previous value we had found before so we are still in the same set of one that we were dealing with so there is no point in updating that but we have to exhaust all the ones that are connected with this original one we had found before so we will check over here okay this is one so because this is one we will uh we will change its value to zero because it it now it becomes part of of this uh original set we had uh now again we are from here we are going to repeat the same process okay we don't find any ones from this point so we are good but remember over here we we didn't ex exhaust all the possibilities from our original coordinate so we still have to do some work so again we will come back we will find one over here which means we will have to turn turn it to zero so we will convert this one to zero as well and now from this particular position we will will try to repeat the same process so we will check all of its neighbors and all of it neb its neighbors in this scenario are now zero which means we are good like we have at least exhausted some possibility and we have and we have at least found one set of Island okay now we will again repeat with our process and notice that I convert all these three values to zeros because we already found an island over here and now now uh we will repeat the same process so again we will start traversing our uh Matrix and over here we encounter the one again which means now we have encountered a new set of Island so we will update the value in our Islands we will update this to two again we are going to repeat the same process so first of all we will update this one to zero and uh now this is zero we still have to check its neighbors we find an adjacent neighbor again we uh we we flip it to zero first and again we go to the next element again we flip it to zero and now we won't find any more neighbors that uh are uh basically one which means that again we will start traversing so we keep on traversing over and over and over and we don't find any ones but now we are at this point again we find a one we update our Island so our number of Island becomes three and now we need to find all the neighbors that are uh present in this particular Island and we set all of the those values to zero so these values are set up to zero and now U we check that okay no neighbor actually has a value of one which means we have exhausted all the possibilities of uh number of neighbors uh that could be a part of the island and now again we repeat the same process and now we find this one and this is the last element so again we increase the number of islands that we have found to four and we set this up to zero and now because we have exhausted all the possibility and we reach to the end of the grid we can simply return whatever the value we find in the number of islands and that would be our solution suppose we we were given uh an input with all the zeros like over here we wouldn't have found any Island and we can simply return zero in that case as well but this is like a very basic approach and the approach we took at in this scenario is actually depth first search uh to find the set of ones that are adjacent to each other like we could have used BFS as well but I mentioned earlier like I'm trying to learn graph Theory and first I'm going to master DFS then I will start working on the BFS so that's why I decided to do choose the approach of depth first search in this scenario okay and uh the time complexity in this case would be uh actually bigo of M cross n time complexity because that is in uh we have to iterate over entire grid that is given and the space complexity would also be bigo of M cross n in the worst case scenario suppose that we are given a grid where all the values are just ones which means that for every any single element we will have to iterate over all the entire uh grid and uh that could be the worst time worst time and space complexity first we'll create two parameters row and column to calculate the uh current row row and column values for the given grid okay and we will also create a variable called Island and initially we will set it up to Value zero and we would update this every time we encounter one inside the given Matrix and inside the loop we will have a condition that if the current I and and J position inside the grid is actually equal to 1 then only we are going to call our DFS function so first we'll do Island we'll increase the value of islands and now we will call our DFS function in the DFS we are going to provide the I position the J position and we will also provide the grid that uh we are working on and uh once this Loop ends like we should have all the set of separate ones and uh we should have all the values of the total number of islands so we can simply return the number of islands we have found okay now we need to create the logic to implement this DFS function so first we'll create a function in inside the function we will need the values for uh the row and column again for the entire grid so we'll just name them new row and uh this would be grids length and we will also create a parameter called new column this would be the first uh position's length and uh this is basically the same as finding the row and column we found over here but we need to use it so I'm just giving different names we'll also create a 2d array of uh called directions this would make our lives easier and allow us to iterate over uh all the adjacent values of any current position and we are going to initialize it with default values we have this established first we'll put a condition that if the current row and column are they out of bounds or not we will also put an additional condition that if uh the current value we are at inside the grid if that is already zero or not because if that is already zero we won't have to do anything so if any of the these conditions satisfy we can simply break out of the DFS uh function and this would be our terminating case if this is not true first of all we will update the current position we are at inside the grid and we will name will'll enter the value as zero because remember we have already updated the uh island island and now we will just run a for Loop and itate over all the four directions so that will be that will allow us to go over all the neighboring uh candidates of this row and column uh that we have and now we are simply going to call DFS on uh row plus direction of zero and column plus direction of one and we'll also provide the value of grid as well and uh yeah I guess this should be our logic and uh we can try to run this code okay looks like we messed something up oh okay seems like our solution is working let's try to submit the code seems like our solution is also working but it's not the most efficient solution and uh I'll try to make my solution better because maybe there is some other way we can solve this problem and uh if I find out I'll probably make a video on that sometime in the future meanwhile let me know in the comments if you have any thoughts regarding this problem Hello friends we are still not employed by Fang company so let's not stop lead coding till we get there graph problems have always been a big no no for me I have I have always been afraid of graph problems but the thing is now I have decided to take them heads on and uh today we are going to start doing more graph videos so this is the first of many graph problems to come and uh this question has been really popular with Facebook recently it's been asked 44 times which is huge number also key other companies like Amazon Google Bloomberg Microsoft Twitter they are also asking this question but the thing is Facebook for some reason has been really interested so I highly urge you to go and uh check this video If Facebook is one of your dream companies to join okay this is a lead code medium problem and we are given a reference node in a connected undirected graph so first let's understand the meaning of these two values suppose we are given a graph like this notice that there are only four nodes and from any single node we can reach to all the other nodes in the given graph which means that this is a connected graph so this is what connected means and undirected graph means suppose we are given a graph like this uh and we establish that a is B's neighbor which means that we can Traverse from A to B and also we can Traverse from B to a so there is no restriction regarding the direction of uh any direction of any Edge between two nodes so we are given a reference point to that and we need we need to return a deep copy of the graph so what does a deep copy of the graph means that suppose we are given a graph like this so we need to return a graph like this where if you see the values of the nodes they are all the same but the thing is we are not using the exact same nodes we are using different nodes with same node values uh which means that this would be a legitimate case where we can consider this as a a deep copy of this original input the thing is if we create a graph like this over here we are using we are using these the same node to represent over here which means that we are not creating a copy of this original graph we are just referencing this point to whatever value we had over here so this is not what we want to give and also if we create some graph like this if we see the values of the nodes the values Remains the Same but the thing is the ordering is different that in terms of neighbor selection and how they are perceived they are different so this is also a false case we need to return a copy of this exact same input just with the nodes that are copied from this one so at the beginning the most basic idea we are going to have is that okay we are given an input we are given a reference point we know that the input graph is connected which means that there are no loose ends that we have to worry about so why don't we just Traverse through the uh in given input graph at every single note we starts creating a copy of it we start creating the same sort of neighbor connections that we have in the original graph and then just try to return the new graph that would be a perfectly good logical Sol rational person would think and uh that Sol that would be a good entry point to start our solution but thing is we are going to see that with that approach what would be the issue how can we remediate that issue and uh what would be the final solution so let's start so first of all suppose in this given input we start at this one position so we create a new node one okay now from this one we can go to any neighbor we can go to two or we can go to four let's say that we go we go clockwise so we go to two so we create a new new neighbor over here called two again from this two we go to three uh and over here keeping the same logic we create a new node now notice one thing that initially we had uh we created a clone over here we went to its neighbor again we created a clone over here we went to its neighbor again we created a clone over here we will go to its neighbor so basically for we are doing the same problem again and again for different kinds of input so that should immediately click in your mind that this we are going to solve recursively so just keep this in mind that this this is a very good way to use the recursive approach and uh now at this three again we go to its neighbor so we'll create an edge and we will create a new node four uh for this one so from this four again we go to its neighbor again we go over here but the issue with this approach is that for this our recursion to end we need to have a terminating case but in this scenario we are not terminating it anyhow because the thing is the graph is connected we are terminating in a scenario where if the graph is empty we return something empty or something like that but the thing is over here again we when we come back to this one we are still going to see that okay this is one we need to create the clone of it we will create a clone of it again over here which means that we are going to do we are going to overwrite whatever value we have which is which would be the same value again we would go to two we would again create another clone again we would go to three again we would create another clone again four again another clone we will so Bic basically we are going to end up inside the loop again and again infinitely this is almost like Infinity War Thanos is going to snap his fingers something like this because we are completely uh destroying our computer's resources our company's resources because it's an infinite loop it's never going to stop so and the reason it's never going to stop is because we are doing the repetitive work again and again and again and that is the issue so somehow we need to resolve the issue so how we are going to resolve the issue well basically the idea is simple if at any point suppose we create an additional data structure in that additional data structure we keep track of whatever the value we have traversed already or we have cloned already if we know that which means that initially when we start we are going to check in that new data structure first that hey this element have I Ed have I cloned it already if I have cloned it already I would skip over I would go to next element if I haven't cloned it already I would create a new clone of it and then I will put the same entry in the hashmap first before I go to the next element so that way when after this first Circle comes and when I come back to the same position I would know that okay I have already calculated this one which means that I don't need to calculate it again and I can skip over it first of all let's create let's see that what kind of additional data structure we are going to create where we can immediately find that whether we have visited any particular element or not which means that we are going to do lot of searching hence we will need a data structure that is very quick and efficient in terms of finding the uh any element that whether it contains that element or not uh and the answer is pretty simple if that kind of scenario happens we need to use hashmap or hash or something with the hashing we cannot use the link list over here it would work fine but it's going to add that much more additional time strain or on our system so make sure that you justify your reasoning I mean in the interviews people are not typically going to ask that why did you use hashmap this is a given but thing is that uh thinking should be clear in your mind that why you are using it and in most of the graph problems uh typically hashmap is being used and now inside this hashmap we are going to store two values so as a key we are going to store a node and as a value we are also going to store the node but thing is as the key we are going to store this input node and as the value we are going to store the cloned node that we will create so let's see that what what should be the algorithm for our solution and how we are going to approach it so initially we start at this position one now at this position one first of all we check that whether we have this entry inside our hashmap or not okay we don't have the entry inside the hashmap because we can find it in constant time if the entry does not exist we first of all create a clone node okay clone node has been created now after creating the Clone node immediately before even we check for the Neighbors of this one immediately we are going to add an entry inside the Clone node so the value would be the cloned value that we have created and the key would be the original uh input we are given now this is done now we are going to check for this one's neighbor so one let's say we end up at this neighbor number two so again for this neighbor number two first of all we are going to check that whether neighbor number two exist in this hashmap or not it does not exist so we will create a clone now the Clone has been created first we will add the value to the hash map and after adding the value we would again go again recursively do uh find for the two's neighbors so in this case uh the two's neighbor would be three so we will create a first we will check that whether three exist in the hashmap three does not exist so we create the node and then we create this one now again we check for the value number four four does not exist so again we create an entry inside the hashmap we provide the key value and then we create the Clone node four again now for the fourth we again check for its neighbor so fource neighbor one neighbor is one which we already have it in hashman which which means that now we can ignore this case because we have already dealt with now second neighbor for four is three which already exist in the hashmap which means we can we can be dealt with it uh we go back two is already done one is already done which means that now we are running out of neighbors to take track from inside the given uh original input and we know that the original input is completely connected graph which means that there is at no point there is a possibility that there exists some value five over here that is part of this graph but it is not provided uh using this connection because all the elements are connected which means that this would be our final clone graph that we need to return so after the loop ends and the recursive termination cases trigger we can simply return whatever the Clone graphs we have found because from any single location we are able to guarantee to reach all the other elements and once that that is done essentially we are done so this is a very effective solution basically all we are doing is just we are traversing over the given graph and uh during the traversal we are doing something so in this case we are cloning it um we are using the hashmap to keep track of whatever the visited elements that we have been through and uh this solution is pretty efficient it's uh it's not the most difficult problem in the world but thing is I am very bad at graph problems so and I have always been scared of graph problems but thing is now I have decided to spend more time on graph problems because if you want to join Facebook you can't you can't even think about not doing graph problems okay so today is first of many problems to come uh if we see the time and space complexity the time complexity in this case would be big go of V plus e where V is the vertices and E are the number of edges because notice that over here we are only doing this much work we are not doing any additional work so that's pretty simple and in terms of space complexity it would actually be B of V uh in terms of number of vertices because over here we had four vertices and uh in the hash map we created four entries uh so whatever the number of vertices we are provided we are going to use that and uh that would be our space complexity so this solution is actually pretty efficient uh we are using depth first search to solve this problem but even we can solve it with using breath first search so it makes no difference in terms of time complexity the thing is I just did this using depth first search next one I'm going to use breath first search maybe so first of all we are going to create a new hashmap and we are going to name it visited to keep track of whether we have already visited the node node or not now inside the method first of all we are going to check that if the given node is null which means that we can return the node okay and also we are going to check that if uh the if we have already visited the existing node then we are simply going to return whatever the uh value we have stored inside the visited hashmap okay if this is not the case uh first of all we are going to create a clone node so let's just name it clone node and in inside the Clone node we are going to give it the value of whatever the node value that we currently have and we are going to assign a new array list we are going to add the new clone node to the visited node we are going to run a for Loop for all the neighbors of existing node so inside the loop we are going to iterate over the neighbors of the existing node and we are going to create the Clone nodes for that and inside the current clone node we are going to put the neighbor as an array list so and over here we are going to make the recursive call with the neighbor after this Loop ends we are simply going to return the Clone node let's try to run this code okay seems like our solution is working let's try to submit the code okay our solution works and it works pretty efficiently there is still room to make a lot of improvisation as we can see that our solution is not the most efficient but thing is I'm really bad at graphs so it took me a lot of time to make this video because I need to understand very thoroughly by myself first before I can create the video uh but soon I'm going to do lot of graph videos so it's going to so my video quality is going to improve and also my coding is going to improve so hope for the best and uh let me know in the comments what do you think about the video and uh yeah see you next time thank you [Music] so the lead code problem we are going to solve now is called maximum area of Island and we can see that this one is a medium problem and also a very well-like problem the statement is quite straightforward we are given an M cross n binary Matrix named grid now for this particular grid we are given bunch of different ones and bunch of different zeros now we are being told that on represents an island and zero represents just water okay then we need to return the maximum area of an island that we can make inside the grid and if there are no islands that we can form we need to return zero plus we are being told that every single cell with Vue one is uh the island and if there are bunch of different ones connected with each other then we need to basically do the addition of all of those cells and then we can consider them as one entire block of an island so let's try to understand this with an example here is an M cross and G we are given and we can see that there are bunch of different zeros and bunch of different ones now some ones are isolated so this is just an island in its own and we can see that the area of this particular island is going to be value number one because it is only connected with just one uh Island by itself but if we take a look at some other Islands we can see that they actually form bunch of different ones that are adjacent to each other amongst all four horizontal values and that increases the a area of those particular Island so we will have this island that is of size four same with this island of size five and so on and so forth now we need to return the island that contains the maximum value so in this case this island chain or this connection of ones are actually total area of six so in this case we will need to return return the maximum area of islands as six as the answer so this is what we need to return now let's try to understand that what are the different logic we can take to solve this problem now we know it's a very straightforward problem the idea is that we are going to iterate in one single Direction uh from the starting point and the moment we identify that there exists some island or value number one then we need to iterate over every single possible neighbor of this particular one and the moment we exhaust all the possibilities by exploring every single neighbor we can determine that that has been the current uh area that we have been able to find plus we will also need to keep track that what is the maximum Island we island chain we have been able to identify it so far so let's try to understand the most common basic approach to solve this problem let's say that we start iterating from this very first cell in sequence in just regular sequence so we say that this is water this is water so there is no area we can find we come to this node this value is one so the moment we identify one we will have to take a look in all four directions to see if there are any possible Island chains that we can make since in this case there is there are no Island chains we can form we can see that the area of the current value we have been able to identify so far is one and so far we have only found one island with area one so the maximum area we found so far is also one after doing this we will have to mark this one as being visited because we have already visited this node and why are we marking it visited I'll just explain it to you later so let's say that we mark this one as visited as well okay that this this one has already been taken care of we iterate again nothing we we don't find anything once again we find one more one over here which means we will have to uh do the iteration for our current updation right now so once again we start looking in all four directions the moment we go to this direction we find one more one so once again for this particular one we will have to repeat the same operation look in all four directions and here the problem may arise let's say that we look in this direction and this direction and then we decide to look up into this direction so this is also a neighbor of one and we can also by mistakenly calculate this one once again so as part of the island which means we may stay inside an infinite Loop and that's why in order to prevent that issue the moment any particular value that we have visited we are just going to mark that that value has been visited so we don't recount those values again so let's say that we count this value then this value then we go into this direction and this direction and so far we have visited all of these four ones and the current area so far we found is four which means maximum area also needs to be updated so we are going to update the maximum area once again now we uh start our iteration in the similar fashion these are all zeros so nothing to do with this once again this one would have been one but since we already visited this one there is no point in redoing the same operation so we are just going to go and ignore this case completely and once again we are going to ignore all of these cases once again we identified one one so so far the area is going to be four we cancel out all of these four nodes as well and we keep on repeating the same operation until we find the maximum area which we would find when we get to this particular one as value number six and this is what we need to return in this case so the moment I was explaining this solution it should completely come to your head that this is actually a graph problem where this given M cross n grid is actually the Matrix we are given that represents a graph it's an adjacency Matrix and for this adjacency Matrix all we need to do is we will have to find that what are all the connected components for any particular graph and the cluster of the connected components whichever has the highest value we simply need to return that as part of the answer or as part of the area we have been able to calculate so far now we know with any particular graph problem the most important thing is that how we are going to iterate over the graph so we know that iterating over an M cross n grid is quite straightforward we simply need to run two four Loops to iterate over that the moment we identify any particular one then we will have to explore in all four directions and iterate over the entire set of directions where whichever the value is one and we will have to keep on repeating the same operation so logically all we are doing is a depth first search whenever we identify any particular one that exists we can also do a BFS but DFS in my opinion would make much more sense in this case because we need to go in any particular direction uh it won't change the result but U I just like to use DFS for this particular type of case uh then in order to complete the DFS and not run into the issue of uh recounting the same value we will have to keep track of and all the visited nodes for that we have two options one option is that we can try to manipulate the existing input but let's say that your interviewer is very picky and uh he or she does not want you to play around with originally given input so instead of playing around with originally given input you can also create a m cross n Matrix and just Mark all the values by zero whichever the ones that you have visited so far so that way also you can just keep track of all the nodes that you have visited and you are only going to do a DFS on unvis exited nodes so that's it that is the whole solution and on top of it for the entire duration you are going to keep track of the current um area that you have found so far and the maximum area that you have been able to find so far and combination of this would actually solve this problem quite simply quite easily let's try to understand the time and space complexity in this case time complexity is simply going to be big go of M cross n because we will have to iterate over every single cell and even for our DFS operation we are going to Mark those nodes as as visited in terms of space complexity because we are using an extra space to store all the visited nodes it is also going to be big of M multiplied by n or nodes multiplied by edges so in this case overall this is a very good time and space complexity once you understand that this one is an is actually a graph problem it becomes very simple to solve and also move forward so now let's quickly see the coding solution for this one so the coding solution is quite straightforward uh we are given our Max area of Island that we need to find and we are given the grid as part of the input first thing we are going to do is to check that if the given grid is equal to null then we are simply going to return zero it's an edge case then we are going to initialize a variable called Max area and initially the value is going to be zero then we are going to iterate over every single value that is currently present inside our grid using two Loops uh I and J and for every single Value First we are going to check is that if the given grid position if that is equal to one then we will start calculating the area of this current one that we have been able to identifi so far and we will have to iterate over in all four directions and that's where we are using the DFS method next thing for every single one that we have been able to identify so far it could be possible that that particular value could be the maximum area we have been able to identify so far so we we are going to compare the max maximum area we have so far and the new area or the current area we just found for this particular through this DFS call now let's understand this DFS call and how does it work in the input we are providing the grid that we are working with we are also providing the current I and J position very first thing we are checking is that if the given grid is going out of bounds in either one of these cases we are simply going to return zero or if the given grid position I and J that we are working with if that is also zero then also we can return zero if that is not the case we are going to mark this cell as visited now in this case I'm not using an extra hashset I'm just uh using the same grid to update the call but if your interviewer ask you that you cannot change the given input then you might need to create a new instance of uh new M cross and Matrix and repeat the same operation then we are going to add value of area by one and then we are going to make four different calls in all four directions and we are going to do the plus and equal to operation for the area which means for every single one that we are being able to identify in each four each of these four areas we are going to add that value to our existing area and we are simply returning the area in the end so this is this is our helper method where recursively we are using the DFS operation and we are updating upd updating the area of the current area we have been able to identify it so far in the end we simply need to return the max area we have been able to identify so far once this for Loop call ends so now let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs 100% faster than all the other Solutions which is exceptionally good so once again the solution is present in our GitHub repository so feel free to go ahead and check it out thank you hello friends we are still not employed by Fang company so let's not stop lead coding till we get there today we are going to do a very important lead code problem Pacific Atlantic waterf flow and as you can see that this problem hasn't been asked in too many companies but I think it's the companies where this problem has been asked are really one of the most important companies in the world uh Google Amazon Uber Microsoft Facebook Apple by dance which is a parent company of Tik Tok Bloomberg so you can understand the scale that why this problem is important and what kind of companies ask this problem and the thing is main intention for understanding this problem is to not to understand the actual problem but rather the approach behind the solution because that can become a base foundation for too many other problems there is lot of information in this problem statement but if we try to comprehend this using the picture it really it's really simple to understand so I'm just going to go over that essentially we are given uh a grid like this and we are told that this is actually an island on somewhere in the ocean but thing is it is at the Cross Junction between Pacific Ocean and Atlantic Ocean and the way it represents is that this top top and this left edges they are actually Pacific Oceans and this bottom and this right edges they are Atlantic Ocean so this and the second information we are given is that all of these coordinates inside the given um Island represents the height of that particular area and why the height is important because we are told that uh on this particular Island on this particular grid there happens to be lot of rain which means that uh rain Falls and we know the property of water that it gets transferred from higher height to lower height we are also told that that rain at any particular cell can travel to can go to four directions it can go to top uh right bottom or left which means it cannot go diagonal in any scenario and the condition that if uh it can travel travel from one cell to another cell is that if the height at any particular given cell if it's greater than or equal to the cell we are trying to reach then the water can Travers travel to that uh that cell which means suppose we take this cell for an example the height for this cell is four which means if the rain falls on this cell we can conclude that rain the rain water will go to cell three it will also go to cell one and cell two but it would not go to this cell five because the height at cell five is greater than uh cell four which means that this is cell four and this is cell five so water can't travel like this now the interesting part for this question is that we need to understand that what are the uh cells in the given grid that can travel where if the rainwater Falls it can travel to both Atlantic Ocean and also Pacific Ocean so let me clean this up a bit suppose we consider this uh cell number five and if rainwater falls in the cell number five uh let's see that can it reach Atlantic and Pacific like we know it can reach but in this uh cell cell adjacent to the cell number five the height is three which means water can go over here from this three the water can go to this one and because this is at the edge of Atlantic uh of course water can go to Atlantic ocean from here now from this uh cell number five uh we know that water con can also go on this side because the height is four and from this four the water can go because the height is two Which is less than four and from this this is at the edge which means that at any point whatever the height over here is uh like 1 2 whatever value all of that can go to Pacific Ocean so we can conclude that water from this uh cell number five can reach to both Atlantic and Pacific Ocean let's take another example suppose we take an example of this uh value number four so we know that from this cell we cannot go over here we cannot go to five but we can go to two and from two we can go to Atlantic so that concludes one one U option now let's try to see that can we go to Pacific Ocean so first if we try to go on top okay we can go over here because this is three but from three we cannot go to the top because this is uh four so we can't go Pacific in that this direction if we try to go over here we can reach to this one we cannot go to this seven which means that uh from this four we can go to Atlantic Ocean but we cannot go to Pacific Ocean so we wouldn't include this in our intersections for every single cell we are going to check that whether it can reach to both Pacific and Atlantic Ocean if it can reach we will just maintain a list or some sort uh that will take care of all the cells that we are able to reach uh to both the oceans and we would keep on adding them in in this list so first we'll start with this first element uh we know that it can reach to Pacific Ocean but it won't be able to reach Atlantic Ocean because height over on both these cases are greater so we wouldn't include this we would go to next one so over this this again can reach to Pacific but it cannot reach to Atlantic because if we it will Traverse in these two directions but it won't be able to go any further over here and over here uh same happens for this one for this one and uh basically this solution would work we would find our answer eventually our list would be filled out suppose we are at this location five so we know that this is at the inter exact intersection of both the oceans and it can clearly go to uh the rainwater can clearly go to Pacific and both Atlantic so we would add this particular location in our list and uh eventually the list will be filled out but thing is uh the issue with this approach is that in terms of time complexity we are actually doing lot of lot of repetitive work because for every single cell we are checking all the possibilities and we might end up doing in the worst case scenario big go of so suppose this uh is M and these are n cells so we can say that the time complexity would be big go of M multip N squared because for every single cell we will have to iterate over all the other cells and uh this is not a very good time complexity there is there exist a better approach so in order to solve this problem we are actually going to use a different approach and we are the approach we are using is actually if Mountain cannot come to mammad Muhammad will have to come to Mountain and what I'm trying to say is suppose that rather than checking at any particular cell that whether it can reach both Atlantic and Pacific Ocean we create two separate grids so suppose we create a grid and another grid so two separate Matrix of Boolean values that has the same size of whatever the input size we are given and at any particular location we just name that that okay this matrix consist the data of all the cells that can actually reach the Pacific uh ocean and this cells contains this Matrix contains all the data of all the cells that can actually reach to the Atlantic Ocean and once we have these two matrixes defined uh the moment we find that okay so over here we know that this particular element three this this can reach to Pacific Ocean so over here suppose this value corresponds to this three so we will set the value as true over here and same goes on this side that suppose we find out that uh this particular element at four position four can reach to Atlantic otion bya this way so whatever the corresponding we have value we have over here we will set that value as true and eventually we will have the entire uh matrixes filled out and once we have those all we need to do is just intersect both of them and find the common elements between both of these Matrix and uh that would be our final list of matrics that contains all the cells that can reach to both Pacific and Atlantic Ocean and this would be our solution well this solution actually works pretty fine it's pretty efficient and uh all we need to do is we need to figure out that how we are going to generate these two Matrix and what are all the different logic we are going to take let's take the most basic approach I'll be showing you an example that suppose we want to reach to Pacific Ocean how can we fill out that M Matrix now what is the most basic thing we know about Pacific Ocean well we know that for this particular Island all the cells that that are present in this row and all the cells that are present in this column they are actually at the edge of the island also they are at the very uh adjacent to Pacific Ocean which means all the water in these positions can actually reach to Pacific Ocean in all the cases so in our Matrix whatever Matrix we have we can basically Define all the elements these positions as true because we know that they can reach to a Pacific Ocean now previously at any particular location we were actually trying to go outwards to see if water can reach to adjacent cell or not but rather than going outwards why don't we come inwards from the cells we already already know that can reach to Pacific Ocean so over here these cells we already know that can that they can reach to Pacific Ocean so if we check that whatever the cells that are adjacent to these cells from this particular cell that can reach to Pacific Ocean can we reach to the these adjacent cells or not and the moment we find that okay we can reach to some adjacent cells that we haven't already visited so we can set that as true suppose the value over here is three and we know that this is able to reach to Pacific Ocean and suppose the value adjacent to this one is actually six so we know that uh since the height difference there is a height difference and uh over here we need to check the reverse height difference previously uh in this approach we were actually checking that whether the height we are currently at and the height the adjacent cell is actually the height is lesser than whatever the current height we have over here we are coming inwards so we will check that whatever the next cell is that we haven't checked whether its height is greater than whatever the height we currently are at so in this case this is three this is six which means that okay from this cell we can come to this cell and uh over here we know that we are coming to this cell from this particular cell that is already able to reach to Pacific Ocean so over here we can directly mark this one as true and we won't have to do lot of calculation over here because we already know that this cell is true and we are reaching to this cell via this cell and this would be a very good solution and this is how we can actually fill out this entire Matrix like all the remaining portion in uh bigo of M cross n * in just single traversal because we are not for any particular cell we are not going to check the whole thing we are only going to check the cell that is exactly adjacent to it suppose we are at this particular cell cell and we know that this cell can reach to Pacific Ocean we have already set this value as true okay now uh we do calculations like this and suppose before we come over here uh from this route we have already calculated this and we know that this is already true that this can already reach Pacific Ocean and we are at this position and we are checking this again so first we will already find that whether the value for this particular element has been calculated already or not if it has been calculated we don't need to do repetitive work and we can just simply skip over it uh so we that way we can also make uh some runtime adjustments that would be more efficient on our case okay now we need to find a way to somehow create the Matrix that stores the information of all the cells that can reach to Pacific Ocean and also to Atlantic Ocean uh in order to do that at first I thought that we are going to use dynamic programming over here and the reason I thought is because first of all we are defining a set of uh all the cases that can reach to Pacific Ocean so this becomes our base case once we have our base case defined uh we are essentially going in all the directions to see that if we can reach to next cell and suppose in this case we are able to reach to this cell from over here due to the height difference so we will mark this as true and uh again from over here we will again do the same thing and we will so basically at any point we are using whatever the calculation we have calculated before to generate the next results so that's a very clear indication that we we need to use dynamic programming over here but it turns out that I was not not able to solve it efficiently I was still missing out in a lot of test cases so apparently dynamic programming is not the way to go but I still urge that if anyone can solve it using dynamic programming I would be uh more than happy to understand your approach so second thing I I tried to do is uh that okay in order to solve this we need to iterate over the entire Matrix and in order to iterate over the entire 2D Matrix we we can use We have basically two methods we can use either breath first search or we can use depth first search to iterate over all of the elements and do some calculation now I'm new to graph Theory and I need to first of all perfect myself on depth first search before I move towards solving the problems using breath first search so I chose the approach of taking depth first search but it can also be solved using bread first search without any issues and we know that in order for us to sell uh to complete this program using depth first search we need to use recursion over here and uh of course we can use recursion because notice that at every single position uh so over here first of all we Define that this can reach to Pacific Ocean Now we move on all the directions and over here we find the height difference so again we know uh that uh this can reach to Pacific otion because this can reach to this cell so we mark this as true and then again we repeat the same process that we have just did and again we would mark this as true and again we would repeat the same process so essentially we are doing the same sort of work but for different inputs and that's a very clear indication that we we need to use depth for sear uh using recursion and uh let's move on towards coding now first of all we are going to check the condition that if the given input is actually an empty Matrix then we just need to return null okay if that's not the case uh let's create two parameters to store the value of row and column now we'll create to Boolean Matrix to see uh if the to store the value of cells that can reach to Pacific and Atlantic Ocean and we are going to name that Pacific reachable and Atlantic Atlantic reachable and we are going to create both of them to the size of whatever the uh initial Heights Matrix we are given now we will run a for loop on the for both The matrixes Matrix to be filled out in order to fill both the Matrix we are going to create a DFS method and inside the DFS method we are going to provide the row and column location and uh we are also going to provide a Pacific and Atlantic Matrix so first we'll do it for Pacific Matrix and we are also going to provide uh the input Heights that we are given we are again going to call the same function for the Atlantic will iterate using column as well now before we calculate the result first let's create the method now inside the DFS method we will have to iterate over for any particular cell we will have to iterate over all four of its uh adjacent cells so we'll just create a 2d array called uh directions and we are going to use it uh to iterate over all the adjacent uh or neighboring cells so we are at this DFS location which means that we already know that this row and this column pair is already able to reach to subsequent whatever reachable uh Matrix that we are trying to calculate so which means that we will set that value as true now we will start iterating over the neighbors of whatever the current cell we are it and we are going to create the new row and new column now we will have to check that if this uh new row and new column are they out of bounds or not if that's the case we just ignore that uh and we continue we also check that if we have the if the new row and column uh cell have we if we have that value calculated before we can also just ignore that case okay if both the cases are not true uh we will check that if the height difference of the previous cell and new cell is in our favor or not which means if the heights for the new row and new column if that is greater than or equal to whatever the previous height was if that is true we will need to call the DFS function again with the new row and new column and uh this this would be our Logic for this DFS method because we are eliminating all the cases and we are also uh calling the recursive function based on the height difference so so after these four uh entries run we should have both of our Pacific reachable and Atlantic reachable Matrix is filled out and now it's just a matter of finding the common elements between them so first of all let's create a list of lists uh to store our result and we'll just name it as result just going to iterate over the entire array uh row and column wise and we are only going to check that if both the Val vales are true in both the Atlantic and Pacific Ocean cells so if if both are true we can add it to our list so uh after this Loop runs we simply need to return whatever the result we found and uh that should be our solution let's try to run this code okay seems like a solution is working let's try to submit this code okay our solution also works it is accepted by lead code but thing is it's it's not the most efficient uh solution so let's see that if we can do some modifications and uh one modification I can think of is uh rather than calling this DFS system right here and checking this condition all the time what if we revert the condition and if this condition is satisfied we can return we can just uh return it and we can just continue before so that's why Loop breaks more times before and uh if all of these conditions are not true then only we will call our DFS function let's try to run the code okay the code is working let's try to submit the code okay we see some improvement in our code and now it's a little bit faster than what our previous result was so I'll be posting this code in the solution you can check it out from there uh from the comments and uh let me know if how do you like the video thank [Music] you so the lead code problem we are going to solve now is called surrounded regions we can see that this one is a lead code medium problem and also very well like problem now the statement is quite straightforward forward that we are given an M cross and Matrix named board that contains bunch of different x's and bunch of different zeros now we need to capture all the regions that are four directionally surrounded by X and if a region is captured then we need to flip all the zeros into that particular reg region into the AIS that is uh surrounded region so let's try to understand what they are trying to ask we are given in this example uh an M cross and board where we can see that there are bunch of different X values and bunch of different zero values now in this case what is the definition of any particular zero surround zero region to be surrounded a region is surrounded if in all four directions it is uh connected by some sort of X in each one of them if that is the case we can determine that this particular region is surrounded now notice one important thing we are not concerned with its immediate neighbor but even if the neighbor of the neighbor is still a value X then we can determine that that particular value is still surrounded by XIs so the moment we identify a surrounded region all we need to do is convert all the zeros into X's which means we can see that this node is surrounded by four x's in these four directions uh this same way with this particular zero it is surrounded by these four X's and same way for this particular zero it is surrounded by these four X's so logically all of these would be converted into the X's which we can see over here but for this particular region it is only surrounded by X in three different directions not four so we are not going to flip this 0o into X we are going to leave it as it is and then we need to return this state of the M cross n grid as part of the answer so let's try to see that what is the simplest logic we can use to solve this problem now let me give you one example of bunch of different zero potential values in all of these different grids let's say for this particular grid if we have any single value zero then that value has to be not surrounded region why because currently this particular value is located over here even if in all all the other directions we have access then also we would never be able to get a four directional pattern where this region becomes a surrounded region so in the answer we are always going to have a scenario where this zero is going to remain zero same way for this 3x3 grid let's say that if we have any particular uh zero present over here and let's say that all the other values are currently X's then we can very easily determine that this zero is actually surrounded by xcess in all four directions so in the answer when we try to create basically this zero has to be flipped into X that is true but let's say instead of doing that instead of this being zero in this middle portion let's say if we have zero located at any of these edges any of these okay I'm not saying all of them are zeros let's say any one of this is a zero and let's say that all the other values are X's so I'm currently marking these by a bunch of different X's this region would never be surrounded that's a given fact why it would never be surrounded because there is always going to be one or two directions where it is located on the edge which means there can never be an X planted over here so in if the node if the node is in the middle then it has the possibility of being a surrounded region but if we identify zero at any particular Edge then that zero is always going to be a not surrounded region so it it does not needs to be changed that is what I'm trying to explain now let's try to see one more example in this case let's say if we have any particular these four zeros placed like this and all the other values are x's in this case all of these zeros has to be converted into the X's because all of this becomes a surrounded region but for some example if we have any particular zero located over here we already established that this does not needs to be changed that is number one thing second thing is that not only this does not needs to be change let's say that if there are any particular other zeros connected with this value then also they are also going to be not surrounded regions once again I repeat if there are any particular zeros that are connected with this Edge then we can determine that this is also going to be not a surrounded region and we are going to exploit this property to its fullest because uh remember in this case particular this zero is actually always going to have one more zero located over here which means it can never be for directionally challenged by another zero and this is what we are going to use to solve this problem uh what we are simply going to do is that we are going to treat this as a graph problem on not only a graph problem we are also going to treat it as a graph traversal problem where we need to do the depth for search at any given moment we identify a value that is currently zero the thing is we are not just going to blindly start looking for zeros in all of these particular grids that it makes no sense if there is any particular zero in the middle there it might be possible that there might be excess in all four directions that could prevent it from becoming a not surrounded region what we are going to do is we will try to only Traverse into the edges of this particular Matrix and for each of the edges we will try to find that if there exist any particular zero then we are going to start doing the DFS and all the values that we identified through this iteration we are just going to Mark those numbers that they are always going to be uh four directionally not surrounded regions and all the other regions or all the other values we can simply mark them by X so let me let's try to understand this with an example that I'm trying to show you let's say that in this case we are currently given that this particular these two nodes are currently zeros and let's say that this is connected with this zero and let's say that this one is not connected with anyone else and then we have this zero connected like this and all the other values are currently X values so logically the algorithm I'm proposing is that we start iterating over this m cross n Grid in first of all all the edges so let's say that these four are the edges and then uh we once again identify this Edge and this Edge and then this Edge and this Edge so we found a one Edge that contains a value zero the moment we identify one Edge that contains the value zero first of all we are going to mark this one as a special zero so let's say that I'm keeping track of all the zeros that I have been able to identify so far and let's say that this one is a special character that contains a zero at the edge then we are going to do the DFS operation in all four directions to find all the connected zeros but we can see that this one does not have any connected zeros so we are just going to say that this is the only zero we find and then continue with our iteration once again again we are at this position this is also X once again we identified one more zero so the moment we identify one more zero we are going to mark it as a special character and then we are going to start doing the DFS operation in all four directions this one is an X so we don't do anything this one is an X so we don't do anything but this one is not an X so this one is also a zero and a zero that has been found by reaching a zero that was present in the edge so once again we are also going to mark this as a special character and then uh now from now on we cannot move uh ahead anywhere forward so we cannot do anything on top of it for our DFS operation we will have to keep track of all the visited nodes so we are also going to mark all the visited nodes as well so it's just some simply for our convenience and that's it so once again we don't find any more excess so then we simply say that we iterated all the edges we reach we did the DFS on whenever we found a zero at the edge and uh we Mark those nodes and apart from these nodes everything else should be converted into the AIS which means this node has to be converted into an X and that's it this is the state of M cross n that we need to return of all the zeros that are not surrounded and all the surrounded regions are being converted into the excess so that's it this is the whole solution uh if we try to understand the time and space complexity in this case time complexity is going to be big of M cross n because we will have to iterate over every single nodes and this is an example of adjacency Matrix kind of representation for the graph space complexity well this is De debatable if you have to create a new snapshot then you might have to use M cross n space if you can modify this current existing node just by changing this character from something else from zero maybe something like a hash or something then also we can use the same pattern or same logic so it's up to you how you want to approach that or how your interviewer wants to do that it can be a common space complexity or if you are uh if you are not allowed to change the input then it it is going to be big of M cross n space complexity so now let's try to see the coding solution for this one so the coding solution is quite straightforward we need to solve the given board and first we are going to check for the edge case that if the given board is equal to null we can simply return if that is not the case we are going to Define our M and our n then we are going to start iterating over the boundary and start marking all the zeros that we find on the boundary as like a temporary character or a temporary variable so let's say that uh we run two Loops we have this if condition that if the given node is equal to 0 or M cross M minus one and J is equal to 0 or n minus one which means we are checking for the edge nodes on top of it we are also checking that if the given board position marks the value as zero if that is the case then we are going to call our DFS method in the DFS method we are checking that all the surrounded regions that we need to find so uh this is our DFS method where uh we are first of all checking that if the given node is equal to null or we exhausted all the possibilities we can simply return if that is not the case we are going to mark that particular value as a temporary character T stating that this has been visited and we are going to run the DFS operation in all four four directions repetitively which means we are only going to be left with temporary values that are currently visited by us after this DFS operation that are connected with the zeros that are located at the edge then uh once that is done we simply need to check uh and capture all the surrounded regions so for that we can simply iterate over the given input array and check that if the given input board position is equal to zero which means it is not t then we are going to Simply mark it as X if that is not the case and if that value is T which means it is not a surrounded region so we are going to mark it as zero and that's it this is the whole solution let's try to run this code okay seems like our solution is working as expected let's submit this code and our code is exceptionally faster compared to all the all the other Solutions which is great to see and uh once again you can find the solution on my GitHub repository link is in the description thank [Music] you hello friends hope you're having a fantastic day so now we are going to do an awesome lead code problem called rotting oranges we can see that this one is a medium problem and also an extremely well-like problem the statement is quite straightforward we are G given an M cross n grid where each cell have one of these three values first value is zero that represents that there is an empty cell which means there are no values over here a second potential value can be one which represents that there exist a fresh orange on that particular cell in the M cross n grid and next value is two which represents that there could be a rotten orange or a bad orange placed in that particular cell now there comes the interesting part that with every single minute any fresh orange that is four directionally adjacent to a rotten orange becomes rotten so after every single minute iteration we will have uh we will start finding more and more rotten oranges and they would keep on growing now we need to return return the minimum number of minutes that must elapse until no cell has fresh oranges that is number one thing that we are being asked if that is the case we need to return the minimum number of minutes and if it is impossible to rotten all every single oranges then we need to return minus1 as part of the answer so let's try to understand this awesome lead code problem okay so suppose this is one of the exampled input that we are given now notice that the values are 2 1 and zero given in different sections of this 3x3 cell now we know that value number two refers to a bad orange so I have denoted that as like B over here and in this grid and one refers as normal orange so I have just marked o or like zero that represents a fresh orange okay don't confuse this with like value zero because value zero I have left it as empty because there are no oranges or nothing on that particular place so now let's focus on our input now the way we are given this problem this is a bad orange now let's say that this is the current starting position so at minute number zero this is currently what is happening right now but we know that after every single minute all the oranges that are adjacent in four direction to this bad orange will start getting bad so after 1 minute passes we are going to have two more uh uh oranges that have gone bad and that are these two oranges so we can mark them as bad oranges and all the other oranges that we have are going to remain as it is uh this this happens during the first minute during the second minute once again more Apple oranges are going to get bad so since this Orange Is Right adjacent to this one this will go bad and this orange will go bad in the next minute so this these two oranges will go bad so if we Mark the number of bad oranges it is going to keep on increasing in this fashion and now we are only left with two fresh oranges and during the third minute basically we are also going to have this orange go bad uh because notice that this is directly adjacent to this orange so during the third minute this orange will also go bad and all the other oranges we already have they are bad and during the fourth minute basically uh because the in the third minute this orange is fresh but during the fourth minute this orange will also go bad and now we don't have any fresh oranges so we can say that after 4 minutes basically every single oranges that could go bad they have all gone bad so in this case we need to return return four as the answer now let's say for the same example we are basically given one more scenario let's see that what would happen in this case well we know that during the first minute the adjacent orange is going to get bad so now we are going to be left with two bad oranges and few other good oranges during the next iteration once again the same thing is going to happen and now in this next iteration basically this orange is going to go bad so then we are going to be left with these three bad oranges and then these three good oranges during the next minute uh once again same thing is going to happen and basically we are going to be left with uh this uh orange as becoming bad orange as well and all the other oranges would remain good and during the next iteration basically this orange will also go bad but notice one thing that despite every single orange being bad we do not have any particular way for this particular orange to go bad which means no matter how many iterations we take even if all all the oranges went bad this orange will still remain Fresh So in this case because we cannot have every single orange becoming rotten we need to return minus1 as the answer so this is what is being asked us to solve in this problem now I know this problem looks really interesting and really important in terms of many different aspects so first let's try to start breaking the problem down and start understanding different things on what we can do to solve this problem let's say that in this problem we are given oranges like this and all the other cells are simply empty logically what is the most simple thing we are going to do well we are we need this is the initial position so we are going to have a value called minute and in this particular minute we are going to mark that all the minutes that has elapsed so far so during the zeroth minute this is the position so during the first minute what is going to happen we are going to start noticing that this orange will go bad okay then during the second minute this orange will go bad during the third minute this orange and during the fourth minute this orange will go bad so this case it's going to take 4 minutes for every single orange to get rotten so the thing is we can visualize it very quickly and very easily but how can we implement this programmatically so that's where few important Concepts come into the place that let me start describing number one concept is that basically for every single position we will have to understand that what is the rotten or bad bad orange and then we will have to start iterating from that particular element so so far we were lucky that the very first element was actually a rotten element but let's say in the same scenario instead of this being rotten what if this was a rotten orange once again the answer would still be 4 minutes but in this case we would have iterated over all of these cells before finding this rotten cell before we start branching out so that is number one thing that we need to first of all find that what is a rotten uh uh orange okay that is number one thing next thing is the moment we find the rotten orange what we do is we start branching out but the question is are we BR branching out in the depth first manner or a breadth first manner well logically in this case we are actually iterating in the breath first search manner because for every single node that we iterate over we try to iterate all of its neighbors before visiting or before visiting their neighbors and let me give you a very simple example for that let's say in this example uh during the very first iteration we simply visit this neighbor okay so we are going to mark this as a bad orange but in the next iteration rather than going in one particular direction we are going to branching out in two directions and marking both of these as bad apples and then after exhausting all the neighbors of this particular orange then only we will start exploring more neighbors of these remaining oranges so this is also another uh important point to be understood okay that we will actually have to use breath for search in this case to solve this problem okay we took care of two items now let's try to understand that how we are going to keep track of the number of minutes well logically the answer is quite straightforward that whenever we have to make any single new BFS call we are going to keep track or keep increment ing the number of minutes that we will have to make so this would be our minute counter that we are always going to update with every single new BFS call we make now we know that in order to use a breath for search we will have to use a Q and logic is quite straightforward that first of all we are going to uh iterate over all the oranges that we are given and try to find all the bad oranges we have in this case we only have one bad orange but it could be possible that we are we may be given multiple bad oranges so let's say that we are only given just one bad bad orange so we are going to put this bad orange in the cube and with every single iteration we are going to Branch out in all four directions from this bad orange the moment we identified a good orange we are going to mark that also as a bad orange and push it down the queue in order to be processed in the next iteration and that next iteration will happen in the during the next minute so this is the second important logic that we will have to understand that how we are going to be processing the the cube now comes the interesting question that how would we know that we have actually isolated or ex completed every single oranges that we could and whether we need to return the minutes or do we need to return minus one so for that during the first time when we are actually iterating over to find all the bad oranges and pushing them on the cube at the same time we are also going to have a counter that stores the number of good oranges we have and what we are going to doing is that let's say in this case we realize that we have four good oranges now every single time we add one value to the B we are going to reduce one element from the good oranges we are going to be doing the breath for search as long as that we can we are able to reach some oranges and then once we get out of our Loop we will try to check that hey uh do we do we still have any more good oranges so in this case uh we would not have any good orang so we can simply say that we did not had we did not find any good oranges so we can return the minutes if we do find some good oranges then we need to return minus one that's it this is the whole problem and this is the whole solution now I know that we can use Q Plus we can use recursion to complete the BFS call also uh for this given M cross n grid we are actually treating it as an adjacency uh Matrix for our graph kind of problem and every single node we are treating it every single node that contains the value of either a bad orange or an orange as a node and connection or the neighbors of each other are being treated as sort of like Edge between them if we see time and space complexity in this case time complexity is going to be simply bigo of V multiplied by E vertices multiplied by edges and for the space complexity well since uh we are not using much space except uh storing a queue the space complexity would be directly dependent on the number of bad oranges or number of total oranges present because in the worst case we might have all the oranges that might go rotten so this is the whole time and space complexity now let's quickly see the coding solution so my solution would make much more sense over there so the very first thing we are doing is to check that if the given grid is equal to null we can simply return minus one if that is not the case we are going to define the values of M and N then we are going to initialize a count called Fresh count this is to store the fresh oranges that we have at the beginning of the cube uh and then we are going to start our queue where we are going to be storing all the rotten oranges that we found so far now the first thing is count the fresh oranges and we are also going to push down all the rotten oranges down to this Cube so we simply use two four Loops to iterate over all the values and uh we are going to be counting that what are all the fresh oranges we found and if we identified that the value is two which means that particular cell position is a position of a rot and or orange okay so now that's good now the very first thing we are going to check is for the Ed Edge case that if there are no fresh oranges we can simply return zero that during the zeroth minute uh all the oranges are rotten if that is not the case we are going to initialize a variable called minutes with the starting position zero and we are going to have Direction uh array to iterate over all four neighboring directions for any particular cell so these are not nothing special just the uh zero and one combinations of adjacent cells and that we can simply add to the current I and J positions now we start our BFS operation where we first check that if the given Q we are going to iterate until the given Q is not empty first thing we are going to check is the size of the given Cube then we are going to check that for any particular given I position while it is less than the size of the que we are going to first of all pop one element out marking it as rotten and then we are going to be iterating in all four directions so notice that with the by using the direction variable we are actually going to calculate the X and Y positions of all the adjacent cells then we we check that are we going out of bounds if we are not going out of bounds then we are going to be turning the fresh oranges into the rotten and we are going to reduce we are going to be reducing the count of the fresh oranges that we found so far on top of it we are also going to be updating the um rotten q and adding those values inside our queue as well lastly we are going to be updating the minute variable for every single new breath first search operation that we make because this is the increment timer for every single level of BFS now in the end we simply have to check that if the given fresh count is equal to zero we are going to return minutes if that is not the case we are going to be returning minus one that's it now let's try to run this code seems like our solution is working as expected let's submit this code and our code runs extremely fast and it beats 99.99% of every single solution which is pretty great pretty awesome once again you can see the coding Solution on our GitHub repository so feel free to go ahead and check it out thank you [Music] so the lead code problem we are going to solve now is called walls and Gates we can see that this uh UI looks slightly bit different than T our typical lead code problems and that is because this is actually a very popular lead code premium problem so that's why I took this uh screenshot from a website called lead c.ca so so whoever is operating that thank you so much now let's understand the problem statement we are given an M cross n 2D grid that is initialized with three possible values first possible value is minus1 so minus1 defines that there is a wall or an obstacle that we cannot cross over next value is zero zero defines that there is a gate and third value is an INF so INF is a very large number basically and if we are given this very large number that defines that the given room is empty so basically we are given three distinct values one value defines that on that particular cell position there could be a wall or it could be a gate or it could be an empty room so for the rest of this problem let's just try to use only these three values so it would make sense for us to understand okay now we need to fill each empty room so each cell that contains the value e with with the distance to its nearest gate so this is the gate that we are given we need to calculate the distance from every single empty room to its subsequent nearest gate and if it is impossible to reach a gate then it should be filled with an infinite value or which means like an empty room so let's try to understand this with an example basically we are going to be given a grid like this that contains three different values uh infinity minus one and 0o but thing is I have presented them slightly nicely over here so let's try to understand and figure out that what does this problem statement is actually asking us to solve so we can see that there are bunch of different empty rooms that are currently given to us and we are only given two different Gates that these empty rooms can try to reach to Plus for some empty rooms we actually have walls that are coming in between so we will have to ignore those walls and try to figure out that what is the best way to reach to those particular Gates so let's just create an empty uh uh like empty M cross and grid and we will try to fill out these values so we can see that for this very first position this one is an empty room so what are the closest gate to this empty room one closest gate is located over here if we calculate the distance this is actually three cells away so in this case uh one option is that we can fill value three over here or if we have to calculate the distance between second it looks like this is very close this see feels like that this is only two steps away but that is not the real case why because there is a wall in between so we cannot cross the Wall so if we have to reach to this particular gate we will have to go down this path and then this path and then this path so that actually makes the total distance as four but thing is we need to calculate the shortest distance so over here shortest distance to the gate is going to be value number three same way shortest distance over here is actually going to be this gate that is this value value number two shortest distance distance over here is once again this gate and that is this value number one now this value is already gate so we can Define it as zero or let me just mark it as gate for our understanding now at this particular position the closest gate is actually this one and this is only two steps away so we can actually mark value two over here same way this is only one step away through this gate same way this is also one step away through this gate same way this is two and this is three and this one is actually four steps away from the gate and that path is actually going to be this one so this is going to be four for all the other ones the walls are always going to remain the walls so we can simply Mark the walls as it is and the gate is going to be as as gate and this is what we need to return as part of the answer uh now for some reason let's try to understand that suppose uh this value is also a wall let's say uh that over here uh let's say that this value is also a wall okay just for the understanding purpose so then now at this position we have no way to reach to a gate because both adjacent doors contains a wall so in this case we are still going to make uh put this as an infinite value or mark it as an empty cell so just for our understandings okay so let's break down the problem in subtask and we will try to calculate the result number one thing we need to check is that distance of any particular cell from the gate this is is the number one thing second condition we have is that if there is a wall we cannot cross so we cannot go to the wall we do we should not consider if there is an empty room we will try to find that how many steps it take from empty room to reach to the gate or from gate to reach to the empty room so now what the approach I'm suggesting is that if we try to calculate at every single gate that or sorry every single empty room that where is the closest gate and if we try to find this one this problem can get like slightly more expensive why because remember that at this gate location we will have to do like either a BFS operation or a DFS operation and we need to keep on iterating over of every single possible Neighbors in order to calculate that where does the nearest uh uh nearest gate lies and it could take potentially bigo of like M cross n times for every single Grid in order to find both the gates in the worst case scenario so this problem can become like M cross n multiplied by m crn that is going to be very expensive problem so rather than finding out the from like distance from empty room and searching for the gates it would make much more sense that from any particular gate we can start iterating over and branching out in like uh different traversal fashion and try to find the empty rooms and for each traversal that we make we simply have to do one iteration because uh we know that it is one step further from the gate in order to reach to that particular empty room so what the approach I'm suggesting is that first of all we simply iterate over the given input array and try or sorry given input Matrix and try to mark all the positions that contains gate we identified that this contains gate now from this gate we start traversing in all the possible directions until we exhaust every single possibility of finding an empty room for the from any particular gate that is option that is number one thing second thing is that we also take care or take into the consideration that if I have to reach to any particular uh any particular empty room how many hops did I had to take in order to reach to that empty room also it could be possible that some other gate can also reach to same particular empty room that then we will try to put the value that contains like the lower value compared to the current value we have as part of the empty room so let me explain the solution then it would make sense now the question is let's say that we identify that these two are the gate positions we know where we are we want to iterate from but the question is how we are we going to iterate are we going to use depth for search or breadth for search so logic is quite straightforward since in this case we will have to calculate how many hops it take to reach to any any particular location we don't want to do the backtrack and keep on going in Just One Direction we actually wants to Branch out in each of the directions so logically it would make more sense to use breath for search in order to calculate our result so if we have to use breath for search we will actually have to use a cube in order to generate the result so idea is we are going to initialize a cube in the cube we are going to mark all the positions that contains the current gate values then we from this particular gate value we will keep on iterating over until the next element and all of its neighbors that we are able to reach that are currently empty rooms we would mark them to the gate as well and we would try to update the value of those empty rooms by 1 plus and the moment we do the next iteration we will add one more value the moment we do the next iteration we will do one more value so let's say that we start our iteration from this value So currently this one is a gate okay these are all the walls that we cannot use or we cannot go go over so let's try to start populating our array using this gate value and see that how is the result we get during the first iteration we are going to go down this path so we know that for both of them the distance is going to be 1 one and currently remember the distance is infinite so we are always trying to put the smaller distance on the place of the gate next is uh next from here we cannot go anywhere because this is a wall we already visited this node and uh so there are no other ways to go but from here we we still have two ways to go down so let's mark the values for both of them so this is going to be two this is going to be two once again from this two we have one more way to go so this is going to be three and from three we have one more way to go this is going to be four that's it we exhausted all the possibilities down this path but over here we still have more paths that we haven't Traverse over so this is going to be three then this is going to be four this is also going to be four then this is going to be five so or sorry no this has to be a gate value so we are not going to do anything so now we exhausted all the possibility as at this gate once again we are going to repeat the same prog process from this gate and try to fill in the lower value so if we Branch out this value actually becomes one because this value is and 1 is less than four so we are going to put one over here then this value becomes two because two is less than the current value we have so this becomes two then this value becomes three because this value is actually smaller than this one so we can mark this as three now from this two if we have to go this way this becomes three but we already have a two which is already a smaller value so it makes no sense for us to go down this path from this three we cannot go anywhere else so that's it now this state actually contains every single possible like distance of empty room to the gate that we have been able to identified and all we had to do is was to use a breath for surge starting at the gate and keeping track of all the graph related princip principle so basically keeping track of all the visited nodes and updating the value from the current position or every single new BFS we make we simply have to add value by one and then we need to Branch out in all four directions where the given gate is uh sorry the given cell value is not a gate and it's not a wall which means any place that is an empty room we need to calculate that what is the distance from a gate and if we do this for all the gates eventually we would left with with what is desired from us that we can return so if we have to understand the time and space complexity in this case the time complexity is going to be bigger of M multiplied by n but we will have to do this by the number of gates that are present and if we see space complexity well we will have to use a q in order to do that and Q depends on the number of elements so it is also going to be big of M multiplied by n and this is what we need to return this is a pretty good time and space complexity and congratulations you just learned an awesome lead code problem uh that is a premium problem and you don't didn't have to pay for the lead code premium so anyways now let's quickly see the coding solution so this is going to be the solution and I cannot run this in lead code because this is a premium problem but I would still paste the solution in our GitHub repository so you can check it out from there so we have our infinite marked as a very large number then we are creating a static position called direction to iterate over all four directions basically this will help us during our breath for search calls now this one is the main method the walls and gate method where we are given the rooms as part of the input we first check for an edge case that if the given rooms are null we can return if that is not the case we Define the values of M and N then we also initialize a new Q which we are going to use to do a breath first search then we are going to find all the gates that are currently present inside our given array by using two four loops and we are checking for the value that is equal to zero after that we are simply going to do a BFS for every single gate where we are checking that uh for this particular gate position what are all the four directions that we can explore into for each of the four directions we are going to check that number one we are not going out of bounds and number two if the given value of room that we are reaching toward the cell is actually infinite then we are simply going to update the value of the distance and in the end we can simply add that value to our Q as well to keep on updating the distance so basically we are going to be storing like the smallest distance possible from every single gate and this is what we need to return uh in the end so this solution would work as expected and now let's uh I won't be able to run it but you will be able to find the solution at my GitHub repository so feel free to check it out from there thank you Hello friends we are still not employed by Fang company so let's not stop lead coding till we get there today we are going to do core schedule lead code problem and this is one of the most versatile problem uh that has been asked at bunch of different companies like huge huge huge number of companies uh we can see the companies like Amazon Microsoft Facebook Google Tik Tok Snapchat Robin Hood twio Uber eBay Tesla all the companies have asked this question and this question is very practical real life application so that's why a lot of companies like to ask this question so this is a lead code medium problem and we are given a number of courses and we are also given an array of prerequisites where any single entity in Array is defined like this where a where we are given two values suppose A and B separated by a common which means that we must complete course B first in order for us to complete course a so suppose we are given an entity in the prerequisites like this 1 and zero which indicates that this course one actually has a prerequisite called course zero so we can Define it like this that course one has a prerequisite on course zero and uh in terms of the Practical manners we first complete this code course zero in order for us to complete this course one and based on the information given we need to check that whether we can finish all the courses or not and if we can finish all the courses depending on whatever the prerequisits we are given we need to return true otherwise we need to return false okay now that we understand the problem statement let's take a custom example to understand the problem suppose we are given the list of prerequisites like this and we are given the number of courses as four which means that we need to complete the 0 1 2 and 3 these four courses we need to complete and this is the list of prerequisites we are given now we can consider this as actually graph problem uh we can consider these as graph Ed nodes and uh the prerequisite information we can treat them as graph edges so over here we can say let's plot it on a graph and let's see that how it would look so over here one has a dependence on Z so I mention this zero has a dependence on three so let's also mention this and two has a dependence on zero so two has a dependence on zero okay so this is how we can plot this on a graph and we need to see that whether we can complete all of these forces four courses or not so the most intuitive solution is to check from the beginning we check at this course number uh zero that can this course number zero be completed or not now in order in order for us to complete this course number zero we see that this course Zer actually has a uh Edge pointing towards course number three which means that course three is a prerequisite for course zero so we need to complete this course three before we can course complete course 0o now with we are at this course three again we check the same thing that whether we can complete the course three or not now course 3 does not have any prerequisite which means it can be completed on its own so we say that okay course three can be completed now again we backtrack to zero at Z we check that do does zero have any other prerequisites that we need to take care of the no 0 is 0 only has one prerequisite on course three which we can complete which means that we are able to complete course zero as well so we can mark this uh and the square box indicate that we are able to complete that course so we are good so we already knowe that zero can be completed three can be completed now we check for this course number one so at course number one we check that what are the prerequisites for course number number one well course number one has a prerequisite on course number zero so we since we already know that course 0 can be completed which means we can uh also conclude that course one can also be completed which me which we can mention over here and we can check for this course number two so course number two also has a prerequisite on course zero which is already done which means we are able to complete course number two as well so in this case for all the four courses we are actually able to complete them and uh we can return true in this case that yes uh based on the given uh number of courses and prerequisites we are able to complete all the courses now we need to check that what could be the scenario if we cannot complete the course so suppose we are given an additional Edge like this in the same example suppose we are given this additional Edge now let's see that how the dynamic would change let me clean this up a bit okay now we have this additional Edge 32 which means that in order for us to complete this course number three we would need to complete course number two as well now let's see that can we complete so initially we would check that can we complete this course 0 so in order for us to complete course 0 we would need to complete course three okay now in order for us to complete course three we would need to complete course 2 okay and again in order for us to complete this course two we would have to complete this course zero so notice that we are constantly stuck inside a loop it's the same scenario where you need experience to gain a job and you need a job to gain experience uh it's some somewhat similar kind of example that we are stuck inside the loop which means that no matter what happens we are not able to complete any of these three courses without completing the other one because there is an interdependence between each other and uh essentially in this case we would have to return false that we cannot complete all the courses but the thing is why do why did we have to return this false well the only the reason is quite simple basically we in terms of graph manner if we speak what was the difference from this graph compared to this previous graph only this Edge and when we added this Edge what essentially we did was we introduced a loop inside our uh graph among these three values 0 2 and 3 so we can conclude one thing that at any given moment if we've identified that there exist a loop inside our graph we would be able to immediately return false if there does not exist a loop and we are able to from every single element we are able to complete all these prerequisits in the that scenario we need to return true so now we have these two information let's see that how can we use them and how can we solve this so suppose we are given an example like this and uh these are all the prerequisites that we are given and we need to complete the six total six number of courses uh in order for us to conclude that this graph can be uh scheduled or not so essentially we are going to apply the same logic we are going to first of all take these inputs we are going to convert them in a graph like this uh inside the graph for every single course we are going to see that whether we can justify these prerequisites or not and uh at any moment if we identify that there exists a loop we will immediately terminate and return false if there does not exist a loop uh we would uh keep going and uh eventually we would return true so that is the idea and in order for us to achieve that first of all what we are going to need is we are going to need some sort of graph data structure because initially the only only two values we are given is number of courses and the set of prerequisites uh so first of all we would create a data structure like uh hashmap and inside of our hashmap we are going to store two values we are going to store as a key we are going to store uh the number of courses and as a value we are going to store the uh number of prerequisites that every single course has so initially we would have so this is the number of courses and these are the prerequisites that we have uh and we would try to see that can we complete all the courses or not so first of all we are at this course zero so in order for us to complete this course z we need to see that what are the prerequisites for course zero uh so for course zero the prerequisites say course two now for this course two what is the prerequisite the prerequisite is actually course three okay and now for this course three the prerequisite is actually course 4 so here and the for this particular course 4 the prerequisite is actually course 5 so here now we are at this course 5 we check that can we complete this course for five and yes we are able to complete the course 5 because there exist an empty list so which means we can conclude that course 5 can be completed over here because there is an empty list so again we backtrack we go back to course 4 at this this course 4 we know that course 5 can can be completed since course 5 can be completed we can also have an empty list over here because it defines that at any moment if we are at this course 4 that course 4 can always be completed because its prerequisites are already met so we can have an empty list over here now again we go back if we go back we are at this course three so in order for us to complete this course three we would need to set up an empty list over here because course 4 can be completed uh that is done now again we come back to the course 2 at the course two again we will create an empty list and now uh we are at this course zero so at this course zero we only have dependence on course number two so we can also have a an empty list over here basically defining that course zero can be completed okay so that is one observation that has been done well and see that we were only trying to calculate that can we complete this course 4 but we already concluded that we can complete these all these courses as well and we have already established them inside our hashmap so at any moment uh we only need to identify the remaining courses and not all of these courses that we have solved already which means we are efficiently improving our solution uh second we come at course one now this course one actually has three dependencies uh course 2 course 4 and course 5 so let's take care of each of them one by one first of all we'll check that from from course one can we complete course two so we check for this course two and we check that the these prerequisites are already met because there exist an empty list which means that we can eliminate course two from over here from the list of prerequisites because we know it can be completed again we check the same thing for this course 4 uh over here this course 4 we again have the empty list so we can also eliminate the course 4 over here as well and again we can repeat the same process for this course 5 that course 5 can also be completed because there exist an empty list which means even at this position course one we can create an empty list over here and now if we look at all the courses the only prerequisites we have are just empty list lists and uh once we achieve that basically we can conclude that we have already reached our solution and we can return true in this case so this solution works perfectly fine but thing is we missed the key point over here like because this was a true scenario we did not identifi any issues but the thing is if there was an a loop we were not actually checking that whether we are en encountering any Loop or not so let's see that if we want to encounter any loop at any iteration what would be the additional steps we need to take so let's modify our example a bit suppose we have an additional prerequisite like this 53 that in order for us to complete this uh course 5 we will need to complete course three so we will have an edge like this and uh let's modify our prerequisites table okay now in this example we know that there exist a loop between this uh 3 4 and 5 so we need to take care of it and in order to take care of it I'm suggesting that we create an additional hash Set uh at the beginning of uh checking for any single course so we create a hash set and in the in our head we just name it as visited or something and over here we will keep track at that at any location are we repeating the same element so let me show you what I mean by that so initially suppose that we are at this course zero and then we start our program so we want to check that whether we can complete course zero or not so first of all we we will check that whether we have already visited this course zero in this current iteration so we check in this visited node uh that have we visited core Zer because it's a hash set it's a constant time operation so we are not adding any additional strain on the time complexity so we haven't visited this node zero we would uh so we would add an entry over here first now we will check over here that what are the prerequisites for this course zero so the prerequisite is course 2 so again we would add we would check our visited node first so course 2 is not part of it so we would add an entry over here and uh again we would continue over here so now we need to check this course three again we would add it uh entry to the visited node uh we check over here we need to check course 4 four we haven't visited so we would add an entry over here uh then we would check the force prerequisite uh five five we haven't visited so which means we would add an entry over here and now at this five we would check the prerequisite for five so for the prerequisite for five is actually three so we are again at this position three so first of all we'll check the whether we have visited this three or not and this time we would know that yes we have already visited this node 3 uh which means that we are in a loop so this is what this hash Set uh confirms and the moment we find out we can imediately return false over here we don't even need to check any additional uh items in this given uh graph and uh we would be able to terminate our case immediately which means and in case if this Edge was not existant uh this entry for this value number five for this value number five we wouldn't have to check anything and uh we would have been able to complete all of our code and we would have been able to return true but which is not the case this time because there exist an additional prerequisite as specified over here so this would be our final solution and now let's calculate the time and space complexity for this one so for time complexity we can actually complete this whole thing in bigo of V + e time because at any moment the maximum traversal we will have to do is from one uh one node to all the single uh nodes and uh throughout all the single edges so this would be the time complexity and space complexity because we are creating an additional uh data structure like this hashmap and also this hash set but the thing is Hash set is going to be smaller so we are only concerned with this hashmap for General time complexity it would be uh sorry space complexity it would be big of v+ e as well and okay first of all we will create a hashmap and we are going to store uh integer and list inside it we will name it course graph okay now we will have to build our graph so essentially we are going to iterate over every single uh prerequisite in the given prerequisites and first of all we will check that whether this prerequisite is already added in our graph or not so if it is added already we only need to append the new prerequisite and if it does not exist we will need to create a new one uh we will have to create a new entry in our course graph so we will create a new list and add the list and then we will add the entry of the course and uh the list to our graph okay so after this Loop ends uh we should have our graph structure ready so now we will create a hash Set uh that will take care of integer values and we'll name it visited and now we will have to run a loop for all the courses that we are given and now we will have to create a method to check that whether there exist a cycle inside the loop or not and uh let's name our method that uh course schedule which indicates that whether we can schedule a course or not in this course schedule method we are going to provide the current uh course the visited node and the graph that we had created and if this response back to false at any given moment we would know that we cannot create the core schedule so we will return false immediately and if this Loop ends and we don't return return false which means that everything was successful and we we can return true okay now we will have to create the score schedule method so let's create a Boolean method now let's uh test our terminating cases so if if our set contains the current course which means that we have detected a cycle so we can terminate immediately so we can return false uh also we check that if uh for the current course uh we if we already have an entry in the graph where it has an empty array list we can return true if that is not the case we will have to iterate over all the prerequisites for any particular uh course so first of all we will add the current course that we are iterating over in our visited hash set then we will iterate over every single prerequisite for that particular course uh we would uh we would call our recursive function so and we will provide the current we will provide the current prequisite we are at we will provide the visited uh headset and we will provide the graph and if at any point this returns false we can return false immediately however if this uh loop executes we know that for that particular course we are actually able to complete uh complete the course and we can schedule it so first of all we will remove it from the visited node and then now since we know that uh this particular course can be completed we would update the entry for that course in our course graph uh so we would Set uh the prerequisite to null which means that in future at any point if we identified this particular course we know that we are able to complete it and we can just move forward quickly and uh at the end we can simply return true in this case so I guess this would be our core schedule function uh where the main logic happens and uh let's try to run the code okay seems like our code is working let's try to submit the code okay our solution works and uh it's it works pretty efficiently so I would be putting this solution in the uh comments you can check it out from there and this was a really long video it took me a lot of time to make it so I hope you like it and let me know in the comments on what are your thoughts about this problem um see you next time Hello friends I'm A Cloud Solutions architect at Microsoft and my aim is to empower every single person to become better technical interviews keeping with that goal in mind today we are going to solve a very important lead code problem so let's get started with the problem so today we are going to do core schedule 2 lead code problem and if you see some of the popular companies who have already asked this question there are companies like Amazon Google Microsoft Tik Tok Apple plantier bite dance Roblox Uber Facebook Robin Hood Snapchat Bloomberg door Dash lift and Goldman Sach so this has been a very popular question at many different companies I'm going to pay my atmost attention I hope you also enjoy the video so this is a lead code medium problem and also very well like problem on lead code in this case we are given two items first item is number of courses now the number of courses it says that suppose we are given number of courses to be three which means that we are given the courses 0 1 and 2 suppose we are given the number of courses to be five in this case the number the courses are 0 1 2 3 and 4 so this is what the number of courses defined second item we are given which is more important is the array of prerequisites now what does an array of prerequisites Define well there can be a structure that looks like this a b what this means is that uh course B is a prerequisite for course a we all know that we need to complete like the prerequisite course in order to go and do the more advanced level courses so in this case if we complete course B then we are eligible to complete course a but say for example for some reason we are not able to complete course B we are guaranteed that we would never be able to take part in or be eligible to complete course a now after having these two items number of courses and prerequisites uh basically what we need to do is we need to return an ordering of courses such that we are able to finish all the courses and what does finishing all the courses means that we are abiding by the list set of or the all the prerequisites that we are given amongst all the courses and uh definitely there could be many different answers to that uh we can complete the courses in many different ways so we need to return any of the valid answer and some for some reason if we are not able to complete all the courses we need to return an empty array so let's try to understand this with few examples so in the first example we are only dealing with two courses so the two courses are going to be zero and one now for these two courses uh we are only given one prerequisite and this prerequisite says that course zero has to be done in order to be eligible to complete course one so if we complete the courses in The Ordering of 0 and one then this is going to be a legitimate answer where we are first we complete the course zero because it has no prerequisites and since we have already completed course Zer we are eligible to complete course one and this is going to be a valid answer so we can return this as the answer if we take the second example this is little bit more complicated now we are dealing with four courses which means courses are 0 1 2 and 3 now in this case if we see there are a bunch of different pre requisites so let's go every single one of them and try to find some answer so first one it says that course zero has to be done before we can do course one okay that that is good second one says that course one needs to be completed before we are eligible to do course two so we have already completed course one over here so let's try to do course two after that then it says that course two has to be done before we are eligible to do course three so over here we are already done with course two so let's complete course three after that so this is one of the valid orderings and in this case if we return 0 1 2 and 3 as the answer this is going to be a perfectly valid answer uh and in this manner we are keeping track of all the prerequisites and we are also completing all the courses let's take one final example so if we see in this final example this is little bit different example so over here we are given three courses so courses are going to be 0 1 and two now we are given some prerequisites so let's try to go through each one of them so first one is 0 to 1 okay we need to complete course 0 in order to complete course one one that's good now second one it says that we need to complete course one in order to complete course two so one we have completed over here let's create uh it for two but now this prerequisites it it's a little bit tricky and the tricky part is that we need to complete course 2 in order to complete course zero which is the tricky part because now if you see there is no way for us to complete like all three courses because every single time we are going to be bounded by some other course because definitely in order to complete course one we need to complete course z in order to complete course 0 we need to complete course two in order to complete course two we need to again complete course one but we cannot complete course one because zero hasn't been done so this is going to be keep running in the round and round and this is a huge problem so in this case we are simply going to return an empty array because we cannot find an ordering that satisfy all the properties So based on my drawings and all the logic I'm trying to show you is it becomes pretty trivial that how we are going to solve this problem uh the way we are going to solve this problem is using graph Theory and for the graph we need two items we need nodes and we need edges so as the nodes we are actually going to use the number of courses that all the courses are going to represent a node in itself and for the edges we are going to take all the values that are present inside the prerequisite table and based on that we are actually going to create an edge and that is going to give us very interesting results now in this case say for an example just consider this example and let's try to draw a graph in this case so first one okay we are given four courses so we are going to draw four nodes so first prerequisite is that we need to complete course zero in order to complete course one which means Zer is actually a prerequisite for course one so we can have an edge between 0 and 1 where 0 is a prerequisite and one is the node that we that needs the prerequisite of zero so notice in this case I'm only drawing one directional Edge why because for 1 0 is a prerequisite so that's why there is an edge between 0 to one but the thing is for zero there is no Edge coming back from one because so far we haven't find that there is a prerequisite in this case so because it is not the case we are simply going to keep progressing now next one is that we need to complete course two in order to complete course one right so so basically from 1 to 2 there is also going to be an edge because uh course 1 is a prerequisite of course 2 and course one has to be done before we can proceed to course two so that is why there is an edge from 2 to uh 1 to two same way we must do course two before we can proceed to course 3 so we must do course two in order to proceed to course 3 and this is also prerequisite and this is a graph that is being made based on the number of courses and the array of prerequisites that we are given now our aim is to find any legitimate offering so for in order to find any legitimate offering the logic is going to be quite simple what we are going to do is we are going to pick any single node and we are going to do a depth for search now in the depth for search we will have to keep track of like two three items first thing we will have to keep track of is that there are no Cycles if we find cycle basically uh we have entered a scenario where we are not able to complete all the prerequisites say for example in this case if we are given an additional node that looks like this or sorry an additional Edge that looks like this so in this case we have actually detected a cycle and because we have detected a cycle there is no way for us to complete all the courses so definitely in this case we will have to return an empty array but lucky for us in this case we are not given a prerequisite that looks like this right so we don't we found no Cycles second thing we need to do is we can pick any single node and from that node if we start iterating over all the all of its neighbors in the DFS Manner and then keep a track of all the elements that we have visited uh by doing that we won't be able to find any cycles and also uh we will try to order them in a manner that uh we match all the dependencies and in the end we simply need to return the ordering so this is going to be a perfect logic to solve this problem uh that we are taking consideration of everything now let's see that we know the core logic that how we are going to use it let's see how we are going to implement it so in this case we have total seven courses that we need to take care of and for all of these seven courses I also have a prerequisite array now based on these two things we know that for any single graph problem we need to we need a way to represent the entire problem in a graph manner so how we can do it is we we have two ways a we have adjacency list and adjacency Matrix right so in this case I think we are good with going with adjacency list rather than adjacency Matrix because the graph is not going to be too sparse and uh so let's try to keep stick with adjacency list now based on this given array we would be able to create our adjacency list now how we are going to create our adjacency list well basically for adjacency list we are going to create a hashmap now inside this hashmap we will have to take care of two values first one is like the key and second one is its value so as a key we are going to take all the courses that are present and as the value we are going to take that which courses like for that particular node for home it is the prerequisite again I'm repeating myself so as the node we are going to take all the courses so basically the nodes are going to be 0 1 2 3 4 4 5 6 7 over here and as its value we are going to see that for what are all the courses it is a prerequisite for so let's try to draw our graph and also fill up our prerequisite uh table okay so based on the given prerequisites we have been able to draw our graph now if we see on the graph uh graph is only for our explanation basically all we will have to do is we will have to create our prerequisite uh adjacency list that I mentioned now in the hashmap these are all the nodes or the number of courses as mentioned and now let's uh try to keep on mentioning their prerequisites so first we'll see that what for what are the courses zero is a prerequisite so from the graph we can actually take a look at this prerequisite array as well the thing is I feel it would be better if we just do it from the graph it would be easier to visualize so in this case basically course one and course two these are the two uh neighbors or these are the two edges that derive from course 0 which means uh unless completing course 0 we cannot complete course 2 or course one because for both the courses Zer is a prerequisite same goes okay let's see for course one course one is actually a prerequisite for course number six okay that's cool for course two okay course two is a prerequisite for course number four and six actually has no prerequisites okay now we have done half of the work we have created our graph now the question is how we are going to Traverse the graph how we are going to make sure that we are finding cycles and how we are going to keep track of all the answers that what should be the correct ordering so these are the three tasks we will have to do the traversing part is pretty easy to solve we are simply going to use a DFS and we will keep on iterating the question is how we are going to detect Cycles uh whether they exist or not in order to do it basically from any single node if we are going to do a DFS we will have to keep track of that at any given position we not coming back to that particular note that from where we started so we will have to find a way to keep track of all the visited nodes so one of the best way to keep track of visited node is using hash set so we are going to use couple of hash sets there is also another trick where we can give the nodes some numbers and uh or some colors where we can treat them as such that whether they have been visited or not but for explanation purposes let's just keep track of hash set when we go to the coding we are going to use it differently now we also need to keep track of the ordering the idea we are going to use over here is that we are actually going to use a stack initially the stack is going to be empty and from whatever the node we started visiting we will keep on visiting until we reach to a point where it does not have any prerequisites or all the prerequisites has been met once we get to that point we would add that course into our stack eventually our stack is going to be full and remember the idea of a stack is that in the stack we keep on adding adding adding all the values when we pop off we pop off all the values in the reverse manner then we added so basically we are adding the first value inside that contains basically all the prerequisites and then we will keep on adding values on top of it so the Top Value inside our stack is going to be a value that contains no prerequisites and uh then we will keep on popping one value at time and in the end we should be able to get our answer so after this long explanation let's see all of these things in action okay so now we have our structure ready uh I have created an adjacency list over here now for this adjacency list first of all we are going to do DFS so I'm going to keep track of that what element we are DFS in over we are for any single DFS that we are doing we will also have to keep track of the current visited nodes that we are going through because during the D d fs we do not want to find any Cycles so if any element appears in the currently visited elements during the same DFS we would know that we have encountered a cycle right suppose we do not encounter a cycle and we reach to an element say for an example like six that does not have any prequisites then we can simply conclude that that node is a good node to be added to the stack so we will simply add it to the stack once adding to the stack we will also add it to the node of visited nodes what this would do is this would allow us not to do redundant work or not to do duplicate work so let's see the whole calculation in action okay so first we are going to start dsing over the first element so we are going to start with element number zero if we start with element number zero what are the neighbors or what are the values for element number zero okay so first value is value number one right so currently we are visiting okay initially we started our visit with element number zero then first element we are visiting is currently one now we are going DFS which means we are going in depth so even for node number one we are going in depth so node number one has uh is a prerequisite for course number six so which means if we want to get to course number six we will have to go through one so now we will go to course number six So currently we are visiting course number six uh now course number six does not have any pre uh is not prerequisite for any of the courses which means this is wonderful so now what we can do is we can conclude course number six to be done so we will take the course number six value from here and we can actually add it to our stack so if we add the value number six to our stack okay now we have added a value number six which means course number six we have already put the ordering for that if we put the ordering for that which means we have already visited that course so we are going to add an entry in our visited hash set now uh for let's go back now if we go back okay we still have one more element one that we haven't processed right so if we check for element one does it has any other U any other prerequisites or is it a prerequisite for anything else apart from Z no so which means this is done so for one we do not have any more courses where one could be a prerequisite which means one can also be added to stack so we will add entry number one to the stack as well and also at the same time we would Define one has also been visited now we go back to course number zero so for course number Z currently we have taken care of this course number one but we haven't taken care of this course number two so we will keep on uh iterating So currently now we would visit course number two for course number two do we have any uh ways to go to next course yes we need to go to course 4 we will have to go to course go through course two so we can go to course 4 now for course number four does is it a prerequisite for anything else yes it is a prerequisite for course number five so in order to go to course number five it we have to go through course number four now for course number five okay course number five uh can go to course number six but the thing is six has already been visited so we can ignore this case if we ignore this case course number five is not no longer prerequisite for any other courses which means now course number five is actually ready to be added to our stack and also visited has set so let's do that we will remove course number five from here we will add that five has been visited and we will add an entry five over here awesome now we have course number four so for course number four okay apart from five it did not add anything else so which means course number four is now also eligible to be added to the stack so we will visit course number four and we will visit course number four to our stack now for course number two let's see if there are any more entries no there are no more entries awesome so now we will put course number two over here as well so two added and also two added two removed from the current stack and now we are back to the course number zero for course number Zer okay we already took care of course number one now we also took care of course number two which means Zer is now also eligible to be added so awesome let's do that so we add zero over here and we add zero over here that's great now if we go back that this has been jumbled up so let me clean this up a bit now in this case Okay uh now we took care of course number zero right now for node number one U we will check our visited hash set so in the visited hash set yes we have already visited course number one so we don't need to do anything course number two has already been visited awesome course number three hasn't been visited so now for our current DFS we will start visiting course number three okay so for course number three it has many different prerequisites uh so course number three okay course number three is a prerequisite for course number one so currently we are visiting course number three let's see course number one okay one has already been visited so we do not need to visit this one four has also been visited we do not need to visit this one five has been visited and six has been visited which means all of the courses which which could lead us to these courses have been visited which means course number three is no longer prerequisite for any other courses so it is a good candidate to be added to our stack and our visited hashset so we can add it to our stack and we can also add it to our visited hashset right awesome now if we see our stack is already full so do we need to worry about adding these more courses or checking for them no but if we want we can do it it would only be constant time because all of them they have already been visited so we don't care now since we have our stack ready let's try to uh pop out all the values sequentially if we pop out all the value sequentially this is going to lead us to our answer why because okay first we have to complete course number three then zero then 2 4 5 1 and six if we complete courses in this manner we would be able to meet our prerequisite so let's see that whether our answer that we received uh is is this a valid answer or not let's compare it with the graph that we created okay so now we have both the values side by side let's see if we start iterating so if we first complete course number three then we would be able to finish lot of different courses so we do not have we won't have any prerequisites for uh okay uh course number all of them have some other prerequisites but if we do course number three there is no harm so that is good if we do course number zero that is also good right now can we do course number two yes course number two only has prerequisite on zero which we have already completed so we can do course number two can we do course number four yes course number four can also be done because we had it had prerequisites on course number two and also course number three both of both of them have been done awesome now for course number five okay five can also be done because it had prerequisites on course number three and course number four both have been completed course number one course number one only had prerequisites on course zero and course number three both have been completed so we can do that and also for course number six it had actually prerequisites on course number 1 3 and five all three of them have been completed before so this is a legitimate valid ordering that we can use and this is a great way to solve this problem see time and space complexity in this case the time complexity is actually going to be big go of v+ e where V is the number of vertices and E is the number of edges and if we see space complexity space complexity is also going to be big of V plus e and uh this is a great example and also the way to find this ordering is also uh topological sort so congratulations to you you also learned a new algorithm so since this video is already too long uh the code solution for this problem I'm just going to explain it and then paste this code in the comment so you can check it out from there okay so first of all uh we are actually doing things a little bit differently than what I explain basically we are creating three different like white gray and black uh Val values so this is going to be assigned to every single node white is going to represent that the node hasn't been visited or it hasn't been touched so far gray means that during the current DFS this has already been visited and black means the code that is already going down into the uh tag or that we have created which means from where we can patch it and use it for the answer now let's go to our main method first first we have this find order method where as an input we are given number of courses and we are also given prerequisites now first thing we need to do is that based on the prerequisite we are actually going to create the adjacency list this is what we are going to create as I explained in the explanation now after this adjacency list we are going to assign every single value to the white color for the first time why white color because it hasn't been added to any list or it hasn't been visited and then we are going to go over every single values of this adjacent list and call our DFS function now what does this DFS function is going to do it is going to recursively call all of the values or all of the neighbors of that particular node until we reach to the end now let's see what happens inside the DFS function uh we receive a node as an input now we have a Boolean value if is possible that is going to check that whether we have been able to find any cycle or not and how we are going to be able to find a cycle by using this gray color so if a node that is already assigned a gray color and somehow in the DFS we find it to be gray again which means we came back to the same node which we have already traversed during our current DFS so there is a cycle present so this is a good way to detect that and for that we just created a different method that if the given color is gray we simply get the DFS method uh we simply assign the values uh is possible to be false okay now in this case first we assign the value to gray for any any particular node that we are visiting then we start visiting all of its neighbors now for every single neighbor we are only visiting the node that the color where the color is white if the color is black we are going to ignore that if the color is gray we are going to assign the value is possible to false which means that this is not possible to do it and we can simply return an empty array in that case if not basically it recursively we are going to call our DFS function for every single neighbor and for every single neighbor we are going to assign the value to Gray and we are going to keep on doing it until we reach to a point where it does not have any more neighbors left so at that time we are going to put the node and assign it to color black and also we are going to assign it to our topological order list that we have created recursively if we keep on doing it basically our topological order list is going to be basically our stack where we would have all the values filled up and once once that is done from our main method we will check that okay if this is possible if that is true which means if this is still possible then we will simply iterate over all the number of courses and we are going to create a new array called order for this order we are going to take all the values in the reverse from the topological order and uh we are simply going to return the order list that we just created and this is the whole solution so I would be posting this in the comments so I hope you understood it and uh if we try to run the code this runs perfectly fine if we try to submit the code the code runs uh decently efficiently and uh yeah so let me know in the comments what do you think about [Music] this so the lead code problem we are going to understand now is called redundant connections this is one of the most popular questions in my opinion why because we are going to be dealing with graphs on top of it we are also going to be learning about the trees a data structure and we will learn a new data structure called disjointed set Union so this problem contains two of the most popular data structures that we already know and one very popular method that can come in handy in all sorts of different cases so let's understand what this problem statement is asking us to solve first we are given the difference between a tree and a graph the only difference between a tree and an undirected graph is that graph is connected and it can have Cycles meanwhile tree is completely connected and it can never have any cycles that is the only difference now we are told that we are given a graph that was originally a tree which means it could be possible that this graph may be not connected or it may contain Cycles okay this is the important clue that originally this was a tree but then it turned graph and now it is no longer tree which means there has to be some cycle existing inside this given graph that contains total n nodes and we are given the number of nodes as to be 1 to n on top of it we are also given an edges array that defines that any particular Edge between any two array 1 to two now the thing is we need to return an edge that if we remove it so that the resulting graph actually becomes a tree of n node that's it so we need to basically remove an edge that is part of the cycle that removing that edge would not have M any impact on all the nodes of this particular graph or tree from being connected and if we can remove that then basically uh there should not be any Cycles inside the existing graph so let's try to understand this with few examples let's say that we are currently given three nodes 1 2 and three and we are given bunch of different edges between between them like this one so in this case we can clearly see that this is not a tree why because there exist a cycle inside this Loop and wherever there is a cycle it can never be a tree so this is currently a graph but imagine in this case if I just removed this particular Edge between the these three nodes then this is a very clear example of a tree why because we can see that it currently has three nodes all three nodes are connected with each other because that is one of the conditions of being a tree that all the nodes has to be connected on top of the connected portion we can also see that there are no Cycles which means that removing 2 to three was one of the good decisions and in this case we need to return 2 Three Edge as part of the answer that if we remove this Edge then we can completely um generate our answer now the question comes that why do we only decided to remove edge 2 to 3 in this case if we had remov an edge let's say 1 2 3 then also the answer would have been perfectly fine we would still have a tree that looks like this but thing is uh we are given in the problem that if there are multiple answers that we can remove the edge then we need to return the answer that occurs in the last input which means like the last Edge in this case made sense to be 2 2 3 so that's why we removed 2 2 3 and not 1 2 3 okay so now let's we already understood that what does the problem statement is asking us to solve basically see we are given a graph that contains bunch of different end points and amongst some end points there exist some sort of uh cycle and we need to first of all detect that which uh particular cells contain are part of the Cycles or which Edge is part of the cycle and then try to see if we are if we are able to remove that edge or not so if we once again take one more example in this case once again we can see that removing this Edge from 1 to 4 makes no sense now why because uh it does not solve our problem number one this is there is still a cycle persisted and number two now we have unconnected components so this is no longer a tree uh this is always going to be a graph so logically in this case the answer once again has to be the same one that we need to remove the edge between this two and three and by doing so we are still going to have a tree like structure where we this one node is part is parent of three different nodes that is 2 3 and 4 and this is what we need to do so once again we need to remove this 2 2 3 now let's understand that what I'm suggesting we use to solve this problem and for that I'm suggesting to use a very popular data structure that is called disjointed set union now first let's understand that what does this disjointed set Union data structure is so this data structure actually has only has two properties but these two properties are very important and very awesome properties so first let's understand that what are the two properties basically disjointed set Union allows us to create a groups of set and uh that's it so it can show us that if we if we have like bunch of different uh objects or values it can show us that that particular object belongs to which group and if we provide two different objects it can sh say that whether those two objects are part of the same group or not so let me explain it to you then it would make more sense to let's say so I mentioned that this disjointed set Union works with two methods first method is a find method where if you provide in some value then it can say that this value belongs to which group okay on top of it second one method is a merge method so for the merge method basically if you provide two distinct uh data structure like two distinct objects that belongs to separate groups then it merges into one common group so let's see how it works let's say that currently I have these three nodes that are part of this one particular group okay and let's say that I have these two nodes that are part of this second second separate group typically in a disjointed Union set all the nodes are typically represented by some node that is currently ly present already inside that particular group so let's say we randomly select that this one is the leader or the representative of this entire group so we will call this as a group one okay that every single node that is currently present is being represented by this value one so we can call this as group one same way over here the representative is this value number four so we can call this as group four where every single node is being represented by group four now we know that we can do two methods we have the find method and we have the merge method so let's say that if I try to do a find method and if I try to find Value number three so if I if I try to find Value number three all I'm going to get in the return is that this value number three is part of this group one so in the answer I would only get value as group one and in the return why because all of these nodes are represented by their parent node or by their represent ative and representative in this case becomes like the parent of all the nodes that are part of this particular group same way if I try to do a find operation and if I want to find Value number let's say five then in this case the answer we are going to get back is going to be group four because this value number five is part of this group four now let's say that we wanted to do a merge operation so the moment we do merge operation between Group 1 and group four then both both of these are going to be merged into one single set one common set and how it is going to operate number one thing this property is going to remain as it is now we have two options which uh who is going to be the representative from 1 to 4 either 1 or four we can pick whoever we like so let's say that in this case we decide that representative is going to be one of this common jointed group so how this group is going to look like that one is the representative it already had values 2 and three so it is going to continue to have values 2 and three that represents or who has parent value as one but same way now we are also going to add one more node four whose parents or representative is now going to become value number one and for this value number five it is still going to have four as one of its parents but now for this newly created group if we try to find that any particular character let's say if we want to find Value number three then for Value number three we are going to say that value number three is part of group one so in the answer we are going to return the value as group one same way for Value number five if we try to do that in this case once again we are not previously we were returning value number four but remember now value number four is also being represented by value number one so once again for Value number five the same property is going to be inherited to Value number five as well and now for Value number five we are also going to say that this is part of group five so this is the whole concept of disjointed set Union but thing is why the hell am I explaining you this concept what does what purpose this serves us now let me show you that how we can use this method to actually solve our problem and very effectively find or detect that whether there exists a cycle inside any particular graph or not or cycle does not exist and remember whenever you have to find a cycle in an undirected graph then this is a very popular method uh in order to do this one so not only we are learning about the Redundant connection lead code problem we are also learning a new method a new algorithm a new data structure with our existing tree and graph data structure and that's why this is a beautiful problem okay so coming back to the solution now remember the problem statement that we needed to find that among these three nodes let's say that if there exist a cycle like among these four nodes we don't know where does cycle exist if there exist a cycle we will need to remove the node that is causing the cycle or sorry remove the edge that is causing the cycle and once we find that we need to return that as part of the answer so let's say that currently we are given this these four nodes okay and we are we are being told that these are the edges we are currently given so what we can do is currently we can can create four separate groups and these groups are not connected with each other so if we create four separate groups how it is going to look like we will have a group one we will have a group two we will have a group three and we will have a group four currently these four groups are not connected with each other so we can actually have a disjointed Union set that is currently present that represents that for every single node who is the representative or who is the parent of that particular node so if we want to Define that currently the we can have a parent array let's say and for every single node we will try to Define that who is currently the parent of that particular node so since this one is being represented by its own so the parent is going to be one same way the parent for this one is going to be two same way the parent for this one is going to be three and so on and so forth so currently all of these four nodes are unique on their own they don't share any parents so far now what we are going to do is we we currently have four edges that we need to deal with and let's mark these four edges so the first Edge is 1 to four same way second Edge is 1 22 the third Edge is 1 2 3 and fourth Edge is uh 2 to 3 okay so logically uh if this is the case now we currently have parent for each four separate sets we are going to go start iterating over the edges for every single edge we are going to check that what are the current parent groups we have and if we identify that they contain separate groups for both the Vertes of this edges then we are going to do a merge operation okay let's so let's start doing that and then you will understood So currently we are dealing with Edge 1 to 4 now for this Edge 1 to 4 we will have to check that which are the vertices involved so number one vertices is value number one number two vertices is value number four so for both of these we we will check or we will do a find operation that who is the parent of those particular sets for one the parent is already one for four the parent is currently four so both are separate sets there is no common commonality so if there is no commonality we will do the merge operation over here so let's if we do the merge operation what will happen is we are essentially establishing a link between this node one and node 4 so by doing the merge operation now we will have to that who is going to be the representative so let's say that we are going to choose the smaller value as the representative so I choose representative to be one now if I choose the representative to be one which means now even for this four the parent is going to be one because four is being represented by one and for the value number one the parent is going to be itself so we will have to make some adjustments to our parent array so this value number one is going to stay as it is that it is currently the parent of its own but for this value number four the parent is going to change and now this is also going to be represented by value number one okay we completed this operation and now we have made the updation on the parent block and we also are done with this one to4 uh Edge so now let's take care of 1 to2 Edge once again repeating the same operation we have two nodes 1 and two and for both of them the one has parent as one and two has parent as two uh we can see over here but now since both are separate so we will have to do the merge operation if we merge these two cells once again we are establishing a link between this one and two establishing a link between one and two now which means we are also updating the parent of this two to be value number one okay and now the next Edge we currently have is once again Edge 1 2 3 so once again for 1 2 3 it currently has one and three as separate nodes uh if we take a look at the parents it is going to be 1 and three if we do the merge operation because they are separate links so if we do the merge operation we are going to have our parents array that is going to look like all four values are being represented by one because we are also establishing this link as well now this is our parents array all four values contain one but we still have one more link that we haven't tested and that is this link 22 3 so let's do that for this 2 to 3 if we see we currently have vertices 2 and three as part but now if when we check for the parents we can see that the parent is going to be common that is going to be 1 and one for both two and three so this is going to be common the moment we identified common parents amongst any two vertices we can clearly say that if we were to create an edge between these two nodes that edge is already part or is going to be part of the common nodes that are already connected by connected in a common set so creating this new Edge is only going to lead to create creation of cycle and the moment we identify any two nodes that share a common parent basically we can just return that edge as the answer and this is the whole solution basically so you understood how beautiful the solution was we first of all understood that how how a disjointed Union set works then we understood that what is the difference between tree and a graph then we understood that how we can use disjointed Union set and its proper to find or update the parent values or create new links between any two vertices and then we find the edge that is causing all sorts of trouble and return that as part part of the answer so this is a beautiful solution and a beautiful approach so now let's quickly see the coding solution solution for this one okay now uh the problem the coding solution for this one is not so complicated so let's try to understand what is being asked us to solve first of all we need to check that for any particular given node we we will have to Define that what are all the different parents so first we are going to initialize a new array called parents and notice that we are setting the value as Edge length + one now we are starting to iterate parent from one not from zero because initially each node is its own parent and we are being told that the current nodes we have are 1 to n not 0 to n so that's why we are starting from one and we are marking all the values as their own parent which means all the nodes are currently individual sets of their own then we are going to iterate through every single edge in order to find the Redundant one uh the moment we identify a new Edge we are going to break both the values in part of two nodes node one and node two for both the nodes we are going to be finding the parents of those nodes node one and node two and for that we are going to be calling our find method that we have defined next um we need to check that if at any given moment we identify that the roots are same for both node one and node two we need to return that edge as the answer because that edge is causing all the trouble and creating the cycle if that is not the case then we need to update the root of that particular second like the parent of second root to become the value of the first root and this is what we are doing is the union or the merge function amongst our two values so let's quickly try to see the helper for function we have created that where we can actually use to find that who is the parent of that particular node basically we are simply checking that if the node is not the the node we currently have if that is not equal to the parent node we are simply going to keep traversing up in order to find that which is the parent node and we are going to be updating the value of the parent node that's it it's very simple and uh we are returning that value so basically uh we should be able to calculate everything now this is just a return statement that is ideally just returning the value zero basically this this should never happen because we are being told that for every single input we do have a graph that contains a cycle and we need to return proper Edge so we should be able to find a scenario like this now let's quickly try to run this code and see see if our solution is working as expected or not seems like our solution is working beautifully let's submit this code and our code beats 100% of all the other Solutions which is awesome in terms of memory usage it is exceptionally well so in both aspects this is doing wonders and this is a really good uh solution Hello friends we are still not employed by a Fang company so let's not stop lead coding till we get there today we are going to do number of connected components in an undirected graph lead code problem this is a graph Theory problem as you you can see from the name and this problem has been asked in one of my favorite companies Amazon LinkedIn Facebook Pinterest Microsoft Google Bloomberg Apple Twitter so these are all my dream companies I want to get get a job at any one of them and that's why I'm making these videos so I would be paying my atmost attention I hope you enjoy the video so this is a lead code medium problem but but in my opinion this should have been an easy problem and if we look at the problem statement we are given n nodes of a graph and we are given a uh an array of edges and those edges are undirected which means if we are given an uh Edge like this that A to B uh which means we can say that we can go from A to B and we can also come from B to a now we need to return return that based on this given input how many different of different kinds of connected component there exist inside the given graph so over here we are given an example with five nodes uh 0 1 2 3 and 4 these are the five vertices of of a graph and we are given some array of edges based on these arrays uh we are able to see that there exist these this is the graph and there exist these two different set of connected components so over here because there are two connected components we need to return to suppose we could have given some example like this that 0 1 2 3 uh so this is one connected uh component inside the graph uh then there is also one more node that is isolated and then there is one more node that is something like 5 six something like this so in this case how many different connected components we can find so if we see over here the number of different connected components we can find is 1 2 and 3 so in this case we would iterate over this given input and we would say that hey there exist three separate connected components and let's see that what could be the intuition behind the solution for this one okay suppose we are given a custom example like this and always remember that it is really important to come up with your own custom example uh in any interviews so suppose we are given a custom example like this where the number of nodes we are given is eight and these are list of edges that we are given now based on these edges we are able to form a graph like this and we can imagine that there exists a graph like this now over here if we just look at it we can understand that there exist uh three separate components that are connected with each other inside this given graph and in this case the answer is going to be three and we need to return return that now the idea is that first of all based on this given input we will need to find a way to iterate over this given graph now to iterating over this given graph can be a little bit tricky and the best way to do it in any computer language is to use adjacency list or adjacency Matrix so you can we can use either one of them so in this case we are going to use adjacency list usually ually we use adjacency Matrix when the number of edges are far more than the number of nodes and we don't have any clear indication that that would always be the case in this scenario so it's better to go with adjacency list now once we have our adjacency list it becomes easier for us to iterate over these given nodes right so we have solved a part of problem but the other part of problem is that we need to find that how many number of connected components that exist now in order to do it uh basically we need to find a way to keep track of whatever the nodes we have visited so far and uh the best way to do is is to create a hash set so suppose we create a hash set and uh we keep track of all the visited nodes that we have we have visited so far now the approach we are going to use is that initially we are going to start at this zeroth position now from the zeroth position we are going to run a DFS in this case then why DFS because the DFS has a very particular property that it starts iterating from one element and it will continue to iterate till it can reach all the subsequent elements or all the subsequent neighbors of this initial uh element so we are not going to stop up until then and how we are going to use visited hash set is let me show it to you so essentially we will start our function with the zeroth position we are first of all going to check that whether the node we are currently visiting is it present in our visited hash set or not so zero is not present right which means we will have to add zero over here so we add zero over here now uh and at the same time we are starting our DFS function from the zeroth position so we are going to have a variable called counter and initially this counter is going to be initialized at zero but now since we have started our DFS function so we are going to initialize our counter at as one now uh from this uh zeroth position we are going to see that okay it has a neighbor one so we will check that whether one exists in the visited hash set or not it does not exist so we will add one over here so now this one has been visited and then uh we have we see that one has a neighbor two so again we will uh come back at two uh two has not been visited so we will add the value two over here now uh all the nodes in in this case have been visited that zero has been visited one has been visited and two has been visited which means we don't have any more nodes to go to so we will just end our Loop over here and now uh in our a list because we have already uh checked this 0 1 and two nodes so we won't be doing anything for them because they have already been visited now we will come at this node number three now again this node uh we are at this node number three and this has not been visited and this is a new starting for the DFS function so every time we do that we are going to uh increment our counter function so now the value of counter is going to be two so we will add the count to to be two and again we are going to to repeat the same process so this three has not been visited so we will we will add an entry over here called three uh from this three it has neighbor four and five so again four and five have also not been visited so we will add an entry over here and once all of them has been visited which means that we no longer needs to iterate over these nodes because they have already been visited and their count has been accounted for and because they were connected so we only need to in increase counter once when we start the DFS function we do not want to increase the counter for all the nodes that are present and once that is done so these all nodes are taken care of now we are at node number six so again we start the DFS functions from the scratch so we will have to increase our counter so we are going to going to increase our counter to uh value number three and now we are going to add the values to Hash set inside our hash set we are going to add value number six so we are done with this one and now we visit value number seven as well and we are done with this one so now essenti we in the in our visited set we have visited all the number of nodes that were originally given as part of input and uh at the end of this we simply need to return whatever the value of counter function we have found so in this case the counter we have found is three and this would be our answer so basically this is the simplest approach it's very easy to understand very easy to uh explain in any interview and I don't know why lead code put this as a medium problem this should have been easy problem as I mentioned it from the beginning now if we calculate the time and space complexity in terms of time complexity essentially we are doing uh couple of things over here so first thing we are doing is we are creating an adjacency list then after creating this adjacency list we are iterating over all the values that are present inside the adjacency list in uh form of graph so the time complexity in this case is actually going to be big of V plus e where V represents the number of vertices or nodes and E represents the number of edges because at any given moment we will have to iterate over all the number of nodes and all the edges that are present uh in terms of space complexity so for the space complexity essentially it's going to be the same it's going to be big of V plus e and why because we are uh storing this uh adjacency list which is essentially the combination of vertices and edges and we are also storing this visited hash set so but in visit in this visited hash set we are only storing the all the vertices so this is actually bigo of V only so essentially the space complexity is going to be bigo of V plus e for adjacency list plus bigo of V but uh generically we can write it as big of V plus e any interviewer would be satisfied with this answer so first of all we are going to create a variable counter and we are going to initialize it to Value zero and now we will initialize an array called visited and I know that I mentioned that we are going to use a hash set but we can also use an array as well and uh initially we are going to initialize this array with the size n uh the reason we are not using hash is because uh it was causing some issues with uh in Java by passing by reference and passing by value so I'll try to probably work upon that uh separately and now we will create an adjacency list and we are going to store uh all the nodes and edges inside our adjacency list we will run two for Loops one to add all the nodes and one to add uh all the edges and now we are going to iterate over every single node and we are going to check that whether that node has been visited or not if not we are going to initialize uh we are going to call basically our DFS function and we are going to increase the counter as well and when this for Loop ends essentially we only need to return whatever the counter we uh whatever the result of counter variable we got okay now let's create our DFS function so first of all we are going to Mark the current node as uh one so we know that we have already visited this node and now we are going to run on a for Loop for all the neighbors of this particular node and we are going to call the DFS function again recursively and notice that we are only calling DFS function for all the nodes that we haven't visited and uh this should be it let's try to run our code okay seems like our solution seems like our solution is working after a bunch of different uh compilation errors let's try to submit this code we have a some solution seems to be working as expected and uh I would be posting this in the comments so you can check it out from there Hello friends we are still not employed by a Fang company so let's not stop lead coding till we get there today we are going to do a very important lead code graph problem uh graph valid tree basically we are checking that whether the given graph is actually a tree or not and this question has been asked in bunch of different top tier companies uh companies like LinkedIn Google Amazon Bloomberg Microsoft and Facebook so these are my dream companies so I'm paying my atmost attention I hope you like you enjoy the video okay so this is a lead code medium problem and we are given n number of nodes we are also given a list of edges and we are told that these edges are actually undirected edges now we need to see that whether the given graph is actually a valid tree or not if it is a valid tree we will return true if it is not a valid tree we will return return false and we are also given an example to understand this problem like in this example we are given these five nodes and we are given some list of edges based on this list of edges we they have shown that this could be a pictorial representation and over here they are saying that yeah this is a valid tree so that's why they are returning true now the question is in order to understand this first of all we will have to understand that what is the relationship between any graph and a tree what is the difference between a graph and tree and how can from the given input we can identify that okay this is a valid tree or not right that every single tree is also a graph but that is not the case for every single graph that it will always be a tree because if I if I put it in V diagram essentially graph is a actually a super set and it tree is just one of its subset so this can be a tree and this is a graph there are lot of cases lot of real life cases to understand that as well like uh the person who got slapped by Will Smith is always going to be a human but not every single human has been slapped by Will Smith it is something in that kind of relationship right now the thing is what are the differences between a graph and a tree that inside the tree all the components are connected all or all the nodes are connected there is no restriction for graph that all the nodes should be connected and the second difference is inside the inside any tree we will never encounter any Loops so we can just say no Loops while inside the graph there can be Loops let's try to understand this with some examples is is this a valid tree actually yes this is a valid tree because notice over here that from one node like every single nodes are connected with each other and we do not we do not find any single Loops but thing is say for example in this case if I had an additional Edge something like this I can clearly see that there exist a loop between these four uh nodes and because we have identified a loop we can clearly say that this though this is a graph but this is not a tree now let's take another example now this is a valid tree like all the nodes they satisfy these two properties that they are connected and there are no Loops the same graph if I had some components like this some additional nodes though they are not connected with all the nodes they are connected with each other or there there are some isolated nodes something like this if this is the case this will always be true that okay this is a graph we can put put it in the category of graph but this will not be a tree and uh in this case we'll need to return false now before we move on towards solution I just have a simple request if you see a lot of people they watch my content but they are actually not sub subscribed to my channel it takes me lot of time and lot of effort to make these kind of videos and I would really appreciate if you can just show your support and uh subscribe the channel like now this problem actually can be solved in so many different ways and I'm going to show you few different ways on how we can do things now the question is what we need to find basically basically we need to find that whatever this given input is is this a valid tree or not in order to find that whether it's a valid tree or not we need to check two things whether all the nodes are connected and uh if there are any Loops or not right so what I'm suggesting is that we break this problem in two parts in the first part we check that what could be the different ways we can see that whether these nodes uh they are connected or not if they are all connected we are good and if they are not connected we can return uh false immediately that this is not a value tree and once that is done we will find all the ways on which we can identify that uh whether there are any Loops or not right so first let's uh go with the first approach now our aim is to check that whether all the nodes are connected or not what could be the different things we can do over here in order to check that essentially what we will need to do is we'll have to Traverse over whatever this given input graph is now traversing over this given input graph based on the structure we are currently given in the input is going to be a little bit tricky uh based using this uh number of nodes and edges so the question is like first thing we need to do is we will need to convert this given input in either adjacency list or adjacency Matrix either of them can be used and it it will work perfectly fine but in this case I will suggest to use adjacency list we only use adjacency Matrix when there are too many edges we don't have any clear indication in this case that there would be too many edges and uh we we would try to use a an adjacency list right so now we are trying to check that whether all the nodes are connected or not and we have already created our adjacency list now what I'm suggesting is that through this adjacency list we know that we would be able to iterate over this in given input and through this given input what we do is we create a hash set inside the hash set initially it would be empty whenever we are at any point iterating over any single node inside this given hash set we will check that whether that particular node already exists in the hash set or not if it does not exist we will add a new entry inside the hash set and at the end once we have traversed all the values inside the given input uh through this adjacency list what we are going to do is we are going to check that what is the total size of hash set and what is the total number of n given if both are same we can conclude that from any single point we are able to reach to all the other elements and because we were able to reach to all the other elements uh all the elements are connected and uh we at least satisfy one condition so let's see that how it would work suppose uh in our adjacency list we start traversing through this position number one right so initially we check that whether this value number exist in the hash set or not it does not exist so we'll add an entry over here that okay uh value number one now through this value number one we can Traverse in two direction we can either Traverse to the neighbor on the right or neighbor on the left so let's say that we go to this node number zero again we add Zero from this zero we go to node number two again we come to two now from this two we can't go any way forward right but the thing is uh we we still need to go back we need we'll need to do backt track we'll go back to one again through one we will go back to three now uh at this three this is not added so we add it over here from this three we will go to four so we will add four over here from this four again we will do a backt track and we will come back at three and then we will come to five and then we will add five over here now at the end of this hash set we are able to iterate over all the elements inside the given input right and we check that what would be the size of this hash set so so size of this hash set would be six and what is the given n so n is also six which means in this case we are at least able to conclude that this given hash set is actually satisfying our condition and inside this given graph all the nodes are connected so we are good now suppose in this case if we had an now suppose in this case if we had another node something like this and this was not connected to any of them basically this would not have been entered inside our hash set and our n in this case would have actually been seven rather than six so we can clearly see that if our size of our hash set is going to be lesser than whatever the number of n we have if that was the case we could have written false immediately because we F found that there exists some not connected component and uh which was not the case in this case so this is one of the very good approaches to identify that whether the graph is connected or not okay now we have taken care of the first part and now we need to take care of the second part that we need to check that whether in the given graph does there exist a cycle or not so first thing that comes to our mind is that why don't we use uh the visited hash set that we have we have already created and in that visited hash set what we are going to do is at any point in time we are going to start exploring from one of the node in the given input graph from that node we are going we are not going to stop exploring till we uh exhaust all the neighbors of this particular graph and at every single time we are planning to come to next element we would first check that whether that element exist in the visited hash set or not if it exists uh then we would we would consider that there exist a loop and we would break out of it if it does not exist we would add that entry over here so first we will add we will start traversing this value number zero so it is it does not exist in visitor so we will add an entry over here from this zero we will uh we'll start exploring its neighbor so one of its neighbor is uh this value number one and remember that we are going in depth for search so we will not stop until we exhaust all the possibility in One Direction before going to the other neighbor we could do it bre breath for search way as well uh it's up to us now from this one again depth for search we see its neighbor that there is a neighbor to so we add an entry over here uh because it does not exist now remember that this is actually an undirected edge so what does an undirected edge means undirected Edge means that from zero we have an edge to go towards one and from one we have an edge to go towards zero same goes from one that we have an edge to go towards two and from two we have an edge to go towards one and same goes from uh two that we can go to zero and we can come back now over here from this position number two because we have an edge that goes to zero we can consider that Z is also a neighbor of two in this case from this two we will try to go to this zero and the moment we try to go to the zero we will see that okay it has already been visited it is part of this hash set so we would say that okay there exist a cycle and uh we are pretty happy with ourselves that we have identified a cycle and now we are done with our case the thing is this is actually a wrong approach and the re why it is a wrong approach that it is wrong approach because there exists this undirected Edge and let me show you by an example that what could be the problems if we keep using this visited hash set only and uh how can we uh how can we find false positives so suppose we are given an example like this that uh 0 calls one and uh two and that's it this is the input we are given right and now we don't have any entry inside our hash map now the thing is all the edges are undirected edges now because they are undirected edges we can represent them in different manner so let's represent them in slightly different manner so from zero we have an edge that goes towards one from one we have an edge that goes to zero same goes from 0 to two and 2 to0 now initially we start traversing from this zero now we we have our algorithm that initially we are going to add the entry to visited hash set so zero does not exist so we add the entry towards our visited hash set now from the zero we need to check all of its neighbor before we move on to some other node now from this zero first of all let's say that we go down this path and we check its neighbor to because there exist an edge like this we are able to check its neighbor right so we are at this position number two now at this position number two we don't have an entry in the visited headset so we enter an entry over here that uh this is two now from this two again we will need to repeat the same process that we will need to uh check for all the neighbors or all the edges that two this two can point to now it does not have any edges that go further but it has an edge that goes back to zero now the thing is in this case again we will use our same logic so from this two we we can still go to zero so we will check that whether we have visited this element zero or not and over here we find that hey we have already visited this element zero which means by our logic that we were previously trying to impose we would have we could have said that okay we have we have found a a cycle a cycle that looks like 0 to two and two to back to zero and we in this case say that hey we have found a cycle and this is not a tree and we will need to return false and blah blah blah the thing is this is actually not the case and why it's not the case is because of this correlation of having an undirected edge that is causing all this problem which means that we cannot rely only on having a visited hash Set uh if we do that then essentially we are not we are not going to be able to find an answer because in this case we know that from there does not exist an edge and from this uh two we are coming back to zero only because there exist an undirected edge from this 2 to Z and that's why we can consider this zero to be two's neighbor but in reality this zero is actually parent of this child 1 and two so if that's the case why are we still doing doing things like this what could be a better approach we can use to find that what would be the solution to detect these Cycles there are a couple of different ways where where you can tackle this problem one way to tackle this problem is that initially remember the only reason we are causing this problem is because there exist an undirected edge which means that there exist uh two directed edges from any two nodes so what we can do is we can put a condition that at from any point if we travel from this one to is zero or two if we are able to travel one in One Direction we would get rid of the remaining Edge and let's see that how it would work so what I'm proposing is that initially uh initially we are at this zeroth position so we check in our visited hash set we don't have any entry so we add an entry over here that okay we are at the zeroth position now from the zero first let's say we travel to one which means that now we have travel from 0 to one in this direction so our aim is that we get rid of this uh reverse Edge in our adjacency list so if we get rid of that now we are at this position number one at this position number one again uh we add an entry over here in our V visited hash now from this position number one what we have to do is we will have to to check that what are all the neighbors that we can travel to or all the children we can travel to but this one does not have any neighbor or children so which means we don't have to worry about anything so over here we can see that okay from this one we can't go anywhere but thing is there still exists some uh some nodes that we haven't traveled to and we are using either BFS or DFS in any manner to Traverse over entire graph right so which means that we will have to do a backtrack so now from this one we do a backt trck now again we end up at this zero but thing is in this scenario remember we are not ending up at this zero because from one there existed an edge like this where we consider zero to be one's neighbor we are coming back to this one because we are using backtracking uh through any BFS or DFS algorithm uh we can we can implement this recursively or iteratively doesn't matter in any scenario we will have to iterate over all the nodes that are present inside the given graph and since we have haven't traveled all the nodes that's why we are coming back to the zero so again this would be a new entry in the visited hash set so again we come back at this zero and this zero we check that okay we have already explored one of the neighbor of this zero but we still have to explore another neighbor so again we repeat the same process from the zero we explored another neighbor of zero we come back at two and immediately we get rid of this uh this Edge that was coming back to it and then we add an entry over here that okay we are at this position number two now from this two again we don't have any more neighbors to go to so now we have explored all the neighbors of one so we can mark one as being done uh we have explored all the all the neighbors of two so we can Mark or two as being done and now we come back at this zero and we can Mark zero as being done because we have explored all the neighbors of zero possible as well and in any scenario we did not find any single Loop because we did not find repeated value inside our visited hash set so we can determine that there does not exist a cycle and which means in this case we can return true because there are no Cycles so we can say that there is no Loop for this one and the only reason we are able to come up come up to this conclusion is because at every single position we were removing the edge where in One Direction we have already traveled so that is one way to take care of this problem and uh this solution would work as expected as well right now the thing is there could be another solution where we can use the little bit different logic little bit different data structure and we can do things in better Manner and let's see that what would be that approach so the second approach is that rather than using this visited hash set we don't have we don't need to do anything with this visited hash set let it be used for the purpose of counting that whether all the elements are uh connected components or not uh what I'm proposing is that we created another data structure a hash map and in that H in this hash map what we plan to do is uh we as a key we have parent and as a child we as a value we have the value of its children now let's see that how could how can we use this combination to do things a little bit differently also over here let's say that we are given a graph like this that zero 1 2 3 something like this right so 0 is connected to 1 1 is connected to two two is connected to three and now we have this three connected back to this one as well which means that there exists a cycle over here now because these are undirected edges which means that they are bir directional edges as well so from this zero we can go to one from this one we can go back to zero and blah blah blah whatnot so initially let's say that we are at the zeroth position from the zeroth position we starts exploring its neighbor or children or whatever you want to call so the moment from this zero we are able to reach to this one we would add an entry over here in this hashmap and the entry we are going to make is that uh zero is actually a parent in this case and one of the children that we could find for this zero is actually node number one so node number one is a children of uh zero and just stay with me that why we are using this approach now again from this node number one we need to explore its neighbors right so what what are the neighbors of this node number one we can explore neighbors based on the number of edges that goes out from this node number one so from this node number one we actually have two edges that goes out first Edge is that from this node number one we can go to node number two now we check in this hashmap that does node number one exist node number one does not exist as a key so we add an entry over here so we add we say that okay parent is one node number one and from this node number one we can actually travel to node number two so we are good with that now again from this node number one we still have possibility that we can go back to this node number zero so again we check in this hash map okay that whether there exist an entry for this node number uh zero that we are trying to reach remember this very importantly we will check that whether this node number zero that we are trying to reach from this node number one does it exist in the hash map or not okay so zero exist in this has in this hash map again we check that from this one we are trying to reach to this zero is this one one of the children of this node zero or not in this case yes one is the children of node number zero if that is the case we can identify that this connection from 1 to zero is actually not a cycle it's just a trivial Loop and that is being caused because there exist an undirectional edge on both the sides so that's why we will ignore this case we will ignore this connection we are not removing the edge again remember we are not removing Ed we are just ignoring this case because in the hash map we are able to find that okay this 0 to one connection is actually just a trivial cycle and we move on with our life so from this one again since we have reached to this two right and two is not existing and uh two is one of the children of one now again we are at this position number two now again from this position number two what are the different ways we can travel we can either go back to one or we can go to three let's say that we go to three first so we check that whether three exist inside the hash map three does not exist which means we can create an entry that where two is a parent and three is a child we are good with this so far now again from this two when we try to check that from two we are trying to go back to one is that is that a cycle so first we check that whether this one exist in the hash map or not so one exist in the hash map over here and two is one of its children so because two is one of its children we are going to ignore this case and we are going to uh ignore and because we are ignoring this particular we are just going to move on with our lives now we are at this position number three from this three we will check that okay what are the different places we can travel back 2 so from this three we see that okay one Edge that goes to one one Edge that goes to two first of all let's see let's explore this Edge from 3 to two uh so over here we will check that we are trying to reach to this node number two so two already exist and three is one of its children which means we are going to ignore this Edge so we don't have to worry about anything now again from this three we check for this value number one so okay from this three we try to see that whether we are able to reach to node number one or not node number one has already been visited inside the hashmap and that's why we are able to determine that there exist a loop inside over here from where we are actually going back to one of the places that was actually uh not uh that is already been visited in inside our hash map and this hash map acts as both it acts as a visited uh hash set that we were implement we were planning to use and also it acts as a way for us to determining that whether we are detecting the correct Cycles or we are detecting the trivial Cycles between the unid directional edges and this would be a way on how we can check the Cycles which means that the combination of this using this hash map to identify that whether cycle exist or not and using this visited node and iterating over using BF BFS or DFS inside our graph original graph uh using these two data structures we can actually com we can get rid of both of our cases where we need to check that whether the graph is connected and we need to check that whether the graph contains any Cycles or not and once because we are able to do both of these things at the end if we are able to reach to end node we will return true if we are not able to reach to end node we can return false and this solution actually works perfectly fine there are no issues with this solution it is a very elegant solution if you tell it in any interview they are going to be very impressed with the depth and breadth of your uh thinking capabilities what are the space and time complexity over here and and can we do something better so let's uh first try to determine that so space complexity in this case we we know that we will have to use a hashmap and we will have to use the visited array as well inside the hashmap we are going to iterate over all the nodes plus all the edges which means that over here the space complexity would be big go of V plus e because we are iterating over all the vertices and all the edges the time complexity in this case would also be big of V plus e because we'll have to iterate over all every single node and every single edge multiple times in order to come to this solution but the thing is we are not doing Loop inside loop work so which means we are not doing repetitive work at any given moment okay after such a long explanation let's see that there can there be a better approach and yes there is actually a very elegant very beautiful solution where actually we don't even have to go through all of these mess to detect that whether Cycles exist or not in order to do that actually we need a higher knowledge of uh graph Theory what do I mean by that okay uh at any given moment suppose we are given a graph like this that 0 1 2 3 four suppose we are given a graph like this right now if we want to identify that whether this is a tree or not like in this case we can clearly see that yeah this is a tree there is a very legitimate scenario there are no Cycles all the nodes are connected and blah blah blah what not everything is good with this right can you notice an important property over here the important property that I'm talking about is if you count that what are the number of nodes and what are the number of edges does there exist a correlation Yes actually there exist a correlation and the correlation is that suppose we are given the number of nodes equal to n and if we are given the edges that are n minus one and we determine that all nodes are connected if we determine that all nodes are connected because remember in our solution when we are trying to find finding that whether the nodes are connected or not is much simpler we simply need to use a hash set we need to iterate over whatever the given input we have and uh basically we can mind that okay whether the nodes are connected or not but checking for the cycle is slightly more complicated actually not slightly much more complicated because either we have two options and both options require us modifying lot of things or managing a bunch of different data structures either we can choose to remove the remove the edges like this or we can choose to create a hash set like this in both the cases we are actually doing a lot of work so what if we actually don't need to encounter that whether we need to find the Cycles or not if we only encounter that whether the given nodes are connected or not if that is true and at any given moment we identify that okay all the nodes are connected and then we identify this property that whether the number of nodes that are given and number of edges that are given if there is the difference between them is only one if that is the case then the given graph will always be a tree let's see in this scenario in this scenario we can identify that okay from this zero all the nodes are connected that this 1 2 3 and this four we are able to connect to all of them right uh how what is the number of nodes so number of nodes in this scenario is actually five this 1 2 3 4 5 now let's see that what are the number of edges so if we calculate the number of edges the number of edges is okay this is one Edge this is two second Edge this third Edge and this is fourth Edge there are only four edges that are possible if we have any more edges then for sure there would be a loop because remember where would you add an edge in this scenario you can add an edge over here okay there creates a loop uh let's say that you don't add an edge over here suppose you add an edge over here again it creates a loop well you don't have an add an edge over here you add an edge like this so again this creates a loop like this eventually as long as the the difference between the number of nodes and number of edges is actually not exactly one and if the the number of nodes are one number higher than whatever the number of total edges are given if that is the case and we determine that all the nodes are connected then we can clearly say that okay everything is good with our life and we don't have to worry about anything why now why we need to check that whether all the nodes are connected or not the only reason we need to check if all the nodes are connected or not is suppose we are given a scenario like this that we are given these three uh these three nodes suppose we are given these four nodes right and in this four nodes so remember our equation is that number of nodes and edges so if nodes are four and if edges are three so we can say that okay everything is good with our life in this case the number of node is 0 1 2 3 okay so total four four nodes we are good number of edges 1 2 3 so this is also good the thing is over here you can see that there exist a cycle over here between these three edges and why there exist a cycle because this particular node is not connected so always at any case we will have to check that whether all the nodes are connected or not and once we identify that all the nodes are connected we are good and then we can just uh wrap up our solution so using this solution actually everything becomes so smooth that if we calculate the time and space complexity the time complexity in this case is actually big go of n because we only need to iterate over the in given in number of nodes and where n n defines the number of nodes if we calculate the space complexity the space complexity is also bigger of n because we only need to maintain a hash Set uh to take care of what all the number of connected edges so once we find out that what are the number of connected if all the elements are connected we can immediately identify that whether this given graph is a tree or not so let's move on towards coding now now first of all we are going to check that whether the given number of edges uh it's if its length is uh one less than the number of nodes or not if that is not the case we can return false immediately so and if that's not if that doesn't happen we will have to make an adjacency list so we will create an adjacency list so it becomes easier for us to iterate over the given input array so for all the given n we are going to treat them as vertices and all the values that are provided in the edges we are going to treat them as edges basically notice over here that we for every single edge we are actually adding two entries inside our Regency list and that is because the given edges are actually undirected so that's why we will have to add an edge for both the nodes uh so if there is an edge between 0 to 1 so we will have to create two edges and the those two edges would be zero uh to one and from Node 1 to0 so that is what we are doing by the second for Loop okay now we will start iterating over the given graph inside the adjacency list and uh I want to learn that how to iterate over the graph using stack so I'm going to uh do it using stacks and I will be doing iterative depth first search so first I'll initialize a stack of integer values and just name it as stack and we will also have to create a hash set of uh integers called visited inside our stack we will add the first entry so we will add the node zero and inside our hashmap visited we'll mark the first node as visited we will pop the first node that is inside our stack and then we will start iterating over its neighbors and we'll see that if that uh neighbor has already been visited then we will simply ignore that case if that is not the case we will start iterating uh we will start adding those neighbors to the to our stack as well and we will also add that neighbor to our visited hashmap as well it would be neighbor not node okay and after this Loop ends we only need to check that what is the size of our hash set so if or else we will return false and uh let's try to run the code okay seems like our solution is working let's try to submit this code okay our solution works pretty efficiently Hello friends I'm A Cloud Solutions architect at Microsoft and my aim is to empower every single person to be better at technical interviews keeping with that goal in mind today we are going to do a very interesting lead quote problem called word letter that has a real life application because this is a game by self as well and if you see some of the popular companies who have already asked this question there are companies like Amazon Bloomberg LinkedIn Microsoft Google Uber Apple Facebook lft bite dance and Goldman sex so that's why I'm paying my at most attention I hope you also enjoy the video so this is a lead code hard problem and also very well like problem which is a rare combination to be seen now in this problem we are given two words a begin word and an end word and we are also given the list of words called dictionary or word list now our aim is to reach or go from the begin word to the end word by a transformation sequence the question is how does this transformation sequence Works uh well the transformation sequence works is that suppose we are currently at word one uh we can only jump to word two if the Chara the difference between the characters is only one so say for an example if we are given a word like cat and we are given the second word like C C we can go from cat to cot because there is only difference of a single character a the C and T are common across both the words so this is a valid transformation sequence the idea is that from the begin word we need to keep on doing the transformation sequence amongst many different words and our aim is to reach to the end word somehow and if we are able to do it we need to see that what is the minimum number of ways we can do it and these words they has to be present inside the word list that we are given so we cannot just create words out of fly this is this is the purpose of this word list uh set that we are given that we are given bunch of different words and if somehow we are not able to reach to this end character uh using the transformation sequence we need to return zero and if we can we need to return the minimum number of hops needed to reach to there so let's try to understand this with couple of examples if we see this first example here the begin word that we are given is called Hit and the end word is cog and these are the different words that we are given so one of the ways we can solve this problem is by creating a word sequence that looks like this in this case we are starting from the first word and we are reaching to the end word and these are all the different hops that we are making using the transformation sequence so this is a valid example but if we see in this case we are actually taking six different hops to reach to the end word can we do something better and the answer is yes there is exist a better solution for for this problem so let me quickly show you the better one again even for this example we are able to reach from this beginning word to the end word but in this case we are doing the whole journey by only five different hops so in this case we need to return return five as the answer because we are only taking five steps to reach from the first word to the end word and this is going to be our word lad uh if we take a look at the second example in the second example the word we are given is hit and again end word is cog so that is true but the thing is in this case we need return zero why we need to return zero well because this Cog is actually not at all present inside this word list that we are given so since the end word is not present we cannot reach to the end word so basically we need to return zero so I hope this explanation makes sense and you are able to understand the problem statement now let's see that what is going to be the approach we will take okay so before we come up with the optimal solution first let's see that what kind of pattern we can see in this problem basically we are given a beginning word and an end word and we are told that there are some series of words that we need to go to in order to reach to this end word and we need to return the minimum sequence possible Right the thing is in this problem we are not only guaranteed to given all the words that would be used between this beginning and end word and it could be possible that we are given some different words that are not being used or they can be used but thing is that leads to like a longer answer and we do not need to like go through all of of them and we only need to find the shortest path now if you see this kind of structure what does this reminds you of well you are absolutely correct this is actually a very similar structure to a graph where you can see the words that are given they can be treated as different nodes and the relationship between those these nodes can be treated as edges so we have our vertices and edges and we have a way to define edges now how does an a vertices connects to an edge a vertices connects to an edge through the mechanism that the number of characters of word one on and word five in this case they only have one differing character and that's it that is the only way we can define a relationship between them once we have a structure like this ready now let's see what is our aim our aim is to find a path from the beginning word to the end word and if we want to find the path what we can do is we can simply iterate over the given input and see that what are the different paths we can take and try to find the most optimized path or the shortest path that leads us to the correct answer so in this case we can actually find two different paths that leads us to the answer first one is the one that I indicated in blue and second one is the one that I indicate in this purple color now in both the cases this path is actually the shortest path that leads us to the answer and in it to in in the end we need to return return the distance between the words amongst these paths so in this case the answer is going to be five but you get the idea that basically we can if we are able to generate this graph structure then all we need to do is just we need to do the breath for search traversal and the question is why breath for search because we are trying to find the shortest path and if we do depth for search it could be possible that in practice it might take us longer so breadth for search would be a better candidate in this this case so if we are able to create a graph structure and if we do the breakf first search we can actually find the shortest path okay so now we are going to use the same example that we have been given as the input now first of all we need to find that uh the beginning word that we are given is the word hit right and say for example we device some mechanism to easily Traverse through these words to make sure that whether these words exist or not right now the question is from the hit we are treating this hit as one of the nodes right now we need to find that what are all the different edges this hit is able to connect to the idea we can do is that uh we can see all the possible words that this hit can have with just one differing character the logic is we can start with the first character and keep all the characters from a to zed and then keep the remaining two constant so what we will do is we will try to check for the words such as uh AIT then bit T all the way up to zit right these are all the different words we can make then same way we can keep the H and T common and then uh do a b c all the way up to zed and we we can keep on repeating the same process so basically at every single word what are the different possible words we can have well uh say for an example the if the length of this is equal to M then basically we can have M multip by 26 differing characters and or differing word possibilities now amongst these 26 word possibilities all we need to do is we only need to find the words that exist inside this word list and since this is a dictionary basically we can access pretty fast and check that whether any word exist or not we can do it in constant time so this is not going to be an extra overhead so by using this logic we are actually able to generate all the graph pairs for our given input so first value is going to be hit and now let me just quickly draw the graph structure okay so we can actually make a structure that looks like this and this is a pretty decent representation of the input that we are given now this is going to be our start node and and this is going to be our end node or the beginning word or and the ending word now basically we need to iterate over the given graph and we are also going to keep track of all the notes that we have visited so far uh that is to uh not end up inside any uh like unexpected Loop or infinite Loop now all we need to do is from starting point we already mentioned that we are going to run a BFS and we are also going to have a variable called Min that is going to keep track of what is the minimum path we have found so far so if we just see the input one of the path we can take is that we start from hot or hit and then we can go down this path and uh eventually we would be able to reach to the end word so in this case if we see and definitely we are going to keep track of all the visited nodes and everything is going to be taken care of if we see this path basically it is going to take us six words and currently this is the minimum value we have because we haven't identified any other path right so six is the correct answer now what let's see that if there is any second option that we are missing so yes there is another option that we are missing and the option is that if we start from this hit we can go down this path and through this path the number of words we encounter is actually five so because we are encountering five words basically we need to update the minimum number of answer we can get let's see if there is any another path that we can take that we are missing and yes there is also still one more path that we haven't taken and the path that that looks like this and in this path also we are encountering five words so again the answer is going to remain five and we have explored all the possibilities so in this case we can simply return five as the answer because that is what we need to create and you see once we have this graph kind of a structure ready things becomes much easier to comprehend and we can simply written the answer pretty fast pretty efficiently so this is the whole logic behind this problem now uh in this problem currently we are only going in just one single Direction uh but uh in practice there can be like a bir directional uh BFS where uh we start iterating from here and we also start iterating from here and we can do like BFS from this direction BFS from this direction to reach somewhere in the middle and to find the answer and uh we we can do things slightly faster in that cases but I don't think anyone is going to expect you to do this in any of your interview so don't even bother uh if we see time complexity in this case the time complexity is actually going to be biger of uh M so m is the number of length of any character and I mentioned that length is going to remain constant amongst all the word List characters so we don't have to worry about that so number of M squ now y m sare m Square uh is taken in order for us to generate uh the this graph like structure so it takes big of M Square time and uh for every single character there can be uh one possibility that we need to it because we know the starting and ending point so basically it's going to be m² * n uh in terms of the number of time complexity where n is the total number of words given and if we see space complexity well basically we are anyway storing this graph like structure and that is going to uh uh give us like the go of M square space so we also need to take care of that so in my opinion this was a tough problem but once you know the logic you can solve it easily and this shows this goes to show you that if you know the logic about different data structures things becomes much easy because this word lad game is actually a real life game that people use and people play so yeah this is not just a random out of the blue question now let's move on to the coding so since this word letter problem was already becoming such a big uh video so that's why I'm just going to explain you the code rather than typing all of it and I will go through the explanation so first of all we are going to initialize a variable to note down the word length because that is pretty important and we are also going to initialize our hashmap that contains the information of all the combinations inside the dictionary that could be possible uh now what we are going to do is for every single word that is present inside this given word list we are basically going to iterate over all of its characters and we will try to see that for all the differ differing characters uh what are all the Transformations possible and whenever if a transformation is possible we will basically add it to our all combination dictionary because this is a hashmap inside the key we are going to store the value that is being present and uh inside the word list and and as its subsequent value we are going to have a list of all the possible combinations that any particular word can have so this is going to give us our uh dictionary and uh this is going to take basically M Square time to do it or L Square time to do it now in order to iterate over the breath for search we are going to have our que where we will keep on adding or we will begin with the first word and we will not rest until we have iterated over all the neighbors of this first word and we will keep on repeating the same process iteratively so we are not doing recursion we can do recursion but we are doing it iteratively and also as mentioned that because we do not want to get inside a position where we end up in in an any infinite Loop we are basically going to create initialize a hashmap and now we are going to basically put the first word or the begin word that we are given as the input and then we will start iterating over our given cu uh in the BFS fashion so first of all we are going to create a pair or so first of all we are going to uh remove the node in that is ex existent inside the priority que and then we will try to get its word value then we will see that what level it is and basically uh we will iterate over all of the different word possible words that uh can be present and we will keep on repeating the same process for all the adjacent words and every time we go to the new level we are basically going to increase the size of the level so this is going to return us that how many different paths that we have taken so far and somehow if we if we get out of the loop then basically we need to return zero so this is the whole logic behind the whole problem and uh this condition refers to if we have reached to the end word and this condition refers to in in the scenario where we have not reached to the end word we have we are somewhere in the middle so basically we are going to add a new entry inside our queue and we are going to increase the current level we are at so I think this solution makes sense I would be posting this code in the comments so you would be able to check out the code don't worry about it uh let me try to run this code and our solution works as expected let's submit this code and our code runs decently efficiently in terms of space complexity and time complexity both are really good and this is the BFS solution uh from the lead code [Music] so once again we are going to do a very awesome lead code problem this one is a Rec construct itenary we can see that this one is a lead code hard problem also constructing an itary is actually a very popular real life use case that we see in like uh aviation industry all the time so this is an important problem let's pay our atmost attention now we are given a list of airline tickets where any particular position uh we are given like a tle value inside the array that defines that where what is the departure and arrival for locations based on that particular unit now we need to reconstruct the itary in and in like a particular order and return that reconstructed itary now let's see that what are the constraints around reconstructing the itary number one thing is all the tickets belong to a man who departs from JFK which means JFK is the starting position for our entire itary then uh next thing is that if there are multiple valid itineries that we are able to construct then we should return the itenary that has the smallest lexicographical order so what does lexical lexicographical or lexical order means it means that uh we need to sort them In Like A to Z manner basically uh which means uh if we let's say if we have two tickets first one is from JFK to LGA and second one is another ticket from JFK to LGB then we must return LGA first before returning LGB because remember that we are sorting lexico graphically so this one has character a and this one has character B so a comes before B which means this has a smaller lexical order so we need to uh put this in priority now we are also told that we may assume that all the tickets are valid and we must use all the ticket once and only once so let's try to understand this problem uh and try to see that what could be the potential Solutions number one thing is this is the type of input we are given now we can see that there are bunch of different tickets we are given in this case we are given a ticket that uh is from Munich to London hro we are given a ticket from JFK to Munich then San Francisco to San Jose and London hro to San Francisco so these are the five tickets we are currently given I have just plotted all the five airports over here and now let's see that what is the solutions we can make so let let's just take a simple approach and uh let me just keep on marking all of these nodes uh or like all the flight connections so we know that we have a connection between Munich and London Heath so let me mark this one then we have a connection from JFK to Munich so let me also Mark this one then we have a San Francisco to San Jose so marking this one and then we have London Heath to San Francisco so let's mark this one so this is a valid order we can see that every single ticket we currently have that are four tickets we have we used all of these four tickets over here after using all of these four tickets we need to reconstruct itary starting from JFK so we can see that if we start our jour from JFK the direction is going to be JFK to Munich then Munich to London he he to San Francisco and San Francisco to San Jose this is the reconstructed itenary that we need to return in this order let's take one more slightly complicated scenario so we have uh like bunch of different tickets in this case and we only have three airports to deal with so first ticket is JFK to San Francisco so let's just mark this one so JFK to San Francisco this is one option second option is JFK to Atlanta so let's mark this one then San Francisco to Atlanta okay then Atlanta to JFK okay and then Atlanta to San Francisco okay so currently these are all the different options we have now let's see that what is the optimal option we need to choose we need we know that we need to start our journey from JFK now notice at JFK we have two different tickets going outwards first ticket is going to the San Francisco and second ticket is is going to the Atlanta so question is which ticket should we choose now here comes the lexico graphical ordering that we need to pick from and we can see that a Atlanta is lexor graphically smaller than San Francisco so we are going to pick ATL first so in our path this is going to be the first path we are going to take all the markings that I'm marking with red is like the correct marking okay so we took care of one ticket then from Atlanta once again we have two options we can either go to JFK or we can either go to San Francisco so once again it makes sense to pick the smaller amount and that is once again going back to JFK so let me let us go back to the JFK now at JFK we only have one option that is go to San Francisco so we go to San Francisco and then from San Francisco now we only have one option that is to go to Atlanta so we go to Atlanta and now from Atlanta we still have one more Edge that is remaining and that is to go back to the San Francisco so we will once again go back to the San Francisco so this is the sequence we are going to follow where first we are going to go from JFK to Atlanta then this is the second this is the third this is the fourth and this is the fifth flight we are going to take so this is what we need to return return now I know understanding this question took way longer than expected but don't worry the solution is not that complicated so let's just try to understand a simple logical scenario just for this particular input that we are given what is the one thing that we did to solve this problem well it is quite obvious what we did to solve this problem we first of all Mark that from every single airport what are all the different possibilities we can take and then we started iterating over our journey from JFK on top of it not only marking the all the different possible Journeys we also Mark that what under what order should we start picking uh uh and start moving in in any particular direction so what I'm suggesting in this case is that we are only given the tickets we are only given these values from any particular two nodes what I'm suggesting is that we actually treat this as a graph problem and which is pretty obvious why are we treating it as a graph problem through this one we are going to be marking every single airports we currently have as the nodes and all the tickets that we currently have as the the edges okay we already got our nodes and edges on top of it what we need to do is we need to iterate over the given graph now iteration of the graph is quite simple we know that we have two methods we have a breadth for search method and we have depth first search method now in this case going in one particular direction makes more sense because notice that over here we are going in like a depth for search fashion even in this example we saw that we were doing bunch of different back and forth in order order to complete all of our transaction and that was also being done in depth for search fashion so in this case we are also going to be using DFS to iterate over all the nodes next thing is we need a starting pointer to iterate over we already have a starting pointer and that is starting from the JFK so we know that we first of all need to treat it as a graph we will need to do a DFS we will need to start iterating over from JFK next thing is when we are constructing a graph we will have to set up ordering in which sequence are we going to go to any particular airport and for that we will have to follow the lexor graphical ordering so for that what I'm suggesting is that we actually use an adjacency list kind of a scenario where we store the adjacency list uh for our graph and we do it in lexor graphical ordering so what I'm suggesting is that we initialize a hashmap as part of the hashmap we need two items key and value as part of the key we Mark the nodes or the airport as part of its values we Mark that from that airport how many different tickets that we can Traverse over so or how many different airports or destinations we have okay uh then once we have these two values then we need to populate these arrays so let's start populating this value uh for this given input okay so currently let's go one by one in these uh throughout all of these tickets so first one is we are starting from JF JFK so one node is JFK okay now from the JFK we need to have a ticket uh the destination is San franisco so let me Mark this as SF then we have one more ticket from JFK and the destination is Atlanta now we know that JFK is already present the thing is we are trying to insert Atlanta over here so one logical thing is that rather than just doing anything let me just create a link list over here where I'm storing Atlanta as well that from JFK I have one more ticket that goes to Atlanta okay same way we have a San Francisco and the destination is Atlanta so let me also do that and we have Atlanta and JFK so Atlanta and JFK okay and last one is Atlanta to San Francisco so we are going to have one more destination San Francisco from Atlanta now we have our uh key or our graph uh like our adjacency list being created okay inside our hashmap but the thing is we need to sort this in lexico graphical manner so what we are going to do an intermediate step where we are simply going to update this given uh graph that we have created so far and for this one we are simply going to sort all the values or all the inputs we have in the destination in lexicographical manner we know that this can be done in N log n time so we are going to spend that extra time in order to complete that so let me just start marking this one so first entry is JFK okay for JFK we currently have two values first one is San Francisco and second one is Atlanta but this is not sorted correctly so we are going to sort it first one is going to be Atlanta and second one is going to be San Francisco as this is going to be the sequence of Link list for San Francisco we only have Atlanta so let's some let's just mark this one and the last one even for the Atlanta we have JFK and San Francisco that is already sorted in correct order so let's just mark this one uh so JFK and we have uh Atlanta okay uh sorry uh San Francisco okay so let's just mark this one as well and now we have everything we are looking for now all we need to do is just do the DFS operation from our adjacency list on the graph and every time we update we iterate over one destination we are going to remove that from the list so next time when we are at the same airport we simply pick the next uh uh next lexo graphical entry in sequence so let's try to run the solution so we start our uh Journey from JFK so we are initially at this JFK location we saw that the first ticket we need to find our first flight is Atlanta so let let's just Travers to Atlanta marked as a now we need to do the we need to go to the Atlanta because we are currently presented in Atlanta also at the same time we are going to remove Atlanta from here and we need we are going to go to the Atlanta now Atlanta the very first flight is JFK so once again we are going to come back to JFK so after coming back we are going to remove JFK from here so now at the JFK the next flight in sequence is San Francisco so let's just make one another journey to San Francisco and uh now we are going to remove San Francisco from here now at San Francisco next flight is Atlanta so let's just Mark a journey to Atlanta and we are going to remove Atlanta from here and now from the Atlanta let's just mark one Journey to the San Francisco so we are going to Mark a journey to the San Francisco and we are going to remove San Francisco here now the moment we uh come to any particular position let's say we came to San Francisco now there are no more entries or no more destinations for us to visit which means we can conclude that we have iterated over every single possible tickets that we currently have present and we can simply say that we iterated over all the entries and this is the path that we created we can just keep track of the path in like a backtracking function uh and because we are making recursive calls to use the DFS and solve this problem quite easily quite beautifully quite simply and this is an awesome lead code problem if we understand the time complexity in this case that that that is going to be big go of vertices multiplied by edges plus big go of n logn in order to do the Sorting but this is already greater than uh n logn so we don't need to factor that in and if we talk about the space comp complexity it is going to be bigo of uh once again uh veres multiplied by edges because we are creating a new hash map uh that is going to be of length V so actually this is only going to be big off size V but in the value section we are going to have all the uh all the edges that we currently have so it's going to be V plus e okay so this is a still a good time in space complexity Now quickly see let's quickly see the coding solution for this one okay so the very first thing we are going to do is to create a map to store the list of destination for every single departure airport so we are going to create a new hashmap where as a key we are going to store the string that is going to store the name of the airport and as part of its value we are going too be storing a link list or list of strings now we are going to iterate over every single tickets that we currently have and keep on marking all the values uh inside our graph hashmap that we have just created after having a representation now we are going to be sorting all the values that we have in the destination of the graph so we are going to do run a for Loop and just do a sort operation after sorting it out we simply need to start our journey from the JFK terminal so we are going to have a link list that is going to be creating an itenary that we need to return as part of the answer and we are going to have a DFS operation that is going to start from the JFK airport where we are going to pass in the graph that we have just created that contains all the sorted destinations and the itary link list where we are going to be storing all the values in sequence now let's see our DFS method so first thing we are doing is that we are adding the current airport we are at at the uh destination after that we are checking that while the given destination is not null and the list of destination is not empty then we are going to remove that destination to avoid revisiting the same path so we so we are simply going to removing that inside our uh array and we are also going to be calling the next value that we need to iterate over and calling our DFS function 1 again so that's it this is the whole solution where instead of passing in G gfk we are passing in the next airport that we have to iterate over and we are also adding the airport to our itinary as well just so that we can we know that what airport we are beginning at and we are generating the itenary in the reverse order so now let's try to run this code seems like our solution is working as expected let's submit this code and our code runs beautifully compared to like almost 75% of all the other Solutions like 71% it can still be improved in terms of space complexity uh so let me know in the comments if you want to see that but anyways you can still see or find the solution on our GitHub repository so feel free to check it out from there thank you [Music] so the lead code problem we are going to solve now is called minimum cost to connect all points this is a very popular question in my opinion why because we are going to be dealing with something very important that is called PES algorithm to solve this problem and this Prince algorithm actually has lot of different practical applications that you can use it in all sorts of different questions and different techniques so let's understand the problem statement we are given an array points that represents an integer coordinates of few points on a 2d plane which means X and Y type of graph and we are told that any particular point value is defined as x i and y i so the coordinates of that location now we are told that the cost of connecting two points X and Y is the manharan distance so let's say that if you typically has like three values and if you are trying to let's say connect any two like this one in this case the cost of this this one is going to be the Pythagoras if we try to choose the diagonal but the thing is Manhattan distances that instead of picking out the value of the straight diagonal between these two points you first go to a common point and then go to right so in this case you are actually doing the Delta of X and you are also doing the Delta of Y so absolute values of X1 and X2 amongst these two points and the sum of this is going to be the total distance you are going to cover so this is called Manhattan distance and this is what we are going to follow so it's slightly better for us so that we don't have to spend so much time on calculating the Pythagoras or root values now we need to return the minimum cost to make all the points connected now let's try to understand this with an example in this case suppose these are the different points we are given now we need to make sure that number one we connect all of these points in some fashion and after connecting these points we also need to make sure that the distance we are traveling by connecting them is the minimum distance we can now let's try to understand first of all that how does a manad and distance is going to work so let's say you want to find out that what is going to be the distance between these two points then logic is going to be quite straightforward you are first going to do the difference between X pointers so this sorry y pointers and you are going to add it to the difference between X pointer so in this case the distance between these two nodes is going to be four and though it's not a diagonal I'm just writing it diagonally so it becomes easier for us to understand thing is the solution of this problem is a something where we will have to deal with minimum spanning tree now minimum spanning tree is a very important Concept in the graph Theory where you are given bunch of different points on any particular plane and you are trying to connect all of these points in some fashion such that the there there are no Cycles being formed and you are not you are trying to span the tree in like only the places where it is absolutely needed nothing more than that but the question is first thing that should come to your mind is that hey in this case we are only given points we are not given the edges which means these are simply just the nodes we are given we know in order to solve any particular graph problem we need two items we need a no nodes and we also need edges but I think is good thing for us is we we already know how to calculate Ed Edge between any two points and the thing is in this case there is possibility that from every single point you are able to connect to every other point in order to treat it like an edge the thing is uh if I try to draw the whole Solution by that matter it's going to look very bad because imagine how many number of different edges you can form amongst all of these points and then it it is only going to look so much more messy and complex if you have to understand all the different flows and data entries and data points and whatnot so what we will try to do is we will understand that what is the most simplest logic we can use to solve this problem and we will also understand that how we are going to be using the prims algorithm and the solution of basically PR algorithm plus the graph Theory concept to solve this problem so let's start working on the solution of the problem I I hope you must have understood that what the the problem is asking us to solve so now let's very quickly and very simply think one by one that what are all the different possibilities we have across all of these five different points well number one possibility is that if we are at this point we don't know that what are all the points that are currently present inside the remaining graph which means we don't know that if we have to generate a minimum spanning tree that crosses or that goes through all every single nodes that are currently present which node should this node zero be connected to so we don't know this question number one thing that what is the minimum cost to reach to any particular point from this node zero and remember we need to make sure that we don't form any Cycles because we simply need to connect all the points and if there are Cycles uh basically we our cost of connecting all the points would increase so the shortest way to connect all the points is to is through like some sort of a straight line or a tree kind of structure where there are no Cycles so now at this zero the number one thing we will have to do if we have to F find the shortest distance or the closest point we will first have to calculate every single distance we can from all the remaining points to this zeroth node and the distance between these points would be treated as the edges because we are basically connecting two different points and amongst those edges we will have to find the edge with the smallest value so these are actually weighted edges and the other thing is the connection in this case is going to be bir directional why because whatever the distance from this zero to this node is same distance is going to be from this node to zero as well so we don't need to do any directed distance calculation in this matter all we are concerned about is what un need directional uh transfer and to understand that what is the minimum place to reach that place now now comes another problem let's say that from this zero it makes logical sense that this is going to be the smallest distance that we can calculate and we also know that the distance amongst this one is going to be 2 so sorry 2 + 2 so total let's say that this distance is 4 that we already know that this is going to be the smallest distance but once again when we come back to this place now we still have three more nodes that we will have to iterate over we are not not going to iterate over node number zero we are going to treat that this zero has already been visited but once again we will have to repeat the same operation and from this pos position we know that the shortest distance we should be able to find is going to be this value so if we calculate this I think this distance is going to be three okay and same way from this three the shortest distance that we calculate for any particular node is going to be this one and this distance is also going to be four but the thing is now we still have one more node remaining and we already found the results for the these four different nodes so question is how do we know that which node is actually going to call to this particular node so for that we will actually have to find a way that while we are calculating the distance from zeroth node to all the other nodes and same way from this first node to all the other nodes we will still have to keep track of all the nodes that are that are still remaining because the thing is it could be possible that there are some nodes that are not in down the path of the shortest nodes but thing is we need to connect all the points so we will still have to find a node that is still closest to this node that it makes sense to make that connection now I know what I just said might sound confusing but the thing is try to understand this from an example point of view that if you are all only if we only traversed or if we only used the greedy approach where we are just iterating in the minimum fashion then we are always going going to be stuck with one node that is not following that this beautiful path and the thing is if we try to find the path to that node that remaining node from here this might be much longer compared to this distance so in order to do that the what logical solution I'm suggesting is that at we first start at the zeroth position from the zeroth position we make the calculation that how much time it is going to take to travel to this first node second node third node fourth node all of these nodes same way then we find that amongst these four nodes which one has the smallest value to reach to there so smallest Edge and we realize that the smallest Edge is one in this case then from this one we know that we already calculated the distance for for zero one is a self node in its own which means now from one we will have to keep track that how much time it takes to reach to node number four 2 and three and keep all of these results stored somewhere as well and then try to pick the smallest value that we can once again from the smallest value repeat the same operation for the remaining elements so even from this smallest value we will calculate these two distances once again pick the smallest one and then from the smallest one see that what is the remaining value and for all the remaining Valu so for this remaining node see that uh currently we should have three results one result is between node one and this one node number four second result is node two and node number four and third result is node three and node number four and amongst these three whichever is the smallest one pick that one and that would be our solution so now let's just try to walk through the whole solution that we just talked about and see that what are all the different concepts we will have to use to complete the solution in a manner that we are proposing now first of all what we need to do is we will need to make sure that there are no Cycles in order to make sure that we will have to keep track that all the nodes that we have currently visited so we can use some data structure like a hash set or an array or a Boolean array of size n to keep track of all the values that we have visited so far so let's say we will use hash set for now for our understanding purposes but at the same time we are also going to be using array during the implementation okay so let's say that we currently have our hash set that we are going to sto be storing to make sure that there are no Cycles next thing is we will have to make sure that for every single node we calculate the distance to all the remaining nodes find their distance and we need to sort those distances so in order to do that one of the beautiful data structure we have is actually a heap and we can have a Min Heap where from every single node that we start iterating over for all the remaining values we will try to calculate the distance and put them in the mean Heap so that we it would be stored in like from uh in a uh ascending order so smallest value would be at the beginning that we should be able to find and how we are going to be storing the value inside the Heap would be in this fashion where the first value is going to be the distance and second value would be the point so we would say that in order to reach to that particular Point what is the smallest distance that we will have to cover that's it that's all we need because we are only concerned about the cost to reach to that point so now let's see that first node is zero in order to reach to zero and let's say that we decide to start from zero it's not necessary that we have to start from Zer but let's say that we decide to start from zero so in order to reach to zero what is the minimum cost it takes so minimum cost it takes is uh still going to be zero so we are going to be adding the value 0 0 over here next thing is from zero now we have four different options to choose from that in order to reach to all of these values so first values in order to reach to let's say this one is node number one node number two node number three and node number four so in order to reach to node number one the smallest distance is going to take is going to be value number four and uh we will mark it as by by 41 same way if we have to reach to this value number three let's say that the distance is going to be 5 + 2 7 so we can mark the values as 7 and 3 same way if we have to reach to this value number 2 then the distance is going to be 13 so we can Mark 13 and 2 and next thing is uh same way if we have to reach to Value number four then the distance is going to be 7 so we can still Mark 7 and four and notice that we are going to be sting in these values because this is a Min Heap so it would automatically be sorted so the value would be something like this one so 7 and four and then uh I think it was a 13 and two so these are the currently four values that or five values we have so far we will pop and now we have started our iteration so we will pop the very first element which means we pop this value 0 0 and we know that the cost to reach to Value number 0 is z so we will also need to have a variable to store all the cost so let's say that we have a variable that where we are storing all the cost in the cost we first add zero because that is the cost to reach to Value number zero let's say we kick out value number zero the thing is because we already visited zero we are also going to be marking zero inside our hash set so let's say that this is our hash set and we already visited node number zero so from now on any subsequent entries that come in with value number zero we are simply going to ignore that because we have already visited that inside our hash set okay and uh let's uh keep on doing the iteration now the next entry inside our Heap is node number one from node number one it takes four cost to reach to node number one so let's mark the cost to 0 + 4 we are also going to be marking that one has already been visited so far and we have this this channel being established okay now uh from once again from one we will have to repeat the same operation because remember from every single node what we are trying to do is we are going out in the breadth for search manner not depth for search manner so we went to one of the neighbors of four and then we are going to be visiting one of the neighbors of one same way we are going to be visiting one of the neighbors of three and same way we are going to be visiting one of the neighbors of four so this is a BFS traversal not a DFS traversal and uh now let's just mark one and uh okay so now once again we are going to leave all we are going to be popping these two entries but but these three entries like 73 74 and 132 is still going to be present inside our Heap now from this one we have once again three options first option is this one the cost of this is nine second option is this one the cost of this one is three and the third option is from 1 to 4 so the cost is going to be uh 2 and five so 7 so once again we are going to be having one entry that is three and three which is in order to reach to no number three we are going to be um using distance three next entry is uh in order to reach to node number four the distance is going to be 7 so next entry would be 74 so we can also put one more entry over here 74 okay and uh we are going to be having one more entry that is 92 in order to reach to two the distance is going to be 9 so we will have one more entry 92 over here and then the 132 would be like subsidi to the back end and uh this is going to be the current values inside our Min Heap now once again we are going to be pop popping out the very first element that is the smallest element that is node number three in order to reach to node number three we will have to add cost s+ three so we will Mark plus three cost over here we will Mark three as being visited because we already visited this one and we will get rid of this entry so now you can see that now the moment let's say that uh suppose I'm just giving for an example suppose we say that this is the next closest node and we will try to extract this one the moment we see that in order to reach to node number three it takes seven cost the thing is we already visited three inside because it's present inside the hash set so we can simply ignore this case and same way we are going to be ignoring all the cases that are going to be uh like different from uh the nodes that we have not visited so far same way from 3 to 4 we we have uh this type of distance and that distance to four is going to be four once again so we can Mark 4 four because that is the smallest entry and from three we will have to calculate one more distance that is to up to this two and that distance is going to be uh 102 so we can mark one entry over here that is going to be 102 but so once again we are going to be adding cost four because we visited node four it takes four unit of time to reach to node number four and we have visited all of these entries now the thing is we visited all of these now um from four we will once again calculate the distance to two so let's say that this distance is going to be 15 so 15 to 2 So currently these are all the entries we have inside our Heap and let's see that what what we need to do so we already visited 0 1 3 and 4 we haven't visited node number two so we start popping values out so we first pop this value 7 74 because we have visited four so we can just ignore this one same way we can just ignore the 74 and then we have this node 92 so we pop 92 out two we haven't processed so we are going to be marking the node two visited over here and add this cost 9 over here as well and now you can see that uh the size of our hash set is exactly same as the size of all the number of points that we are given which means we have visited all the nodes and we can stop our conclusion so in order to do this one the moment we uh the size of our hash set becomes the the number of nodes present we can stop over calculation and whatever the cost we found so far we can return that as the answer so in this case the answer is going to be 20 and this is the whole solution so I hope it makes sense to you that how did you how did we calculated this we dealt with lot of Concepts that that how not to detect Cycles uh then we also make sure that we had a hash set to understand that what are the nodes visited so far we had a heap to find the smallest entry from any particular point and we were doing all of this while calculating the cost of the minimum spanning tree so this is a beautiful solution if we understand the time and space complexity time complexity is going to be big go of first of all let's imagine we will have to do n Square work for any single node why because at this position we will have to calculate distance between all of these four points same way at this particular location we will have to calculate the distance between all of these four points so we will have to do bigo of n Square work to calculate all the distance and then we will have to find the shortest distance and shortest distance we are finding by using a heap so it takes an log and time in order to find the solution from the Heap so overall the time complexity is going to be big off n square logn if we see space complexity because we are storing all the entries inside our Heap it is also going to be big of n Square so overall this is an expensive time and space complexity but given the scope of problem we cannot do anything better than this one so now let's quickly see the coding solution so the very first thing we are going to do is to define the total length of given all the points that we currently have this we are going to be using to check against that whether we have collected all the points or not then we are going to be initializing our priority Cu uh and this is going to be our Min Heap then we are also initializing a new Boolean array to store that all the values that we have currently visited so far so we are marking it as in MST whether it is present in the in the minimum spanning tree or not then we are finding a new class called point so let's understand this one so we have a new class called point and it only contains two values first one is a distance and second one is an index and we can see that we are going to be using this uh instance of this class to store values inside our Min Heap where we are storing that in order to reach to any particular index what is the distance that it takes and then Heap would sort it out for us and the very first element we are adding inside the Heap is that we are adding the very first value or value located at index position number zero inside the points and we are saying that it takes zero cost to reach to those points and this is how our priority Q works we are also having a variable to store the minimum cost um that we have been able to find so far and we have a value called points connected so which we can use it to compare it against the total given length of points to Define that whether we should complete our iteration or not then we are running our Loop until our points connected reaches to the total number of n that is currently present then we are fetching the very first value that we currently have uh out of the priority CU so we are doing a poll operation and then checking that whether this point that we found out uh this current Point have we already visited that current point so we can check that using uh the uh Boolean error that we have created then we are checking that if we have not visited then we are going to be marking it as visited and we are also going to be updating the minimum cost to reach to all the nodes by the distance that it takes to reach to that particular node and we are also updating the value of points connected so far so now we already calculated and visited that particular point but thing is we will have to still calculate the distance to all the remaining points from that point so we are going to be running another for Loop that is going to span across every single uh end that is currently present first we are checking that any particular index that we are checking have we already visited or not if we have already visited that that we then we can ignore if we have not visited we will calculate the distance uh by using the map uh the math. absolute points and then uh we will add a new entry inside our priority que by adding that e location and the distance to reach to that he location and it would sort it automatically in the end we simply need to return the min cost that has occurred so far to reach or connect all the points and this is the whole solution so let's try to run our code okay seems like our solution is working as expected let's submit this code and our code runs beautifully compared to a lot of other Solutions it's almost 80% faster in terms of time complexity and also 80% faster in terms of space complexity so which is pretty great once again the solution is present inside our GitHub repository so feel free to go ahead and check it out from there thank [Music] you so the lead code problem we are going to solve now is called Network delay time this is a pretty popular lead code problem so let's understand the statement basically we are given a network of n nodes marked from 1 to n so in total we are given three items first one is times that defines that in order to reach from one particular node to next node how much time it takes so if we take and look at this example let's say 21 1 then we can say that in order for us to reach from node number two to node number one it is going to take one unit of time so this is how bunch of different times we are given then we are given told uh K as a starting point and that says that we will have to start iterating over our journey from is equal to 2 so in this case from second node and this n defines the total number of nodes that we currently have now the problem is asking us to solve is that we need to return the minimum time it takes for us to travel all the N nodes to receive the signal and if it is not possible for all the end nodes to receive the signal then we need to return minus one so let's try to understand this with an example say for an example in this case we are given an input like this so we can see that in total we are dealing with four different nodes and we are given three different edges so first edges from node two to node number one it takes one time same way from node two to node number three it takes one time and same way from node number three to node number four it takes one time in order for us to reach now we are given K is equal to 2 which means starting from K we will have to make sure that are we able to send a signal that reach every single node and what time it takes for to reach all the need all the nodes in the minimum so during the very first minute we will have a signal that would that can go to node number one and node number three so we can say that these two nodes would have been visited after 1 minute and then from node number three we still have to visit node number four so we can say that in order to reach node number four it is going to take one more minute which means it took 1 minute to reach over node number three and then one more minute to reach to node number four so in total it took us 2 minutes to reach to node number number four and 1 minute to reach to node number 1 and three so in the minimum time two we can reach or a signal can reach every single node starting from node number two so this is what the problem statement is asking us to return let's say in this case instead of two if we are being told that our K starting value is at three so in this case now we are starting our iteration from value number three so once again we will have to check that how many nodes can we reach so we know that in the k three only points to one node so during the first minute we would visit node number four but thing is we we don't have any way for the signal to visit to node number two and node number one so in this case we will have to return minus one so this is the whole problem statement now let's say that this is the input we are currently given and we are trying to deal with that how we can actually find the network delay time starting from any particular node the thing is we don't know that what node we are going to be starting our code with but all we have is the information about the total number of nodes that are currently present and the distance it takes in order to reach from one particular node to other particular node the logic is quite straightforward we treat this one as a classical graph problem where starting from any particular node we will try to see that if there exist a shortest distance that can cover all the nodes that are currently present if we are able to reach to all the nodes then we will have to che check that which is the farthest node and how much time it took us to reach to that particular level let's try to understand this within with this example that we were starting our node at node number two and it took us 2 minutes to reach to node number one then the amount of time it takes to reach to this node number three and node number one is obsolete because we are only concerned about the minimum time it takes to reach to every single node and that should be our key Focus so few assumptions we can make is that number one we can use this as a graph problem this one is going to be the ders uh problem that uh in order to reach us to the shortest minimum uh uh span and I don't know the spelling of T so sorry about that and uh no worry now coming back to the question basically we need to number one thing is have a graph like structure so what I'm suggesting is we create some sort of an adjacency list or adjacency Matrix kind of a structure so let's say that we do create an adjacency Matrix or hashmap that contains all the information related to nodes and what are all the different distances that we can travel from those nodes now we all know that what are the different uh edges it takes us for from any particular node that we can iterate over so we because we are given the information in this fashion like X Y and T where X and Y are the nodes and T is the amount of time it takes to reach there so we can just simply take this x put it in the node section so this would be the key for us to search inside our hashmap and this Y and T defines that in order to let's say that in order for from X we we can have an information like this one that Y and one so we can see that the node is X if we have to reach to Y it takes us one time so let's try to build a graph like that for all the nodes that are currently present in this case but the thing is we are also going to do one thing smarter and that is that instead of just pointing out the nearest neighbor any particular node can visit we will also try to sort these values based on the shortest Value First and the longest value later why are we doing that because we are trying to we have two objectives number one objective is to reach to all the nodes and second objective is to do it in the minimum time so we will have to find the quickest route possible next objective is that we will have to iterate over all the nodes that are currently present so we are going to fulfill all of these goals by making some adjustments in the way we do over calculation so for that first let me just set up the graph structure that I'm suggesting and then we will start tackling over the other problems now in this case we are only dealing with four nodes so starting with node number two we have two options if we have to reach to node number three it takes us two times so it makes sense that this is the shortest distance so we can mark the values as in order to reach to node number three it takes two times and in order to reach to node number one it takes uh three times so we are going to Mark things like this same way starting at node number three once again we have two options in order to reach to node number four it takes us three times and same way in order to reach to node number one it takes us six times same way from node number one we only have one option and that is in order to reach to node number one it takes five times and from node number one we don't have any option so at the node number one we basically just don't have any edges that are going out so we will not Mark anything now we knew that these are the four edges that we will have to Traverse over next thing is that we also need to keep track that what are the nodes that we have visited so far and also the other thing is we need to know that is the node visited if that is the shortest distance that we found so far now in order to tackle both of this problem what I'm suggesting is we create a new array uh that is of size n so we will have values like this one like 0 1 2 3 and 4 but the thing is in this case we are only dealing with node starting from 1 to n so not from 0 to n so thing is for the very first value inside the array we are just going to ignore this one okay so let's say that we ignore this and initially we will set this array up to a very large value so let's say that we are populating uh the entire array with the maximum Vol value possible and then the only time we will update this array is number one if we find out a path to reach to that particular node by some smaller value and number two if we cannot find that in the end it would be able to show us that there are some nodes we are not able to read so we can just return minus one in those case so let's try to start iterating over our solution now it would make much more sense let's say that in this case our given K is equal to 2 we are starting our iteration from node number two so what is the minimum time it would take us to reach to all the nodes now from at node number two we can see that the very first possibility is that if we have to reach to node node number three then we will have to do we can do it in two times currently node number three has not been visited so we found a shorter way to visit node number three so we will mark it by two and then same way we are going to ignore or pop this case out from our given list basically we are dealing with a priority Cube or a hashmap like a structure so inside the hash map we will add the value number three but we will pop out this value from the from the priority Cube now from this node number three once again we are going to repeat the same process and by the way currently inside the priority Q we only have these two values present so first value was uh 32 and second value was 13 now now we add one more value that is uh the value 43 so now notice that we popped one value out and we have uh two more values that we will have to deal with okay and we would keep on iterating in terms of priority q and we would try always try to find the short distance uh that we will try to kick out in this case both values are three so let's say that we decide to update node number one first so node number in order to reach to node number one we can do it in three times so let's mark this one now once again at node number one we don't have anything so we cannot add anything to our priority Cube then we are located at our node number uh four so sorry node number three so at node number three we added one value that is 43 and we also have to add one more value that is 1 and six so for the 43 currently four has not been visited so we would Mark uh value number in this case we would not mark value number three why because in order to reach to node number three it took us two times so we will have to do the sum with two so in order to reach to node number four it is actually going to take us five times so we are going to mark four and five and same way if if we have to follow this path and reach to node number one then it would have taken us eight times so we are going to mark this as 1 and8 inside our priority Cube and this is the important step where we are updating the total number time it takes in order to reach to that particular node based on the previous value we had for in order to reach to that node so in this case once again the node for four has not been visited so we will update it by value number five but notice that this 18 does not need to be updated because we already know that we can reach to one in three times then why would we choose a path that reaches one in eight times so we will ignore this one and then now we are at Value number four so from four we can we have one more path then we can go in order to reach to node number one and uh this takes five times so if we choose that then it becomes 5 + 5 so 10 but the thing is we still don't need to update because we already have value number three now thing is we because we are starting from K is equal to 2 which means from K is equal to 2 in order to reach to K is equal to 2 it is only going to take zero time so we should have updated this at the beginning uh so I forgot to update but let me just do it right now that in order to reach to K is equal to 2 we can do it in zero times and now we can see that we are done with our entire iteration our priority Q has to be empty because we took care of all the nodes and we are left with this array now in this array all we need to do is we need to iterate over all the nodes uh ignore the first node because we are only concerned with between 1 to n nodes check that if we found at any particular moment any value that was the original max value that we started with if that is the case then we can simply written minus one saying that there were few nodes that we were not able to reach if we don't find any value with minus one we are going to find that what is the maximum value we have in this current array and currently the maximum value is five so we can say that five is the to minimum number of time it takes for a signal to reach to every single node start ing from K nodes and this is what we can return so this is a beautiful solution it has lot of practical application like aviation industry uh Network routing industry all the things use methods like this in order to compute that what is the shortest distance to travel from one uh one point uh of the plane to the other point of the plane which is pretty awesome and uh pretty nice now let's try to understand the time complexity now it makes sense that we will have to do bigo of uh n multiplied by V work for every single node and at every single node we will have to check that what is the shortest distance for that we will have to add the those entries inside of priority Q so it is going to be multiplied by logarithm of N and this is a pretty decent solution where n is the total number of nodes and V is the total number of vertices and sorry not vertices but this should have been edges so n multiplied by E if we look at the space complexity well we are using quite number of additional data structures we are using u a graph like data structure to store all the values we are using a priority Q we are using bunch of different pointers and stuff like that so overall the biggest one is the graph likee structure that is big of once again vertices multiplied by edges so this is going to be the space complexity that we would be dealing with so now let's quickly see the coding solution for this one so the very first thing we are going to do is that we are going to create a graph like representation using an adjacency list and for that we are using a hashmap to store the nodes as integers and its subsequent edges as the link list type of structure we are simply iterating over every single edges we are marking the very first node that we currently have as part of a key and then the second value and the third value is being represented as the edge and the time it takes to reach to that particular level then we are initializing a new priority Cube where this is going to be a Min Heap and we are going to be checking that what is the min minimum amount of time it takes to reach to any particular node then we are going to be adding the very first value as saying that in order to reach to node K it takes zero amount of time and this would be the starting point for our Min Heap or priority CU next thing is that we will have to initialize the distances uh of an array with uh the starting value as maximum value so we create a new array starting with n+1 nodes plus we fill out all the values that we currently have with the maximum value possible and the value at the K position in order to reach to K distance we mark it as zero because it takes zero amount of time to reach to node number K now then our priority Q iteration starts that while the priority Q is not empty number one thing we are going to do is pop out the very first element that is present inside the priority Cube Mark the current node with the very first value inside the priority Cube and the current distance in order to reach to that node as the second node of the Tuple then we are checking that if the current distance is greater than the current distances that we have already found then which means we can simply ignore that case and we don't need to iterate do anything with that particular node but if we don't have calculated or we found some value that is smaller then we are going to check that what are all the neighbors for that particular node and we are going to be marking all of those Neighbors uh in our graph like data structure and adding those to the priority CU on top of it we are going to be updating the distance that we need to calculate uh by adding the current distance plus the new distance that we found in order to reach to that particular neighbor so this way we are continuously updating all the values we can inside our array lastly all we need to check is that inside the new maximum distance array that we have created uh that we need to check that in in the given array what is the maximum value we currently have and notice we are skipping the very first element inside the node because we are starting from n is equal to 1 index not zero is index and then we can simply check that if we found that the maximum distance to be the maximum value possible then we need to return minus one if that is not the case then we simply return whatever the maximum distance we found inside the array so let's try to run this code hopefully it should be working seems like our solution is working as expected let's submit this code and our code beats almost 70% of all the other Solutions which is pretty great and pretty awesome so once again you can find the coding solution for this problem in our GitHub repository link is in the description take care [Music] so the lead code problem we are going to solve now is called swim in Rising water this one is a hard problem but a very interesting and intriguing problem so let's try to understand this we are given an N cross n integer Matrix called grid where every single value inside the grid represents the elevation or height at that particular Point uh in this I and J location or any particular cell now we are told that the rain starts to fall and at T times which means rain is falling let's say from 1 minute then uh 1 minute it keeps on falling like 2 minutes 3 minutes 50 minutes up all the way up until T times then the depth of water everywhere is T which means rain is proportional to the amount of time that has passed linearly now we can swim from any particular Square to all the four Direction adjacent squares if and only if the elevation of both the squares individually are at most T which means we can swim from one square to any four directions as long as let's say that uh the current T is let's say 15 so any particular square that has the value 15 or less in all four all these four directions we can swim from this current place so the amount of T be becomes the critical point for us to compare that are we able to Traverse in in between any two squares or not now we we need to make sure that we need to reach to the bottom right Square where we are starting from the top left square and we need to make sure that what is the least amount of time we need to wait before we can reach to the bottom right uh right Square so let's try to understand this with an example the aim is we are given a grid like this now our objective is to Traverse from this particular node to this particular node we are being told that at every single moment what is the elevation or what is the height at that particular point now the thing is let's say that we are currently T is equal to 0 point right which means and we are currently located at this moment so the thing is currently only zero units of rain has fallen which means this particular portion is entirely filled up with rain water so we are able to swim within this cell but the thing is this cell has a height of two this cell has a height of and this cell has a height of four so we cannot Traverse in any four directions right now let's say now enough time has passed and right now currently T is equal to 3 which means we can assume that let's say 3 m of rain has fallen so if 3 m has rain rain has fallen then this portion would have filled up completely because it only requires 2 m to fill up but thing is all the other squares are still not filled up and because current T is equal to 3 and we are currently initially located at this very first spot then we can Traverse to this particular spot any time after T is equal to 2 so at T is equal to three we can still travel when T becomes four then at T becomes four this portion also gets filled up and we can also swim in this direction as well so our aim was to reach from this particular Square to this particular square and we can only do that once the T amount of T gets four so notice in this case we are avoiding this path going down because this path is more expensive so our answer in this case would be T is equal to 4 let's try to take one more slightly complicated example our aim is to reach from here to here now we notice that there are bunch of different ways for us to we can go from here to here we can take as many paths as we want and actually if we have to calculate mathematically how many paths it's going to take I think it's going to be n divided by number of ways we can move uh and factorial of that so this is going to be a very expensive operation if we have to manually Brute Force our way to check every single path but lucky for us logical thing is that we need to check only for some T positions so let's say that initially if we are at the position of T is equal to 5 so let's see that where up until what point can we reach if T is equal to 5 we know we can swim from here no issues with this one then we cannot swim in into this cell because this is a higher T but this is a lower T value so we can go over here then next ly from this we can also go over here because this is also lower than five but we cannot go anywhere further so we will have to increase the value of our T to T is equal to 6 still we cannot go anywhere further if we do T is equal to 7 then we can Traverse up until this point and notice that at t equal to 7 we can also Traverse to this point because this is lesser than the current T value we have so the minimum amount of T we need to complete all the values is not going to be T is equal to 6 even though this value is 6 it is going to be T is equal to 7 so one more way to explain this is to find a path that Travers from this one to the last like top left to bottom right corner and in that path uh find the minimum like the maximum value of T that is required so that would be our answer so now let's try to reverse engineer our way through this one we already know that let's say if we are being told that you have this particular example and for this example example you need to make sure that you need to iterate over all the values only and only if for any particular given T so let's say that we ask you that if the t is equal to 3 are you able to reach to all of these values so logically what we will do is we will start from here and then we will see that what are all the cells that has less value than T So this cell has less value than T then next this value is less less value than T and then we can see that now we cannot go anywhere further we can also try to do backtrack and check for the other possibility but still we won't be able to do it so logically we need to do like depth for search or breath for search in order to find the path we need to take to reach to the end that is number one fact the other thing is after finding the DFS or BFS we don't know that what should be the optimal value of T in order for us to reach to the very end so for that there are bunch of different possibility but one common way that is for for sure is that the minimum value of T can be uh zero so whatever the smallest value is so let's say the smallest value is zero so the let's see the possible values of T can be zero or t t has to be less than the maximum value we currently have so in this case the maximum value we have is 24 so T has to be somewhere between 0 and 24 that is a given fact like less than or equal to why because all the time if T is equal to 20 4 then we have access to Traverse to every single cell in this G given entire architecture so if we can Traverse to all the cells for sure we can find a path that can uh lead us from top left to the bottom right corner but so now we found one condition on where the T should be able to move this is number one thing that what are what could be the potential value of the T second thing is we already know how to calculate that for any particular given value of T are we able to Traverse to all the cells and reach to the bottom right corner or not we can do this in both the ways we can use a breadth for search or we can use a depth for search in order to do this one and it's a pretty common and standard method that logically we are going to be traversing over all the different paths wherever this condition meets up and the moment we find out that the condition is currently satisfactory we can actually move to all four directions to find the value we are looking for so what I'm suggesting is instead of checking for all the potential values of T which is going to be pretty expensive operation why don't we use binary search in order to find the uh the correct value of T that makes sense so what I'm suggesting is let's say that for this particular given given value we know that the T has to be somewhere between 0 and 24 so what we can do is we can treat this 0 as the left pointer this 24 as the right pointer then we will try to find the midp pointer mid pointer is going to be 12 so let's see that if we use the t is equal to 12 are we able to reach to this uh bottom right corner so we can go down this path that's for sure but now after this five we cannot go anywhere because this is 16 and this is 21 so 12 does not work which means the answer of T has to lie somewhere between 12 and 24 so we update so sorry not 12 like 13 and 24 so we update our left pointer and right right pointer once again we try to find the midp pointer so in this case the midp pointer is going to be I think somewhere between 18 so let's see at 18 are we able to figure out so yes we can go down this path yeah for sure at 18 we can take this path and once again we should be able to complete our answer in this manner no issues with this one so yes 18 works so once again now we have our left pointer as 13 and right pointer as 18 once again we will do the binary search so we will find uh the middle pointer to be 15 let's see at 15 are we able to find the correct value we are looking for no right because the 16 we would not be able to cross this threshold so next possible value is going to be uh 15 and once again 18 sorry 16 and 18 so the logical step would be 17 17 would work because we would be able to find out then once again uh from between 16 and 17 we also have to find that are we able to do it so if we do the midp pointer once again the value would be 16 and for 16 we should be able to find the answer so logically uh we had to do like instead of doing 0 to 24 steps we only did five steps to find that value 16 and that we did it using binary search so logically in this problem what I'm suggesting is that we use breath for search or depth for search whichever one you would like to choose uh in order to iterate over all the cells and we do this with doing the binary search on the value different values of T and the value the range for T is going to be the smallest element like 0o less than or equal to T less than or equal to whatever the maximum element we have inside our grid and uh somewhere between that we would try to find the value of T so the solution would work perfectly fine if we have to calculate time and space complexity in this case the BFS or DFS would take B go of n Square work because we have n cross n grids and for one iteration and we will have to do this log and time because we are trying to find different values of T so it's going to to be n² log n uh in terms of time complexity in terms of space complexity depends on how you implement your breath first search or depth first search if you are using recursion and you if you are using like a stack recursive stack to store those values then it might take big of n square space as well so just be mindful of that now let's quickly see the coding solution for this one so the very first thing we are going to do is uh we are going to Mark the value of n then we are going to initialize our left pointer and right pointer this is going to be the cell locations and then we are checking that while the our left pointer is less than right pointer we are going to find the mid pointer that we will have to iterate over and on top of it we are also going to check or we are going to call our helper method call swim uh can swim and which checks that for any particular given grid depending on the midp pointer are we able to reach if we can then we shift our right pointer to the midp pointer if we cannot then we update our left pointer to go right + one so this is our binary search method now let's understand our can swim method so in the can swim we have the given grid as the input and the different values of T we are working with on top of it we are checking that first of all what is the length of the given grid we are also having a visited Boolean hash set that defines that these are the cells we have visited so far because we don't want to be stuck inside the infinite Loop in breath for search or depth for search and we are going to call our DFS method in this case where we are passing in the grid the nodes that we have currently visited the I and J location and we are also passing in the different values of T now this is going to be our recursive d uh DFS method where first thing we are checking is that what is the given length of n then we are checking for the scenarios that if we are going out of bounds so the these four conditions are for going out of bounds or we have already visited that node or we notice that the location of the grid position is greater than the current T value then we can return false that we cannot go to that particular cell if that is not the case and we check that the current I and J position is at the bottom right then we can simply return true saying that yes we are able to reach to bottom right corner if that is not the case then we Mark the current node as visited and then we we call the DFS method in all four directions and once again recursively repeat the same process so this is the coding solution so basically after this recursive process ends we should either receive true or false for any particular T value and inside our main method we are trying out bunch of different T values and making these uh various calls so this is the whole solution now let's try to run the code okay seems like our solution is working as expected let's submit this code and our code beats almost 98% of all the other Solutions which is like one of the fastest solutions for this particular hard problem so I hope you find it useful once again the solution is present on our GitHub repository so feel free to go ahead and check it out from there thank you hello friends we are still not employed by a Fang company so let's on stop Le coding till we get there today we are going to do alien dictionary lead code problem and not only it is a very important problem this problem can actually be asked in multiple ways it can it can be asked directly as a graph question or it can be asked as a followup question for the previous uh question that we solved verifying an alien dictionary because both questions are very similar and if you want to check that where the solution for this problem is you can check it out from over here also the another reason why this problem is really important is if you just take a list of companies that have asked this problem Airbnb Facebook Google Amazon Bloomberg Microsoft Uber they have all asked this question last 6 months also ID giants like Pinterest Apple Twitter eBay they all have asked this question in last 6 months to one year and uh bite dance uh Snapchat and flip cart so they have asked this question not fairly recently but still it's important and uh I will be paying my atmost attention because my aim is to clear any Fang interview and uh I hope you also enjoy the video this is a lead code hard problem and it justifies this hard tag uh so let's understand the problem statement essentially we have identified a new alien language that uses English alphabet however the order of those letters is unknown to us now we are given a list of strings uh inside this words and we are told that they are from this alien languages dictionary and in that string the important property this words have is that they are sorted lexicographically and we need to return return a string of unique letters that are present in the in these words and we need to written them in lexicographically increasing order now also there could be possible that there might be multiple Solutions so if there are multiple Solutions we only need to return any one of them and there could be some some cases where this given uh string of words is invalid and if it is invalid we need to return an empty string so in order to understand this problem first of all we will have to identify that what does this lexicographically increasing order means the second thing we will have to understand is that what are the cases where this particular uh input is going to be uh resulting in falsified uh information and what does this string of unique letters with lexicographically increasing order means because this unique word is actually really important and I'll come to that later so suppose if we just talk about what is lexicographically sorted means if we talk about English language if we talk about the words ab ab b c d uh all the way up to Z this is plain English language that we use on a day-to-day basis now in the English suppose we are given any four letters uh suppose we are given letters like uh q a uh e b r c and uh Q E suppose we are given letters like this right and if we want to sort these four in plain English language how we are going to sort them like of course the answer is simple we are only going to check that what is their position in this given order and based on that particular order we will sort them so if we sort them uh the sorted result would look something like e a QA Q E and RC something like this right and the reason we are able to generate this is because we know that the position of e comes before q and in this case there are two entries Q A and Q E so which means like if we will have to identify that what is the second letter and second letter A comes before E and then this R actually comes before Q so we are able to determine a sequence like this now in this given problem we don't need to generate a sequence like this uh basically we are told that we are not given this information we don't know that what is the order of words are and we are directly given this particular sequence that is already sorted in that particular language so suppose this was to be alien language and if we want to identify that what should be the answer we need to return in this case the few things we can determine from this input is that okay over here the we are checking first uh at any point we are checking any two adjacent words in those two adjacent words we go letter by letter and we try to see that what is the first differing letter that comes to uh in comes to the existence and based on the differing letter whatever the word is presented first should come first in that order rather than second uh word second letter uh so if we compare these two words e a and QA we can see that the first differing word comes as e and over here it is Q so which means we can determine that e will always come before Q in this particular alien language now don't forget this that this is plain English for just imagine this as an existing scenario so we know one scenario okay that e should come before Q right now over here again if we compare next two words the next two words are QA and Q E Okay so in QA and QE notice that the first letter is Q so it is common which means we cannot identify much information from that but the second letter is a and e which means we can determine that at any given scenario a will always come before E so we can notify that we can also create a scenario like that that a will always come before E and over here I'm denoting this relation by uh an arrow which indicates that at any given moment e should always come before for Q because uh it is on the uh beginning end of the arrow and uh the where it is pointing to uh should comes later and uh again we will compare these two words q e and RC so if we compare these two words we can identify that okay Q should come before R so we can also denote that relationship that Q will become uh will be before R right right and over here now we have these three relations So based on these three relations we can actually establish something uh over here that we can establish that a will always come before e and e will always come before q and Q will always come before R so one of the sequence that we can return over here is that a e QR okay so this is one of the sequence that we have to maintain at any given cost because we are given these conditions based on the words that were given but thing is will this be our answer and actually this will not be your answer and the reason this will not be your answer is because over here we are given this particular line that we need to return a string of unique letters from this words in the new new alien language that is lexicographically increasing order but thing is over here if we look the original input the in the original input we actually have one more unique character that we are missing and that particular unique character is so we already took care of e we took care of a we took care of q a q e r all of this we took care of but C the letter c what we did not take care of it and the thing is over here based on whatever the input that we are we were given originally we cannot determine the position of C but thing is we know that c is also a unique character and the only thing we know about the positioning is that for these four characters we can Define some positioning like this for C we cannot determine any positioning but thing is it has to be part of the answer as well and that is why we are told that there could be multiple Solutions and we need we need to return any of them so in this scenario uh this could also be a solution where a e QR and C we are placed at the end or this this could also be a a a solution where a we we put C somewhere in the middle and eqr is uh also placed like that the important thing is that we need to maintain this order as long as we are maintaining this order because this C is one of those uh unique letters where we cannot find the dependency for that so we will need to take care of it as well and this is a very important detail that lot of other videos have missed out and uh that is why took me lot of time to make this video I want to make sure that I go through it completely now let's take one more example from the given input and we will again try to find that what should be the answer for that so in the given input we are given the following words these are the words that we are given in the alien dictionary right and our aim is to find that what should be the answer in this case well the first thing is uh that we are what we are going to need uh in order to generate the solution in order to generate the solution we are going to need two things we are going to need list of all the unique characters that exist and second thing we are going to need is uh what are the dependency on uh all between characters and based on these two things we will try to generate some sort of order or some sort of pair and also remember that we will have to consider the scenarios where we could find invalid strings as well so I'll be explaining that uh in this uh in this example so over here um if we see the list of unique characters the unique characters are w r t f e okay these are all the unique characters that we can find in this particular input okay now let's start making dependencies now in order to make dependencies at any given moment we will have to compare two adjacent words and we are going to find first differing character and based on the differing character we are going to establish some different dependency so first of all the first uh first two words we are going to compare are W RT and W RF okay in this case ww is common r r is common which means that first differing character is T and F and we already know that these words are sorted so because they are sorted we can determine that t should come before F okay we already know that this is good now what is what are the next two words next two words and we now we are done with this wrt the next two words are WF and e r okay so WF and e r now in this case what is the first differing word well the first differing word is first letter by itself W and D which means we can make another dependency that W should always come before e now we can ignore this again we compare next two words so e r n e t t so over here what is the first so e is common the first differing letter is R and T which means that R should come before T next one is E T and R ftt so over here the first differing character is e and r so we can also mention that e should always come before R okay now we have these four dependencies uh for these five unique characters now let's try to see let's try to create a dependency tree from this given input so if we see we can clearly see that okay W is dependent on E and E so w comes before E then e comes before R okay then for R comes before t and t comes before F so this becomes all the dependencies and if we notice all the unique characters they are already part of these dependencies so we are good we don't need to do anything more over here now if we make that what should be the order of uh letters the order of letters in this case would be w e r t f and and this would be the correct solution now notice that in order to generate the correct solution what we had to do is we will we had to find all the unique characters all the dependencies once we had all the dependencies we actually had to iterate over all the dependencies see that which dependencies are interconnected based on their interconnection we have we actually had to generate this order and in order to do that we are actually using uh graph Theory and how we are using graph theory is basic basically all the unique characters in this case are actually nodes and all of these dependencies are actually edges between those nodes and those edges can be represented as in some form of adjacency list in some sort of hashmap and then we will need to iterate over all the entire graph and then at any moment we will have to go through the graph and find the solution that what what should be the order in which we are able to iterate over all the the unique characters which means that all the nodes inside the graph and we need to generate this order of pairs and if we are able to successfully generate this order of pair we will return whatever we find and if for somehow we find out that the input is invalid we will have to take care of that scenario as well so first let's take a couple of examples where we we can find that the input could be invalid now based on the English language we know that at any given moment if there are two words present W1 and W2 and we know that any single word so suppose W1 is actually prefix of this W2 if that is the case then W1 should always come before in the dictionary than W2 let's take it by an example suppose we are given two words uh like bat and Batman if we are given two words like this so if we compare if we start comparing these two words and see that what should be their order we check that okay B is common a is common T is common right now over here this actually ends there is actually an empty list there is nothing over here while over here there are still some values so if that is the case we can determine that this W1 is actually prefix of this W2 because these three characters are also present over here and in that scenario this W1 should always come before W2 at any given moment we identify that this particular character is not present in correct Manner and suppose we are given an input like this that Batman and bat if we at any moment encounter this scenario we can immediately return false because or we can immediately return an empty uh string because this is a wrong ordering so this is one of the failed scenarios where we cannot do anything right so this is very important to understand and we will have to take care of this in our solution the second thing that that will not work is that at any given moment suppose we are given list of words uh suppose the words are like x a b x suppose we are given list of words like this and what this means is that the first letter X should always come before a okay so based on these two we can establish this dependency based on these two we can also establish that a should always come before B okay and over here the next thing is that b and X which means that what this is saying that b should always come before X so if you notice over here that we are actually stuck inside a cycle that X will X needs to come before a a needs to come before B and B needs to come before X so at any moment in our graph whenever we are traversing over all these unique characters and dependencies at any moment we encounter that okay there exist uh loop and if we detect that there is a loop from any particular uh node then we can return false immediately or we can say that okay this is an invalid case where the string actually doesn't exist and we will need to break out of the loop suppose we are given a custom example like this words and we are told that all of these words they are lexicographically sorted in the alien dictionary and now we need to return the order of words of all the unique characters that we can find so what should be the approach well in order to do that we are going to need two things uh first thing we are going to need is all the list of all the unique words or all the unique characters and we are also going to need uh the entire dependency uh between any two letters that which should come first and which should come later right so let's start working on it uh so so first of all we have b and a okay so we will just add list of unique letters b and a and second word is b b y which means that first differing characters a and Y so we can establish a dependency like this that uh a should come always before y okay now again moving forward with next two values so over here the first differing character is b and a which means that b should always come before a and also U I forgot to add one more unique character y over here right now uh this B should come before this a so we will add that to our dependency list as well that b should come before a right so this is one dependency and over here we have the unique character D so we will add the unique character d as well now we will uh we have this other word uh these two words and in these two words a is common which means that D and S L are differing characters so first of all we'll add the word L over here and over here we have this D right so we know that D at any given location will come before L okay so we'll just mention that now over here we have one more unique character T so I'll Al also mention that now the next two words are these two words over here the a is common L and I are different and also we have one more unique character I now uh we we know that there is a dependency between L to I so we will also mention that that L should come before I now the next two words are uh Ai and a i r now notice over here that this AI is actually prefix of this AI R right which means that this AI will always come before this word AI R but we cannot determine anything regarding this R because this R by itself it has no other thing to compare it result its result with which means that though we have a unique word we don't know that what is the intention for that particular word is and now let's see that in the dependency list that we have created uh among these unique words what are all the words that we are able to find a pair for so one pair we were able to find is for this one this b a y uh let me just draw everything in same color so b a y this is one pair which means we know that at any given moment this b a y order has to to be maintained like B always has to come before a and uh Y and uh same goes for this DLI that D always has to come before L and all L always has to come before I but in the list of unique characters we are given this R and T as well that are not represented by any dependency which means we can show we can say that this R and this T they are unique characters by themselves which does not have any sort of dependency right so if we want to see that what could be the potential different pairs we can make over here well there could be bunch of different results like there can be so many different permutations and combinations let me just give you a few of them like most simple one would be b a y d l i RT so this is one combination uh where notice that we are just maintaining the entire order now second combination could be uh b d a l y i r t now notice over here that at any given moment we need to make sure that these two orders are are met up so B is always coming before a and a is always coming before y so that is satisfied over here D is always coming before L and L is also coming before I so that is also satisfied this RT they don't have any dependency so it doesn't matter we could have some pair like this that b r t d a y l i this is also valid pair because notice that this B A and Y this is maintained this uh D L and I this is also maintained this position of R and T doesn't matter so there can be bunch of different options that we can choose from and I'm just showing you that uh these are the different results we can have right because we need to take care of unique characters as well so don't forget the unique characters they are really important now what should be the approach in this case well one approach is actually quite simple because we know that we have a unique characters we have the dependency we can choose some data structure like hashmap we can iterate over at any point whenever we identify the dependency we can iterate over the entire hash map we can from any point we will try to see that whether it has any dependency or not if it has dependency we will go to that dependency we will try to over those values and we will try to generate the order list right so let's see that how it can work suppose we create a hash set like uh suppose we create a hash map like this okay suppose this is our hash map and based on these dependencies we know something that we know that okay for in order for us to put down this B we know that a has to come after B which means a has dependency on B right we will mention it over here now for this a a has to come before y so a has to come before y now for this y we don't have any dependency so we'll just leave this value as blank now for this particular d d has to come before L right so we will just mention L over here now this L has to come before I so we'll just mention I over here for this I we don't have any dependency so we are good and same goes for this T and R that we don't have any dependency so we are good now since we have this dependency tree let's see that what would be the approach we can take over here so in this scenario suppose if we want to calculate that what would be one of those ordering pair what we can do is we will start traversing through all the all of these values all of these unique characters and remember that this is hashmap so in hashmap we are treating these as key value pair key values and these are actually values so in the keys we are mentioning all the unique characters in the value we are mentioning all the dependencies now over here we will start iterating at this B so first I'll just Mark B as that we are iterating over it right now from this B we identify that okay we need to have a before B so again we go to a because we will have to check all the dependencies right we cannot just put any letter randomly any place right because this B has some dependency so we will have to go over that now this a has actually dependency on y so again we'll go to Y and we'll just Mark a as being as part of being visiting and over here we reach at this y y don't have any dependency so we are at this y now notice that we are actually traversing this graph in DFS manner depth first search manner right and in depth for search at this y we identify that okay this y does not have any dependency so we can just put y to our order list so we can just put y to our order list now from this y we will do a back backt trck we will again come back to a again we will do a backt trck again we will come back to B and then we are we would be done with this B right that okay we are done with this now again we we start we ignore all of these now we start with this second position now in the second position first we determine that whether we have calculated this value already or not so since a is already calculated over here so we ignore that so we can ignore the second case again we check that whether this why we need to calculate it or not but why we have already calculated so we can ignore this right so we will ignore this and now we'll move on towards this D now do you see any problem with this one well definitely we are seeing a problem with this one and the problem is that over here the dependency is like this that B has to come before A and A has to come before Y in order for us to generate the dependency uh dependency order but over here when we started traversing the actual dependencies we are getting is actually in reverse order you see that y comes before uh a and a is coming before B so one way we can do it is that we can start traversing like this one that over here we again come to this D for this D we find a dependency as L for this L we depend find a dependency at I for I don't we don't find anything so we'll just put I over here then we backtrack so again we put l over here and then again we backtrack and then we will put D over here and then we come to this T like this I this L and this has already been done so we ignore that we come to this t t does not have any dependency we put it there I has already been processed and we reach at over the over here at R now this order list we got is actually correct but in reverse order because the dependency should be like b a y and uh this should be D but over here it's D Li in reverse order and same goes for b a y so what we will have to do is uh when we calculate the answer we will have to return the reverse of this answer and that would actually satisfy uh these dependencies so that is one way of doing it right uh and there is also another way of doing it and the better way is that when we are actually creating this hashmap we can actually do something different uh prev previously in the hashmap what we are doing is that over here we had a key as all the unique characters and as the value we had these dependencies exactly as they were mentioned that for this particular B it is dependent on a for this particular a it is dependent on y but thing is that is not true the actual true thing is that actually this y the position of Y should be dependent on a that y cannot be present unless there exist an a value before that if we start so if we rather than storing the dependency on value that is taking care of the value that comes after it if we start taking care in reverse order so let me show you what I mean by that so suppose if we have a hashmap like this and over here in the value we actually present at any given value what should be the previous value that has to be present in order for us to reach at that particular value so what that would do is that if we want to calculate this B we don't need to basically have any value right so over here we will leave this as blank that for B we don't have any dependency but for this particular a we actually have dependency on B that B has to be there in order for us to process this a so we will put a dependency over here saying that okay B needs to be there for us to calculate this value a same goes for y that a needs to be there in order in order for us to calculate this value y again we reach at this D and for the D we don't have any dependency so we'll just leave it blank but for this particular L again we'll have to have a d over here so we'll put a d over here for so for this D we don't have any dependency so we can leave it blank for this particular I we actually have to put we have to have an L before that so we'll put a dependency over here and for this R we don't have any dependency so we will leave it blank right so this is the table we actually this is the hash map that we work with and over here now let's try to iterate over this the hash map essentially our aim is to iterate over this entire hashmap identify that at any point if you are inside the DFS function you are not finding the repeated character so that is the item number one second thing to make sure is that you go through all the characters and you start building up the order list so over here we will get so over here we will get uh we initially start at B and at B we don't have any child so we are good to put B over here now next uh and we can mark that b is already done now we are at this a so for a we need to check that whether B is done or not B we check over here B is already done so we are good which means that we can put a over here so we will put a over here again we will Mark a as being done again we are at this y we check that okay A Y has dependency on a so we check okay a is already done so we can put y over here as well now we are at this D so D does not have any dependency so we can just simply put D over here and we can just mark this as done again from L we check for D D is already marked so we put l over here T does not have any dependence and we Mark L T does not have any dependency so we Mark uh T is done we can put it over here now this I has dependency on l l we have already marked that it is done which means we can complete this I as well and for this particular R it does not have any dependency so we can put it over here now if you if you notice this scenario we are actually fulfilling both of these dependencies and uh notice that this B comes before a and uh comes before y so we are good uh with this dependency this D comes before L and I so we are also good with the second dependency as well and this T and R they were actually separate values so it doesn't matter wherever we put them as long as they are there uh it fulfills our purpose and this is the actual solution that we need to take care of that where initially we will iterate over all the words we will create all the unique characters based on the unique characters we will create the dependency list uh based on the dependency list we can actually create a hashmap uh that we are going to use to Traverse as a graph but thing is rather than traversing the original hashmap we can actually create a reverse link reverse list of dependencies and we can iterate over that just once using DFS or BF DS anything but we are going to use DFS because I want to master DFS for myself and we and that would be our solution so it took me lot of time to come up with this solution it took me lot of time to understand this problem okay let's calculate time and space complexity for this problem so the time complexity for this one is going to be bigo of C where C is actually total number of characters that are given in this original input words because notice that there are three actually three parts of this problem the first part is that we need to find all the unique characters like in order to in order for us to generate all the unique characters we will have to iterate over uh all the characters that are given in the original input words so that is one part now second part is that we need to create a dependency and in order to generate the dependency again we will have to Traverse all the words and the third part is that we will have to uh so we are generating some sort of hashmap and in the inside the hashmap we will have to iterate over all the values inside the the present hashmap so at any given moment the maximum work we are doing is iterating over the sum of all the characters that are given inside this words so that is why that would be the time complexity and if we want to calculate the space complexity the space complexity would actually depend on the number of unique characters so suppose that in English language the number of unique characters maximum we can have is only 26 right and we are also told that for this alien language the maximum number of unique characters we can have is also going to be 26 so space complexity actually has a finite number and there is only so much it can grow so we can treat space complexity to be bigo of one or constant space complexity for this one even for us to creating this additional hash map the second thing is that suppose if we want to calculate based on the number of unique characters uh we there is also one equation where the space complexity would actually be B go of U plus whatever the U square or n whatever the minimum value of this is and uh let me know in the comments if you want me to explain the space complexity uh in a scenario where the number of unique characters are actually not finite and not 26 like in this case it's 26 so I will just uh leave it as it is but let me know if you want me to explain that first of all we are going to create our hashmap and we are going to actually create it outside of this uh Alien order method that is given because we want to use that hashmap to uh our to other to our DFS method as well so and as a key we are going to use unique characters and as a value we are going to use the dependency so it would be list of characters and we are going to name it reversed list because uh essentially we are just reversing the ad adjacency list uh also we will create another hashmap to uh essentially store the value of uh any parameter that we are already currently visiting inside our d FS method and uh so we'll need to create an output of uh strings so we can create a string Builder variable now the first uh thing we need to do is find all the unique letters inside our given word string of words now this is done now we will have to find all the edges and we will have to add the reverse edges to our reverse reverse list hashmap now at any given moment we need to check that whether the word two is actually prefix of word one or not if that is the case we can return false immediately and we have found a terminating case where the given uh string of words is not valid okay okay if that's not the case we will find the first differing character between two words and add it to our add it to our hashmap and notice that we are actually adding the value to the second diff to the second word's differential character and the moment we find the first deferring character we can actually breakout of that particular word now we are going to iterate over the reverse list hashmap that we have created and we are going to run our DFS function okay for for all the keys present inside the reverse list uh hashmap we are going to run the DFS function and we are also going to check that at any given moment have we receiving the result as false so we are just going to create a Boolean variable result and now we are going to call the EFS function and we are going to uh provide the character inside the reverse list and at any moment if we identify that the result is uh for this result character is actually fault uh we will return uh empty list immediately okay now uh all we need to do is that once we once this DFS step runs um we should have our output inside the result so we will have to check that whether all the unique characters are have been taken uh care of or not so we are going to check that whether the length of output if that is less than the size of our uh list if that is the case uh we can return false immediately because we haven't taken care of all the unique uh unique values present and if none of these cases uh happen we will return whatever we find inside the output now the only thing we need to do is we will have to create the DFS method now first of all we are going to check that whether the current character C we are checking if we have already visited that uh or not if we have already visited that we are simply going to uh return false if that's not the case which means first We'll add the current character to our scene uh hashmap and we are going to Mark the entry as false so that way whenever if we encounter the repeated value it will always return false otherwise by default the value would be true okay now for every single uh character inside uh the current for the for the given character we will iterate over inside the uh reverse adjacency list and at any point if we encounter the result false we will return false immediately if that is not the case uh we will remove the entry from the scen uh hashmap so we'll set the entry as true and uh inside our output string we will append the value and for that particular character we are going to return true okay so I know this is a very long and too many lines of code I'm going to put this in the comments let's try to run the code okay seems like our solution is working and also remember I was talking to you that we will have to take care of all the unique characters uh here let me show you an example so suppose we only have two characters H and P if we are only given input like this and we know that H comes before P right which means that uh in the result we should be getting HP so let's see that what okay so this is this is accepted right but now let's say that we have additional character h a and PB now over here we don't have any mechanism to measure this a and this B so they become unique characters right and now let's try to run the code for this particular test case so if we do that uh you are going to see that A and B would be at weird locations so over here see the important thing is in our output we are maintaining the order for this H and P and that is what it matters Like A and B over here in our output is actually behind this HP while over here the A and B are actually at the beginning and then there comes HP so it doesn't matter as long as the order that are that is given in the input is maintained and now let's try to submit this code and uh oh wow our solution is actually 99% faster than all the other Solutions and uh I use lot of uh help from the solutions tab from this uh lead code premium because it took me a lot of time to understand this problem so I'll be posting this in the comments you can check it out from there and uh hope you like the [Music] video Hello friends hope you're are having a fantastic day today so now we are going to solve an awesome lead code problem that has tons of practical use cases we are going to solve a problem called cheapest flight within K stops and all the travel companies and Airlines uses the logic we are going to solve in this problem so this is a really important and informative problem with lot of useful properties so basically in the problem statement we are given n cities that are connected by some flights and we are given an array called Flights where we have three values we have the source City we have the destination city and we have the price it takes to get from like the source City to the destination city and we are given bunch of entries like this now we are also given three additional integer called Source destination and K that defines that we want our travel to start from the source City end at the destination city and K is the maximum number of stops we can we are allowing ourselves to take and our aim is to find the cheapest tickets that we can find within the constraint of given case stops from source to destination and uh if we can find the cheapest ticket that's great we need to return that value if we cannot find any tickets then we need to return return minus one so let's try to understand this problem with a real life example so here I have given bunch of different uh values inside our our flights array and we also have three different values called Source destination and K now we can see that every single entry inside this array contains three values and we all know that this defines the source City the destination city and the price it takes to reach to that particular destination city uh we are also being told that we are planning our journey from Source City Zer and destination city 3 now this 0o and three can be replaced by any real life values like New York and Paris France New Delhi you name it and we are saying that we want to take at most one stops nothing more than that and now let's try to see that what is the amount or what should be the answer in this case so I have drawn the whole information that we have provided in this flights array in this beautiful graph like description and now we can see that we are starting our travel from uh City number zero and we need to reach to destination number three now we can see that one root is that that we go from 0 to 1 and then once we reach to stop number one this would be our first stop and then from one we can we have to go to three because we are only allowing ourself to only take just one stop now from zero there are no other stops that we can take in order to reach to three so this is the only path that we are allowed to take within the given constraint and the cost to reach to City number three in this case is going to be 100 + 600 so in total 700 and this is what we need to return as the answer now say for an example in the same scenario instead of K being 1 if we are given the value K being two as allowed to be to be given now in this case let's see the scenario first stop we can take is that from zero we can reach to City number one this is going to be our first path now from the city number one we have two options one option is that we reach to City number three that gives us the answer that we can reach to the destination Within $700 but the other option is that since we are allowed K to be two we can take one more intermediate city as a stop and we decide to take a stop at City number two now in order to reach to City number two it takes $100 plus $100 so $200 to reach to City number two and from City number two we also have a direct connection to City number three and that is also going to be adding the cost of 200 so it takes 200 to reach to City number two and plus 200 more more to reach to City number three so in total it's going to be 400 so in this case the cheapest flight would be 400 that we can return as part of the answer if we are given our K to be two so this is what we need to return uh in this example now the first logic that comes to our mind is a very simple Brute Force approach where logic is going to be quite straightforward that we go through every single possibility of all the nodes that we can visit and all the edges that we can visit and then try to see that what is going to be the cheapest price to reach to the city number three in order to do that we can actually use the graph based representation of this given input uh flights array and after converting it into the graph we can actually do like breath first search or depth first search from any particular node for all the other subsequent nodes so we are iterating over all the possible edges and uh recording the values we can also use backtracking recursion you name it in order to solve this problem the thing is uh that solution would be okay in terms of like coming up with just a solution to have but the thing is think of the real life scenario we are dealing with 100s or millions of cities flights and cost so that's not a scalable solution we need to find a better approach and that's where a beautiful solution or algorithm that comes into the picture and that is called belman Ford algorithm so now let's see that how can we utilize this algorithm to solve this problem so once again we are going to be using the same example to solve this problem using the belman for algorithm the logic is quite straightforward we are actually going to be focusing on the only thing that for every single K iteration how much time it takes to reach to any particular destination and what is the cost associated with that and in the end for all the given K entries we will keep on running the same process until we reach to the end that we are looking for and then if we found any particular cost for the associated destination city in this case we have value number three then we can return that if that is not the case then uh we can return minus one so let's try to understand the logic I'm suggesting to solve this problem for that we are actually going to be using some sort of placeholder values where we can store that how much time it took or how much money it took to reach to any particular destination city for that number one thing we need is to have an array called cost that defines that in order to reach to any particular destination city what is the cost associated with this now the second layer of complexity in this case is value of K because notice that in our one one of the examples we saw if we only have to make one stop then we come up with the different cost but if we are allowed to use two stops then we are able to come up with a different stop or different cost so once again we are going to be using the same logic and in order to justify the value of K if we in order apart from using this one we will also have to use a temporary array for every single value of K so now let's try to understand the logic I'm suggesting um current ly I have defined an array called cost and we are going to be seeing that in order to reach to any particular destination city what is the cost associated with this one this is the number one thing and second one is this temporary array would be reset for every single K value and once we calculate that how much time and effort and money it took to reach to any particular destination city around any of the K iteration then we are going to be copying this temporary array to this cost are and repeat the same process for the upcoming subsequent K values now in this case let's say that for first we are going to be calculating that what would be the logic for K is equal to 1 then we will see that what would be the logic for K is equal to 2 Okay so let's uh stay with me this is going to be pretty interesting to understand and learn the whole process now we don't know that how we can uh Define that whether we have a City cost Associated that is cheaper or not in order order to do that what I'm suggesting is that initially I put the cost to the maximum value possible and after putting the cost to the maximum value possible whenever we find some value that is smaller than the current value then we update that value because it it is in our benefit to update that the cost it takes to reach to that destination city and now let's start our process now we know our source city is zero so by default logically in order to reach to City number zero the cost has to be zero because we are already there that is our source city so we are going to be checking first of all updating that value inside our array so for City number zero currently it takes maximum value to reach to that particular City but we are going to be defining it as zero okay and now we are starting our process so we are going to go through Edge by Edge for every single array we are going to be updating the temporary value for that Ki element and then uh temporary array is going to be SW flipped over to the cost and then we are going to repeat the same process So currently for the temporary array we are going to take a copy from the cost for this first iteration so this is zero and all of these are Max in order to reach to the any particular City now first thing is that in order to reach to City number one it takes us $100 so we are going to be updating that information that in order to reach to City number one it takes makes $100 but thing is first we are going to check that the source City that we are traveling from that already has some value and it is not the maximum value because if any particular city has the maximum value that means that that city is not reachable so if the source city is not reachable how can we reach the destination city from that Source City now in this case source is zero and destination is one and the price is 100 so we already know that we can reach to the source City because this value is zero inside the current array so then we are going to be updating this one as 100 because it takes $100 to reach to that particular City next thing is in order to reach to City number two it takes $100 from City number one but the thing is in or our original cost array we cannot reach to City number one so once again for this one we should not be able to reach to City number two as well because City number one is not reachable so notice this is going to be for K is equal to 1 only one city so uh we can only make one stop so that is this stop and if we so that's it so now uh next thing is in order to reach to uh City number zero the cost is 100 from uh Source City 2 once again for two Source city2 we cannot reach inside the cost array so we cannot update the update any value and also in this case this would not be updated because currently in order to reach to City number zero the cost we have is zero and this is 100 so why would we pay higher money if we already have a lower value so this would not uh be used next value is in order to reach to City number three it takes $600 the thing is uh we cannot reach to City number one so currently and notice that currently we are iterating over K is equal to Z and we have maximum value of K is equal to 1 so we are going to be running this iteration twice so currently for K is equal to 0 uh uh the this one is from 1 to three it takes $600 but the thing is uh we cannot reach one so we cannot reach three once again next iteration uh we cannot reach any other City because uh 2 to 3 is 200 but we cannot reach two so we cannot reach three so these are also going to be blank now notice that after the first iteration we only traveled one city that was the immediate neighbor of this node number zero and this is the whole point of this exercise that every iteration we are going in like breath manner uh for all the cities that we can iterate over and we are updating the cost accordingly now for the next ke iteration we also need to update the value of this temporary value inside our current current cost area so first we will update this one so this is going to be 0100 and then these two are going to be max value and max value and once again we are going to be starting with a blank temporary array but we are going to take the copy of this cost array so this is also going to be 0 100 and then max value and max value now let's see the same iteration again now 0 to 1 100 we already have this value stored so we don't need to update 1 12 to 100 now in this case we are able to reach to City number one with 100 cost so in order to reach to City number two the cost has to be 200 so we can update this value to be 200 and notice that this time we are iterating over for K is equal to 1 we initially started for K is equal to 0 and now we are going to keep on repeating the same process now next thing is 2 to 0 it takes 100 but we don't need to update that because in order to reach to zero we already have the value as zero next one is 1 2 3 as 600 currently in order to reach to one we have the value 100 so we can reach to City number three and 1 2 3 is going to be 700 so we are going to updating the value as as 700 and now next thing is u 2 to 3 is 200 but we cannot reach two in this case because cost array is still showing two as maximum value so we are not able to reach this one so we are not going to be considering this Edge and next thing is next would be the K is equal 2 but the thing is notice we only have K is equal to 1 as Max so the moment we are done with this one we will break out of all the loops and sorry before this one uh we are actually going to updating the temporary array to the cost array as well so now inside our cost array we will have a couple of more entries so in order to reach to City number two it's going to be uh 200 and in order to reach to City number three it's going to be 700 now after this one once we end our Loop we are going to be checking our cost array we are going to be seeing that if the destination city is three and if this value is not maximum then whatever value is we need to return this one so our answer is going to be 700 and if we cannot return 700 like if the value would have been maximum then we would have return return minus1 now let's see let's take one more example for K is equal to 2 just to solidify your understanding once again uh 0 to 1 100 we we already have updated this value 1 to 2 100 we also have updated this value as 200 1 2 to 0 is one uh 100 we don't need to update this one because we have Z as 0 1 to 3 is 600 so this has also been updated and next value is 2 to 3 is 200 so this value we can see that we we are able to reach to City number two that means we can reach to City number three the cost is going to be 200 plus 200 400 but the current maximum cost to reach to that particular city is 700 so we need to remove 700 with 400 because now we can reach to City number three with 400 cost and now say since this is K is equal to 2 once we are done with our Loop we will update this value over here so this becomes uh 400 and then uh in the end if we have to return return the answer we can return return 400 that after with K is equal to two stops we can reach to City number three in 200 cost so imagine see how beautiful the solution is and now I hope you understood that what we are trying to do over here if we have to calculate the time and space complex complexity it's quite obvious that for K times we will have to iterate over all the given uh edges that we currently have and all the given nodes that we currently have so it's going to be K multiplied by the number of nodes and edges so o multiplied by V uh yeah and this would be the time complexity and if we see space complexity we are using couple of arrays to store the values this is going to be the temporary storage and this is going to be the constant storage but both are dependent on the number of cities so let's say if the number of cities are the number of nodes so it's going to B go of n where n defines the number of nodes and this is the whole solution now let's quickly see the coding uh solution for this one so the coding solution is actually quite straightforward first we are going to initialize our cost array then we are going to be filling the cost array with the maximum value possible then we are going to Define that in order to reach to Source City it takes us zero amount so we are going to mark it as zero and then we are going to initialize our two Loops first Loop is only going to run from 0 to K value where we are going to be starting a temporary array where that is going to be the clone of our cost array that we have created so far next we are going to be iterating over every single edge now for this Edge first thing we are going to be doing is defining the value of u v and the cost to reach to that particular City where U is the source City V is the destination city and cost defines that how much money it takes to reach to the destination city the values are extracted from our flights input array next first thing we are checking is that in the original cost array if in order to reach to City U that is the source city is maximum value that means we cannot reach Source City in that K iteration so we need to do we need to continue that operation if that is not the case and we are able to reach to the source City then we are checking that in order to reach to the destination city V what is the current cost we have and if the current cost is actually greater than the cost we are able to achieve using the cost it takes to reach to City U plus the current cost for the based on the current Edge whichever is the smaller we are going to be keeping that value inside of temporary array and once we are done iterating over all the flights for that K iteration we are going to be copying the temporary array inside our cost array and repeat the same process for the next K iteration in the end the answer is quite straightforward we need we simply need to uh check that if the cost to reach to that particular destination city if that is the maximum value possible then we need to return minus one if that is not the case whatever the cost value is we can simply return this one and this is the whole solution look how beautiful it looks now let's try to run the solution seems like it's working as expected let's submit this code and our code runs beautiful it beats almost 97% of all the users which is pretty awesome and uh I would be posting this solution inside our GitHub repository so if you want you can go ahead and check it out from there thank you [Music] the lead Cod problem we are going to solve now is called climbing stairs we can see that this one is an easy problem and also a very well-like problem the statement is quite straightforward that we are trying to climb a staircase that currently has n steps to reach at the top now each time we have the option to either climb one step at a time or two steps at at a time now now we need to determine that in how many distinct unique ways we can reach to the top of the staircase so let's try to understand this with an example suppose we are only dealing with just one single step how many distinct ways we can reach to the top well obviously there is just one way we can reach to the Top by taking one step so in this case we need to return return one as the answer let's say for the same example instead of one what if we have two steps and now we are trying to reach to the top what are the distinct ways so first is distinct ways take one step and then again one step and second distinct way is to take two steps directly so in this case we need to return two as the answer that these we have two distinct ways to reach to the top same way if we have three distinct uh three steps uh how many distinct ways we can reach to the top well we can continue by taking just one step at a time so that is going to be our path number one second path we take two steps and then we take one step or third path we take one step and then we take two steps so overall now we have three distinct ways to reach to the top so this is what we need to return as part of the answer now let's try to understand the most common Brute Force approach to solve this problem well uh the idea is quite straightforward let's say that we are currently dealing with five different stairs now at any given moment uh starting from position zero we have two options first option is either we take one step or uh the option is we take two steps so let's make a decision tree based on that currently we are at Step Zero what are the options we have we we can take one step and reach to step number one or we can take two steps and reach to step number two same way at one we can take one step and reach to step number two or we can reach to two uh uh step number three same way we can reach to step number three or we can reach to uh step number four and over here we can reach to step number four and we can reach to step number five now the moment we reach step number five this is one of the unique paths so we will note this path down and keep on iterating with our uh possible choices so once again over here we will have two choices four and five and once again we will have here one more choice but now notice that there is a big issue with this one why because at every single position we have two dist different ways to choose form and whatever path we take depending on that we are once again going to be dealing with two more positions so in this case the uh time complexity is actually going to be 2 to the power of n which is a very expensive time complexity and we will have to find ways to do things smartly so that's where the most beautiful concept of the Entire Computer Science come into the place and that is called dynamic programming now notice over here that we are doing bunch of repeated work for the same amount of thing that we are calculating we are calculating that what are all going to be all the different options from Two and same calculation we are doing it over here we are calculating that what are going to be all the different options from three and same thing we are calculating over here so why don't we just memo wise or store the information that we have already calculated uh and use it whenever we needs to use it uh sometime in the future and that is the whole idea of dynamic programming so in order to do that or in order to achieve dynamic programming we'll have to understand two things what is going to be the base case scenario or the minimum starting point for us to understand or start building the solution and second one is what is going to be the dynamic programming correlation amongst different parties so for first let's understand the base case well base case is quite straightforward let's say that if we are given zero steps how many different ways we can reach to the zero steps so we can only have one distinct way to reach to the zero step because where we are not taking any steps let's say if we are only given one step how many different ways we can reach to the top we only have one way to reach to the top is that is by taking one step so these two are going to be our base case scenario where uh uh DP of0 is going to be defined as 1 and DP of 1 is also going to be defined as one so now these are the most common entries that are always going to be true and that we can calculate very easily now let's understand that what is going to be the dynamic programming recurrence relationship between uh or any given two parties so for that let's try to understand the scenario we are currently dealing with these five steps and we are trying to determine how many unique ways we can reach to step step number five so the most simplest logic you can think of is that whenever you need to reach to step number five what are the ways to reach to step number five well one way is that either we reach to step number four and then take one step or second way is that we either somehow reach to step number three and then take two steps now you must be thinking that there is one more way where we can take one step from Step number three and then take one more step to step number four well we already covered this case when we first mentioned that whenever like all the different ways you can reach to step number four and then take one step so overall we only have two unique ways to reach to step number five that is through step number three and step number four and once we are at either one of these locations we are guaranteed to reach to step number five so all the ways we can reach to step number three are all the unique ways we can reach to step number five same way all the ways we can reach to step number four are all the ways we can to your step number five and this is going to be some of these two unique ways so this is going to be a recurrence relation why because we are we have the Liberty to choose from one or two steps and uh if we do it like reversely we can just calculate that okay uh we need to calculate all the ways to reach to step number three or step number four and do the sum and that is going to be a recurrence relation based on that we can actually create a mathematical formula that at any given moment DP of I is going to be D DP of I -1 + DP of i - 2 and based on this equation now we can solve all our problem very easily let's say that now we are trying to solve for the answer n is equal to 6 we already know that this is the formula we are going to use to solve this problem on top of it we already have the first two values being filled out why because DP of 0 1 2 3 4 5 and then this is going to be the value number uh six now for DP of 0 we already know it's 1 and DP of 1 we already know it's one so say based on this equation DP of 2 is going to be 1 + 1 so now we can notice that if we have to reach to uh step number two there are two unique ways to reach to step number two and same way has been proven by this equation as well same way for step number three the sum is going to be 1 + 2 so we can do it three same with step number four uh we can do some of these two values so it is going to be five for step number five the sum is going to be 5 + 3 so it is going to be 8 and for step number six it's going to be 8 + 5 so answer is going to be 13 so there are going to be 13 unique ways to reach to step number six and the solution becomes quite easy and simple and notice what we just did is we first establish a base case then we established that what is going to be the relationship and then based on that we kept on populating further and further value so even now if we have to calculate for n is equal to 100 you can do it very easily and very quickly so so logic is quite straightforward uh now we can do one more improvement over here because we are only dealing with two previous values instead of using an entire array to store all the values we can just have two variables previous one and previous two and for every single value we can uh just resolve these values and keep on updating for a subsequent current values so we'll see this in code that how this can work but basically this is the whole idea and based on this you can solve this problem very easily and very quickly if we see time complexity it is going to be big of N and for space complexity well if you use a full array it would be big of n but if you just use couple of variables like this it is going to be biger of one so now let's try to see the coding solution for this one now the coding solution is quite straightforward first we are going to take care of the base cases that if given n is equal to 0 or 1 we can simply return one if that is not the case we are going to initialize two variables to keep track of the previous two steps value and the initial values are going to be 1 and one for Step Zero and step one then we are going to iterate over the given Loop starting from I is equal to 2 or from the third step all the way up to the n and for any particular current step the number of ways we can climb up to that step is going to be sum of previous two elements so we will add that and then we will simply swap the values between previous two and previous one so previous one is going to become the current value and prev two is going to become the previous one value that we had before and after keep we keep on updating that in the end we can simply return uh previous one as the answer and that would be the number total number of ways to reach any particular end step so let's try to run this code okay seems like our solution is working as expected let's submit this code and our code beats 100% of all the other Solutions which is pretty awesome and that is because this runs in 0 milliseconds but anyways this is a beautiful solution and a good introduction towards the dynamic [Music] programming Hello friends so now we are going to solve a very popular lead code problem called minimum cost to climbing stairs this is the subsequent question to another popular lead code problem called just climbing stairs so let's understand the problem statement basically we are given an integer array called cost where every single value inside this array represents the cost of to reach to that particular step in a staircase now once you pay the cost you can either climb one or two steps the question is that we can either start from the very first step or the second step so the zeroth index or the first index and we need to return return the minimum cost to reach to the top of the floor so let's try to understand this with couple of examples first example is that let's say that we are given an input array like this that contains three entries 10 15 and 20 now we can see in this case that if we take one jump straight to the 15 now again from this 15 we have two options we can either take a jump that directly goes to 20 or we can take a jump that directly goes above 20 so basically we are able to reach to the top floor so in this case the answer is quite obvious that if we are able to reach to 15 we can reach to the top floor very easily without paying any extra cost so 15 would be the minimum cost that we need to pay in order to reach to the top floor let's take one broader example now we can see that this staircase has 10 different entries and every single step contains a different price the idea would be if we decide to take two jumps in this case which would be the greedy approach it wouldn't work because we would incur cost that is 100 rather than it would make sense for us to take one jump at this position number one with cost one and then take two jumps now once again when we are at this position once again it would take take sense to take two jumps because once again the cost incurred would be one and once again taking two jumps now after taking two jumps once again it would not be wise to take two jumps directly because we would be encountering cost 100 rather than that we can actually take one jump and incur this cost one and through this one we can also skip over this 100 and take two jumps and reach to one so in total we are only taking six jumps with each jump costing us one unit so in this case the minimum cost we need to pay in order to reach to top would be six so this is what we need to return so the very first approach that comes to our mind is a very simple Brute Force approach the logic is quite straightforward that we calculate every single possibility so we calculate a possibility like this then we start to calculate the possibility like this that taking one jump and then two jumps and three jumps and then we calculate the possibility like this and then this and then this something like this so overall across all the possibilities eventually we would find a a pattern that contains the minimum cost but this is a very inefficient approach we can clearly see why because we are doing repeated work lot of times in order to comprehend and the solution we can solve this problem in N Square time using the Brute Force approach but this is still very inefficient so let's try to see a better approach uh there where we can actually solve this problem so now to solve this problem we are actually going to use the most beautiful thing in the computer science and one of my favorite topics that is dynamic programming why we are choosing dynamic programming to solve this problem well first let me give you a very clear logic if we have to choose any particular value we will have to make the decision based on the previously calculated values and based on that we would be able to Define that whe what is going to be the minimum cost to reach to this step now currently what I'm suggesting is that we use a bottom up approach so we go from the very first entry to the very last entry and at every single step we simply calculate that what if we have to include this step what is going to be the minimum cost associated with this step and let me show you what I mean So currently we have no choice uh to but to calculate that what is going to be the minimum cost to reach to these two values and it's quite straightforward we can always directly make jump to this very first step or very second step so we can create a dynamic programming array and the purpose of this array is going to be that we will calculate that what is the minimum cost it takes to reach to any particular element and we know that for sure the minimum cost is always going to be these two values uh for the first two entries because we can either take one jump or two jump so let's just Mark these two but now when we come to this position we have two options either we take one jump at this step number five and then two jumps directly to step number uh three or we take one jump directly to this step number one and then take one jump over here so if we have to calculate the dynamic programming of this value so let's say that this is currently index position two so this is 0 1 and two okay so the dynamic programming equation is going to be quite straightforward that dynamic programming of two is simply going to be Cost Plus DP of 1 or cost of that this cost defines the current cost of this index okay uh Cost Plus DP of Z so in this case and whichever is the minimum value we will pick that so this equation is going to give us lot of interesting results and build our dynamic programming array so let's try to see our solution for the minimum cost it takes to reach to this step number step with value number 10 one option is that we do uh Cost Plus DP of 1 we know that DP of 1 the value is 1 so this is going to be value 11 and second one is Cost Plus DP of0 so this is going to be 50 and whichever is the smaller we are going to pick this which means if we have to use this step 10 then the minimum amount of work we will have to do is going to be 11 there is no other option so we will just fill that value up once again with this value number two we are going to repeat the same operation and basically the logic is going once again going to be quite straightforward that cost at 2 is going to be dependent on these two entries so 2 + 11 or 2 + 1 so 2 + 1 is 3 so obviously it makes sense for us to give the answer as three and uh not 11 so we'll mark this one this entry and once again this is the top position so once again the top position the value is one now if we have to include this one or not to include this one the once again the logic is quite straightforward we are going to compare the values of the previous two entries which we have already stored and that is three and 11 so once again the total is going to be four that is the smallest entry we need now notice that we have the option to choose the minimum cost among these two entries so whichever is the smaller value amongst these two is the one we are going to pick for the answer because you can go to the top from this two step as well and you can go to the top from this one step as well so once again the minimum of these two is going to be three so we are going to return return three as the answer in this case and this is the whole logic we are I'm suggesting to solve this problem now ideally I created this dynamic programming array to solve this problem but you actually don't need to have an entire array dedicated to solve this problem you can actually just store all the entries in two variables so you can also save so much time uh so much space in terms of space complexity as well now let's try to calculate that what is going to be the time and space complexity for our optimal approach time complexity is going to be big of n because we are iterating over the given input array just once and space complexity well obviously if you decide to use a dynamic programming array then it's going to be bigger of n but if you just use two pointers you can ALS it can also be biger of one as well so now let's see the coding solution for this one so the coding solution is quite straightforward first we are checking for two edge cases that if the given input only contains one or two stairs then we can simply return those values accordingly if that is not the case we are just simply using two variables first and second and we would be updating these two variables continuously now we are starting our Loop starting from the third step or I is equal to 2 to the very end of the given array and we are simply doing a very simple calculation we are checking that what is the current cost for the current step or current I value we are at for that we are defining a new value and we are simply calculating that what is going to be the minimum value of the first or second plus the cost of the current value cost of I then based on that we are updating the values of our first and second so now our first value is going to become the second value we had and our second value is going to become the current value we had which is quite straightforward quite simple to understand and after the end of our Loop we are simply checking that what is going to be the minimum value amongst first or second and we can return that as the answer so let's try to run our code seems like our solution is working as expected let's submit this code and this is beautiful we beat 100% of all the other Solutions and that's because this problem actually runs in 0 milliseconds so no surprises there but important thing is that look at the time complexity we are saving or sorry space complexity we are saving U where we are beating almost 90% of all the other solution so our solution is one of the best Solutions on lead code uh that's because we are using two variables so so once again the solution of this code is present in our GitHub repository feel free to go ahead and check it out thank [Music] you hello friends we are still not employed by Fang company so let's not stop lead coding till we get there the problem we are going to do today is actually asked in lot of top tier it companies and if we look at the recent data it has been asked in Amazon 20 times Apple eight times Facebook two times uh Google six times so needless to say that this is a really important problem uh so I hope you provide your utmost attention uh this is the outline on how we are going to solve this uh and the things I'm going to cover in this video so first we'll understand the problem statement I will be creating a bro for solution uh then we will build an optimal solution with dynamic programming and uh at the end I'm going to show the Java code for this one basically this is a lead code medium problem but in my opinion it should be a lead code easy problem uh because it's not very difficult to understand but the thing is its concept is really important uh that helps you build the conceptual knowledge of dynamic programming which you can use in bunch of different uh problems and lot of fang companies loves to ask this kind of questions so if we understand the problem statement uh basically we are a professional robber uh and we are planning to rob houses in each street now the thing is uh the way houses are mentioned uh in the street is that every single house has some amount uh in that particular house but the only condition we have is if we rob one house we cannot Rob the house that is exactly adjacent to it so suppose we decide to rob this house uh if we rob this house which means that we cannot Rob this house house or this house and uh we can again if we want we can again drop this one uh so that option we have and the our aim is to maximize our profit so basically we are given an input array nums uh that shows that for every single house how much uh amount of money is presented over there and we need to see that what route can we take which maximizes our input or the amount of money we can steal and uh we need to Pro show that in the output so let's uh try to understand this with an example so basically over here we are given the values as 1 2 3 and 1 so notice that the maximum uh amount we can uh steal is basically if we go down this path so if we start with the first house and then notti then we can't use the we can't Rob the second house but then we rob the third house and uh the sum of these two would actually become four and this would be our answer so for the Brute Force we are going to solve the same problem uh basically one way to understand the Brute Force approaches that at every single position initially we are at zeroth location so if we just make all the possible pairs uh which we can create where we can rob houses basically that would be our solution let me show you how so initially at zeroth position now we have two options either we can select the value number one or two so either we can select the first value or second value uh and these are the subsequent values now at this position one we again have two options either we can rob the third house from here or we can skip the third house and we can also Rob the fourth house if we want so the two choices we have over here is either we go down this path or we go down this path and uh at this house number two we only have one option we can't Rob this one or we can't Rob this three so we can only Rob this one so uh the only choice over here we have is actually one and now we just do the sum of all the values so uh for this path the sum we would get is four uh for this particular path the sum we would get is two I just put it in a box so it's easier to differentiate and down this path the maximum sum we can achieve is three so if we compare these three elements we can clearly see that four is maximum so we simply return four now Brute Force solution works but the problem with this one is that we need to create every single pair and uh in order to generate pair essentially at every single position we have two options that whether we need to keep this value or we need to we do not need to keep that value and that eventually would bring a lot of different values in our graph and uh on the number of decisions we can make which means that the time complexity for root Force approach would be you guessed it correctly 2 to the power of n where n is basically whatever the number of inputs given over here and you guessed it correctly also I already gave it away U but we are going to use dynamic programming over here and let me show you how we can use dynamic programming to solve this problem uh we are going to have use a custom example and I have already mentioned it bunch of times that it is really important to have your own custom examples uh that shows that you can think outside outside of the box so over here initially uh we are at this position value number two okay so what we can determine is that initially at this position if we were given only one house what is the maximum amount of value we can steal from this particular house of course the answer is pretty simple we can only steal whatever we are given right because we we are only given just one house so initially at this point suppose if we create an additional data structure that keeps the track of what is the maximum amount of money we can steal up for any element then it becomes then our decision making will become easier and we would be able to choose that what path we want to take uh so let me show you by an example so initially at this position value number two the maximum amount we can Rob will only going to be two because there are no other values before that so this is the maximum amount we can drop so far okay now this at Value number four the maximum amount we can drop is actually up until this point it's only four because we can't use two uh when we are robbing four uh when we if we choose to Rob this second house if we choose to Rob this one we can't use it uh we can't basically use this first house so uh we know that for the first two values these are the maximum amounts we can drop now we are at this position number three so at this position number three we have two options choices are pretty simple either whatever the value maximum we have so far over here which means that so far the maximum value we have is four or whatever the previous maximum value we had plus whatever value we currently are at because remember if we decide to rob this house number three uh basically we can we still have the option to Rob house number two we can't Rob house number four uh so up until this value number five the maximum we can Rob so far is actually uh five why because we can we check that okay up until this point what is the maximum that previous element has dropped basically like one house before this house has dropped and that that maximum value is two so I can do two plus three so maximum I can rob up until this point is actually five so okay we have this knowledge and up until this value the maximum we can Rob is four now let's forget about this one for now because anyways at any given time we are only concerned with the house that are adjacent to each other now we are at this position number nine so what is the maximum value we can rob up until this. n well the answer is quite simple we check that okay uh what are the two values before this nine so this is five which means that if we decide not to Rob Rob now this house the maximum we have robbed so far in this uh Sub sub array is actually five but how do we decide that whether we want to keep this 9 or not well we just need to apply the same logic the house that is adjacent to 9 before that what is the maximum amount we have found so the maximum for that is four and we do 4 + 9 so 4 + 9 is 13 which means that up until this point the maximum we can get the amount is 13 which is definitely greater than five so it is in our interest to keep this pair so far now we can forget about this four because we already calculated its value over here and now at this next value value number 11 again we have two choices do we want to keep 11 or not so again we do the same thing we compare 11 with whatever value we have over here we do first of all we do sum of 11 + uh this 5 so we do 11 + 5 okay this one is 16 so which is greater than 13 which means it is in our interest to keep the value 11 uh so again we are going to have 16 over here we can forget about this one because we already calculated its value and uh yeah so we are now the two choices we have is 16 and 13 and this value number two we need to check two items uh so value before that this is 16 and this one is 13 so we do 13 + 2 15 so so far if we decide to keep this value number two in our list of houses that we are planing to rob the maximum value we can achieve so far is 15 uh but the thing is we have already found a better option than this 15 and which is 16 uh where if we decide to rob these three houses we will get the optimal uh answer and notice that every s we were able to complete this whole iteration in just single uh it we were able to complete this whole calculation in just a single Loop uh because we are keeping track of uh whatever the elements we have calculated so far which is the exact use of dynamic programming and we are not using more than one element at any given moment which means that our solution is actually quite helpful and uh very perfect so let's calculate the time and space complexity and basically this would be the optimal solution so time complexity as you guessed it correctly it's actually bigo of n because we are completing everything in just one single iteration we don't need to do multiple rounds of uh checks and the space complexity uh we have is actually big go of one it's actually constant time because notice that at any given moment the maximum value we are keeping track of is just couple of elements uh and uh we kept on updating our elements that whatever we are keeping track of which means that uh we are not using that much space we are not creating an additional array to store all the values okay let's create two elements uh we'll name it Rob one and uh initialize it to zero and we'll create a Rob two we'll also initialize it to zero and we'll have another variable we'll just name liit Max to keep track of Maximum element that we have calculated so far and now let's run a for Loop inside the loop first of all we'll calculate that whether we have achieved the maximum value or not so max would be so whatever value we have at Dr one plus whatever value Val we are currently at so this is one option or whatever the value of Rob two we have because notice that the drop Two element is actually right adjacent to this e element and now we need to update the values of Rob one and Rob two so Rob one will actually become whatever value of Rob two we had because we are updating it every single iteration and Rob two will actually become the maximum value we have found so far and uh yeah I think this this should be our solution and at the end we will return uh the max element so let's try to run this code okay now our solution seems to be working let's try to submit it oh okay yeah our solution is actually 0o runs in 0 millisecond and it's 100 times faster than all the other Solutions but the thing is this is not true uh because we are given a limited number of test cases we are Computing everything in just constant time so that's why it's showing us 100% faster Hello friends we are still not employed by a Fang company so let's not stop lead coding till we get there uh today we are going to do a very important problem House robber 2 and this is actually an extension of original House robber problem I have already solved the House robber problem over here so you can check out that video and I highly recommend that you check out that video before coming to coming on to this problem uh typically in any interview this problem is actually going to be asked as an as a follow-up question after they have originally asked this house robber problem and that is why if we see the number of companies that have asked this question recently it's actually quite small compared to what we are used to seeing for the other companies but thing is still Amazon and Google have asked this recently even Microsoft asked this just a little bit sometimes back and also few other companies have asked this so this is a lead code medium problem and uh basically the problem statement uh is saying that we are professional robber and we are planning to rob houses along the street now the catch over here is that the all the houses in the in this given Street are actually arranged in a circular fashion and also there there is one more constraint that we cannot uh Rob two houses that are adjacent to each other if we rob two houses that are adjacent to each other uh basically police is going to be called and we will be caught uh so this is a constraint that we have to look into and our uh our motive is to collect or gain or Rob as much money as possible without being caught so let's try to uh let's try to see a pictorial representation so basically all the houses in the street are actually placed like this so suppose if we consider that this is our first house uh actually the first house is also neighbor of the last house uh in the given street because all the houses are stored in a circular fashion and now since the houses are stored in a circular fashion that is one more thing that we need to consider and also we cannot Rob two adjacent houses so suppose if we decide to rob this house we cannot Rob this house or we cannot Rob this house so the first example we are given is the houses are uh placed like this and uh these are the amount of money that is uh at each house so basically since there are only three houses we can only Rob one house and we need to select the house with maximum money so it's pretty simple over here that if we select this house we get the maximum money and if we rob the house with value number three we can't Rob uh these two houses because because they are adjacent to each other uh in the second example the houses are stored like this 1 2 3 and 1 and uh the most amount we can collect over here would be if we rob this house and this house so in that case the amount of money we would collect would be four and uh we won't be able to Rob these two houses because they would be adjacent to each other so we already know the Brute Force approach basically The Brute Force approach is to make every single uh pair uh and check out all the possibilities to see how we can uh find the answer but the thing is there is no point in go exploring Brute Force approach over here uh I'll directly go to the most optimal solution that we are going to achieve using dynamic programming because this is an extension of uh House robber one if you want to get get more information about the approach you can check out that video first so for the optimal solution we are going to use a custom example and this this is very important to use custom examples because it shows that you can create test cases on your own and this is a really good skill to have in actual Computer World so suppose the number of houses we are given over here are in this fashion and uh let's try to draw them in a circular manner now basically we can use the same solution we were using in uh House robber one because remember in in House robber one what we are doing we were just simply going through whatever the input we had and we were just keeping track of what is at any location what is the maximum amount of money we can rob up until this element uh by checking the previous values we are essentially going to do the same thing over here but just in a little bit different manner because uh in the House robber one problem we were considering the whole thing because they were uh all the houses were placed in a straight line so we were able to consider them like that the thing is over here the additional constraint is that whatever the last Mount or the last house is is actually neighbor of the first house which we can see over here that these two houses are neighbors of each other which means that if we at any point decide to rob this house we cannot Rob this house or vice versa that uh if we decide to rob this house first house we need to make sure that we do not Rob this house so the answer is actually quite simple rather than treating this as a circular uh Street why don't we just uh run two functions so basically uh in during the first uh uh loop during the first uh iteration we are going to check the first sub problem and let me show you what I mean the additional constraint we have over here is that if we consider this house uh it is guaranteed that we cannot use the last house or if we use the last house it is guaranteed that we cannot use the first house so since we know that this this condition exist why we are simply going to uh do calculation twice in the first calculation we are going to check between these houses that what is the maximum amount we can Rob and during the second uh loop we are going to check that amongst these houses what is the maximum amount we can Rob and then we just need to compare that what is the maximum value we have found across both the loops and whatever the maximum value we find we just uh push it we just submit it as uh our answer so let's iterate over the uh entire problem okay so these are the two Loops that we are going to iterate over so let's calculate the result for the first uh loop so for at the first position the maximum amount we can drop so far is only going to be one and at the second house the maximum amount we can drop is only going to be two because we cannot drop the first house now the for the third house we have two options either we keep whatever the value of two we have or we keep the value of 1 plus the third house value and we check we see that whatever is the maximum value amongst these two we are going to keep that so 1 + 15 is going to be 16 and of course 16 is greater than two so we are going to say that up until this house number three the max maximum amount we can Rob is 16 now we are at the fourth position now over here the maximum amount we can Rob is actually two we have two options either we can Rob on 16 units or we can do two plus whatever value at house number four we have so 2 + 11 is actually 13 Which is less than 16 so even up until this point the maximum amount we can Rob is still going to remain 16 and not 13 because uh definitely 16 is greater than greater value so it is in our interest to uh keep this value 16 now again we are at this position three and also notice that at any given location we are only considered with values that are uh of previous two houses that we have calculated over here we don't need to consider all the values because we are already adding them up and we are only keeping the maximum values so this works in our favor so at Value number three uh the maximum we can achieve is either 16 + 3 or 16 by itself which is this 16 or 16 + 3 so of course 16 + 3 is going to be greater so we are going to store 19 and we don't care about these values anymore because we already have the latest values so far now at Value number six the maximum we can find is is going to be 16 + 6 or 19 we need to select whatever is greater so 16 + 6 is 22 this is the greater value so we are going to keep this and we don't care about 19 so we can see that at the end of this first Loop the maximum value we have found so far for this particular uh set of houses is 22 now let's repeat the same process for the second uh uh loop so in the second Loop for the first position the maximum we can drop so far is two uh at the second house the maximum we can Rob is 15 now over here the maximum we can Rob is either 2 + 11 which is 13 or 15 so of course 15 is greater so we are going to keep 15 over here now at this position number three we can either do 15 + 3 or compare it with 15 so 15 + 3 is 18 so we are going to keep 18 over here now at this position we consider these two values so either we do 15 + 6 which is 21 or we check with 18 so 21 is greater so of course we are going to keep this one and now at this last position we check that whether 21 or 18 + 10 so of course 18 + 10 is 28 so we are going to keep that and we are we do not consider about 18 so after this entire Loop the maximum value we have found so far is is 28 and the maximum value we had found over here was 22 so our job is pretty simple we just just need to see that whichever value is actually greater we simply return that and in this case 28 is greater than 22 so 28 would be our answer and we just return that value uh this is a very good solution we are building it on top of whatever we have solved for house uh robber one and because we are basically using the same solution we are just changing the scope of uh up until what points we are using this solution so just keep that in mind and uh if we calculate the time and space complexity uh the time complexity for this one is going to be bigo of 2 N uh because we are running two Loops uh 0 to n minus 1 and N uh 1 to n uh so if we gener generically mention this it actually becomes becomes bigger of n and uh if we calculate the space complexity the space complexity would be big of one because we are apart from storing couple of parameters we are not using any additional space so that's why we we are able to run this in a constant time uh sorry constant space okay let's start creating parameters so we are going to need two parameters Rob 1 and Rob two and we are going to initialize both to zero we will also need two parameters to store two maximum values so we'll name them Max one and Max 2 and Max one will initialize it to uh the zeroth house and Max 2 we can actually initialize it to uh zero because we are not going to consider the first house and we are keeping the max one as zero because in case we are given the condition where we only have uh one input so we can simply return that now let's run a for Loop starting from the first house so I equal to 0 to I is less than uh length minus 1 I ++ okay over here we are going to calculate max one so max one would be uh maximum value amongst Rob 1 plus uh the current number we are at or uh the value of Rob and we also need to update the value of Rob 1 and Rob two so Rob one would actually become Rob two and uh Rob 2 will become the maximum value we have found so far now once we are done with this Loop we need to reset the values of Rob 1 uh equal to Z and Rob 2 equal to0 because we are going to use them again in the second Loop and uh we are going to create another for Loop uh I = to 1 and we we are going to set up I is less than so nums do length I'll Plus+ okay and essentially we are going to use the same conditions uh by the way we this would be Max one we are going to use the same condition so we can just reuse the code and uh we are going to rather than calculating Max one we will be calculating Max 2 so let's do that and uh after the second Loop we still we simply need to return whatever the maximum value we have found amongst Max one and Max 2 and uh this this should be the solution now notice that I'm running two Loops over here but the thing is uh an efficient way to do this is to create a function and uh function would uh intake the parameters like start and end value and you can just repeat this process so that would be an uh efficient way to do do this code as well let's try to run this okay seems like our solution is working let's try to submit the code Hello friends we not by F company so let's not stop lead coding till we get there today we are going to do longest palindromic substring lead code problem and if we see some of the companies where I want to get a job who have already asked this question there are companies like Amazon Microsoft Google adob Apple Bloomberg Goldman sax Tik Tok Uber bite dance LinkedIn Tesla and eBay so that's why I'm paying my atmost attention I hope you also enjoy the video this is the lead code medium problem and also one of the very well like problems on lead code uh basically we are given a string s and we need to return the longest palindromic substring that is present inside this original given string s so in order to understand this problem first of all we'll have to identify that what is a palindromic string and a palindromic string is basically as the name suggests any string that forms a palindrome and we know that palindrome is any string where if you read it from left to right or right to left uh the number of sequencing is same so in this case a b a is actually an example of a palindromic string also a b b a is also an example of palindromic string because in either of these two cases whatever you whatever side you decide to move along the number of character occurrences Remains the Same so that's why they are palr and now our aim is to find the longest palindromic substring inside this given original string s this is not a very good example to understand so let me create a custom example in this case we need to find that what is the longest palindromic substring so if we see the string s by itself it's actually not a palindrome but if we see these three values a b a and we get rid of this B and D we can actually create a pandrum which means in this case we can return the answer as a b a to be longest palindromic substring that is present inside this given string s and this is exactly what we need to return so now let's see that what would be the different approaches to solve this problem in order to understand the Brute Force way we will have to identify that what is the thing we need we need the longest palindromic substring that is present inside this original given string s so the aim is that we need to find a substring uh so why don't we just use the brute force method and we find every single possible substring that we can make out of this given example s so we can make bunch of different substrings let me just draw some substrings over here so these are some of the substrings that we are able to generate from this original given strings now our aim is to find that what is the palindromic substring if the substring is palindromic we will find its length and then we will try to find the longest palindromic sust strring in that way so uh we can clearly see that in this case this AB a is going to be the answer for this longest palindromic substring and eventually we would be able to find this solution using the brute force method but what is the issue with this like issue is actually pretty evident that even for this four character string we will we had to create bunch of different substrings and out of all of the those substrings we will have to find some effort and resources to find that what is the longest palindromic substring so that is just waste of time and uh energy if we see the time complexity in this case the time complexity is actually going to be big of n Cube why M Cube because it takes n Square time just to create these substrings and after doing that we will also have to identify that whether those given strings are actually palindromic substrings or not and which is the longest amongst all of them so that also takes end time so that's why the overall we can write it as big of n Cube time complexity so let's see that what would be the better approach to solve this problem well before we come to the optimal solution was let's build some intuition behind achieving that optimal solution uh the idea is that we need to find the longest palindromic substring now there are two possibilities we could have an odd number of string that is a palindrome or we could have an even number of string that is actually a palindrome now in each cases the middle value is actually providing some interesting results and the thing is that in both both the cases the palindromes are actually built around these middle values how let me quickly show it to you well if we just take this mam for an example over here we can actually conclude this D to be a substring in its own and because this is a single character substring we can actually conclude this to be a palindrome as well uh because if we read from this left direction or right direction in each cases we are going to get the same result now if we add these two A's uh to this D we will also get the substring that looks like this a d a now in each cases this D remains common but the left value and the right value because they both are same we can conclude conclude this string to be a palindrome as well now again if we repeat the same process and we add this M and M again because they both are same and we are adding at the corners so if we add them we will get a value that looks like this now this D originally was a palindrome after adding this a a it remained pal Drome because both character had the same value and again after adding this mm again it the whole thing Remain the palindrome because they both had the same value now in this case if I extend and if I add a value that looks like X and Y over here so this X and Y is actually not same so this whole thing will not be a palindrome but this middle portion will actually be a palindrome and in this case because we had odd number of characters that are forming a character uh we actually have just one value that we can consider as middle value and all the other values from this middle value are actually just a bunch of set of characters they who both have same same values let's take an example for this even number case now in this case actually we have two middle values and the two middle values are BB now if we were to consider this BB this is actually palindrome in itself because again by definition even if we go from left or right in each cases we are reading the same value now again this a a both are same value and they are actually same value that Corners our original given middle values so if we form a value that looks like this this BB was already a palindrome and the two values we added they are also same so because they are same this whole thing actually becomes a palindrome and again just like this case if we add an X and Y over here this whole thing will not be a palindrome only this A B B A would remain palindrome so now after knowing this solution actually it becomes really easy for us to identify that what would be be the optimal solution suppose this is the example that we are given and we are trying to find the optimal solution for that what we are going to do is we are actually going to expand on the corners and we are trying to see that whether the left and right value of any middle value if they are actually same or not if they are same we can consider the whole part to be part of any palindrome if they are not same then we will move on to the next value and start doing the same process now there could be two possibilities we could have an odd length palindrome where we will only have one middle value or we could have an even length Palin room where we will actually have two middle values so in each cases we will have to take care of them so I'll be showing you the odd example first and then I'll show you the even example and uh basically it's slightly different idea and uh I'll just show you when we when we go there so first of all uh we are going to take this value X now we are going to expand upon the corners uh so we are going to see that whether this x could be the middle of a longest palindromic substring if that is the case then we will expand upon this x so we will try to see its left value and right value the left value is actually null and right value is actually M now uh this left and right they are not same and also this middle value is actually not same with this right value and it's also not same with this left value which means in each cases this x is actually not part of the middle of longest palindromic substring so we will get rid of it and we will move on to the next value now we are at this value number M again we try to see the What is the left and right value left is actually X right is actually a again they both are not same and none of them are same with this m so which means that now we will move on to the next value next value is actually a again the left value is M right value is D nothing is same so we will move on to the next value because this is also not a part of the palindrome now we are at this position number D now if we take the left and right value the left value is actually a and the right value is also actually a so because this left and right value is same this D could be a middle of any palr we don't know if it is the longest palindromic substring or not now the longest palindromic substring that we have found so far is actually of length one why length on because any character in itself is also a palindrome remember that so that's why now we have this new substring that looks like this a b a this is also palindrome and we will try to see that whether it is longer than whatever the existing palindrome we have which is true that this AB a is actually longer so we'll have to update the value of this AB over here seeing that this is the longest palindrome we have found so far we will keep on expanding on its corner so so far the values we have is a b a again we will move on the left and right pointer so uh this is M and this is also M so because they both are same again we can consider this to be a palindrome and the previous longest palindromic substring we had was a a but this is actually greater than that so we'll update its value and now the longest palindromic substring we have found so far is madam Madam now again we will go and uh repeat the same process repeat the same process over here we will have the value Y and over here we will have the value X so these two are not same so because these two are not same now we are no longer forming a palindrome so we will have to get out of it so we will just move on to the next value and if we move on to the next value the next value is actually a so again this a uh the left value is D and right value is M so this is not a palindrome we will go back to m m is also not part of any middle of any palindrome and this Y is also not part part of any middle of the palindrome so now we are done for our example so far and in this case whatever the answer we have found over here for the longest palindromic substring which is m a d a m we will return this as our answer and this solution would work work as expected now this was the case of odd number of palindrome that be that is being the longest let's see the even number of palindrome so in this case again we are going to repeat the same process first of all we'll take this x we take the left and right value again we don't find anything interesting so we'll move on to the next value now next value is a again we check left and again we check right we don't find anything right uh because so we'll move on to the next value now again we are at this position number B now we are at this position number V if we check the left value we find a but if we check the right value we actually find another B so because these two are same actually the combination of these two B's could be the middle of a the longest palindromic substring and that that is going to be true in this case so we are going to to expand on a little bit differently now now we are going to have this BB as the middle of the longest palindromic substring we have found so far and we will repeat the same process so we will try to find that whether what are the left and right values so left value is a and right value is also a so again this is a b b a because these two are same and this middle portion we are just considered to be the middle so this is also forming a palindrome and the longest palindromic substring we had so far was only of length one and then when we found this b b it become of length two and now we have this AB b b a so this is of length four so because this is of length four we will have to update the longest peloric substring we have found so far to be a b b a now again we will repeat the same process so if we again go left and right this is actually X and this is y so now these two are not same because these two are not same so now we will just get out of it we will again check with this a and why we don't find any pend and we would be done with this one so in this case we would return this a b b a as part of our answer and that would be the final solution so the time complexity in this case is actually going to be bigo of n Square now why n Square because we will have to iterate over every single value to see that whether that is the middle of the longest bomic subring or not that takes uh n time and if we will have to iterate over all the values on the left and right side to see that whether it's the longest bomic substring or not which means that in the worst case scenario we might have to iterate Over N Square Times to find the answer uh in terms of space complexity we might have to keep track of big off n characters at any given moment where n is the number of characters present inside the string now this is actually a much bigger Improvement compared to our Brute Force approach which had the time complexity of big off n Cube actually and now let's move on to the coding first of all we are going to check some edge cases if that is not the case we are going to run a four Loop across the given string for the any value we are iterating over we don't know that whether it is the middle of the longest palindromic substring of an even length or of an odd length so at any given time we are actually going to have two variables that call a function where we are going to check that whether the odd length or even length palindromic substring can it be the middle of any palindrome and uh so first I'll create two variables and we'll name it as Len one and Len two and we are going to call a function called check palindrome inside this function we are going to provide the value of given string X current position of I and we are considering this to be an odd length so that's why we are considering I to be the middle element also we are going to create a variable called length two we are again going to call the check palindrome function we providing the value of string s we are also providing the value of I and we are also providing the value of I + 1 uh y + one because remember that in the even length palindrome we actually have two middle entries and that is how we are going to do it and and also we are going to have a variable called length where we are going to keep track of the maximum length of palindrome we have found so far remember that amongst these Len one and Len two at any given moment if we identify that there exists some valid pendum and we have found the maximum value we might have to update the value of the maximum variable so we are going to uh check for that condition as well for that we actually need two pointers called left and right and we are going to check the whether the given length we are getting if that is greater than the left and right length we have already found so far the thing is we haven't declared these variables yet so first of all let me quickly declare these variables and we are going to initialize their values as zero we are going to update the value of the left pointer uh and that will be decided based on the value of I so we are going to do I minus whatever the value of uh current length we have found we need to do it divide by two but thing is we don't know that whether that length is odd or even so we will subtract it by one value and then we will divide it by two so in any case we will get the correct result for the left pointer and for the right pointer we are actually going to do I plus whatever the length we have found uh divided by 2 and this should give us left and right pointer to create the desired substring and after we we run out of the loop we will simply return the substring so now we are done with most of the logic in the main uh method now we'll just have to create this check palindrome method so let's assign the value L and R uh for the ease of our use now we are going to run a while loop that until the point when we have a valid palindrome we will keep on reducing the value of left and updating the value of right and we will check that whether both values are same or not we'll also take care of some edge cases while the existing value is a valid pal room we will reduce the value of left pointer and we will update the value of right pointer this while loop we will return the whatever the length we have found so far this should do it let's try to run this code we will have to update the value of this right pointer by one let's try to run the code again okay seems like our solution is working let's submit the code and our code works as expected I'll be posting this in the comment so you can check it out from there thank you hello friends we are not by a Fang company so let's not stop lead coding till we get there today we are going to do palindromic substrings lead code problem and if we see some of the companies where I want to get a job who have already asked this question there are companies like Facebook Amazon Twitter Google Microsoft Uber Goldman Sach Apple Bloomberg and Linkedin so that's why I'm paying my atmost attention I hope you also enjoy the video so this is a lead code medium problem and basically we are given a string s and we need to return the number of palindromic substrings that exist inside this given string is uh lucky for us we are given the definition that what a palindrome is basically a palindrome is a string that reads the same from backwards and frontwards so suppose we are given a string like this g g if we read it from the backwards or frontwards in both the cases the answer Remains the Same also one more example A B A this is also an example of palindrome because in either case we read it the answer Remains the Same now a quick question for you guys that whether this character B is this an example of a palindrome or not and the answer is yes this is also a palindrome why because if we read it from the left and also read it from the right we get the same result but if we are given a string that looks like this a b this is not a palindrome because if we read it from the left and from the right the answer is not the same so these are some of the examples of a palindrome um we are also given the definition of a substring but I don't think that it is necessary to Define it is actually pretty trivial now let's try to understand this problem with an example suppose we are given a string s that looks like the c a b a now in this case we need to find that what are the number of palindromic substrings that exist so we can clearly see that we have a pend Ric substring that are these four characters are actually palindrome in itself because as I mentioned earlier over here that even a single character is also a palindrome in itself so we already have four palindromic substrings so far but if you notice over here we also have one more palindrome that is this ab and that is also a palindromic substrings which means that in this case we need to return five as our answer that we can actually make five palindromic substrings for this given string s and this is what we need to return so let's see that what would be the difference approaches to solve this problem suppose this is the svr given and we need to find that what would be the broad Force solution for this problem well we have to understand that we need to find all the existing palindromic substrings that are present inside this given strings which means we need to find the substrings so what we can do is we will make all the possible substrings that we can make from this given s and then we will check that whether that substring is a palindrome or not and simply we will get our desired answer so if we see that in action for this particular string we can actually make substrings that look looks like these so these are all the substrings that we can make from this given string s now all we have to do is check that whether any given string is a palindrome or not and in this case we will find that these four strings are palindromes and also this string is a palindrome all the other strings are not palindromes and then in the end we can return five as the answer for this problem and that would be a valid answer for this problem but what is the issue with the Brute Force approach well the issue with the Brute Force approach is that the time complexity in this case is actually going to be big go of n n Cube why n Cube because it takes n Square time just to make these substrings and then it takes n time to check whether a substring is a palindrome or not so cumulatively this is a very bad time complexity and we will have to find a better approach so before we move for the optimal solution first of all we'll have to build some intuition behind it that how to identify a palindrome well in the palindrome there could be two possibilities the palindrome could be of odd length or it could be of even length first let's see that what would be the scenario in the odd length so suppose we are given this character o this is a palindrome in itself we have already ENT identified that because if we read it from left or right we get the same result right now if I decide to add two more characters x o XX at the edges this Still Remains the palindrome which means that because both of these X's were same uh and this middle middle value was a palindrome in itself this whole thing actually became a palindrome again if I take it even further if I add two more characters BB again this whole thing Still Remains a palindrome and if I keep on adding same values as long as they are same this will always remain the palindrome but the moment I add a value that likes A and B now this whole thing is not a palindrome because these two values are different but this portion is still a palindrome and also the smaller portions Still Remains the palindrome which means we can Define that the palindromes are like an onion where the middle value Remains the Same and because of the middle values all the other subsequent values where the values are actually same the palindromic property is sustained why I'm giving so much explanation for that uh is you will see it in the optimal solution and the in the odd cases we only have one value as the middle character but inside the even character suppose we are given a value like BB so this is a palindrome in itself and both values are same because both values are same uh this is an even length and this is an even length pendum now again I decide to add two more characters XX because they both are same this Still Remains the palindrome again I add value a a this is also pal but the moment I add a value that is different like X and Y now this whole thing is not a palindrome but this middle portion Still Remains a palindrome so that is the important property that in case of odd length we we have a middle character of the palindrome that is a single character and all the other characters has the same value in case of the even length palindrome we have two characters that are same so that is important two characters they are both same and then all the other characters they are also same as well and a smaller pal is forming a larger palindrome and let's see that how can we use this property to find an optimal solution so suppose this is the example we are given and we need to find the optimal solution for that the idea is that at any given character we are actually going to see that whether could this be a middle of any palindrome and if it is the middle of the palindrome we are going to keep on expanding our palindromic search and we are going to keep adding our answer result first of all let's see for this character number c that can the C be part of any middle of the pal palindromic substring or not well we already know that the C is a substring in itself because if we read it from left or right we get the same result and we are also going to have a variable called answer so initial value was Zero now because this C so now because the C is a palindrome in itself we are going to add the value to our answer as well now we are going to see that whether the C is a middle of the palindrome or not which is not why because if we see the left of the string and right of the uh C this is actually a null value and this is a which means both are not same so because both are not same this is not part of any middle of the substring now we are going to have this value a again we are going to repeat the same process well a is a palindrome in itself uh so we are going to add the value to our answer first of all so this becomes two now again we are going to check that whether this a is a middle of any palindrome or not we also have to check for both the cases that could this be of odd length palindrome or an even length palindrome so for odd length palindrome like the both left and right value would be same and for even length palindrome the value would be same with that itself so first of all we are going to check with the a so the left value is C and right value is actually B so both are not same also they are not same of this A and B which means this is not an odd length palindrome and even length palindrome so we are good to go now we will move on to the next value B now this next value B is a palindrome in itself so we will update the value inside our answer to three after doing that we are going to check that could this be the middle of any palindrome or not so we will check the left and right value left value is a and right value is also a so because these two are same we can Define that this B is actually part of the middle of the palindrome which is of odd length and we are going to keep on expanding our palindrome so now this b a b so sorry now this a b a is also palindrome so we will update our answer immediately so answer becomes four now now again we will keep on expanding our palindrome so if we do a left and right over here the left value is C and right value is actually null so these two are not same because these two are not same we no longer have a palindrome so we will break out of the loop now again we still have one more character left to check so again we will check for this value number a so a is a palindrome in itself we will put the answer as five then again we will check that whether this a is a is that a middle of any palindromic string or not so we check left and right value left value is B and right value is actually null which means these two are not same and they're not same of this a as well uh so immediately we will break out of the loop and we can return uh and the next value over here is actually null which means we don't have anything we have reached to the end of the string so this is the answer we need to return in this case that five would be the answer and we will return that let's see one more example s where we will find the even length palindrome so over here again we are going to repeat the same process so first of all we'll take this character number c can the C be part of the any middle of the substring or not so this is not part of any middle of the substring and we will have an answer variable so first of all we'll initialize it to one because C is a substring in itself now we will move on to the next value a so a a if we check the left and right pointer left is C and right is B so these two are not same so immediately a is also not the middle of any new palindrome but it is the palindrome in itself so again we will update the value to two now again we are at this position number B now at this position number B if we compare left and right values so left value is a and right value is B so these two are not same but these two are actually same so we can Define this BB to be a middle of a palindrome and this is the property we are going to use right and by the way for this B first of all we will update the value to three and now we have this BB that is a middle of the sub palindrome now immediately we will check the left and right Valu so left value is a right value is also a again these two are same so this is also palindrome so we will update our answer again so this becomes four now again we will check the left and right value over here so left value is C and right value is actually null so in this case these two are not same because these two are not same we will break out of the loop and we will say that okay so far we have found something decent so right now again we are at this position number B now remember that this becomes little bit tricky that it becomes easy for us to if we check over here this left value is actually B and right value is a so again these two are same but we should not fall for this strap because we have already concluded this BB to be a middle of the palindrome so we will not consider this one and this is also not a palindrome which means that the answer we will only update by one and that this value by itself is a palindrome and at the end we will check for this value number A and A is a palindrome in itself so we will update the value to be six but in the left and right there is nothing so we won't do anything with that and in the end we will return this answer six to be the final answer and this is the solution we are going to use to find all the palindromic substrings inside any given string s this is the final optimal solution if we see the time and space complexity in this case the time complexity is actually going to be biger of n Square why n Square because it takes us end time to iterate over all the values and for any single value we might have to iterate over all the remaining values so that takes n Square time but this is still a big Improvement compared to our Brute Force approach which had the uh n Cube if we see the space complexity in this case the space complexity is actually going to be bigger of n because at any given point we might have to store all the values of n of all we are going to initialize a variable called answer and we are going to assign the value as zero now we are going to create a for Loop and iterate over the given input now we have two possibilities any single character inside this given string s could be the middle value of any odd length palindrome or an even length palindrome so we are actually going to make two calls to our check palindrome method where we are going to return a value that whether this given string is a palindrome or not and we are going to add that value to our answer variable and inside this method we are going to pass the value of our string s and we are also going to pass the character position of the middle variable so the odd length palindrome would have the same same middle value so we will pass on that and for even length we are going to pass two values so over here we we will pass I and we will also plus I + 1 to be the middle characters basically after we get out of this Loop we should have our answer ready so we can simply return that now let's create this check palindrome method and we will initialize a variable called count to count the number of palindromes we encounter now we are going to run a while loop that while now the left and right pointer are in bounds are and not out of bounds and while their character positions are same so which means they satisfied to be the palindrome if that is the case we will keep on updating their values and we will keep on adding our count variable and in the end we will return the count variable so let me quickly type it type that so this condition defines that whether this given string is a valid palindrome or not if that is the case we will decrement the value of our left pointer we will increment the value of our right pointer and we will increment the value of our count variable and once that is done once we get out of this Loop we simply need to return the count variable and that's it uh so let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs pretty efficiently and I will be posting this solution in the comments so you can check it out from there thank you Hello friends we are still not employed by Fang company so let's not stop lead coding till we get there today we are going to do a very important lead code problem decode ways and uh this problem has been asked in bunch of different Fang companies like Amazon Google Facebook uh Microsoft Uber Lyft Apple so I highly recommend that you focus full attention to this problem uh this is the breakdown that we are going to do for this problem we are simply going to understand the problem first we are going to see a Brute Force solution based on the Brute Force solution we are going to see that how can we create an optimal solution and eventually we will write the Java code for that and uh this is a lead code medium problem and we are given a note that uh basically a message containing letters can be encoded into numbers using the following method so a is 1 B is two and up until that if we keep doing that uh Z is actually 26 and uh we are given a string of uh s that contains digits and we need to return the number of different ways we can decode it so let's understand this with an example suppose our given input s is equal to 12 uh we can decode this in uh two ways so one way to decode this would be to consider 1 and two as separate elements and 12 by self as a single digit so this uh the value for 1 and two would become a and b using this logic and the value of 12 would become the letter L so we don't need to return these values we don't care about them the thing is we need to return that how many different ways we are uh decoding this uh given input string and in this case the answer would be two let's take another example so suppose our given input s is equal to 226 how many times uh how how many different ways we can decode this one so one way to decode this one is uh 2 and uh 26 so that's one way second way to decode this one is two or two and six so that is second way and the third way to decode this one 22 and six and uh if we check out the values so this would becomes B uh Z this would becomes b b f and this would become VF so over here we can see that there are three ways we are decoding this given string so in the answer we will return the value as three now there is let's consider one more case uh suppose the value 0 0 would be a special case and uh there could be multiple possibilities where zero can appear so suppose our given input s is something like 0 1 uh 1 so in this case we won't be decode it in any manner because uh remember that our range starts from this value number one up until 26 so zero is not part of the range so we cannot begin our string with value zero at the beginning so this won't work uh second possibility that zero could be somewhere in the middle so suppose the our given input s is equal to 1 0 1 something like this so in this case we cannot decode this in 1 and 01 we can't do this why because we can't decode this 01 because remember that in this scenario if zero comes at the beginning we can't decode it uh the way we can decode this is we can consider this as 10 and this as 1 that value of zero can appear at the end so our input string s can be something like uh 2 0 0 so in this case we can decode this value to Z but we can't decode this zero so we won't be ble to return anything or our value s can be uh 52 0 so in this case we can decode this we can decode this value 5 and we can decode this value 2 0 because 20 is again between 1 to 26 uh but if we are given something s is equal to like 5 70 we can't decode this because we can decode this five but we can't decode 7 0 because 70 is not part of uh this 1 to 26 range so when value Z comes in it becomes a little bit tricky and we have to just take care of it for Brute Force approach let's take a custom example suppose our given s is equal to 2 1 2 3 and uh we need to see that how many different ways we can uh decode this one so Brute Force approach is pretty simple we just take all the possibilities uh starting from the first value and keep moving and keep building our solution and when we reach at the end at any given path we consider it as a one way to decode it so initially we can decode this as two and whatever the remaining value 1 2 3 we can decode this further into 2 1 and whatever value remaining again same thing 2 1 2 and uh this three and uh in the in the end we can decode this as 2 1 2 3 so this would be one way we would be able to decode this so where if we treat all the values as separate entities now let's see let's go back and see that can we can we have more possibilities so over here we cannot have any more possibilities because this two one and two are already being decoded and this three we only have one possibility to decode it by itself so we don't have any any possibility over here so we go back uh further up do we have any possibility over here so yes over here we still have possibility that we can decode this 2 and one the same way we have decoded over here but this 23 we can decode it as a single value so of course we reach at the end of the loop so this is one more possibility on how we can decode it now let's go back so for this value 123 uh of course we have we still have more possibilities because over here we are considering this value as two and one separately so over here we will consider this as two as already being decoded and rather than considering this as one a separate character we can also consider is it as one two and then we can decode three so this can also be another way so we'll just mark it okay now we have exhausted all the possibilities over here uh considering this value if we start from this value number two so we come back at our uh main point and let's see that what are the more possibilities we can have over here so we can do rather than choosing two we can choose 2 one and whatever the remaining Stream So remaining is 23 okay now let's see that how many different possibilities we can have over here so we can have two possibilities now we can do like 21 2 and three so that is one option or we can do 21 and 23 so that is second option and uh yeah both would be a separate ways and apart from these we cannot make any other possibilities so essentially we are uh we can say that there are five different ways to uh decode this 2123 string and uh those five ways are U mentioned over here uh what is the problem with this Brute Force approach well the problem with Brute Force approach is that actually we are doing a lot of repeative work uh how we are doing repeative work if you notice over here that we know that we need to calculate that for this 23 how many different ways we can compute this one but this 23 we have already computed it over here so we since we have already computed over here it is not very fruitful to compute the same thing twice and in Brute Force we are not doing it so that is why our uh path will keep on growing and growing until we reach to our all the possibilities which means that we are actually doing exponential work for this Brute Force approach uh so of course the big the time complexity would be B go of 2 to the power n which is really bad and uh we should avoid it in all cases and actually it can be a avoid it pretty simply if we just use memorization if we just create an additional data structure something like an array or something where we store the value of calculations that we have already done and if we at any point come back to the same calculation U that we have we have already computed we can simply return that value so we can use something like an array or hashmap I think hashmap would be more efficient in this case because we we are able to look up things in constant time and if we only apply that we can actually implement this solution the this Brute Force solution in very effective manner we can actually use recursion because uh remember at every single moment we are repeating a sub problem so we are repeating a sub problem and we are Computing that so if we just use memorization with recursion so for for this approach we can actually achieve the answer in time complexity of big go of n rather than this 2 to 2 to the power n and that would be really efficient okay before I go into the optimal solution I want to show you a few observations suppose our given input s is equal to 7 so how many different ways we can decode it of course only one way we can just use seven suppose our input is 77 we can still only decode it one way uh using like 7 s and that would be the only way we would be able to decode it even if our n value is 777 7777 whatever the value we have all of these can only be decoded just one way because all of these values they are forming a value where we can only use individual characters now what is the scenario where we can use the characters that are not individual and we can uh collectively use the pair of elements okay now let's take one more example s is equal Al to 21 2 3 and now let's try to see that how many different ways we can decode this one this is the same one we have used in our Brute Force approach so we know that there are five different ways we can decode this one but thing is we are going to do things a little bit differently over here we are going to decode these all of these values so first we'll start with value number two how many different ways to decode this one only one way and that way is two now let's consider the second value 21 how many different ways to decode this one well of course two values or two different ways and those ways are two one so that is one way and second one is 21 by itself and uh let's take the third value 2 1 2 so there are actually three different ways to decode this one let's consider the next value as 2 1 2 3 so we know that for this one there are actually five different ways to decode this and the five ways are okay you must be thinking that why am I writing all these letters because the thing is there is actually a very important uh relationship that exist whenever we find out uh whenever we add a new value to our to our calculation and if that value that is being added If the previous value of that with that particular value if that falls between this 10 to 26 actually something interesting happens so notice over here that this uh 21 came in okay we are we are checking for this value number 21 now the thing is just for a second imagine if this value was actually 27 so how many differ different ways would we be able to decode this one well only one different way and that one different way would be 2 and 7 so treating both values as separate values uh same goes for 28 29 and any value above but the thing is because this value Falls between this 10 to 26 portion we are able to do something interesting so notice that whatever value we append over here there is there will only always be one way to decode it I'm not talking about the value zero forget about zero a part from zero if there was any other value the way to decode it would be to whatever the way we have been decoding the previous value if we just add that value then that would be the way to decode it which is over here that two and one we are already decoding it with whatever value we were using we were decoding before and we were using that way but the thing is over here this 21 by itself falls under this 10 to 26 which means means it is a letter by itself so we are able to add it to our decode list and that is why we have two over here okay but now the interesting part comes in okay now over here we are adding one more two and this two Falls between the value z uh 10 to 26 because the appending value becomes 12 so this 12 Falls between this 10 to 26 now let's see that how many different ways we are creating the pairs actually 2 1 and two this is same from whatever the pair we had before one just one iteration before okay now this 2 1 we already have had a 2 one over here and we are just appending this value two over here so that is also okay because we can append it right so whatever the ways we were we were decoding before we are still using those ways but thing is over here something interesting happens because this one two by itself is a way to decode we are actually able to create this 2 one2 pair which we were not able to generate over here we are not able I mean we are using this two over here but the thing is we are using it for 21 but we can't do anything further than that we are already also using this 212 over here and how can we say that we are using this 212 over here is be because this value is basically 12 uh Falls between 10 to 16 but thing is this two actually comes from the first value this one and uh why because at any given moment we find out that there exist a pair with the new value being added and that comes between this 10 to 16 we can actually do sum of previous two values that we have calculated so far and the sum of these two would actually give us the number of different ways we can actually decode this one if you still don't believe let me show you with an with another example let me clean this up a bit now over here we are seeing that five distinct pairs are being made and we are adding a value three over here and we know that this uh pair 23 exist between this 10 to 26 so that is all okay right we we know all of these stuff now let's see that how many different ways we are generating the pair so one way is 212 and we are just appending three this would be the case even if the value was 2129 if the value was 2129 we would still be able to use this way because apart from this three that there would be a nine over here but that's not the case right now but the thing is we we would still be do it and if you look at look over here this is the same path we were taking and we are just adding one more node so no impact on the number of results second pair we are making is actually 20 212 and we are appending three over here again that is the case over here that we already had a 212 and we can append three over here so that that gets uh taken out over here if we had the 2129 we would be appending 9 over here so that Still Remains common okay there are no issues with that now next pair over here is 2 and 12 so we also have a two and 12 pair and we are adding a three over here which means that even if we had this nine we would still be adding nine and that would be it we we we don't care about it but the thing is if we had this nine we won't be able to generate these two pairs because notice in these two pairs we are actually creating an additional value by the value that has added over here and if we if this value was not between this 10 to 26 this value would not been able to be generated okay now the question comes that we have already exhausted all the possibilities over here so where does these two additional values comes from well actually if we look above over here this one is actually 21 right so we are also using 21 and we are creating a new decode node 23 and we are appending appending it over here also notice over here that this one is 2 1 and this one is 21 so we are appending a node over here uh 23 which means that at any given location if we want to see that how many times we can decode it we if we know the information of previous two elements and if we do some of those uh we can actually generate it so that's why uh the value for this uh 21 this can be decoded two times this value 212 this can be decoded three times so for the value 212 3 actually this 23 Falls between 10 to 26 that is okay that is perfect if that that is the case we simply do an addition and if we do an addition and we just uh find whatever result we have calculated and we can simply return this this is a very effective solution now what could be the other case well the other case could be that the new value we are adding that does not fall between this 10 into 26 so suppose over here the new value we are adding suppose the new value is 2128 something like this so after adding this new value uh this becomes 28 it does not fall between this 10 to 26 because it does not fall between this 10 to 26 actually we don't need to do addition over here we simply need to whatever the route we can make before this element that would be the only possibility we would be able to decode this one as well because that I just showed you over here that over here I was adding a nine and because I was adding a nine I was only able to uh make the new decode paths for these three elements I won't be able to generate these two values and this becomes our recur recurrence relationship and this actually becomes our dynamic programming solution now let's try to solve this dynamic programming programmatically we know that we need we can about the two previous elements so suppose our given input is like 21 2 3 we initial and we initialize two values before that as 1 one say we have these two as 1 one now we check at any given location that whether the value we have does it fall does this value with its previous value does it fall between this 10 to 26 okay in this case this two does not fall between 10 to 26 if it does not fall between 2 to 26 we just need to take whatever we had from the previous element so previous element over here we had one so we we'll just take one okay now we have this one so again we check with its previous element that whether the value Falls between this 10 to 26 the value becomes 21 it falls between this uh 10 to 26 so we do whatever the previous two elements were we do sum of it so the previous one element is one and the previous second element this one is also one so we do 1+ so we do 1 + 1 so we can put two over here now we have new element this Falls between this 10 to 26 that's good so we do sum of two previous elements sum of two previous elements is actually 2 + 1 so we can put three over here now we have this three now we then it creates the value 23 again Falls between this so we can do sum of 2 + 3 and that becomes 5 and this five would be our result so this is a very important dynamic programming Solutions and uh at any given moment if we find out that suppose over here we have an value 8 now this 38 does not fall between this 10 to 26 so it becomes simple that for this pair the number of ways we can decode this will still be five because we'll just take whatever value we have calculated over here the solution works perfectly fine and the time complexity for this case would be big of n because we only need to do one iteration across all the strings and the space complexity would in this case would actually be big go of one we would be able to complete this in constant space and time because remember that at any given location we only need to keep track of just two elements we don't need to cap keep track of this whole entire array we just need two starting elements and uh we would keep on itating them over uh different values so this is a very good solution and uh okay first of all we'll check that whether the first element is uh zero or not if this is the case we can simply return zero okay so we will create two parameters uh 1 and two and we will initialize both to Value one let's run a for Loop we'll start the loop from first position and we will go up until the length of the given string we we are running it from I equal to 1 because we already check for the zeroth position first of all we create a value current to keep track of the current element and now we check that if the current uh if the new character that we are trying to add if that is not equal to zero we can assign the one the value of one to current now we also need to check that after adding the value at I position are we getting the two-digit value between 10 to 26 so first of all let's create a new variable uh called uh value and we'll try to calculate the two digit value we check the condition so if value is greater than or equal to 10 and value is less than or equal to 26 which means we need to update the current value is current plus whatever the value of two we had because remember the value at current we are already adding it as one now we need to update the values of 1 and two so two would become whatever the value of one we had and one would become whatever the value of current we had and uh yeah I think this this would be our solution so at the end of the solution we need to return the value of whatever the current value we had but since we are initializing current inside we'll just return the value as one and uh let's try to run the code oh we can initialize the current as zero let's try to run the code okay looks like our solution is working let's try to submit the code okay our solution works pretty fast and pretty efficiently so I'll be post Hello friends we are still not employed by a Fang company so let's not stop lead coding till we get there today we are going to work upon a very important dynamic programming problem uh coin change and which in my opinion everyone should do it at least two three four times until you get a real grasp of the concept on how to solve it and uh let's understand the problem statement we are given an integer array of coins representing coins of different denominations and we are also given an integer amount ount that represents the total amount of money that we want to generate now we need to return the fewest number of coins that we can use to make up to the amount that has been provided over here and if the amount of money cannot be repres reproduce we need to return minus one let's try to understand this by an example so in the given example the number of coins we are given is 1 2 and 5 and the am amount we are given is 11 so suppose so based on the example we can clearly see that the most optimal way we can uh create this 11 is by using 5 + 5 + 1 so in general this sums up to 11 and if we see the number of coins it we are actually using uh three number of coins to generate this value if we look at the second example uh basically we are only given one coin the value number two and the amount we are given is actually three so no matter how many times we use the the number of coins to we cannot generate this amount three so in that case we need to return minus one while in this case we would be returning three because we are using these three coins so once we have this clear now let's try to understand that what could be the different approaches we can take to solve this problem uh the first approach that comes to our mind is actually to use uh greedy approach where uh whenever we are given the number of coins uh so let's take uh one of our own custom examples and we also need to keep in mind that whenever you are solving or giving any Fang interviews make sure to have your own Uh custom inputs because uh Fang compy companies really like this kind of stuff uh and that shows that you are able to think outside of the box and you can also create test cases on your own so suppose we are given an input like this and the amount we need to create is actually 8 so in our greedy approach basically we at any given moment for the given uh amount we will take the biggest coin that is smaller than this amount and and keep repeating till we reach this amount now let me show you that why this approach won't work because if we see here uh the amount we have is eight and the biggest denomination of coin we can create that is lesser than 8 is six so if we take this so let's create uh our answer where where we keep track of how many coins we are using so we use six over here we take uh 8 to 6 so we subtract 6 -8 uh we get the remaining value is two so since the remaining value is two uh we cannot use these three coins anymore because they all are greater than two and if we were to subtract this coin from two we our result will actually become negative so we cannot use that but we cannot you we can still use uh value number one so if we do that and if we use the coin number one because this is a greedy approach so we will add the coin number one to our answer as well and so now the remaining value will be one so again we cannot use these three values but we can still use one so we will use one the remaining amount is zero which means that we have reached our total amount of eight and we would add the value number one over here once we do that essentially if we calculate in the answer we are using uh three separate coins to reach the amount 8 so our answer would be three in this case and we would return three but notice that this answer is actually not the lowest number of coins we can use actually if we just use the coins three and five we can simply create this value eight and uh our result in this case should actually be two not three uh so gredy approach doesn't work at all now let's see what could be the next approach we we can take over here uh we are given an input like this and uh we need to reach out to a particular amount 8 so at any given point uh if we start basically start calculating from zero and we will keep on making choices based on the number of coins we have until we either reach to this value 8 or our choices actually becomes greater than 8 until these two things happen we can keep on making choices given our uh coin denominations and based on that we can actually create our own uh decision tree and in the decision tree whenever we reach at Value number eight we will keep track of the value U keep track of the path and based on that path we can calculate that what are the minimum number of iterations we have to make so initially we are at zeroth position so from zeroth position we have four options that we can take uh so let's take let's make four these four decisions 1 3 five and six now at every single decision we still have four more decisions that we can take to reach out to this value eight so again at Value number one we still have four more decisions we can make so let's do that and again at every single iteration we we still have four more decisions and with every decisions we come closer to this value number eight so initially over here complete eight were remaining over here we are only dealt with uh creating the value seven because we already used one coin the remaining value would be seven so over here the remaining value would be one the over here the remaining value would be two over here the remaining value would be four and over here the remaining value would be six and suppose we continue on this path again we would still have four choices and notice that the remaining value we wanted to create was six which we are able to achieve over here so the sum for this particular path one again one and then again six is actually 8 which means that we have found a potential route and if we see the number of coins we had to use we had to use 1 2 and three coins so current amount um current answer we need to return is actually three and since we have found this route all the other routes if you see the values would not reach to eight and uh we can cancel out these values and basically uh because if we keep going on we will still have to make more decisions and the number of Route will be will definitely be greater than three so we can start eliminating these routes and we have one potential route over here again if we keep on going down this path of three and keep making more decisions we would end up with an a result that would be greater than three or we would not reach eight at all so we can ignore this again we can ignore this uh from five and at 6 uh we would still find a root something like this where because notice even at six we still have four decisions we can make so we can make e we can choose either 1 3 or five or six and notice that only one is remaining over here and we can select this one so we would have another potential route uh starting from one going to six and then again going to one that sums up to 8 but again for this route as well we need to use three coins so our answer will still remain three and it won't be changed but this is where we find another answer and now we have exhausted all the possibilities from value number one so we can just ignore all of this let's get rid of it so we we have something that is more uh clear and not so much congested now let's try to see that what could be the possibilities from this value number three so even at Value number three uh the remaining amount we have would be five and at Value number three we still have four more possibilities that we can choose from 1 3 5 and 6 and notice that in all of these possib these three possibilities uh we would not reach eight uh so we would not reach basically the remaining value would not be uh zero which means means but if we get down over here five over here only five is remaining and we directly have a coin five present at the decision tree three and if we calculate the route the route would look like uh one and then two so basically we are only using one coin over here and we are using second coin over here so we are only using two coins to reach to this value eight so we can simply update our answer that we have found a new minimum value that can come up as our answer and we can uh set the value as two now we can continue to search and keep on making more decision trees and uh even for those nodes we will continue to making uh further down decisions uh to see if we can find a better answer but we won't be able to find a better answer than two and eventually we would have to return this value so this solution in a way it works and it works uh as expected at least we are getting the answer but the issue with this approach is that time complexity is actually so bad it's uh not even in polom time it's simply in exponential time and the time complexity suppose the amount we are given if we consider it as M essentially until we reach this amount M we are at every time keep on making multiple decisions uh based on the number of coins that are given so we can compute the time complexity as bigo of M to the power of n where m is the given amount and N are the number of coins that are present at any given moment this is such a bad time complexity that we even if we ask NASA to run this command they won't be able to do it U more more than up to a certain values and uh we need to find a better approach and in the optimal solution we are simply going to use just two golden words dynamic programming and let me show you how we can solve this via Dynamic program programmatically and we are just like a rational person we are just going to think it uh in terms of int intuitively that if we are given this problem just to solve on a PAP pen and paper how we are going to do it um and one approach is that we can basically start from the value number zero we can keep on reaching towards the amount we want to reach out to uh and for every single element that we have found we will found that uh for 1 2 3 4 how many number of coins it took us uh to generate that particular amount and once we are sure with this value whatever value we have generated the amount for one or amount for two we would be able to to use this uh later down the road and let's take an examp let's continue with our example and see how can we achieve that so uh we are given the example 1 3 5 and 6 and the amount we want to generate is 8 so initially we would create an array of amount from zero all the way up to amount of 8 and we will initialize all the values uh by any value that is higher than 8 so let's say 8 + 1 and now we will start start with our solution so so far all the values are actually 8 + 1 in this amount array uh and this represents that these are the number of coins that are needed in order for us to generate any particular value now if we just want to generate zero coins uh how many number of coins do we need well answer is pretty trival actually uh we simply need zero coins uh and this becomes our base case so now let's say let's say for the second value amount of one that if we want to generate value number one how many distinct coins we need so whatever value is we will check first of all in our coins for all the values uh that are given in the coin to see if we can directly use if the given coin is lesser than the value we are trying to achieve can we use that coin so since the value is one we can clearly see over here that this one if we just use one coin we would be able to generate this value one so the answer in this scenario becomes pretty simple that if we just use one coin we would be able to generate this value and notice that for value number one we cannot use any of these three coins because they are all greater than our value one so there is no point in using them now let's repeat the process for amount two so for amount two if we want to generate the value to how many minimum number of coins we need so first of all let's check with the first value okay so coin is actually less than two so we can use this coin we will use this coin so if if we use that coin basically we have already used one coin so far and we since we use coin number one and we want to achieve value two we can see that now the value we are trying to generate is actually 2 - 1 so again value number one now we want to generate value number one and if we we can do two either two things either we can go back to all these coins again we try try to generate that value or notice this beautiful thing over here that we have already calculated that if we want to generate amount one how many coins we are going to need so why are we being so picky and why are we doing all this extra work and why are we making our lives miserable our cpu's life miserable by doing all these additional calculations why can't we just stor this somewhere and if we have stored it we can simply use use it uh over here so in this case we can see that we have already used one coin in order for us to generate this one and now once we have generated this one we know that the amount the number of coins that are needed to create value one is already computed so we will do 1 plus amount to generate one coin and this would be the answer if we want to generate two the value two from the given coins and this would become 1 + 1 so 2 and this would be our direct answer and these are the minimum number of coins that we can use to generate value number two the reason I'm emphasizing so much on this is because this exactly is the core concept of dynamic programming and we have just hit a very big hammer to its head basically we have said that hey I'm going to take this dynamic programming all the way I'm going to chew it Sol it up so it becomes a second nature to me and now let's continue with our example this is going to be a really long video but I hope that I recommend that if you just understood at any point I would just suggest you to go ahead and uh start skipping over so now the value for amount two is actually two now let's calculate for amount three the if we look at for amount three we have now we have two options either first of all we can start uh either first of all we can start with this value one we'll take value one then again the remaining value would be two and we have already calculated that what is the amount that is remaining for Value number two over here so if we let's take that approach just to just for the sake of understanding so first of all we use coin number one so we use coin number one and plus the amount that is remaining is actually 3 - 2 so we still have amount two that needs to be computed in order for us to achieve this value three so we can say that uh for this one the way we can do it is one coin that we already used plus whatever the amount two we that we need to use and notice amount two has already been computed over here so we can say that 1 + uh 2 = to 3 so if we choose one of these coins and we try to achieve the value number three initially we would be able to uh find our answer uh by using minimum of three tokens now again we notice that now since we have computed this coin we notice that three value number three is actually less than or equal to this given coin 3 and we can use it to our advantage so now we know that we want to achieve value number three over here if we just use this one coin we would be able to achieve this amount number three and current minimum amount that we have calculated that is that we need minimum three coins in order for us to achieve value number three so why are we using three coins because our aim is to use the minimum number of values so we can simply just say that if we just use one single coin that is of denomination three we would be able to calculate the result as three for this amount three and we won't be able to do anything with these two because they are already greater than three so we can't make three with those denominations now let's move forward with our uh with the next value amount of four and if we generate the amount four how how many number of coins we need so basically if we just take this first coin we know that we have already used one coin and plus we have the value remaining as uh amount three amount three is already computed we are using the best knowledge of computer processing we can and based on that we can we can simply determine that oh and by the way this would be 1 not three my mistake so we can just simply say that if you want to generate amount four we can do 1 plus amount three is already 1 so we can use two and this would be the minimum solution that even if we use the first coin as three we would use second coin as is one and still the we will get the same answer so I'm not going to do whole computation but you get the idea so for amount four we can say that uh two are the minimum number of coins we need in order for us to generate amount 4 if we want to do amount five how many coins we need and the answer is pretty simple we already have this five present over here so we can just simply write one and uh notice again notice that we are going to check all the coins uh and when we get to five we will be able to say that this this is the minimum number of coins we can use uh next is amount of six if you want to generate amount of six again the answer is one because we are already given a six over here and we are going to check through all the coins that are lesser Less in the value of whatever the amount that we are trying to calculate now let's calculate for amount of seven if we are calculating for amount of seven and if we check for the first coin uh the first coin is actually zero so basically we can just simply say that uh the first coin is the first coin is actually one so basically we can just simply say that uh we now we need we have already calculated the one coin plus now we need to calculate the amount 6 because 7 - 1 is equal to 6 and we have we already have the result for amount six so we can just simply write that we need uh at least two coins in order for us to generate the value number seven and now let's try to calculate our output that we are want we are we have already given that we need to calculate uh the8 so if we can want to calculate amount 8 and based on this table it becomes pretty simple initially so first of all we will calculate this with value one so basically we would be doing the calculation something like uh one coin that we have already used plus amount of seven and we know that amount of 7 um from our previous computation is actually value number two so we will do 1 + 2 = to 3 for this amount 8 that we are trying to calculate but uh can we do something better and remember that we are going to check all the coins so because we are going to check all the coins when we get to coin number three our solution would be that we have used one coin and that is the coin value is three and because we have used three now we need to generate the amount 8 - 3 = to 5 so we can say that we used one coin to generate the value three and now we need to generate value five in order for us to achieve this amount equals to 8 so if we do 1 plus amount of five what is the answer and the amount of five is already calculated over here U as one so we'll just simply use that value and we'll do 1 + 1 = to 2 and we will carry on with our computation with this value fine uh value five again we will find the answer two uh because we will do 5 + 3 and when we get to Value number six we will again find the answer to generate the amount 8 as three because we'll do like uh six plus amount of two so uh the minimum number of coins that we can find in order for us to generate value number eight is actually two and we can simply return uh this value to now notice that we also have to take care of the scenario where we cannot create the amount based on the given coins and if we cannot create the amount uh at the end of our computation the value for amount would amount of Any Given let's say eight that we cannot compute in this case would actually be uh the value 8 + 1 so equals to 9 because notice that at the beginning of our array this is how we initialize the values to and if after all the computation we found that the value of amount is actually the original by default value that we set which is amount + 1 if that is the case we know that we are not able to generate this value and we are not able to make any impact with our solution because the coins cannot generate this value we will simply return minus one and this solution would work perfectly fine this is a really beautiful solution and if you go through with this approach in your interview you are going to just be very impressive candidate and all the Fang companies would want to hire you so what let's calculate the time and space complexity so time complexity for this one would be uh actually bigo of n * m now why n * n because we are running the loop to calculate the value n and n is actually the value of this amount of whatever is given so we are Loop we are going through a loop end time and M are the number of coins uh because notice that over here for every single element we will have to use the we will have to go through all the coins in in order to generate the value so the time complexity would be big of n * m and the space complexity would be bigo of n because we are creating an additional data structure array to to store all these values and the values we are storing up to is actually uh the amount whatever amount we are given so we can say that the space complexity would be big off in okay so let's create an array uh amount and its size would be amount + one we fill out all the values inside the amount as amount + one this would help us determine that whether uh if we cannot create the value we we need to return return minus one or not and now uh we will set up the initial value for amount of uh zero would be zero now let's create our Loop so we will start with i equal to 1 because we have already calculated the value for amount zero and while I is less than or equal to amount uh now notice that for every single value of I we need to calculate for all the values of coins so we will do we will have another loop uh that would iterate our coins and first of all we'll check that if our present I is actually greater than or equal to whatever value of coin that we are comparing it with so if this is true then only we will check that whether what is the amount uh for any given j u sorry any given I so we'll do a minimum value of either the value itself so whatever value we already have or we will take one coin of any J and we'll do an amount of I minus J and Yep this is the main logic uh because in this logic we are calculating uh all the amounts and we are using it uh further down the road as well so after this iteration we just need to check that if uh for any given amount so amount of amount if that is um less than the value amount + one which means that we have been able to generate this amount so in that case we would return whatever the value we found else we can simply return minus one let's try to run this code we made a silly mistake again oh we need to check with coins of J yeah looks like our code Works let's try to submit this and yeah our submission is actually pretty efficient compared to other uh others who have submitted so I hope you like this video it took me a lot of time to make it and I know it was a really long video but it was believe me it's equal informative once you master dynamic programming you are almost guaranteed that you at least have a foot in the door for Fang and uh yeah we are not going to stop till we clear Fang see you today we are going to do maximum product sub array this is a very popular problem on lead Cod and if you see some of the companies where I want to get a job who have already asked this question there are companies like Amazon Amazon LinkedIn Microsoft Google Apple Bloomberg Facebook and Uber so that's why I'm paying my atmost attention I hope you also enjoy the video okay so this is a lead code medium problem and as mentioned a very well-liked problem on lead code basically we are given an integer array called nums and we need to find a continuous non-empty sub array that has the largest product and we need to return the product uh we are also given the definition that what a subarray is that is basically a continuous sequence inside the any given array and let's try to understand this problem with the with an example so I have broadened this example over here and basically we are trying to find the maximum product sub array so a sub array that contains the maximum product in this case this is a negative value and that changes the dynamic equation so in this case the product of these two elements that is a sub array is actually going to be six and all the other sub arrays they are always going to have lesser values than six so in this case as the answer we need to return six that that is the maximum product sub array we can make for this given input array and this is what the problem is asking us to do so first let's see that what is going to be the Brute Force way to solve this problem well the Brute Force way to solve this problem is that we are asked to find the maximum product sub are right so if we are asked to find something of a sub array why don't we check every single sub array see that what is the product we can make and find the maximum amongst that so like do the baby steps so what we are going to do is we are going to keep keep on iterating over every single sub array that we can make uh we are going to see that we are going to have a variable called answer and uh in the answer we are only going to store the maximum value we have found so far and then we will keep on repeating the same process for all the remaining sub arrays and eventually we would find a pair that contains the maximum product sub array and in this case the answer is actually going to be the 6 * 7 that is 42 and we will have 42 populated as the answer eventually so the Brute Force way is a very trivial way but it leads to the correct solution so if you are only looking for solution you will get it using Brute Force but what are the issues with this one well the issues clearly we can see over here that we will have to iterate over every single subarray that is there and that would lead us to have a Time complexity of bigo of n squ so which is B very bad because for every single element uh we will have to iterate over every other elements and then keep on repeating the same process so the idea is to see that can we find something of a better time complexity we can actually achieve that using the most important concept inside our computer programming and that is called dynamic programming using the dynamic Pro programming we are basically going to have two pointers to store some critical important results and that is going to lead us to find the maximum product sub array so first let's understand one thing regard regarding what is being asked we are trying to find the product now we know that for the product suppose if all the integers are just positive integers then basically it is the product of all the integers that we need to return right the thing is that is not always the case we could encounter negative integers and the negative integers leads to very uh interesting results the interesting results are that first of all we suppose in this case uh these three values if we do product of them okay the product of these two is six and the 6 * -3 leads us to -8 to be the product over here right the thing is now this value seems very low value because of the negative value but imagine that over here rather than this four being positive if we had a NE -4 then that is actually going to lead us to have a very beautiful results that if we do -8 * -4 the answer is going to be + 72 and that is going to be the maximum product subar so you see what I'm trying to say the moment encountered a negative value immediately we found it to have the minimum value but that negative value lead us to have some better consequential results in the future so we don't know that whether we whenever we encounter a negative value we don't know whether we should keep it or not so that is a tricky part that is why we are going to use dynamic programming and we are actually going to use two pointers and these two pointers are going to be that at any given position we are at inside our array we are going to see that up until this point what is the minimum value we have been able to achieve and what is the maximum value we have been able to achieve or basically what I'm trying to say is what is the minimum product we have been able to achieve and what is the maximum product we have been able to achieve and every single value we could have three possibilities so let me clean this up a bit at every single value we are at there could be three possibilities either this value could be part of a sub array that lead leads us to have the maximum product or it could have been a part of a sub array that leads us to have the least value up until this point or this could be the start of a new sub array that leads us to have a maximum product in the future the idea is at any given position we are going to check three things and the three things we are going to check is that up until this point whatever the minimum value we had which is which we have stored so far we are going to multiply this value with this minimum value we are also going to multiply this value with whatever the maximum value we have able we have been able to store so far and we are also going to compare this value by itself so we have basically three values at any given position the value with the previous minimum value the value with the previous maximum value and the value by itself and for all of these three values we are going to see that what is the minimum value we are able to make we will store that what is the maximum value we we are able to make among these three values we will store that as well and eventually we would reach to the end of our loop with the maximum value we have been able to generate and we will have a parameter called answer and in the answer parameter whenever we identify a better maximum value we would populate that so this is the approach I'm suggesting now let me try to go over an ex an example okay so suppose this is the example we are have and now let's try to use dynamic programming in this case with two pointers so we are going to create two pointers called Min and Max and for every single value we are going to compare it with the values that we are going to compare it with and we are going to populate these results we are also going to have a variable called answer we will update it based on the maximum value we have found so far okay so first value is five so we for all the three values we only a five we can't compare any with anything okay so minimum value we have found so far is going to be five maximum is also going to be five and that's it now this next value is three okay so now let's see that what are three values that we have to compare so first value is three by itself next value is 3 * the minimum value so 3 * 5 and next value is 3 * maximum value so again 3 * 5 so the three values we have is 3 15 and 15 okay so now the minimum value amongst these three is going to be three so we are going to populate that and the maximum value is going to be 15 so we are again going to populate that the answer so far that the best we have received is 15 so we are going to populate that okay now let's get rid of this one now again we are at the next element that is one so now the three values we have is 1 1 * whatever the the minimum value so that is three so the value is going to be three and the 1 * the maximum value that is 15 okay now among these three values the minimum value we can able to make is going to be one okay so let's populate that and the maximum value is going to be 15 the answer is going to remain the same now let's clean this up okay now Things become interesting when we reach to this value min-2 okay now the three values we have is going to be min-2 by itself then minus 2 * the minimum previous minimum value so previous minimum value in this case is 1 so - 2 * 1 is going to be -2 and the previous maximum value so previous maximum value in this case is 15 so - 2 * 15 is going to be -30 okay now these are the three values we have and now we are going to see that what is the minimum and maximum value we are able to generate right so currently the minimum value we are able to generate is going to be -30 so we are going to store that over here okay and the maximum value we are able to generate in this case is going to be min-2 so we are going to store that over here okay now we are good up until this point now this value is zero so the three values that we have to compare is going to be 0 0 * the minimum value so that is again going to be the 0 and 0 * maximum value that is again going to be the zero so all three values are zero so let's put zeros over here now again uh we are at this value number5 so now the three values that we have to compare is going to be -5 and then both of these are Zer so it's going to be 0 0 again so currently the maximum value we are able to generate is going to be the zero so we are again going to populate the value with zero and the the minimum value we are able to generate is5 so we are going to populate the value with5 now the next value is 8 okay so now the three values we have to compare is 8 8 * 5 is going to be -4 D and 8 * uh the 0 is going to be 0er okay now uh the 3 values that we have let's compare them and let's find the minimum value so minimum value in this case is going to be -40 so we are going to put it over here the maximum value we are going to have is eight so let's populate that over here okay now we are at this value number minus 3 so with this minus 3 we again we have three options so - 3 then - 3 * this -40 that leads us to positive 110 and - 3 * 8 that leads us to -4 okay so now in this case the minimum value we have so far is going to be minus 24 which is this one and the maximum value we are going to have is going to be 120 and this 120 is greater than this value number 15 so we are also going to update that in our answer and now we have reached to the end of our array so end of our dynamic programming Journey so we'll stop here and whatever value we have found in the answer we are going to return this as the answer so in this case answer is 120 that is the correct answer if we see and if we compare this to our Brute Force well essentially because we are using the beautiful concept of dynamic programming we are completely everything in just one single iteration and all we are doing is just storing couple of variables uh to store the previously calculated results and comparing different values that leads us to have the correct answer and find the maximum product sub array in a single iteration which is wonderful if we see time complexity in this case the time complexity is is actually going to be bigo of N and the space complexity is actually going to be bigo of constant space complexity because apart from storing couple of variables we are not storing any other data so this is a very good time and space complexity to have compared to our Brute Force approach that had the time complexity of big of n Square which was very bad so first let's take care of some edge cases that if the given number is empty we can simply return zero so now we will initialize A Min variable a Max variable and a result variable okay so now let's run a for Loop to iterate over our given nums array let's initialize a variable called current to keep track of the current variable we are at okay now we will have to calculate max and Min value so first let's calculate max value so this takes care care of comparing three values for our Max variable and we are using math. Max function two times because that is the way to do it I think in Python you can do it just without using like two math. Max functions now let's calculate our Min value as well the thing is for our Min value we will also have to use the max value but since previously we have already calculated our max value it makes no sense for us to use that over here so what I'm going to do is I'm going to create a temporary variable and this temporary variable I'm going to calculate the max value then for the calculation of Min value basically I'm going to use the previous um max variable now because this is the temporary variable we will assign this value to Max we will also have to keep on updating our result variable as well that's it uh basically when the loop ends we should have our answer populated in the result variable so let's return that now let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs pretty efficiently compared to a lot of other Solutions and I would be posting this solution in the moment so you can check it out from there Hello friends we are still not employed by Fang company so let's not stop lead coding till we get there today we are going to do a very important lead code medium problem word break uh let's understand the problem statement so basically we are given a string s and we are also given a dictionary of string word dict and we need to return true if s can be segmented by all the words that are given inside the verdict so if we look at the example suppose our s is lead code and the verdict we are given is uh first set is lead and second set is code we can clearly see that this lead code we can generate from whatever we are whatever the values we are given in this dictionary so we will return true in this case and we are also mentioned that we can use the same word multiple times so suppose if this problem was lead code lead uh code uh something like this we would still return true because um all whatever words are we can still make it through this dictionary but if we were given some wording like this that lead code lde so up until this point we have the words that we can make from this uh dictionary the thing is this Le there is not a specific word given for that uh the word we are given in the word dictionary is lead so it does not match so in that scenario we would return false otherwise we would return true okay let's try to understand that what would be the Brute Force approach suppose we are given s is equal to ESN and the dictionary we are given is uh e SP p and N so we can clearly see that all the words we can are present in the word dictionary so the answer should be true uh and in the root Force solution we are going to use a bottom up approach so uh and in this uh video I'm going to show bottom up approach all the way um even for the optimal solution so this can also be solved as a top down approach so let me know if you want to make a separate video on that uh and there is also one more thing to consider suppose we are given something like s is equal to null value or empty string and in the word dictionary we are given some elements like a b a b blah blah blah so this case we can clearly return return as true why because this empty element will always be there uh though it might not be showing but the thing is if there is if there are no elements in our given string the we can always return true because the emptiness also exist in this word dictionary so we are going to use this logic and uh let's see that how we can build our uh B Brute Force so we are doing bottom up so we are starting from the lowest value and eventually we are going to make the whole world so the first value we need to so we are at the zeroth position the first value we need to make is uh simply the word break of a value e and the word break of value e is very easy to calculate U we only need to check that whether the word break of uh empty string and the value e exist in this given word dictionary or not so basically and we know that if there is an empty string scenario this will always be true because I just explained it to you how so we only need to see that whether this e exists in this word dictionary or not if this exists we can clearly say that this is true and the we can uh denote the value of word break of e as true now the second option we second decision we can make over here would be to see the word break of two elements so e and s and how can we determine the word break of e and s uh well again it's simple so we need to we have two ways to determine that either we can do a word break of empty string and we can check that whether this es s value is present in this word dictionary or not or we can do a word break of value e because we know that this is always true the word break of Mt is always true so we can do a word break of e and we can check that whether the value uh s is present uh in this given word dictionary or not and word break of e we already know how to do it uh for this word break of e we need to do word break of Mt and we need to calculate the value of uh to see that whether this e is present or not the third option over here we can have is uh and you guessed it correctly the word break of three elements so es and for this three elements we again have three more possibilities so word break of empty string and uh we need to check that whether es all these three exist in this uh scenario or we need to check that whether the word break of uh whether the word break of this uh e and SP exist and the word break of E S and P exist and yeah so these are the three ways we can determine that whether the word break of ESP exist uh the next option we have is is uh the final scenario that whether the word break of ESPN exist or not and to check that we we will have four possibilities so first one is that we check the empty string and we check whether the ESN the whole word is uh present in this word dictionary or not or we can check that whether the word break of e is present and SPN these three values are present or not or we can check that word break of es s is present and we can check for pn or we can check word break of es P and we can check the value n so these would be the four cases where we need to calculate all of these and for every single one of them so even in order to calculate this word break of e we will use uh the this method to calculate this word break of e s we will calculate this uh whole method and uh yeah so this would would be the Brute Force solution eventually we would find that uh whether we are able to make this ESPN or not and uh whatever a result we get we just need to uh bring it upwards and we would be able to find the solution so this solution works but it works in a very horrible way because at every single location we have two possibilities to make whether we want to keep that uh element or not whether we want to keep that element or not and our decision tree keeps on growing and growing and growing and uh though we will come to the correct solution but it's going to take us a lot of iterations to achieve that because over here you can see that we only had these four elements uh that we need to consider we generated such a big tree and over here most of the values we did not even completed the whole uh sub iteration for the them because it's going to I would be running out of space so the time complexity as you have guessed correctly for this approach is actually big go of 2 to the power n because at every single location we are making two decisions which is pretty bad and why it is 2 to the power n because we are calculating everything at the same time so see that do we have a room where we can save whatever we have calculated before and can we use it further down the road of course we can because notice over here this W word break of e we are using it over here but we have already calculated its value so why do we need to calculate its value again over here same goes with word this word break of es we already calculated the value over here so why are we repeating this whole process there are lot of repeated effort this is repeated this is repeated this is repeated we have already calculated all these values so somehow if we just create a cach we store that whatever the values we have calculated so far and keep track of that cach and whenever we need to encounter that uh whatever value we are calculating right now we can simply check that whether that has already been calculated and uh using that we can actually come up to a better solution since you guessed it correctly that because we are using something that we have already calculated in past we are keeping it keeping a track of it in some form and we are using it further down uh in our next iterations so basically we are using the most beautiful thing in the computer programming the dynamic programming approach in the dynamic programming we are going to create a sing single array of size whatever the input given input string is and uh based on that particular array we will calculate all the values that have been calculated so far and because this is a bottom up approach we are going to uh start filling up array from the zeroth position and we will reach reach at the end and in the end after all the calculation we will just simply return whatever the value we have calculated over here so let's see that what would be the optimal solution suppose um again we are considering the same example s is equal to ESN and the word we are given is e s p and n and now let's create a new data structure uh called DP of an array that is of size four and uh there would be so 0 1 2 3 4 now we know that this zeroth position uh would always be true and uh why it would be true because this indicates that for DP of size Zer which means that for string of size zero does it does the word dictionary contains this particular element or not this is what this DP is representing that every at every single location whether the value of uh that length of the character is it present in this word dictionary or not so DP of0 we know that that's an empty string and if it it is an empty string we can determine the value as true so this would become our base case and this is very important to identify in a dynamic programming problem that we need to have a base case and uh initially we would set up all the other values as false and uh we will run our iteration so let's see that what each each of these values are going to represent and you guessed it correct that this value represents word break of zero this represents the word break of one so in this case it would be the value e and this represents the word break of value e s this represents the word break of value es and this one represents the whole word so word break of the value ESN and uh yeah so at the end whatever we whatever result we find over here if we just return that that would be our perfect solution so example we are going to take is the same one that we have been uh discussing so uh the S is ESPN and the value of word is e SP and n and we know that our uh dynamic programming of value zero this is our base case that is true so what we are going to do is we are going going to iterate over starting from single element we are going to keep on increasing the size of our element depending on the size of our element we are going to fill up this DP array and uh at the end we'll just return the value so initially we will have we will calculate just for Value e so DP of 1 would be calculating the word break for Value e so let's see that whether this value e is present in this word dictionary or not so the value is present so we can say that the DP of one is true okay this is good now let's check for the second element so uh for DP of E2 this would be calculating the word break for e s now we know that we can break down this word break for ES in two parts either we can do uh like an empty string and we can check for this value e s or we can do the word break for the value e and we can check for the value s in this uh given word dictionary if we check if we go for this one es es is not present over here so we are left with uh the second approach in the second approach we know that uh word break of e which means this DP of one so DP of 1 is already true so we can see that okay this is true now we only need to check that whether this s is present or not so s directly is not present in this word dictionary which means that this condition is not satisfied this condition is not satisfied so we can say that the value for DP of 2 is actually false so we will just mention it over here that this is false okay let's try to calculate the DP of three so DP of 3 means word break of elements e s p word break of ESP means three things uh first one is that uh we need we can directly calculate to see that if ESP is present or not this is not present so this condition won't work second one is we can check that whether the uh word break of e is present and the word SP is present or not and third we can check is whether the word break off e s is true and uh the p is present now the thing is we already know that this condition is not true the ESP is not present which means uh we we need to check these two conditions now let's check this bottom condition first so word break of es this word break of es is actually word uh the dyn in the dynamic programming array it's the second position so DP of two we need so DP of 2 and the value P now we know that DP of 2 is already false which means that this condition will also be false so we don't need we don't even need to calculate and we don't even need to check for this element p in the word dictionary because we know that since this DP of two is false we can just ignore this case and let's focus on this one so word break of e which means that uh DP of one so DP of 1 is true if DP of 1 is true which means that at least this condition is true now we need to check that whether SP exist in the word dictionary or not not and SP also exist in the word dictionary which means the DP of 3 we can consider this as uh true let me also put this one uh on this side now let's calculate the DP of 4 which means word break of e SPN so again this will have four conditions now I'm going to write this in a different manner so we can also say that this is DP of 2 and PN because DP of 2 represents this es s and we can also say this as DP of 3 and n and uh yeah these are the four conditions we need to check and if any of the them are true we need to return true over here so let's check the first one does ESPN exist in over here no it does not so this is false uh so WB of e is true so at least one is true but SPN does not exist over here which means this is also false now DP of 2 this is already false which means we don't even need to calculate and check for this PN now the last one is DP of 3 DP of 3 is uh true so this is good now we need to check whether n exist over here or not so n exist over here which means this is true so we find one case that is true so which means that over here we can mark this value as true and remember that uh this given string this is of length four so because this is of length four we simply need to return whatever value we find as DP of 4 and that is true so in this scenario we will just return the answer as true and that would be our solution this is a very good solution because notice that we are already calculating what we need so far we are keeping track of it at every single position because we have calculated these values we are able to use it effectively and come up to the result let's calculate the time complexity so we are iterating over all the elements at least once so that is an N then we are also creating substrings so for every value n there can be n minus one substrings which means that we need to do additional n work so the time complexity would be B of n Cub so this is also pretty high time complexity but if you compare it with uh 2 to the power of n this is actually way lesser uh because this time complexity that can still be complic uh calculated and uh this is a polom Time complexity but the thing is this one is exponential and uh yeah we don't we need exponential salary what not exponential time complexity so let's uh code up the solution okay let's create a Boolean array uh to store our cache and we'll name it as DP we'll assign its length to s. length + one and we know the base case where DP of Zer would always be true also uh for this word dictionary uh this is a list so we are going to create a hash Set uh that will store the strings and we will store this word dictionary over there so it becomes faster for us to access the word dictionary we'll just name it word set now I think we are all set to start our Loop so we'll create the two Loops notice we are starting our loop from I equal to 1 because we don't need to uh we already have the value for I equal to Z and we are going to start the second loop from zeroth position and while J is less than I because we only need to go up to I point now inside the loop first of all we will check that whether the dynamic programming for the J value exist or not and this is what I already explained in the uh solution explanation that if this is true then only we check that whether the word Set uh contains the substring so we'll use a substring method and we'll provide the parameter as J and I because J is uh less than I and uh if this is true if this is true basically we just need to assign the value of DP of i as true and uh yeah I think I think that's it and we don't need to do anything uh and at the end of the loop we can simply return the value of our uh DP of s do length and and uh yeah also when we find this value DP of I is equal to True which means that we can break out of this uh inner loop because there won't be other another pair that we need to calculate because even at any moment if we find a single true that's sufficient for us so let's try to run this code okay uh looks like our solution is working let's try to submit this yeah our solution works it is accepted by lead code but not that this solution is actually pretty slow uh it is taking a lot of time and uh it is not as fast as our other Solutions so there is one trick we can do is rather than going from I uh from J equal to 0 to I we can actually go in reverse so we can start the position of J equal to IUS 1 and we can see that whether J is greater than or equal to Zer and we will do J minus minus that way we would be able to find this uh a little bit faster so let's try to run the code first yeah this works let's try to submit it and see the significant difference now our solution is much faster and uh even if you see over here previously this one was running in 13 millisecond and this one is now runs in 4 millisecond basically we are just eliminating uh and breaking out of this inner loop faster we are not doing anything special so yeah this is just something to keep in mind and uh yeah I hope you liked it and I will [Music] be now the next problem we are solving is called longest increasing subsequence this problem actually is two Optimal Solutions first optimal solution is a dynamic programming solution that can solve the problem in big of n Square time and which I'm explaining in the first part of this video now for the same problem there is an even better solution which is very tough to understand and that is something that is using a patient sort algorithm so the thing is if you are only considering and trying to learn dynamic programming I think part one of the solution should be fine if you also wants to learn the optimal approach for the same problem you can also see the part two of the same question uh so there are going to be two solutions for the same problem and uh now let's start understanding the problem statement Hello friends we are still not Ed by Fang company so let's not stop lead coding till we get together today we are going to do a very important lead code medium problem uh longest increasing subsequence and I have decided to break this video in two parts in the first part I'm going to discuss the uh Brute Force solution and an accepted uh solution for this problem and in the second part I'm going to show the optimal solution but the thing is the optimal solution is really difficult to achieve and it's a little bit tricky to come up with so let's understand the problem statement basically we are given an array of numbers and we need to find the length of longest strictly increasing uh subsequence so subsequence means that suppose we are given an input like this uh 1 2 4 5 so we can say that uh the value 2 and five is actually a subsequence of this given initial problem let's try to understand that what is the input given so we are given over here and8 and this example and uh if we take these numbers uh 2 3 7 and 101 uh this would be our longest increasing subsequence so if we get rid of this value five this would be the longest subsequence we can make where all the values are in increasing order and the length of all the values would be four which is what we need to return as a part of this uh output so once we know the problem statement let's see that what could be the Brute Force approach so in the Brute Force approach so in the Brute Force approach we are simply going to take every single subsequence that we can possibly make uh keep a parameter that tracks the length of any subsequence and eventually at the end we we should be able to find a subsequence with the maximum length so let's take a small example and see that how what are the possible subsequences we can make so suppose our given input is 5 3 and 8 I'm only taking three elements because I I need to show that uh why this approach is bad and what are the possible subsequences we can make out of this so let's start making all the possible subsequences uh the possible subsequence would be five 5 3 5 8 3 3 8 8 and 5 38 these are the possible subsequences we can make out of only these given three problems and if we check the length of each of them and if we find out the property that which one is the which one is a strictly increasing order we found that this is the strictly increasing order and the maximum length we can achieve is two so this solution works it works fine the problem is that notice that we are only given three elements over here and based on this three elements we are able to make almost seven subsequences mathematically it's actually two 2 to the power of 3 - 1 and for any s any single given n this is the number of subsequences we can make so um suppose we are given n values in the given input the number of subsequences we we would be able to make would be 2 the^ of n minus 1 so if we calculate the time complexity we can just say that the time complexity is actually big go of 2 to the power of n which is extremely horrendous uh time complexity and this is exponential so even give with with enough numbers even NASA won't be able to solve this one so let's move on to the next approach now now we want to find the better approach and we know that the way to do this is to use dynamic programming the thing is how can we identify that we need to find the solution using dynamic programming also what what dynamic programming solution are we going to use so I'll be discussing both the things in uh next portion and first of all let's take an example we'll try to see how we are going to solve it then I'll will show you how we can determine that we are using the dynamic programming and after that we would be imp implying uh the result and I would be showing you the coding example suppose our given input is suppose this is the input given and we need to find the longest incre increasing substring so just by looking at the given example we can determine that the longest increasing sub substring actually exist between 7 8 16 and 27 and now let's see that how can we come up with this solution how do we determine that this is dynamic programming suppose we are just given an example like this we are just given one value that let's say the value is seven if we are only given seven what is the longest increasing substring we can make well the answer is quite simple we can simply make just one substring uh of length one so this actually becomes our base case that if we are only given one value we are guaranteed to have at least one substring that would be the longest increasing substring that we can make so now let's see that how can we use this logic say that for all the given elements basically there exist one substring at least that is the longest increasing substring let's just Mark all the values as one we know that if we are only given the value 10 the longest increasing sub substring we can make would only be one but then it comes to the second value now we have something to compare to suppose the seven value if this was greater than 10 and we only had two values we can see that at the second position the longest increasing substring that we would be able to make would actually be whatever we have made so far + one so we would have been made two but over here that's not the case and over here the value 7 is actually less than whatever uh we are given the value before that which means that we the longest substring we have at the value 7 would also be one so this would be true in this case but now when we come to 8 we have two possibilities what are the total substrings we can make up until this point up until 8 okay so for this value eight what is what is the one thing that we can determine we can basically determine that there are three possibilities of the substrings we can have and we can compute one possibility is we could have a substring like 10 and 8 second one is we have we could have substring seven and 8 and third one is we could have a substring 8 by itself uh in case if all the values before eight are actually uh greater than 8 so in this scenario from 10 to 8 we know that 10 is already greater than 8 so we cannot create a substring over here so let's ignore this scenario for the second scenario 7 to 8 actually this is a valid increasing substring because 7 is less than 8 and uh it comes after it so what we can determine is that the longest increasing substring we can make at Value number eight would be whatever the longest increasing substring we have made up until this point so whatever the longest increasing substring we have made for the value number seven plus 1 because 8 is coming after 7even and 8 is just one step after it so the we can see that longest increasing substring at Value number eight would actually be whatever we have found up until longest for the longest increasing substring of 7 + 1 and this is how we can determine that this should be solved as a dynamic programming problem because in Dynamic program in basically whatever calculations we make in the past we keep track of them in some way either through an array or storing them in variable somehow and based on those results we actually use it in upcoming future calculations so that we don't have to calculate everything from the scratch so this is one way we can determine that this problem should be solved do using dynamic programming because if we just look at the problem we understand that we need to find the longest just increasing substring which means that we need to keep track of whatever we we have calculated so far in the past and using those results we would make decisions that whether we want to keep this current current value or we want to ignore this current value so this is a very important thing to keep in mind and this is uh basically the core concept of finding the P pattern whenever you are given uh that whether the problem is dynamic problem or dynamic programming problem or not because in in the inter the interviewer is not going to tell you that hey this is a dynamic programming problem and just go and solve in that manner so now let's again continue with our example so we can determine that currently the value at uh 8 the longest in the longest increasing substring we could make at a value number eight is one but we just found that from 7 to 8 we can actually make a substring as well so this would become actually two and we can see that up until the point of 8 the longest increasing substring we can make is actually two and not one now let's move forward now let's consider for Value number five at Value number five let's again compare from 10 to 5 we cannot do anything because 10 is already greater than five so there is no point of doing this conversation let's again let's compare uh 7 to 5 from 7 to 5 we cannot do anything because 7 is greater than 5 and also 8 is greater than 5 so so at Value number five there are no values that are less than five so the at Value number five the longest increasing substring we can make is actually size one because there does not exist a smaller number before five in our given input so we will keep this one as it is because we have already made all the all the calculations now let's calculate the for this value number 16 and actually for Value number 16 if you notice that all the values are smaller so this would be a very good point for us to understand that how everything works so so from 10 to 16 we notice that 10 is smaller than 16 so there is a possibility and uh basically we can say that whatever the longest increasing substring we have found at 10 if we do it plus one that would become 16 so the longest increasing substring for 10 we have found is actually 1 so 1 + 1 = to 2 so let's just update the value two over here and now let's move on with our calculation so we are done with this step then let's calculate with 7 so if we do 7 to 16 actually again we we'll do 1 + 1 uh because Lis s of 7 so 1 + 1 is again two we have already we already have two so there is no point in updating the value Let's ignore this let's do again with the value 8 so from 8 to 16 we know that the the value of 8 is actually two so over here at Value number 16 we can say that increasing substring at Value number 8 + 1 so it becomes 2 + 1 and 2 + 1 okay I made a mistake I think this is one that represents five and that value for 16 is actually over here so I'll just write it down so uh Lis of 8 + 1 is actually uh 2 + 1 which is 3 which is greater than whatever the longest increasing sub substring we have so far so which means we can update this value so over here the longest we have found so far is actually three and now we can also create one more substring from from 5 to 16 if we calculate from 5 to 16 we found that the value is actually 1 + 1 would be 2 which is not greater than whatever we have at 16 so we can say that up until this point 16 the longest substring out of all of these values we can make is actually three uh for the Valu up until the point of 16 and let's move forward with our calculation so again the next value is 27 27 is greater than all the other values so if we do 10 + 10 to 27 we would find the value as 2 uh we will do 7 to 27 we will find the value as 1 + 1 again 2 we will do 8 to 27 we would find the value 2 + 1 as 3 again we will do 5 to 27 the value we would find would be 2 and at the end we would do 16 to 27 and we know that the value at 16 is 3 so we would be able to find the value as 3 + 1 and because we have calculated all these results we don't have to do calculations all the way from beginning and we are just able to use the results we have stored so far so we know that the maximum value we can find is 3 + 1 so we would update the value at um longest increasing substring at Value number 27 to 4 and then we come to our last value 9 so and again we will do the whole thing for 9 so 10 is greater than 9 so we cannot do anything 7 is less than 9 so we will we can for this one we can have the value as two uh 8 is also less than 9 so from 8 to 9 value we can have would be three uh five is also less than 9 so from 5 to 9 the value we would have would be uh 1 + 2 2 from 16 to 9 we cannot do anything because 16 is greater than 9 and from 27 to 9 we cannot do anything because 27 is uh less definitely greater than 9 which means that the maximum value we could have find so far over here for 9 is actually three and that comes from uh the 8 + 1 so we will update the value over here as three and now we just need to find that what is the maximum value we have found in this uh array that we have created based on the calculation so basically clearly we can see that this value four is the maximum value we have found and that would be our answer that would that is what we would be returning as uh longest increasing substring the thing is we actually don't need to iterate over the entire uh entire array again we could have actually done this when we are calculating or when we are making this are we could have just keep track of one parameter called Max and we would compare it with whatever the value we calculate at each location so whenever we find a new maximum value we'll just store it in this value and at the end of our Loop in this Max parameter should have our final solution and we can definitely return this and this solution would work perfectly fine now let's calculate the time complexity so basically the time complexity for this one would be Big O of n² um and it's pretty un simple to understand that because for every single element we are basically taking all the elements before that and comparing it with whatever the element we have we did the same for every single element so uh for n element n we might have to compare it with n minus one values so the time complexity becomes bigger of N squ and if we calculate the space complexity the space complexity is also bigger of n because we need to create this additional array to store all the values and uh this is a good time complexity and good space complexity compared to a root Force approach remember our Brute Force approach the value we had was actually 2 to the power of n which was way higher this was almost exponential time complexity and we have done significant improvements from this one and we have actually moved to n squ so this solution would work perfectly fine in any interview and uh I'll move on to coding but thing is I would be making another video uh to explain that how can we solve the same problem uh using n log log and complexity and this is actually pretty ideal and if you can achieve this in any interview uh if you if you can come up with this comp time complexity uh right then and there in an interview you can be guaranteed that you would be placed in any company you want so let's move on to coding now so first of all all we will create a new array called Lis and we would uh create the array of size whatever the size we are given for the input nums and we will initialize the array with value one we will also create a parameter called Max uh that will keep track of the maximum uh maximum longest increasing subsequence inside the loop and we will initialize the value as one so now let's create our two Loops so first of all we'll create a loop that is starting at position number uh one not zero because we need something to compareed to otherwise all the values would be just uh one before that and we will run it till the length of the given array we now this would be our Inner Loop and we would start it from position zero and we will run it all the way up to the position I now inside the loop first we need to determine that whether our current I that is on the right side of uh the array is actually lesser is actually greater value than whatever our J is if that is the case then only we would move forward with the calculation so if I is greater than J now we will do our calculation for the uh dynamic programming so the value of I would actually be the maximum value we can achieve for whatever Lis of I we already have or 1 plus whatever Lis of J we have achieved and this would be our uh recurrence uh relation I guess that is what it is called in dynamic programming uh so this is just to keep in mind that uh yeah if you mention that this is the recurrence relation it it sounds really good impression sounds cool as well and also we check that whether the current Lis value is our Max or not so we'll just just check the existing max value with the new Lis that we just created and uh yeah I think that's pretty much it after this Loop runs uh we can simply return whatever we have found for the value Max and this this should be our answer let's try to run the code I think we made some silly mistake yeah yeah looks like our code is working let's try to submit it and uh our submission works but if you notice that our submission is not actually the best submission uh it's only faster than 55. 54% of the online sub submissions and that is because our this subm this solution is actually work in uh Big O of n² times so n to the power 2 but uh there is another solution that actually runs in bigo of uh n log n time and I would be uh creating a new video explaining that uh solution and this is actually a pretty interesting solution it's actually a sorting algorithm that we are going to use to achieve this so hope you like the video let me know what do you think and if you have any suggestions just feel free to reach out to me our goal is to get get employed in any Fang company and until we get there we are not going to stop so hope you like it thank [Music] you so basically the previous previously when I solve this problem I mentioned in that video that I was solving it in bigo of n Square time and this would be perfectly good and reasonable to expect from any candidate uh in an interview the thing is if you want to be an exceptional candidate if you want to make sure that you don't leave any gaps uh in your Fang journey and your uh so you need to know these things so that's why I'm creating this video and in this video we are going to solve this problem and actually big go of n log n time and the way we are going to do is something called as patient sort so let's uh let's take our custom example and as I have mentioned previously that it is very important to make custom uh examples because using those custom examples you can determine that you have the ability to think and uh make sure that that uh how can you create your own test cases so this is our example and uh it's quite a long one but the thing is I need I need to make sure that I go through all the possible aspects in the given example and that's why I took so many integers so it becomes absolutely clear in mind in your mind that how you how we are going to achieve it so basically at any given location we can either have a null string so a subsequence that has no no entries uh subsequence that has just one entry OB subsequence that has two entries so this is null uh one entry two entries subsequence that is three entries subsequence that is four entries and so on so and our aim is to find out a longest increasing subsequence that we can achieve so for this one we are going to use couple of arrays we are going to put them in a different Manner and uh as you would have guessed that because the time complexity we get is actually n login somehow we are going to use binary sort over here so let's start the uh let's start the problem first of all we are going to create two arrays uh first one first array is to keep track of the longest increasing subsequence that we have found so whether it's value of value one of value two of value three whatnot and second thing is we are going to store the last digit for any given longest increasing subsequence so what I mean by this last digit is that suppose we find a long an increasing subsequence over here that the values 5 16 and 27 is uh an increasing subsequence so in the longest increasing subsequence array we are going to note an entry as three where the because the length of values are three and the last entry we have in this sub subsequence is 27 and the combination of these two is going to allow us to create some pretty interesting things so let me go over the example and I will be explaining uh every single time what we are doing and uh how we are finding it and at the end I'm going to show you that what could be the intuition behind this so at first location 10 basically we don't have any any substring so far so the current substring we have found up until this point 10 is just a single value uh 10 and in this single value 10 in our Lis we can create an entry like one and the last digit we have for this entry one is 10 so we are good so far now let's move on to the next one now next entry is uh So currently we only have a substring 10 next entry we have is 7 now we cannot create an increasing subsequence just just by these two pairs because uh obviously 10 is greater than 7 but the thing is uh we can replace this 10 with this 7even and how we can replace it is because up until this point 10 is a substring of length one and 7 is also a substring of length one so both of us are just same but the thing is whenever we move forward all the values that are greater than 10 will also be greater than 7 which means that suppose we have value over here 11 15 18 something like this and if we take it with 10 we would be able to create a longest increasing sub substring like 10 11 15 18 the thing is same thing can be done for seven as well so it makes no difference that which entry we keep but if we have a value that is between 7 and 10 10 won't be able to do anything in that case suppose we have an entry like uh 8 9 11 so in this case if we would have just considered 10 the longest sub substring we would be able to make is 10 to 11 11 that's it but from 7 we can actually make 7 to 8 8 to 9 and 9 to 11 this would be of size 4 and this would be only of size 2 so it is in our interest to keep seven as our longest increasing subring and not 10 because uh value of seven is actually less than it so we will replace this 10 in this uh in this two array we have created So currently the last element we have becomes s and this uh seven is also of just uh length one so we have only kept this one entry and we have basically just discarded it we have went over it and we didn't find anything good now at this point we only have a substring of seven now comes the value 8 now 8 is greater than seven and8 is in itself uh higher value so we have now we have two possibilities either we have we can keep seven as it is as a longest increasing subsequence or we can have a sub subsequence like s and 8 and we are not appending eight behind this seven we are creating that the longest increasing subsequence we have so far of value of size one is still seven but this one is we are creating a new subsequence that is of size two and we we are appending this seven behind 8 so which means we will be creating a new entry over here in our longest increasing subsequence of value two and the last element of this value is actually eight but the thing is meanwhile the first element is still seven because we only up until this point if we consider a substring that is of only value that is to be only of size one the best element to choose for size one would be seven because it is the smallest and this is the main logic behind the patient sort so let's move on to the next element again we go to Value five now and the substrings we have so far are 7even seven and 8 and now we have this five so we cannot append this five over here we cannot do anything with this but the thing is if we consider these four elements and if we consider the substring of size one five would be the most ideal candidate and not seven because five is actually less than seven so it is in our interest to replace this entry 7even with the entry five and we will update in our uh in our uh array with entry five let's clean this up bit now due to space Contra constraints we are going to write down our sub uh subsequences over here so so far we have to found two subsequences one is just five that is of size one and second one is seven and 8 uh that we have we have stor stored over here and we have we are keeping track of the last digit that we have appended again let's consider 16 so now for this 16 six and if we consider the last two elements 16 is definitely greater than five but there is no point in appending 16 at five it is in our best interest to append 16 behind this 8 so our algorithm is basically what we are doing is we are taking the value from the input we are checking in our uh last array to see that where what is the best position to fit that value and the best position to fit that value is to keep keep the increasing order intact because notice that previously the value we had was seven and 8 that was increasing order now the value we have is 5 and 8 that is also increasing order and now the next value seven next value 16 comes we can actually append it behind eight so after eight8 we can create a new entry and we would do that so we would create a new entry called three and why we were able to do a new entry is because this s and 8 we are not going to replace 8 by 16 we are actually going to leverage this seven and 8 because they are already a subsequence and our aim is to find the longest increasing subsequence so why would we replace 8 with 16 it's actually in our favor to keep keep this 7 and 8 and create a new subsequence 7 8 and 16 so that we can use because suppose if all the values that come after 16 are like 9 10 11 12 13 and if we have created a subsequence called uh 7 and 16 so these all values we would not be able to consider them as our longest increasing subsequence because we don't have this eight but if we have this uh seven and 8 over here and if these values comes after 16 and we have created a separate entry like this 1 7 8 and 16 so this is separate in itself we can actually append all these 9 10 11 12 13 values behind this uh 7even and 8 and this would be our longest increasing subsequence so I hope that this makes things uh more clear that why we are choosing to have a new uh 7 8 and 16 as substring and we we would we would create a new entry in our array as well so now these are the three substrings we have next value is 27 so 27 is again greater than this uh 16 so now we are going to create a new entry 7 8 16 and 27 and we are going to have a new entry in our Lis with value number four and we are going to add the last digit as 27 over here I hope that what I'm doing is understandable that why we are actually creating this new entry uh from the given input the next value we have is nine so let's see that where is the best place we can fit this nine the best way the best place you can fit this nine is actually after 7 and 8 so like this 9 the thing is we are not going to replace this 7 and 8 with 9 because up until this point up until 9 if we see the best pair with two entries only that with the least value is actually seven and 8 there are multiple pairs that create the Val uh that are creating the longest increasing subsequence of length to uh like 5 and 16 16 and 27 5 and 27 the thing is they're all greater values if we see the last element over here 7 and 8 the last element is the perfect fit so that is why we are going to keep the S and 8 and we will be creating a new entry at this place so we are going to replace the 16 with value number N9 so let's update this in our array as well so for the value three the best we can find is 9 and that would be the subsequence 7 8 and 9 so so far we are keeping track of all the subsequences that we have found uh with the values 1 2 3 and four and we are also keeping track of the last digit that we have calculated so far and because all the values are in an increasing order it becomes very easy for us that whenever we find any new value like this uh it becomes pretty easy for us that where we are going to add it in this uh array and which uh value we are going to update it so this is the main logic behind patient sort now the next value is value number one so where in this array we can store value number one it's pretty simple we can only store it at position one no other position we can store and based on this we can see that up until this point if we only have to create a sub subsequence of length one it would be the most ideal to have the last digit as one because all the values after that would actually be uh in an increasing order and we can replace this p in our list of subsequence we will have entry one over here now let's consider this value number 13 where over here we can add this value number 13 so that it would give us the most value and actually we should not be replacing this N9 with value number 13 because we are not trying to achieve a subring like this rather than having 7 8 and 9 we are not trying to get 7 8 and 13 because that is not in our favor because notice that this is already existing and 13 can be appended uh next to it so what we can do is actually we can replace this four what the subsequence with four entries with this 7 8 9 and 13 so our new subsequence would become 789 and the Val 7 8 9 and 13 and why we are able to replace the 7 8 9 and 13 with previously 78 uh 16 and 27 the reason is quite simple because both generate the value four so that is okay but the thing is with this 9 and 13 we have higher odds of making longest increasing subsequences for the upcoming values and which we are going to see right for with the next value so we'll update the value 13 over here and so far so far these are the four subsequences we have now the next value is actually 15 and imagine that if we had kept this value as the substring of four values we wouldn't be able to insert 15 over here because though both of these were same 15 is easier to be appended over here but it cannot be appended over here so that is why in the previous step we actually replace this value four with 13 so I hope this makes it uh more understand understandable now let's see that what we can do for this uh value number 15 so the logic is quite simple we are simply going to append this value number 15 behind this 13 so the new subst and we are again we are going to keep the value number uh 7 8 9 and 13 as a four substring as a substring of length four and we are going to create a new substring 7 8 9 13 and 15 and this would be a new entry in our array so we will have a substring of length five and the last digit for that would actually be uh 15 and this would be the end of our array uh and since we have reached to the end we just need to iterate over this one and find out that what is the biggest length we were able to find and we just simply return this value so this is is as simple as it can be and why we are able to achieve it because at every single location for every single element we are trying to see that where we can fit that element that best represents that position and based on it we were keeping track of the longest increasing subsequence so basically we were intellectually choosing our own longest increasing subsequence and we are also keeping track of whatever we have calculated in the past because if we were to choose a value of three that what is the longest increase in subsequence up to the point of three we can easily say that hey it's this one and the last digit is actually n so if we find um some better digit it becomes pretty easy uh for us to calculate that where we are going to append that value and I hope this makes things uh more understandable now let's calculate the time and space complexity for this one and it's pretty simple Le that at any given location we are iterating over the entire array and for any single position we are checking that where we can store that position in this given uh new array that we are trying to create but thing is this new array is already sorted so if it because it is sorted we can actually achieve that in log and time and initially we have to iterate over this entire actual input once so that will take end times so basically we are calculating this whole approach in bigo of n log n time which is a very good time complexity because if you remember correctly originally the BR for The Brute Force approach our time complexity was 2 to the power of n for the uh second accepted approach that I completed in last video our time complexity is actually n squ the thing is n log n this is a thing of beauty now let's move on to coding and if you still don't understand the concept I again ask you kindly to go over this example again because if you can Master this sky is the limit for you so let's do the coding now let's create a new array list we can start by adding the first element because uh the first element would actually be the first uh list of uh size one and then we will initialize our Loop to iterate over the entire input array and again we'll start the loop from uh second position I equal to 1 inside the loop we need to find that whether the given number is it actually greater than whatever whatever the last value we have in this subsequence if it is we need to append it to the subsequence so and we can just add it to the subsequence if not we'll need to run the binary search so and over here we can just create a new function for to run our binary search and in input we will provide uh the substring and current uh I value we have and now let's create method for that inside the loop first of all we'll create a left and right variable so left would be of size zero and right would be of whatever the size we have for the uh integer for the given in substring now we will just run a condition that while left is less than right we are going to calculate the midp pointer and then if the midp pointer is already existing we simply return that value if not we either move on the left side or right side so we'll do left is equal to Mid + 1 else we can simply do right is equal to Mid and after the loop we can return the value of left now over here in the J we are receiving whatever the value of left we got so we add the subset to uh our existing subsequence the that should be the logic uh so after the return We after uh the end of the loop we just need to return the size of the list and this should provide the longest increasing subsequence let's try to run this code looks like we put the values out of order yeah looks like our solution is working let's try to submit it and yeah see our solution is actually faster than a lot of other submissions and that is because we are our runtime is actually in login and uh I'll be posting this solution in the comments and I hope you like the video thank [Music] you hello friends hope a fantastic day today so now we are going to solve an awesome lead code problem called Partition equal subset sum now we can see that this one is a lead code medium problem and also an extremely well-like problem so let's understand the problem statement basically we are given an integer array called nums now we need to return true if there can be a partition in the array such that the two subsets that we make with that partition has the sum that is equal of the sum of the elements in both the subsets and if that is not the case then we need to return false now I know that the wording of this problem is actually uh not the best way to put the put the problem statement but let's try to understand in simple terms we are given an integer array now we need if we can create two partition such that that sum of all the elements in this partition and sum of all the elements in this partition if both are equal then we need to return true if that is not the case then we need to return false now let's try to see some examples if we see this first problem we can see that there are four elements and we can create a sum uh like this that is sum of 5 + 5 + 5 so this can be one partition and second partition can be this value 11 and if we check the sum of both of them they turn out to be 11 so in this case we can return true that we can create a partition such that the sum of all the elements in both the partition are equal to each other let's try to take one more scenario 436 now in this case uh we cannot create a partition where the sum is going to become even if we create a partition like four and three and second partition is six then it doesn't work because this is going to be seven and this is six and there are no other partitions that you can make so in this case you will need to return false because no such partition can be made next let's see one more example so in this case we can create a partition like this 1 2 and three as first partition and second partition is six if we do some of like either partition event eventually we would get the value six as the answer and this is what we need to return because we are seeing six partition being made we need to return return true in this case now if we see the Brute Force approach for this problem it is quite straightforward brute force or the most simple way to solve this problem would be to check for every single possible partition so we can start start from the first element and we can try to start every single possible partition so we can create a partition where one value only contains five and the other value contains these three values then we create a partition like this then we can create a partition like this and so on and so forth so every single time we would try to create all the possible partitions and then we will see that whether that approach works or not but thing is this is not the most optimal approach why because we can clearly see that with the given number of elements we can create multiple partitions so this is this basically becomes like an exponential uh time complexity because now we are dealing with all the permutations and combinations so this is not a good way to move forward with this approach we'll have to find a better way to deal with this problem so the Brute Force solution would not work let's try to see that what the optimal solution would look like now before we start understanding optimal solution let's make two or three very quick assumption that will help us El eliminate lot of bad cases number one thing is whenever we are able to make like two equal partitions there has to be the total number of uh all the sum has to be even number what do I mean by that well if the sum is even then only we can create two partition that are going to be equal to each other and we can understand it with this example we have three values 1 + 2 + 3 so total sum is going to be six and because this total sum is six we have the possibility of creating two partition that becomes equal in value that is going to be three and three if we had the total sum to to become even number let's say that this value is 1 2 and 4 something like this if we have a part if we have an input array like this if we do total sum this becomes seven with seven we can never create two partitions that are going to be equal to each other why because 7 divided 2 is going to be 3.5 and we are only dealing with integer numbers so we cannot have a partition that sums up to 3.5 which means we cannot generate the answer this is the first resumption we can make that the total sum of all the elements has to be an even number okay after determining the even number next assumption is that once again for the same example we can see that the total sum is six now the total sum is six we know for a fact we need to create two partitions and both partitions has to be even so both partitions has to be value three and three in nature so in this given input array if we can find a partition that sums up to only value three then we don't have to to find another partition it has to exist inside the array why because we know that the total of all of these elements are six and we if we already find a partition let's say with these two values that sums up to three then we have we must have another partition that is going to be 6 - 3 so it this is also going to be three so we can also find that answer so basically we need to first check that whether the sum is even number and second thing we need to check is that are we able to find a partition that can actually sum up to the total sum so total sum divided by two if we are able to fulfill these two conditions then we can return true immediately and if we cannot fulfill these two conditions then we can return false in the end or immediately okay now let's try to see the solution I'm proposing and for that remember one thing that the input we are currently given we are actually depending on the previously calculated values that we already we have so far which means let's say that if this is the example we are given we know that we can make a partition with these two values as partition three but this is use useless information if we don't know that what other values are or what is the total sum we know in this case that the total sum is going to be 14 so because total sum is going to be 14 we are striving to create a partition that sums up to Value number seven but with these two we can only create three so should we discard them from the partition yes but we can have another partition like these three values that sums up to seven but thing is creating partition depends on the previous elements that we already have calculated and the next future elements that might come into the picture so our current calculation that we are doing for the current value is actually dependent on previously calculated values that we already have on whether to include that inside our our solution or not to include that so we are going to use the most beautiful thing in the entire computer science that is dynamic programming and for dynamic programming what is the approach I'm suggesting number one we are going to create a new dynamic programming array but for this array we are not going to go to the full length of the total sum that we currently have we are only going to go up until the total part like the half of the total sum So currently half of the total sum is value seven so we are only going to have seven entries inside our dynamic programming array we can create a partition array like this now initially all of the values are currently going to be false because we cannot create any single partition so far because we haven't checked for all the values except value zero why value zero because we can always create a partition that equals to zero if we don't have any value in that partition so the purpose of this dynamic programming array is that for every single element we will only mark it true if we can create a partition that sums up to this value so let's let me just Mark the initial value as zero as true because we can always create a partition with zero entries in it so now this one is currently true and our aim is to check that by the end we are done with all the current numbers that we have we simply have to check that whether the DP of 7 is true or not if this is true then we can always have a partition that sums up to seven which means we can create two equal partitions that sums up to 7 because the total is 14 so I hope my explanation made sense now let's see the walkth through of this this problem so first thing we are going to do is now we currently have value number one the idea is we are going to be starting from value number 7 and we are going to go back to the value number one and currently our I value that we are dealing is going to be uh the current I that we are using to iterate over all of these values and next thing is that for the number that we are currently using so we are actually using value number one to go over so all we need to do is that dynamic programming value of any particular number depends on the total number of position like so I position I have minus the number value I have so let me explain what I mean So currently I minus num that we are going to check for any particular value so let's say when initially the I is going to be 7 so if I have to update the value of s currently I have DP of I minus num is going to be uh DP of 6 so so DP of 6 is false so I'm going to leave this false same way for DP of 6 I'm going to be checking DP of 5 this is also false then for this one because currently the number is one that we are dealing with same way this is false this is false this is false except when we reach to this very first element we can see that dynamic programming for one is going to be the value of I minus num so the value of I is currently 1 and the value of num is also currently one so this is going to be uh DP of 0 so DP of 0 we know is true which means we can also create a partition with that that sums up to Value number one and we can mark this as true so let's just quickly do this one and this is going to be uh turned into true now you understood what I did I check for all the possible values and I check that whether there can be a partition being made where I can include value number one and then we can I can make those part partion So currently I don't have any values so I can not check any other value apart from creating a partition that is one now let's start to work with value number two once again we are going to be repeating the same formula that we are going to be checking of DP of I minus the current number that we are dealing with and current number is two so for Value number seven I will have to check DP of 5 so this is false so I'm going to leave it as it is for six I'm going to check four this is also false for five I'm going to check check three this is also false but now for four I'm going to check two this is also false but for Value number three I'm going to check DP of 1 I now notice that DP of 1 is true so I can also Mark this as true because I can create a partition using value number two that sums up to Value number three so I'm going to be marking this as true now for DP of two I'll have to check value of DP of0 so this also becomes true so I can also Mark this one as true as well because I can create a partition that sums up to two which only contains one value now you must have gotten the grip of what we are trying to do in this problem so now let's just quickly walk through the remaining solution for DP of 4 for Value number 7 I will have to check the DP of 3 DP of three is three true so which which means we can also create DP of 7 is equal to true as well so I'm going to mark this one as true uh same way for DP of 6 we will have to check DP of 2 so this is also true so we are going to be marking this as true as well and now you understood for DP of 5 this is also going to become true and DP of 4 is also going to become true so this entire array eventually became true and we haven't checked the value seven but we can also check for Value seven as well no worries with this one and this is also going to become true so now logically all we need to check is the DP of 7 if if that is true or not since this is true so in the answer we can also return true saying that we can create a a partition that sums up to Value number seven using this dynamic programming approach and this is what we need to return so basically this is such a beautiful solution and uh rewatch again if you did not understood and let me know in the comments on how do you feel about my explanation now let's try to understand the time and space complexity in this case time complexity is going to be big of n because we are simply editing the over entire array but we are doing it uh in total number of the total number of elements that are currently present inside the array and if we see space complexity so space complexity is going to be biger of n because we are using an additional array to store this information now let's quickly see the coding solution for this one so the coding solution is quite straightforward first we are going to initialize a variable called total sum and we are going to iterate over the given input are nums and add all the elements inside the total sum first thing we are checking is that if the given total sum is odd then it is not possible to create equal partition so we can simply written false if that is not the case we will first of all create the target value of which the partition number we are trying to achieve then we are going to initialize a Boolean array uh called dynamic programming and we are going to be marking the first value inside the dynamic programming array is true now notice that I added the value to be Target + one because if the target is seven we need total eight elements inside the array where first element is going to be DP of0 I hope you understood that now next thing is that uh we are going going to have a for Loop that is going to iterate over every single number that we have in the nums array for each of the number we are going to be checking that uh we are going to be starting from the target value and we are going to go down to that particular number and we are going to be reducing one element at a time and every single location we are going to check inside the dynamic programming array that what is the value of J minus num and if that value is true then we can also Define the dynamic programming of J to be true as well and in the end we simply need to return dynamic programming of the tar Target value or the very last element inside the given array so this is the whole solution let's try to run the code seems like our solution is working beautifully let's try to submit this code and our code beats 94% of all the other Solutions in terms of time complexity and 87% of all the solution in terms of space complexity this is one of the most accurate and beautiful Solutions out there so I would be posting this inside our GitHub repository feel free to go ahead and check it out thank you hello friends we are still not employed by Fang company so let's not stop late coding till we get there today we are going to do a very important lead code problem unique paths and as you can see that this question has been asked in Google Facebook Amazon Apple Microsoft Bloomberg all huge gigantic it companies so I highly urge you not to miss this video and uh try to understand the problem as as thoroughly as possible um this is going to be the framework for the video we are going to understand the problem we are also going to find a primitive approach we are going to find the optimal solution and we will write a Java code for the optimal solution this is a lead code medium problem we are given that there is a robot and an M cross n grid and robot is initially located on the to top left corner now robot tries to go to the bottom right corner so this is the last place where robot wants to reach and uh at any given moment robot can only make one move it can either go down or it can go right at any point in time uh no other ways it can make so in the problem we are given this m and n and we need to find that how many distinct unique paths can robot take to reach to the bottom right corner or its final destination so suppose our given m is equal to 2 and N is equal to 3 if both our m is equal to 3 and N is equal to 2 this is one of the test cases so if we see if we draw it on the board it would look like this this is where the robot is initially so I'll just mark it as R and this is the destination that robot wants to reach the bottom right corner now we know we need to to find that how many unique paths exist so let's see that how many unique paths can we make and at any given moment robot can either go on the right side or down it cannot make any other steps so let's see that what are the possibilities so this is one possibility so this is one path I'll just mark it somewhere now this is second path I'll also Mark it somewhere so this is second path so have we exhausted all possibilities no there's still exist a third path and the third path is like this 1 2 one and apart from these I we cannot make any uh any more paths so essentially we are existing all the exhausting all the possibilities and we can return that for this given M and N the number of unique paths can be three now I hope that this uh makes problem statement more understandable over here initially we are given an example of M is equal to 3 and N is equal to 7 uh and the number of unique paths they get is 28 but I thing is this would be too such a long uh uh example so I'm not going over it okay let's understand this uh with a custom example so suppose our m is equal to 3 and N is equal to 3 so we would have a grid that looks like this over here this is our robot this is our destination now we are going to calculate that at to in order to reach reach to any element how many unique paths we can take so suppose if we want to reach to this element how many unique paths we can take we can only take one unique path and that would be to take this right step from here we cannot take any other step same goes for this element that we can only have one unique path and that would be to take two right Steps From Here uh we cannot reach to this point any other ways same happens for these two elements as well that we can only take one step down or two steps down to in order to reach to the these two elements but the thing is there cannot be any other unique path if we want to get here but thing is when we get to this middle points uh something interesting happens and the interesting thing is suppose we want to reach to this point how many unique paths we can take well we can take two unique paths we can take one unique path to reach to reach over here and then over here or we can take one unique path to reach over here and then again reach over here so we can say over here we took two unique paths but thing is if if we just see that what are the entry points to get to these this point actually there are only two entry points to get to this point one entry point is that we can if we somehow get to this point we just take one step downwards we we come over here or if we somehow get to this end point if we take one step on the side we reach over here which means that whatever the unique paths we have at these two locations if we just sum these two up it will give us the number of unique paths we can we can take to get to this point point so let me show you by by another example now again let's consider this element so in order to reach to this element there are only two ways we can reach to this element we can either take one step from here or we can take one step from here which means that whatever the number of possibilities we have over here that once we get to this point we will be able to come to this unique path okay so that is a given same goes over here that no matter how many number of possibilities we have to come to this point if once we are at here we are guaranteed that we can come to this point so in order to reach to this point the only possible ways are this one and this one so if we sum these two we will find the number of unique unique ways we can reach to this element and in this case it would be three if we continue down the same path for this point uh we can take three distinct paths to reach over here and in order to reach to this destination D we can take 3 + 3 six uh unique paths to get to here and this actually becomes our answer okay so based on our previous explanation we know these things so if we see now we need to see that how can we use dynamic programming to solve this problem and the reason we are choosing dynamic programming is because at any single location we are Computing that whatever the previous two results that we have already calculated and we are using them to calculate the next values so that pretty much uh indicates that we need to use dynamic programming over here now let's take a 2X two Matrix and uh we'll just provide the index values so index values would be 012 012 and we would name this Matrix as DP to refer dynamic programming now the thing is if we want to find out the value at this position we know that it would be sum of these two elements so mathematically we can write them like this that DP of 1 1 because this this is one and this is one is actually equal to DP of 0 1 that we have already calculated which is this Value Plus DP of 1 0 which is this value and some of these two will give us this value so generically we can actually write them like this that at any given location DP of M and N would actually become DP of M -1 n plus DP of N and nus one and this would be our recurrence relation for dynamic programming and I already explained that why are we choosing dynamic programming and our aim is to find that how many distinct ways we can reach to this destination so this destination would actually become uh DP of 2 2 over here and if we compare it with whatever m&n is given uh this actually becomes the value over here this would become the DP of m-1 and N minus1 so we start our calculation like this and eventually we would reach to this point and we just need to return whatever we have found over here and this would be our solution so we can just create two Loops one Loop iterate over the column one Loop one Loop iterates over the rows and eventually we will reach this end point we return this this becomes our solution and this is a very efficient dynamic programming solution uh any Fang companies Facebook Google Amazon whatever they would be happy to hire you immediately so now let's see that uh what would be the time and space complexity so time complexity would be big go of M * n because we need to iterate over this entire grid so that's why it's B of M * n and space complexity remember that we are creating this additional DP array uh which is 2x2 matrix and we are giving the size as M and N so space complexity would also be big go of M * n and and this would be our solution now let's move on to coding okay first of all we'll create a two- dimensional array and we'll name it as DP and uh we'll provide the length as M and N now we'll have to create our base case so we will fill our uh two dimensional array and this is the way to fill a two dimensional array and over here now we'll create two for loops and uh we'll start with i is equal to 1 and J is equal to 1 because we already have cases for zero while I is less than m i ++ J is = to 1 J is less than n okay now we will provide our recurrence relation so DP of I and J at any location is equal to DP of I -1 J plus DP of i j minus one and uh yeah this is pretty much it this should be working so now let's uh return let's return uh DP of M minus1 and G N minus one let's try to run this code oh it should be arrays do fill small error looks like our solution is working let's try to submit the code okay our solution is actually runs in 0 millisecond it's 100% faster than all the other submissions which is pretty good and uh [Music] I'll so the lead code problem we are going to solve now is called longest common subsequence now we can see that this one is a lead code medium problem and also one of the most like problems on lead code so I'm going to pay my atmost attention now let's understand the statement we are given two strings called text one and text two now we need to return their longest common subsequence and if there is no common subsequence that exist then we need to return zero now we are given the definition of a subsequence is a string that is a new string that can be generated from the original string with some characters that can be deleted without changing the relative order of the the characteristics so without getting too much into the details of the definition let's try to understand what we are being asked to solve basically we are given two strings text one and text two now we can notice that text one currently has five characters a b c d e and text two has currently three characters a c and e now the thing is if say for an example from text one we decide to eliminate this characters B and D we can also create a c and e and this is going to be the exact same manner or the sequence of relative order Remains the Same between both the strings so we can say that for this given example we actually have a longest common subsequence that we can make that follows the relative order and that is of size three so we need to return three as part of the answer for in this case now let's try to understand it with one more example for this one now we can see that currently the characters we have is XY Z and the characters we have for this text two is y a b so now we can only find one character that is common between both of them and that follows the relative order and that is this y apart from that we don't see anything common so in this case we can only create a longest common subsequence that only cont consist one character so we need to return one as the answer now if we take a look at this example text one and text two we see that there are no characters that are same between both the text so in this case we will have to return zero but in the same example say for some reason if we are given the values like a b c and DF over here and then we are also given D over here then we will need to return two as the answer because the relative order of d and e Remains the Same even if this this string had three additional characters so we will have to solve this problem and definitely this is going to yield to some very interesting results now let's understand the Brute Force approach to solve this problem the logic is quite straightforward let's say that we are currently given two strings uh in this particular fashion then we what we can do is we can go through every single possible combination of any particular string and try to match it with the other string so what I'm suggesting is that for this text one we start taking permutation of all the other substrings that we can make out of this one and we know in terms of making permutations we can some actually make 2 to the power of n permutations for any given value why because at every single character we will have to make the decision that whether we need to include this character or not to include this character in order to generate the permutation so this would eventually yield us the correct result because what we'll do is we'll try to create all the different permutations and combination compare it with this given another string and we'll try to see that what is the longest common subsequence that we are able to make but this is very inefficient approach and also the time complexity goes in some sort of exponential form so I'll not go into the depths of this one and we'll try to do something smart in order to solve this problem now let me come to the optimal way to solve this problem and for that we are going to use one of the most beautiful Concepts in computer science and that is dynamic programming now let's take a quick recap let's understand that why do we actually have to use dynamic programming in this problem well the answer is actually quite straightforward because let's say that we are currently given the two strings as a b c d e and then once again a c and d now notice that if we start comparing the two strings at any given moment character by character it would not be very much fruitful why because okay let's say that we Define that this a is common between both of the subsequence now we are at this character B and we don't know that next character B is not present over here so we don't know that whether B is going to be present somewhere down the road or not so do you think that we should compare B with every other character that is currently present inside the t2 string well we could do that and we are going to do that but in order to do that we'll also have to remember that what was the relative order of sequence that we have been able to identify beforehand and it could be possible that if we are dealing with multiple sequences which subsequent to consider so let me give you one example like this let's say that we are given currently strings like a b c d e okay and we are given the T to Str string to be a b then x y z and then once again we are given the string to be let's say uh b c d e so do you think that from this particular point forward if we see the longest common sub sequence we can make is going to be two but the moment we start identifying these characters we can if we just drop this B we can actually create the longest common subsequence of size five but we have to drop one B that was already part of one of our relative subsequence which means the result that we are going to make later down the road is actually going to be dependent on the previously calculations that has been made and also future calculations that we are yet to be make and when we are at the last position we should make the best judgment on which path to take so that's why this is a good candidate for dynamic programming now the question is how we are going to use dynamic programming to solve this problem and for that what I'm suggesting is number one we have to check every single character for all the other characters and same way for any particular character we will have to compare with compare it with all the the remaining characters so there is no getting away from that in this problem we will have to do n Square work or M multiplied by n work where m is the length of text one and N is the length of text 2 okay so this is this has to run in bigo of n Square time complexity but how we are going to do that number one thing I'm suggesting is that we actually create an M cross n grid just like the one that I have shown over here and for this particular grid we'll need two things for for our dynamic programming we'll need a base case scenario so base case is quite straightforward that if any particular character is not matching with the other character then we simply Define it as zero and notice that we actually have created an extra space uh at the beginning so there is an extra row and extra column which means this is not strictly an M cross n Matrix this is actually an m + 1 multiplied by n + 1 uh Matrix so we are adding one more extra line and that is to consider our base case now at any given moment what we are going to do is if we identify that there exist a combination there exist a value that is common let's say that over here the C and C is going to be common for this particular cell which means what we can definitely say in this case is that this cell is going to be an addition to the previously calculated longest common subsequence now what is going where is going to be that information for the longest common subsequence to the diagonal value why it would be at the diagonal value well let's take a simple example let's say that currently the values are a b c and this value is a b and c so notice that for this particular Square the logic is going to be quite straightforward we are going to have a and a common at this place then we are going to have B and B common at this place and then we are going to have C and C common at this place which means longest common subsequence is directly represented towards the diagonal value in the best case scenario and this is the fact that we are going to exploit so whenever we identify that at this particular location there was a common subsequence then we had to add one value to the previously found longest common subsequence but we haven't found any subsequence because this value is zero so definitely the longest common subsequence at this eighth location is going to be one so we are going to mark it by one same way the longest common subsequence at this location is actually now because we are comparing AB with ab and that's why this is going to be an addition to the diagonal so we are going to mark value two and same way this is going to be value three one more addition so same logic we are going to apply over here that whenever we identify any particular common characters we will check the diagonal value that is number one thing next thing is that let's say we identify any particular character that does not have any common values so both characters are different than each other then it becomes the question that what is the longest common subsequence we have found so far and there can be two possibilities why because let's say that I'm currently at this B position so on one side I'm checking against AB but for a I have checked with a I have checked with a c and I have checked with a c e because I'm trying to fill up this row same way for any particular C character I'm also comparing it against a against a b against a BC and whatnot so the answer for the longest common subsequence where the characters do not match is actually going to reside on the adjacent cells for any particular cell so let's say I'm trying to consider the values for this cell now we know that B and C don't match so in this case we'll have to check that what is the longest common subsequence we found either way because we are not only comparing text one with text one or text two with text two we are comparing them with each other so we'll have to take the maximum value amongst the adjacent cells and this is going to yield us the correct result so now let's recap our rules number one if we find equal characters so let's say that if I and J value are equal then we are going to do the + one operation compared to its um diagonal value so diagonal value is going to be i - one and J minus one uh this cell okay and if that is not the case if we find that I and J character do not match then we will have to find the maximum value from its adjacent values or subsequent neighbors so now let's try to do the solution right now okay let's start filling up this particular whole Matrix now very first value we find a and a there is a match if there is a match we are going to compare it with its diagonal value and add one so diagonal value is zero so we are going to add value number one over here now next thing is that we will also have to check uh let's let's go row by row so now we are checking this a with this value B A and B do not match so if they do not match we will have for this cell we will have to check its neighbors so we check this neighbor and this neighbor and whichever is the maximum value we add this one so what we are seeing is that up until this point inside our uh input we have calculated a b with a so in this text one and text two we can see that the longest common subsequence we find was of size one and this is what we are defining it over here next we are comparing a with C once again uh sorry a with C once again there is no commonality so we'll add value one a with d once again no commonality so we will add the maximum value one and a with e once again the maximum value is going to be one now let's repeat the same operation once again but now this time we are going to be doing it for Value C now C and A do not match so we'll try to find the maximum among these these two value and once again the maximum value among these two is still going to be one so let's just mark it as one same way this is going to be one as well now we are at this position of C matches C so we'll have to do an increment with the diagonal value and we are going to be adding plus one over here so we can mark this as two now for this D with C we'll have to compare the maximum among these two and the maximum value is two so we'll mark the value as two as the answer and same way 2 is the answer over here now we are comparing e with this a so once again the maximum among these two value is going to be one and notice we found two over here but why we are marking one because notice what we are calculating or comparing so far we are comparing a with value a c e so in this case the longest common subsequence is going to be of size one and that's why we are marking one over here same way this is going to be one because we are comparing the maximum among these two same way with C we are the now the value is going to be two because this value was two and why it was two because notice we are comparing the values a b c versus value a c e and amongst this comparison we can see that there exist the longest common subsequence of size two that which is represented over here this is the beauty of dynamic programming solution now uh for this D comparing with this e once again we'll choose the maximum so answer should be two and now we have e common for this last cell so we'll have to do plus one with the diagonal so 2 + 1 is going to be three so we'll mark it as three in the end we simply need to return whatever we find in the very last cell as part of the answer and that is going to be uh three in this case so we can return this with confidence see how beautiful the solution looks all we need to do is just fill up this Matrix and things work out beautifully for us now if we have to calculate the time and space complexity for this one time complexity is going to be biger of n square or M * n and space complexity is also going to be big of uh m + 1 * n + 1 so we can say m cross n for Simplicity but anyways this is a beautiful time and space complexity and very awesome approach now let's see the coding solution for this problem uh basically we are going to Define two characters M and N to define the length of both of the given strings text one and text two then we are going to initialize our new array uh DP array now notice that we are defining it as an length of m+1 and N +1 to take care of the zero case scenario that is going to be our base case for our dynamic programming table now uh for this Matrix we are going to fill in all the details so we are going to use two for Loops to iterate over every single row and every single column notice that we are starting the values from 1 and one because for I value of 0 and J value of 0 we already defined the values as zero now first thing we are checking is that at any given moment we identify that the character at IUS one and character at J minus one location are equal to each other then for the current I and J value we are going to add one to the existing diagonal value that is i-1 and jus1 value in inside the DP if that is not the case then we are simply going to pick whichever is the maximum value for any particular I and J element from its adjacent neighbors so whether the top value or the left value of Any Given cell and in the end we should have completed all the values for the longest common subsequence and the very last element inside of our DP array is going to represent that so we are simply going to represent that value that should give us our correct longest common subsequence so now let's try to run this code seems like our solution is working as expected let's submit this code and our code beats almost 90% of all the other solutions that is excellent in terms of time complexity now for the memory we can improve on some aspects uh but we are using like an M cross and grid and that is also a fine enough solution but overall this is a beautiful solution and once again it is available aable on our GitHub repository so feel free to go ahead and check it out from there thank [Music] you so the lead code problem we are going to solve now is one of the most popular lead code problems that is called best time to buy and sell stocks with cool down this one is a medium problem but in my opinion this can be categorized as hard in some scenarios and this is a very well-like problem so let's understand the problem statement we are given an array called prices that represents the price of any particular stock on any particular given I day now we need to find the maximum profit that we can achieve and we have the luxury to complete as many transactions as we like and the only restrictions is that after we sell our stock we we cannot buy the stock for the very next day which means we'll have to cool down for one day now let's try to understand this with an example say here are the price of any particular stock is given for five consecutive days and our aim is quite simple maximize The Profit now let's try to First understand that what is going to be the answer in this case let's say if we decide to buy stock on this particular day then our buying price is going to be one and then we decide to sell the stock on this day so then our selling price is two so what is the profit we made during this duration is going to be of value one then remember after selling we'll have to wait one more day for the cool down so let's say that we decide to cool down on this day then we buy again when the price is zero and then we sell again when the price is two so we make profit of $2 or two two units over here so in total amongst these prices the maximum profit we can make is going to be three now notice that we did not use the greedy approach and try to maximize our profit in one single transaction why because logically it would make sense that if we have values like this then if we have already bought the stock on this day then instead of selling over here if we decide to sell on this particular day then our profit for this region would have been two but this would not yield us to the maximum profit why because then we cannot buy stock on this day because of the coold down um condition that we have and then we are at the last day so even if we buy the stock then we are just diminishing our profit let's say that we don't do anything on this day still the maximum profit we can achieve is going to be two in this case so this is a very tricky problem and uh first let's try to understand a very simple Brute Force approach in this case to solve this problem now notice the Brute Force approach is quite straightforward we for any particular day simply try out all the different combinations and permutations and combinations and uh do all sorts of calculation so we can check that what if we buy on this day then we decide to sell on this day then we decide to sell on this day then we decide to sell on this day and then we decide to sell on this day uh once again repeat the same scenario when where we are buying on this day and then selling on this particular day and based on that also consider it for the cool down scenario as well so logically for any particular I day we can have three different states that we can think about whether either we are buying we are selling or we are resting and for each one of the three possibilities uh we will have to do this e times and we are calculating all the permutations which means now we are talking about the time complexity that yields in big of n factorial time because we are dealing with all the permutations so this is a very expensive Brute Force approach to find the maximum profit we'll have to optimize the things but thing is there is no way for us to get away from maintaining the states for any particular I day that what if we buy the stock what if we sell the stock or what if we rest for that particular day and what is going to be the maximum profit in that regard and once we have this information it becomes much easy for us to find the appropriate result that we are looking for now let's talk about the optimal way that we are going to solve this problem and we are going to use the most beautiful Concept in the computer science that is dynamic programming now let's just do a quick recap why do we need to do dynamic programming in this case in order to solve this problem well logically we cannot use just any single approach to find the maximum profit we just saw it with this example that if we decide to use greedy approach where we are trying to buy at the smallest price and sell at the highest price this does not yield the direct result also the decision we make at any particular day on whether we need to buy the stock sell the stock or go into the cooldown mode would depend on the all the previous values we had and all the future calculations that we might have which means all we can do is that for any particular day we can simply say that if let's say on this particular day if I decide to buy the stock what is going to be the maximum profit I I can make if I decide to sell the stock what is going to be the maximum profit and if I decide to go for the coold down what is going to be the maximum profit and keep this calculation doing for every single one of these days and just based on the previous calculations of the previous day we should be able to calculate the maximum profit of the subsequent day so I know what I just said might confuse you but let me explain it with an example so let's say that for the same example that we were talking about let's define find each of the scenarios for maximum profit that we need to calculate in each of the three scenarios for buying selling and for holding or resting or if we are in the cool down mode how do we Define that what is the maximum profit we can generate if we decide to buy on any particular day let's say that on this particular day if I decide to buy a stock then what are the different considerations that I'll have to make number one consideration is we can only buy any stock after we are coming out from the cool down which means on the previous day we must have been in the cool down state so number one thing is we in order to check the maximum profit for Buy on any particular day we will have to compare two values number one value is that what was the maximum profit we were achieving on the previous day for this buy operation um and compare it with that what we did a cool down yesterday and now we are trying to buy so the cool down maximum profit for the previous day minus the current I value we have so price on this particular day so now let's try to generate the mathematical equation for any particular value of buy but the thing is we'll have to remember that what was the maximum profit achieved on the day before and not on the current day so for that we'll need to have some data structure that that stores that information and we can use uh an array to store that information we can create an array of the same size so let's say that I create an array of size five where for any particular day I'm defining that what is going to be the maximum profit I can achieve if I decide to buy on that particular day so that calculation is going to be dependent on the maximum profit I was able to achieve if I had already bought before and not buy today or maximum profit I can achieve if I was I'm coming out of the coold down and I decide to buy today so what the mathematical equation is going to be that maximum profit on if I decide to buy on E day would be I'll need to compare two elements so max between uh what was the uh buy of I minus one so what was the maximum profit on the previous day and compare it with the coold down profit on previous day plus uh sorry not plus but but minus the current prices that we are dealing with so price on the current day so this is going to be our mathematical equation for our buy formula same way for our selling let's say that if we we want to calculate the maximum profit we can make if I decide to sell on any particular I day once again I'll have to do the calculation with the previously calculated values but now in this case the calculation comes off a bit different number one thing is if I decide to sell today and on any particular day then the profit I'll I'll be comparing it with is that what is the profit I was making if I sold yesterday so if I sold yesterday and I made more profit it does not make sense for me to sell it today so that is number one thing we are comparing and we are comparing that what was the buy profit that we made yesterday so if I bought yesterday what was the maximum profit I was making plus the price of the current p day so same way for the buy we made this equation same way we can make another equation for sell where we are comparing the maximum value amongst the two values so what was the previous profit if I sold on yesterday instead of selling it today and comparing with with what if the maximum profit I made on buy minus buy of I minus one so previous day if I bought the stock plus whatever the price of I today is because the price increased so there is high higher potential that I could I can gain more profit by selling the stock today and uh next thing is if I decide to rest on this particular day so let's say that uh instead of selling on any particular day I decide that I'm I'm not going to do anything and I'm just going to rest then what is going to be the implication so we simply need to compare that what was the previous day's profit we were making that is for sure so for rest we are going to compare the previous day's profit so rest of of uh IUS one and we are going to compare it with what if we sold yesterday so if we sold yesterday then we are resting today so what is going to be the profit if we sell yesterday and whichever value is maximum we are going to store that as the answer okay so based on our explanation these are the three different uh equations that we made now I just wrote them roughly to have a brief idea on what we are talking about and then we have initialized three different arrays that we are going to to play around to keep track of the maximum profit on that particular day based on whether we can buy sell or rest on any particular day so now let's first initialize the value and this is the prices array that we are given that we are dealing with now on first day we cannot sell anything or we cannot rest so we can Mark these values as zero and the maximum profit we can make on very first day is if we decide to buy something and let's say if we buy something we haven't made any profit we are actually losing money or putting money on the table so the maximum profit we can make if we buy something is going to be minus one or the negative of the price of that particular day okay now we can start our calculation so let's say that for second day if we have to calculate that if we decide to buy something what is the maximum profit we can make so for that for buying we need to compare the Buy price on the previous day so maximum profit being made on the previous day and what if we decided to rest on the previous day so what was the maximum profit we were making then minus the price of the current day so if we compare that we are compare comparing the value of minus1 that is the maximum profit being made on the previous day and what if we rested on the previous day so that was 0o minus the price on the current day so 0 -2 so we are comparing the values of min-1 and -2 so what is the maximum profit we can make well of course maximum profit is going to be minus1 so we can simply Mark minus1 at the Buy array same way for the sell array if we decide to sell on this particular day what is the maximum profit we can make once again we are comparing the previous selling profit previous maximum profit from the previous day or what if the previous maximum profit we are making if we bought a day earlier plus the prices of the day today so of course this is quite obvious that uh if we decide to compare then first value we are comparing is zero because that is the maximum profit we are making on the previous day and we are comparing it with the buy maximum profit on the previous day so that was minus1 plus the price is today so the price is today is 2 so -1 + 2 so we are comparing the value 0o and 1 so obviously one is greater so maximum profit we can make uh if we decide to sell is going to be one so we'll mark one same way if we decide to rest today then we are comparing two values the previous profit being made on rest and previous profit being made on sale both of these are previous because we are simply not doing any transactions we are just resting so both are zero so since this maximum profit we can make by resting today is also going to be zero next thing is that what is the maximum profit we can make when the price is three so once again for buying we are comparing the maximum profit so minus1 versus uh what if we rested so resting is 0 so 0 - 3 is going to be - 3 so -1 and -3 we are comparing so -1 is the maximum profit so we'll just Mark minus one so far okay now for selling if we decide to sell when the prices are three we are comparing two values first value we are comparing is the previous day's profit so that is one and second value we are comparing is the previous day so this is minus one so -1 + 3 so that is going to be + 2 so once again and by the way this it would not be this minus one but this minus one I just uh did not includeed that but you I hope it you understood what I mean so this profit is going to be two that if we decide to sell or sell today maximum profit would be two which would be great and for the resting over here we will have to compare the previous day's resting value versus selling value so this is one because we are comparing these two values basically once again when the prices are zero what is the maximum profit we can make so pre now the values we are comparing is going to be minus one with what if we decide to rest yesterday so if we rested yesterday then we would have made uh so it would be 1 minus the current days price 0 so 1 minus 0 is going to be one so we are comparing values minus one and 1 so over here obviously the judgment is quite obvious that it would it would be in our favor to buy today so we'll just Mark as value number one same way if we decide to sell today uh what is going to be the maximum values we are comparing number one value is previous day's profit so we'll mark two and second value we are comparing is that what if we bought yesterday so that is going to be minus1 plus the prices of today so -1 plus 0 is going to be minus1 so answer is quite obvious that we are just going to leave do as it is this is the maximum profit we can achieve if we decide to sell uh today and the for the resting phase if we decide to rest we are comparing these two values so maximum profit we can make is going to be two now for the very last day the value is one so if the value is one we are comparing these two values so first value is one and second value we are comparing is 2 Min - 1 so both values are one so we can make maximum profit as one so we'll just leave one as it is uh next value is for in terms of selling what is the maximum profit we can make so one option we have is two because that this is what we have second option is that the buying profit from the previous day so this is going to be value One Plus the price of the stock today so okay and this should this value should not have been one this should have been two so let me just mark it clear okay so 1 + 2 so 1 + 2 is going to be 3 so we are comparing values 2 and three so it would be in our favor to sell today if we bought yesterday so now the answer is going to be three this is the maximum profit we can make and for the very last element if we decide to rest today which means we must have sold our all of our stocks yesterday so we are comparing these two values and the values are are two and two so this is going to be two now this is what our table looks like basically where we can see that in the end we simply need to check that what is the maximum profit we are making if we are selling on the last day or if we are resting on the last day because if we buy on the last day we are always going to lose money so whatever value is higher amongst these two value has to be our profit and in this case our profit is going to be three so this is what we can return as it is so this is the whole solution I know it looks messy but it's beautiful in my opinion because we are imagine what we are doing for every single day we are maintaining three different states we are calculating that what is the maximum profit we are achieving on each day and we are taking into the consideration of the previous task being done for any particular day solution so that is in itself pretty awesome that we are able to do it and dynamic programming is actually giving up a huge contribution in this program so if we see time complexity now then it is going to be bigo of n because we are simply iterating over the given input array once to solve the whole thing if we see space complexity well this is going to be big go of 3 * n because we are initializing three new arrays to store all of these states so this is a beautiful time and space complexity and also an excellent question in my opinion so I hope the explanation made made sense now let's see the coding solution now the coding solution for this problem is quite straight forward first of all we are checking that if the given prices is equal to null or the given length of the price array is less than or equal to one then we can simply return zero if that is not the case we have a variable n that is defined to calculate the length of the given prices array based on that we are going to initiate three different arrays to check out the state of the profit on every single possible outcome so uh first one is for buy second one is for sell and third one is for rest uh now we are going to initialize all of these three areas for the very first position now for sell and rest the value is going to be zero because it's quite straightforward we cannot sell on the first day and if there is no s sell happening the day before uh then we should not be resting or this should not be a cool down day uh but for buying because if we decide to go and buy on the very first day then definitely we are going to be at a loss so the maximum profit would be the negative price of the price of that stock and on that particular day now we are simply going to run a for Loop to iterate over the given input array we are starting iterating from the very first day and now we have our conditions set up for buy sell and rest in order to make the Judgment call that what is going to be the maximum profit if we decide to buy a stock on any particular day then we will have to compare that what was the maximum Prof profit if we bought the stock the day before and we need to compare it with let's say that if we decide to rest the day before minus the current prices on this particular day same way the maximum profit for sell is going to be calculated where we are comparing the profit from the previous day by selling or by buying whatever we bought on the day before plus the current prices of this day so we'll compare these two values whichever is higher we are going to keep it keep that as the profit and in order to make the Judgment that whether we should rest or not today uh we will compare the maximum profit achievable on any particular e day and for that we are comparing that what if we decide to what was the profit we made if we rested the day before comparing with what what was the profit we made if we decided to sell the day before whichever is higher we are going to keep keep it as it is now for the maximum profit we simply need to compare that what was the value if we decide to sell on the very last day or if we decide to rest on the very last day whichever one value is higher we are going to return that as the answer so this is the whole solution now let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs beautifully it beats almost 80% of all the other users which is pretty significant and once again the solution of this code is present in our GitHub repository so feel free to go ahead and check it out from there thank [Music] you so the lead code problem we are going to solve now is called coin change 2 this is the additional version of the original coin change problem now we can see that this one is a medium problem and also very well- like problem the statement is quite straightforward that we are given an integer array called coins that represents the coins of different denominations and we are also given an integer amount called amount so that represents the total number of money that we are trying to make now we need to return the number of combinations that make up to that amount and if we cannot make any particular such combination then we need to return zero now let's try to understand this with an example uh suppose uh we are given an input where the Val the coins we are given are currently 1 12 and5 and we are given the amount to be a value number five now the ask of this problem is to see that using these coins how many different ways we can generate the total amount to be five so let's start marking each of the ways well one way is quite straightforward if we use all five one coins then we can actually make up to the value number five second way is if we use coin number two plus we use three one coins so this is also a good way and we can generate value number five same way we can use two coins of two and then we can use one coin of one and the lastly is that we don't use one or two coin and we simply use coin number five and that also gives us value number five so in total there are four distinct ways for us to generate value number five so in this case we will return return four as the answer first and most common approach that comes to our mind is a Brute Force solution where we are given uh coins and we are trying to find different ways to make any particular amount so let's say that in this case uh the amount is five what is the most common thing that we can do to solve this problem that is that we will take every single coin and try to make every single possibilities so one possibility is we will take this coin number one five times to generate amount number five then one possibility is that we will take this coin number one four times and then we will add this coin then we will take this one coin three times and then we we will add this coin one same way we will keep on repeating this again and again and again for every single possible combination and you can see that in eventually we would receive the correct result of four but this Brute four Brute Force approach is going to get out of hand really quickly because now we are dealing with exponential time complexity and we are working in the like Realm of factorial and exponential time and space complexity so this is a very bad approach now in order to generate the optimal solution we are going to use the most beautiful Concept in the computer science and that is called dynamic programming now first let's understand that what is the core logic to finding solution for any particular coin in this problem let's say that currently we are only given the coin of size two and we wants to find out that how many distinct ways we can generate amount number eight well for sure your in your mind you would must be saying that there is only one distinct way to generate amount number eight but let me take a different approach let's try to see that if starting from one how many different ways we can generate each of these amounts and we will try to make some important assumptions based on the findings that we are going to make so let's say that currently we have all of these values now we know that currently if we only have the coin number two we cannot generate amount number one so let's say that currently we cannot generate amount number one so we can mark this as zero also no remember one thing that we are at the beginning of our in uh input so we don't have any way to generate each of these amounts so initially I'm going to initialize all of these values with zeros now I know for a fact that if I have coin number two I can always make value number two so I can simply mark this value as one so let me just mark this as one now I also know for a fact that I can also generate amount number four using coin number two so let me also Mark this value as one as well and now let's do a recap why was I able to mark this value as one because one logic is that I can do 2 + 2 but other logic is that if I already know I need to do 2 + 2 why am I bothering to doing all of these computation when I already know that how many distinct ways I can generate amount number two because whatever the number of distinct ways I can generate amount number two I just need to add the total number of distinct ways for the amount number four that I'm currently doing I know it's sounds confusing but let me give you an example let's say that currently in order to generate amount number six I only have zero distinct way to do it but now I know that currently I'm dealing with coin that is of value two I also know that the current amount I am trying to make is amount number six so I can simply check that if I do 6 Min - 2 so in this case the value is going to be four I simply need to check that whatever the distinct ways I can make value number four I just need to add add it to the current amount number of distinct ways I can generate value number six and that is going to be the number of distinct ways I should be able to generate value number uh six so in this case this value is going to be one same way currently I can not generate value number eight but I know I have a coin of size two so instead of doing all of these computation like this I can simply check that 8 minus the value of amount of coin is going to be six I can generate six one distinct way I can generate 8 zero distinct ways so why not just do 6 + 8 like what the sum of these two values and whatever the value is that is going to be the new value for 8 and this becomes our dynamic programming solution to solving this problem and we are going to do this for every single coin because in our initial example we only had one coin of value number two but now we are going to have a coin of two and one and five if we have scenarios like this how would this operate so this is the core logic we are basing our solution based on now let's make some considerations for the optimal solution number one we are going to be using a dynamic programming array to store the result from the starting value of zero all the way up to the current amount that we are given now the first question is what is going to be our base case and that is quite straightforward that if we have to generate amount zero we know for a fact that there are zero distinct ways to generate am or sorry there there is one distinct way to generate amount number zero so we can mark this as one next thing is that in order to generate any particular dynamic programming of I value the answer is that we are simply going to check that what is the current distinct way to generate any particular I plus we are going to be doing DP of I minus the current coin that we are iterating over and that is also we are going to be adding into the number of distinct ways using this one solution we should be able to find the result of this problem and all the different possible ways to generate the answer so let's take it with one example and it would make things more clear so let's say the given coins are 1 2 and 5 and the currently amount we are trying to make is five so now we are going to initialize our dynamic programming array and now we also have base case that there is one distinct way to generate amount number zero now we are dealing with coin number one so for coin number one we are going to be using the same logic and U we will start iterating for Value number one because whatever the coin size is we will start iterating from there so now currently all of these values are zero because there are zero distinct ways to generate value number one what is going to be the equation of dynamic programming of one in this case using this logic this is going to be dynamic programming of one so currently this is 0 plus dynamic programming of 1 minus the current coin value that is one so dynamic programming of zero so this is this value is one so remember from over here so we can just take it from here and this value becomes one so we will mark this initial value as 1 now same way we are going to be repeating the same operation for DP of 2 so DP of 2 is going to be DP of 2 plus DP of 1 so this value is also going to be 1 and same way subsequently all of these values are going to be one for our coin number one so let's just Mark all of these values as one now again now we are dealing with another equation and another coin next coin in our category is coin number two so let's say that we are dealing with coin number two so for coin number two we will start itating from coin number like amount number two because it does not make sense to iterate from amount number one what is going to be equation for DP of two in this case this is going to be DP of two so current distinct ways to generate amount number two plus DP of 2 minus the amount the current coin value that is 2 - 2 so that this is going to be zero so this value is already one because we already have one distinct way to generate amount number two plus we will also check it over here so now we have one so notice now we have two distinct ways to generate value number two and we have we are we are dealing with coins one and two possibilities so in this case this value is going to become two same way uh we are going to be this this 3 is going to remain as it is because 3 minus remember 3 - 1 is going to be 1 uh 3 - 2 is going to be one but thing is this value is also one and this value is also one so this is also now going to become two because now there are two distinct ways to generate amount number three for Value number four this is we are going to be doing sum of these two values so now once again four is going to become three because there are now there are three distinct ways to generate amount number four and same way for Value number five now we are going to be doing the sum of 5 + 3 so this total is going to be uh 1 + 2 so then now there are three distinct ways to generate amount number five as well now we are bringing in the value number five into the equation now for the value number five would not impact all of these results up until this point because we cannot add five for anything but we can add five for this value so for what is going to be the equation for DP of 5 this is going to be current DP of 5 plus d P of 5 minus the value of current coin so current coin value is 5 so 5 - 5 is going to be zero so this is going to be there are three distinct ways that we take took from here plus there is going to be uh one distinct way that we can make amount number five and that is going to be over here so the answer is going to be four so in this case we can just mark this value as four and this is going to be the whole solution now see how beautiful this solution is and all we have to do is just come up with this equation and try to understand that how generating a new value based on the previous value using the current coin size can make all the difference and uh this is the whole solution basically so U now let's move on now let's understand the time and space complexity first time complexity is going to be bigo of n square and uh not n square bigo of n so where n is the given number of coins multiplied by the amount that we are trying to calculate so overall we we can consider it as n Square because it's like multiplication of two different variables but one variable is the number of coins and the other variable is the amount that we are trying to generate and in terms of space complexity it is going to be big of n because we are using an additional array to store all the results now let's move on to the coding solution so for the coding the idea is quite straightforward first we are going to initialize our dynamic programming array to the value of amount + one because we need to encounter for the value zero now we will set up the base case for our dynamic programming where if you have to create amount zero there is exactly one way to make amount Zer using no coins and then we will keep on updating our dynamic programming array for every single coin logic is quite straightforward first we will take in the current coin that we are iterating over then we are going to start iterating from I from uh the value of coin to the value of amount and for every single value for that particular particular instance of J we are going to add it based on J minus coin so whatever the current value is we will add it with the J minus one location and in the end uh we should only return the amount that we are we are being asked to return so whatever value we find for the dynamic programming amount we we can simply return that so such a small coding solution but such a beautiful approach using C dynamic programming now let's try to run this code okay seems like our solution is working as expected let's submit this code and our code beats 100% of all the other Solutions which is which means this is the most optimal solution that we have provided and also this is one of the most efficient in terms of space complexity as well so once again this coding solution for this problem is available on our GitHub repository feel free to go ahead and check it out from there thank you [Music] so the lead code problem we are going to solve now is called Target sum and we can see that this one is a lead code medium problem and also an extremely well-like problem on lead code we are basically given an integer are called nums and we are also given an additional integer called Target now we need to build an expression out of these given numbers such that by adding one of the plus and minus syllables before each of the integer in numbers and concatenating this expression to basically create this target value uh so here is an example let's say that if we are given values two and one then we can add plus before this two and we can add minus before this one and combine them to build an expression such that minus 2 + 1 which is going to result in the value one so now we can basically create bunch of different expressions like this using plus and minus sign now we need to return the different Expressions that we can build inside the given nums array that where the total sum becomes the Target and we need to return every single possible combination that can have such values so let's say if we are given an example like this where we are given nums array that contains five elements and all the values are one and we are also given a Target value that sums up to three now in this case we can use plus and minus symbol to create bunch of different Expressions that I have noted down over here and we can see that all of these are unique operations that all sums up to Value number three and in total we can Define that there are exactly five different ways for us to generate value number three U from using this given nums array and using plus and minus equation and in the end we need to written five as the answer in this case now first let let's try to understand the very preliminary Brute Force approach the logic is quite straightforward that for any particular given number of uh input all we need to do is just test out every single possible uh plus and minus symbols and make the subset sum of every single possible permutations and combinations let's say in this case we are given Target to be three and we are given these four values so what we'll do is first we will use all the plus values and we will try to see that if we are able to read Target if not then we will try to go reverse and we will try to add one minus over here and then leave all of the values are plus then we will make these two as minus then we will make these three as minus then we will make all four as minus and so on and so forth we will keep on checking bunch of different permutations and combinations whenever we hit Target value we will Mark that as an correct answer and in the end we simply need to return that variable the solution works it gives the answer but it is extremely inefficient and you can understand why because we are testing every single potential permutation combinations and majority of time we are going to be not targeting value number three we will have some other answer so we are not focused on that so we'll have to do things smartly so before we come to the optimal approach we will let's make few things or few mathematical equations correctly let's say that we are currently given bunch of different values inside our nums array right now we know that all of these values they can have some uh any particular meaning but thing is we can add all of these values and we can Mark these values so sum of all the values inside a variable called sum so let sum be the sum of A + B + C now we are also given for a fact that we need to create partition amongst these a b and c in such a manner that there are now there are two partitions first partition is S1 and second partition is S2 and the difference of these two partition becomes the target value so this is one equation we can make second equation is sum of S1 plus sum of S2 is actually going to be this sum value as well so now we have two mathematical quadratic equations for two different variables and we know the value of Target we know the value of sum so it it should make sense for us to get the quanti iable value for S1 and S2 and let's combine them so if we do combination of these two plus this two we can create a new equation where the values are we did nothing special we just did some of these two values okay now in this scenario this S2 and S2 are going to cancel out each other so we can see that 2 of S1 is going to be Target plus sum so we know that we need to find a partition such that the value S1 exist and the value of s S1 is going to be simple that is going to be Target plus sum ided 2 and we have the value of S1 now if we can identify S1 then we should be able to identify S2 so S2 would be basically all the remaining values and we will just add minus sign before them now the thing is lucky for us we are not being asked to calculate that what are all the uh different Expressions we simply need to provide the number of different Expressions so for that that we actually don't need to calculate every single possible pairs we simply need to know that what are different ways we can generate S1 and this would be true for S2 as well and then we can simply return that as the answer okay so now we have established all of these things now let's try to also consider some edge cases and some scenarios that for sure we can say that they are never going to make anything so let's say that if we identify that sum of all the values are less than zero in this case it would be impossible for us to generate the target value so in this case we can simply return zero as the answer same way if we identify that the value of S1 is not modul by 2 it's not possible to modul by two then also we can return zero uh next thing is that in any scenario we identify that S1 value becomes neg is a negative value then also we cannot find subsequent S2 value because in front of S2 we are putting all the negative values so we can return zero as well these are going to be our edge cases so we can get rid of them now let's come to the meat of the solution uh the aim is that we are currently given a nums array that contains bunch of different values let's say A1 B1 C1 all of these are some integer values now we need to create the combination amongst these values such that the sum of them so A + B could become S1 or a plus C could become S1 so on and so forth we are not focused on adding plus or minus and all of these things we are only focused on finding a subset sum amongst the given values that sums up to that value and this is the critical moment of the entire problem to understand that why are we trying to find this one okay now we know what we need let's see how we can achieve this and how is actually going to be solved by the most beautiful Concept in the Entire Computer Science and that is called dynamic programming now why dynamic programming is a good candidate in this case well reason is quite straightforward let's say that we are currently only given just one value one and we are given some arbitary Target value so in that case we can simply say that whether this makes the Target or not does not make the target let's say the target is also one then we can say that there is exactly one way to generate Target we can clearly see but if we are given values 1 1 and one now in this case the number of ways we can generate Target actually increases with the increment of every single value let's say next value is two let's say next value is four so so on and so forth whenever new values gets added to the equation the way for us to generate that particular Target becomes in increasingly uh more on top of it our S1 also changes so what I'm suggesting is that instead of focusing that how many different ways we can generate S1 why don't we just generate the entire sequence that's starting from zero all the way up to S1 that how many different ways we are able to generate that particular element and that we can calculate very easily using every single numbers that we are given and we are going to keep into the consideration that how many different ways we were able to generate some previous element and based on that we would add that value to our s so that's why this is a good candidate for dynamic programming on top of it let's see that how does dynamic programming is actually going to work so we explain that we are going to create a dynamic programming array we also know that how how can we generate our S1 basically the formula for S1 is the target plus total sum divided by 2 and we simply need to generate this value now for our dynamic programming we are going to have an array that starts from zero and goes all the way up to our S1 now what is going to be the value of DP of0 no now notice that this zero indicates that how many different ways can we generate value zero and in this case we know that ex there is exactly one way we can generate value zero and that is by not using any values inside our subset sum problem so that is one way and this is going to be our base case that we can use as uh uh as like a stopping point now let's say for an example I'm giving scenario let's say that the given number only contains value three and the tar Target we are given let's say that this target is also three right now we know for a fact that if this number is three then we can make two numbers plus three and we can also make minus 3 because we can use uh two signs plus and minus so in that case if this number is three does it make sense for us to check that how many different ways we can generate value 1 and two no of course not we cannot generate value one or two using this value three we can only generate value three and above values so we are always going to be considering this value three so what is going to be our dynamic programming equation well dynamic programming equation is quite straightforward let's say that if we are trying to find that what is going to be the dynamic programming of three because current the given number is three then this is going to be that how many number of different ways we are able to generate three plus the total number of difference between dynamic programming of three minus the current num value so current three that we have so basically 3 minus num and this would be the formula that we are going to be using in order to populate our dynamic programming array let me explain the solution once again that at any given moment dynamic programming of I number is going to be depending on dynamic programming of f which already says that these are the different ways you can generate value number I plus DP of I minus the current numb value that we are iterating over because remember if we can generate three we can also generate six like if we are given one more three so on and so forth so if we are at six location and we know that there are two different ways we are able to generate three then there is going to be three different ways we we can generate six basically that's the way how it works let's say assuming that original value of six was one now coming back to our problem let's try to populate our DP array for the given case let's say that current given values are 1 1 1 1 and 1 so in this case all of these values are uh one and the target value we are currently given is going to be three now for this scenario we are going to be using our equation that DP of I is going to be DP of I plus DP of I minus num's value and uh we need to calculate our S1 so S1 is going to be Target plus sum so in this case Target is three and the sum is going to be five so let me just Mark sum is equal to 5 so S1 is going to be 5 + 3 8 / 2 so S1 is going to be 4 so we are going to initialize our dynamic programming array that is going to be extending from value zero all the way up to four so let's just mark this value okay now let's uh start making our base case so dynamic programming of value zero is one so that is obvious uh we can't do anything about it now let's start populating all of these values one by one now the current value we are dealing with is value number one now notice that we are actually going to start traversing in the reverse order not in this order and why are we going in the reverse order is to make sure that whenever we calculate the results or the number of subset sum we calculate that only once not two times because let's say that if in this case currently all of these values are 0 0 0 0 now if I apply this equation and if I start with this one so position one we are going to be starting with then this value becomes one this value becomes now this value would become two why because we are doing the sum of this value with this value and so on and so forth so the value would keep on increasing and we would count the same value multiple times so that's why we will start counting in the reverse and we will come up until this particular number value that we have so let's start with value number four currently the value of value number four is zero and currently uh so this value is going to be zero and DP of I minus none so 4 - 1 is going to be three this is also zero so we we don't we are not bothered to check or update this value number four because there are no ways we can generate value number four using just one one now next once again we are at DP of 3 so for that and we are considering this very first one so far now once again uh equation is going to be 0 plus DP of 3 minus DP of 2 so 0 plus this so This value is also going to be zero so this will remain zero same way DP of 2 will also remain 0 because this is 0 + 0 but for DP of 1 DP of 1 is zero but DP of 1 minus num is going to be 1 so this value becomes one at the end of this equation and notice that what we have done so far is nothing but just saying that if we are only given an input array that is that contains value one then we can only generate value or Target some to be one one time that's it now we are considering our scope and we are including the second one into the equation let's repeat the same operation so DP of 4 is still going to remain zero and same way DP of 3 is also going to remain zero because of the this equation but for DP of 2 now this value would become uh one as well why because now we have two one way to generate value number two that is by using 1 + 1 and for DP of 1 this value will become two why because remember that we are following this equation so this is going to become 1 plus DP of I minus num is also going to be zero and that value is also one so this value would become two okay after this now we are considering this third one so once again the value of DP of 4 is going to remain zero so let's just leave it as it is but for this DP of 3 this value is going to become one so let's just mark this one as one now DP of 2 is going to become Uh current value of 1 + 2 so this value is going to become three so let's just mark this as three and this value is going to become 2 + 1 so this is also going to become uh three so let's just Mark three as well now we are considering this one so for this particular one now once again we are starting from position number 4 and this value is actually going to become one because the previous value is 1 now this value is going to become 1 + 3 so because previous value is four so let's just mark this one this value is going to become six so let's just mark this one and this value is going to become four so let's just mark this one as well okay cool now we are at the final one so for the final one we are going to be doing the sum of these two values so this value would become five which means we are saying that if we we have to generate four using these values then we have five different ways to generate four same way this value is going to become 10 so let's just mark this as 10 and let's just mark this uh as 10 as well and uh in this case one would become five and this one is going to remain one as it is and now we have reached to the end of all the nums so basically we are simply going to return this value as it is this is the whole solution now look how beautiful this looks basically this dynamic programming array tells us that if we are given the input numbers as 1 1 1 1 1 then if we are given the target value to be four then we can generate it in five different ways if we are given Target Val or S1 value not Target value F S1 value to be three then we can generate it 10 different way and so on and so forth so we are calculating for all the possibilities and uh I hope my solution made sense now let's understand the time and space complexity time complexity is going to simply big of n multiplied by big total number of S1 because we will have to do all every single iteration this time for all the values that are currently present inside our given input nums in terms of space complexity because we are using an additional array it is going to be biger of n but that is a a reasonable and acceptable solution it's not that bad and it's actually pretty good because we are using memorization to solve this problem so now let's see the coding solution for this one so first we are going to create a variable called sum and then we are going to iterate over the given nums array to include the total sum of all the elements and that we are going to populate inside our sum variable now we are checking that if it is possible to make partition which means we are checking few edge cases and scenarios that is the first one is that if the sum of Target plus sum becomes an odd number then we can simply return zero if that is not the case then if the sum is actually uh total sum is actually less than the absolute value of Target in that case we can also return zero as well if that is not the case we are going to Define our S1 that is defined by Target plus sum divided by two based on the explanation we had during our solution now we are checking that if the S1 is less than zero then also we can return zero uh this is to make sure that we are preting negative array size if that is not the case then we are going to initialize our dynamic programming array where we are uh initializing it with s + 1 + one value and we are going to have our uh initial base case for our DP array where DP of 0 is one because there is exactly one way to sum up to Zero by using no elements then we are going to iterate over every single nums that is currently present inside our nums array and for each of the number we are actually starting from S1 and we are coming down all the way up to nums and we are reducing proding one value so there is a loop inside the loop where we are simply following the the equation where the value of dynamic programming of J is going to be the sum of dynamic programming of J plus J minus num and we are coming in reverse order in the second Loop is to make sure that we are not counting the same element twice if we go from num to S1 then there is a very high likelihood that we are going to keep on Counting the same element multiple times and that would give us all kinds of weird results so in the end we simply need to return DP of S1 and uh this should give us the total number of distinct ways we can sum up to that particular Target element now let's try to run this code okay seems like our solution is working as expected let's submit this code and our code beats almost 99.78% of all the other Solutions which is our solution is one of the most popular Solution on the entire lead code which is pretty awesome and we are also extremely efficient in terms of space complexity as well so once again the the solution for this code is present in our GitHub repository feel free to go ahead and check it out from there thank you [Music] the lead code problem we are going to solve now is called interleaving string now this one is a lead code medium problem a very well-like problem the thing is this problem statement is extremely complicated to understand we are given string S1 S2 and S3 now we need to check that whether string S3 is formed by interleaving strings S1 and S2 if you want you can go ahead and read this all of this description if not let me give you a quick simple example we can notice that currently the entire S3 can be created using the characters in the same sequence that they are present in S1 and S2 so let's take it start one by one we have this character a so we can take a from S1 so we use this one same way we use a so we can we also use this one now we have a d So currently this character is B and this is D so once again we can use this one same way okay now we have B B and C so we can use B you can use B and we can use C so same way we use all of these characters and then once again we have characters B and C and same way we have character a so we can take a from here and then once again we have one more C and then we can take C from here and this ends all the characters inside S1 and S2 and all the characters inside the S3 we can say that we can inter leave string S3 from the given string S1 and S2 this is what we need to prove for any given input if we are able to do that awesome we need to return true if we cannot do that we need to return false well the most basic root Force approach comes to our mind is to check for every single permutation and combination of S1 and S2 to see that how can we form uh the all the characters in such a way that we are able to generate S3 so let's say that we are check for the first uh character a then we need to either choose the first character over here or first character over here we cannot choose both so lucky for us we can choose a over here so we get rid of this character now we are at second character on B and we are at still at first character at B now the thing is next character we are trying to find is B let's say that by sheer chance we decided to choose this B character if we choose this B character immediately the very next element is X thing is we check okay this one is B and this one is C so X does not match B or C so we can see that because this does not match either one we can simply return false saying that we cannot interl string but thing is this would be a wrong assumption because we did not consider the scenario where instead of picking this B we could have picked this B and then we would would be still in a position where we are comparing the values between this B and this X and then this x would have make perfect clear sense so in the simplest term we are actually making a decision tree where the very first character option choices we have is amongst A and B which is the very first these two characters and for that we have in the S3 we have a character a that we compared so now we get rid of this one now in the next choice we have the character B and then once again B and in the S3 once again the character we have is B the thing is we don't know which B are we going to choose from so we can choose from B uh that is located over here and then we would have the choices c and b or we could have chosen this B and then once again the choice choices we would have is going to be B and X so depending on that we can have many different decision trees and now you will start to notice the problem that could arise because at every given moment we have the option to select something from between two different task or two different paths and that is the time complexity of 2 to the^ n which is extremely bad time complexity and that's why solving this problem in brute force would yield the correct result but this is not going to be a good approach we are trying to deal a scenario such that any particular result that we are currently calculating is actually going to have an impact on the previously calculated results and depending on that we will have to make further decisions that which path are we going to take and this is this is why this becomes a perfect candidate for the most beautiful Concept in the computer science that is called dynamic programming because number one we will have to keep track that what was the previously calculated result number two what is the current result and number three store these values in such a format or such a fashion where we can access them immediately and we can make judgment calls based on that so let me now let's start understanding with very small examples let's say S1 is an empty string S2 is an empty string and S3 is an empty string once again yes from using this example we can create string S1 from S2 and S3 this is always going to be true let's take one more complicated example let's say the values are going to be a b and this value is going to be C and currently for S3 we are comparing the values a c and b we know we can make this one but how it is going to work the idea is first we are going to compare the very first element uh compared to S1 and S2 and the value S3 and for that let me just make a very small table okay this is going to say that if I am at 0 and zth position then even for the S3 I'm going to check for the zeroth value if I'm at first and zero position then for the S3 I'm going to check for the first value if I at second and zeroth position then 2 plus 0 so I'm going to check for the second value inside the S3 and so on and so forth uh we will keep on repeating and compare the values so let's compare we know if we are at zero position and zero position in S1 and S2 and the cell inside the S3 is also zero So currently we are starting at one zero means that S1 is empty S2 is empty and 3 is empty in that case this is always going to be true because we can always inter leave string S3 from S1 and S2 if both characters are zero okay that's a given fact now let's take this scenario currently we are at position a and so let's say that if we are only given S1 is equal to a we are only given S2 is equal to nothing because we are marking it as s z and zero we don't have any value for S2 and for S3 we currently have uh we are only comparing the 1 + 0 so we are only comparing the first value inside the S1 So currently S3 also contains just a one value so if this is the case are we able to interl string S3 from S1 and S2 yes we can interl string S3 we can just use this thing this string so because these two values are same we can say that this is going to be true now let's add one more scenario let's let's add this two over here so if we have if we we are given a string such that a b S2 is still empty because we are comparing against this cell and for S3 because this has two two characters we are going to mark two characters um so this is going to be a and C now in this case are we able to inter leave string S3 as AC if the given string S1 is AB and S2 is Mt no because B and C does not match so in this case we can mark because they do not match we will mark this result as false okay if that is now let's come back now we are at this position so we are com checking for this particular cell so what is the position of this cell currently this one is empty so the value inside the S1 is going to be empty and the value inside the S2 is only going to be C and uh we are comparing the S3 to be uh so let's do the sum of these character these characters because this is zero and this is one so we are only comparing one value from the S3 and that is going to be a so if we are given three strings S1 S2 and S3 like this are we able to inter leave no because this one is a and this one is C so they do not match so we are going to Mark false over here now once again let's repeat the same operation now we are checking in for this particular cell so what are going to be the configurations for the cells S1 S2 and S3 well uh S2 is going to contain character C S1 is going to contain character a and for the combination of this one so this is one and this is one so 1 + 1 is two so we are going to consider two characters from S3 and that is going to be AC in this case we know we can we are able to generate this pair completely so we know for sure that this needs to be true but thing is how are we able to say for certainty that these pair matches well because notice in this particular position we have the value this value as a this value as C and the combination of these two values becomes a c let's see that what is matching with what we we can see that very first value a we already have a match because of this particular value and currently we have a match with C that is coming in so whenever we have any value on like this is going to be y AIS um so whenever we have any match on let's say that this is going to be our I throw and this is going to be our J throw if we have a match on J throw because C is matching with this currency so if we have a match on J throw we will have to compare that are we able to generate a and C in order to make sure that if this C is valid or not if you get confused just look at this example and it would make sense because we we can this character C is only good if we already have a previously matching character if we did not have a previously matching character let's say over here instead of this S3 being a b c if we had values x c b then this would have been x c so even if these two characters match because we are at this particular cell still this should not have been true why because this character did not match and if this character did not match this value would have been false so in this case because this value was was true so using that because this value was not X and this value was actually a then only we can say that the there is any fruitfulness in this C currently matching with the subsequent value inside S3 so the result of this character is actually dependent on its previous uh character because the string was from S2 so whenever any particular cell from S2 we are trying to compare we are going to check it with the previous element on top of it so in this case we can mark this one as true as well because this character was true same way now we are at this position where if we notice this is going to be a b c and since the sum is going to be 2 + 1 so 2 + 1 is 3 so we are going to compare all of these three characters so this is going to be a CB as well now notice that the matching pair the matching pair in this case is actually going to be this B so we are matching with the character from S1 if we are matching for this particular cell for a character from S1 then we need to check that whether the very previous value for all the other remaining S1 characters are we facing the value to be true and in this case because remember same way for this character we check that whether this previous element was true or not and because this element was true then only we can say for certainty that this has to be true as well but in this case now the matching pair is from this region the top region then we will have to check that whether the for this cell whether its previous element on the left for S2 was true or not why because let's say once again repeating the same example let's say that if this S3 instead of being AC CB if this value was once again let's say x cb or x uh YB something like this one then even if this B matches the previous values did not match so this value must have been false so then we would have to mark this false but since this was not false and we found out a correct match so we can also Mark this as true now we iterated every single possibility inside this cell and uh same way we simply need to return whatever the value we have at the very last element inside this character and then we can return return true it as true or false now let's take one more quick example to understand that how how does this thing is going to work completely so for this example we know that this is this value is always going to be true so let's just mark this as true now we are going to iterate over the First Column okay so we will compare the S only S1 values with S3 values so for this first value we have a a matching so because and because it's S1 we are comparing it with previous value So currently this matches so we can also Mark this a as true same way next value is B once again B ab and ab are still matching so and the previous value is true uh so we can also Mark this one as true next value is X and this value is C because of this they do not match so we we are going to mark this as fall we don't need don't need to check any other value next value is once again B and this value is D so once again they do not match so we can simply return false and even if we they did match we would still mark them as false because the previous value was false same way we are going to check the column value where we are only comparing this S2 with this given S3 So currently the very first value should have been a but over here the value is B so we can mark this as false uh same way now this value is is B but this value is X so once again we can mark this as false and same way this value is y but this value is X so once again we can mark this one as X now we are at position 1 and one so because values are 1 and one we are comparing the value number two so value number two is going to be B so we can see that yes there is a potential match B over here now notice Whenever there is a match on this side we will need to compare for this cell it's above cell cell above it so since this value was true we are going to mark this value as true as well now we are comparing once again uh this particular cell so for this cell the value should be 2 + 1 so we will need to compare the third value so third value is X over here and over here both values are B and B so this value needs to be false same way uh next we are going to compare 3 + 1 fourth value so fourth value is B so we notice that over here we do find a potential match B with this B fourth value that we are trying to compare but thing is once again same way yes we have a potential match over here but the value Above This was false so because of that we are also going to mark this one as false and same way now we have this value C over here uh and we have this value comparing between D and B so it does not match so we are going to return false over here same way now once again we are comparing this particular cell so now the value is 2 + 1 so 3 so third value is X yes because third value is X we can notice that uh this is this x matches it matches with the value on once again J axis so we will have we have to compare the value above it this value is true so because of that this is also going to be true then we are going to compare this B and x with this B so once again this value is B that is correct now this B matches with the value over here in this case because it matches with the value on the I AIS V for this particular cell instead of covering the value above it we are going to check for the value right before it and this is true so that's why this is also going to be true next we are going to compare the values between c and x and we this value is 3 + 2 5 so fifth value is going to be the C so once again the C is true so if this because it matches with uh over here with the I I value so we are going to compare the value before this one uh that is true so we are going to mark this one as true as well same way the next value we are comparing is going to be D and x and over here the value is also D so we are also going to mark this one as true because it matched over here now we are at once again this position the value is y so the value is 3 + 1 so 3 + 1 4 4 is not y so we can y or 4 is not a so we can simply return false over here same way this value we are comparing is going to be uh B with Y so uh and this is going to be 2 + 3 5 so fifth value is actually C over here so we can return false over here same way the now this is going to be 3 + 3 so sixth value is D and over here the values we are comparing are going to be Y and C so once again it does not match so we can return false and the very next value is y and because uh this is the 7th value and we are comparing 4 + 3 7th value over here so we have a potential match y the moment we see a potential match y on this J axis then we will have to compare the value above and the value above is T So this value is also going to be true and in the end we need to return whatever the value we found for the very last element since this was true we are going to return true and this is the whole solution see how beautiful the solution is because for every single possible pair we keep on checking that whether we can inter leave string S3 with given subsequent string S1 and S2 so this is pretty awesome and uh the time complexity in this case is going to be bigo of M multiplied n where m is the length of S1 and N is n is the length of S2 space complexity is also going to be biger of M multiplied by n and it is quite obvious because we are using a dynamic programming uh 2D array to store this answer so now let's quickly see the coding solution the coding solution is quite straightforward first we are going to Define three different variables m n and L to Define respective length of S1 S2 and S3 strings we will check for an edge case that if the given uh string length m + n is not equal to l we can return false immediately if that is not the case we will initialize our dynamic programming array and notice that as part of the length we are keeping it as m+1 and N +1 this is to take care of that extra row and extra colum where we are only considering S1 or S2 string then we are going to have our base case that DP of 0 0 would be true as in we can always create or inter leave a string with zero characters if both S1 and S 2 has Z and S3 also has zero characters if that is not the case then we are going to fill in the first row where uh we are simply going to check the values for the um S1 row and same way we are going to fill in our first column using S2 uh where we are simply comparing the characters S1 and S2 S1 with S3 and S2 with S3 and we are going to pick the previous row value or column value and the place of the current I or J position then we will fill in the rest of the DP table where we are going to use two for Loops starting with I = to 1 and J equal to one and for every single cell we will compare that whether that Cell matches with S1 and S3 or it matches with S2 and S3 if it is if it matches with S1 and S3 then we can simply um Mark the value of the previous row position if it matches with S2 and S3 the character Val value then we will mark it with the previous column position and based on that we will keep on filling our DP table or dynamic programming table in the end we can simply return the value for DP of M and DP of n so if this is true it's great if it is not true then we can simply return false and this is the coding solution let's try to run our code seems like our solution works as expected let's submit this code and our code beats good chunk of other Solutions in terms of time complexity and it is excellent in terms of space complexity we beat nearly 9646 of all the cases which is pretty awesome and once again the coding solution is present in our GitHub repository so feel free to go ahead and check it out from there thank you Hello friends we are still not employed by a Fang company so let's not stop lead coding till we get there so the question we are going to do today is called longest increasing path in a matrix and if we see some of the companies where I want to get a job who have already asked this question there are companies like apple do dash Google Facebook Tik Tok nvdia Amazon Uber Microsoft Snapchat by Dan and bunch of more so I'm going to pay my utmost attention I hope you also find this useful so this is a lead code hard problem and also very well- like problem which is a rare combination to find uh basically we are given an M cross and integer Matrix and we need to return the length of the longest increasing path in this given Matrix now what how do we build this longest increasing path that we need to return the length of uh essentially we are told that from every single cell we can move in four directions left right up or down and based on that we need to calculate that what is going to be the longest increasing path we are also explicitly told that we don't have to care about diagonally moving or values outside the boundary so let's try to understand this with an example suppose in this case this is the example that we are given now our aim is to find the longest increasing path now we know that uh from any single cell how to define an increasing path let's say that we are currently located at the cell number four now we have the option to go in four Direction up down left and right now from this four direction we only need to go to the direction of the cell that is actually increasing order uh so we we are we need to maintain this increasing property so from this value number four what are the places we can go we can go to 9 and we can go to eight we cannot go to six because this would be a diagonal and we cannot go anywhere outside the boundary now in both the cases we have the option that the values are currently in the increasing order for this 8 and N which means both are legitimate scenario but our aim is to find the longest increasing path so from 8 do we have any other option to go to that increases in the path no no from again from 9 do we have any other option to go to in any any next cell that increases again no so in this case from four the longest increasing path we can make is going to be two but this is this the longest inside the given entire Matrix the answer is no we need to find the cell that has the longest increasing path so if we take one more example let's take an example for this value number one again at this location value number one we have the option to go into four Direction but let's say that for the ease of convenience we decide to go into the direction of this one 122 currently the in the increasing path length is one again from this two we have one more neighboring cell that is higher than the value that is this value number six so this time the increasing path value will increase by one and again from the six we we can go to one more neighbor that increases in the value and that is value number one and originally we started with this value number one and we moved one hop so basically we will add one more over here so essentially we can create a path that looks like this uh 1 2 6 and 9 and this would be the longest increasing path in our Matrix and the length of this Matrix is going to be value number four that is what we need to return in the answer and the first approach comes to our mind is the Brute Force approach the very basic approach that we can take to solve this problem now let's try to understand that what would be the Brute Force approach in this manner well of course the answer is quite simple from every single cell we start iterating in all four directions and from all four directions we will see that where we can find the increasing path and the moment we find the increasing path we keep on adding the value to our answer uh variable and uh we will keep on adding one over here and same way for our increasing path we will go to its neighbor and again we will keep on repeating the same process so let's try to see the solution I'm proposing inaction okay okay so let's say that for the ease of convenience we start at Value number one uh or this value number nine again from nine uh what would be the increasing path we were we are able to make and what is the maximum answer we have find so far these are the two variables we are going to keep track of so nine does not have any neighbors that are in in the increasing order because nine is the biggest value amongst all so in this case we won't be able to find anything let's go to this another nine again same thing will happen we won't be able to find anything so these two are uh the the values that we took care of now we are at Value number four since value number four we already calculated that there are only uh two paths we can take So currently the uh increasing path maximum we can make is going to be two so answer currently we have found so far is value number two that this is the maximum path we are able to make but let's keep on increasing with next subsequent values So currently the values we took care of is going to be the first row so I'm just going to mark them as X that we already took care of this now we are at this value number six from six what are the options we have we cannot go here because this is not increasing this is same uh we can go here to 9 so this is good so from six we can again create a path of increasing path of size two and then that's it so again our answer will remain same we also took care of six same for same goes for this six uh this six we have the option to go to Value number nine and we have the option to go to Value number eight but that won't lead to any further the results so again we cannot move any anywhere forward so we also took care of these five variables uh now let's move on to Value number eight again from this value number eight we do not actually have any path to go to so we don't we don't even bother updating any of the variables uh now we are at Value number two and now things will start to get a little bit interesting so what are the options for the increasing path we have at Value number two so first increasing path option is over here so from 2 to 6 that is good again from six do we have the option to go for the increasing path and the answer is yes uh that is 6 to 9 so in this case from this value number two the maximum increasing path we can achieve is going to be value number three so we are going to update our result and so far the longest increasing path we have found so far is going to be value number three so again we are going to result uh we are going to update our answer as well uh now we are at Value number one so what are the options we have so far can we go to this no can we go to this six yes So currently we go to this six from this six what are the options we have we can either go to 9 or we can either go to eight so let's just first go to8 okay now we went to the eight from eight can we go anywhere else no so in this case for this particular path the answer we found is three but we still have one more option that from six we can still go to this N9 so even if we go from 6 to 9 we don't have anywhere else to go so once again the answer is going to be three as well now uh after taking care of both of these path now let's see let's explore more options uh and that option is that from this one we can go to this value number two okay from this two we still have option to go to Value number six from this six we still have option to go to Value number nine so in this case we created a path that is 1 to 2 to 6 and then to 9 so in this case we created a path with a path length of four that is going to be the maximum path we have found so far so we are again going to update our values so this is going to be the current uh increasing path we found for the cell number one and the maximum path we have been able to find is also going to be four so we are going to update our answer because we need to enter the most uh the longest increasing path and now we still have one more value that we need to go to so again from this value number one we have the option to go to 1 to 8 and then from 8 we won't be able to go anywhere else so in this case the maximum path we are able to achieve is going to be two uh after completing or after iterating every single value we found out that the maximum longest increasing path we can create is going to be value number four so our Brute Force approach gave us the appropriate answer that we were looking for but what was it the most optimal answer well the answer you already know that of course not and why because there are a few things we can actually make changes to so first thing we can make change to is going to be regarding uh that for every single cell we were actually doing lot of repeated computation uh and how we are doing that let me give you a quick example so again let's clean this up a bit initially when we were traversing our answer when we reached to this value number six we already knew that from this six there is only one path we can go and that is going to yield us the higher result and that is from 6 to 9 so the longest increasing path or the longest path we can make at Value number six was going to be two now when we came back to this value number one originally from one what we did was we went from 1 to 2 from 2 to 6 and 6 to 9 every single place repeating the computation we did we have already completed and that is a bad approach what if we already knew that at Value number six the longest we can do is going to be two same way this value number two the longest we can make is going to be value number three so from based on this information if we are at Value number one and we need to go back to this value number two we can clearly see that from one we already know that there is an increasing path that leads to two but from two we already know that the maximum amount of value it can generate in terms of longest increasing path is going to be of value number three so rather than doing all of this computation we could have actually just done from one we reach to two and see that we already have the computation result for two so we could have done 1 + 3 and the answer would have been immediately available available to us as the value 4 so this is one of the major significant Improvement we can make and what this Improvement is this is actually we are storing the results that we have already calculated so what we are doing is uh one of my favorite things and one of the most beautiful things that is available in the computer science that is we are actually using dynamic programming in this case uh but on top of using dynamic programming we are also doing something more interesting and that is that we are actually uh rather than treating this as the Matrix or 3x3 Matrix we can actually treat this uh as individual nodes and this individual nodes would have some way of connection with them uh how connection because we are trying to find a path now for this path we are actually given the definition that if only from this current cell let's say the value of current cell is a if there is a path from A to B B where B is greater than a then only we can connect a to B and consider it for our path so rather than treating this as just 2x2 matrix or M cross n Matrix we can actually consider every single cell in this Matrix is equal to node and the path that we are trying to connect actually as the vertices and once we do this uh after seeing these two words immediately in your mind it's going to click that essentially we are treating this as a graph solution uh and we are try in the graph we are trying to find the longest increasing path we already know how to build a path and that is using the greater than or less than uh relation between any two cells so essentially we already have a directed graph and we already know that this is there wouldn't be any Cycles in this graph because uh let's say that how does the cycle occur in a single graph let's say we go from 3 to 5 up uh in the same position three then we can see that there is a cycle but in this case it is not possible to have a cycle why because the relation of this Edge is actually based on the property that three is less than five that's why there is an edge that exist over here if three was not less than five then there won't be any Edge over here so which means from 5 to 3 there is an edge uh there is an impossible way to create an edge so essentially this is also going to be an a cyclic graph and the we already know that this is a director a cyclic graph uh and in the D A or direct a cyclic graph we are trying to find the longest path basically rather than treating it as longest increasing path we are just trying to find the longest path so essentially now our life becomes much easier on top of that we are already going to use the dynamic programming properties so we are going to know that how we are going to take care of every single value so we are not going to repeat the computations that we have already created now let's see that what would be the solution look like in action okay so now what we are going to do is we are actually going to create a dynamic programming uh to M cross n grid uh and in this case we are going to use this to store that every single element how many increasing path we can make maximum amount of increasing path we can make so this would be a great help for in terms of memorization on top of that for every single node we are treating it as a graph and uh we are going to build the graph upon them so we are not actually creating a separate graph we can actually use the same Matrix for the visual representation I'm going to make some uh circles and some arrows but you would be able to imagine that what we are actually trying to do so first let's say that we are at Value number nine so we are at a graph node would like 9 from nine do we have any edges extending out no because this is the same as N9 and this is less than uh 9 so there is no edges which means the longest path we can make at Value number N9 is going to be of value number one okay we are we are good with this result now at this second cell 9 again same thing is going to happen that we are going to have a single cell that is not able to Branch out or connect with anything else so once again the longest path we are going to make is going to be value number one now we are at this value number four what are the options we have so let me just clean this up a bit and from this value number four we actually have couple of options we can either grow from 4 to 9 or we can go from 4 to 8 so let's say if we decide to go from 4 to 9 do we need to calculate that from 9 how many values we can go to no why because we already know this result so from this four let's say if we go decide to go to nine we are actually going to create a path like this that uh uh initially we are going to have a node four and from four we have the option to go to 9 or from this value number four we have the option to go to Value number eight So currently we have two options from this eight we don't know how many options we have because we haven't calculated but we we already calculated the result for this value number N9 which means if we decide to go from 4 to 9 we are for sure guaranteed to have an increasing path of two because from 9 it does not lead anywhere else so we are good with this so far which means uh and from this 4 to 8 let's say if we decide that from four we are going to go to eight what are the options we have from eight we cannot go here or here so again from eight there are no possible nodes that we can calculate which means we are again going to be able to create a maximum path of two so in this case rather than doing all of this computation we can actually create store our answer and we can just put down the value 2 over here uh that this is the longest path four can take now we are at position number six from six uh what are the options it has well six as you can clearly see that six is not able to go over here it is only able to go over here and this we are already calculated from so that means that from six we only have two options uh and that is the longest path we can make is of value number two again from this six we have two options we can go to this value number eight or we can go to this Val number nine uh in either case the maximum path we are going to make is going to be of size two uh reasons you already know from this8 we cannot actually go anywhere else so the longest path we will be able to make is going to be one now from this value number two we actually have just one option that where we can go and that is to go to this value number six but from this six we already calculated the results and that is going to be two so in this case we can clearly write the answer as three now from this one we actually have multiple options to go to so this I'm going to draw in the answer and you would be able to understand what I mean so initially we are located at this value number one from this one we have the option to go to Value number six uh from this one we also have the option to go to Value number two and from the six we have the option to go to Value number eight and uh we also have the option to go to Value number N9 from this two we have the option to go to Value number six and then six we have the option to go to Value number N9 and currently we are located at this position so these are the possibilities or these are the options we can have let's assess each path so in this case if we go from 1 to six uh uh then from six we can either go to 8 or we can either go to 9 in either case the answer for this portion is going to be value number three but in this case if we decide from 1 to 2 2 to 6 and 6 to 9 we are going to get the answer to be of value number four so in this casee four is the maximum answer we can get but we don't actually have to do all of this computation why because we are using dynamic programming that is the most important concept uh so far so from this value number one the moment we see that this is where we can go our mind should click that if we go if we take this path then what we would do is from here we would if we take this path then the sum is going to be three but from here if we take this path then the sum is going to be four so obviously we are trying to find the maximum value so we are going to store the value of four rather than storing the value three and four is here now we are again located at this value number one from this one can we go over here no can we go over here yes so what is the maximum path we can make we can do one jump like this and we already know that there is there is only one single entity path we can choose over here so maximum value we can get is going to be two so this is going to be our dynamic programming uh graph combination Matrix combination solution and that is why this is treated as a hard problem but in my opinion if you already knew these Concepts then it won't be so difficult for you and after watching this video I can guarantee that this is definitely not going to be hard for you so we can clearly see that in the end we only need to return the maximum value that is present inside the dynamic programming graph and that we can return quite easily and this is going to be the whole solution now this is a very beautiful solution if we see time and space complexity in this case essentially the time complexity is going to be big go of 2 * m cross n so overall we can write the time complexity to Big of M multiplied n which is a very good time complexity and if we see space complexity well this is little bit more expensive because we are using an additional uh 2x2 or M cross n Matrix over here so this is also going to be big of M multiplied by n but this is also reasonably acceptable this is not very complicated so in my opinion this is a very good problem to understand three major Concepts uh and that is graph uh dynamic programming and also Matrix so everyone should do this problem at least once now let's go to the coding part that is not so difficult so basically first of all we are going to create uh 2D array uh to store all the directions that we are going to Travers over we are also going to have some private integers that we are going to use now the first idea is to create or to find the longest increasing path as an input we are using the Matrix that we are given in the input and we are simply going to iterate over the given Matrix we are also going to create an a cache or a dynamic programming M cross n array and we are simply going to have our answer stored initially as as value number zero then with using two for Loops we are going to iterate our uh n cross n array and we are going to check that whether at any single cell position are we finding the maximum longest increasing path or not and for to do that we are actually going to call another helper method called DFX where in the DFS as an input we are going to provide Matrix the current I and jth position so to identify that which cell we are talking about and the current array that we or the current dynamic programming Matrix that we have created and populated now inside our DFS method we are first of all going to check that for any particular value are we or have we already checked uh that particular cell value or not and we are going to initialize the dynamic programming array as zero so if the value is not equal to zero then we need to find the value for that and we are now going to iterate in all four directions from that particular cell uh then we are going to check that we are going out of bounds or not using these four conditions if not then we are only selecting the path where the adjacent values are going to be in the increasing order and if that is is the case then we are going to update the value of our current cash uh with whatever the maximum value we can find for that existing cache or recursively calling the DFS method again and in the end we are going to add one more value to our cache because we found an additional path that exist and let's say if we don't find any additional path still the initial value of cash is going to be zero so if we increase it by one it is going to be added by one so let's try to run this code seems like our solution is working as expected let's submit this code and our code runs pretty efficiently compared to a lot of other Solutions uh I would be posting this uh code in our GitHub repository and that link for our GitHub repository is actually posted in the uh description so you would be able to check it out from there thank you hello friends so the lead code problem we are going to solve now is called distinct subsequences we can see that this one is a lead code hard problem and also a very well-like problem now basically we are given two strings s and t in the input now we need to return the number of distinct subsequences uh of s which that which equals to basically T so how many different ways we are able to generate string T from the given string s and that is what we need to return so let's try to understand it with couple of examples let's say that we are given the string as a b b and the given string is a and b now in this case notice that we can generate t uh in two distinct ways first one is if we use just this first two ab or second one is if we delete this ab and we use the first and last AB uh so that is what we need to return as the answer second scenario is that let's say if we are given the word rabbit R A BBB i t and in the subse uh subsequence that we are trying to generate is r a BB i t so in this case we are dealing with three Bs over here and over here we only need two BS so basically once again we can generate it using three distinct ways first way would be where we are eliminating or not considering this B uh so that forms rabbit second scenario would be where we delete this B uh and third scenario where we would not consider this B and in either case we would be able to generate e so we can return the answer now as always let's try to understand the Brute Force solution first well we know that at any given character s we need to Define that will that character help us generate value that is currently present in T So for a smaller example let's say the given values a b b the current T that we are trying to generate is a and b now notice that at any given location of s we are making two decisions whether to include this a or exclude this a in order to generate the T if the characters match we include it for our subsequent answer if they do not match we could have excluded it and then try to see whether some other sequence makes sense or not same way after doing this even for the other two characters we still have the same two possibilities on whether to include this character or not and very quickly we realize that this leads to basically exponential time complexity where we are dealing with somewhere between like I guess 2 to the power of n uh um time complexity where n defines all the characters that are currently present inside the given s and two because we are making two decisions at any given interval which is in very expensive time complexity if you plan to solve this so we'll have to find a better way to compute now just try to understand that the optimal approach in this case is going to involve the most beautiful approach in the Entire Computer Science and that is going to be dynamic programming but thing is let's first understand that why do we need to use use dynamic programming in this case well because all the values that we have currently calculated so far are going to help us make future decisions let me give you an example let's say the given values are a b b c and the value we are trying to generate is going to be a b and c now notice in this case if we have already computed that in order to generate this character a there is only one way we could do it why don't we just keep that information handy so next time when we encounter character a b we don't have to look the entire ways to generate a from the given input we already know for a fact that this are like let's say there is only one way to generate a we know for a fact and then we found like two or three occurrences of B then in either case for each of the occurrence we can recompute that result so let's say that since we are given Three B's over here we know for a fact that there are going to be three distinct ways for us to generate a b no matter what and now when we are dealing with c and we realize that there is only one C over here which means there is only one way we could do it which means it does not add to us being able to generate this value so overall the answer is going to be three but let's say over here if we are also dealing with two C's and a d then also the answer might change so at any given instance in the character that is currently present at T we Define that whether that character matches the subsequent character inside the s or not and based on that we are trying to check that what has been the previously calculated results for each one of the characters and then we are able to make that decision on whether to include that character or not now notice in this case the number of sub subsequences only increase when the to when the characters match and basically when we have already calculated all the values that we have calculated so far because over here if this was AB BC and b c we know that there is only one distinct character but if this was a b BC then we have a match at B and one time and a match at B at the another time so basically we can take whichever B path we want and the answer would still yield the same result so that's why we are dealing with two possibilities over here first possibility is if there is a match if there is a match basically we include both the possibilities of calculating or both the paths that would yield us in a subsequent if they do not match then we simply do not need to include that and we can keep the same subsequence number that we have even if we did not included that character from the given subsequent s because it wouldn't change the total number of result that we are trying to generate and we would understand this if when we start using a DP Matrix in order to solve this problem now the question becomes why do we need to do use a DP Matrix because the characters present in s and and the characters present in t they both are of value to us and we will have to calculate for every single possible permutation combination and in the very last result that we find in The Matrix that is going to be the total number of distinct subsequences we can make so I have currently drawn a big Matrix like this now notice that all the characters we have in the T are currently present over here and all the characters in s are currently present over here as part of this so this is going to be basically our jth value and this is going to be basically our I value now we know that this is going to be a dynamic programming solution also for any DP solution we need two things we need a base case so base case is going to be quite straightforward it would be as if if the given s is not present or if the given T is not present what is going to be the value we know that if let's say that t is not going to be Pro present which means there is only way for us to generate uh T from the given s is not to include any characters because that is also a subsequence of given s so all of these numbers would only mean value number one so we can just mark them as one because if the character in s is present but subsequent T is not present we can only make one subsequence out of it let's understand why Versa if the given s is equal to null but we still have some value present inside the given t which means we would never be able to generate T based on the given s because the given s is empty so because that is the case then all of this results are going to be zero because we are not able to generate t or we are not there there does not exist any subsequence that would be able to form T from the given s okay now we know that what needs to be the recurrence relation so recurrence relation is going to be quite straightforward for any particular I and J's value we are trying to calculate we would see that if they match or not if they basically match we will have to do the we will have to do the sum of both the subsequence which means we would need to consider that what does the diagonal value for any particular character is so that is going to be uh let's say for I and J if they match then the diagonal would be i- one and J minus one plus what the previous subsequence has been with respect to S and that would be the value i-1 and the current J value we'll have to do the sum of both of these these two characters so let's say that for an example we notice that this a matches this particular a so because this cell has a match then we'll need to combine the subsequence we are able to generate over here plus the subsequence that we have been able to generate over here because we can take both the paths from here and notice that only the values of I differ J would remain constant because we are trying to build uh t from the given s now I know it sounds confusing but we'll understand it when we move to building our Matrix now the second scenario is that if they do not match if they do not match then simply that does not add any value for us to build a subsequence let's say over here this a and this B do not match so because they do not match they are going to have the same number of distinct subsequence value that we calculated even for the previous result of I that is going to be the cell above it so we will just replicate that value so if they do not match basically we will just take whatever the value of I minus one and J was as it is and we will store that in the result so now based on this to recurrence relation let's see that what does our um distinct subsequence that we are able to find we notice that there is a match over here R and R they do match so because they do match we are going to take the sum of the diagonal value and the top value now notice diagonal is also going to be zero for the first value so we'll just mark it as zero and sum of this two is going to be one so we'll mark it as one same way for this R and A do not match because they do not match we are going to carry forward the value from the top so this would become zero same way R and B do not match so this would become zero R and B do not match so on and so forth so all of this are going to be zero okay now a and uh R once again they do not match so we will take the value from the top now over here in this case a and a actually match so for this cell because they match we are going to do the sum of this character plus sum of this character so let's just Mark these value as one as well once again A and B do not match so this is going to be value from Top uh and so on and so forth we will just Mark all of these values as zero now for B and R they do not match so because they do not match value from the top one b and a do not match so once again value from the top as one B and B do match so because they do match we are going to do some of these two values so the answer is going to be one okay uh once again B and B once again match so some of these two are going to be uh zero and once again B and B do match so some of these two are still going to be uh sorry once again B and I do not match so value from the top and then B and T do not match so value from the top now B once again so this is is going to be value 1 one so far but now this notice that this B also matches this B so in this case we are going to do sum so this would become value two now once again this B also matches this B so once again the sum is going to be value number one and now so on and so forth the these are going to be 0 0 as it is now for this third B once again this is going to be one this is going to be one there is a match with this B so because there is a match I'm going to do sum of previous two elements so this is going to be three once again for the subsequent B once again there is the sum so this is going to be three uh so I'll add those values and now this value is I so they do not match so value from the top is zero and once again T do not match so value from the top zero okay now I'll change colors again so better visibility for I uh basically all of these values do not match so up until that point we can just carry what whatever value we had from the top but now this I matches this I so we are going to do some of these two values so total is going to be three once again this T do not match this I so once again the total is going to be zero and lastly for this T last time we are changing the colors and basically the value is going to be uh same that we have been able to identify all up to this but this last T matches this lastly so basically the sum is going to be these two and the answer is going to be three and this is what we we need to return as the answer so basically you understand that how using dynamic programming we were able to shrink our solution from 2 to the power of n to basically time complexity of big of M multiplied by n where m is the length of s and n is the length of uh T so which is a very good time in space complexity we cannot go any more optimal than this now in terms of space complexity because we are using an extra Matrix this is also going to be big of M multiplied by n uh that is a reasonable cost to pay so now let's understand the coding solution for this the coding solution is going to be quite straightforward first we are going to Define two variables M and N to take care of the length of the given subsequent s and D strings then we are going to initialize a 2d dynamic programming array and uh basically we are taking it as m+1 and n+1 this is to take care of the base case Okay after that we will initialize for uh basically when the given I uh and I is equal to 1 and J is equal to basically zero so for the First Column all of those values are going to be one and all the J column is going to be zero we haven't mentioned it over here but that would be like an intuitive thought that we can understand now we'll start filling in the dynamic programming array we will check that for the given dynamic programming array if the characters match then we are taking in the value from the diagonal and the value from the top and summing it up that is going to be our subsequences if they do not match we'll just directly inherit the value from the top of the D DP Matrix that we have calculated so far in the end we will simply return the result or the very last cell in the DP Matrix coding is not that much but concept is quite important let's try to run this code okay seems like our solution is working beautifully let's submit this code and our code beats nearly 65% of all the other Solutions which is pretty awesome in terms of space complexity we could have done things slightly better but anyways this is also a reasonably good uh space complexity once again the coding solution is present in our GitHub repository so feel free to go and check it out from there thank you the lead code problem we are going to solve now is called edit distance we can see that this one is a lead code medium problem and also extremely well like problem on lead code basically we are given two strings word one and word two and we need to return the minimum number of operations that we need to do in order to convert word one into word two completely now we have three operations that we are allowed to do we can insert a character delete a character or replace a character at any single moment and we can come up with the solution so let's try to understand some of the examples on how long will it take so let's say that if the given word one is horse and word two is Ross in this case we'll need to do three operations basically to convert this word one into word two first we will convert this H into R so now we are uh left with two words basically r o r s e and then r o s then we will keep o as it is and R as it is now we will we can delete this uh r R so notice that now we have the two words as r o s e and r oos and then lastly we can also delete this e so basically we have both the words same so notice we did three operations first one was the replace operation between these two values then we simply go ahead and deleted this R and then deleted this e and that solve the problem same way if we are given three words like a b c and XY Z in this case the only thing we can do is we can replace all each of the character 1 by one so in this case we also need to complete or take three operations to come up with this solution let's say if we are given two words that are exactly same so in this case we don't need to do any operation and we can simply return zero as the answer so basically the idea is that we have the ability to either insert delete or replace a character but we'll have to convert word one to word two basically so now let's try to understand that what would be the Brute Force approach to solve this problem so in this case uh as a Brute Force at every single character we have the three probabilities that we can choose for and we can uh replace the character with whatever character we have over here we can delete this character or and we can create an or we can insert a new character so we can take each of this subsequent path and then over there we will also have three more possibilities and we would continue to keep on going down each of the path until we find word two and we will find all the possibilities of generating word two and whichever has the smallest distance we will pick that now notice that this is a very expensive Brute Force solution why because at every single node we have possibilities to go down to three other nodes and even for those three nodes we have subsequent more possibilities so basically we are running into issues of exponential time complexity and that would directly be dependent on the total number of words present for word word and word two which is very expensive so we'll have to find a smarter and clever way to come up with the solution now logically the only thing that makes sense in this case would be that because we have we are dealing with word one and word two and we are dealing with all the values that we currently have now notice that whatever the result that we have computed so far would impact on the subsequent result we are trying to generate I'll repeat what I just said basically uh currently if we have to generate like a b and sorry a x and z uh from this given a b then what possibilities we have like we know that first character is a so we can keep it as it is now we are dealing with generating this B with this remaining x and z and for that what we can do so with the B we will have basically a character so we can just replate it replace it with X and then we can insert Z over here so we can generate an an answer like this but thing is notice that we don't know subsequently in word word if this value was to a a YZ if it was something like this then we would have our choices differ if we had some other values where we are trying to come up with a solution where let's say that uh this is a b uh Z and the next value we are trying to build is a x b y z so even in this case uh every single moment we are trying to make the decision we will have to compute that what was done for the previous values and take that into consideration and I'm giving all of this explanation just to explain that we will be using the most beautiful approach to solve this problem that is using dynamic programming where we will compute every single possibilities so we'll compute that if we have to generate this word and the only word given is currently a what would be the answer uh a b then what would be the answer a b z then what would be the answer and so on and so forth if we try out every single permutation combination and have a 2d Matrix to keep track of all of these values then we will we'll be able to solve this problem very efficiently now what are the possibilities we have at any given location remember we can do three operations we can do an insert operation we can do a delete operation we can do a replace operation and for each of the three operation if we we only do this operation if the current characters that we we are dealing with for the word one and word two do not match so let's say if they do not match we need to do these three operation but we are only going to be selective and we will look at the previously comp comp computed results from our dynamic programming array and for that we would be able to determine that if we do insert if we do delete or if we do replace what is going to be the cheapest operation and we will do plus one because we are adding one more operation and then compute the result now let's try to understand this with an example and it would make much more sense on what I'm talking about uh we are going to take into the consideration for the same input that we we were originally dealing with where word one is horse and word two is Ross now notice that I have created one additional row and additional column on the each side and that is to take care of the scenario of what if word one is completely empty and what if word two is completely empty and based on that we will build our solution because remember for dynamic programming we need two things we need a base case and we need a recurrence relation so base case is what if the word is completely empty then we know that we'll have to only insert the character and build the solution and uh recurrence relation is the three subsequent neighboring cells that we have already computed for any particular cell that we are trying to compute so let's see a scenario like this where presumably word one currently is null and we know that let's say that given word one is null and for the word two that value we are given is also null then we basically do zero operations because we can't do anything to because they both are exactly same now if word one is still null that is what this row defines but word two contains the value only R now if word one is null and word two is R if we want to generate R from word one what will we do basically we would insert a character so we would do one operation insert operation uh where we are inserting a value and that is what we are doing over here so in order to generate only R subsequent with the given current empty empty word one we would need to do it with one operation same way if we have to generate r o and this word one is null we basically insert two characters so we are going to do two operations now notice in this case we don't need it to compute for this full value because we already know that in order to generate R we only needed to do one operation if we have to generate o we know for a fact that for to generate R there is only one operation needed so for r o we only need to consider the maximum number of operation needed to generate r + one because we are inserting a new character and that is that is supposed to be two same way for R OS we are not going to compute the full thing but we know for in order to generate r o it takes two operations uh and then if we have to add s to it it it adds one more operation so this is going to be three same way let's imagine that for this particular First Column uh if the given word two is let's say null and the g word one is let's say all of this h o r s e horse then what we would do in order to generate this value well if it's going to be null we can add it as zero because both values are same but if this word same way if this word 2 is equal to let's say null and word one is currently H then basically we will have to delete H because we are trying to build word two from word one so in that case we'll have to do one operation same way if we have to basically given word one as ho and word two as null once again we'll have to delete H and delete o but we don't need to calculate how much time it takes in order to do both of this we already know that takes one operation to delete H same way it's going to take 1 + one operation to delete ho so this is going to be two same way this is going to be 3 four and five subsequently now notice that at every single character that we are trying to build we basically have three possibilities let's say that currently word one we have is so for this case this is going to contain value H and word two we have is only going to contain value R now in this case for both basically H and R if we want to generate this what are the options we have for word one we can either replace delete or insert a character and if we were to replace a character basically we simply take whatever the previous value we had over here and we just replace it we do the replace operation that is option number one second option is if we have to delete the current character if we have to basically if we trying to delete this h then this is the scenario where H does not exist only R exist so we take whatever the value we have over here and do + one over here because we did a delete operation so that would be the subsequent value over here or if we have to insert a character basically in that case r does not exist so in this case once again we take whatever the value we had over here and do plus one so now notice that in order to build this cell we have three corresponding relations with each of these three subsequent cells we can do whatever operation we want to but basically in each of the cases we our uh number of operations we are doing relies on the subsequent neighboring cells so if we do plus one amongst these three then basically we can generate that value but thing is that plus one we are going to pick the minimum cost it takes to build this cell amongst these three so for these three values we will do plus one and we will see that what is going to be the minimum value and whichever the minimum value is we are going to insert that value over here so I hope that logic is understood to you why we are picking this value but basically in this case notice that if we do plus one over here the value becomes two this also value becomes two but in this case this would turn value to be one so we are going to keep value as one now notice same with this character is H this character is O once again they do not match and they because they do not match we have the option to do all of these three operations they depend on the neighboring cells the neighboring cells we already know so once again we will do the minimum amongst these three so the total is going to be two and basically plus one with the minimum same way for this one the minimum plus one so the total is going to be three so what does this three defines this defines that if we have given word one as H and word two as basically R oos in order to do that if we have to do that it takes three operations to build that uh this word Ros from this word 1 H same way we are going to be doing for every single possibility and combination once again now notice o and R do not match so we will do the minimum operation so minimum is going to be two once again now in this case because this o and because this o match for this particular cell if there is a match we don't need to do anything and we can just take previous subsequent diagonal value we had where basically we are not doing anything we are just uh keeping the value as it is so this is going to be one same way if we have to do this now because the values do not match so it's going to be 1 + 1 so this is going to be two same way for this R and R because these values match we will take the diagonal value two once again over here uh the sum is going to be two and once again for here the sum is going to be two and that is this diagonal sum okay same way for this S and R the values do not match so this will become three s and O once again values do not match so this would become three now S and S do match so because they match we will take the diagonal value and keep two as it is now same way for this particular cell the value is going to be four for this particular cell the value is going to be once again four and for this particular cell the value is going to be three and whatever the last value we have on this U 2D array that would basically Define that if the word one was the full value so h o r s e and if the word two was the full value r o s then it would take three operations to build word two from word one and uh can return return three as the answer so this is going to be the whole solution now if we see time and space complexity in this case the time complexity is going to be big of M multiplied by n because we'll have to iterate over every single value that is currently present and in terms of space complexity well because we are using an additional 2D array this is also going to be big of n multiplied by n but overall this is much better than our Brute Force approach and this is a beautiful example on how dynamic programming can be powerful for us to solve any problem uh especially like the recurrence relation problems okay so let's try to see the coding solution for this now so the coding solution is quite straightforward basically we are going to Define two variables M and N to capture the length of word one and word two then we are going to initialize our 2D dynamic programming array that is going to be of size m+1 and m+1 where we'll need to create a scenario where M and N are defined as zero and then we will find values for those as well then we will initialize our value for basically each of the words so like for word one and word two if they were given alone and then we will try to fill in the values for both one uh word one and word two uh in subsequent first row and First Column after doing that we will fill in the rest of the dynamic programming array where we are iterating over every single cell uh that are not filled where we are checking that if the given subsequent word one and word two are same then we will just choose whatever the previous value was from the diag value if that is not the case we will check all the three adjacent neighboring cells plus one and try to find the minimum value for each one of them so basically we will try to replicate the scenario on if we have to delete a character replace a character or insert a character and whatever is going to be the least cost we would put that in the current I and jth value in the end we simply return the result or the very last element inside our dynamic programming array and that should provide us the distance it takes for to generate a word one from word two or vice versa so let's try to run this code okay seems like our solution is working beautifully let's submit this and our code works well and beats most of the other Solutions in terms of uh time complexity so which is pretty good and once again the coding solution would be present on our GitHub repository so feel free to go and check it out from there thank you Hello friends hope you're having a fantastic day today so the lead code problem we are going to solve now has to be one of the most difficult problems that I have solved so far it's called burst balloons we can see that this one is a lead code hard problem and very justifiably also a very well-like problem so basically we are given n balloons that are under index from 0 to n minus one uh so they are they can be placed in an array now for each balloon is painted with a number on it that number represent is represented in an array called nums and we are being asked to burst all of these balloons now the number that is currently written on that particular uh balloon represents like some sort of coin values but thing is when we burst a balloon we actually get coins in multiplicate by multiplying its neighboring cells with with that particular number and then neighbors basically change because we already burst a balloon from in between and then we keep on repeating the same process our aim is to make sure that we can receive maximum number of coins by bursting uh as many balloons wisely so this is the key phrase now we are being told that uh let's say that we run into an issue where there is a neighboring cell that is at the edge of the given nums array then basically just imagine that there is one neighboring cell with one painted on it so that we don't turn into an issue of a being out of bounds so let's say that we are given an example of two balloons the values are 1 and five now notice for these two balloons basically we can treat them as uh following where uh the middle two balloons are still going to be values 1 and five as represented over here but it is going to have two neighboring balloons that are valued one and one that we are not going to bust we will only consider these two balloons but they are there for us for toour support now what is the maximum value we can achieve now let's say that we decide to pop balloon number five if we pop balloon number five basically we get value such as uh multiplication of its neighboring values so it would be 1 multiplied 5 multiplied by 1 because of these three values now notice this would yield us the result five plus we still have one more balloon because we already po balloon number five we would have one more balloon one that needs to be popped and now its neighboring cells would become one and one and with one so this would become one and this would total out to six but thing is this is not a wise approach why because in the same example if we notice that instead of bursting balloon number five at the beginning if we decide to burst balloon number one one in the beginning instead then basically our values would be so we burst this balloon number one so that would yield us the value of 5 * 1 * by 1 so total would be five plus now this balloon no longer exist but we still have this five left and uh its neighboring balloons are one and one so this is also going to be five + 5 so total is going to be 10 so we need to return 10 in the answer let's say same way we are given the values 31 58 now in once again for this example as well we uh can Choose Wisely and and the most logical way to pop balloons would be that if we decide to pop balloon number one if we decide to pop balloon number one we would get values 3 * 1 * 5 and the remaining balloon would be 3 5 and 8 okay so let's uh sum up this value so this is going to be 15 so 15 plus uh these three values now once again in this case and remember uh imagine that there are going to be two neighboring ones present at all the times okay now once again we would decide to pop balloon number five if we do that do that we will be doing 3 * 5 * 8 and the remaining balloon is going to be value 1 3 8 and 1 okay now once again in this case this is going to be 15 plus this is going to be 120 plus this is now in this case the ideal thing would be to pop balloon number three if we pop balloon number three then we get value 1 * 3 multiplied by 8 so 24 and then we would no longer have three existing so last value would be eight remaining with two adjacent ones and that would be plus 8 and if we do total of all of these values the maximum number we can achieve is going to be 167 and this is what we need to return in the answer so I hope this long explanation makes sense that what is being asked for us to solve this problem now very first approach comes to our mind is a typical Brute Force approach that if we are given n number of inputs let's say values 1 2 3 4 right why don't at every given position we have the three option of choosing whether to pop that balloon or not to pop that balloon so if we decide to pop balloon number one then we are going to be left with uh the value that we received from balloon number one so that is going let's say that the value is X plus we have the possibility of dealing with the remaining 2 3 and four values and once again in this path one once again we will have the option to uh take this X Plus amongst 2 3 and four we can pick a number so let's say we decide to pick balloon number two so that value becomes Y and then once again we are going to be left with values three and four and once again we will be making a decision same way for every single value we can make a decision based on the sequence of balloon we pop and same way we are going to have different choices and subsequently it will grow over period to basically all of the different permutations and combination of choices we can make so that is going to be a very huge decision tree that we can make now in this case the answer is going to be 2 to the power of n where n is the total number of characters present because at every single instance we are deciding whether to include that or not to include that so that's a very expensive time complexity that doesn't work let's try to become greedy in our approach so greedy approach Works something like that uh basically we can take an input and we will try to pick the smallest value so let's say that we saw in the example of 3158 that we would pick the one first because it was the smallest value so it would not bring any uh like long-term benefits to us if we just keep it around so why don't we burst Balloons with the smallest value possible so in that case if we decided to burst this balloon number one let's say Being Greedy okay so we get the value as 15 okay plus now we are left with three values uh three uh 3 5 and 8 once again logically we would be bursting balloon number three so if we do that once again we would be generating the value as 3 * 5 * 1 so this would become 15 uh plus uh same way we would be left with value five and 8 if we do that we will be bursting value number five so the value would be 40 and plus lastly that would be value number8 so this would become 8 so if we do sum of all of this it's going to be 30 + 47 70 + 8 78 so greedy approach also doesn't work because we know that if we can do it wisely we can solve this problem and gain 167 coins amongst the this input so this is also a second choice uh that would not work so now the solution would become pretty obvious to you so in this case we are actually going to be using the most powerful and beautiful concept of the Entire Computer Science and that is called dynamic programming now how we are going to be using dynamic programming is that remember in The Brute Force approach basically when we had four inputs uh we would take certain paths so we would pick what if we bust balloon number a and then we are left with whatever the value we generated from balloon number A plus whatever value we can generate from BCD same way once again we have two choices of A+ B plus whatever value we generated from CD same way over here we could have decided to bust balloon number a sorry balloon number B and then once again generate the value that would be gained from a c and d and once again we could have burst balloon number uh a and then once again the values would have been C and D now notice that both in this case we are left with value a plus b plus C D and A plus b + a plus c d basically in just reverse sequence so we need to keep track that at every given moment whatever the balloon we burst uh depending on whatever the range what is the value we are generating now now important phrase over here is going to be range that we need to know that between every single combination of values what uh maximum coins that we are able to generate now in this case we'll need to do uh we'll need we'll require a 2x2 matrix now notice in 2x2 matrix I'm using the same example we used 3158 but we are we have added one at the at each of the end uh they are just denoted by a different color and they are to make sure that we have a neighboring cells present but we are always going to be iterating amongst these four values okay so when I talk about keep track of the values of bursting balloons that would be amongst uh the set of values now one more thing is we let's say that I only give you value number three and ask you that what is the maximum balloon I can generate you must be saying that hey it's pretty straightforward we would do like one multiplied by 3 * by 1 and total is going to be three for sure now let's say that I give you value 3 and 5 now what is the maximum possibility well we have two possibilities one possibility is that we actually take three first so basically that would become uh 15 + 5 or we could have taken five first and that would have become 15 + 3 so to Greater total is 20 so we could we can say for a fact that if we are dealing with only two Balloons with value three and five maximum value we can generate is going to be 20 now in this case let's say that we add one more possibility that 3 5 and 8 now for this fact we can say for for with certainty that with this eight the maximum value amongst this three and five we can generate is going to be 20 so we can leverage that fact and we can use it to to our advantage in this case there is also possibility that instead of of taking eight at last we can take eight somewhere in middle so we'll need to keep track that what would be the value being generated with the value three and eight and we'll have to keep track of all of these different permutations and combinations of values so that's why we need a 2d Matrix and a sequence of range that we are going to be determining now in this case let's just try to do it uh one by one starting with the smallest Range possible and that is going to be of interval one so let's say if we are only dealing with interval one ranges what are are the different values that we are trying to compute for first value would be 1 1 second value would be 22 third value would be 3 3 and fourth value would be 44 okay now for 1 one we are thinking that if so for 1 one If This Were to last value that we are going to be bursting what is going to be the result so basically uh because range is one remember so we are only incrementing the neighboring cell by one so in this case 3 * by 1 multili by 1 so the maximum value can generate is going to be three so we will mark it over here same way in this case uh let's say that uh for some reason we decide that instead uh for 22 so for 22 this is the value that we are talking about what is going to be the maximum value we can generate the neighboring cell so remember that we have we have decided that we have burst all the Neighbors in that range but because this range does not have any value other than that the then the these are going to be the neighbors so this is going to be 3 * 1 * 3 so that is going to be 15 so we can Mark 15 as it is same way for Value number five once again uh there are no neighbors so 1 * 5 * by 8 so that is going to be 40 and same way for Value number 8 once again uh 5 * 8 * 1 so that is going to be 40 so we can mark all of these values as it is that's cool now let's up the an and let's update our uh total number of uh prices uh sorry range that we are currently trying to build out so first range would be of size two now comes the interesting part now what are the ranges we can generate so range would be 1 to 2 second range would be 2 to 3 and third range would be 3 to 4 now let's talk about just range 1 to2 for a moment now in the range 1 to2 we have we are talking about basically the these two values three and one okay now um three and one amongst the grand scheme of total three 5 sorry 3 1 5 and 8 amongst these four values so now notice that we have the two choices First Choice is that three would be the balloon that we would pop last or one would be the balloon that we would pop last what if we decide that three would be the balloon that we are going to be bursting last then in that case we what is going to be the neighbor of three that we would multiply three with because we have already popped one 1 so that would be value number five so that would be 1 * 3 * 5 this one we got from the neighboring one that is this over here and five we got that is the end of the range uh that is the over here plus we must have received whatever compensation we got by bursting just balloon number one and that is going to be DP of basically 2 and two so this is that that is uh this value so the maximum value we can generate is 15 so in this case it's going to be 15 + 15 so maximum value we can get is 20 for range 1 to 2 by bursting balloon number three last so one possible value is 20 so let's just Mark 20 as it is right now let's just come back once again do our calculation now for the same scenario we are considering that what if uh we decide to burst balloon number one last so okay so three and one we are bursting this balloon number one last which means we have already burst this balloon so what is going to be the neighboring cell one and 1 and five now what is going to be the value so bursting balloon number three would give us maximum value of three so let's mark three plus uh bursting this balloon number one now would be 5 * 1 * 1 so that is going to be 8 so 5 and 8 um yeah so basically 5 plus three so total going total is going to be eight so in this case because the higher value uh is going to be the maximum value that we can generate that would be amongst this oh sorry uh this value was supposed to be 30 not 20 because remember we did 15 + 15 okay so now the maximum coins that we can generate at between range 1 to 2 would be amongst the maximum between uh 30 and 8 and we know that maximum value is going to be 30 so we will just Mark 30 over here this defines that this is the maximum number of coins we can generate U for this particular range now let's just come to the next range uh in our set of sequence and now I'll just start moving quickly because I don't want to spend this much time for each of the things okay next range would be value 2 to 3 so now 2 to 3 the values are going to be 1 and five okay now for this one what if we decide to burst balloon number one first sorry balloon number one last if you B burst balloon number one last basically it's going to be value number 3 * 1 * by uh 8 so that is going to be uh 3 * 1 * 8 so that is that would be 24 plus whatever the value we get from DP at Value five and five uh sorry value three and three so that is value 3 and three is going to be 40 so the sum is going to be 64 okay now what if we decide to burst balloon number five at last so in that that case uh well it's going to be 5 * uh 8 * uh once again three so plus whatever value we get by bursting this balloon uh uh so that is going to be 15 so the total is going to be 135 so logically it makes sense that at range 2 to 3 the maximum value we are able to generate would be value 135 so we will just Mark 135 as it is okay now the last range we have is going to be range 3 to 4 now once again at the values range 3 to 4 what are the basically two balloons that we are able to pop uh the values are five and8 so we can either pop value number five and the last if we decide to pop value number five in the last basically uh we would be gaining the value 45 if we decide to burst value number8 in the last we would be gaining the value 48 now why did we get 48 I'll just quickly explain basically we are doing 1 * 8 * 1 so this is 1 one and this is the second one because remember we are talking about this range and plus whatever value we get by bursting this balloon so that is that would be 40 so basically 8 plus 40 so that sums up to 48 okay so maximum value is going to be 48 between the range 3 to 4 so we'll just mark it over here as 48 okay now same way now we took care of all the intervals of size two what about all the intervals of size three so once again for this one the complication now becomes even more critical because now the first range we are talking about would be 1 to 3 so we have the three candidates 1 2 3 would be 1 2 and three so now we have three candidates basically 3 1 and five to solve this answer uh and for each of the one so we have what if we decide to go each of the one in the end so I'll just do calculation for one of the values for Value number three so basically this would what if we decide to go with this value at last uh now remember 3 would be multiplied by 8 and it would be multiplied by 1 so it would be 1 * 3 * by 8 because we took care of the entire range okay plus now because this is the first value in the range that we are talking about we would also need to do the dynamic programming of range between this value 2 and three so 2 and three we already have the answer and that is 135 so this would become 135 plus + 24 so the total is going to be 159 okay now what if we decide to burst balloon number one in the end once again uh that value is going to be 51 and what if we decide to burst balloon number five in the end the value is going to be 70 so 159 is the obvious choice so between the ranges 1 to 3 the maximum value we can generate is going to be 159 so we'll just Mark 159 as it is same way for the range 2 to 4 the maximum value that we are able to generate would be once again value 159 as well by the same logic and uh so we'll just from 2 to 4 the value would be 159 as well so we'll just mark it as it is over here and now comes our final range that is of range size 4 and for the range size 4 the only possibility in this case we are going to have would be uh basically just one value so the range would be from 1 to 4 we have the possibility of bursting uh 3 1 5 and 8 all four balloons at the last what if we decide to bust balloon number three last if we decide to bust balloon number three last basically the coins we would be generating would be three plus whatever the range we can get so basically 2 3 and 4 so DP of 22 4 uh so DP of 22 4 we already know that that value is 159 and plus value number three so that is going to become value uh 1 62 okay uh now let's do the calculation for Value number one so basically once again for Value number one the total would be 159 plus uh the total sum would be um sorry no for Value number one the total would be only 52 and why it would be 52 because remember uh this value uh the the range would be uh so for this one value number one the range would be basically we would do multiplication so that is one multip by 1 multiplied by 1 so that would be 1 plus remember we have two ranges first range is uh DP of 1 to 2 so DP of 1 22 and second range would be DP of uh 2 to 4 and sorry DP of 3 to 4 because we already took care of DP of 2 so this DP of 1 to 2 is going to be 30 plus DP of 3 to 4 is going to be uh 48 so 48 + 30 + 1 so whatever the value that that would come up to so so on and so forth if we keep on doing basically the maximum value we are going to be getting would be for Value number eight because remember for Value number eight the multiplication would have been uh8 okay let me just clean this up a bit and I know that this will this video is getting super longer but it is what it is okay for Value number eight basically the multiplication is going to be 1 * 8 multi by 1 By ignoring all of these values plus DP of uh range 1 1 2 3 so range 1 to 3 the value is 159 so 159 + uh 8 so this would become 167 that would we would store over here and this is what we are looking for that what is the maximum value we can generate between range 1 to 4 uh that would be 167 so we can return that as the answer I know this was a super long video perhaps the longest one uh that I did for dynamic programming but it's an important one now let's analyze the time complexity we'll have to iterate over uh n my n Matrix basically so that would become big of n Square work and for each of the ranges we will have to do it so that would be multiplied by n so that total time complexity would be big of n Cube there is no other way to do it faster than this even with using the dynamic programming and space complexity is going to be biger of n Square so which is a reasonably good time complexity given how complex this problem is so now let's quickly see the coding solution for for this one now the coding solution is slightly straightforward so basically we are given total length n based on that we are going to be generating our extended array that is going to be of size n+ 2 and we are going to be adding the last values as one that is to take care of the neighbors then we are going to be iterating over the original nums array and add values to our extended nums array that is that would be for Simplicity for us to update all of the values now we will generate our dynamic programming array that is notice that the values is n+2 and n+2 that is to take care of the two neighboring cells now we'll start filling in our dynamic programming table and iterating over all the values on top of it we'll have to Define range for every single different position and that is what this right length defines that this is the range we are talking about and at every given range for every single range that is is possible we will calculate that what is the maximum coin we can achieve on that particular value that would be by doing the multiplication of uh extended nums left minus one multiplied by extended nums of that particular value multiplied by extended nums WR + one notice that we are taking the values that would be out of the range for every single value and we are updating the Value Plus by doing the coins of d dynamic programming dynamically programmed ranges that we have already found so far so for any I range the value would be DP of left to IUS 1 plus DP of I + 1 to the right and we already have the values being calculated by bursting that particular balloon and the range value at any particular location would be the maximum value that we currently have or the new maximum value that we just found whatever is greater we'll just store it in the result so these are the three four Loops that would take care of all the entire logic that we just explained and then we can simply return the value for the range one to n that is the range that we are given in the input so let's try to run this code okay seems like our solution is working as expected let's submit this code and our code beats nearly 80% like 74% of all the other Solutions which is pretty awesome I would be posting this in the comments uh and in our giab repository so feel free to go and check it out from there thank you hello friends I'm A Cloud Solutions architect at Microsoft and my aim is to create free resources that will Empower every single engineer in this world so that they can do better with their technical interviews now continuing in that direction today we are going to solve a very important problem called regular expression matching so let's get started with the problem so if we see some of the popular companies who have already asked this question there are companies like Microsoft Amazon Facebook Google Bloomberg Adobe Apple Uber Snapchat Tesla Goldman sax and Airbnb so that's why I'm paying my utmost attention I hope you also enjoy the video so this is lead code hard problem and also a very well like problem basically we are given two input strings one is string s and the other one is Pon P now we need to implement a regular expression matching function that can support a DOT character and a star character inside this PN p as well now we are given the definition that what does a DOT and a star represent basically a DOT can represent that it can match any single character uh and the star represents that it can match zero or more preceding elements now first let's try to understand both of these with examples so suppose we are given a patn p that looks like a b and Dot now dot by definition it can uh support any single character now inside our given string s suppose we are given the values to be a b c now can we conclude these two to be matching strings the answer is yes why because for this particular dot we can consider it to be C because it can match any character suppose if we given an s that looks like a BX is it true yes this is also matching with this PN P because for this this time for this dot we are actually considering it to be X but if we are given s that looks like a a x is this matching no why because the second character over here this is a meanwhile the second character inside our pattern is B these two are not matching so this is not a matching sequence uh so basically this is what does the a DOT represents now let's try to get see one example of what does a star represent so basically suppose we are given a patn p that looks like this uh where the values are again A B Star now what does this star is uh saying by definition the star is saying that it can match zero or more preceding elements now what is a preceding element of this x the preceding element is B so which means that now this particular pattern can match bunch of of different uh other strings so strings such as a b b b b does this match this particular pattern yes why because if we see okay first character a is matching each other now for the second character B we can have multiple B's over here because of the star value because that is what is given in the definition So based on the definition we are now in this case considering the star to be all of these B's suppose we are given a string s that is only a is this matching with this patn P yes this is also matching why because this star can represent that we have zero or more preceding elements so in this case we are considering that we have zero BS in the patn which means that our given s is actually matching and in this case uh since both of these are matching now let's try to take one more example suppose our given s is equal to like a b x is is this matching no this is not matching why this is not matching because this AB portion this is matching that is good but we do not have an X over here and that is why this is not a match does this match and uh pause the video for a second try to guess that whether this matches or not let me come up with the answer the answer in this case is that this is actually a match believe it or not this is a match why this is a match well okay first f is matching this is good up until this point now because we have a star with DOT which means we can have n number of occurrences of Dot and We Know by definition that dot can represent any single character in this case what we are going to have is we are actually going to have seven different dots and these seven different dots they are going to represent each character that is missing in the remaining string and then eventually when we reach to the end we are going to declare this as a match and we will be able to return true in each of the cases so I hope after so many examples things would make sense and you would get the idea that what this problem is asking us to do basically we need to return a Boolean answer whether true or not that whether any given two strings do they match or not match okay now before we come up with the solution first let's see that what could be the different possibilities for our problem and what could be the different things we can do in the solution now I have drawn a table over here where I'm representing different like string values and pattern values and we'll try to see that what happens in every single scenario and what are the actions we can take now I have noted that there could be like a c mentioned over here in this column file and uh this means that it could be any character from A to Z because in the string we can only strictly have A to Z characters meanwhile for the patn we could have definitely C or we could also have a DOT and a star so that means different things and if they are present we might have to do things a little bit differently so first let's see the first scenario in the first scenario basically the both the values we are given is like a simple character so for S and P suppose we are given the values like a b c and XY Z this is pretty simple to match that whether the string matches the patn or not we simply need to judge character by character in this case we can simply see that whether they are matching or they are not matching this is a very simple binary operation second option we can have is the most beautiful option that whether we are given one character and we are given a DOT value this is also very straightforward if there is a DOT present definitely it Mees it matches the character we can simply return that there is a match for that particular character second scenario is that we could be given bunch of different characters and we could be given like some characters at the beginning and then we might be given like a DOT and a star in this possibility basically what we need to check is that whether like a single character like this first character and whether this first character I mean this could there these could be this could represent like more characters these could represent something like uh a a a a a and like a a a dot star something like that right there could be like different matching things I'm just noting down C but this means that if like the before portion matches everything at this position is definitely going to match so in this case if like the values before the dot and star matches then everything is a match right if we take a look at this example basically we are simply given Dot and star in this case 100% there is going to be a match why because all the values that are present over here we can take like 0 1 or bunch of different dots and that all of these dots can represent uh all the characters that we have now comes the interesting part where we are dealing with a star what could be different possibilities so let me give you like one possibility suppose for this our string and P value we are given the values like a b and over here we are given the values as a b star question is is this a match yes this is a match why because this is the first value this is a match in itself and over here we only have one value of B now over here we have B Star so this B Star could represent that we don't have any values or we have one value of b or we have two values of b or we have infinite values of B all across like the board whatever we want to choose in this case we are definitely going to choose one value of B which means this is a match so in this case what are we considering value before the like preceding value of star so value before preceding value of star if that is a match definitely we can find a match right there could be another possibility we could be given a string we could be given a p we could be given bunch of different values like a b b x y z a b x y z so far everything is the match over here and then over here we are given something like uh 2 3 4 5 Z's right and over here we are given like just a star value in this case how would you define that whether this is a match or not well definitely this is a match but the way you are going to Define is that the values that this Zed and star that we are considering like these values before that we are checking that whether all the values that are present before that are they a match if all of these values are match definitely uh we can create this to be a match so again we are considering like all the values before the preceding value of star I know I'm using lot of abbreviations but you just have to be with me I'm not going to write all of them and if that is a match we can consider this to be a match there is also one more possibility where we actually do not need to consider this like preceding value at all what could be a scenario suppose we are given string s is equal to like a b c d and over here we are given some p is equal to a y star and then b c d in this scenario this is definitely a match why because for this y star we are considering this to be zero if this is being considered as zero values which means that this is a match and then all the other values they are match so we will find a potential match over here so again we are considering like if the value before the preceding star if that is a match then we can consider this to be a match so now we are just like dealing with lot of possibilities where every single time for Value inside the patn we will have to keep TR track of the value like two value before that that whether that is a match or not and in order to calculate any single calculation we are always checking that whether the values before us are they matching or not so this is a very good candidate for a dynamic programming solution why a dynamic programming solution because first scenario we are definitely like using whatever the results we have calculated to check that whether the current result we are at if that is a good or not second already calculated results are going to give us the ability to decide that what what do we do in the current position because we are not only dealing with like simple characters we are also dealing with like a DOT and we are also dealing with a star so this is going to be really helpful and we can use something like recursion to solve this problem but that is going to complicate things we are actually going to use recursion with DP and that is going to make things much more easier so let's try to take one example over here and the question is for a dynamic programming we are not only going because we are dealing with two different like string and pattern it would be better to create a 2d Matrix and inside the 2D Matrix for every single like uh ring and every single pattern we will try to see that whether the characters match or not and based on their true and false values we would be able to calculate some interesting results so let's see that in action with an example and that would make things more clear okay so currently we have created an example for a string and a pattern and we need to check that whether they match or not now also for this pattern I have created a 2x2 matrix where inside every single row represents the string value we have and every single column represents a character inside the patn we have and we will try to see that whether there is a match or not now remember the for the first row and column I have kept it as empty why because uh these we are going to use to create our base case now our base cases that currently for the string the first character we have is empty character and also for the Pat the first character we have is empty character now because these two are empty characters definitely empty characters are going to match for sure so in this case this value is always going to be true now we will try to see that whether there is a match over here or not so in this case because this is an empty character and we have some character over here there is not going to be a match so definitely we would always be able to like have all these values as false So currently we are at this first position this value is F this value is F both of them are characters both are same and when both are same we will also have to check that all the values before that if they are also match or Not So currently the only values before that were two empty strings and that represents this diagonal corner so because this diagonal Corner was true and we have matching set of characters we are going to take the value that is diagonally present and put it at this position for this one one box again I'm repeating myself that because these two characters are same so first we check okay these two characters are same then we check its diagonal value because what this diagonal value is going to do is it is going to check that whether all the values before these two values are they a match or not and this will come in handy when we are at some position like this because if over here we find this a a to be matching which means this value is a true but do we need to keep it as true because if this is false which means if we are say for an example we have string to be fa a and we have patn to be Pa a in this case though these two match but this is not a match why because this F and P does not match so we can break out immediately and that is what we need to keep track of every single time and that is why this is a dynamic programming problem so in this case as explained this is going to be true okay now again let's start filling up this all of these files and uh what we are going to do is okay this one is true now we will have to check that okay currently we have F A and the value we are comparing it against is f is this this a match no this is not a match so this is going to be false again currently the value is fa a star and the only value we have is f is this a match yes this is a match why because for this a star we can actually consider this to be an empty string or zero values of a and if we do that then we will have no values over here so in this case this F and this F is match and why this happened because we had a star value over here and we were get we were dealing with the star value so now again the new theorem comes that whenever we are dealing with a star value we will have to check the value before its preceding value again whenever we are dealing with a star value we will have to check the value before its preceding value and if that is true then we can directly Mark true over here so we check okay this was true so definitely we are going to to put true over here awesome now we are at this position number n now currently what is the scenario we are comparing we are comparing the values of f a star n and we are comparing it with f so n and F there is no match so definitely we can Mark false over here now we add a DOT over here again there is a no match so we can Mark false over here and same way this is also going to be false okay now we are at this position so now we actually have two values F A now for this F A if we only compare it with this value f is this a match no this is not a match so we can Mark false over here okay now after marking false over here uh currently we add this positions okay so f a fa a definitely there is a match so because these a a matches we will compare its diagonal value and the diagonal value we get this result and we will Mark the value over here so this is going to be true awesome now currently we are at this F A star so fa star is this a match with this fa again now we have the star value so we will have to check first thing we will have to check is whether we can consider this to be just like an f and empty string or we can consider this to be an fa a or we can consider this to be an FAA I'm talking about this value right and if we see this f a fa a is all is a perfect match so now because we have a star value again over here we are going to mark this as true but this true we are getting it from the value before because remember in this case you must be wondering that hey for this particular position the this value is actually empty then why are we marking this to be true we are marking this to be true because this one is true because we found a match of f a f a and because this value is true we will mark this as true so let's do that awesome now currently the next value we have is like f a n and this value we have is f a so definitely there is no match we will mark this as false and all of if we add dot we will again mark this as false and blah blah blah right these are all the values going to be false now currently we are at the position of f8 a let me clean this up a bit so currently we have f a a over here and currently we only have F over here so definitely this is going to be false again this fa is also going to be false now again we are at the critical juncture we have a star value now because we have a star value You Must Be Wondering that what will be the possibility well the possibility is again over here for this F A star we can consider it to be like only F or F A or f a a this case we are going to consider it to be f a a now you must be asking that hey previously when we were at this position you mentioned that uh because this is true we are marking this to be true then when we were at this position you mentioned that though this was false but because this was true we were marking this to be true now we are at this position this is also true uh sorry this is also false this is also false then how come we are marking this as true we are marking this as true because this value is true mind blown yes this is like the most important point for this problem that whenever there is a star present we will have to check three different values so whenever there is a star present we were checking that whether the value before the preceding value if that is true we can mark this as true if there is a star present we will check that whether the value before this if that is true then also we can mark it true and if there is a star present we can check that whether the value above it if that is true then also we can mark it as true which means whenever we were at this position if we don't want to get into all of these these like calculations all we need to do is that currently we are at this box then we will have to check three different boxes boxes first box is the right like before box second box is this one like the Box before box and third box is a box above that box so for that this particular box if either this this or this if any one of the value is true we will need to mark that value over here if all three are false then only we will mark it as false and why this happens because this was a star value and there could be bunch of different possibilities we can use over here and this was the most difficult part of this problem and congratulations you understood it perfectly and now because this was true now currently we have this FAA and now we have this like f now we are at the next value so next value is f a star n and this n is not a match so this is going to be false and then all the subsequent values are also going to be the false now this is a very easy problem to tackle because because now we are at this position n so this is not a match so this is going to be false this is also going to be false this is also going to be false and now we are this n n and n because these both of these are characters so there is a match because there is a match we are going to consider its like diagonal value so diagonal value is true so this is also going to be true now this is a DOT value and we only have values up until this point so which means we are going to mark this one as false and we are also going to mark this one as false now again we are at this value number G so all of these are going to be false up until this point now there is a DOT over here and there is a g over here which means there is a match so if there is a match we are going to compare its diagonal value the diagonal value is T so that is true so because this one is true we this is also going to be true and the last value is going to be false because we only have value up until G up till this point and we have this M over here now the last value is okay this is going to be false false false false and this is also going to be false now we are at this last position this m is a match with this m so because this is a match we are going to take its diagonal value and the diagonal value in this case is true so we are going to take this value as true now our dynamic programming table is complete and all we need to do is we need to check this diagonal file and we need to check this last value because this last value was true we can return true in this case and this would be the answer we need to return and that is the whole logic behind this problem and uh this was a very beautiful problem uh if we were only dealing with the dot values this would be much easy to solve but because we were also dealing with the star value it added a layer of complexity now if we see time complexity in this case the time complexity is actually going to be biger of M cross n where m is the length of uh string and N is the length of the uh pattern and if we see space complexity because we are creating a 2x2 matrix basically the space complexity is also going to be big of M cross n and this is a beautiful solution like one of the best dynamic programming Solutions I have seen so far so I hope you would have enjoyed it now let's move on to the coding first we will check for an edge case that if both the values are null we can simply return return null if that is not the case we are going to initialize our uh dynamic programming 2D array and for this 2D array let's name it as DP and we are going to assign the length of whatever the length of s is+ one and also length of p + one and we are going to assign the base value of the 0 0 to be true and now let's populate the first row so this should take care of the First Column now let's start our uh loop so we are going to iterate over I and J which means uh we are going to do two for Loops inside the loop we are going to check for all three different possibilities so first possibility is that uh the given characters uh the p is actually a DOT if that is the case which means it would be able to match any single character we are marking like the DP of I + 1 and J + 1 to its diagonal value now you must be wondering why am I dealing with like I + 1 and J +1 because for the first row and First Column remember we mark their values as zero and we actually started the value of S and P on the first position so that is why every single time I'm going to updating like like I + 1 and J +1 values because the I and jth value is actually located at like z0 position they have they don't have any values so if there is a DOT present we simply check the diagonal value now the second possibility is that both of them are characters and if both are characters and we they both match we can also Mark their value as same as their diagonal value now we are at the third possibility and the third possibility is that if the given character if that is in the patn a star if that is a star then we will have to do some additional calculations so now for first we are at the value star so there could be two possibility we could have some value as like character and a star or we could have some value as like a DOT and a star so if if there is a DOT and a star we only need to check that whether all the values before that if they are match or not and if that is the case we would be good we can mark it as true and uh so first let's take care of the scenario that if the given value is actually a DOT star now we have done that check and then we will check all of those three boxes I mentioned that if either one of them is true we will simply add that value over here with this this value we are actually comparing all of those three boxes so if any one of them is true we can mark it as true and in the end this concludes all the possibilities we can do inside our Loop so basically we are done with our calculation now simply in the end we need to return that what was the last value inside our uh dynamic programming diagonal that should be it let's try to run this code okay seems like our solution is working as expected let's try to run this code and our code runs pretty fast compared to a lot of other Solutions and which is really good in it's great in terms of time complexity and also in terms of space complexity and I would be posting this solution in the comments so you can check it out from there thank you today we are going to do maximum sub lead code problem and if you see some of the companies where I want to get a job who have already asked this question there are companies like LinkedIn Amazon Apple Microsoft Google Adobe Facebook Bloomberg Uber H dance Yahoo eBay and Splunk so that's why I'm paying my at most attention I hope you also enjoy the video so this is a lead code medium problem and very well like problem on lead code basically we are given an array called nums and we need to find a continuous sub array which has the largest sum and then return the sum value we are also told that a sub array is a continuous part of any array so we are given the definition of it now let's try to understand this with an example so suppose this is the example we are given well I have actually drawn this example uh in much bigger form form over here so for this example what we are going to do is we are going to see different sub arrays and then we are going to see that what is the maximum sum we have we are able to find so far and then in the end we will return whatever the maximum sum we have found so first of all this value is actually -2 so because this value is -2 even if all the remaining values they are positive it makes no sense for us to keep this value so we are going to ignore this value and we are not going to keep it in our Uh current subarray now this value is positive one so that is good but again combination of these two is actually min-2 so again we cannot keep this in the our continuous sub array well now this value is actually pos4 and which is good sign now these two value this is again still positive three which is also a good sign and the combination of these three is again five and then we add this value so this becomes six and we are going to keep on updating the max value as well so max value so far we have found so far is six that we can see that up until this point the sub ARA there where we have found the maximum value to be is six now this is again minus 5 so the if we do 6 + - 5 we still get positive 1 value which is again positive so we are keeping this as a sub and then again this value is + 4 so + 4 + 1 becomes + 5 so this is also positive but thing is uh in the end up until this point the maximum value we were able to find is six so because it was six we are going to return six as the answer this is what the problem is asking us to do we need to find the sum of Maximum sub array and then return that value so let's see what would be different approaches to solve this problem basically we need to find the maximum sub array what we can do is we will try to find every single possible sub array try to see the sum of all of those characters and whichever possess the maximum sum we simply return that sum so let's see that in action so first of all what we are going to do is we are going to take some of this character then we are going to take some of these two characters then we are going to take some of these three characters and so on and so forth we are keep on repeating the process with this first element after we are done with this essentially we are going to get rid of this first element and now whatever the remaining elements are we are going to start taking some of those values so in this case what again we are going to do is we will take this element then again we will take these two elements and again we will take these three elements and overall we will keep on making the sum and eventually we would find the answer and the answer in this case is going to be the sum of these three characters and whatever the answer is we can simply return that so this approach would work as expected but the issue with this root Force solution is actually that we are doing a lot of repetitive work if we see the time complexity in this case the time complexity is actually going to be big go of n squ so let's see that what would be the better way to solve this before we come up with the optimal solution first of all let's make couple of things very clear uh what is our aim and what is the thing that we are trying to find well basically we are trying to find that what is the maximum sum sub array at any given moment there can be any current subarray that we are iterating over which could be the maxim Maxum sub AR or could not be the maximum sub AR we don't know but at any given moment we will have need to have the ability to keep track of some of all the characters that are present in that particular subarray so which means that we are going to have a variable called current or current subarray where we are going to keep track of the sum of all the current variables that we we have rated over and we are keeping track of uh well second thing is that we need to find the maximum sub aray and amongst any of the sub arrays anyone could be the maximum subarray so we are also going to keep track of another variable called maximum subar where we are going to keep track of Maximum current sum we have found so far so well these two things are understandable right uh they are from programming perspective but there is also one more thing that is actually rational and the rational thing is that at any given moment suppose this value is actually minus 3 so current Su sum or current sub array we have found is actually minus 3 so if this value is min -3 because this value is negative so if this value is negative even though all the remaining values they are positive and they keep on increasing the value in size this minus 3 is always going to have to cause them to have a lesser value so if that is the case why are we even bothering to keeping this value at our Bay or at our disposal so the idea is at any given moment for our current subarray the moment we would identify that the current value or some set of current values they are causing it to have a negative value if that is the case we are going to immediately update our current sub array and then we will keep on moving towards the next values and based on these two Logics uh all we are going to do is we are going to iterate over our given array and keep on going to updating the current sub array and then keep on updating the maximum sub array we have found so far and in the end we should be able to find the answer so let's see that traversal in action before we start iterating over this V we are going to Define some default values for this current and maximum variable the default value for current is going to be the zero and for maximum it's going to be whatever the first element of this given arrays which is minus 3 that is to cover an edge case where we are only given one element now let's start iterating over Okay so now uh the sum of these two elements is actually going to be - 3 + 2 so - 3 + 2 is actually going to be minus1 which is still less than Z so because this is less than Z we are not going to update our current Max variable and the maximum sum we are actually able to find so far is going to be zero which is definitely greater than -3 now again the for these three variables again the sum is going to be negative so we are not going to do anything and we are going to ignore all three of these cases now this value is actually positive so because this value is positive the current sum we have is going to be eight so which means we'll have to update the maximum sum we we have found so far to be the value 8 as well now again we add the sum of these two values so 8 + -1 so 8 + -1 actually becomes 7 so this becomes 7 Which is less than whatever the maximum value value we have found so far so we don't need to update the max variable now we again add this value to our current sum so 7 + 2 7 + 2 is 9 9 is greater than whatever the maximum value we had so this becomes 9 okay now again this is also a positive value three so we can do 9 + 3 which becomes 12 so we are again going to add the value 12 to our maximum sum that we have we have been able to find so far and then this value is actually -5 so we can do 12 + - 5 so 12 + - 5 is going to be 7 and again because this value is still positive we are keeping this current sub array going on because we we don't know future values might be positive values and this can also go up pretty quickly now uh we are we have actually reached to the end of this uh array and we don't have any more elements to go over so the maximum sum we have found so far is 12 and this is what we need to return as the answer in this case uh and so this is the most optimal approach to solve this problem if we see time and space complexity in this case the time complexity is going to be big of n why big of n because we will have to iterate over every single array or every single value that is present inside this given array which takes big go of end time if we see space complexity in this case the space complexity is actually big of one or constant space because apart from storing these couple of variables we are not using any additional space so that's why space complexity is very minimal first of all we are going to initialize two variable called current sum and maximum sum for current sum we we are going to initialize the value to be zero and for maximum sum we are going to initialize the value to be the first value inside this given nums array we are going to create a for Loop to iterate over this given array now we are going to check that whether the current sum if that is less than zero or not if that is less than zero we are going to update the value of current sum to zero that is not the case we are going to calculate the value for current sum and maximum sum so current sum is going to be current sum plus whatever the current value inside this given nums array we have and we will have to check that whether the current sum we have created if that is the maximum sum or not and after Loop ends we simply have to return maximum sum let's try to run this code seems like our solution is working as expected let's submit this code and our code runs pretty efficiently I would be posting this in the comments so you can check it out from there thank you hello friends we are still not employed by Fang company so let's not stop lead coding till we get there today we are going to do Jump game problem recently this problem has been asked in Amazon Facebook Apple Google Oracle Tik Tok all these gigantic companies and uh they are some of my dream companies so I'm going to do my atmost focus for this video and I hope that you uh find it enjoyable this is going to be the framework for the video first we are going to understand the problem then we'll come up with a Brute Force approach we'll improve our Brute Force approach we'll find the optimal solution and then we'll write the Java code for the the optimal solution this is a medium problem and we are given an integer array nums and we are initially positioned at the first index so zeroth index each element in the array represents that the ma that is the maximum jump we can take and if that is true can we reach to the last position so if we are able to reach to the last position we would return true if we cannot return reach we can we will return false so let's understand this with an example suppose our given input is like 2 3 1 1 and 4 and initially we are located at this position this is the same example over here so we can see that if we over here we can take maximum two jumps so either we can take one jump and reach over here or we can take two jumps and reach over here let's let's get the gredy approach and we'll take the maximum number amount of jumps so over here if we take two jumps we end up over here over here the maximum jump we can take is only one so we can we will reach over here again the maximum jump we can take is just one so we'll reach over here and this is our last position so since we have reached over here which means that we can conclude that we can uh solve this Jump game and we can reach to this end position so we'll return true in this case now let's take one more example so suppose we are given input like this 3 2 1 0 and 4 and if we check for the possibility so over here the maximum number of jumps we can take is three jumps so if we take three jumps we reach at Zero from zero we can't move any any anywhere for forward uh so let's rather than taking three jumps we'll try to take two jumps so if we take two jumps we end up over here and over here the maximum we can take is just one jump so again we end up at zero and lastly rather than taking two jumps from here we'll just take one jump so we'll end end up over here at this position number two now at this two the maximum jumps we can take is two so again we end up at the zero which means that in any circumstances if we start at this position number one we cannot reach to this last position so over here we would return false this is basically the problem statement uh I have given a custom example that we are at any position we are going to first of all see that what is the maximum jump we can take we'll try to make that jump we'll try to see that using that jump if we can reach to this end index if we cannot reach to the end index somehow we will backt trck we will go back to the position where we initially took the jump from and we'll try some other possibilities so let's see that in action so over here we are initially at this position number two the maximum jump we can take is at Value number two so that jump will bring us over here now over here the maximum jump we can take is at uh this position zero which means that we can't move any further so we will backt track so we will backt track we will come back over here now again we are at the second position now let's rather than taking the two jump we will reduce our jumping possibility and we will just take jump of one step so now we reach at this value number number three and over here with this value number three we can take maximum jump of three steps which means that we can if we take three steps we will end up over here so 1 2 3 and at this position two the maximum number of steps we can take is two which means that even if we take two steps we will cross our last um entry which means that in any case we would be able to reach to this last element and we would return true in this scenario now this approach seems sensible on pen and paper because we are dealing with a small number of uh things U small small number of input and we are able to clearly see that how the pattern is going on so let's take another example so these are the values let me also denote the index values for these now with every single iteration I'm going to note down the uh in the index value transition we are making okay so initially we are at this position number five the maximum jump we can take is a five step which means that we would end up over here so initially we would do something like this so 0 25 this is one one step we take we are at zero position which means we can't go forward which means we have to backtrack which means that again uh from five we will come back to this zeroth index now from five rather than making a jump of five steps we will make jump of four steps and we would end up at this position four so from zero we would end up at this position four now from this four the maximum jump we can make is one so again we will take one step jump and we would end up at this position five again from we are at zero we can't do anything so we will have to backtrack so in order to backtrack we will go to go back to this position number four again we have to backtrack from this position Force we will end up at zero again we will rather than making a jump of four step we will make a jump of three step and we'll end up over here so we end up over here and so on and so forth so you can see that this uh in this approach all we are doing is just we are going some place we are coming back again we are going we are going and then again we are coming back again we are going to some next element we are going to some next element and we are coming back and suppose this keep keeps repeating multiple times uh you are essentially depleting your resources because if you see the time complexity at any single iteration uh or at any single value we have two possibilities whether we wants to keep this value in our current transition or we do not want to keep our Val keep this value in our current uh path that we are calculating which means that the input if we make decision tree the decision tree would would keep on growing and growing with uh addition of every single value which means that uh we are basically making lot of decisions and the time complexity in this scenario would actually be big go of 2 to the power n because at every single position we are making two possibilities this is a very bad exponential time complexity which we cannot allow in any scenario okay so the issue in the Brute Force approach we had is that we were doing lot of repeative work because at any point we found out that we are not able to make any progress from this point we are still ending up at that point so let's see that how can we counter that with a better approach suppose we create an additional data structure over here so we create a dynamic programmatically additional data structure over here uh let's create an array and in that array we are going to Define that at any position can we reach to this end point and if we identify that yes we can reach to this end point uh we would basically fill that position as true and let's see that how it can help us so if at any point in time we are at this final position we know that this is the main uh terminating case which means that we can put true over here so this final element we can always put true and this would actually become our base case now we have a base case we are going to start iterating on from right to left Manor and uh we are going to start filling up our DP array to see and in the DP array the only thing we are mentioning is that at any given location if we are able to reach to this end point or not if we can we'll just mark it as true otherwise we'll mark it as Falls okay so now one step over here this is uh this value has potential to make two jumps uh and it only takes one jump to get to this last point which means that if we end up at this fourth position we can reach to this fifth position which is what we want so over here we can also fill this as true now we are at this zeroth position from this zeroth position can we reach to this fifth position no because we cannot we can basically can't make any jumps so we'll just fill this as false okay now from this one can we end up at this fifth position so we are going to now the interesting part comes now we are going to check that okay this is possibility of of only doing one jump right so with one jump we can only end up at this third index now we only need to check that in this DP array for this third index if the value is true or false so in this case this is already false which means that the maximum we can get to is this third place from this third place we can't go anywhere so we don't even need to check these values we can only check this DP table and we can conclude that no we can't go anywhere forward so we will put a false over here as well now we are at this third position now from this third position we will again do the same check but thing is this has potential to do three jumps okay so let's do one jump at a time so First We Take a jump if we take a jump of one step we end up over here we check over here that this is false which means that this is false right now we take second jump with the second jump we end up at this third position we check in this DP array this is also false which means that we can't do anything now from this third position we still have one more possibility that we can take a jump of three uh values so if we take a jump of three values we end up at this position value number uh this index number four so for this index number four we we see that the value is true if we find any true which means that we can say that from this second uh this index uh index number one one we can reach to this last end point and now for this position we need to check that it has potential to do two jumps we will only check for one jump so with one jump we will end up at this first uh uh index that one is true which means that we can fill true over here as well and in the end we just need to return whatever of DP of zero we form so in this case we can determine that this uh is true which means means that we are able to come to final uh end point so this solution is very good it works perfectly fine okay so the time time and space complexity for this approach would be so the time complexity would be bigo of n Square because notice that we need to do one iteration to go on the to for every single element and sometimes for any given element we might have to do multiple jumps like we did in this case of three so in the worst case we might have to solve this in bigo of n Square time and the space complexity would also be bigo of n uh because we are creating this additional DP now this is still much better than our Brute Force approach but our aim is to go into companies like Google Facebook Amazon apple and whatnot so those companies expect the best out of the best Solutions and is this the best out of the best Solutions we can do uh actually no there is still a better optimal solution and let me show you how we can get there okay and this optimal solution is actually based on uh the dynamic programming solution that we just saw so in dynamic programming what we are doing is we are creating an additional DP array and we are storing that whether we can uh reach to this last element or not but thing is what if rather than storing this value at any position when we find out that suppose from this position we found out that yes we are able to reach to this last position so why do we need to check that whether we can reach to this last position or not if at any point amongst these values if we end up at this position we would still be able to guarantee that we can reach the last element because we have already checked this this condition so rather than checking to for this whole thing if we just check that okay from here if we can reach to this element or not and if this is true we can simply return true at that moment also and let's see that in action so let me clean this up a bit let's mark all the index values okay initially we create an element called final and this final element represents the last value in the uh given input and initially we set it up to this uh index number five right now our aim is is that at any point we found out that among these values if anyone can reach this final element then that element by itself becomes this final so rather than storing all the values of at any given location we are actually shrinking down our boundary of search initially the final is at this fifth position now we are at this second position so all we need to do is to check that whether our current index I uh our current index and this current value if some of these two is actually greater than whatever final we have So currently the final we have is this uh five so this is the final we have current sum of these two values becomes 4 + 2 is equal to 6 which is greater than 5 which means that we can update the fin value of our final so now so now this becomes our new Final and we basically don't care about this value anymore now we are at this third location and we try to see that uh the index plus its value so this will this becomes 3 + 0 is it greater than our final no this is not greater than our final because this is three and this is four which means that we can't do anything over here so we drop this calculation and we check with the next element so over here we have this two and we have the value one so 2 + 1 is this uh greater than four so greater than final no this is also not true which means we can't do anything over here we again go back now this is 1 and this is 3 Now 1 + 3 is this greater than or equal to Value 4 yes this is greater this is actually equal to four which means that we from this point we can come to this point this is what this concludes and which is what we want right so now we know this inform which means that we can update the value of our final again so now the Val the value of our final would become one so at this value and now at this zeroth position we need to check that whether we can reach to this one or not so current so over here the sum of these two value becomes 0o plus uh this is two so two is definitely greater than the final amount we have is 1 which means that we can reach over here so the final element would be shifted to this point and our at the end of our iteration the final would be zero so now the final is zero after the end of the iteration we only need to check that what is the value of final if final is zero we return true if final is anything other than zero we return false and this is a very good solution the whole thing runs in the time complexity of bigo of n and if we see the space complexity we are only storing one additional parameter so we are essentially using constant space and we are solving this problem so this is a very efficient solution let's create a variable called final oh I Java I can't use final let's call it final with an extra L and uh we will assign it value as uh nums do length minus one and now we'll run a for Loop and we'll start it from I is equal to uh number of length nums do length minus 2 because we already know the result for uh the array length and we will run it up until we reach to this zeroth position we'll do I minus minus and inside the loop we are only going to check one condition that if uh the current value of I plus nums of I if they are greater than or equal to whatever the final value we have we can uh update the value of this final parameter to whatever the I value we have and uh yeah that's that should be pretty much it now we only need to check that if uh the value of this final character is uh zero or not so if it is equal to zero we can return true else we can will return false okay let's uh try to run the code seems like our solution is working let's try to submit the code okay our solution works 100% faster than all the other Solutions this is really good sign and uh this is not constant time but because we are basically shifting our uh boundary we are essentially reducing the number of work we can do we can do and also if you see the memory usage we are actually better than uh 86% of all the other Solutions so this was a very small line of code but this uh small line of code actually requires huge set of understanding so see you in the next video thank you [Music] Hello friends I a cloud Solutions architect at Microsoft who like making lead code videos and today we are going to solve an awesome problem called Jump game 2 if you is some of the popular companies who already asked this question there are companies like Amazon Google Goldman sax Bloomberg door Dash Uber Microsoft Apple Tesla Tik Tok Snapchat and bite dance so that's why I'm paying my at most attention I hope you also enjoy the video so this is a lead code medium problem and also very well- like problem on lead code basically in this problem we are given an array of integer called nums as an input and we are told that we are initially positioned at the first position inside this given array now our aim in this problem is to return the minimum number of jumps required to reach to the last position now you must ask that how are we going to make these jumps what are the criterias for that so the criteria for any jump is that any given value that is presented inside this given array represents the number of values it can jump so basically if this one is represented to we can say that it can reach it can either take like one jump or it can take two jumps and reach to these positions and our aim is to reach this last position and basically we need to do this in the minimum number of jumps that is required now if you are confused don't be I'm actually going to show you a couple of examples uh to understand that how things work so basically over here we are given five different values and for these five different values as I mentioned earlier every single value represents the maximum number of jumps it can take so this value number two has two possibilities it can either take one jump and reach to this position number three or it can take two jumps and reach to this position number one same goes with value number three it has three options it can take like one jump two jump or three jumps and then uh do that and our aim is to reach the last position from the first position in the minimum number of jumps possible so if we see see in this example the answer is actually quite evident uh we start our position at this value number uh two and uh if we just take like first jump to reach to this value number three okay so currently the number of jumps we have taken is one now from this value number three if we take another jump of the size three basically we would be able to reach to the end position and in total we are only taking two jumps to reach to the end so basically we need to return two as the answer in this case if we try to understand the second examples things are a little bit different so in this case we can only take one jump so okay so currently the number of jumps we have taken is one now from this one we need to take one more jump to reach to this position so again the number of jumps we have taken so far is two now from this two we have two options either we can take one jump and reach over here but that is not the most optimal way most optimal way is we take a jump of two steps and reach to directly through this end point so basically the answer in this case is going to be three that we need minimum three jumps to reach to this last position and in this case we need minimum two jumps to reach to this last position so this is what the problem is asking us to find and uh I know it can look tricky but it's really simple to do it and uh let me show you couple of different uh approaches to solve this problem okay so the first approach that comes to our mind is a Brute Force approach and in The Brute Force approach basically we are just going to use the simple Logic the log logic is that at any single position we will try to see that how many jumps it can take and try to explore all the possibilities and try to find that how many jumps it takes to reach to the end element and also have like a minimum variable in mind that whenever we find minimum number of jumps we will keep on adding it over here and eventually when we compute all the calculations we should have a result so in this case what we are going to do is that okay this value is two so first we will consider the possibility of just taking one jump so in this case okay if we take one jump we reach over here again we have three possibilities over here but we are only going to take one jump so again we reach over here again this only has one possibility so we reach over here and then we reach to the end so in this case we took in total five jumps to reach to the end now secondly we are going to take like different things so first we will take two jumps uh so we took two jumps and now we take one jump every single time and try to see how when we reach to the end and so on and so forth we keep on repeating the same process with different combinations now just by the explanation you can imagine that how complicated it's going to make things because for every single time you will have to calculate different permutations and combinations of sums and eventually it's going to lead to very disaster results like if we see time complexity in this case it's going to be in the order of n factorial because for every single element we will have to compute the process for all the other elements and that is going to be in the order of big of n factorial which is really really really bad bad so we will have to find a better solution and the better solution is actually quite simple so let me just directly go to the optimal solution and now for the optimal solution we are actually going to use a very interesting concept called greedy concept and basically we are going to try to make the biggest jump possible every single time and try to see that where does that leads us now being greedy is not good in real life but in computer science it is like the must thing so you have to do it now uh for the greedy approach we are actually going to keep track of four different variables so first variable we are going to keep track of is the index value we are currently at so let's just name it as index uh again we will also have to keep track of the number of jumps we have made so far uh also we will have we will need a variable to keep track of current maximum variable that we have been able to reach or current maximum value we have been able to reach and also from the current index we will have to keep track of that what is the current uh end value we can reach at so there are four variables let me go over them again first one is the index value second one is the number of jumps we have made so far these two are sensible third one is to keep track of that what is the current maximum value we have achieved so far and we will only update it when we find like a better maximum value when we go through the example everything will make more sense and the current end defines it is in correlation with the index value that where does the current end lies and if we are at the index value then we will have to make some changes so now let's look at the example and uh currently Let's uh initially assign the values so initially the number of jumps are zero current maximum is also zero and current end is also zero uh now we start our journey so first we come up at this first index so whenever we are at the first index okay the index value currently is zero now the index value is zero now let's just keep on updating these values right so currently this has value number one so if this is value number one which means means that this zeroth index has the potential to reach maximum at the first index which means the current maximum value we can achieve is that okay this current value is zero now over here it says that it has maximum potential to reach index value number one so one is definitely greater than zero so because it is greater than zero we will update the value of current maximum to one that okay this is the maximum value we have been able to achieve now the interesting part comes the current end we were at the current end was Zero because we were at the zeroth position and also the index value we were at was also zero so because both of these values were same which means that in order to get ahead to the next index which is not the last index again remember I'm repeating in order to get ahead from the current index which is not the last index we will have to update the current end because currently the current end was also here and the maximum value was also here but this is the value one so we have the ability to go to the next which which means the current end needs to be updated and whenever both of these are at the same place that means if we are updating the current end value we will only update the current end value in the condition when we are making the jump so again let's just go back to our analysis because the index value and the current IND current end both were same so because these two values were same we can Define that we need to update their values which means we are taking a jump so okay so we made a jump so we will do jump plus plus So currently this value becomes one but thing is where do we update this current n to we will always go this current n to the whatever the maximum value we have been able to find so far so current maximum we found is one so again we are going to include this value number one over here now let me clean this up a bit so now we are at index position number one so we will update our index value so our current index value is one now at this position what is the maximum it can travel maximum it can travel three points so 3 is going to be 1 + 3 so that is four so now this is the current maximum we can achieve that is four so we will compare four with the current maximum we had current maximum is one so four is definitely greater than one which means it is sensible for us to update the current maximum so current maximum becomes four now uh we will also have to check that what is the current end now current end is still same as the index value because this was the current end so which means that anyways we will have to make a jump so because we are making a jump we will update the value over here so currently the number of jumps we have made so far is two and we will also have to update the value of the current end so max current end we can reach is position number four because we already established that that is where the maximum number of jumps we can take so okay we are good up until this point now again let's make the changes so now uh we are at index number two so let's see that what store happens at index number two now index number two uh the maximum we can take jump is one so if we take one jump we reach at index number three but the thing is if we check the current Max current Max is already four and the maximum we can reach is three so three is actually less than four uh so in this case we don't need to update the current Max okay awesome we are not updating the current Max and now we check okay current end is four and the index value is two so these two are not same because these two are not same we don't need to update the current end or the number of jumps that we are taking now okay now our index value keeps on updating because we are checking this for every single index value so now we are at position number three so now at position number three we have maximum three possibilities right so if we go to three steps we reach to the index number six so our current maximum will become six because definitely 6 is greater than four now we updated our current maximum now we also need to check few other things okay so current end and index value these two are not same so we are not going to do any changes for now so now our index value becomes four so let's update this okay so this becomes four now we are at this fourth position this uh only has possibility of one so this this will reach to the maximum of five but five is actually less than six so in this case we will not update the current maximum now in this case the index value and current end is both are both of them are same so because both of them are same we will have to do the update so now when we do the update okay we are going to Mark the current end as six because that is what the current maximum we have been able to achieve and also the number of jumps we are going to take is going to become three okay now again we keep on repeating the same process so again our index value becomes five now because with the with the five index value um the maximum we can take is one so that is going to lead up to six because but we we already have current maximum at six so we don't need to do anything and these two values are not same so we we are not going to do anything now the index Valu is at position number six now at position number six we are actually able to reach to the end uh with just a single jump so we are going to do that okay now we reach to the end of the this jump but the thing is we are just going to for the sake of Simplicity go ahead with this calculation so the current maximum we have been able to achieve is going to be seven that is the end now uh current end and the index value both of these are same so because both of these are same we will have to update our number of jumps that we need to take and also we need to update the current end so current end in this case is going to be seven and we are going to check that if the current end reaches to the last position or the size of the array that means that is the answer and we can break out of the loop and whatever the answer we have been able to find we can simply return this so in this case for this example the answer is going to be four that we can return simply and this is the most beautiful approach of the greedy solution that I have seen so far now if we see time and space complexity in this case the time complexity is so good because we are only going through every single values and calculating keeping track of four different variables so time complexity is actually going to be big of n so notice that from bigo of n factorial we were able to bring it down to Big off n and all due to the gredy approach that we took if we see space complexity in this case the space complexity is actually going to be big go of one or constant space why because we are not using anything else apart from like these four values so that is also a wonderful news so let's initialize three variables that we need that is going to be jump current end and current maximum and initially all the values are going to be zero now notice that I'm not using the index value over here and that is because we can actually use it from our Loop d directly now let's run a for Loop to iterate over the given input array so now every single time we will check that what is the current maximum we have been able to achieve so we are basically going to compare the maximum value amongst the existing current maximum value or the value of I plus uh whatever the value of nums of I for that particular I is and whichever is maximum we are going to put it in the current maximum now we are also going to check one very critical condition that if the given I is actually equal to the current and we are at if that is the case which means we will have to update the value of the jump so we will do jump Plus+ and we will also have to update the value of the current end so current end is in this case going to become the current maximum that we have been able to achieve and believe it or not but this concludes the whole solution uh after uh we get out of the loop we can simply return the jump that we have been able to find and uh this should be it let's try to run this code okay seems like our solution is working as expected let's submit this code and if we submit it this is beating like almost 99.999% of the solutions in terms of time complexity and in terms of space complexity this is also very efficient so this is a very good solution and if you see we are just only using a single Loop and just like few lines of code to to solve this problem and uh I will be posting this in the comments so you can check it out from there thank [Music] you the lead code problem we are going to solve now is called gas station and we can see that this one is a lead code medium problem and also a very very very well- like problem uh the statement is quite straightforward that there are n gas stations along a circular route where the amount of gas at any particular station is defined in the array gas fi and then we are told that we have a car with unlimited gas tank that cost cost of I gas to travel from I station to the next I + one station let's re do a quick recap basically we have we are given two arrays first array is called gas and second array is called cost uh basically gas any particular value inside the gas area defines how much oil or how much gas we can fill in the tank at that particular location cost at that station defines that if we have to move to the next stop uh what is going to be the cost in terms of gas amount So based on distance you can understand it that way now we begin our journey with an empty tank at one of the gas stations okay now we have uh basically need to make sure that given these two arrays uh we can start from any particular gas stations index and we need to check that if from that gas stations index are we able to travel around the entire circuit once in a clockwise clockwise direction if that is the case then we need to return the location of that index if that is not the case we need to return minus one and we are guaranteed that we would be able to find a solution so if there exist a station there has to be only one station that can fulfill that Pro property otherwise it would be minus one there would not be any duplicated answers so let's try to understand this with an example uh currently we are given a variable called gas and we are also given variable called cost uh at any particular uh index position this is the amount of gas we can fill in the tank but if we need to go to the next stop then this is going to be the cost associated with that and so on and so forth so let's try to see that what would be the answer in this case let let's say that suppose we start our journey from index position zero which means currently our car has uh so let's just mention that what is going to be the uh tank uh amount of gas in the tank okay so currently tank has empty so no no gas at all at position number one we would be able to fill in one amount of gas so currently tank has only one amount of gas now let's say that if we need to reach to next position uh index position number one then we will have to pay this cost if we were to pay this cost it would be 1 minus 3 so basically we our tank would go in negative so we would not be able to reach to this position number two from tank number one so we can clearly say that option zero it does not work same way we can also check that from option number one currently our tank would be initially zero okay let's just repeat the calculation so this is going to be zero but now we can fill in 10 uh plus two so now the gas would be two but if we have to get to option number three then we would have to spend 4 units or 4 L of gas which means 2 - 4 would become minus 2 once again we would not be able to reach to uh item number four so that would also not work so let's just start our iteration from this third index position once again repeating the same logic currently tank is going to be zero but we can add tank as three so three and uh but if we are to reach to next station we the cost is 5 so 3 - 5 once again this would also not work so now we are at this uh index position number three So currently our tank is going to be zero so we can add value number four so now tank has 4 L of gas if we have to reach to Value number five then we need to spend 1 liter of gas so once again this is also going to be 4 - 1 so basically when we reach to this index position number five our tank would have three units of gas once again at this position we would fill in five units of gas so this is going to be 3 + 5 but now from this in the clockwise clockwise Direction basically we will need to reach to station number one but we will have to pay cost of two so 3 + 5 - 2 so overall this is going to become uh once again six so we are going to have six units of gas when we reach to this position number one once again over here we will add one unit of gas but in order to reach to next element we will have to spend three units of gas so now when we reach to this index position number two our gas is going to be uh 6 + 1 - 3 so 7 - 3 so basically this is going to be 4 Once Again from this position number two uh we need to reach to position number three so 4 + 2 minus we will have to spend four units of gas so basically this is going to become two and at this position once again we will uh we will we get three units of gas so 2 + 3 minus if we have to reach to next which is from where we started then basically it's going to be five so 2 + 3 - 5 is going to become uh zero so basically we would be able to reach to uh unit number four and this is going to be the starting point if we were to complete the whole circuit so we'll need to return the index position so we can return return three as the answer over here and I know the explanation took a lot of time to understand what this problem statement is but basically this is is actually the whole solution as well because in order to solve this problem we don't need to use any special data structure or any special architecture basically if we just follow the most simple basic rule that we are going to start our iteration from the very first index and from this very first index position we are going to check that are we going in a scenario where our current tank goes negative if the current tank goes negative we can simply choose the starting point as the next element and once again if it goes negative we can choose the starting point as next element and we will keep on repeating the same proc the moment the tank goes into negative we will just update the tank value to become zero and that is the whole logic of this problem to solve this problem now let's talk about some of the critical possibilities number one scenario is the only way we are not able to complete the whole circuit is a very simple logic that is that if the given gas is going to be less than the total number of cost if that is the case cost is higher so we would not be able to complete the full circus C circuit and we can calculate this immediately basically by summing up all the values that are currently present in both gas and cost arrays and we can just compare those values so if that is the case we can simply return minus one immediately saying that this problem cannot be solved if that is not the case then we will simply follow the most common most logical thing that humans are really good at and that is called greedy approach that we are simply going to to take the first value try the solution if solution works great if we at any given moment find the T goes into negative then we will just pick the next value so over here for the same problem I have just presented it in a different manner currently we have our index position stored inside so 0 1 2 3 and 4 now this second Circle defines that how how much amount of gas can we get at any particular location and the values located at these Gates Define that if we have to jump from gate number one to gate number two then we will have to spend three units of gas and which we can sub subtract so basically the solution is that we will start uh our greedy approach by iterating at Value number one with initially the tank is going to be zero and then we will just repeat the same exercise we did so we will check okay over here we can add one unit of tank but this is going to be three units of tank to reach to Value number two so tank would go into negative so basically we would choose our starting point over here uh by resetting the tank to be zero once again two and this is four so tank goes into negative so once again we would choose our starting value to be index position number two once again tank goes into negative so once again we would choose our starting index to be this the moment we find a starting index that where the tank does not go negative we would try to iterate over and see if we are able to complete the whole journey or whole transaction and basically we should be able to do it in this case because we know that we have have a starting point where the tank does not go negative from to when we start iterating and secondly uh the total cost of basically um total cost is basically uh not less not greater than uh the total number of gas so that's why we know that the answer should not be minus one and uh just that's it so in this case we would return three as the answer if we have to calculate time and space complexity it is quite straightforward for time complexity basically this can be done in big off end time if we apply the greedy approach and we do some slight tweaks with the code so the tweaks with the code I'm going to explain you when we get when we actually get to the coding portion and for the space complexity well we are not using any additional space to solve this problem so basically this is going to be big off one so which is quite beautiful now let's just quickly see the coding solution so the solution is quite straightforward first we are going to have a few variables uh they are going to be initialized at zero first one is total gas and total cost both are initialized at zero then we have tank and then we have starting index then we are going to have simple for Loop that is going to iterate over every single starting point in the given input we are going to have two variables total gas and total cost that is going to be continuously adding the total amount of gas and total amount of cost we have for the current proportion of gas that can live inside the tank is going to be calculated by adding the current gas with the current tank value and reducing or removing the cost of the current I position then we are checking for a simple condition that if the tank goes into negative then the starting index that was originally at zero now needs to be at I + 1 position because we identify that the current I position does not work and then the current value of the total amount of gas inside the tank is also going to be zero then we are going to check Che at if at any given moment the total amount of gas becomes less than the total amount of uh cost after the running of whole for Loop then if that is the case we can simply return minus one and if that is not the case we simply return the starting index and this is the whole solution let's try to run the code okay seems like our solution is working beautifully let's submit this code and our code beats 99.29% of all the other Solutions which is exceptionally fast so pretty good and once again I will be posting this solution in our GitHub repository so feel free to go ahead and check it out from there thank [Music] you hello friends hope you're having a fantastic day today so now we are going to solve an awesome lead code problem called hand of straits now we can see that this one is a medium problem and also a very well- like problem on lead code let's understand the problem statement we have a girl named Alys who has some number of cards and she wants to rearrange these cards into a groups such that each group of the size group size consist of group size consecutive cards so let's try to understand what this means basically we are given an in array called hand that defines bunch of different values inside a deck of cards and at any given integer I is the value return for that particular hand now we are also given another variable called group size now we need to check that whether we can divide all of these hands in a group in group sizes like groups of the these group sizes such that that all of the rearrange groups contains consecutive cards and we can rearrange all the groups so let's try to understand this with an example and then it would make much more sense let's say that we are currently given the hand or deck of hands like this and we are given the group size to be three so let's see that can we create the different uh SI three size groups so first group we can create is going to be cards 1 2 3 now notice that there is a condition when we when we are trying to create the groups that every single card inside the group has to be consecutive so we can create this one group second group we can create is is using these three characters and that is 2 3 and four and third group we can create is using 6 7 and 8 so now notice that in this case we used all of the cards that were currently given to us and we divided them into the size of three and each group contains the cards that were coming in consecutively so in this case we can say that we can create the hand of stats using this so we will return true in this case let's take one more example suppose the given hand is values 1 2 3 4 and 5 and in this case we are given the group size to be four so in this case we can create a group of size four with these four characters or with these four characters both of which are going to have consecutive values so values would be 1 2 3 and four but thing is we would still have one value one more value left that is going to be left out that we cannot use so in this case we can return false because we are not able to create or use every single card inside our hands array let's take just one more example let's say that currently the values given are 1 2 3 and uh five 6 and 8 and in this case the group where that we are trying to create is of size three so we can see that we can create a group 1 2 3 like this no issues with this we can also create a group of three cards using five six and8 but thing is this is not going to be a correct group because we need to create a group that only contains consecutive elements and five six and eights are not consecutive cards If This Were to be 5 six and seven then it would have worked so because of that for this particular example we will have to return false so that's it this completes my explanation on what the problem statement is actually asking us to solve let's see that what is going to be the optimal approach to solve this problem well the idea is quite straightforward what I'm suggesting is that we are given currently the hands and we are also given uh group sizes now we know that for this particular given group sizes we will have to create groups the values inside the group has to be consecutive so first thing that comes to our mind is that if we are doing dealing with consecutive or subsequent values why don't we just simply sort the given input of hands and then try to start creating groups according to that do you think that approach would work let's try to see that approach in exam action let's say that this is the current hand that we are given now we are trying to use our first approach where we are going to sort every single value inside our hand array and try to create groups of size three so the sorted hand is going to look something like this now notice in this problem if we try to create groups of three we would not be able to make consecutive groups we would run into this issue if we create a group of three we would have a group that looks like 1 2 and two and based on this we can just say that this is a false group and we cannot make sense of it uh but this would not be the correct cor correct assumption correct assumption would be that if we identify two values that are same in frequency then we only need to consider the first value for the partition of first group so the idea in this case would be that we would create a group that is going to be 1 2 then we found a repeated character so we would ignore this one and add value number three into a group after creating this group we will check that whether there has been any values that are currently left so yes this two has been left so let's use the same operation so now we are going to create one more group using this two now notice that we have already used this three in the first group so we are going to be eliminating that and then we can have we will have values three and four in this case so we can also repeat the same operation and then uh after all the values that we have currently used we will keep on trying to make partition and trying to check that whether they follow the property of them being consecutive or not so in this case based on this approach we can actually find the solution which means number one there are few assumptions we can make based on this number one sorting is going to be greatly helpful second thing is we come into the issue of duplicated numbers so we will need to know that what is the frequency of every single character and if we can combine these two values store that information that have the sorted values of all the unique values that are present and have the frequency that that how many times they are currently present it would be easy for us to make these these groups and if we are able to make subsequent groups that follow the all the property and we are able to use every single value inside the hand we can R return true or we can return false so using this what I'm suggesting is that we actually use something smartly we use a a hashmap and we use uh sorting approach now the thing is why are we why am I suggesting to use the hashmap because we are dealing with uh unique entries and and for each of the unique entry we have different frequency and this is what I'm suggesting that we store as part of the hashmap where as a key we are going to store that what is the current value of the hand and as it subsequent value we are going to store that how many times that hand has been repeated in any particular iteration next after storing this information we will have to sort all of these given keys because we are trying to generate consecutive values one by one so logically why don't we just combine hashmap and sorting at the same time where we can simply use a tree map that is going to have Best of Both Worlds that that can access and fetch all the elements in bigo of one time and it can insert all the elements in B of log and time for the frequency and stuff like that because based on the key value so this is going to be an efficient approach so now what I'm suggesting is that we are currently given our hand that we are we are going to be dealing with for this particular particular hand what we are going to do is we are going to create a tree map this tree map is going to contain the unique Value Plus their frequencies and for these two using these two values we will start creating groups of bunch of different numbers and we will need to make sure that the starting if the starting value of group is let's say five and the group has to be of size three then next value has to be six and next value has to be seven if we can find six over here that's great if we cannot find six at any given moment we can directly return fall saying that this group is not being able to make so let's try to see my solution in action so now based on the hand we have our tree map ready notice in the tree map we have every single key or the hand value is currently sorted and we also have the frequency that how many times this is present now we need to create the group size three for every single value uh so the idea would be that for very first group we are going to take the smallest value out and we are going to reduce its frequ frequency and this is going to give us the starting point for that particular group so starting point is going to be one which means this has to be a group of size three so next subsequent element that should be in the group has to be value number two but thing is we are not sure if two is present or not and lucky for us we can check that immediately that whether two is present or Not by the way when we took this one out we would have reduced it frequency so we can reduce the frequency to zero the moment frequency becomes zero it would make sense to El completely eliminate that element rather than just storing it so we can eliminate three now we are looking for two we found two and which means we can also reduce the frequency of two so now the frequency is going to be one next thing should be three so we are trying to find a three and we also found the three over here we are also going to reduce its frequency from one um uh two to one so now this is also going to be one and we created our first group now for the second group once again we will check inside our hash map or tree map that what is the smallest element and this is going to be the very first value inside our tree map that is starting point is value number two so now we are going to use value number two over here which means its frequency is going to become zero if the frequency becomes zero we can mark it a zero and then uh next element should be three so we will check that whether three is present yes three is present so we are also going to Mark its frequency to zero once this becomes zero we can also eliminate this value and we can also uh look now we are looking for next element to be four four is also present and we can mark four as counted so we can remove that element and close this group now after closing this group we have basically deleted all the elements before that now once again we will have to create a new group then that group starting point has to be six so we'll going going to Mark six over here and then which means now we are looking for seven and eight and lucky for us seven and eight are also present so we can just Mark these as visited and then in the end notice that now we currently don't have any value inside our tree map and because we did not find any at any place uh where we could not find an element so in this case we can return true now let's say that in the same example instead of this being seven let's say that this value would have been N9 so in this case what would have happened that we would have values such as six and the frequency of the value is going to be that six is present one time uh 8 is present one time and nine is going to be present one time over here we find that the starting point has to be six now for this sub this group to exist we will have to find Value number seven but seven would not have been present over here the moment we identify such thing like this we could have return false immediately so this is just for you to understand that under which scenario we would return return false and basically this is the whole solution now you can see how beautiful we are doing things uh if we calculate time and space complexity in this case the time complexity is going to be big of n log n why n log n because it takes us login time to add all the entries inside our uh tree map in terms of space complexity because we are using an additional tree map it is going to be big of n but we can manage that now on top of it we can also do one more optimization that if let's say the given number of hands is currently 10 and if the given group is equal to three so if the total cards are 10 do we even need to check that can we make all the groups of size three no why because three we can only create like the group for nine cards and there is still going to be one more left out card so initially we can always check that whatever the size of the given currently H is if that is going to be divisible by uh the given group size or not and this value the remainder has to be zero if that is the case then only we will move forward so this would be a way for us to eliminate few like bad and edge cases uh and now let's see the coding approach now for the coding solution first thing we are going to check is to see that whether the given length of all the H so all the cards that we currently have if that is divisible by group of zero if that is not the case then we can directly return false because for sure we would not be able to make the group of that particular group sizes if this is not divisible by zero if that is not the case we are going to initialize a tree map uh where we are using hash map in combination with tree map because we want to access the keys in a particular order and now we are going to be counting every single card so we are going to iterate over each of the card that is currently present inside our hand array and we are going to be adding that to our tree map where we are going to Define that if that card is present as the key then we simply update its frequency if that is not the case we create a new entry then we attempt to form groups where we are first of all in the outer loop checking that while the we still have present cards inside our key tree map we are going to do the following where first we are going to initialize the first key or the first starting point of the first group with the smallest key and notice that because we are using tree map we can actually just keep on accessing the keys directly because they would be stored in a sorted manner then we are going to iterate over uh the for Loop focusing on each particular group sizes where we are checking that what is the current card that is going to be first plus I then we are going to check if that if the we have that current card inside our tree map or not if we do not have that value inside the tree map we can simply return false immediately because we cannot make consecutive groups if that is not the case we are simply going to add that value then we are going to reduce the value or the decrease um decrease the count because we are removing the card and then we are checking that if the given count is equal to one then we can simply remove that card completely from our tree map if that is not the case we simply reduce its frequency and repeat the same operation if we do get out of this Loop which means we are able to get out of every single uh card and use every single card to create the appropriate group sizes and which means we need to return true in the end so this is the whole solution let's try to run our approach seems like our solution Works beautifully let's submit this code code and our code beats good chunk of solutions it is not the best and there are still improvements can made can be made but given the time frame this is a good approach and uh the solution is present inside our GitHub repository so feel free to go ahead and check it out from there thank you [Music] the lead code problem we are going to solve now is called merge triplets to form Target triplet now we can see that this one is a medium problem and also not very well- like problem but a really important one basically a triplet is an integer array of three integers okay that's fine and we are given a 2d integer array called triplets with bunch of different values that contains the pieces of uh triplets which means like values like a B and C okay now we are being told that there is a target triplet x y and Zed now we need to make sure that in this given triplets are we able to generate this target uh by doing the following operation on any number so basically we can pick any two triplets from our given triplet array and if we pick any two triplet basically we can combine them to create a separate new triplet that is only going to contain three values but that is going to be the maximum value at each position amongst these two two triplets so let me give you an example suppose we have a triplet 1 2 and three and we have a triplet let's say four 5 and six so in this case we know that amongst these two the higher value is four then amongst these two the higher value is five and amongst these two the higher value is six so if we merge these two triplets basically we can form an operation like this so based on this we are being told that we can do as many number of operations as we need amongst all the triplets that that are given but we are trying to make this target number if we can make the target number awesome we need to return true if we are not able to make the target number then we need to return false so let's try to see one example and we'll try to figure out different examples from that so first one is that let's say that in any given case we are given these three triplets right for these three triplets we need to form a number 2 7 and 5 now notice that we have the option to do the operation between any two triplets so let's say that we do that Max operation between these two triplets which means we have value 2 5 and 3 at one position and second value is 1 7 and 5 by doing the operation like the merge operation basically we we can pick the maximum amongst the all of these values and we will form a new triplet that is going to be maximum of these two values so the value is going to be two this is going to be maximum so value is going to be seven and this is going to be the maximum so once again value is going to be five and notice that this exactly matches the given input Target that we have so in this case we can return return true saying that yes based on the given input we are able to generate the target value and hence we can make the triplet by merging two triplet let so let's see that what is going to be the uh Brute Force approach to solve this problem well it is quite straightforward that for any given triplets that we currently have let's say that we are given in total five triplets and I'm just marking them as a b c d and e and for each of these five triplets we have the option to do the merge operation so if uh The Brute Force ways that we do merge operation amongst these two tripletes we do merge operation amongst uh these shooter plates and so on and so forth we keep on repeating and every single time we compare it with the target value to see if we are able to generate the target value or not and eventually if we can we would find the correct answer but this would yield in bigo of n Square time where n is the number of triplets that we currently have which is an inefficient approach we'll need to find a better approach and the optimal solution in this case comes from doing things in the most simplest manner optimally and that is to use a greedy approach so let's say that this is the example that we are currently given now notice that whenever we are iterating over any particular um triplet we should always compare it with the target to determine that is this a triplet of uh interest or not and the comparison should only contain two items first thing is that whether if each of these three values if all of these are less than the target value then and then only it is a triplet of interest for us otherwise we need to move on to the next triplet and why let's try to understand let's say that currently we are given a triplet 2 six and 5 and we are given the target to be 4 66 okay so in this case we can notice that every single value so 2 6 and 5 comparing with 4 6 and six notice that every single value inside this triplet is actually less than or equal to the Target triplet that we have which means this can be a potential uh candidate that we can use in future for the merge operation now the thing is if we are going to use this for the merge operation then we should just put this put this on a side noting that we found a triplet which can be of potential use to us uh at the same time we should also have to keep track of a variable that what if we already found a triplet that we are all anyways going to find the optimal solution with and in order to do do that we will have to basically compare the given triplet with the target triplet and keep track of the maximum value that we are able to generate from both of these triplets and just store that information so let's say in this case we can notice that the because this is a triplet of Interest then we are going to store the maximum value amongst these two these two and these two and notice we are having a condition that this has to be smaller or equal to the Target which means either we can have all the values that are going to be smaller than Target or it is equal to Target which means we would never exceed Target in this approach so in the maximum variable we are going to compare the max values so we are going to this is going to be four this is going to be six and once again this is going to be six okay so we took care of this triplet now let's move on to the next triplet once again in the next triplet we have a value called 7 4 and 6 now notice that for this one for 7 4 and 6 we did found a triplet that we currently have over here that is of potential interest uh could to Target or not so notice that the very first value 7 and four so 7 is greater than four which means if we do merge operation with this triplet then all we are always going to have first value that is going to be great greater than the target value which means this would not be a use for us so we should just simply skip over this triplet because we should not use this triplet to merge with anyone else okay next we have this value 4 4 and six so let's try to see that if we use this value what is going to be the um expected range or expected triplets we are going to be find so in this case uh basically once again we compare four with four so this is equal four with six so this is lesser and six with six so this is equal so once again this can be a potential uh triplet that we can use so now let's try to do the max operation in this case so the current values are 4 4 and 6 so we are doing 4 4 and 6 and we are comparing it with the target which is 4 6 and four so now notice that maximum amongst these two is going to be four so we add four over here maximum amongst these two once again is going to be six and maximum amongst these two is going to be uh six and now in the end we are going to have maximum variable that is going to contain values 4 6 and six over here and meanwhile we are going to have another uh Target value that we were trying to achieve and that was also 4 6 and six so notice that because both of these values match we can simply say that yes there exist a triplet that we can uh generate by merging other triplets and if we cannot find this maximum value which means that does not exist A A Triplet that is of a good use to us so in that case we would would have returned false so if we if you see approach for this solution then we can simply run it in big of n where n defines the number of triplets and in terms of space complexity we are not adding any additional space so this is going to be big off one as well so I hope this solution makes sense now let's quickly see the coding approach the coding solution is quite straightforward first we are going to initialize an array with size three uh naming it as Max values then we are going to iterate over every single triplet that we are given inside our tripletes 2D array and for each of the pair we are going to check that if the current triplet that we have will it be contributing towards making the Target or not so we are checking that if the given triplet uh position the value the first value is less than the target less than or equal to Target second value is less than or equal to Target and third value is less than or equal to Target if that is the case then we are going to Simply update the maximum values we have been able to achieve based on the given current triplet and the target values now remember because we are uh considering triplet values to be less than or equal which means if uh the only case where we have the target value uh set as it is is if the given triplet value is also same as Target value that subsequent value so we are going to store the values for all three parameters and keep on repeating the same process for every single given tripletes in a greedy fashion in the end we simply have to check that whether the three values present inside our array match the target values that are present if that is the case we can return true otherwise we can return false so let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs beautifully and it is pretty fast so I will be posting the solution in the comments so you can check it out for from there thank [Music] you so the lead code problem we are going to solve today is called Partition labels and we can see that this one is a pretty popular lead code problem basically we are given a string that we want to partition into as many parts as possible so that every single letter in each of the partition appears at most at one and not in any other partition now note that the partition is done such that after concatenating all the parts in order the resulting string would be string s so we cannot just partition randomly from the middle of the string it has to be sequential now let's try to understand it with some examples let's say that we are given a scenario like this now we want to create maximum partition where every single character only appears in just one partition so in this case we can create a partition with this a b a because remember a appears over here and a appears over here so they both has to be in the same partition and then we can create one more partition called D and notice that if we combine this a a d then we would get the resulting string s same way for this one we can create a partition a a because that would fulfill uh that all the characters of a are present then we can create a partition called b c DB because B is present over here and here so it has to be part of the same partition now for this third one we can create a partition AA we can also create a partition CC and then we would be creating an individual partition called B and then there would be a partition called D and this is what we need to return return so basically in the answer we know don't need to return something like this the exact partitions but we only need to return the size of those partitions so for this example we would written answer such as two and then two and then one and one so these are going to be the sizes Now The Brute Force solution is actually quite straightforward we simply take a character we iterate over every single remaining values we see that what is the last point where the character occurs and then tries to create a partition of that size and we keep on repeating the same process again and again for every single remaining characters and so on and so forth eventually we would get all the necessary partitions but the thing is this is not the most optimal approach and we can see that this one would run in big off of n Square time so we can do something better and let's try to find an easy and simplest solution that we can derive from originally uh brainstorming our Brute Force approach and that is to use the greedy way to solve this problem we are going to be very efficient in picking and choosing how we are going to go forward by selecting the partition now the first rule to select any particular partition is to identify that for any particular character the starting value doesn't matter but what is going to be the last occurrence for that particular character matters the most because once we identify that a character is part of any partition then we will have to figure out that what is going to be the last place this character is going to be placed at that is number one thing second thing is apart from being like finding the last position we would also have to figure out that this partition makes sense if all the characters present in this particular partition has the last Point either being this value or before that I repeat that this only this can only be a partition if every single unique character that there are present their last Point uh or the last occurrence would either be less than the index value that we are currently at So based on using these two values and some additional variables like the partition end time and the partition starting variable we can actually solve this problem very easily and very efficiently so let's first identify our first approach that is to find the last occurrence for every single unique character so let's say that for a the last occurrence is going to be uh index number two for B the last occurrence is going to be index position number one okay so now we have our list of last occurrences for every single character after that we can start iterating over any particular given character in this simple fashion on in this given string and all we will have to compare is that what is going to be the last occurrence compared to uh its current I position and whichever is going to be the greater value we are going to put it as part of our partition end because that has to be the partition end and whenever we find a greater value we would update the partition end that we are currently at on top of it if we are at a position where the given I value is equal to the partition end which means we found out a correct partition so no other character exist that has a greater last occurrence compared to our current value and we can mark it as a partition so we can just add it to our result list so let's say that we are also creating a result list to store all the results okay and let's just uh follow our approach so first we identified value number a so for Value number a the last occurrence is located at position number two so the paration end has to be at least value two so we'll mark it over here okay and then uh the partition start initially is going to be zero then we are going to iterate over value number B what is the partition end partition end is one one is lesser than value number two so which means uh we can we don't need to update the partition end next current I value we are at is value number a that is located at position number two so in this case because I is equal to 2 and the partition end is also going to be two we can actually Mark these values inside the result So currently in the result we are going to have three characters so that we can determine by finding out position start minus uh sorry position end minus position start + one we'll have to add plus one because we are starting with a zero index so in this case first result is going to be value number three after that we are going to update the position start value to the partition three uh number three and we are going to reset the value of partition end okay so currently the partition end would be dep dependent on this particular value C okay so C for the current C value the last occurrence is six and previous value was two but six is greater so we are going to Mark 6 as the current partition end now for this D the partition end is going to be four so four is lesser than six so we don't need to do anything over here same way five is lesser than six so we don't need to do anything over here now we are at I is equal to 6 and current partition end ends at six as well so in this case once again we are going to do partition end minus partition start plus 1 one so we will have four characters in the second partition as well which are these four characters now we are at Value uh now the new Partition end is going to be value number seven okay so we Mark partition value number seven and lucky for us the value we are iterating over for y is also valued at Value number seven and by the way the partition uh start would also be updated to Value number 7 so since we found I is equal to 7 and the partition ending position is also seven so we can mark this as a new Partition and this is this is only going to contain one element and same way this is also going to contain one more element and we can mark it as the answer and this is the whole solution basically let's do a quick recap first we created an array that is going to store the last occurrences of every single character uh once we have that then we can simply go over uh all of these characters one by one uh comparing with the last occurrence the the current position end date and position start value and we can maintain a result array and if you see the coding solution this would become much more sense that how does all of this operates now if we calculate the time and space complexity in this case the time complexity is going to be bigger of n because we will have to iterate over the given input string couple of times but overall it's just a linear update or the linear traversal and the space complexity is also going to be bigo of n or this can be biger of one depending on how you perceive it because if we are only talking about the lowercase English letters then there are only 26 possibilities and we can use a constant amount of space to solve this problem so you can debate this with your interviewer that and how they wants to perceive it but both basically both the approaches would be correct so the coding solution is going to be quite straightforward first we are going to check that what is the last occurrence of every single character and since there are only 26 characters that could be in string s we can use a simple array instead of using a hashmap we can iterate over every single characters and then just mark their uh position with the appropriate I position and just store it in our array called last currence step two is to iterate through the string and determine the partition for that we will need to have a variable to store the answer and we are going to initialize our array list called result we also need couple of variables to keep track of the partition end and partition start pointers so uh once we have everything set we see we are simply going to iterate over the given integer uh and we are going to Mark the current partition end as the maximum value between the current partition end that we have been able to find and the maximum value of the last occurrence of the current character we are at then if at any given point we identify that the given I is actually equal to partition end then we can simply find find a we have simply found a partition where there does not exist any more characters further than that point so we can add that value to the result and then we can start working with our next partition so we can just update the value of the partition start and then we can keep on repeating the same process and uh in the end we can simply result return our result array list so let's try to run this code the solution is working is expected let's submit this code and our code beats 91% of all the other Solutions which is excellent and I will be posting this in the comment so you can go and check it out from there thank [Music] you so the lead code problem we are going to solve now is called valid parenthesis string we can see that this one is a lead code medium problem and also a very well- like problem basically we are given a string s that contains only three types of characters uh open parenthesis closed parenthesis and a star now we need to return true if the given string is valid and there are some definitions given on what is valid basically any left parenthesis must have a corresponding right parenthesis that's fair same way any right parenthesis must have a corresponding left parenthesis uh next point is that left parenthesis means opening parenthesis must go before the corresponding closing parenthesis so this is valid but if we have like this then this is not valid okay and last one is that if if we are given star at any moment then we can consider star to be whatever we want so we can treat it as a right parenthesis or a closing parenthesis or an open parenthesis or we can also consider it as an empty string so that makes no difference so let's try to see some examples suppose we are given a parenthesis like this this one is a valid if we are given a parenthesis like this once again this is a valid if we are given a parenthesis that contains star once again this is a valid in this case we are treating the star to be an empty string which means we are basically left with this uh we can also say that this is also a valid uh string and so on and so forth so the only scenarios where it is not valid is if we are dealing with number of uh like out of order parenthesis or we are dealing with multiple parentheses of being like this and only one parenthesis like this so this is also not valid so let's try to understand the most common Logic on how we can pursue solving this problem now we know that if we are only dealing with uh working with problems that only contains parenthesis we can simply use a stack and solve this problem very easily very efficiently there are like lot of different examples of that I would not go not go in depth in this case because the important thing for this problem is this ASX so whenever we are dealing with an estx we have three possibilities we can either consider it to be an open parenthesis we can consider it to be an empty string or we can consider it to be a closed parenthesis so in each of the cases let's say that if we are dealing with multiple stars there can be many possible uh combinations and permutations that we should be able to make but that adds more and more complexity to our problem because let's say that we are given a string like this now in this case uh we need to basically have option over here to choose three different entries for and for each three different options we have another way to choose three more different options and so on and so forth so we can make many many different possible combinations so we'll have to do things smartly so one solution I'm suggesting in this case is that we use greedy approach and basically we iterate over the given input in just a single fashion and we keep track of the number of open parentheses and we also decide that what is the maximum number of open parentheses that we currently can have depending on the star value and what is going to be the minimum number of open parentheses we can have depending on the given star value now there are two possibilities one possibility is that for any particular star if we treat it as an open parenthesis which means there is one more open parenthesis left for us to deal with so in that case we can add basically that value to the max PA character or we can treat the star as an empty string or a closed parenthesis in this case we have one less open parentheses that we need to deal with so in this case we would update the value for the minimum character so let me me just walk you through the solution I'm suggesting let's say that we are currently given an input like this so in this case we are going to Simply have few rules for two variables that I'm suggesting first variable the variable's name is maximum open okay and second one is minimum open now for each of this we are keeping track that what are the maximum number of untouch open parentheses we have and what is the minimum number of untouch open parentheses we have the logic is quite straightforward we are simply going to follow few rules if the given input character is an open parenthesis then we will have to increment at both the places so we are going to increment at Max and Min if it is a closed parenthesis which means there is one less uh open parenthesis for us to deal with so in this case we would decrement at both minimum open and maximum open variables and we are going to initialize these with value zero and if the given value is star in this case we have two possibilities so there is one possibility we treat this as an open parenthesis or we treat this as an closed parenthesis or an empty string so if we are treating it as an open parenthesis which means there is one more open parenthesis left for us to check so we are going to increment at our Max open so for Max open we are going to update the value whenever we encounter a star and whenever we encounter star we can also trat treat it as a closing bracket so we will decrement the value at the minimum variable that we have stored and this are the rules that we are going to follow now uh there are couple of conditions that would allow us to solve this problem basically find the uh loose cases so first case is that if at any given point we identify that given number of Maximum open parentheses go into negative which means that there are too many uh too few two open parentheses and too many unopened parentheses because remember uh when this can go into negative whenever we have a closed parenthesis then we decrement the value so let's say that if for the given example if the first character in itself is a closed parentheses then we would have decremented the value for maximum open and minimum open so in this case the maximum open would have become negative so we can see that now even if this is like the most valid string this is Al this is always going to be not valid because it has an open parenthesis where we don't have a corresponding Clos parenthesis so this is one scenario that we can keep track of second scenario is that at the end our goal is to ensure that there are no untouched or there are no uh left open parenthesis so let's say that we iterate over the entire given input using these three rules and we find that there are no open parentheses which means the Min open is zero then we can simply return zero as the answer now next thing is uh we have a possibility where if we are encountering a star we are we are basically uh reducing the value of the Min parameter so Min parameter can still go into negative but thing is this would not directly say that uh we are dealing with an invalid string so in this case if for some reason the minimum variable goes negative then we are simply going to just start it back to zero uh treating that there are no uh no open parenthesis left for us to check and I know that there are lot of rules that I just talked about but the thing is if you just understood what uh we are trying to do with the example then it would make perfect sense so let's say that this is our minimum variable this is going to be our maximum variable and we are going to start iterating in this fashion so first we identify an open parenthesis which means we are going to increment the value for both in Main and Max So currently both values are going to be one once again open parenthesis so both Val are going to be two and once again open parentheses both values are going to be three now notice what these values Define is that what is the minimum number of open parentheses that we will have to deal with and what is the maximum number of open parentheses that we have to deal with so far we haven't encountered any Star so that's why the numbers are same amongst both of them now we encountered a star so we can read the star as either an open parenthesis or a DOT or a closed parenthesis if it's a one more open parth pareses then we would have four open parenthesis that we will need to deal with and if we treat this as a closed parentheses then we will only have to basically deal with one less open parenthesis because we can basically close these two parentheses so in this case this value would become two and let's try to see this by different examples so first three values we have as open then we have a star over here so what are the two possibilities first possibility is that we create a closed parenthesis so in this case this becomes a closed parenthesis so how many number of open parenthesis that we are left to deal with two which we are representing over here if we treat this as an open parenthesis in this case how many number of Maximum open parenthesis that we will have to deal with four and that we are capturing over here and this is the whole logic of the entire solution so now let's continue moving forward so once again we identified one more star so once again the minimum variable is going to be decreased by one so this would become one and maximum variable would be increased by one so this would become five and now we encounter a closing parenthesis so whenever we encounter a closing parenthesis basically we are reducing the values at both minimum and maximum values so this would become zero and this would become four now because we reach to the end of the loop we don't care about this maximum variable this maximum variable is only there to keep track of if this goes into negative or not if it does goes into the negative which means we can stop immediately and return false if that is not the case we check the value of this minimum variable and if because this is zero so in this case we can return true for this one and that this is a valid string so this is the whole idea behind the solution now if we see time and space complexity time complexity is going to be B of n because it's quite straightforward space complexity is going to be B of one because apart from using couple of variables we are not using any extra space so this is a wonderful solution and now let's quickly see the coding solution for this one so the coding solution is straightforward first we are going to initialize couple of variables called minimum open and maximum open this is to keep track of the minimum possible open pareses and maximum possible open parentheses now we are going to start iterating over character by character inside our given input string s and for every single character we are going to check that if there is a an open parenthesis then we need to increment both Min open and Max open otherwise if it is an closing parenthesis then we need to decrement both Min open and Max open and if uh that is not the case which means we have identified a star value in this case we will need to decrement the minimum open because we are treating it as a closing bracket or an empty string or we need and we need to increment the maximum open because we are treating it as uh open uh left parenthesis now at any given moment we realize that the max open is less than zero which means we can return false immediately because there are just way to many any uh closing parentheses compared to the subsequent open parenthesis now if that is not the case then we are going to check that at any given point the if the Min open becomes negative then we are simply going to um initial initialize the value starting from zero so Min open can go into negative but we don't care about that now in the end we simply need to check that if the given Min open is equal to zero which means that there are no uh minimum possible left open parenthesis so in this case we can return true saying that the given parenthesis string is valid so let's try to run this code okay seems like our solution is working as expected let's submit this code and code beats 100% of all the other Solutions which is exceptional so once again I would be posting this solution in the GitHub repository that we have created so you can find it from there thank you Hello friends we are still not employed by a Fang company so let's not stop lead coding till we get there today we are going to do a very interesting lead code problem interest interval and if you see the number of companies that have asked this question it's really amazing uh the companies like Google LinkedIn Amazon Robin Hood Facebook Uber Apple Twitter Microsoft service now Bloomberg and Goldman Sachs like these are if you you see the description of my channel these are my dream companies that I want to get a job of so that's why I'm doing these questions and I'm paying my atmost attention I hope you also enjoy the video so this is a lead code medium problem and essentially we are given an array of nonoverlapping intervals this is a multi-dimensional array it's a 2d array and at any given cell essentially we are given the value like start and end which indicates that there exist an interval between those times now our aim is that we need to insert a new interval into the list into the array of intervals that we are already given and we need to we need to maintain this nonoverlapping uh quality of the intervals so if we try to understand this this with an example uh suppose over here we are given a set of intervals like 1 3 69 so we are given an interval like this 1 2 3 this is already given and we are also given another interval like six to 9 and we need to insert a new interval called 2:5 so if I draw it on paper it would be something like this so two would fall over here and five would fall over here and this is the new interval that we are trying to insert in this original existing interval so how can we insert this new interval well the answer is actually simple essentially what we are going to create a new interval is that we will start an interval at position position number one then from one we will have an interval all the way up until the position number five and then we will have another interval from position number six and all the way to position number N9 and this would be the two intervals that we will have to take care of now the thing is in this problem we can clearly uh identify that why did we come up with this approach because we wanted to make sure that we do not we do not have any overlapping intervals so that is why when we found out that this is the existing interval and this is the new interval that we are trying to achieve if we wanted to insert this one there exist an overlap between these positions between this 2 and three so that's why because there was an overlap we actually chose to merge these two intervals and we created a new interval like this and for this one this had no concern with the existing uh new with the coming coming of new interval so that's why we left it as it is so let's see that what could be the different approaches we can take what could be the different scenarios and how we need to behave in any single scenario of them and essentially that would be our solution so first of all if suppose we are given a number series like this and we are given a list of uh intervals like this that there exist an interval between this value 2 to 4 there exist another interval between this value 8 to 10 and 13 to 15 now we let's see that where different set of intervals can be entered so suppose first of all we are given an interval like this that is not overlapping with or that is not in conflict with any existing interval so let's see that what would be the scenario in that that case suppose we are given an interval like this that from 0 to 1 we are given an interval like this now if we see this new interval it has no sort of conflict with any of the existing intervals if we wanted to add this to our uh array of intervals it would be just pretty simple we simply create a new interval like this 0 to 1 and then return whatever all these values are and this would be our answer so we we should be we would be done in this case there won't be any issue but suppose if this is not at the first or at the beginning of the intervals if this is at the end of an intervals so suppose this particular uh new interval that we are trying to enter suppose we are given some interval like this that uh from 16 to 17 we are given an interval so suppose we are given interval from 16 to 17 something like this now in this case what would be the approach essentially we would be doing the same thing what we would be doing is we would be transferring this interval on top of whatever the existing intervals we got and how we are going to do it as basically we are going to start traversing towards the original given input we are going to see that okay where is the starting point of this new interval and where this new interval can fit inside the existing set of intervals that we have now in order to check that essentially what would be helpful it would be helpful if we had a sorted uh set of intervals and in this scenario all the intervals that we are given they are already sorted so that is why which works in our favor so which means it becomes really easy for understanding where this new interval we wanted to uh shift into and in this case uh so we will start traversing we will first see that okay this is the value two this is this is 16 we don't care so we move forward uh again we are done with this interval now what is the next start point of this interval this is 8 and this is 10 and this is 16 so again it doesn't matter there is no overlap so we can put this in the answer again this is 15 this is this is 13 this is 15 and this is 16 so again there is no overlap so we can put this in the answer as well and then we find out that after 15 there are no intervals and we need to enter this new inter uh interval 16 and 17 so we simply add it over here from 16 to 17 and we add this to our uh array of answers as well and we return these four as a new new set of intervals now suppose somewhere in the M rather than this one this these are like easy scenarios where we are given at the beginning or at the end suppose we are given something somewhere in the middle so suppose we are given a new interval that we have to take care of uh something like this that it is from 5 to 7 this is the new interval that we are trying to insert what should be the approach in this case again we are going to repeat the same case over here this this is the value 5 and 7 and now what we are going to do is we will start iterating over this given input we will see that okay first value is two and uh the end of this in this interval is is at four so this is 2 and four and the new interval starting point is five which means there is no conflict so far so we would add this to our set of answers now from this four we reach at this five and at this five is the starting point of this new interval so we check in our original set of intervals that from 5 to 7 does there exist any conflict so from 5 to 7 actually there is no conflict in our original interval so if there is no conflict we simply add a new interval over here from 5 to 7 add it to our list of answers and because we have reached the end of our new interval right we we have reached the end of our new interval which means what this dictate dictates is that from this point forward there cannot be any existing interval that could be causing any sort of overlap with this uh with the arrival of this new interval so whatever the answer or whatever the list of intervals we are given Beyond this point once we have already entered this new interval we can simply add these to our answer array and this would be our solution so this would make our lives very easy and that is how uh we we would be able to handle this scenario as well right now the so far the all the three scenarios we saw we entered the value at the beginning at the end or somewhere in the middle but in all the cases there was no conflict between existing intervals with the new with the arrival of new intervals now suppose the new interval that we are trying to enter uh that new interval is something like 3 to 8 suppose it's something like this that now we need to take care of this scenario where we are handling this new interval and which is from 3 to 8 so what should be the approach in this case well the approach is actually quite simple uh we will start iterating over our input we will find all the intervals so first we we find that what is the start point of this interval so the start point of this interval is two and what is the end point of this interval the end point of this interval is four now what is the and every time with the end interval we are going to compare the start interval of the new uh new inter new interval that we are trying to insert so the start interval of this one is three and this one is four which means that we know that we will have to enter this three over here and there exist a conflict now since we have identified a the conflicting scenario what should be our approach well our approach should be simple that we are going to take a look at this particular interval and we are going to take a look at this particular interval now there exists a conflict because there exists a conflict we are going to check the starting points of both the intervals now in terms of starting points of both intervals this one is smaller than this one so whatever is the smaller we are going to treat this as the starting point of this new interval that we are trying to enter because there exist an overlap amongst these values so we are taking care of the overlap so that's why this would be our starting point this would be the start of this new interval and we are going to drag this new interval up until the end of this point so up until the end of this point when we come we find out that it ex it comes up until all the way to Value number eight now in this scenario we did not had anything in the middle but if we did had anything in the middle that would have been merged by this new interval right but thing is even when we come at this position number eight we see that actually the position number eight is start of another interval so which is this one so if it is start of this interval we cannot just treat this as a separate interval I mean what I'm trying to say is we cannot have an interval like from 2 to 8 is one interval and from 8 to 10 another interval because this 8 is actually a conflicting point and it is a con because it is a Connecting Point these two intervals also needs to be merged so because this a is a Connecting Point we are going to merge this interval with this new interval that we are trying to create and essentially this interval from 8 to 10 will also be dissolved by this new interval and we would have an answer like this in this scenario that uh we would have a new newly created interval from 2 to 10 this would be for one interval we have and this would be another interval because remember now we have already entered this one which means all the values Beyond this point Point are not part of our concern we concern we can simply add it to our uh list and in this scenario the second interval would be uh from 13 to 15 and this would be our answer that we are going to return so this is one conflicting scenario and uh I mentioned that how we are going to tackle it so essentially the different test cases in this case we we can have is that we can either have a scenario where the item lies somewhere between beginning or at the end where it is not conflicting with anyone or it can be existing somewhere in the middle where it is not existing not overlapping with any other interval or it can be a case where it conflicts with some intervals with one interval or more than one intervals in either scenario what we are going to do is the moment we find that there exist a conflict we are going to see that what is the start Point what is the lower value amongst these two so because the lower value is two we are going to start this new interval start starting from the position number two okay now for the end position again we are going to do the same thing we are going to check that what is the end position of this existing interval and what is the end position of this new interval and in the end position we will have to uh check the maximum value because the interval we are trying to create should be the size of biggest interval that we could create which is not overlapping with any other interval so that's why we would have an interval that is maximum amongst these two ending values so these two ending values the value is8 so we would have an interval from 2 to 8 so far but thing is this is not the end yet because when we come at this eight we will still have to check for the conflicting scenario so over here we have we would have the starting we would have two intervals like this and in the two intervals we have the eight value as the value number eight as common so we are going to merge these two as well and in this case we are going to choose the biggest value we can find as 10 and we are actually rather than having an interval from 2 to 8 we would actually have an interval from 2 to 10 and this is the critical part to understand and this is basically our solution essentially we are using the greedy approach but this is all we don't need to do anything else and if we calculate the time and space complexity the time complexity in this case would be actually big go of n because at at any point for this new interval we would need to find that what what what should be the entry point of this new interval and then we will check for the conflicting scenario if there exists a conflict scenario we will find a way to put it there if there does not exist any conflicting scenario well good for us uh in terms of space complexity well for the space complexity it would also be big off n because we will have to create a new array of list of intervals that we are going to return so we will have to create a new two-dimensional array something like this in this scenario from where the answer would be 2 to 10 and uh 13 to 15 so this would be our new array that we are creating and we would be returning that so that's why SP that explains the space complexity and uh yeah this would be the solution now the question is where can you use these kinds of approaches like what is the point of having this question in at the first place and actually this is a very interesting question it has lot of practical applications practical applications is like suppose you are trying to design an an app where you need to maintain some sort of calendar or we you need to maintain scheduling so the and these are very practical very real life applications uh Google Mail Outlook all the companies they all use this mechanism they all use this mechanism so if we know that where we need to insert an interval where we are not creating any conflict it could be a conflict between shifts of two employees working for a factory or it could be the interval between two trains going through a station so like yeah these are real life practical exams and that's why the that justifies the number of companies that are asking this question so first of all we are going to initialize some variables and we are going to create a new start and new end for the given uh new interval we are also going to create two pointers uh left and right and left would be at the zeroth position inside the given intervals and right would be the last uh the size of the given intervals we are also going to create a link list to store all the output and then we are going to convert it into the array so now first of all we are going to add all the nonoverlapping intervals that come before the new start so we are going to create a while loop and now inside our given list we will need to add the new interval so in order to add the new interval we will have to check two there could be two possibilities there might be an overlap or there could not be an overlap so we'll have to take care of both of them so first we are going to create a parameter called interval and we are going to uh store all the value inside this parameter now we are going to check the condition that if the current uh position where we need to insert the new interval does there exist an overlap or not so if there is no overlap we can just simply add the new interval so if that's the case we can just simply add the new interval if that is not the case which means that exist an overlap so if there is an overlap we will have to first of all check that what entry we like what should be the uh starting point and ending point of the overlapping character and that we can Define by choosing the minimum out of the starting values or the maximum out of ending values so first of all we are going to uh add the last value we have in uh our link list inside this new interval variable that we created and now we are going to check that what should be the endo and we would add the new entry to our link uh link list okay now we might have to merge all the elements that are after uh that came because we added this new interval so we will take care of the merge scenario and if there exist an interval we will do the same thing that we did before so essentially we can just repeat this process uh yeah after this Loop runs uh we should have everything stored inside the link list so we can return the link list but we will have to convert the link list to an uh array and this should be our answer let's try to run the code it seems like our solution is working let's try to submit this code oh we will have to check for the this end variable here so that's why okay looks like our solution is working and it's actually pretty fast compared to a lot of other Solutions and even in terms of space complexity we are also saving a lot of time or lot of space as well so I would be posting this in the comments you can check it out from there Hello friends we are still not employed by a Fang company so let's not stop lead coding till we get there if there is any question that can get you in the Fang it's this one that we are going to solve today because if you just see that the number of companies that have asked this question it's just out of this world this question has been asked by hundreds of companies literally hundreds of times you can see over here that like Facebook and Amazon they both have asked this question recently over 100 times in their interviews so you can imagine the severity and the importance of this problem that we are going to solve apart from Facebook and Amazon if we look at the number of companies that have asked this question there are companies like Google Salesforce Microsoft Bloomberg Apple Uber LinkedIn IBM uh VMware Walmart Tik Tok Adobe Twitter Twitter uh bite dance and uh then there are companies like Yahoo PayPal wish Oldman XX Robin Hood and also plenter square and so these are all one of my dream companies where I want to get a job that's why I'm making these videos and that's why I made this channel so I would be paying my atmost attention I hope you also enjoy the video this is a lead code medium problem and uh it is one of the most like problems on lead code and that's why a lot of companies likes to ask this problem so essentially we are given an array of intervals where every single entry inside the interval mentions that there exist a start point and an end point of that particular interval now we need to iterate over all of the intervals and then we will need to merge all the overlapping intervals and we need to return an array of nonoverlapping intervals from this given input and uh that would be our solution so if we try to understand this with an example suppose we are given some set of intervals like this now let's try to mention them on this uh number sequence that we have drawn out now over here our aim is to return all the nonoverlapping intervals and if there exist an overlap we will need to merge those two intervals so first of all we will have to identify that what are the those two intervals where we can see an overlap so essentially if we look at the start values of this interval so start value over here is 1 and 3 and if we look at the start value of the second interval the start value is actually 2 and 6 and over here we can clearly see that there exist an interval amongst these values and this is these are the two two intervals that are causing an overlap and we will have to merge them now the question is first of all we need to know that why did we why we were able to calculate that there exist an um overlap over here based on the given input like this is a pictorial representation we can clearly see that why there is an overlap but in terms of computer we will need to dictate some sort of mechanism so essentially we can say over here is that at any point if we start iterating over any number of intervals and if we identify that for those particular intervals if the starting value so in this case the starting value is actually two if this starting value Falls between any interval so because this two currently Falls in between this 1 to 3 this this first interval is 1 to 3 and over here the starting value of this new interval actually falls between that those places and the moment we identify that okay this two Falls between this 1 and three interval so we know that okay this uh interval that starts at 2 so this 2 to six is also causing an overlap between this given input interval and we'll need to merge them so this would be our condition to identify that at any moment at any interval we are trying to see that whether it intersects with some other interval or not what we are going to check is we are going to see that uh suppose this value is the start value so we are going to see that this start value if that means if that is less if that is greater than whatever the interval start we are checking and whatever the interval end we are checking for if this condition is true we can determine that there exist an overlap and now since we have already identified that there is an overlap uh we'll need to resolve that so in order to resolve that how we will resolve that is we will create an interval from this value number one to Value number six so essentially we are merging both of these intervals and why how what is the condition we using to merge these two interval is that we are going to check that okay for the starting point of the new interval what is the minimum value amongst both the start values so Ina in this case over here the first start value is one and second start value is two so the minimum value is actually one so we create an interval that starts at position number one and for the end value there is this three and six so we compare this value three and we compare the value six and we identify that okay six is greater in this case so for the end value we are going to to pick the the maximum value among two values so we are going to create a new interval like this that is from 1 to 6 and then uh essentially we have taken care of these two overlapping uh intervals and for this one this 8 to 10 and this 15 to 18 these two intervals they are not causing any kind of overlap so we can just directly put them as it is inside our uh answer so in this case if we try to calculate that what would be our answer the answer is actually quite simple the uh our answer in this case is going to be an interval from 1 to 6 and this is the merge interval second interval is going to be 8 to 10 and the third interval is going to be 15 to 18 so this would be our solution and we can simply return this one if let's try to understand the same problem with another example that is given over here so in the second example we are only given two intervals 1 to 4 so this is one interval 1 to 4 so the question comes that are they overlapping integers and the answer is yes why because if we see at this value number four actually Four is Connecting Point for both the intervals so four is the ending point for the interval one and it is the starting point for the inter interval number two so in this case we actually need to merge these two intervals and we will have to create an interval like this that is from value number 1 to 5 and again we are going to use the same logic the logic is going to be that over here the values were 1 to 4 and over here the values were 4 to 5 so for the starting values we are going to choose the Lesser value and for the ending values we are going to pick the maximum value so maximum value in the Lesser value in this case is going to be one and maximum value is going to be five so this would be our intervals and this is the these are all the scenarios that we need to take care of so suppose we are given a custom example like this let's see that what what should be the solution and always remember that it is really important for any programming interview that you come up with your own custom examples it shows that you have the ability to think about all the different kinds of test cases and you can come up some with some unit test on your own so over here our aim is to find that all the non-overlapping integers now for to find all the nonoverlapping integers we already know that what is the condition that how can we determine that any particular value is actually causing an overlap and the way we can do it is that by checking the start value and comparing it with that whether it exists somewhere in between uh any given interval the question is previous two examples we saw they were already sorted so they were all the starting values were already in some in a sorted manner so that's why it was really easy for us to identify that whether there exist an overlap or not but nowhere uh in the sequence we are told that all the input should be sorted so that's why that makes things a little bit more complicated and let's see that how it does so so over here suppose we are given an input 4 to 6 so we can create an line over here that okay there exist an interval like this from 4 to 6 now second one is 11 to 15 so again there is an input like this 11 to 15 next one is 7 to9 so there exist an input from 7 to9 and this next input is 2: 5 so we know that there is an overlap but we are going to just draw it over here and the next one is 13 to 16 so over here we can clearly see that there are two places where there exist an uh in overlap but we don't know that yet right because the input is not sorted and we will have to identify it by ourself so how we are going to actually identify well essentially we are going to use the same logic we are going to check that whether the start value Falls in between any of the interval if it does we are going to determine that okay that part this so if it does so we know that this particular interval is in conflict with that interval and then we are going to have to merge it so let's try to do that so over here we are comparing this value number four that is the starting value first of all we are going to check that whether four Falls between 11 to 15 well it does not so we are good with this whether four Falls between 7 to 9 it does not so we are good but over here four actually falls between 2 to 5 because uh two is actually less than four and four is actually less than the five so we know that four actually exist over here which means there exist a conflict between this and this these two intervals so we will have to resolve this conflict how we are going to resolve this conflict well of course we are going to create a new interval so starting value is going to be the lesser of both of them so we are going to have a starting value that is at two and for the ending value it's going to be greater of both of them so the ending value is going to be six so we are going to create a new interval like this that is from this value number two to Value number six and we are good with this one so essentially we have merged these two intervals so we can uh just simply mention that okay these two are merged or these two are taken care of so we we don't have to worry about them anymore and now we are done with essentially these two intervals right and we have in our answer we already have this uh this new interval stored now let's see that how can we move forward so again for this 11 to 15 again we will have to repeat the same process so we check that whether this 11 Falls in between some uh interval so first of all we we compare this 11 with this four and six so it does not fall in between and also remember that because we are done over here doesn't mean that there could not be any more uh overlaps that we cannot take care of so we might have to do it so that's why we are going to compare again all the values so 11 does not fall between 4 to 6 11 does not fall between 7 to 9 11 does not fall between this 2 to 5 and 11 does not fall between 13 to 16 so so far we are good that okay this 11 to 15 that is okay we don't have any issue with that now we again check for this 7 to9 so we check that whether This 7even falls in between somewhere so 7 does not fall over here it does not fall over here it does not fall over here and it does not fall over here so this 7 to 9 is also good 2 to 5 we have already checked okay so this value number two two does not fall anywhere so we are good with this interval as well now again we are at this interval number 13 so for this interval number 13 it does not fall here but oh it falls in this place so we again have a conflict between this uh these two intervals so 13 to 16 that is one interval and second one interval is 11 to 15 that exist a conflict so because there exist a conflict we will have to resolve that and we can Mark these two as done so we are going to create a new interval that is 11 and 16 which means lesser values of the starting values and greater values of the ending values and this would be our new interval so we can add this to our answer as well so this would be uh 11 and 16 this is also our answer and now we need to check that amongst these intervals which were the ones that were not part of any overlapping Series so we know that this particular uh this particular value this particular value 4 and six was part of an overlap 2 and five was also part of an overlap 1115 and 1316 they all were part of overlap which we have taken care of with these two values so this seven and N9 was not part of any overlap so we'll have to add that to our answer as well and uh we will add the seven and 9 to our answer and this would be our final answer in this case now the thing is we are able to resolve this uh quite easily right we are able to generate the answer we know all the logic and blah blah blah we are able to identify the over overlapping condition if we calculate the time and space complexity in this case the time complexity is actually biger of n Square why n Square because remember that for every single entity we are going to have to check all the remaining elements same goes for this one that for every single entities we are going to have to check for all the other remaining values so that causes n Square work the question is can we do something better over here and that rather than using this n Square can we uh bring down the time complexity and the answer is yes okay let's sort this given input so the sorted result would be now this is the sorted result now we need to identify that whether there exist a conflict or not so it becomes really simple what we are going to do is we are always going to check the first value and we are going to compare that whether the starting point of any value if that is actually less than the ending point of the previous element if that is the case we would be able to identify that there exist a conflict and always we are going to start checking from the second value because for the first value we know that the first element is already the smallest value so even if there exist a conflict between first two en entities this first one would always act as a starting point of the new merged uh variable or the new merge interval so let's try to do that and over here we will start with the second position we know that okay this one is four We compare it with the last element of the previous interval so last element of previous interval is five so we know that actually Four is less than five in this case we know that there exist an overlap between these two values because there is an overlap we can see that we need to check the we need to take the minimum value among among these two so minimum value is actually two so we create a new interval starting at two and for the ending values we will have to check the last values so the ending value in this case would be six so we will have a new interval like this so let's draw a new interval like this on this uh number system now we are already done with these two values now we Che take a look at this value number seven so again for the seven We compare with the last element in this case so 7 is actually greater than six which means that does not exist a conflict between these two values so we can start creating a new interval from seven and now again for this 11 we are going to compare it with the last element so over here this value is 9 so 9 is actually less than 11 which means in this case there does not exist a conflict so 7 to 9 is an interval in its own we are good with this one now we have calculated this one now again over here this is 13 and this is 15 so we know that 13 is actually less than 15 so in this case there there exist a conflict between these two values so because there exist a conflict we are going to do the same conflict resolution Technique we amongst this 11 and 13 we are going to pick the smaller value so smaller value is going to be 11 so we pick this one and for this 15 and 16 we are going to pick the greater value so 16 is the greater value so again we are going to create an interval like this it is from 11 to 16 so essentially we have resol we have taken care of two overlaps that existed between the these two values and these two values but we are we were able to identify them immediately why because all we have to do is at any point we just have to compare one value that was in the previous interval at any given moment and now over here we can just simply start iterating over whatever the answer we have found so far so in this case we can simply return the answer as uh 2 to 6 7 to 9 and uh 11 2 16 and this would be our solution now if you look at the look at the solution over here essentially all we had to do is just iterate over the sorted input once so basically to generate this answer we are only doing big of n work but the total time complexity in this case is actually going to be Big O of n log n and why n logn because we will have to generate the sorted input from this given original input and that takes n log and time first of all we are going to sort the given input okay after sorting the given input based on this uh based on the starting values we are going to uh create a link list and we are going to uh store answer in this uh link list now we are going to iterate every single interval inside the given input so now we are going to check that whether we are at the first position or whether the given interval if that is in conflict or not so if that is not in conflict or there does not exist an overlap we are simply going to add it to our answer okay if that's not the case we have detected a conflict and the moment we detect a conflict we will have to resolve the conflict so essentially we are going to add the new interval that is merged okay and and uh after this Loop ends essentially our answer should be in the answer link list so we can return that but in this case we need to return a two dimensional array so we will convert our uh answer uh list to a two 2D array okay let's try to run this code seems like our solution is working let's try to submit this code okay our solution works pretty efficiently I will be posting the solution in the comments you can check it out from there Hello friends we are still not employed by a Fang company so let's not stop lead coding till we get there today we are going to do nonoverlapping intervals problem and this problem is actually very similar to merge interval problems and insert interval problems I have solved both of these problems and I will be posting their links in the description so you can check it out from there like though this problem seems like it has not been asked by many companies actually this can be a very interesting uh post question after these two interview questions so uh usually like all the interval problems they are done in sync and even for this particular problem if we see it has been asked by Tech giants like Facebook Amazon Microsoft Bloomberg Apple Oracle Google by tons which is Tik Tok and Snapchat and these are my dream companies so I'm paying my atmost attention I hope you also enjoy the video this is a lead code medium problem and we are basically given an array of intervals where every single entry has a starting point and an ending point that represents that particular interval now our aim is in this problem is is that we need to return return that how many minimum numbers of intervals that if we remove uh from this given original input if we remove those then the remaining result should be uh such that all the intervals becomes non-overlapping so we need to return the number of intervals that we need to remove so let's try to understand this problem with an example that is given over here and over here we are given some set of intervals and let's try to plot them on this given uh number series and see that what would be the answer okay so after plotting all of these our aim is to return our aim is to see that okay if there exist an overlap inside this given interval uh we need to return the minimum number of intervals such that all the remaining intervals becomes non-overlapping so over here we can clearly see that okay there exist an overlap between these points and the over is actually mainly caused by uh because of this particular interval and these two intervals so our aim is to remove the minimum number of intervals that uh that basically allows all the remaining intervals to become non-overlapping so in this case if we simply remove uh this particular interval that starts at position number one and ends at position number three this big one so if we get rid of this particular big big interval we will have a result where all the intervals they are actually not in collision with each other and they are not overlapping with each other over here we can see that they uh they actually connect at some point but that is not an overlap like I know that in previous questions we used to consider this as an overlap but you can confirm this with your interviewer that with what approach they want to go so in this case we only get rid of this one interval that was existing and because we get rid of one we will return one that in this given input if we simply remove one interval we would we can determine that okay there exist uh one interval such that uh if we remove that then all the other intervals becomes non-overlapping now to generate the optimal solution the main thing is that we will have to determine that whether there exists an overlap inside the given interval or not now the previous examples we saw the input was already sorted but in the problem statement it is nowhere written that the input should be sorted so input could be something like this where everything is different value now the thing is first of all over here we need to determine that what are the intervals that are actually causing the overlap and then we can determine that what which one should be removed and what not blah blah blah what should be the strategy for that now the thing is uh if we plot these uh this given input on side on a number system uh we will get a result like this over here we can clearly see that there exist a conflict between uh these two intervals uh which is represented over here the thing is is how we were able to identify that there exist a conflict we were able to identify because the starting point of this particular uh interval was actually falling between uh the two values of some already existing interval so that is the condition we will have to determine if we want to find that whether there exist an overlap or not so over here suppose we get at Value number five and we want to check that whether five has an over has an overlap anywhere so five we will have to check all the other intervals so five does not exist between this 2 to 4 so there is no overlap with this one it also does not exist between 8 to 9 so there is no overlap and it does not exist between one and three so that's why there is no overlap so now we are we are say that okay this five 57 has no overlap with any other uh interval now we check for this value number 2 to 4 so again we check the starting point for the value number two so value number two does not fall between 8 to 9 so there is no overlap but two actually falls between this 1 2 3 because one is actually less than the Val Val two and two is actually less than value number three so which means two Falls between this interval so that's why the interval 2 to 4 and 1 to 3 are in between uh and overlap and then we will have to take care of that scenario now do you see a problem with this one and the problem is that I can see is that for every single value we will have to check all the other remaining values that whether there exist an overlap or not and that actually causes bigo of n Square time and this is unnecessary work like even just to determine that whether there exist an overlap or not we are actually doing big of n Square work which is like pointless uh there there exist a better approach and the better approach is uh that if we sort the given input and then we sort them based on their starting values things becomes lot a lot easier so let's see that what should be the sorted array now we have sorted this given original set of intervals and now we have all the values sorted so now if we see if we want to identify that whether there exist an overlap all we need to do is we just need to compare any two adjacent values and the moment we compare any two adjacent values we can directly tell that whether there exist a conflict between them or not how can we tell them is that we only need to check that whether the starting point of any uh second interval compared to its previous interval if that is smaller then we know that there exist a conflict so in this case we can say that between this 1 and three and two and four there exists a conflict because this particular interval ends at Value number three and this particular interval starts at Value number two so that's why there is a conflict U meanwhile if we see over here this particular uh interval ends at Value ends at Value number four and this one starts at Value number five so that's why there is no conflict so this is a very easy way for us to determine that whether there exist a conflict or not and if we see in terms of time complexity the time complexity for the sorted operation uh takes only big of n log n which is a big Improvement compared to the previous time complexity for this one which was big of n² okay now we have determine that how to identify overlap the question is that how to find that what should be the most number of nodes that we will have to remove and uh what should be the strategy for it so essentially there can be three different scenarios at any given moment the first scenario is that between two intervals there does not exist an overlap so if there does not exist in overlap there is no need for removal so we don't need to remove at anything so we are good in this case this is like the most beautiful thing the second scenario is that we are given one interval that is clearly bigger compared to the second interval so essentially we can say that the second the second interval is actually subset of this given bigger interval so in this case things actually becomes pretty easy for us all we need to do is that we simply need to remove the bigger interval because that there is a conflict between these two intervals right now which we can see but there could be possib possibility that there might exist some other interval something like this so say in this scenario if we got rid of this interval we still have to we will still find ourself to be having conflict between these two intervals and again in order to resolve that we will have to remove this one as well but rather doing this suppose in this scenario we only had uh two intervals like this and originally if we just just got rid of this bigger interval then immediately even though there exist another interval somewhere down which was actually causing an overlap between this original interval still we would we will have to perform less remove operations so that is why uh the strategy should be that always remove the bigger interval now the question comes in scenario like this where the starting point of one interval is actually falling before and the starting point of second interval actually falls somewhere in between so what should be our approach in this scenario and in this scenario as well uh what I'm suggesting is that we remove the interval that has the longer end point essentially if we at any point identifies ourself in this kind of scenario our strategy should be to remove the end to remove the interval with the end point that is greater so suppose we consider that uh the starting point for this interval is actually 1 to 3 and suppose we consider that starting point for this interval is 2 to 4 so in this scenario the the strategy we are going to use is that we are always going to remove the interval 2 to 4 why because the we are going to compare the end values and whichever interval has the greater end value we will decide to remove that particular interval so essentially we are using a gry approach but by using this gry approach what we are going to do is that over here we know that for this particular case for this particular interval we only had an interval that was causing an overlap over here but again the same thing could happen that we might have another interval like this where this particular interval was causing an overlap between this and this and also this so immediately remember our input is sorted so we are coming from left to right inside the number sequence so the moment we identify that whatever has the greater end point if we decide to remove that so even over here we already got rid of this one so even over here if there exist another interval that comes after this 1 2 3 still it would not be in overlap with this 1 2 3 and we will have to do less remove operation and this would be our ideal approach if we calculate the time and space complexity uh basically the time complexity in this case is going to be big of n log n uh and Y N logn essentially U doing this interval converting this interval from uh normal input to sorted input takes n log and time and then after that once we have this input given essentially all we need to do is just we have to iterate over the given input once because it is already sorted and then we can perform the remove operation and we can count the number of times we removed any interval so that this second part takes big of end time so total work we are doing is actually Big O of n log n plus Big O of n but in general we can write this as Big O of n log n and in terms of space complexity we are not using anything extra so we can just say that it's a constant time space complexity at most at most we are just going to use couple of extra uh variables so first of all we are going to check that if the given uh intervals is empty so we are going to return uh zero okay if the that's not the case we will have to sort the given input and we are going to sort the given input based on uh the starting values okay after the Sorting we are going to initialize couple of variables so we are going to keep an keep a variable called previous to keep track of the previous element and uh we will initialize it to zero we are also going to have a variable called count to keep track of the number of elements that we will have to remove so we are also going to initialize it to zero and now we are going to run the for Loop that runs over the given sorted input and over here we are going to start it as int I is equal to 1 because we already have the previous value as zero for the comparison and remember that because the input is sorted at any given moment we are only comparing two adjacent elements inside the given interval so first of all we are going to check that if there exist an overlap between two adjacent elements and if there exist an overlap we are going to check that which ele element is having the greater end value so we will update the previous counter based on that and if there exist an overlap we are going to increase our count this second if condition dictates that the If the previous uh interval is actually greater than the current interval we are at we will have to update the previous counter to next element and in any case we are going to increment our counter count variable and if this is not the case uh essentially we have found that between two adjacent intervals there does not exist uh any overlap so we are going to increase our uh value of our previous uh count previous variable to the current I so that we can use it for further uh implementation and uh once we are done with this Loop essentially this count variable should have our answer so we can simply return the count variable and uh this should be our solution let's try to run the code okay seems like our solution is working let's try to submit the code okay our solution is working as expected and uh it's actually pretty efficient in terms of memory usage and even in terms of time complexity it's not that bad compared to other Solutions I will be posting this in the comments and you can check it out from there we are not going to stop till we get into Fang and uh see you in see you next time Hello friends we are still not employed by a Fang company so let's on Stop Lead coding till we get there today we are going to do meeting rooms lead code problem and this is actually a lead code premium problem so uh if you want to know that what are the list of companies that have asked this question in this in their interviews that comes later in the video and I have provided the time stamp for that you so you can directly go and check out let's understand the problem statement essentially we are given an array of meetings uh called intervals and we are given start time and an end time for every single meetings inside this given array now we need to determine that if one person can attend all the meetings or not so let's try to understand this given uh Problem by an example so over here we are given three different meeting times and let's try to plot them on this number sequence that we have created so first meeting starts from 0er time and it lasts until 30 minutes second meeting starts at 5 minutes and ends at 10 minutes and third meeting starts at 15 minutes and end at 20 minutes so over here we can clearly see that there is no way possible for one person to attend all the meetings because there exist a conflict between this meeting and this meeting and there also exist a conflict between this meeting and this meeting and this meeting so because there is an overlap between intervals and essentially that's what we will have to determine in this problem so over here we can clearly return false that there does not exist uh any way possible for one person to attend all all the different meetings that are given in this interval now if we take a look at the second example and let's try to plot it in a uh on a number sequence so over here uh we can imagine a number sequence like this and over here we are given one meeting that is that starts at 7 and ends at Value number 10 and second meeting starts at 2 and ends at Value number four so over here we can clearly see that it's possible for one person to attend this meeting and after that he can attend or he or she can attend this meeting so in this case we will return true and uh basically that's what we will need to determine now the the tricky part over here is that we will have to determine that how do we identify that there exist overlap between any two values so suppose over here in this example if we are given an another meeting that starts at 3 and ends at something like that now in this case can we say that uh does there ex can one person attend all the meetings or not well we can clearly see that because there is an overlap between these two meetings one person won't be able to attend all three meetings and over here we will have to return false the thing is why we were able to determine that over here there exists an overlap uh so because over here we see that the starting point for this meeting and ending point for this meeting is from 2: to 4 4 so that is one interval and if we look at this one the starting point from this for this one and the ending point for this one is 3 to 5 so this is 3 to 5 so over here if we consider this particular um interval we can see that the starting point of this interval actually falls somewhere between any other interval that already exist so at any moment if we determine that the starting point of some interval if it falls between any interval and this condition is satisfied that 2 is actually less than three and three is actually less than four which means three Falls in between this interval so that's why we can determine that there exist an overlap and the moment we identify that there is an overlap over here we will immediately return false and uh this is how we are going to approach suppose we are given an input like this uh the different intervals are given and this is the number sequence that we are going to use now over here essentially if we want to determine that can one person attend all the meetings we will have to check that whether there exist a conflict or not so if we look at this first scenario previously we determined that how to identify an overlap so if we look at the starting value of this 20 we will have to check that whether this 20 exist in between some intervals so over here this is 10 to 15 so 20 does not exist over here uh this is 35 to 45 so 20 does not exist over here and this is 10 to 20 now this is this meeting ends at 20 and this meeting starts at 20 so this is also legitimate scenario because 20 is not part of this interval so that is why we can determine that okay this meeting is good like the starting point does not have conflict with any other meetings now let's see about this one so this meeting is from 0 to 15 right so does there exist any conflict between these two between this zero so zero does not exist between this one uh zero also does not exist over here and 0er does not exist over here so we are good same goes for this 35 that 35 does not exist between these two this one or this one so we are good but when we come to this value number 10 we can clearly see that this 10 actually falls between this 0 to 15 because this condition is satisfied 0 is less than 10 and 10 is less than 15 so over here we can clearly see that there exist an overlap between these two elements and we can clearly we can immediately return false so this approach would work perfectly ly fine but what is the issue with this approach the issue is that this takes bigo of n Square time why big of n Square time because remember for every single element we will have to check all the remaining elements based on the starting point uh same goes for this one same goes for this one so that's why we are doing n Square work so this work can greatly reduce if we just sort the given input uh based on the meeting start times and let me show you how so let me clean this up and let me sort this given input so now we have the sorted input now in the sorted input if you take a look at it we are actually we are actually able to determine that whether there exist an overlap immediately how all we need to do is we'll need to compare the starting point with the ending point of the previous interval if the starting point is actually less than the ending point of previous interval we can determine that this meeting actually starts before the previous meeting ends and immediately we can identify that whether there exist an overlap or not so this is basically our solution like in this scenario we can clearly see that the moment we are in the meeting from 0 to 15 so there is a meeting going on from 0 to 15 and before this meeting ends there is there is another meeting that starts at 10 and last up until 20 minutes Mark so there is an overlap over here and immediately we will return false in this case so this approach actually works and uh it is more efficient than the previous approach we suggested uh why it is most more efficient because if we calculate the time complexity the time complexity in this case is going to be big of n log n for the Sorting operation because from this given input first of all we'll have to create a sorted input and once we are done with that uh if we want to identify the overlap we only need to check any two adjacent values at any given moment and the moment we reach to the end point and we don't find any issues we can return true or if we find any issue we can return false before that so this takes B go of end time so total time complexity can be considered as big of n log n and uh in terms of space complexity we are not using any additional space so we can say that we are only using constant time uh to run this problem and uh this is the Final Approach now let me show you the list of now let me show you the list of companies that have asked this problem and uh if you are not interested you can directly go to coding so essentially companies like Amazon Google Facebook they have all asked this problem recently and Microsoft and Ware they are also really popular uh well-paying companies that have asked this problem also companies like Bloomberg Adobe and uh eBay that one of my dream companies that I want to join in apart from the original these Tech Giants so first of all we are going to sort the given input based on the start times of the given intervals after sorting we will have to iterate over all the sorted intervals and we are going to check that whether there exist an overlap or not we are going to check that whether the uh end point of any meeting is greater than the starting point of next meeting if that is the case we are going to return false immediately and and if this Loop ends and we are able to reach to the last element we are going to return true that there does not exist an overlap and now let's try to run this code okay seems like our code is working let's try to submit the code okay our submission works and uh the code is actually pretty efficient and uh I would be posting this in the comments it is not too many lines of code and this problem is very similar to the previous three interval problems that we had we have done so I would be posting them in the comments you you can check it out from there thank you hello friends we are still not employed by a Fang company so let's also up lead coding until we get there today we are going to do a lead code premium problem and uh you can clearly see that this has been one of the most popular lead code premium problems this has been asked in companies that companies like Amazon Facebook Google Bloomberg Microsoft Oracle Walmart Uber Twitter Apple Goldman Sachs Tik Tok and by dance and also some other companies like eBay adob Sue uh they all have also asked this question uh fairly recently so my aim you all know that I want to get a job at any top tier Fang company and that's why I'm making these videos so I'm paying my atmost attention and I hope you also enjoy the video lead code medium problem and it is one of the most popular problems on lead code if you see the like to dislike ratio also the name is meeting rooms 2 so basically it is the next version of the original problem meeting rooms that I have already solved over here so you can check it out from there now in this given problem we are basically given an array of meeting times called intervals and we are given a start value and an end value and obviously start value is always going to come before the end value like as it should be now we need to say that based on the given uh number of uh meetings how many number of minimum conference rooms we are required so that all the meetings can be accommodated and we know that for any single meeting we need at least one conference room and when that meeting ends that conference room can be used for some other meeting so suppose uh say for example we have a meeting that starts at uh at 5 uh and ends at 15 minutes and we have another meeting that starts at let's say uh 17 minutes and ends at 27 minutes something like that so in this case if we only have one conference room we are still good why because first of all this meeting will take place all the attendees will attend this meeting at 15 this meeting is going to end and then they are going to leave away from this uh meeting and then these new people are going to attend the meeting in the same conference room so in this case we can clearly determine that okay with one conference room we are we are we are sufficient to complete all the meetings now but problem comes when say for example we have a meeting that starts at 0 and ends at 30 minutes uh I'm using this original example that is given so suppose we have we have a meeting that starts at 0 minute and ends at 30 minutes we have another meeting that let's say starts at 5 minutes and ends at 10 minutes and we have another meeting that let's say starts at 15 minutes and end at 20 minutes so something like that so essentially over here we are having three different meetings and now for these three meetings how many any minimum number of rooms we need to accommodate all the uh meetings so clearly we can see that essentially there exist an overlap between this this meeting and this meeting there also exist an overlap between this meeting in this meeting so because there exist an overlap that is causing us to create to have more than one rooms because at any given moment two meetings cannot be two two meetings are happening at the same time but they cannot be placed in one conference conference rooms so now we will have to determine that how many number of conference room we need well we will need in this case we will need two conference rooms why two conference rooms if we look at this start time and end time for all the meetings initially let's say we have a conference room like this so initially this first meeting takes place which starts at this 0o minute right so let's say that okay this minute is this meeting is being taken place over here now when we reach at this time number five we know know that another meeting also needs to be started but this conference room is also already occupied so we cannot use this this conference room so what we will have to do is we'll have to use another conference room and uh let me draw it over here so we will have to use another conference room to accommodate this meeting over here now at this five time number five we started the meeting but we notice that at time at Value number 10 we also finished this meeting which which means that now all the folks that attended this meeting they are actually coming out of the conference room and now this conference room is empty but this conference room is still occupied with this original ongoing meeting so that we will have to take care of so at Value number 10 we already emptied this uh conference room but again we start seeing in this order so we can find that at time number 15 we still need one more conference room to attend the meeting so we check okay this conference room is already occupied so we can't do anything but this conference room is empty because this meeting has already been completed which means we don't have to worry about it so this meeting at that starts at time number 15 needs to be placed on this second conference room again and then it ends at minute number 20 so at 20 minutes all the folks they empty the this conference room so again this conference room is now empty now there is no one but this meeting is still going on and and when the time clock hits 30 minutes we can see that okay now this particular conference room the first conference room is also going to be empty and folks are going to leave it at time number 30 and this is basically the approach so at any given moment the maximum number of conference rooms we are using to accommodate all the meetings were actually two so in this case we will need to return two as our answer the question comes that why we were able to generate this to why not some other value and how do we programmatically solve this problem well the approach is actually quite simple that over here what we what we needed is only three only two things uh the first thing we needed is that at any point what was the start Point what is the end point and based on the start and end points we can actually uh come up with some very interesting results so if we see over here in this example what we were doing is that at any given moment we are iterating over this time sequence and based on the starting point of the meeting and ending point of the meeting we are either occupying the room or we are emptying the room and just by keeping track of those two activities we can determine that what is the minimum number of rooms that we are that we need in order for us to accommodate all the meetings let me show you how so over here again keeping up with the the same example so let's say that in this example we already have the start and end times of all of them so what we can do is we can have two arrays so first array would be for starting values and second array would be for ending values and we are going to sort both the arrays based on the timing so over here the Sorting values would be that what are okay so what are the starting points starting points we have over here is 0 five and uh 15 so we have three starting points originally and over here you can see that they are in sorted order but if you look at the original input we can't see them in sorted order order like uh they can be jumbled up or the values can be given in any order right so first of all we will sort everything and then that sorting is going to take big off n log n time so that is uh some activity that we will discuss when we come to the time and space complexity so in initially the Sorting position currently this value is 0 5 and 15 okay let me get rid of this extra space okay now for the ending values the ending values are uh 10 20 and 30 so again let's sort sort based on the ending values so 10 uh 20 and 30 and now what we are going to do is at any any given moment we are going to check both of these uh arrays and in among these two arrays we are going to see that what is the minimum value amongst either starting value or ending value and we are going to keep a count or keep a variable called meetings and we are going to increase the value based on whatever the results we find over here so let's try to do that so initially we we start We compare these two values we see that okay zero is minimum amongst these two so because we are starting a new meeting which means we will have to occupy a room and because we have to occupy a room what we are going to do is we are going to do meeting Plus+ so essentially the the value of meeting was originally zero so we are going to keep the value as one now we are going to now we are keeping the value as one what we are going to do is we are going to iterate over so this we are keeping at this because this this has not been updated in the ending value but in the starting value this zero has already been taken care of so we ignore this case and now for the starting value we compare this uh value number five so again we compare this value number five with this value number 10 we see that okay the smaller value amongst these two is still this starting point in the starting array and because we are starting a new meeting which means that we haven't completed any meeting but we are starting a new meeting so because we are starting a new meeting we'll still have to add the value of meeting so currently the number of of conference rooms we will need we are going to increase it to two and by the way this you can call it consider as meeting rooms I just named it meeting just for Simplicity okay now again we uh we are done with this five so again for the start value we increment and over here we are still at this position number 10 again we compare this 15 and 10 so over here we realize that this 10 is actually smaller than 15 which means we are ending a meeting before so now because we are ending the meeting so we we will jump on this ending array now we will come to this place and because we ended a meeting which means we will have to subtract the value over here so what we are going to do is rather than having to we will reduce this value back to one but and so now we are at this 15 and 20 so we compare both the values and we realize that okay this 15 comes first so we are starting a meeting now so so because we are starting a meeting we will again do Plus+ so now this one becomes two and uh we compare this meeting with this answer so both are both values are two so we don't need to update anything and uh that's why uh over here we are done with this case so now there is no more place to start the meetings so actually we can end over here why because over here the moment we are going to like reach this and this value all we are going to do is we are simply going to reduce the the value of this meeting parameter back to one and then again back to zero so there is no poin in us for doing all this work if the starting uh array has already been dealt with and this would be our solution uh like this is a very simple solution to understand and easy to come up with and this is also very optimal and it solves the problem efficiently so let's see that what would be the time and space complexity the time complexity in this case is going to be bigo of n log n so this is initially for sorting as I mentioned earlier plus bigo of N and this bigo of n is to iterate over the start and end array so uh in general we can write this as big off n log n Only and uh now we are done with this one uh in terms of space complexity for the space complexity it would be biger of 2 N because we are storing two arrays and in the both arrays we are storing some n values so but in general we can write this as big of n as well and uh this would be the optimal time and space complexity first of all we are going to check that if the given uh array of intervals is empty or not if it is empty we are going to return zero that is not the case we are going to create two integer arrays start and end and for both the arrays we are actually going to fill out all the values in the start start array and end array once that is done we are going to iterate over the given input and uh from the given intervals we are going to fill out the start and end array once this is done we are going to sort the given start and end array and once sorting is done uh we are going to initialize a couple of pointers so we are going to name them a start pointer and an end pointer and we are going to initialize the values as zero and these pointers are going to be used to iterate over this start and end array and once these two are done we are also going to have a variable called result uh to keep track of the number of meeting rooms that are needed and we are also going to initialize it to zero and now uh we are going to run a loop but remember that we only need to run a loop until the start array has some values so we are only going to iterate over the start array because one St start is done the result value is always going to go down and at any point we are going to check that whether the current start value is actually greater than or equal to the end value or not if that is the case we will have to update the end array and the reason we are doing it is suppose we are given a couple of arrays like this that uh a meeting starts at zero and ends at 10 minutes and there is another meeting that starts at 10: and ends at 15 so in this case we can actually use just one uh room or one conference room to iterate over why because first meeting has to end first before the second meeting starts this is a condition that is given and we are going to use that hence if this is the case we are going to decrement the number of uh result that is and we are going to increment the endp pointer and if that is not the case so which means that we essentially have a starting a meeting starting before the previous meeting ending and in that case we will always have to increase the number of rooms needed so we can simply increase the result and we will also have to update the starting pointer and at the end uh once this Loop is done we can simply return whatever the result we found let's try to run this code seems like our solution is working let's try to submit this code and we are actually solving this problem way faster than a lot of other Java Solutions and uh you can see it over here so I would be posting this code in the solution uh in the comments you can check it out from there Hello friends hope you're having a fantastic day today so now we are going to solve a lead code problem called minimum interval to include each query we can see that this one is a hard problem and also decently well- like problem the statement says that we are given a 2d integer array named interval where any single value basically defines an interval with the left and right boundary that is inclusive of left and right boundary then we are also given basically an integer array called queries and for any particular query value that is currently present we need to return like an interval within the given interval array that contains that query or that value and we need to return the size of the smallest such interval so we need to first of all identify that which interval contains that query and then if there are multiple intervals containing it we need to find the one with the smallest size and then we need to return the size this is the formula to calculate the size of any particular interval that is right limit minus the left limit + one because it's right and left inclusive so let's try to understand it with a with an example suppose this is our intervals 2D array that we are given we can notice that there are four intervals given in total and we are given uh four different queries that we need to find answers to so let's go through queries one by one so first query is one um like query number two now we can notice that this interval contains two this interval contains two and this interval also contains two so in this case as part of the answer we need to return uh the size of an interval that is the smallest that contains two which is going to be this one because the size of this interval is going to be basically 3 - 2 + 1 so size is going to be 2 over here so we need to return two as the answer same way for Interval number four so uh this interval does not contain four this one do contain four and this one does not and this one do once again let's compare the sizes so size for this interval is going to be 5 - 1 that is 4 4 + 1 so basically the size is going to be five over here the size is going to be 9 - 4 that is 5 + one so size is going to be six so once again this is the smaller interval and the size of the smaller interval is five so we are going to return five as the answer same way for seven there is only one interval that contains seven so basically we need to return the size of it which is six and for 11 notice that there is there does not exist an interval that contains value 11 so we cannot fulfill this query so in that case we need to return minus one okay so this is the answer we need to return now after understanding the problem let's try to solve it using a simple Brute Force approach well Brute Force approach seems quite obvious in this case that uh we are basically given bunch of different intervals right uh if we take a look at this this example that we currently have and we have bunch of different queries that we need to find answers to so logically in The Brute Force what we can do it whatever the query is we can pick that query iterate over each of the inter that contains that query and then the moment we find that okay there exist like let's say three intervals that contains the query find the sizes of each one of them whichever is the smallest uh put that size in the answer and repeat the same operation for all the subsequent remaining queries now let's calculate the time complexity for brot Force approach basically we have to do n work for all of the values that are currently present for each of the query uh we might have to iterate over every single value that is currently present in intervals so basically once again we will have to do n multiplied by n work so basically this is going to be big of n Square uh time complexity for The Brute Force approach let's see if we can shorten this period um by doing something smarter and the answer is quite obvious we are actually going to be using basically sorting in this problem to solve this problem now let's see that where does sorting comes into the picture number one thing is we have bunch of different uh intervals that we are given that we don't know um they can be random orders so let's say that I'm trying to currently process a query number five and there are let's say 50 intervals present do I need to iterate over all of these 50 intervals no if I have sorted these intervals based on their start time all and end time all I can say is the moment I hit an interval let's say that contains the start time of let's say 6 to 5 something like the 6 to 7 if there is an interval like this I know for a fact that all of these intervals are no use for me in order to find query number five or value number five if it has to exist it has to exist between these value if the intervals are sorted so first thing we are going to do is sort intervals based on the start time second thing is now same thing needs to be done for the queries as well uh now the thing is queries can also be unsorted so we need to find match basically over here for each of the query there could it could be possible that there are multiple intervals that uh that query can can have and then we need to find the shortest or there could be some queries that does not have any interval so basically we are also going to sort the queries so that would make our life easier okay so we are also going to be sorting the queries based on ascending order now let's see that what is the third smart thing we are going to do and that is I just explained that for each of the queries it could be possible that there are multiple different options we have from which we need to select that what is the interval with the smallest size so if there was a way for us to determine or store these sizes per interval in smart manner it would be really helpful and for that we can actually use a priority Cube or a heap basically in the Heap we would see that for any particular query how many intervals that are currently possible and let's say we identify that there are three interval that are possible we'll just sort them based on their sizes so let's say that this could be of size one this could be of size two and this could be of size three so one would be the first that would be the root of our Heap and then two and three would be like subsequent nodes and they would be readjusted because it's a priority Q okay after doing this we'll also have to do one more thing smartly and that is it could be possible that we could reach a query let's come back to our example like this value number seven now if we are processing value number 7 and let's say that we have already processed this value 2 and four now in this case we don't need to worry about all of these intervals because they are irrelevant to us because seven can never be there and we have already processed all the values that where that that were coming before 7 so why do we need to keep this intervals in our priority Cube we don't so that's what we are going to do that whenever we are going to be processing any particular query we would be check checking that what are irrelevant nodes inside the priority Cube and if there exis in irrelevant nodes we will just simply delete them so this is the pretext of what our optimal solution looks like and the reason that this is a hard problem is because of all of these steps that we'll have to do that first we'll need to sort the intervals then we'll need to sort the queries and then we'll need to use a priority cue and over there we'll need to delete irrelevant nodes in order to do it now mugging it up won't won't help you so you will have to understand the logic on why we are doing each of these things okay so I hope my explanation was clear now let me give you an example and we'll do a quick walk through okay okay so let's say that this is the list of intervals we are given this is the list of queries we are given now first thing we'll need to do is we'll basically need to sort intervals and sort queries so let's quickly do that now sorting intervals is it's not going to be very complicated because we only have to Interchange these two values apart from that all the other values are already sorted based on their starting values which you can see over here so let me quickly make that change so this is going to be 712 and this is going to be basically 8 and uh I think it was 8 and 10 yeah okay after doing this next thing we need to do is sort queries but thing is we are going to be iterating over queries one by one to store their uh size and the intervals so if we sort the these queries it could be possible that we might run into issue of finding out that what would be the correct order to return the answer because we are returning the sizes so what we'll do is we'll leave these queries as it is basically we are just going to create a placeholder where we would be storing their um uh subsequent index positions okay so let's say that we'll just create a new array that is going to contain all the queries that are correctly ordered okay but we are going to be returning answer based on the index values that we have already stored okay so now we have the list of queries that we need to process now let's see that how does our Heap is going to look like and what are the values the Heap is going to contain okay so first thing is we will try to process query number two now in order to process query number two let's see that what are the the nodes that can contain query number two and there are two nodes first node is uh value 1 and four and second node is going to be value 2 and five now if we see size of both of these size is going to be four for each one of them so we can just store them as it is now because we are processing query number two let's see that are there any irrelevant nodes inside the Heap that uh that are no used to us and there are none because both of the nodes currently contains query number two so so that's good for us now we will have to return the minimum size this query contains and the minimum size is going to be so let me just create an answer array over here the minimum size is going to be four so I'm going to be marking four as it is and remember the query position is correct so that's why this is the correct position where I'm returning next thing is query number four we are trying to process okay so what are the nodes that contains query number four so this node contains query number four this node also contains query number four and there is one more node that contains query number four so let's just add node number 3 to 6 over here as well now if we add this node 3 to 6 what is going to be the length this is also of size four So currently we have all of these as size four so we don't need to delete any of the irrelevant nodes okay now let's see the answer is going to be four but notice we are not going to be writing four over here because four is actually the third value inside the index position so we are going to have an empty placeholder over here and in the third position we are going to store the size as four for the second query that we process okay now the third query we need to process is value number five now for Value number five notice that this first node becomes irrelevant because the ending value is four so it does not make any benefit for us to keep it in the Heap so we can just remove it quickly so basically we would not have this node being store now let's see that what are other nodes that we can include so 7 to 12 we cannot include because the starting value is actually greater than five and all the other values would always be greater than five so we cannot include that so currently there are only two nodes that can contain value number 5 2: 5 and 3: 6 both have the size four so we'll just store the size four but notice five is located in the second position or index position one so we will store five over here okay now we will need to process query number once again for query number 9 notice that this 7 to 12 contains query number 9 and this 8 to 10 contains query number 9 so we'll have to include 7 to 12 over here and we'll also have to include 8 to 10 over here as well inside the Heap but at the same time notice that this 225 and 326 are irrelevant because there cannot be any further nodes that we can use it for so we'll just uh remove it from our Heap and only keep these two values inside the Heap now let's just Mark the sizes of these two values as well so this is uh this this is going to be the size uh 6 and this is going to be size three so if that is the case A8 10 needs to be the root of the Heap so which means 7 and 12 is going to come later and this is going to be of size six so uh now the very first element is going to be 8 to 10 for this query number N9 but notice query number N9 is located on the last position so for the last position the size is going to be three so we'll just mark it as it is and the last query we are trying to process is value number 11 now notice that this 8 to 10 becomes irrelevant based on the last value so we can also remove that and now there does not exist any more intervals that we need to process but there is value that currently contains query number 11 and that is 7 to 12 which is value number six so we can just uh Mark size six as it is and we can return return this as the answer so I hope the solution makes sense now let's try to analyze the time and space complexity okay so time complexity is going to be basically first we are going to be sorting the intervals so that is going to take big go of let's say n log n time okay plus we are sorting the queries so that is going to be big of M login plus we are using a heap to basically go over queries uh and intervals so that is going to take m + n log n time and uh this is the time complexity so notice that yeah even though it looks longer it's still significantly lesser compared to big of and um n Square time complexity okay and if we see analyze the space complexity because we'll have to use an additional Heap and an additional array to store the index position basically we can just Define it as bigo of let's say n + m where m is the length of like total number of intervals and N is the total number of queries and that's what we are storing inside the Heap and an extra array so once again I hope the solution made sense you have to understand that why we are doing these things and uh now let's quickly see the coding approach for this now the coding solution is going to contain lot of steps so let's go over them one by one first we are going to define the length of given queries as n and we will be generating a result array to store the results then we are going to be storing the original index positions uh that are currently present inside our list of queries okay uh and that is uh being stored in a new array called query indices so that's where we are storing these values then we will be sorting the intervals and we would be sorting the query indices uh this is to basically make sure that uh we have sorted values and we will initialize our Min Heap that is going to be our priority Q where the values are being stored based on the Lesser size and uh we are also going to have an interval index this is to iterate over each of the values now in the for Loop first we are going to iterate over every single query that is present inside our query indices and then for each of the queries we are going to check that what is the interval index that we are currently have and what is going to be the length of that particular interval we are also going to check that whether the starting value of the interval index is if that is less than or less than or equal to query or not uh if that is the case we will Define left and right values then we'll also check that we will only take care of the intervals that contain contains the query so that would be done by comparing the right side of value and after that we will try to find that what is the smallest size value that is going to be at the top of the Heap so we can just do Min heap. offer and then we will be updating our index to iterate over the next value after that we also need to remove irr relevant indices uh from the Min Heap and that is to check that if uh what is going to be basically the right side limit compared to the query and whatever the value is we can just quickly pop that out after it we basically need to store the results so that two we are going to do that if we do find the value inside the Min Heap we are going to be keeping it if we do do not find any value we will return minus one so we'll try to keep track of the small EST in size indices that we can find and I know it seems confusing but if you just go over the code it would be easy now let's try to run this code okay seems like our solution is working beautifully let's submit this code and our code beats nearly 55% of all the other Solutions which is pretty awesome we can improve upon the space complexity I can agree to that but anyways this is a very complicated problem and and it took like a lot of understanding of different concepts to solve it so if you can solve it in an interview kudos to it would be Prett pretty good so now uh the coding solution is present in our GitHub repository feel free to go and check it out from there thank you hello friends we are still not Ed by Fang company so let's not stop lead coding till we get there today we are going to do rotate image lead code problem and this problem actually has very real practical applications as we know that there are bunch of different softwares that allows the option to rotate 10 image and if we see the list of companies where I want to join in and already have asked this problem uh there are companies like Facebook Microsoft Amazon Apple Google Bloomberg Uber Tik Tok Nvidia eBay PTM and Robin Hood so that's why I'm paying my atmost attention I hope you also enjoy the video this is a lead code medium problem and basically we are given an N cross n2d Matrix which represents an image now we need to rotate this image by 90° clockwise also one more thing that is mentioned that we need to do it in in place we do not need to use an additional 2D Matrix to solve this problem so the space complexity has to be constant in this case let's uh try to see it with an example so over here we are given a matrix like 1 2 3 3 4 5 6 7 8 9 and we can see that this particular row is actually converted to this column which means that all the nodes have been transported to 90° which means this one has gone to this place this two has gone to this place and this three has actually gone to this place and same goes for all the other elements that this four has actually gone to this place which we can see over here and this seven has actually gone to this place which we can see over here and the same way it is shown in this second example okay suppose this is the input Matrix we are given which means that this is the answer for the 90° rotated Matrix now notice couple of interesting things in both of them well over here the value 1 2 3 is in a row so over here this value 1 2 3 is actually in a column same goes over here that this value 456 is in a row but this 456 is in a column and same goes for the 789 789 so this is a clearly a pattern over here and BAS basically what we can do it is that if we somehow convert this input to replace all the values that are inside the rows to be inside the columns and then reverse those entries so reverse all the rows we would actually get a 90° rotated array and let me quickly show you how we are going to do it okay so suppose this is the original input I have drawn it much bigger over here and now what we are going to do is for every single row we are going to place it inside the column and every single column we are going to place it in the row which means that currently at if we consider this position position number two if we see the I and J's location this is this two is actually located at the position 01 representing these two values so what we are going to do is we are going to flip the values of this 0 and 1 and same we are going to do this for this four which means that this four will come to this place and this two will come to this place the thing they did for this 2 and four we are going to repeat for all the other characters and then we would have an array which would have where all the rows would have been converted to all the columns also there is a name for the process of converting all the rows to all the columns and that is actually called transposing a matrix so first of all we are going to transpose this original given input Matrix and we will see that the result would look something like this so uh this one will remain at the same position because this 0 0 is at the correct place so we don't we can't change anything now this two is going to be replaced by this four which means that over here we would have two and over here we would have four again this three is going to replace by this seven so over here we would have seven and over here we would have three so if we just notice right now this Row 1 2 3 has actually been converted to a column and this column 147 has actually been converted to a row we are going to repeat the same process now and now uh this five will not have any impact because the position is actually 1 one but for the six and 8 we will actually have to swap their values that now over here we would have the value number eight and over here we would have value number six and this N9 will remain at the same position because the value is 22 which means we can't do much about it and now uh basically now we have created all the rows and converted them to different columns now the next idea is that we are going to put this in the reverse order and if we reverse the rows for this transpose Ed Matrix we can clearly see that we would get a 90° rotated answer uh let's do that so over here the values would be 74 1 if we reverse this particular row same thing we will do for this one so the answer is going to be 8 52 and again for this one the last row the answer is going to be 963 and if we see this is actually same as the answer we had achieved before and I just draw all these three different Matrix to give you an example that how we are going to do the things but basically all of this activity can be done in place in inside the single Matrix all we will have to do is we'll have to use a temporary variable to first of all SWAP the elements in this fashion and then once that is done we will need a temporary variable to replace the values uh inside the given Matrix and reverse the rows uh if we see the time and space complexity for this approach basically for the time complexity we are actually we will have to iterate over all the elements inside the given node to create this transpose Matrix and once the transpose Matrix has been created we will have to reverse all the elements which means that the time complexity in this case is going to be bigo of n cross n but we will have to repeat this process two times so which means we can say that bigo of n cross n * 2 but in general we can just write it as B of n cross n and this would be our solution in terms of space complexity as mentioned earlier we are not using any additional space which means we are doing it in a constant space complexity and this is a very good solution any interviewer would be really impressed with your approach and this works for all the different n cross n Matrix now let me quickly show you another solution for the same problem where we don't need to do like this transposing activity and we can actually solve this problem in a single go so for the second approach we have going to do things a little bit differently first of all I have drawn over here bunch of different Matrix of different n size so n is equal to 1 2 3 and 4 I have shown you and now we are going to see that if we rotate the 90° can we see some patterns over here so suppose we have a matrix of the size number one if we rotate this 90° it makes no sense it's the value is going to still remain same so we are going to keep it as one now for this n is equal to 2 if we rotate this matrix by 90° actually the thing is going to happen is that this one node is going to shift shift one value to the right this two node is also going to shift one one value to the right three uh four and three all of them are going to shift one value to the right and the answer in this case is going to be okay so first of all we'll shift one over here one value to the right two and then four and then 3 so this is the 90° rotated angle for this n is equal to 2 so basically what we have done is we have rotated all the values one place to the right okay for the outer layer and in this case since we only have four elements which means the layer is only one we are good so when when we get to This n is equal to 3 things becomes a little bit interesting and interesting how because we have the cells located on the outer layer and we have one cell that is located in the inner layer now when n is equal to 1 when the number of cell that is located inside the inner layer we know that the value is going to remain same so even if we 90° rotate this particular element it is still going to fall over here on the same place we are not going to do anything special with this one but for these other values we will going to apply the same logic we applied over here where over here where because n was two we had to rotate all the values one degree to the right or one place to the right in this case because n is equal to three we are going to rotate all the values to the two two elements to the right okay and this would be the answer so if we see in this case this one is going to come at this place this two is going to come at at this place this three is going to come at this place and same thing is going to keep on repeating for all the other elements and that is how we are going to find uh its solution so let me quickly draw the solution for this outer layer over here this is the answer for the outer layer of this Matrix and because in the inner layer we only have one element and for one element we don't have to do anything special the five is going to be at the same place and this is going to be the solution that we rotated all the elements couple of places to the right now in this case n is equal to 4 so obviously for the outer layer you can imagine that the patn we are going to follow is going to be the same that we are going to rotate all the elements three steps to the right okay so that is clear but for this inner layer we can actually see that this time we have a set of four values where which means we have a 2 cross2 Matrix inside so over here we are going to use the the same logic we used over here where we are going to rotate them one step on the right so first let's do it for the outer layer and then we will do it for the inner layer so the rotation for this outer layer is completed now for this inner layer we will have to rotate them one times based on whatever we have seen when n was two so we are going to do the same thing this is the answer of 90° rotated angle which means one thing we can see over here is is that we can have four pointer starting at this 1 4 16 and 13 and rotate all these values in place by using a temporary variable once that is done we can repeat the same process for this value number two 8 uh 15 and 9 and again we will keep on rotating them sequentially at the same time in place and then we would be able to fill out our outer layer once that is done we will come inwards and we will start filling the inner layer based on whatever the number of n we have and that is the approach we are going to take okay so suppose we have a 3X3 Matrix and I'm going to show you what is the approach we are planning to take now this additional Matrix I have drawn that is only for the understanding purpose actually we are going to do everything in just one single Matrix but I'm just going to show you that what are the value changes happening and how we are going to use this temporary variable to fix our problem so first of all we are going to store the value of this one inside our temporary variables okay so the value inside the temporary variable is one now what we are going to do is first of all we are going to project this value number seven to this place one so this becomes seven and this becomes seven currently this is the scenario now we are going to project this value number nine over here which means that this 7 is going to be replaced by value number n and this is also N9 at this at the current moment again we are going to project this three to this N9 which means that the value of this 9 is going to be replaced by three and this is going to remain three and now at the final moment we are going to take whatever the temporary variable we had and we are going to put it in this place which means that this value is going to be one so at a single iteration we have actually shifted values of all of these four places in its correct position again we are going to repeat the same procedure for this these four values which means that over here now the we are in the next iteration now the value of the temporary variable is two now because the value of the temporary variable is two first of all we are going to project this value number four to this place number two which means that currently both values are going to be 44 then we will project this value 8 to this four which means that this is already eight and this value becomes 8 then we will project whatever value of six we had at this position number 8 which means that this value would become uh six and this is already six and at the end we are going to take whatever the temporary variable we had we are going to project that value over here which means that this six is going to be replaced by this value number two and once that is done essentially in two iterations we have taken care of all the values that were placed out in the outer layer and we are done with this one now only thing we need to consider is this inner layer and because the for the inner layer n is equal to 1 which means that we can basically leave the value as it is and this is the answer answer and this is how we are going to able to rotate the the entire element in 90° in just like very few iterations uh we don't have to do like transpose Matrix and then place the replace all the values and change all the values so even if we see the time and space complexity in this case the time complexity is going to be biger of n uh cross n but the we only have to do it single times and space complexity is going to be bigo of one because we are only using an additional temporary variable to store some values apart from that we are not using anything special to store any values so we will initialize a variable called n and we are going to store the length of the Matrix for this one once we have that we will have to iterate over this given Matrix and we are going to create two for Loops to iterate over this given Matrix now remember we only have to iterate over half of the Matrix we don't have to do much work which means that we are not going to iterate from in I equal to 0 to I is equal to n we are actually going to do it I is less than or equal to n + 1 by 2 now you'll ask that why n + 1 by 2 because in the condition where the given n is odd number we will have to take care of that scenario as well so first of all we are going to create a temporary variable and we are going to store value of one of the elements inside the stem variable and then we will start working on the flip operation for the remaining three elements once that is done we will start iterating over all the elements and once this Loop ends basically we would have rotated our Matrix 90° angle for all the elements now the question comes that how did I get this value of I and J actually I could explain it to you but I would expect that uh you draw the any 3x3 or 4x4 Matrix on paper and try to see that how we are getting the these values of I and J because that would be a very good exercise for you anyways I would be posting this code in the solution so you can you would be able to check it out but still I would expect that if you do it by yourself you would not never be able to forget it now let's try to run this code okay seems like our code is working let's try to submit this code and T our solution is actually 100% faster than lot of other Solutions and uh basically we are solving this problem pretty efficiently again I would be posting this in the comment so you can check it out from there and there I would ask you to figure out that how we are getting these values of I and J compared to this value of N and that would be a really good exercise for you to do at home Hello friends we are not downlo by Fang company so let's not stop lead coding till we get there today we are going to do spiral Matrix lead code problem and this problem has been asked by tons of my favorite companies uh companies like Microsoft Amazon Apple Facebook Google Adobe Uber Bloomberg Tik Tok Walmart Tesla PTM flip cart bite dance eBay Goldman Sach Robin Hood and Salesforce so you can imagine that this problem has been really popular at top tier ID companies and that's why I'm paying my utmost attention I hope you also enjoy the video so this is a lead code medium problem and basically we are given an M cross n Matrix and we need to return all the elements inside the Matrix in a spiral order so suppose we are given Matrix like this in a 3X3 Matrix we need to iterate over this given Matrix in this following fashion in a spiral and return elements in that sequence so to make things more understandable I have drawn different Matrix of different sizes and let's see that what would be the spiral traversal for each one of them so we will always start at the 0 0 position and then we'll start traversing on the right side until we hit a boundary so over here we hit a boundary and then because we hit a boundary we'll go downwards now again downwards we hit a boundary again again we will go in the left direction again we hit a boundary over here of the Matrix now we'll again go upwards in the direction but now this time we will not wait for us to uh hit a boundary we will actually stop at this position number four why because if we keep going in this upwards direction we will end up at this position number one which is though it is before the the boundary still this is the node that has already been visited which means that we are traversing in a particular direction until the point where whether we hit a boundary or we hit a visited Noe so this is a really important concept to understand now let's go back to the traversal so again from this four we will come back at this point five and now from this five you can realize that there is no other direction this five can go to and this would be the answer so this would be the end of the traversal let's see let's do the traversal for this 4x4 Matrix so again we start at the this initial position we start going on the right direction then again we go downwards again we go leftwards then we go up until the point when we hit uh this visited node again we go right again we go down and again we go left and this would be the traversal for this 5x5 let me quickly show you what would be the traversal and of course it's pretty simple to understand so I know you also know that what would be the traversal this is how we are traversing in each one of each all three of the cases now remember that there are two important things to consider over here first thing is that at any point we are traversing we are always following a pattern in terms of the number of directions or the type of direction we are taking and that pattern is always we start at the initial position uh which is this one and then we always go on the right side first after going the right direction we go downwards so we go downwards after going downwards we go leftwards and after going leftwards again we go in the up Direction so so we go upwards then again we go back on the right wordss again we go down and again we go left and dry up and we keep on folling until we reach to a point where all the nodes that are adjacent to any particular node so in this case this number 10 where all the other nodes they have already been visited in this case it would be this node number 13 where all the other nodes they have already been visited so we are traversing until the point where we exhaust out of all the nodes that we can Traverse and let's see that what would be the approach for us to solve this problem like we already know that what are the directions we need to Traverse into and we are always traversing in any particular direction until the point where either we hit a boundary or we hit a visited node which means that these things are important for us to keep track of that this boundary or this visited node we need to understand that how to identify them how to keep track of them and what are the different approaches to tackle both of these and what would be the solution so in order to solve this problem there are actually two different solutions I'm showing you both of them you can pick whatever you want to both have its pros and cons and you can discuss it with your interviewer which solution you want to pick so let's go with the first one now first approach is that we actually start shrinking the boundaries and we don't care about visited nodes how we are going to do it let me quickly show it to you so first of all we always start at this initial position we know the directions we need to take we go right then we go down then we go left and then again we go up this is the the state of direction we are going to follow let me also create our answer of the nodes that we are going to uh Traverse along so first of all we start at this position number one and then we follow up until this point where we hit a boundary over here now the moment we hit a boundary over here we are going to add all of these values to our answer so let me quickly add all the nodes to my answer and then because we hit a boundary over here and this was the direction right direction we know that next direction we need to go is downwards so we start going downwards but we are going to do one thing important over here and that thing we are going to do is we are going to ignore all of them and we are going to actually shrink our boundary up until this point so originally this Matrix was actually 4x4 Matrix now we are going to convert this Matrix to be uh 3x4 Matrix and we are going to ignore this first row as if that never actually bothered and that never actually existed uh so by doing so what we are doing is that we don't need to take care of these uh elements and since we have already added them to our answer so they are always going to be in in our answer as well right now again we go downwards in the same path until the point where we hit a boundary so we hit a boundary over here we are going to add all the nodes to our answer so nodes would be 8 12 and 16 in this sequence and again we are going to ignore all of them because we have seen all of them and now again we are going to shrink our boundary up until this point and we are going to ignore all of these places so let me actually remove them that they never existed for us now again after downwards we will start traversing on the left Direction so we go until this point we will add all the entries on in our answer and again we are going to delete all of them because they never existed for us and our uh boundary actually shrinks even further and after that we start going in the upwards Direction but notice over here we don't have to care about these nodes because we have already shrunk our boundary to only consider up until this point which means that we are going to add this values 9 and 5 and again shrink our boundary and then we will add this value 6 and 7 again shrink our boundary add value number 11 and then again shrink our boundary and in the end we are only left with one value value number 10 and we will add it to our answer and this would be the answer that we need to return so this solution works perfectly fine we don't have to bother keeping track of the number of nodes visited because we are shrinking our boundary with every single iteration and let's see that what are the pros and cons of this one so first of all we'll try to calculate that what is the time and space complexity for this one so time complexity is actually going to be big go of M cross n why M cross n because we have to iterate all the nodes inside the given Matrix so that is a given thing now in terms of space complexity we are actually doing it in a constant space complexity like you can't consider this answer to be a space complexity because anyways we have to return a list of uh all the notes that we have Travers so that is part of the answer that is not part of our algorithm and that is why this is a very good approach and you can discuss with your interviewer that if he's okay with this approach you can also move forward with this one let me show you what would be the second approach so for the second approach we are actually going to keep track of the visited cells and also the boundaries and whichever we hit first we are actually going to change our Direction so One Thing Remains common is that we are always going to Traverse in the same sequence of Direction so first of all we will Traverse in the right direction then we will go in the downwards path then we will go in the leftwards path and then we will go on the upward W path so this will remain common and then we keep on repeating and at any moment we hit either a visited cell or we hit a boundary originally we are at this position number uh one and we are going to mark all the coordinates of the Matrix so the coordinates of the Matrix is going to be 0 1 2 3 and 0 1 2 3 now current position of this one is actually 0 0 we can see over here so what we are going to do is we are going to create a hash set and in inside the hash set we are going to first of all check that whether the coordinate that we are visiting have we visited it already or not if we have not visited it we will add an entry to our hash set so at this position number one we will add an entry to our hash set saying that okay currently we are we have we have already visited this coordinate number 00 and we are also going to create our answer list and inside the answer list we are going to mention all the notes that we have davers which we need to return in the end so we will add the center number one and then we will keep iterating on this direction on the right side until we hit either a boundary or a visited nodee remember either a boundary or a visited note both the things we are keeping track of so and at the same time we are going to add all the entries so in this case we will we would have added entries like 0 0 0 1 02 and 03 all the things we have added we have also added it to our answer that we have already uh Traverse this nodes 1 2 3 and four and now we know that we since because we have hit a boundary it is time for us to go in the downwards Direction so again we will go in the downwards Direction until the point we hit a boundary and we would have also added all the values to our hash set as well again and also to our answer list as well like I'm not going to bother writing all of them but I can understand that you are smart enough to understand that again we go on the leftwards direction until the point we hit a boundary and again we start going on the upwards Direction but notice that when we are going in the upwards direction we are actually going going up until this point number five we are adding all the values to our hash set we are also adding all the values to our answer now at this five when we go try to go this position number one we would have ident we would first check that okay whether this position number one which is located at the coordinate 0 0 have we visited it already or not and we would identify that okay the 0 has already been visited which means that because it has been visited we actually don't need to uh go on go and do that again or what we need to do is change our Direction so at from this position number five again we would change our Direction in the same manner where would have ch where we would have changed our direction if we would have encountered any boundary so uh then again we will add all those entry six and seven and again add them to our hash set and then we keep iterating until we reach to the end of all the entire Matrix and we would have visited all of them now this solution works perfectly fine now but the thing is you would immediately say that hey this solution actually we are using an additional head set which means that for the space complexity we are actually using big go of M cross and space complexity which means how come this solution be can be better this is actually a bad solution uh so your interviewer is definitely going to uh let you know that okay you don't you can't use this hashset to keep track of all the visited noes uh in this case what we are going to do is there is another solution to solve this problem with without keeping track of all of the visited number of notes so at any position if we have visited some node what we are going to do is we are going to add it to our answer list first and then we are going to change its value and how we are going to change its values we are going to put something random that is out of bounds or it doesn't even make sense uh so over here suppose we are at this position number one and then we start traversing this 1 2 3 4 so we have traversed 1 2 3 4 we have added it to our answer and then at the same time the moment we we are done with traversing through any node we are actually going to change its value to something let's say uh minus 100 or let's say value number false or something like that right anything that is not part that can never be a part of this Matrix and we need to replace our value with this one so let's say let's say in this case we replace our value with this minus 100 considering that this would not be a part of this Matrix like it can be and then you can change this value you can discuss it with your interviewer and then again we start iterating in the same fashion so again we would have added all the values to our answer list and again we would have changed all of its values to whatever the value we decided and we are going to keep repeating the same work up until this point and notice that at POS this position number five when we try to go upwards we are going to check that okay if the value of this particular set sell if that is not minus 100 then only we can say that okay this node has not been visited and then only we will add it to our answer but the moment we find out that okay this value is actually minus 100 which means we have already visited this node and added to our answer already so now we have to change our Direction in the same manner where we would have changed our direction if we had encountered any boundary and then we would follow the same path and we would be able to solve this problem so if we see the time and space complex in this case the time complexity is also going to be big of M cross n and the space complexity is actually going to be bigo of one constant time space complexity now you would argue that the issue with this approach is that we are actually changing whatever the given input is and that is not a bad practice that is not a good practice in when you are actually doing inside the job but when you are giving any competitive coding interview your interviewer might expect you to do it so it's always good to know a better approach let's move on to coding now so first of all we are going to create an integer called visited and we are going to assign it some random value so let's assign 101 uh also we are going to create two variables to keep track of the number of rows and number of columns we have after that we are going to uh have a couple of variables to keep track of the row position and column position we are at and we are going to initialize it to Value number zero now we have to iterate over our four Direction so we are going to create a 2d array uh we are going to name it as directions and we are going to iterate over all the four directions so we are going to have four coordinates that would be used to go to any direction we want to and we are going to maintain a sequence uh where the first would be to go to right then next would be to go to down then left and then up now we need to keep track of what is the current direction we are at and when we need to change the direction so we are going to initialize couple of variables uh called current direction and the change direction and we are going to assign the value zero to both of them so we will have to create an array list to store the result so we are going to initialize a list of integers to store the answer and uh inside the inside our answer we are going to add the first node of our Matrix which is located at position 0 0 and after that uh remember every time we we go through any value we will have to update that value inside the Matrix because I am showing you the implementation for the second approach I showed in the explanation video so we will update the value of this Matrix node to this visited element that we already set up now we will start iterating over our um given Matrix and we are going to have few conditions so first thing is we need to iterate over the given Matrix also we have to iterate over in a particular direction and the moment we encounter a condition where we are either reaching a boundary or reaching a visited node we will have to change the direction so we are going to use current direction and change direction and make conditions around them so first first of all we are going to have a v Loop that while the change direction is actually going to be less than two and why less than two because we are we have four directions and at any point we can only go in One Direction and when we are the maximum amount of pns we have is either we can go on right down or left up path and that is what we are going to use once that is done we will have another V Loop that takes care of all the possible ways where we need to restrict our Matrix first four conditions would be to check what that whether we are hitting a boundary and the last condition is to check that whether we are hitting a visited node or not if none of this is true first of all we will have to reset the change direction to zero because we are not breaking any direction after that we are going to update the value of row and column then we will add the current Matrix row and column position to our answer array list and then we will update that value for that particular row and column position to visited uh value and after first Loop ends we will have to update the values of the current direction and change direction so for the current direction we are actually going to add a value and then we are going to module it by four and we will have to update the value of our change direction and after both the loop ends uh basically our answer error list should have all the elements and we would have traversed the Matrix so we can simply return that let's try to run this code okay seems like our solution is working let's submit this code and our code actually runs 100% faster than all the other Solutions which is pretty nice also I have created a GitHub repository where I have been where I'm storing all the problems that I have solved so far and you can go to any problem and you would be able to find the Java solution for that and you can use it it's quite helpful and uh I would be posting this link in the solution as well also this uh solution in the comments as well so you can check it out from there thank you hello friends we are employed by Fan company so let's lead coding till we get there today we are going to do set Matrix zeros problem and this problem has been asked by some of my dream companies so companies are like Microsoft Amazon Facebook Apple Bloomberg Adobe and also sometime in the past there are there have been Google and Goldman Sachs and eBay they all have asked this problem and that's why I'm paying my atmost attention I hope you also enjoy the video so this is a lead code medium problem and it is a very well-liked problem uh basically we are given an m by an integer Matrix and we are told that at any point if we identify that there exist an element that is zero then we need to set that entire row and entire column as zero and uh we are also told that we need to do it in place so let's see it with an example so over here in the example we are given a matrix like this in the input and we can see that this is the element that is zero so because this element is zero we will have to convert this whole row and this whole column to and set it up to zeros and we need to return an answer like this one uh same goes with this second example that we are given a matrix like this where we are to we are given two zeros at these two locations and because there are two zeros we will convert this entire row and this entire column to zero because of this particular zero and we will convert this entire row and again this entire column to zero because of this particular node so this row is common so anyways we will just convert it to zeros and this would be be the final answer we need to return so suppose this is the example that we are given and let's see that what could be the most basic intuitive approach that comes to our mind well first thing that comes to our mind is that we can actually start iterating over whatever this given input is and the moment we encounter a value zero we can just convert that column and that row where the zero belongs to all and set it up all to all the zeros uh and let me show you that why it won't work so first of all we'll start iterating over here we are we across this node this node and this node we don't find any zeros so we are good so far now at this point we identify that there exists a zero over here which means that uh for this particular column and this particular row we will have to convert it to zero so let's just do that so if if I if we do that what we will basically do is uh we will remove all of these entries and now we will convert these entries two zeros which means that uh this is zero this is zero and this will all be become zero now the problem will happen that after iterating this element the moment we reach to this particular node we will again have to convert all of these values to zeros as well but remember that that should not have been done why because originally the value over here was actually one which means that this particular uh row this particular column does not need it to be create converted to zero because of this particular note so that is the problem over here let's see that what could be the solution so let me quickly draw back this to its original form one thing we can do is we can actually create a copy of this one and in that particular copy uh we can actually uh start making the change whenever we find a zero in this particular Matrix so that we do not end up changing the elements before they are being visited so let me quickly create a copy of this particular node okay so now we have created a copy again we'll start iterating over all these elements weon don't do anything over here we identify that that this is a zero element the moment we identify that this is a zero element we will actually make changes to this particular copied element so now we will update the elements in this particular fashion so all of these would be converted to zero now again we start iterating over this one so this is one this is one so we are good this is also one so we are good now this is again a zero so because this is a zero we will again update this row and this uh this column and this row in the copied node so let me quickly make those updates and this will be the solution so in the end we can actually return this copied solution where there is only one entry over here and all the other elements are zero so this solution would work but the issue is that we are actually using a bigo of M cross n space over here so let's try to see that can we do some improve ment rather than using this additional space okay so in the previous approach we used a new Matrix to keep track of all the elements where the rows and columns the entire things need needed to be done out to zero but this is actually not necessary uh remember that at any point we identify that inside the given Matrix if there exist a zero all we need to do is we need to convert that entire column and row set it and set it up to zeros uh which will happen in both of these cases so because at any point we identify a zero the change applied to entire Matrix for that particular row and column why do we use the entire additional Matrix to store all the values this is useless and better approaches that we can actually create another uh set where we take care of all the row positions and all the column positions and all we need to care is that at any point if we identify a zero at any moment uh we simply need to enter that entry in those particular row and column positions and then convert those row and column position to zero let me show you quickly show you how we are going to do this so over here we will start iterating all the nodes and we identify that uh these particular nodes uh 1 2 and three these nodes they are not zero so we are okay with this one but this is a zero so because we identify that there exist a zero node we will quickly note this position to this row and column entries so we will add an entry over here called zero and we will also add an entry over here called zero right we are good so far now again we will keep iterating over this given input uh in the similar fashion so these two are also not zero and this is also not zero so we are good so far uh next we are going to do is that because this entry is zero again we will record those positions inside this additional row and column set that we have created and now uh this last entry is also not zero which means we we don't care about anything and at the end all we need to do is we need to iterate over this additional created uh sets and see that at whatever position we encounter the zero value for that particular row we will convert convert it to zero and that particular column we will convert it to zero so first of all we will visit this uh hash set of rows and we identify that okay first one is zero so because first one is zero all of these entries needed to be converted to zero so we will convert these entries to zero so we good so far again we identify that second is also zero so again we will repeat the same thing and we will get rid of all of these ones and we will convert them to zeros as well now this last one is not one so we are good and we will we will not touch this particular column now we will do the same thing for this one so this is because this is zero we will convert all of them to zero so this becomes zero and uh this one is also zero so we will convert all of them and this last cell also becomes Z and uh in the end we can just simply return this newly created Matrix so this is a much bigger Improvement then that in the previous one we were actually storing an additional entire Matrix where the space complexity is B of M cross n so over here the space complexity is actually improved and we are only using big of m+ n why plus n because uh suppose the number of rows are M and number of columns are n so we are still creating this two additional has sets with those particular element values uh the question is can we actually do something better and even not using this M plus n space and can we actually use the space complexity to be big of one and yes there is a solution that achieves this in B of one as well so let me quickly show you how Okay so pre so previously we were actually using an additional data structure like this one to keep track of all the rows where we need to change the value to zeros so over here suppose we identify that there exist there exists a zero over here we would update that value in this particular place and later we would know that hey we need to convert all these values to zeros and we were also using another data structure to keep track of number of columns that needs to be converted to zero in the same manner that over here we identify that this is a zero we will update an entry over here and we will mark this point as zero and later we would update all of these nodes to zeros but rather than using this separate nodes what we can do is we can get rid of them and we can do the same thing by using this first row as an alternative for this original uh additional data structure and also we can use this First Column as an alternative for that original uh column data structure and uh basically we will do the same concept but we won't be using any extra space anywhere and this is a wonderful approach now there will be one problem with this one and the problem would be that over here we would be using this particular uh row to keep track of all the columns where the value needs to be converted to zero and same way we will have to use this particular column to keep track of all the nodes where the rows needs to be updated the problem is that this particular position is actually a point of conflict uh where there exist two intersecting nodes so we will what we will do is as a solution we would actually create an additional node and we will use these two nodes uh so these three nodes would be working in combination and for the First Column uh we all we will need to do is just use this entire uh first row to keep track of all the columns that needs to be updated and let me show you that how we are going to do the things Okay so so first of all we will iterate over this Matrix and we identify that okay this value is one so we don't care this value is also one so we don't care now this value is zero so because this value is zero we will have to make change to this particular uh row and this particular column but this is at correct position this zero for this row so we only have to update it over here so we will add an entry zero over here right now uh next thing we will do is we will keep iterating over this Matrix so we'll update we'll check these three values and all of them are one so we are good this is also one so we are good now this value is zero so because this value is zero we will have to update over here and also over here so we will do that so we will convert this value and convert it to zero we will also convert this value and change it to zero and uh at the end we will just iterate over this element and this element is already one so we don't have to do anything now this is the Matrix we have all we will have to do is we'll have to iterate over this and the these six nodes and at any position we identify the zero we will convert that row or that column and change it to zeros so first of all we will start iterating over this uh first row and this is one so we are good but this is zero so because this is zero we will have to convert all of these to zero so let's do that so this value would be turned to zero and uh we are good now again we come at this position this is also zero so all of these values needs to be converted to zero so we will flip all of those values to zeros as well okay now we are done iterating over this first row now we will iterate over this this First Column so for the First Column we identify that okay this particular position is zero so because this is zero we will update the entire this entire row as zeros so let's do that so we will get rid of this first value and we will change it to zero now we will iterate to this next node so this is one so because this is one we will not touch this row so we don't have to do anything and this is zero so this because this is zero we will have to convert this entire row to zeros but since these two nodes have already been converted to Z we don't have to do anything and this would be our final solution so uh if we write the answer we can actually write an answer like this one this would be our final answer and we can actually return this as the answer and this solution works perfectly fine let's see the time and space complexity in this case so the time complexity is actually going to be big go of M cross n why because we will have to iterate over this entire Matrix and uh that takes M cross n time uh in terms of space complexity we already know that we are only using this additional node apart from that we are not using any additional space so the space complexity is actually constant space and this is the final solution this solution is very good and let's see the coding first of all we will create an additional variable and we will create a Boolean variable and we will just name it as First Column we'll initialize the value as false and now we'll have to iterate Over The Matrix so we'll need to know the length and height of the Matrix so let's initialize two variables uh to store the height of row and column of the Matrix now we'll have we'll start iterating over the Matrix and we'll start updating the value inside the first row and First Column so we will check that if inside the given Matrix for the first draw if there is any element the where the value is uh actually zero then we will convert that uh and we will update the value of the first uh call variable once that is done we will also have to iterate over all the columns so we will create another loop inside the loop and now we simply have to check that whether at any position we we are encountering any value that is zero if there is any value that is uh zero we will have to update the corresponding I and J position inside the first uh row and column subsequently so once this Loop ends uh all the values should have been stored uh inside the first row and First Column so all we will have to do is iterate over the first row and First Column and we will update the subsequent rows and columns so we will check that if at any position uh the corresponding value for the I and J position if that is zero inside the first first row we will have to update the element of the this particular node inside the Matrix to zero as well and once this Loop ends we would have taken care of all the elements inside the given Matrix but we notice that we are running this loop from I equal to 1 and J equal to 1 which means that we are not taking care of first row and First Column so we'll have to take care of first row and First Column now remember in order for us to take care of the first draw we will have to check the first very first element which is this uh this particular element inside the given uh Matrix so we will do that so we will check that if uh Matrix at 0 0 position if that is zero we will have to update all the values inside the first row and once that is done we will also have to check for the First Column so for that we will we actually have a variable First Column and if the First Column variable if that is true then we will have to update the first uh column to zero and uh after this ends I think we should have taken care of all the nodes so let's try to run this code okay uh seems like a compilation eror it seems like our solution is working let's try to submit this code our submission did not work for this one oh we'll have to start from J equal to 1 inside this First Column so let's try to run the code again let's try to submit it again okay seems like our solution is working and it's actually pretty efficient compared to a lot of other Solutions I would be posting this inside the comment so you can check it out from there also I have created a repository inside the GitHub where I have posted the solution of all the Java problems that we have done so far inside the lead code okay so this is the repository you can go to any problem and you would be able to find the accepted Java solution for that particular problem and I will be posting this link inside the description as well so you can check it out [Music] so the lead code problem we are going to solve now is called happy number now we can see that this one is an easy problem and also an extremely well-liked problem the statement is quite straightforward we need to write an algorithm to determine that if the given number N is a happy number or not and we are given the conditions that how can we Define a number to a happy now it is quite straightforward that starting with any positive integer n we need to replace the given number by the sum of the squares of its digits so let's say that we are given a digit like 16 right if n is equal to 16 in this case we need to replace n with the square of its digit so current digits are 1 and 6 so we need to do 1 square + 6 Square so this is going to become 37 and then once again we will need to do the same thing for the 37 as well where we would do 3 S + 7 Square so this is going to be 9 + 49 so I think it's 58 and yeah so so on and so forth we would keep on repeating this now we need to repeat this until either the number equals one where it would stay as it is or it would Loop endlessly in a cycle which does not include one so either we need to keep on doing this process until this becomes one or until we find out that there is actually a cycle that is happening and there are only two possibilities either it could be a cycle or it could be one now for those numbers when which process this ends in which ends in one are defined happy so we need to return true for them and uh all the other ones we need to return false okay so let's try to understand how we are going to solve this problem by an example suppose the given number n is equal to 19 S so in this case the square is going to be 1 sare + 9 Square so basically 81 + 1 so 8 82 once again for 82 so it's going to be 64 + 4 so 68 now for 68 so total is going to be 100 now for 100 it's going to be 1 square + 0 square + 0 square so basically this is going to become uh the value is one so because we find Value to be one we can Define 19 to be a happy number and in this case we can return true now let's take one more example suppose the given n is equal to 2 this is going to be the the full sequence and this is the full math behind it so you can notice that I have marked all the values defined as circles and if you want you can just pause the video at this moment and notice the numbers but overall notice that we start at two and at some point we end up at two as well and if we keep going forward then next value would be four and so on and so forth so we would be in in an infinite Loop so in this case we can Define the given number n is not a happy number so we can return return this as false so this is the ask of the the problem now let's try to see the solution now for this solution Brute Force basically doesn't make that much sense because it's very quite straightforward we only need to take care of that whether n yields in value one or if n yields in a cycle now we know whether if n yields in value one or not that is quite straightforward and easy to understand we can keep on we can have a method that basically get the square of the sum of given values and and basically for the given value we keep on repeating the process for given n where let's say the if the N value is going to be 55 first we do a modulo by 10 so we get the last digit that is going to be five then we do it square and add it uh to the sum then once again we do the we divide n by 5 so the remaining value is going to be 50 because this is going to be integer and then once again we do it modulo by uh 10 so basically we would get value is five and then we will just do the square of it so this is going to be the full Logic on how we will proceed with getting the square of the sum it's quite easy to implement and we would see that in the code now if we have to detect cycle all we need to do is to keep track of all the N values that we have generated so far and we will have to find a mechanism to quickly access that so for every single new value of n that comes in we would know that whether we have already visited this value or not and for that best way is to move forward by using a hash set so the idea is that we would have a hash set that would keep store of all the different unique n values that we have found so far and there can be two scenarios whenever a new value of n is being found out either it could already be existed value of N and which means we found a loop so we we can check that using hash set in B of one time or the given value of n could be one if either of this cases happen then we simply get out of the loop and we return whatever the subsequent value of n we found so that's quite straightforward now if we see time and space complexity in this case time complexity is going to be bigger of n because we are simply treating over given input n once now space complexity is also going to be bigger of n because we are using this additional hash set to calculate all the possible values of n but overall this is a decent solution and a very easy problem so now let's quickly see the coding solution in this case so the coding solution is actually quite straightforward first of all we are going to initialize a variable called seen numbers and this is going to be a hash set that we are going to be using to keep track of all the numbers we have visited to make sure are we in a cycle or not then we are simply going to have a while loop where we are checking that while the given n is not equal to one and the current number is not present in the uh hash set of seen numbers that we have seen if that is the case first of all we are going to add the new unique entry to the seen numbers hash set and then we are going to have a helper method called get sum of squares and pass in the value n now let's understand this uh method the helper method this is simply going to return an integer value uh and we are checking that current sum is equal to zero now while the given n is greater than zero we are going to start breaking the given value n based on digit by digit by doing a modulo of 10 and we are going to add the square of that particular digit uh and add it to the existing sum and then we are going to divide the current n by value 10 and notice because n is integer so all the fractional values would be eliminated and we are only dealing with raw integers now in the end we simply need to return the sum uh once we are getting out of the loop and and then based on this sum value we would populate our n and keep on repeating the process now the moment we get out of the loop there can only be two conditions either the given n is equal to 1 or we found a scenario where the number was already present in the seen numbers so in either case we need we simply need to determine that whether if the N is equal to 1 we can return true if n is equal is not equal to one we can return false and this would be our Boolean response so let's try to run our code seems like the solution is working beautifully let's submit this code and our code beats a lot of other Solutions which is pretty good now we could do some work in terms of space complexity now because we are using an additional hash Set uh we are not the best in terms of space complexity but there can be ways to improve upon them let me know in the comments if you want to see the improved Solutions and maybe I can put it in the GitHub repository meanwhile this solution is present in our GitHub repository so you can go ahead and check it out from there thank you the lead code problem we are going to solve now is called plus one we can see that this one is a lead code easy problem and also a very well-liked problem basic Al we have given a large integer that is being represented in an array sense and represented as digits where every single value inside the digit represents that particular position so now we need to just simply add one to this given array and uh return the new value in the form of the array so without reading all of this let's just try to understand it normally let's say that we are given an input basically uh originally we are supposed to be given value 95 2 3 but this is given in the form of an array now we need to do + one so basically this value would become 9524 and this we need to return as the array so we are going to once again going to create an array and we are going to return 952 4 and this is the answer that we will have to return same way if this these are the digits we are given we are simply going to return return 1 0 02 but in the form of an array now the the thing is when we are dealing with any value that contains nine then we will have to work about the carry because we are adding one value to it so if this is the value we know adding one would yield the value is 1 0 0 0 0 so once again this is also going to be the array that we are going to have to return but now notice that because these are all four NES this was a four digigit character but this became five digigit answer so we will have to return an array with five entries and this is the only only Edge case where we'll have to do something now logically if you are ever going to be presented with this question you are simply going to use the most basic math of addition and subtraction so you are going to take whatever the value that we are given that let's say that we are given value 1 2 3 you are going to start traversing from right to left and in this fashion first you will take the value if this value is not nine then we can simply just add one value to it and return the answer so in this case since this three is not nine so we can make it as four and then return the array as it is so we are only changing the one index value let's say that we are given a value something like 1 2 and 9 now in this case we know that this is a value 9 the moment we identify that there is a nine we are going to change this to zero and we are going to have to add one to this particular value and keep keep on repeating the same process so basically in this case we would would have considered this to become zero and now for this remaining portion 1 and two we can once again repeat the same operation that we will have to add one value to it so in this case for this one and two this is going to be added with one more value and since this is not n so basically we are going to Mark is Mark this value as three and then return the answer as it is now the only problem is if we identify for some reason that all the given characters are nine then in this this case what is going to happen first we'll try to add one over here so then basically this would become zero because this was N9 so we will have a value like this where currently this is N9 this is 9 and this is zero but this n also has value one that we will have to carry over uh after the same operation once again this would become zero this would become zero and we would have one carry over above this nine once again in the next iteration all of these three would have become zero um sorry all of these three would have become zero and we would have still have one more carry that we are going to add in a newly created value so the simple algorithm that we can create is that we will start iterating starting from right to left if we identify that value does not contain nine we simply do plus one and return the array as it is for some reason if we find that the value does contain 9 we are simply going to mark that index position zero and once again repeat the same operation for the remain remainder of the array of adding value one and keep on repeating the same process for some reason we end or we go through the entire array and we identify that we are at the end of the loop then we simply need to create one more array that is going to be the size one size greater than the previous digits array that we were given and we are going to initialize first value as one and all the other values as zero and return that as the answer so this is the whole solution now this is not any data structure or any problem that we are using uh so it is going to run in big of one constant time uh space time complexity sorry constant space complexity now in terms of time complexity this is going to be dependent on the total number of digits that are present so this is still going to be big of n but it's not that much it's a very simple problem and now let's quickly see the coding solution for this one so the coding solution is quite straightforward all we need to do is just iterate over all the digits from from left to right and we are going to have for Loop to do exactly that and then we are going to check that if the given digit is less than 9 we can simply increment the digit and return the digits array as it is if that is not the case if it is N9 then we will have to turn it to zero and repeat the same process for subsequent digits uh moving from right to left fashion now in case if all the digits were nine that we find out then we simply need to have a new array called new digits that is going to be one uh character longer or one array space longer than the original digits array that we were given and we are going to mark that value as one because that is going to be the most significant bit and the all the other ones are going to be Zero by default and uh then we can simply return the new digits array so this is the whole solution let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs beautifully beats 100% of all the solutions that is because it's a very simple problem uh the coding solution is present in our GitHub repository so feel free to go ahead and check it out from there thank you so the lead code problem we are going to solve now is called Power of x to the power n now this one is a lead code medium problem and also a very well like problem but let's understand the problem statement basically we want to implement a power of x to the power of n kind of a function that's it this is the whole solution so in the input we are given two values X and N where X defines any integer so let's say value is given two and N would Define the power that we need to generate so let's say given n is equal to 4 so in this case we'll have to return 2 to the power 4 so so this is basically going to mean that 2 * by 2 * by 2 * by 2 so basically this is this turns out to be 16 and this is what we need to return now for different kinds of input it could be possible that the given value of n could also be negative as well so if the given value is n is negative then simply uh let's say that we are given the value 2 to the^ minus 4 so in this case we can still perform the same operation but basically we are just doing 1 divided 2 to the power 4 so this is going to be 1 divided by 16 and I don't know what is the decimal value but something like 0.06 or something like that so this is what we need to return okay so let's try to see that what is the most simplest approach to solve this problem we know that we are given a value of n it could be positive or negative uh let's consider those scenarios later but let's say that value of n is given five and we are given the value of x so let's say x is given two we can simply run a four Loop uh that while n is greater than zero basically we would keep on reducing the value of n 1 by one and multiplying the value of x by whatever the initial value of x we are given so let's say currently X is equal to 2 during the first iteration we are going to do 2 * by 2 and the value of n is going to be four then three then two then 1 and so on and so forth and in the end we can return this value as 32 as the answer this solution would work as expected no issues with this now what is going to be the the time complexity the time complexity is going to be big go of the total number of n that is currently present and which is a fair enough time complexity it's not that complicated but thing is uh we want to make improvements to it and we want to make this faster and better solution that for any given value of x let's say the value of x to the power n that we are trying to calculate we can also write this value in x² and then we do n divided by 2 because if we do LHS with rhs then basically X would become X multiplied 2 multili n ided 2 so this is also going to be x the^ n right but logically we can come up with this solution now notice that by squaring the X with itself we are reducing the value of n by two and we can keep on repeating this operation every single time so in that case the solution would run in of logarithmic of n time complexity now let me give you an example on what I mean let's take our scenario we given X is equal to 2 and we given n the value of n is equal to 4 we know that 2 to the^ 4 would become 16 but uh let's try to use my formula so in this case for 2 to ^ 4 we can say that 2 square and then we can also do like on top of it here the value is four so 4 divided 2 so this is going to be 2 as well uh 4 divided 2 I hope you understood now if we do that we know 2 square is going to be 4 and this value is going to be 2 so basically this is going to be 16 and we can return this as the answer now notice in this case all we had to do is just do this one iteration once we did not have to do 2 multili by 2 multili by 2 multiplied by two so this is a much better solution but of course it comes with uh an additional cost on itself now let's try to think that how we can take care of negative scenario so if the given value of n is going to be negative value once again same method can apply but in this case if 2 to the power of -4 then we need to do 1 / 2 ^ 4 so in this case we would do 1 divid 2 the 2 to ^ 2 and then on top of it it's going to be two so once again the same set of steps are going to be done the only thing is for negative value of n we would change the value of given X to 1 / X so I hope that also makes sense now now there is another scenario that we did not consider and that is that so far we consider this value of n to be uh an even value so that's why doing like uh this operation of uh n / 2 was easy like this operation but what if this was an odd odd value so if let's say for some reason we are given X to the^ 5 so in this case we can also treat this as x * x ^ 4 so in this this case we would just first multiply it with the current value of x and then we would have an even value of N and then we would just simply return the same logic so this is going to be X multiplied uh x² uh and square of it so yeah that's the whole point now there is also one more last final Edge case and I know you all must be done with all the edge cases but if the given value of n is equal to Z then anything to the power 0 is always going to be 1 so this is the standard thing so we can just directly create a case and return that that if the given n is equal to zero we can directly return value as one so let's do a quick recap we are basically going to do X to the^ of n uh as x² and N ided by 2 if the given value of n is odd then we are going to do x * x uh squ and N / 2 if the given value of n is negative then we are going to first convert X is equal to 1 / X that's it so this is the whole solution it works as expected time complexity as mentioned it's going to be B of log n which is exceptionally good space complexity apart from storing couple of variables we are not storing much so it's not going to be that expensive and uh now let's see the coding solution so the coding solution is going to be quite straightforward first we are going to handle the base case where if the given value is equal to zero then anything to the power of zero is going to be one so we can quick return that now if that is not the case first thing we are going to do is to convert the given n that is an INT value to the long value because and this is being done for some specific Edge case scenarios nothing more than that then we are going to check that if the given n is equal to negative we will first have to convert n to positive and we will also have to replace the value of x with 1 divided X so basically we are going to be treating n as positive every single time no matter what the value has been given but we'll just uh update the value of the given X now we are going to create a variable called double uh result and current product and this is to store the total results and the uh appropriate result that we need to return okay now we are going to use our log logarithmic function where uh for as long as n is greater than zero we are going to check that uh what is going to be the module of n uh by 2 if the value is one which means the given n is an odd number so we are just going to do result multiplied by current product once so that way basically we are going to be taking care of uh treating n is equal to even numbers from for the subsequent values then we are going to be multiplying the current product with the current product so basically Square the base and then divide the value of n by 2 so at every single step we are making the value of n turning it into half and then doing the multiplication so and then we in the end we can simply return the result so let's quickly try to run this code okay seems like our solution is working as expected let's submit this code and our code beats 100% of all the other Solutions and that is because we are solving this problem in big of uh log and time which is exceptional and we are also beating a lot of other solution in terms of memory and that's because we are just doing things efficiently so once again the Cod solution is present in our GitHub repository feel free to go and check it out from there thank you the coding solution we are going to solve now is called multiply strings and we can see that this one is a lead code medium problem and also a very well-like problem now in this case we are given two integer uh nums one and nums 2 but they are represented as a string and we need to return the product of num one and num two which also needs to be represented as a string now in this case we cannot use buil-in library that converts string to integer and then just do the multiplication on its own so we'll have to find a clever way to do it and The Logical way is very straightforward basically we are just going to apply the same Technique we learned sometime in the grade third or fourth uh let's say say that if I tell you that I have this number 24 and 7 and I need to do multiplication of these two number what is the going to be the simplest logic so in this case 4 * by uh 27 is going to be 28 so I'm going to use 8 and the carry is going to be two then once again 2 * by 7 is going to be 14 14 + 2 is going to be 16 so I'm going to be storing this value and this is the multiplication result let's try to up the NT and let's try to do 12 * by 13 right in this case we are going to do the multiplication in two steps and uh first step is going to be multiplying this three with this two and one and then next step would be one multiplying this one with this one and two and then storing the result now notice every single time we move one digit to the left we are going to add a zero subsequent zero as well so let's do that so this is going to be six M and this is going to be uh three okay now we will have to multiply one with this 12 but actually we are multiplying 10 so we are going to be adding one zero over here and then this is going to be two and this is going to be one and we are going to do the sum of these two values so this is going to be this 56 and this is the result so basically this is the whole idea of how we can multiply multiple digits or like two digits that contains multiple digits uh number one thing is we need to start from the rightmost position now starting from the rightmost position we are going to take a digit uh like in nums one or nums two let's say that num for nums two we took one digit that is going to be this three we are going to take this digit and multiply with every single value of this nums one okay so we can do that next thing is we are going to store this value somewhere that where it needs to make appropriate sense and this appropriate sense comes from two portions first one is number one depending on the index position we can determine that where this value should stay now let's come back to our computer based solution number one thing is if we are given two digits nums one and nums two we need to store them somewhere and the logic we are going to apply is that we are going to store them be storing them in an array now the maximum length of this array can only be the total length of the sums of digits N1 and N2 so we can generate an array like that and I don't want to get into mathematical explanation on why that is the case but that is the case trust me on this so let's say you generate an array that is going to be storing the result now after doing that we'll have to do the tedious operation of storing the result for every single value but we don't need to do one by one we'll need to figure out what is going to be the appropriate space where we can directly store the results so let's say that this is going to be three mult multiplied by two so we know that we'll have to store six somewhere in this array but where the six is going to lie that is going to be some of the index positions of these two values so let's say the index position over here is 0 1 2 and 3 now the index position for this one is going to be one and the index position for this one is also going to be 1 so 1 + 1 is going to be two so we need to store this value in I index plus J index + 1 this value so we store it over here and if there were to be a carry which is not in this case well let's say instead of this being 12 what if this value was 16 so in this case we would have stored eight over here and then there would have been a carry and that carry would have been stored One Step before that so this is where we would take take their carry in and then once again repeat the same operation for this two values and find the appropriate index position to insert that value like this so the multi ication is going to be stored at I + J + 1 location I just explained why and then carry is going to be stored at I + J location because that is going to be one location lesser than the previous location now the question is how we are going to convert all of this string into numbers so we cannot use directly Pars in method but we can do it at the Character level so at a character level we can just subtract the value from from zero and then whatever subsequent values we can actually convert that into integer so I'll show you in the code on how it's done so now let's see that what are the things we have number one we have the way to convert nums one and nums two into integers so let's say we would have values like this next thing is we are going to have a result array where we are going to be storing all the results of all the calculated values and last thing is we are going to apply the common method of multiplying all the values or like digit by digit so taking in one digit and multiplying with all the other digits and once again repeating the same operation for all the remaining ones taking care of the carry and storing them in the appropriate position inside the result array and that we are going to be doing by doing I + J + 1 and I + J for the carry okay so I hope this explanation makes sense multiplication it's quite straightforward we are just going to do it the same way we have been doing since second grade and that is to take care of all the values uh and then take care of the carry and whatever the values we can store it in the answer this solution would work perfectly well uh and in the end there is going to be one last thing that we need to do because we have the result being stored inside an array we will have to convert this array back to string and which we can do it using string Builder or there are many inbu methods that can do it and we are allowed to do it and last lastly we need to convert it into two string and return that as the answer so this is the whole solution This would run in big of M multiplied by n time complexity where m is the total number of digits present in nums one and N is the total number of digits present in N2 because we are multiplying all the digits with all the other digits there is no faster way to do it apart from this and U it's acceptable because that is what the question demands and uh in terms of space complexity because we are using an additional array to store all the values this is going to be big of n plus M where once again n is the total number of digits for N1 and M is the total number of digits for n N2 nums two and this is an acceptable solution now personally if someone ask this question in an interview I think I don't think like it's a very valid question to begin with but it's a popular question and sometimes interviewer like to throw some C balls at you so hopefully you can tackle them just as easily as I explained but overall now let's move on to the coding solution for this one now the coding solution is not the most straightforward one even though the problem is very simple so let's walk through the coding solution first we are going to check for an edge case that either num one or num two is equal to zero we can simply return zero if that is not the case we are going to initialize our result array that is going to be uh of of the combined length of num 1 plus num 2 and then we are going to iterate over every single I and J combinations so we are going to use two for Loops to iterate over all the numbers now notice that we are going in reverse so we are going from rightmost position to the leftmost position now for every single character we are going to multiply uh both like we are going to multiply digit by digit and even though we cannot use directly par int mechanism we can still convert uh any particular string value to appropriate integer value by doing this operation at the Character level and then we are going to multiply both of these two digits after that important thing is to find appropriate position inside the result array to store that product and we are also going to need to store the high value that is where we are going to be calculating the car after that we are we will add the multiplication result to the current position and also handle if there exist any query uh or sorry any carry and then uh we are going to set the current position to the remainder value of the result position low and also divided by 10 to find the high position value uh so we can work with appropriate next values that are going to be coming in then we'll need to convert this array result array into a string which which is quite straightforward we are just going to use the string Builder function and then we can check that if the return the product value if that is equal to zero we can simply return zero if that is not the case we will just convert it to the two string and return whatever the value it is as it is so let's try to run this code okay seems like it's working as expected let's submit this code and our code runs beautifully beats most of their other Solutions which is very good also really good in terms of space complexity as well so once again the coding solution is present in our grub repository feel free to go and check it out from there thank you hello friends hope you're are having a fantastic day today so now we are going to do an awesome lead code problem called detect squares and we can see that this one is a lead code medium problem and also not very well like problem because it's like quite complicated to understand but I really found this problem quite fascinating so let's try to work on this basically we are given a stream of points on an X Y or two dimensional plane and we need to design an algorithm that basically does two things first it adds the new points that we are getting of stream of XY plane data dat structure in like basically storing them somewhere in a type of data structure and duplicated endpoints are allowed and they should be treated as different end points so we'll have to keep track of the frequency of any particular endpoint at any given moment second thing is given the query Point uh we might be needed to implement a method called counts where we are given a point XY point where basically we need to determine that out of all the points that we have added so far based on the given counts Point are we able to generate any squares and if we can we need to determine that that what are the total number of squares we are able to make using that particular point and all the other previously uh points that we have received so basically we need to uh Implement a detect Square class and we need to have two methods in it first one is add that basically adds a point and second one is count that returns that how many number of squares that we have we have been able to generate now let's try to understand this with an example typically we would be given an input like this where first we are initializing the detect Square class and then uh we are adding bunch of the values and we are also at random instances asking for a count of total number of squares that we have been able to detect and these are the end points that we are adding so now let's try to see how it looks like visual ually so basically in this example uh first we initialize this uh detex squares then we add three values so those three values are 1 1 1 3 and 3 1 so they are over here 1 1 1 3 and 31 only these three values okay and at the same time we also come up with uh a count mechanism where we are trying to check that does there exist any Square from this 31 end point so basically uh from this particular endpoint are we able to generate any squares now notice that at this moment in this method we only have these three points so we are not able to generate a square at the moment so we will return zero for that count method but subsequently we add one more point that is this 33 and which is defined over here and after that once again we ask the same question of generating a count and to which we can notice that now we are able to generate a square and a square is simp that every single edge should have the same length and they should be perpendicular to each other so in this case each of the this has a length two and they are perpendicular to each other like X and Y axis so that's why this is a square that we can form using this 31 point so in this case we would return one as the answer and we could have a case where let's say uh next value we are trying to add is once again 3 three so we would have one more point over here and then we are being asked to check that are we able to generate detect any squares using this 31 end point so now in this case we can generate two squares first Square looks like this and second Square looks like the other previous end points so basically in this case we would have return two but you get the point that we what we are trying to generate now understanding this problem is actually quite complicated how do logically we can make this solution work basically and then we will try to understand that how can we tackle of implementing add method and how can we tackle implementing the count method in the most efficient manner now let's try to visually understand the solution approach uh we are given these four points we are trying to determine that how many squares we are able to generate using this 31 end point number one thing that we are going to do is to check that do we have any other points that are common with X and point values so in this case we can find that there exist a value 33 that is FR from this point because we also have an endpoint called 31 that is currently plotted uh but we cannot use the same end point in this case so let's say that we want to find a value that has X but a different y okay so we find a corresponding Val value 33 now we know that these two are going to be in a straight line now if there were to exist uh another value that can generate a square basically it has to be of the same Edge length as this one so it has to have the value two uh as the edge length of it okay now we have one of the edges for the square what would it allow us to generate the square number one thing is we can iterate over all the other remaining points and try to see that what are the different points we have and are we able to generate a square from that or not but in this case we would have to take a look at all the different three remaining sides that is going to be an expensive operation second approach we can do it is that based on these two end points we can determine that what are the end points we are going to need because we already have the distance two in order to generate a square uh and we know for a fact that if let's say that on an empty graph we only have the values 3 three and 31 and we are being told that these are this is one of the side of your Square then other side of the square has to live uh somewhere over here or over here where the distance has to be two in either case and let me explain what I mean because we can only generate a square like this or we can generate a square like this because this is a common Edge this has to live there for sure and we know that this this distance has to be two and this distance also has to be two in order for a square to exist so what are the potential end points we know that this is 31 and this is 33 so if there ex there has to be a square with value two possible then that value is going to be so this value would have become where we are adding the x coordinate to with value two so basically this would have become 5 and three and this would have become basically 5 and 1 if let's say we had this Endo present we could have generated a square because notice that the difference would have been two on each side and this has to be two because of this or second option is that we could have on the other side so that is going to be uh xus 2 values for both of them because y coordinate is going to remain constant because we are uh aligning our match based on the y-coordinate so this value would become basically 1 and uh uh three and this value would become one and one and we know that now we already had one side that was 33 and another side that was 31 potential two values we found is either 53 and 51 or 13 and 1 uh 1 so now the thing that we need to do is is to check that amongst the added end points do we have either these two entries or these two entries it's not like if we have 13 and 53 it would work no it would not work it has to be pair of 13 and 1 1 or pair of 53 and 51 and in this case we know from the input that we have a pair 13 and 1 one and if we are able to find these end points basically we are able to generate a square so we can just update that value and it could be possible that if we had this point let's say 13 two times and 1 one 2 times then in this case we would have generated 2 multiplied by 2 so in total four squares if we only had this like two times uh and uh this value maybe just once so in this case we would have generated 2 multiplied by 1 because of the number of occurrences only two squares so we will have to keep track of the frequency of endpoint as well in order to determine that what is going to be the fastest solution so now let's come back to our original ask we basically were given a data structure where uh sequentially we are adding the values now in order to add the values what are the things that we need to take care or we need to understand number one we need a quick way to look up whether any particular x value ex x coordinate exist or not and why are we considering same can be said for the y-coordinate I'm just taking X because it logically makes sense why because remember in this case we were able to quickly identify this endpoint and then we wanted to check corresponding values so uh um corresponding values would have been like 53 and 51 or 1 1 and 13 so in this case we were able to uh checking based on the xend points that is number one thing second thing is we also need to store appropriate y coordinate in accordance with the x coordinate because there are pairs being present for X Y pair and third thing is uh we need to know the frequency of any particular Endo so if let's say this 13 was present two times I wanted to know this quickly so what is what uh data structure comes to your mind in order to store this information that can fulfill all of this number one if we are trying to store X and Y we could have used something like hashmap but in this case apart from storing X and Y we also need to store the frequency as well we can still use hashmap but this this is going to be like a slightly complicated hashmap because number one we are going to have a hashmap where we need to have key value pairs so we are going to key and value combinations as key we would treat the x coordinate values so let's say that currently first we had the value 1 one we would have added one over here and as its appropriate value we are also going to store one more hashmap a mini hashmap within hashmap and that two is going to work uh run basically the same way it is going to have a key wal pair of its own pH where the key is going to be the y coordinate so basically this is going to be value one and the value is going to be the frequency of Y coordinates occurrence because we already have the frequency of x coordinates occurrence we only need to keep track that how many times the same y coordinate occur for the same x coordinate so in this case the frequency is also going to be 1 one so we can store that information same way next coordinate we are adding is going to be 13 so once again the key one is going to remain common but as part of its value we are going to have one more entry inside this hashmap where now the value of x y coordinate is going to be three and its frequency is going to be 1 okay then we are going to have one more entry where the x coordinate is going to be 31 so we are going to have one more entry three and as y coordinate the value is going to be one and its frequency is going to be one same way we have one more value 33 in this case so three we already have it as a key as an input so we would have stored over here the another value three that is the y coordinate and its frequency is one so we are keeping track of frequency at every given instance and for every single x coordinate we have the subsequent y-coordinates and its frequencies so it follows both of our uh desired needs now we know how how to quickly add a value if we see time complexity in this case this would have run in nearly big off one time every time because based on the x coordinate we would be able to quickly look up uh and we would be able to see that what are the corresponding Y coordinates in also big off one time because we are using a hash map in terms of time like space complexity this would become an big off end solution for every combination of X and Y pairs we would need to add new entries to the hash map so we can generically just mention that this is going to to be big of n okay this would be our solution for adding um method or to build this data structure okay next portion of the problem is that how do we detect squares now notice that for the detect Square method uh basically we need to generate that what is going to be the count of squares and we are given an entry point so an XY coordinate that we are already given we can treat this XY coordinate as one of our uh X1 and y1 that we are trying to working with so we are going to be dealing with an X1 value and we can quickly check in our hashmap that whether we have any other values for this X1 that is currently present within our DX Square method so let's say that we wanted to detect that for this value 31 how many number of uh squares exist okay so in this case for this 31 we know that the x value is three so we will come to our hashmap and we will see that for this three how many corresponding XY values we have one value we have is going to be three and one and so this is one value that we currently have present but because it's the same X and Y we cannot use this Endo so we'll just ignore this next value we have is 33 so next value that is currently present is going to be 33 and that is pretty good that we can actually use this so now we have one endpoint is 31 another endpoint is 33 so difference between y1 and Y2 is going to be 2 now because we have this value two all we need to do is to add two to the one side of X and add two to the other side of X so basically we already have this one and one Edge 3 1 and 33 so now we will need to determine that + two on the X side so that is going to be uh 51 and uh 53 do we have this pair present and second one is 1 1 and 13 do we have like this combination present and if either of this combination is present which again we can quickly look up because we have we are storing all the information in a hashmap so we can quickly look up whether five is present as a as an input or whether one is present as an x coordinate and if they are present what are the corresponding y values we can also take a look at the frequencies and then we would basically just detect the squares and build the the solution so this is the whole solution and if we try to understand the time complexity for um basically count operation this is slightly tricky but not that tricky because uh we know that we can quickly look up the values of x coordinate for any particular entry in B of one time but for that x coordinate there can be multiple Y coordinates so in the worst case scenario we might have to iterate over all the possible y coordinates as well because imagine let's say that instead of this being one one what if we have all of these bunch of different end points and even over here we have all of these bunch of different end points for every single pair we have to keep looking for the combinations of different X and Y coordinates so that would become an a hassle so the time complexity for this count method would be biger of M where m is the total number of Y coordinates present because in the worst case we might have to iterate over all of them so that's still relatively a good time and space complexity given how complex this question could have been so we are trying to use the logic and power of math and some geometry uh to solve this problem and to not go through the Brute Force route so I hope the solution made sense to you now let's quickly see the coding approach for this one so the coding solution is going to be slightly complicated but let's understand so first we are initializing a private hashmap that is that that we are naming as points count that we are going to be using to adding all the values and notice that we have key as an integer and its subsequent value as another hashmap so there is a hash map within an hashmap okay then we are going to have a detex square method that is simply going to initialize the hashmap and then we are going to implement the add method now in the add method it's quite straightforward that we are considering the value X as 0 Z and value y as .1 for every single x coordinate we are initializing a new hashmap if the x coordinate is not already present and then for every single y-coordinate we are checking that if it is not present we basically uh add the frequency as one or if it is present we basically update the existing frequency so if it is present like two times we just add it to three okay now here comes the meat of our problem that is the count method now in the count method as an input we are given an end point so we are treating its X and Y coordinates as X1 and y1 this would allow us to iterate over all the possible combinations and we are initializing a variable called total squares that we have found so far as zero now the very first thing that we need to check is that does our hashmap contains any other value that is on the same x coordinates as the given point X1 coordinate if we don't have any values we can directly return Z Z that's it but if we do have bunch of points on the x coordinate then for each one of them we'll have to do the following and that is that we would find that what are the subsequent y values we will also try to see that what has been the frequency of that XY combination we would check that if the Y2 is equal to y1 which means we are at the same point that we are already given we can ignore that if that is not the case we would find that what is going to be the edge length or side length by doing the subtraction of Y2 minus y1 and this is going to be an absolute value so doesn't matter if it's like above X or below X overall we are only dealing dealing with positive integer then we will have to check that what are the possible values that would allow us to generate basically a square and then we would add it to the existing list of total squares and for that we are using a ER method called count squares where we are taking in X1 and y1 coordinates we are also taking in X3 and Y3 coordinates that we are trying to build and we have the Y2 and the count Y2 so frequency of that coordinate so after having all of this value in the helper method we simply check that do we have the X3 coordinate that we were talking about and its subsequent y1 value if we do what has been the count frequency and we simply multiply that to to basically add the value to our uh uh total squares and we do it for both like X1 plus side length and X1 minus side length so this would give us both set of end points and in the end we simply return total squares now I know the coding solution looks quite long but if you just go and check it out our GitHub repository you would find that this is uh an easier solution to understand once you know that what conceptual uh solution means let's try to run this code okay seems like our solution is working beautifully let's submit this code and our code beats 95% of all the other Solutions which is exceptional and we beat 91% of all the other Solutions in terms of time complexity uh sorry space complexity as well which is also quite nice so this is present in our GitHub repository and I know that this solution says it's a medium solution but in my opinion this can be treated as a hard problem as well because it's not quite straightforward to [Music] understand so the lead code problem we are going to solve now is called single number we can see that this one is a lead code easy problem and also one of the most like problems on lead code basically we are given a non-empty array called nums now every single element in this array appears twice except for this one one element and we need to find that single element that is only present just once now the important thing is we need to be able to find the solution in linear runtime so B of and runtime complexity and using constant extra extra space so using bigo of one extra space now let's try to First understand couple of examples suppose we are given an input array like this then we can see that one appears twice and two appears only once so we need to find the single number so we can return return two as the answer same way over here if there are more entries still we can see that two appears twice one appear twice three appear twice and four appear twice seven only appear once so we need to return seven as the answer so basically this is the problem statement now let's approach this problem in multiple ways the Brute Force approach is going to be quite straightforward so Brute Force approach is going to be quite straightforward we first take a look at the number and then iterate over entire area to find that whether another copy of this number exist or not and we can keep on repeating the same process over and over so basically this is an inefficient approach and this would yield B of n Square time complexity in the worst case scenario uh next approach is a slightly simpler approach we can basically sort the given input array we can find that then we can just iterate once and find the value that is only repeated just once so this approach would be better than the Brute Force but this would still run in big of log n log n time complexity so this is still not valid for us next approach is that we can actually use a hash Map to solve this problem hash map or hash set and where we can just simply iterate over this given input and try to keep on adding all the entries inside the hash map we can keep track of the frequency occurrence and in the end we would find that the frequency for four is only one but that is also still going to run in big of end time but the space complexity is Al also going to be big of end so that is also not acceptable so that brings to the last solution we have and now honestly you are not expected to come up with this solution unless you are like a complete geek or a complete nerd but let me talk about the solution basically we are going to use something called X or gate in between any two numbers now you know that this is a bit manipulation technique and basically we have Gates like end gate or gate uh XR gate and things like that so XR is a very popular way whenever you are dealing with multiple entries that cancel out each other and how it works is that this is the truth table for the X or gate so let's say that we are given X and Y as two separate numbers so if both are basically 0er then we simply return uh Zer as the answer if both are one then also we return zero as the answer so we only return the remaining answer if both values are not same so if 1 is zero and one is one so then in that case we basically return the appropriate value now this xor logic applies to all the numbers as well if we do 4 X or with four then also the answer is going to be zero because both values are same there is also a logic that if we do four then do an XR with five then do an XR with four then once again these four are going to cancel out each other and we are going to end up with a result called five and this you can try to understand based on the X uh X or Y truth table for numbers greater than four so basically I'm not going to write down the whole solution but you can trust me on this that this solution works as expected and uh if you if we have let's say that 10 different entries let's say that uh a then once again XR of a then once again XR of uh X then once again xor of X then once again uh XR of B plus XR of um B and then lastly if we have plus XR of C in this case all of this are going to cancel out each other and only we are going to be left with value C and this is exactly what we are going to do in this problem that suppose you given our nums array the values are 1 2 3 and then 1 2 3 and then value is four so basically we would have a result value that is continuously going to store the values of the XR to its previous value and uh so in the result value first we are going to do 1 X or 2 same way then we are going to do uh that plus X or 3 and if we continues to do that eventually the repeated values are going to cancel out each other and we would only be left with the only number that is not repeated so in this case in the result we would find the value four as the answer and basically this is the whole solution if we see time and space complexity in this case the time complexity is going to be biger of N and the space complexity is going to be biger of one because we are not using any additional space apart from using couple of variables so this is relatively easy and simple approach to solve this problem and uh once again this is a pretty popular bit manipulation problem so now let's quickly see the coding solution so the coding solution is actually the smallest that I have done so far uh basically we just initialize a variable called result and then we iterate over every single nums that is currently present inside the nums array and we simply do xor operation with the existing result Val Val so basically all the elements that are duplicates or multiple copies of each other would cancel each other out and only the single number would have left inside our result variable so which we can return uh as the answer so let's try to run this code okay seems like our solution is working as expected let's submit this code and our code beats 99.9 83% so pretty much all the other Solutions out there which is exceptionally fast it is also really good in terms of time space complexity as well and once again the coding solution is present on our guub repository so this is the GitHub repository that I'm talking about now you can notice that on this repository I have solved hundreds of lead code problem these are the most like most popular and most important lead code problems of all time you would be able to find solutions for each one of them so all you can do is just simply search for it and you should be able to find it now these problems are pretty straightforward and uh if you want to see that how popular any particular question is I have created this Google sheet where in the Google sheet I have created two sheets first one is something I created by myself I went over lead code premium and went that how popular how liked and how important the question was based on how many times it was asked at different companies and then I uh basically sorted them through different topics and different difficulty level which are color coding then we have another list for need code 150 which is also pretty popular list out there and uh um I have been solving all of these problems as well so if you are in the process of preparing for yourself for technical interviews yeah these two can be a good resources at your disposal and uh I hope you find it useful links for both of them are presented at uh the description of this video Hello friends we are still not employed by Fang company so let's not stop lead coding till we get there today we are going to work Upon A Lead code easy problem uh number of ones one bits and this is a bit manipulation problem I know a lot of people don't like it but uh it's really simple to understand so the problem statement is pretty simple we just need to check that in any given integer if we represent it in binary form how many times the one value is being repeated so in this given example we are given a number like this uh n is equal to uh 1 1 1 which is which is the binary representation of the decimal value 11 that uh we need to check that how many times this uh one this one is repeated in the given integer and clearly over here we can see that the one is being repeated three times and which is the answer of this problem and notice that the number is represented quite long because it is showing that all the 32 bits of any integer and all the integer all the input types would be of 32 bit and we need to find that how many times one exist so the first approach we are going to take is quite simple and we are going to use a binary operator and now let me show the table for and binary operator for any given two values the we can have four possible combinations and a and b means if the value of a and b both are one in only that scenario we are going to consider the value of a and b as 1 otherwise if there exist any single zero or both values are zero we would just simply put the values as zero using this logic we can solve this problem really fast and uh the most basic approach is we would simply run a loop 32 times and every single time we are going to compare each element with one and see that if we add the value that exist at any given location with our value one and if the answer is one uh uh we do uh counter plus and uh and after running the loop for 32 all the 32 bits we would just simply return the value of our counter let me show you an ex by an example what I'm trying to say suppose the input we have is 13 if we represent it in binary it would look like and we would have 28 zeros and the prefix now now we will create a value just any random variable uh and we would uh give it as value number one and we will run a loop uh from 0o to 32 and inside the loop for every single value we would compare that whether this one we would compare it with the rightmost element in our given input and we would do an end operation between these two values and we would we would have a counter that we initially set it up as zero and whenever we find that the answer of these two end variables is actually one we would simply increase the counter so for the first so for the rightmost position we would increase the value of our counter so counter would become one and after we are done with this condition we would simply do a left shift for this random operator in the for the given input so now one would be shifted one position to the left and we would again do the same operation so this time we will do an end operation between this 0 and 1 and the value of end operation would be zero so we won't update the counter and again we would do a left shift for this one element and again we would do an end operation the value we would get is one which means we need to update our counter so counter becomes two and again we would shift our element we do an end operation again again the value Still Remains uh one so we update our counter again and we update the counter to three and then we would subsequently update the value of uh this random character to one bit to the left and now notice that all the remaining bits are zero so the uh end operation will always uh equal to zero so we won't update the count and at the end of the loop we can simply return whatever value of count we found as our answer now this approach works perfectly fine and uh this approach actually runs in bigo of one time uh because we only have to run the loop 32 times which is a minimal amount of work that we have to do and the answer would always be constant so this is in itself pretty neat solution but let's see if we can go one step further and we can reduce this uh loop counter time to less than 32 in order for us to understand the optimal solution let's first take an example so uh say we are given a value value n equal to 36 now let's represent this value in binary because we know that binary works like 2 to the power 5 and if we do the summation of these values in decimal terms uh this would become 4 and this would become 32 so 32 + 4 becomes 36 now the intuition behind this solution is that if we take one value lesser than 36 uh let's say 35 and if we represent this value in binary terms the binary representation looks like and notice that the first one that we encountered on our original input the one value lesser than that has the exact opposite in terms of number of ones up until this point that if we do uh end operation between these two values the value we would get is like this so notice that this one has already disappeared in the end result of these two values and if we repeat the same process so now this value that we got in binary the value is actually 32 and again if we repeat this same operation that we do an end between the number of number by itself with one value lesser than that we would gain a result like so first let's uh let's represent the value number 31 in binary and now if we do an end operation between these two values the answer we would get is all zeros which exactly means that we would only run the loop the number of times one we have in our original given input because over here we only had 2 one in the input so during the first iteration of our Loop we got rid of this first one and we can see it over here and during the second end operation we got rid of the second one as well and we got the answer as all zeros so at the beginning if we create a variable count and we originally set it up to zero and every time in the given Loop if we just go through the loop and the value of the current Val value of current n is not equal to 0 we just simply increase the value of count to one so which means that during this first iteration the value of count would be 1 and during the second iteration the value of count would be two and after that we found that the value of n is actually equal to zero so we can simply break out of the loop and when we break out of the loop we would return whatever the value of count we had found and in this case the value of count we found is actually two and this solution would work perfectly fine and this would be our optimal solution the time complexity for this solution is also Big O of one which is a constant time but the thing is the number of loop iterations that we have to go through would only be equivalent to whatever the value of one we are given in the original input array and we don't have to run the loop 32 times like the previous solution so we are actually in our constant time solution we are also saving lot of time and this would be the fastest solution we can reach into um and in terms of space complexity we are not using any additional space so space complexity would also be constant time and and now let's move on to coding thank you so first of all we will create a variable for count and set it up to to zero now we simply run a loop we will run this Loop till the number is not equal to zero and with every iteration we will increase the value of count and we will simply do uh n equal to n n n minus one at the end of the loop we just return count looks like our solution is working let's try to submit the code and yeah submission works as expected it's pretty efficient and neat and uh let me know what do you think about this video and uh if you have any more suggestions feel free to reach out to me in the comments and uh I can address them thank you bye-bye Hello friends we are still not employed by a fan company so let's not stop lead coding till we get there today we are going to work Upon A Lead code easy problem Counting bits which in my opinion should be a lead code medium problem uh let's understand the problem statement so basically we are given an uh integer n as input and we need to return an array uh such that it defines that for every single value from the range of uh zero all the way to whatever given n is how many times the value one is repeated in its binary formation so let's try to understand this with with an example suppose our given input is 3 so the range from 0 to n would be 0 1 2 3 and if we represent these values in binary uh the representation would look like 0 0 1 1 0 1 1 and we need to return an answer array uh such which is of n + 1 size uh such that it represents that for every single value from 0 to n how many times this bit one is being repeated so now for the zeroth position we don't have any ones so we enter the value zero for the first position we have one one bit so we enter as one uh same goes for the second value so we again add one and for the third value we have two ones so in the answer we provide as two and this would be our array that we would return as our answer so let's see what are the different approaches we can take so the first approach we can take over here is of one of the previous lead code questions that we have already solved a number of one bits and uh let me give you an overview of the solution we had achieved previously so if we are given any number n is equal to 5 and if we represent it in binary it becomes one 1 and if we want to find that how many number of one exist in the given uh input we simp we would simply do an end operation between the number and uh it's one value lesser than the number of itself so one value lesser over here would be four and if we represent it in binary it becomes like this and if we do an end operation between these two values the answer we get is uh 0 01 and this would be our first iteration now we would repeat the same process so now again the number we found after doing this end is four and we would do an end operation with one value lesser than four so 3 would become 0 1 1 and if we do an end operation between these two values the answer we get is 0 0 0 and the moment we get zero answer we break out of the loop and at the beginning of our Loop we would create a Val a variable count and only initially it would be set up to zero and with every iteration we would increase the value of count so during this iteration the value of count would become one and during this iteration the value of count would become two and at the end when we find that the number is actually zero we would return whatever value of count we found as the number of ones that exist in our given input so we found that in our given input five it has two number of ones we can repeat the same formula for the given input and uh let me show you how we can do it suppose the input we are given n is equal to 4 we need to create an array from 0 to 4 and we need to calculate that uh for every single value how many number of ones are present in that given input so the array the answer array would be we would need to provide that how many number of ones exist so we can can create a function called count one and for and we can run a loop over the all these values and every single time we would pass on whatever the current value we are trying to find the count for and when whenever we run this uh we run this function that uses this logic uh the one that we just uh discussed then we would be able to find that how many number of one exist for every single given element and when we get the answer back we can just simply fill in our array and return this as answer this solution would work perfectly fine and the time complexity for this solution would be uh n because we will have to run a loop towards the entire towards all the all of all the given values and we for every single value we would have to run this operation count the number of ones and this Loop runs for the time being of number of ones that exist in any given uh input so over here for number five there exist two uh two ones so we would have to run the loop twice uh suppose if we are given any uh n is equal to like this then the loop will run six times so we can say that this uh solution basically Works uh in the time complexity of Big O of n * log n because in order to find this count because in order to find number of ones we would have to run multiple Loop we will have to run multiple iterations in this count one uh solution so this is in itself a pretty efficient solution but we need to see that if we can find a better approach and can we have an optimal solution we can have optimal solution let me show you how we can achieve that now in order to find the optimal solution first let's try to understand that how the logic actually works if we want to find the number of ones in any given element so the operation we are doing is basically we take n and n minus one and then we do a counter Plus+ we can represent it in a different manner so first let's try to understand that suppose n is equal to 9 the actual calculation we are doing is nus one we are doing an end so basically this means that after the end operation we get the value as and the value this comes up as uh 8 and we do an A+ one so keeping this in mind and again if we do it for the value number eight what we are actually going to do is uh we were we are going now our n is 8 so we will do n minus 1 as 7 and the answer is zero so basically our n is zero at this moment and we again do + one in our counter so if we write this in other way we can write it as that answer for the number nine is actually whatever the answer we found for 9 9 and 8 + 1 and if we go down one step further the answer for actually this uh 9 and 8 is actually the answer for whatever the value of 8 we found + one we can write this exact same formation as this and if we try to calculate the value for this a uh a of a 8 actually we can write it as a of 8 and 7 + 1 for this uh particular value and this actually becomes a of 0 + 1 and we know that a of 0 is actually 0 + 1 is 1 and this 1 is actually the value of a of 8 now if we replace this a of 8 over here we can see that uh the a of 9 is actually a of 9 and 8 + 1 and we know that the value of a of 9 and 8 is actually a of 8 + 1 and we know that the value of a of 8 is actually this one so we can say 1 + 1 and we can come to the conclusion that the by the number of ones present in value number N9 9 is actually two and which is what we are given over here and which is what we know and basically what we have done is we have taken this input for any single individual element and we have actually computed the results we have actually stored the results and based on those results we are able to find the future values and basically we are applying dynamic programming we can simply calculate the solution for our entire array in just Big O of end time let's take another example to make things more clear suppose our given input is equal to six so if we want to find the answer for six using the logic we found over here we can consider this as answer for whatever we find for 6 and 5 + 1 and the answer for 6 and 5 is actually this equals to 4 so we can write this as answer for whatever the value of four we got + 1 because this turns out to be four and subsequently if we calculate the value for four we can break it down further as so we can write this as uh answer for 4 and 3 + 1 for this portion and + one for this one the answer for 4 and three is actually n is equal to 0 so we get answer of 0 + 1 plus 1 this would be our final answer for our answer for Value number six so see over here that we have when we get to Value number six we would have already calculated all the values from 0 to 5 and we since we have the answer for from 0 to five we will use those answers to quickly determine the answer for uh value number six and this logic enables us to get our solution in just single iteration and uh this would be a better time complexity than our previously suggested uh algorithm and in terms of space complexity anyways we have to create an answer array in order to return it as a part of the answer because it is given as requirement um for the given input that we are not causing we are not using any additional space and we can just use the same uh array to represent the answer and also use it as our dynamic programming solution so space complexity would also be a big go of one and this is a really ideal approach and let's see let's move on towards the coding so first of all we'll create an answer array and we would give it the size of n + one and now we initialize the answer array uh of zeroth value to zero and now we just need to run a for Loop we'll start the loop from I is equal to 1 because we already calculated the value for zero and we will run it while I I is less than or equal to n and we just have to write one line of solution that if our answer of uh current I is actually equal to answer of I and I minus one and whatever the result of this is we just add one to it and yeah basically after the loop we should have our answer array completely filled up and we can simply return it so let's try to run our code oh we forgot to initialize the value yeah looks like our solution is working let's submit this our submission works pretty fast compared to a lot of other submissions and uh as we can see that this is just couple of lines of code uh that is really doing the trick so though this is really simple to see but in order to come up to this answer requires very strong knowledge of uh dynamic programming hope the hope you like the explanation and the videos let me know if you want me to do anything else with the videos or or provide me any suggestions on how can I improve Hello friends we are still not employed by a Fang company so let's not stop lead coding till we get there today we are going to do a lead code easy problem uh reverse bits and uh this has something to do with bid manipulation so let's understand the problem statement basically we are given a 32bit unsigned integer and we need to reverse all the bits in it uh let's consider it by an example suppose the value we are given n is equal to 5 and if we represent it in binary the binary represent presentation would be and since the given input is 32 bit uh all the other bits would be zero now we just need to return a new element uh reverse that looks like the exact reversal of this binary value so this B the so the rightmost bit on the original input would be the leftmost bit on our new uh variable so the value should look like one 0 1 and all the remaining zeros uh because this one is also 32bit so basically the rightmost zero would be at leftmost position in our new variable and we need to return this the problem statement is really easy to understand and let's see that what could be the approaches we can take to solve this in order to solve this problem we are going to use bit manipulation and specifically we are going to use uh two bet manipulation operators uh first one is and operator and second one is or operator and let me show you by truth table what each uh of these rep uh operations represent and these are the symbols to represent them so the possible value for a and and B we could have is so for A and B if all both the values are one then only we consider a and b as one otherwise if there exists a single zero we will uh keep their value as zero so this would be the table for A and B and in A or B if there exist a single one we would consider the value for a or b to be one so if both are zero then only we would have a or B as zero otherwise the value would always be one now let me show you that how can using these two operators we can uh calculate our solution we are only given one thing over here uh the input parameter n and suppose our n is 5 so the values would be like this the new variable that we are trying to determine reverse is actually unknown to us and that will have all the values that are in reverse order for the given n and we know one thing that all the values in given n is actually 32 bits not more than that so the first intution is that if we run a loop uh 32 times and every single time we take whatever element is present in n and if we put it in our reverse uh variable so whatever element we have present in our n we put it in the reverse variable and then we start Shifting the reverse variable one step to the left side so at the end of the loop our reverse variable would be exact reverse of whatever value that is present in the given n so let's determine that what would be our algorithm initial value for our reverse parameter would be zero so the entire value would be and when I say zero I mean that all the 32 bits would be zero for the reverse element now at the beginning of and we would run a loop uh from I = to 0 to I = 32 and at the beginning of our Loop we would have a condition that every time we are going to left shift the value of reverse parameter uh to one bit so at the end we would have rotated any value that is present over here we would have rotated it to 32 times and it would end up on the leftmost position but after the rotation of the value so first of all so inside the loop first of all we will rotate one bit to the left and we would represent it with this uh symbol next what we are going to do is somehow we will have to get whatever value of n is present we need to copy that value for that particular element and put it somehow put it on the subsequent position at our uh reverse order so how can we do it and we know based on our uh and and or operators so at any given moment the possible value for n would be either zero or 1 and we want to copy whatever value of n exist in our reverse uh parameter a reverse variable so if we do an n and one operation then this would specify and this would provide us with whatever value of n there exist so suppose if the value of n exist as zero and if we do an end operation with 0o and one the result we would get is zero if the uh if the value of n exist as one and if we do an operation 1 and one the value we would get is one so this is how we can get the exact value of one that is present um exact value of n that is present and once we calculate this value that n and one we need to put this value in our reverse variable but the thing is in our reverse variable all the values are initially seted up to zero so all all the values are zero and the the potential value of N and one operation could be either zero or it could be one and whatever we get over here we need to transfer it to our reverse variable and the way we can do it is if we simply do whatever element is present at our reverse variable at our reverse variable and if we do an or operation with whatever the answer we get from n and one we would be able to put the exact value that was present at n at given at any given moment so the operation that we are going to do is current value of reverse we have with and we would be aing that with n and one and suppose initially so if the value of n is equal to0 the answer after this operation would become zero and we know that the value of reverse is initially set to 0 so we would be doing 0 or 0 and the answer we would get is 0 and we would shift it to our reverse and at every single iteration we are going to do a left shift on the reverse parameter so whatever value we we set up at the first at the end of the 32 iterations it would end up over here and so we are taking care of the value of reverse parameter by shifting them one parameter left but we also need to shift the values of given n one parameter one step one bit to the right side uh because we need to calculate every single value of n so suppose the value of n is like 0 1 and then bunch of zeros and then uh 1 and this comes out to be the whole 32 32 bits we need to calculate every single value of n that is present and we need to put it in the reverse order so at the beginning of our Loop we will calculate this value we would put it in our reverse Loop uh and once that is done uh this value would be stored over here initially in our reverse variable but we know that we are doing a left shift operation on our reverse variable So eventually the value will keep on transporting on the left side and it would end up at the first position which is what we want but the thing is on the n on the given input we need to do a right shift operation so we keep on eliminating the values that we have already calculated and we are uh eventually uh when we come to the end of the 32nd bit we would come to this value so 31st bit would become this value and this value would be entered at the second position reverse variable so I hope this makes things uh clear I know it's a little bit uh tricky to understand but once you will do an example by yourself uh with this uh expression that reverse the value of reverse is actually the reverse we currently have or n and one and after this we would be able to copy whatever value of n we have to our reverse for that particular bit and then it's just a matter of uh shifting the values of reverse on the left side and Shifting the value of n on the right side and at the end of the loop we can simply return the value of reverse variable and this would be our answer so now let's calculate the time complexity for this approach basically the time complexity would be Big O of one because the only work we need to do is we need to run a for Loop uh for 32 times and that can be done in constant time and even for the space complexity we we can complete the complete the entire iteration in just constant time because we are not using any additional data we are just using couple of parameters to store some values and uh this would be a very fast solution and it's really simple to understand but the thing is we need to come up with uh a little bit of logic and we need to have little bit of understanding of uh the bit manipulation operators and now let's move on to coding so first of all we will create a variable reverse and initialize it to zero now we will run a for Loop inside the for Loop we will first of all do a left shift on reverse then we will apply our logic to calculate the value of n to reverse so we will do reverse or with n and one and now we just do a right shift one bit for the variable n and at the end of and after the loop we simply return the value of reverse let's try to run this code yeah looks like our solution is working let's try to submit it and yeah our submission Works actually 100% F faster than all the other submissions but uh this is not true this is because the uh solution runs in the constant time and uh hope you like the video let me know what kind of videos you want me to do next and uh if you have any suggestions regarding my videos feel free to let me know so I can improve upon them our aim is to clear the Fang and uh we are not going to stop till we clear Fang interviews thank you bye hello friends we are still not Ed by Fang company so let's not stop lead coding till we get there today we are going to work Upon A Lead code easy problem missing number and uh let's understand the problem statement basically we are given an array of numbers uh containing n distinct numbers in the range of uh 0 to n and we need to return that there is one number that is missing and we need to return the missing number so if we take the first example the range we are given is 0 1 2 and three but we when we see the actual input of uh nums the in the input we only have three 0 and one that if we start cancelling out the numbers that are present in nums and uh also present in our given range 0er can be canceled out one can be cancelled out and three also can be canceled out but uh the value number two is present in our range but not in the given input so we would simply return the value uh two as not not being present and uh two is two being the missing number so there can there can be multiple approaches on how we can solve this uh problem okay and uh we would try to uh keep in mind with this followup as well and we will try to solve this problem in big go of one space complexity and big go of n runtime complexity so the first two trivial approaches we have in our mind is uh first one that if we sort the input array we can uh clearly we can solve this problem easily but the issue with the Sorting approach approach would be that the runtime complexity would be uh n logn because we need to do uh sorting first and that takes n log and time uh second approach is to use a hash set and we would keep on storing all the values of uh nums input in the hash set and uh then we would trate with the Range Loop and go over hash set to see if the value exist in the hash set of not or not and eventually we would find a value that exist in range but does not exist in hash set and that would be our solution and the good thing about haset approach is that runtime complexity would be big go of and and but the issue comes for the space complexity uh and the space complexity for this approach would also be Big O of n which is not what we want so let's see what would be the optimal solution and I would be showing two Optimal Solutions in this coding problem so our first optimal approach is actually pretty simple basically we are given two two items uh first one is range that is from zero all the way up to n and second one is nums input array where the values are zero all the way up to n but one of the value is missing and we need to find this missing value so the most simple approach to do is we run a loop we run a for loop on this range parameter and for every single value in the given input uh from zero all the way up to n we simply do an addition of all the values we store the result of all the elements in the range in a parameter called range sum and we would find some value over here and again we repeat the same process but this time for nums so we do the sum of all the elements in the num uh with another for Loop we store the result of a sum in a new parameter called num suum you can put any name this is just randomly something for taking the name and then when we do a difference between range sum and this num uh uh number sum the difference would actually be the missing number and this this way we would be able to find the solution pretty quickly let's take it by by a quick example so clearly we can see that this um value one is missing so the sum of all the elements were here would be 10 and the sum of all the elements over here would be 9 so if we simply do 10 - 9 we would find the value 1 which is the missing number and this solution is pretty simple to do and uh the time complexity would be bigo of n because we are just uh simply running two for Loops separately so we are not doing much work in terms of time complexity and for the space complexity other than storing the value for just couple of parameters uh we are not consuming any additional space so the space complexity would be constant and this is uh an optimal approach that we are asked as a followup in our original input for the second optimal solution we are going to use a bit manipulation and specifically uh we are going to use X or operator so if you don't know what XR operator is let me give you a quick tutorial on what each value is being represented when it gets X OD with some other value we can only have four possible values for A and B Because all the values in computer system are represented as binaries now in the XR if both values are zero we consider the value of zero if any one value is one we consider the X a X or B as one uh same goes for this one and if both values are one we again consider a X or B as zero now let's see that using this logic how can we uh find the missing number so now consider this property that for any given value n if we X or n with itself the answer we would get is actually zero and let me show you what I mean by that supp our current n is actually six and now let's represent this in binary and now let's try to do N X or n and this is the symbol for XR in uh computer um in programming language so if we do the result uh 0 0 is 0 1 1 is 0 and 1 one is again zero so if we exer two values together the answer we get is actually zero but if we X or so suppose if we X or the values like 6 X or 6 X or 3 the answer we would get is actually the value by itself uh so because 6 X or 6 would be zero and and now let's try to exert three with this given zero so the binary representation for three is equal to 01 1 and now when we try to exert these two values uh 0 and three the answer we would get is 0 1 1 which again means three the number that we exort zero with and we also notice one more additional property over here that whenever we X or two values so 6 X or 6 X or 3 gives the result as three also if we change the order and if we put any order like 3 X or 6 X or 6 this will also result in three and if we do like 6 X or 3 X or 6 this will also result in the value three because order doesn't matter uh if we are xoring two values by itself uh both are going to eliminate themselves and their answer would be zero so whatever is remaining would be uh the answer of this one and we can repeat this for whatever number of times you want so we can if we do something like uh 2 XR 3 XR 2 XR 6 XR 6 XR 7 XR 7 if we run this entire thing still the answer after this would be three because notice that over here two cancels itself six cancels itself and seven cancels itself and only three is going to be remained so now we now since we have established all of this let's try to see that how can we how can this be useful for us in this given problem the input for our given problem is actually we are given range and we are given the input number so suppose for an uh suppose for an example the range we have is uh 0 to 4 so 0 1 2 3 Let's consider 0 to 3 and the input parameters we have is suppose 1 3 and 0o so notice that number two is missing now if we were to use this XR logic that if we XR all the values in the range with all the values in the nums we would get something like this 0 XR 1 XR 2 XR 3 for this range potion and if we X or this with the nums input we will get 1 X or 3 x or0 and if we combine both of these basically all the values that are same would be eliminated and would be turned to zero so this zero would cancel out this zero this one would cancel out this one and this three would cancel out this three and notice that right over here we just determine that the order in which XR happens it does not matter everything is uh not right next to each other still they will cancel out each other and at the end we are only going to be remained with the value that is not at all present in this nums input so in the nums input we don't have the value number two present so the result of range xor nums would actually give us the value two and uh the result two we can simply return it and this would be our solution so this is a very neat very unique solution and because we have the knowledge of XR we are able to come up to this result and if we use this in an any if we use this in any interview this clearly shows that you have very sound knowledge of Computer Concepts and you know how to apply them when they seem fit uh this would definitely give you a very extra very sharp edge over all the other candidates and uh let's do the uh complexity analysis so for the time complexity we are actually doing everything in just uh single Loop for one Loop for range and one Loop for nums uh so the time complexity would actually be bigo of N and the space complexity would actually be big go of one because we are not using any additional space so this would be the most optimal solution and this is what the problem is asking asking us to find now I'm I showed two Optimal Solutions but first optimal solution is very trivial to understand so I'm not going to code it up and I'm only going to code up this XR solution so we will first of all create a variable XR and we initialize it to zero you can give any name and now we will run a four Loop starting uh from the range so in I equal to 0 to I is less than or equal to THS do length I ++ and every time we will exort the number with itself so now again we will run another loop and this time we will run it for the given input array notice that we are only using I less than number of length and over here we are using uh less than or equal to because in the range we have one value more than whatever the value whatever the length of number is and again we repeat the same operation XR with the value in the given input array and now we will simply return whatever we found in XR that this would be our missing value let's try to run this code looks like our code is running let's try to submit this uh submit it and yeah our solution works perfectly fine it's actually pretty fast and pretty efficient and uh hope you like this video I'll be posting the solution in the comments and uh let me know if you have any suggestions for the videos uh yeah let's clear Fang together Hello friends we are still not employed by a Fang company so let's not stop lead coding till we get there today we are going to work Upon A Lead code medium problem sum of two integers so let's understand the problem statement basically we are given uh two elements uh A and B and we need to return the sum of two integers without using the plus or minus operator and uh the problem statement is really simple basically we are given two values A and B and uh we need to return the sum of a + b equals to in this case 3 but without using the plus operator so let's see how can we do that we are going to use two bit manipulation operators uh first one is something called X or or exclusive or and second one is and so let me uh show you what each of them does and what does it mean so we are we will consider a table like this where we are given the values of A and B and the value of a X or B now these are binary elements so we can the only possible values we can have for A and B is 0 and 1 and we can have four possib ities either both are 0 0 0 1 1 0 or 1 1 and the answer for a X or B would be 0 0 is 0 0 1 would become 1 1 0 would also become one and if both are one we would again consider it as zero so this is just something that we keep in our mind and we will use it further down in our equation now let's see what would be the table for a and b now as the name such as a and b we only set the value as one if both entries are one otherwise uh if there is any single zero present we we get the answer of a and b as zero and now let's see how can we use these two operators to find the sum of any two values uh for our given problem so suppose we are given two values like this a = 5 and B = to 3 so the sum of a + b as we know is 8 and let's see how these values are represented in uh binary so a would be represented as 1 0 1 and B would be represented as 0 1 1 because in binary operator the value of any element is actually done as 2 of 0 2 of 1 2 of two so uh this becomes four and this becomes 1 so 4 + 1 = 5 and uh same over here this is 2 and this is 1 so 2 + 1 = 3 okay now let's try to do a summation of these two values so 1 + 1 we cannot do two over here because this is a binary representation so we will uh do as zero and we would have one as carry uh that we carry on towards the left value and again we get 1 + 1 so again the value becomes zero and we have a carry that we need to consider on the left side if we take the carry again we get the value zero and we will have a carry over here and we don't have any value over here so we can just consider uh this as 0 0 so with the carry the value becomes one and if we do the uh if we find the binary value for this one this is actually two of 0 2 of 1 2 of two and two two of the power 3 so the value 2 of the power 3 is actually 8 and which is our answer so if we do the simple addition of binary values we can also get the answer answer as eight but the problem over here is that we should not be using the plus operator so we cannot just simply add these two values so the longer route we can take is we can try to do a X or B first and then we would do a and b and we would move the values to one point left this is simply what we are going to do for the given elements until the point where we find that the values of A and B uh as Z so this is the broader idea of our algorithm and let's see what I mean by that so the value of current a is 1 1 and B is uh 0 1 1 so let's try to do a X or B this is the symbol for XR in uh computer language so we will simply use this one and let's see what the value becomes so we know that 1 1 is zero 0 1 is 1 and 1 0 is also 1 now we need to do the operation of A and B we are doing this operation to find the carry value with A and B values and because we are finding the carry values we know that whenever we have a carry of at any location we need to move it one step on the left side so we will again use the same logic that we will uh use a and b to find the carry value and we would move it one step on the left side so let's see what the values would be for a and b so basically we have one one over here so that value would become one and notice that we are writing one over here and not over here because we are Shifting the element on one step towards the left side so we have one one as one next values we have is 1 Z sorry 0 1 and we set it up as 0er and again we have 1 0 so again we set it up as zero and because we don't have any value over here we shifted one value on the left we can consider the value as zero over here now we have calculated the results for a X or B and A and B and we have moved them towards the one one step on the left in our algorithm this would become our new a and this would become our new B and we would have a loop that until we get a value of B that is not zero we would continue with this operation and let's see where we will get so now the value vales for A and B would be a would become 1 1 0 and B would become 0 0 1 0 and now let's let's repeat the operations again so first we will do a X or B which gives us 0 1 1 becomes Z and we will have a carry but we will consider it later 1 0 becomes 1 and 0 becomes 0 now let's do a and b and shift it to one bit on the left side and because we have to move it one bit on the left side we will start it over here so 0 so 0 0 becomes 0 1 1 becomes 1 1 0 becomes 0 and 0 becomes 0 and because we don't have any value on the rightmost part we will consider it as zero so again we will assign the values as a and as B and we notice that b is still not zero so we will continue with our operations and we will continue with our Loop so again let's repeat the same operation so a mod b becomes 0 0 again 0 0 again Z and Z so all zeros we are getting as a X or B and now A and B shifted one element on the left side becomes we start one element on the uh one element from the rightmost element so zero again zero for these two 1 1 becomes 1 0 0 again becomes zero and we have one blank element on the rightmost uh bit so we can consider it as zero this becomes our new a and this becomes our new B we notice that b is still not zero so let's repeat the operation and now we are going to do a X or b equals to 0 0 0 1 0 Z and a and b shifted one bit on the left side so notice that on this a value we don't have any ones which means that under no circumstances we can have this A and B where we get one answer because a is always zero so same thing applies over here and basically this value would become all zeros 0 0 0 0 0 and now again we assign our values so this becomes a and this becomes B and notice that in this scenario B is completely zero so we can break out of the loop and when we break out of break out of the loop we can simply return the value of a so the value of a we have found in this scenario is 0 1 0 0 0 and this is a binary number if we were to convert it to decimal value we can we can understand this as uh 2 of 0 2 of 1 2 of two two of 3 uh 2 3 and 2 4 so all of these values are zero so we don't consider them this one is 2 Cub which is 8 so we can return a as 8 and this would be our final answer and if we see the original two values in our request basically we had the two integers a equal to 5 and 3 and we get our answer perfectly defined over here and we reach to this answer without using the plus operator so this this would be our solution and now let's calculate the time complexity for the given problem so basically if we see the given input over here we have a constraint that all the values are between negative 1,000 and positive 1,000 which means that essentially we can calculate the time in a constant uh time complexity big go of one we don't need to calculate any anything additionally because overall the input is quite small and we can simply uh do it uh constantly and also the space complexity would be bigo of one because we are not using any additional space we are just using couple of variables to store just few values uh so this is a really ideal approach and I know that lot of people uh don't like to have bit manipulation and uh they simply ignore it or they hate it and most of the times companies don't tend to ask this kind of questions but we are preparing for Fang we are not prepar ing for some random uh company and if you want a dream job why would you compromise so I would just suggest that go over it it might take you like 2 3 hours to go through all the bit manipulation questions and understand the concepts but once you are done with that you will have an extra Edge in the interview so I would highly recommend not to skip anything and not to put anything on the chance I will and now let's move on to the coding and we are going to implement this solution so if our intention is to just sub submit it for the sake of submitting it and uh have it accepted by lead code we can simply write one line of code we can simply return a + b and apparently it works yeah but this is not what we want so we would be now we would be writing the the complete solution that we would use in in an actual interview so first of all we will create a v Loop uh to see if the value of carry is actually zero or not and we are going to store the value of carry in the B element so well B is not equal to zero now we will create a variable to store the value of a X or B let's name it temp and now we will calculate carry as well we will do a and b and shift it to one place uh left shift it to one bit on the left side and now we simply store the value of temp in a so a becomes our temp and as mentioned earlier we will store the carry in B and yeah that's pretty much it once this Loop runs our solution should be stored in a so let's return a let's try to run our code looks like our solution is working let's try submitting it and yeah our solution works pretty neatly it's apparently 100% faster than all other Solutions but actually this is not true all other Solutions are also 100% faster because the runtime is in constant time so hope you like the video and uh let me know in the comments if you want me to update anything in the video our aim is to clear Fang interviews I'm making these videos so I can practice for myself and also I can uh spread the knowledge I have gained to like other like-minded people and uh yeah see you soon [Music] so the lead code problem we are going to solve now is called reverse integer now this one is an extremely popular lead code problem and also a medium one basically we are given a sign 32bit integer X and we need to return x with its digits reverse so basically uh let's say that if the given x value is 1 1 2 3 then we need to return return x equal to 3 2 1 uh same way if we are given a negative number let's say x is equal to - uh 43 5 then once again we need to return as minus then 5 3 4 and uh so on and so forth so this is the basically the whole problem statement now we are also given some condition where we the given number should not exceed the maximum range of a 32-bit integer uh if that is the case then we need to return zero so let's try to understand that what is going to be the most common logic to solve this problem let's say that I tell you that we are given values 1 2 and three and I ask you to reverse it logically as a human what you are going to do you will first go to this number you will find the very last number and you will put that very last number into the front of this new X that we are trying to create and then eliminate this number from your site and once again repeat the same process and repeat the same process for all all the remaining numbers so basically three would come over here two would come over here and one would come over here and this would be our answer that we are going to return this is exactly what we are going to do to solve this problem as well basically all we need to do is uh just do the modulo by 10 operation for this given x value and at every instance we are going to uh do the operation that X is going to be x ided 10 and we are treating X as an integer value so this division by 10 would be basically yield uh that we are eliminating the very last element every given moment so let's see that what is the solution I'm proposing uh if the given X is equal to 437 suppose like this okay then first of all on this given X we are going to do X modulo by 10 operation so we are dividing it by 10 and finding the remainder so remainder in this case is going to be seven so first of all in our new X we are going to add 7 as the very first value and uh so basically how we can add this value basically we will just do uh like 10 to the power uh 0 and 10 to the^ 1 and so on and so forth uh this is how you add digits and multiply by current value we have and add it to the existing value so it's very common uh typically we do it with a small operation that we will see in the code so we would take this value in and we would put it over here after that we are going to run this operation x equal to x / 10 so that would eliminate this um seven from this existing number so after this once again we are going to repeat the same operation now this time the number remainder number is going to be three so once again we would append three over here and then remove three from this existing number and lastly we will have four so we will add four over here and once we have no characters Le left inside the x or the given value of x is less than uh 10 basically we will just add that value and then get out of the loop also at the same time we will have to understand that at every given instance while adding or building this number are we going out of the bounds for the given integer value of the 32-bit number so for that the only thing we can do is just we can just compare whenever we build a new entry for x and if that entry exceeds the existing limit for the integer or 32-bit sign number then we will just simply um return zero in this case so this is the whole solution and uh typic this solution would work in the total number of given uh numbers so basically let's say that we are currently given five numbers so 1 2 3 4 5 then the time complexity is going to Big of five because we will have to do it for every single character by character so this is actually going to be B go of logarithmic of x value where X is going to be the the type of system that we use to represent the numbers now since we are using 1 to 10 numbers so this is going to be a decibal system so simply we can say that this is going to be logarithm of of X for the total number of given characters but overall this is a very simple straightforward solution and now let's quickly see the coding solution so first of all we are going to initialize a new variable called reverse that where we are going to store the answer and then we are going to run our Loop that while the given X is not equal to zero we will first extract the last digit and that is by doing the modulo operation and then we would simply divide the current number of X by 10 and because it's an integer so we would just remove the very last character now we simply need to check the Overflow condition before we start updating the reverse uh functionality so we are only checking that if this given reverse value is already greater than the integer by Max value by 10 or if that is not the case and if the pop is greater than this value then we can simply return zero otherwise uh we also need to check for underflow case the same operation in the reverse order that if we are going out of bounds in the minimum value case if either of this is the case we can return return zero if that is not the case we simply add that value and update the existing reverse number by multiplying the current reverse number with 10 plus adding the pop value or the last value we added and we can simply return the reverse value so let's try to run the scenario okay seems like our solution is working as expected let's submit this code and our code runs beautifully beats near nearly 82% of all the other Solutions which is pretty good so once again the coding solution is present in our GitHub repository feel free to go and check it out from there thank you