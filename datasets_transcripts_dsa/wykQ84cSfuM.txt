[Music] in this course we'll be covering data structures and algorithms in cop the course will primarily cover Collections and generics arrays and area lists basic sorting algorithms searching algorithms stacks and cues the bit ARA class string class pattern matching and text processing dictionaries hashing link lists binary trees sets and sorting logarithms we'll also cover data structures and algorithms for searching graphs and graph algorithms and some Advanced algorithms first of all we'll be starting with collections in cop so if defined a collection is a structur data type that stores data and provides operations for adding data to the collection removing data from the collection updating data in the collection as well as operations for setting and returning the values of different attributes of the collection collections can be broken down into two types linear and nonlinear linear collection is a list of elements where one element follows the previous element a very basic example of this kind of collection is an array nonlinear collections hold elements that do not have positional order within the collection so first of all we'll be exploring linear collections now there are two types of linear collections direct access Collections and sequential access collections under direct access collections we have arrays string and struct now struct is a composite data type that holds data that may consist of many different data types so let's go ahead and explore these in action arrays string and struct so here first of all we'll be taking a look at the string collection this is a type of direct access collection and when we Define a string it is basically a collection of characters that can be accessed based on their index in the same manner we access the elements of an array as well so here we have created a string array and this string array users is containing two users that is John and Matt and you can see that we can access the values using their index positions and they are all in sequence so at zero we have John at one we have Matt and if we have more over here we can just go on with that sequencing like 0 1 2 and 3 and here we are just writing those values uses of zero uses of one now the other type that we discussed was struct now here if you take a look at this example first the integer data type that we have in C is basically a struct so if I go ahead and say here in 32. pars and if I take you to this definition you can see that it is a struct data type and this also comes under direct access collections the only difference between a struct and a class in general is that you cannot inherit or derive a new type from a structure so here you can see that we have created a struct called name and this has got three attributes first name middle name and last name this is the Constructor that we have and it basically initializes all these attributes that we have F name m name L name and then we have these properties which returns first name last name and middle name and then we have overridden the two string method to just return first name middle name last name as a full name and here we are returning initials so first letter of each word will be shown over here now in order to use this struct you can see that we have created it over here initialized it and then we have passed these first name middle name and last name and these two variables that we have will store full name and initials so full name is coming from my name. two string and initials coming from my name. initials now if I go ahead and run this you'll notice the output is coming as John and mat from the array example and then this is the for and then this is the full name initial and here we were converting integer from string so here if I enter a string it will be converted and printed as an integer value now in the next one we'll be covering sequential access [Music] collections now in this one we'll be covering sequential access collections let me tell you that this is going to be theoretical as most of the topics that we'll be explaining over here will be covered in upcoming lectures as code examples so to start with sequential access collection is basically a list that stores its elements in sequential order we call this type of collection a linear list linear lists are not limited by size when they are created meaning they are able to expand and contract dynamically items in a linear list are not accessed directly they are referenced by their position so the first element of a linear list is let's say at the front of the list and the last element is at the rear of the list because there is no direct access to the elements of a linear list to access an element you have to Traverse through the list until you arrive at the position of the element you're looking for linear list implementations usually allow two methods for traversing a list in one direction from front to rear and from both front to rear and rear to front we can take a example of to-do list items let's say so the list is created by writing down one item after the other until the list is complete now the items are removed from the list while each item is completed or finished so linear list can be either ordered or unordered an ordered list has values in order in respect to each other as in John Jessica Frank Miller an unordered list consists of elements in any order the order of a list makes a big difference when performing search data on the list and this is something which we will be coming up when we'll be exploring searches or search algorithms now there are some types of linear lists which restrict access to their data elements examples of these types of lists are stacks and cues a stack is a list where access is restricted to the beginning or top of the list items are placed on the list at the top and can only be removed from the bottom for this reason Stacks are known as last and first out structures when we add an item to a stack we call the operation a push and when we remove an item from a stack we call that operation a pop stack is a very common data structure especially in computer systems programming Stacks are used for arithmetic expression evaluation and for balancing symbols among its many applications now we have cues as well so a q is a list where items are added at the rear of the list and removed from the front of the list now this type of lists is known as first in first out structure sure adding an item to a q is called inq and removing an item from a que is called a DQ Q are used in both systems programming for scheduling operations system tasks and for simulation studies a special type of queue called a priority queue allows the item in a queue with the highest priority to be removed from the queue first priority cues can be used to study the operations of a hospital emergency room where patients with heart trouble needs to be attended to before a patient with a broken arm for example now the last category of linear collections are index collections the first of these called a hash table and that's what we will be covering in upcoming lectures now hash tables stores a set of data values associated with a key in a hash table a special function called a hash function takes one data value and transforms the value called the key into an integer index that is used to retrieve the data the index is then used to access the data record associated with the key for example an employee record May consist of a person's name his or her salary the number of years the employee has been with the company and the department he or she works in so the key to this data record is the employees name we have classes in shop which are called hash tables for store in data in a hash table and this also we'll be covering in later videos similar to Hash tables we have another collection that is called as dictionary which is made up of a series of key value pairs called associations now this structure is analogous to a word dictionary where a word is the key and the word's definition is the value associated with the key the key is an index into the value associated with the key dictionaries are often called associative arrays because of this indexing scheme though the index does not have to be an integer we'll be also covering dictionaries and upcoming [Music] videos in this lecture we'll be taking a look at how we can create our own collection using array list for that we have created a class called collection and if you see it's inheriting from its Base Class called collection base now if I show you collection base it has got this array list which we call as inner list attribute Now using inner list we can have our own collections how we can have our own collections by creating methods for instance here you can see I'm saying create a function called ad add which will accept a parameter of type object and that item will be added to this inner list now inner list is of type array list which is provided by this abstract class collection base and this one resides inside system. collections name space similarly once we have added the item we can also remove it now removing an item is pretty easy similar to add we have remove where we accept a parameter of type object and the same parameter is then passed to the inner list. remove method of the array list and it will remove that item from the array list then we have clear clear basically clear search all the elements inside the array list so it will be back to square one and the content of the error list will be deleted count is going to return the total number of elements that are present in the inner list or our arror list now to implement this we'll go to our program.cs file and here you can see I've created an instance of the collection class that we just created here we have the instance name as courses and we are adding some courses to this collection JavaScript s.net MVC cop python Now using for each Loop we are simply writing the course names and here you'll notice we are finding out how many number of courses are there in the courses collection by using the count method and then we are removing one course from the list or the collection and then we are checking out what is the total count after that we are clearing it out and then we are checking out what is the total count now if I run this one in over here you'll notice initially it's printing JavaScript asp.net MVC cop python then when we were saying number of courses so total courses at that point was four we removed python from it the count reduced by one and here number of courses three then we called courses do clear and here you can see now the number of courses is set to zero so all the items from the collections have been removed and that's how easy it is in cop to implement data structures now in the next lecture we'll be covering [Music] generics in the previous lecture we explored generic functions and and as I mentioned that generics are not limited to function definitions we can also create generic classes and in this lecture we'll be doing that so here you can see I have created a class called linked list and here using the angular brackets I've specified that this could be of any type so representation T denotes that and here I'm creating two attributes of this class one is data and the other one is link now data obviously whatever value we are passing to this particular link list structure to hold and Link is the pointer to the node to which this instance will be connected so here we have our Constructor two things are being passed over here data and the link here we are assigning it to data and Link variables that we have over here properties now to use this we'll go to our programs. CS file and here you can see I've created node one which contains a string object so here the t is being replaced by string and we are storing data as John and then we are seeing that this is the first element that's the reason it's not holding anything now note two on the other hand if you see is having this data as Matt and it's pointing to node one so if you imagine it's now connected with node one so in sequence if you go node one then node two you know that node two knows that I'm pointing to node one and here we are just taking that as an example we're using the nodee 2. link and getting that object which the Noe two is pointing to in a way node one and we are just writing it in the console we're saying print node one data then print node two data so this one is going to print John this one will print Matt and here this third one will print John again so if I run this now you'll notice the output over here and similarly there are many other data structures already available in The NET Framework under the namespace system. collections. generic and we also have the ability to create our own custom implementations as well like the one which you just saw [Music] in this lecture we'll be taking a look at one of the examples of linear collections with direct access the data structure that we'll be discussing today is called Jagged arrays jaged array is an array of arrays where each row of an array is made up up of an array each dimension of a jagged array is a one-dimensional array and we call it a jacked array because the number of elements in each row may be different so here if you take a look at the example that we have we have created two single dimensional arrays called Jan and FB based on the number of days in each month we have the AR Dimension specified so this why is going to have 31 and this is going to have 29 values now we are creating a jagged array the synex of it as you can see if it is a jagged array you need to specify it in this order so we calling it as sales and then we are specifying the number of elements that this jackary will have here as you can see we are just targeting two months Jan and Feb we have mentioned it like this now what we are doing is when these arrays will be initialized the first week of each month we are targeting the sales so here you can see from 0 to 6 for the Jan month and for 0 to 6 for the month of Feb we are assigning total number of sales that happened and here we are looping through each month so we know that there are only 2 months that's why we are looping from zero 2 less than equal to 1 and then for each month we are doing a total now the total is dependent on each month's sales and as we know that we are only taking first week of each month so here we are looping through 0 to 6 and then we are adding it over here month and day and once it has been added we are updating the total and finally we are calculating the average on week so average that's total divided by 7even per week and here we are seeing average sales for the month now let me run this and show how it is working here you'll notice Jan is now having 31 values so you can see it's starting from 0 to all the way up to 30 similarly for the month of Feb you'll notice that Feb is having 29 blocks over here from 0 to 28 now when we are creating this Jagged array you'll notice that the syntax is the data type of the array will be there and then we have these two square brackets after that again we are initializing it with new in and here we are providing the total number of items that this Jack di is going to have now the first bracket that you see over here represents rows in the jaged AR and the second square bracket that you see represents the item position in each row to further elaborate this you can see over here as an example we are saying that sales for the month of zero Zer represents the month Jan over here so we are saying sales for the month of January and then this is the first day of the month of January then over here this is the second day Third Day 4th fifth 6th 7th so that way we are covering the first week week of January over here so this zero represents the row and this represents the item position in that row here we are talking about for the month of February and same number of days are mentioned here as well now we are saying average sales for the month but over here you can see that we are just dividing it by seven so using this example we are saying this as average sales for the month but if we would cover all 31 days and 29 days for the month of J and Feb and then then this will become every sales per week for the month currently as we are just capturing 7 days we are saying every sales for the month and here we have the result for the month of Jan and Feb over here so that was Jack der's in SE [Music] shop in this lecture we'll be looking at sorting algorithm the first algorithm that we'll be exploring is bubble sort bubble sort is one of the slowest sorting algorithms that is available but it is also one of the simplest sorts to understand and Implement that is why we are exploring this first and then we'll see other sorting algorithms as well the reason why we call it as bubble sort because the values float like a bubble from one end of the list to the other end usually if you are having a list of numbers random list of numbers the higher value will go to the right and the lower value will be at the left side if you see it in a horizontal sequence now how this is implemented is you pick one number and you compare it with the adjacent number if the number that you have picked is greater than the number with which you are comparing it then the pigged number will be moved towards right similarly if the pigged number is less than the adjacent number then it will be moved left so at the end of this sorting process you will have lower values at the left side and higher values at the right side and hence you'll have a sorted list of items over here you can see that what we have done is we have used our our existing collection but this one is only going to work with integers here what we have done is first of all we have created 10 items and we have randomly added it to the collection that we earlier had here we are printing that collection and then you can see we have our custom method called bubble sort which is being applied on this collection after that we are printing the sorted number now let's go and see what exactly we are doing over here in bubble sort the first thing that we're doing is finding the upper limmit and that comes by finding out the total count that we have or the items that we have in the array minus one this is the temporary variable that is going to be used for exchange purpose or sorting purposes and here we have two Loops first is the outer loop so we're saying integer outer is equal to Upper so let's say if there were 10 items in the list remember it starts with index position 0 and count is going to give you 10 if total number of items in the list is from 0 to 9 so that's why we are saying 10 -1 9 now upper limit will be 9 over here and it is also being checked as if it is greater than equal to 1 so basically we are running from 9 to 1 in that order and then the inner loop is actually going from 0 to 9 and here we are comparing with the value at these index positions in the inner list so here inner is zero and inner list plus one so we are comparing the adjacent values and if the value is greater than the adjacent value then we are exchanging it and this process is repeated till we have a sorted list and this Loop gets completed so if I now go ahead and run this you'll notice the initial list was having a random order and here in the ascending order the bubble sort has sorted the list of integers so 14 15 34 35 61 66 71 19 94 96 and that's how easy it is to implement bubble Sal in [Music] cop in this lecture we'll be taking a look at how selection sort works now the first thing that we've done over here is we have created a collection and randomly inserted some values to the collection and then we're displaying it finally we applying selection sort on that and here we are printing out the sorted list now let's see how selection sort actually works this sort works by starting at the beginning of the array comparing the first element with the other elements in the array the smallest element is placed in position zero and the sort then begins again at position one now this process continues until each position except the last position has been the starting point for a new loop as you can see we making use of two Loops over here the first one is here and then we have other one over here the outer loop that we have moves from the first element in the array to the next to last element whereas the inner loop that we have moves from the second element of the array to the last element looking for values that are smaller than the element currently being pointed at by the outer loop after each iteration of the inner loop the most minimum value in the array is assigned to its proper place in the array so here we're comparing it as you can see if alter values pointing to the first item in the list then the inner one is pointing to its adjacent item and then both are compared as you can see over here inner is the value and then this Min that we have over here which is currently pointing to out so zero so here we are doing a comparison if the adjacent value is less than the outermost first value then obviously we are saying that this is the new minimum and here we are doing the Sorting now let's save this and run it so here you can see the sorted values now appearing 145 34 till 96 and top you can see the random values being displayed so that was selection sort in [Music] cop in this lecture we'll be exploring shell sort algorithm this algorithm is named after its inventor dunal shell it is basically an improvement over insertion sort and the key Concept in this algorithm is that it Compares items that are distant rather than adjacent items which is the case in insertion S as the algorithm Loops through the data set the distance between each item decreases until at the end the algorithm is comparing items that are adjacent shell sort sorts distant Elements by using an increment sequence the sequence must start with one that can then be incremented by any amount a good increment to use is three and over here you can see that the increment as long as it holds true that is it is greater than zero in that case the logic keeps on repeating itself so over here what we are doing is we are looping through from zero to all the elements that we have in our collection then over here we have taken a variable J equal to I so we initializing J with the current value of I and then we are trying to find out the value in the collection at index position I and that is being stored in the variable temp then we're checking whether the value J is greater than equal to 3 or not which is over here in Inc and the value at index position J minus I in C so initially if you see is zero minus i c is minus 3 so this will not pass at all but whenever the value will be there and the value will exist in that case this swapping will take place and finally we'll get a sorted list so over here in our programs. CS file we have just created a collection Clause added random values to it printed it and then using the Shell sort we are sorting it out so let's run this now to see it in action and here you can see the top list shows the unsorted list and the lower one is showing sorted list using shell sort [Music] in this lecture we'll be taking a look at how we can create our own collection using error list for that we have created a class called collection and if you see it's inheriting from its Base Class called collection base now if I show you collection base it has got this array list which we call as inner list attribute Now using inner list we can have our own collections how we can have our own collections by creating methods for instance here you can see I'm saying create a function called add which will accept a parameter of type object and that item will be added to this inner list now inner list is of type array list which is provided by this abstract class collection base and this one resides inside system. collection name space similarly once we have added the item we can also remove it now removing an item is pretty easy similar to add we have remove where we accept a parameter of type object and the same parameter is then passed to the inner list. remove method of the array list and it will remove that item from the array list then we have clear clear basically clear search all the elements inside the arror list so we will be back back to square one and the content of the error list will be deleted count is going to return the total number of elements that are present in the inner list or our array list now to implement this we'll go to our program.cs file and here you can see I've created an instance of the collection class that we just created here we have the instance name as courses and we are adding some courses to this collection JavaScript s.net MVC cop python Now using for each Loop we are simply writing the course names and here you'll notice we are finding out how many number of courses are there in the courses collection by using the count method and then we are removing one course from the list or the collection and then we are checking out what is the total count after that we are clearing it out and then we are checking out what is the total count now if I run this one in over here you'll notice initially it's printing JavaScript asp.net MVC cop python then when we were seeing number of courses so total courses at that point was four we removed python from it the count reduced by one and here number of courses three then we called courses. clear and here you can see now the number of courses is set to zero so all the items from the collections have been removed and that's how easy it is in cop to implement data structures now in the next lecture we'll be covering [Music] generics in the earlier lecture we covered merge salort and in this one we'll be covering quick salort just like merge s quick sort is also based on partitioning basically over here we pick an element dynamically and in most sort we kind of had the partition value predefined in our example it was set to three now here in quick sort we pick an element and call it as a pivot element using that pivot element we partition the list now there are many versions of uh choosing which element can be treated as a pate element in this example we are treating the last element of the collection as the private element in some cases we can choose the first element as private and in some other cases any random value can be picked as a pivate element now the key process over here is the partitioning so basically what we do is we pick a pivot element we based on that divide the collection into low and high value sets now anything which is lower than the pivate element goes on the lower list and anything Which is higher than the pivate element goes on the higher set and this process is repeated recursively until we get a Sol list so over here we have two methods quick sort and partition quick sort basically makes use of the partition so if you see in our programs we have a collection of numbers and then over here we are doing the quick sort and we are passing the collection and then we are saying the low value is zero so the first element is zero and uh based on the index position total minus one that is the last value in the list and we are calling it as low and high parameters now we'll go inside this method quick sort and what we are doing first is we are checking whether the value low is less than high and if that is true we are creating a partition now partition method accepts the numbers array low and high and over here if I take you inside the partition method you will see that first of all based on the index position that high is representing we are getting the pivate element and we are storing it over here and then another variable is set as I and that is being set as low minus one so in this case I is going to be set as minus one now we are looping through low to high so here you can see we have this for Loop J equals low so low was set to zero and J less than high high initially was set to 10 as our collection had 11 elements so it is going to run from 0 to 9 and here we are checking during this process whether the number at position J or index position J is less than pivate now pivate as you can see is the last element so if this statement is true we are incrementing the value of I and then we are swep in or interchanging the values as you can see now once this whole process is complete we have another set of swapping to be made and here we have created another variable temporary 1 and here we are saying numbers. get I + 1 now after this Loop has completed I will have a different value and based on this index position it will have a value over here temp one and then we say numbers do set I + 1 numbers. get high high and similarly numbers. set high temp one so let's go ahead and run it one Loop to see it in action so I'll be running it now over here you can see low is currently zero high is 10 and this is the array collection that we have total of 11 items in it and these are the items that we have in our collection now as this condition is set to True we'll be going next and here you can see we are going inside the partition method let's go inside the partition method now and here we have a break point already so we'll hit it over here and if I move next you will see the pivate element is set as 96 and that is the last element in our collection now let's move further so here you can see current value of J as of now is zero and if I say numbers. get J and let's do a quick watch over here it is returning 96 so value at J is also 96 over here and the Pate value is also 96 now this condition obviously is not going to satisfy so what it will do it will simply skip this thing altoe let's have another break point set over here and as you can see the value of J keeps on looping through so currently it's set to one now if you see the value at index position one in the collection is 15 now 15 is obviously less than 96 so here it will go inside this Loop and it will increment the and it will increment the value of I over here let's have another breakpoint and click continue so the value of I is not set to zero and here if you see numbers. get ofi so at index position zero the value that we current Curr have is 96 and that is what will be assigned to the variable temp so let's move ahead and here you can see the variable has been assigned the value 96 now and then what we doing we are setting the value at index position zero so I is set to zero and numbers. get of J if you see is 15 so if I do a quick watch over here this is the value so this is what we are setting at index position Z now and once that's done let's move to the next line and if I now show you numbers and here in a list you'll see at index position zero we have 15 and temp is having 96 now at this index position we'll be swapping out it with temp so let's proceed now and finally see what is the status so here you can see at index position zero the value is is 15 now and at index position one it has been swapped with the temp value 96 and once that's done it will continue its process and finally when it will reach at this point you'll notice the the value of I is currently set to8 and here we are trying to get the next item so I + 1 and if I show you using quick watch this this is the value we are getting at index position 9 so that value is then stored over here inside the variable temp one and then again we do the scrapping over here as you can see so at index position 9 we are setting the value stored at this index position represented by the value high so let's see doing a quick watch this also is currently 96 and if I see the value of high over here you can see it's index position 10 so that value is then stored over here at index position 9 and we are again doing a swapping so at high we are again setting temp one so after doing that it is going to return this value I + 1 as the pivate value so now if I go and take a look at numbers over here in a list you'll see 15 66 90 35 94 71 and here 9696 so this process will keep on repeating until we have this condition low is less than high as soon as this condition is false we'll skip it and we'll have our sorted list so let's run it completely now to see it in action and there you go you have the sorted list now coming up 14 15 34 35 61 66 71 90 94 96 so that's how quick sorting [Music] Works in this lecture we'll be exploring searching algorithms the first one in this is sequential search now over here we have created a collection and then obviously inserted 10 random numbers to that collection and now we have created a method called sequential search and here you can see that it is expecting a parameter integer value and here I'm just inserting a value called 96 or passing a value called 96 over here and we are trying to search whether this number exists in the numbers collection or not now let's go ahead and explore how sequential search is working so over here you can see we are looping through index position zero to the last index position and when we are doing that we we are also checking whether the value that has been passed resides at any index position or not and whenever it is found it returns from there and skips the remaining item in the list from being compared otherwise you are seeing that it returns false and we say that this value does not exist in the numbers collection now if I execute this program over here let's run this and you can see it's resulting as true now let's give one more number over here here by stopping this and here we'll be passing 106 now let's run this again and here you can see the list of numbers that's there 96 to 14 we are getting this value result as false because there's nothing in the list which is going to match with the value that we have passed six so basically in sequential search we go from one item like the first item in the list to the last item and wherever the result is found we return from that and say that the item has been found otherwise we go to the end of the list and finally return saying nothing was [Music] found in this lecture we'll be taking a look at binary search algorithm and how binary search is implemented now in order to understand binary search consider a sorted list of 1 to 100 and let's say you are given a task to guess the number or search the number let's say 82 in that case what will happen is your first guess should be the midpoint so between 1 to 100 you have the midpoint as 50 so if youve guessed 50 you'll then compare 50 with the searched value if it is lower or higher if it is lower then in that case you'll know that the value is higher than the one that you have guessed so in that case you have a new list from 50 to 100 now again in that you'll have a midpoint like 75 now when you compare 75 with 82 again the value will be low because your value is 82 which you need to find so in that scenario you'll have the list for the shortened from 75 to 100 and in that that case you know that the value exist in that particular list or subset so you'll again find a midpoint and from there you'll compare the value that you need to search and if it is lower you'll further shorten the list and if it is higher you'll again have the list byoc based on that so here what we'll be doing is let's say we have to search 96 the first thing that we did is applied selection sort so that we have everything in ascending order from 1 1 to 10 let's say and then inside the binary search if I show you what we are doing is we are having three variables upper bound lower bound and mid so upper bound is the last item in the array lower bound is the first item in the array and then we are comparing where the lower bound is equal to or less than the upper bound if that's the case then here we are trying to find a midpoint like I said if the list is between 1 to 100 then the midpoint will be 50 so that is what calculating over here and then we are comparing the mid value with the value that we need to search so here is the value that we have passed and if it matches then obviously we are returning the mid value if it doesn't then it will go to El if block and here we are saying if the value that is being searched is less than the middle value in that case we are shifting the upper bound to Mid minus one else we are shifting the lower bound to Mid + one and then the search is again performed using the while condition so as long as this lower bound is less than equal to Upper bound this Loop will go on and uh wherever the value is found it will be returned so let's go ahead and run this now so here I'll be running it now and here you can see we are getting the index position now wherever the first occurrence of the value is found we are showing it over here so if you see index position 9 if you count from here 0 1 2 3 4 5 6 7 8 9 that is where the first occurrence of the searched term is found and that is what we are returning the index position where the number was found and that's how easy it is to create a bin research algorithm [Music] in in this lecture we'll be taking a look at how we can rewrite the binary search algorithm that we covered in the previous lecture now over here what we'll be doing is we'll be enhancing our binary search approach by creating a recursive function so if you look closely at the binary search algorithm what we are doing in that is that we are shortening the list on every iteration so it's like calling the same function but with different values and that's what we have done over here if you look closely the new method that we have created recursive binary search it now accepts three parameters one being the value which we have to search and the other two is lower and upper value so initially as we were seeing that we will have a sorted list and the lower value will represent the first item in the list and the higher value will represent the last item in the list based on the index position so here index IND position zero refers to the first item in the list and numbers. minus1 represents the upper value in the list or its index value now what we are doing over here in the recursive binary search is that first thing we are checking whether the value that we have passed is less than or equal to Upper value or not now if that's the case then we are going and finding the mid value once the mid Val is there we are checking whether the value that we are searching is less than the mid value or not and if it is less then we are doing a recursive search and in this case you can see that the upper value gets modified or updated so now a shorter list is being searched in case the value is right there then obviously the index position is returned and user is made aware that here's the index position where the value exists if if that's not the case then we are again doing a search but this time the list is updated and here you can see the lower value is now updated as mid + one if this condition itself is not true in that case we are simply saying that there's no way we can find this value in this list basically the value does not exist so let's go ahead and run it now and as you can see the result is coming up at index position 9 so if you count from zero 0 1 2 3 4 5 6 7 8 and 9 so the first occurrence of the value 96 in this list is at index position 9 and here's how we have achieved it using recursive binary [Music] search in this lecture we'll be exploring another data structure called Stacks now Stacks is based on Lea principle that is last and first out and here it involves two kind of operations primarily push is used to add items to stack and pop is used to take items from the stack now in this one we have created a custom stack even though C does provide a stack data structure we'll be reviewing that as well but just to understand the NR of a stack we have created our own implementation and here you can see the stack class what we doing is we are making use of the arror list to store items in the stack and here's the Constructor that we have we are initializing the array list and then we have count which is going to return total number of items that is there in the stack then we have Push which is used to add items to stack and we have pop to take out the item from the stack and then then we have clear which is going to clear out the list and Peak is going to give you topmost item that we have in the list so here what we doing is first of all we are creating set of uh numbers and adding it to the numbers stack one after the other and that's where push operation is called here you can see number. push is the method that we have used after that we are doing a popup operation in which we are popping out one item from the stack and then we are counting the total number of items in the list after that we are doing the peak operation and finally we clearing out the list and seeing what is the exact count remaining now so let's run this first and see it in action so here you can see the push operation and after that we are doing a pop which is giving you the value 96 so that was the kind of last item inserted in the stat back and that's the reason why it was shown first or popped out first total count as you can see over here is 10 and here we are adding 11 items so you can see 0 to 10 less than equal to 10 so after popping out the total number decreased to 10 that is one less and here we are doing the peak operation so the next item in the list after popping out was 14 and that is what we showed over here and then we did our clear operation which was kind of resetting the whole stack by removing every item in the list and uh Here's the final count that is coming up after the clear operation that is zero so let's go ahead and do one more change over here before we move on to the stack so here what we'll do is as you can see we have added these numbers we'll do a count over here as well so after adding let's go ahead and do a count so here's the total count now if if I run this so you can see the push operation has inserted 11 items and after popping out the total count is now 10 so that's what I was trying to explain and now let's go ahead and see how we can make use of the built-in stack class which is provided by system. collections. generic namespace and here you can see we have stack and remember when we were discussing gener we mentioned that there is a template which we can use to create a specific kind of collection now here the collection that we are creating is stack and this is type string if I take you to the stack definition over here you'll notice that we have few methods like you can initialize a stack empty stack or you can initialize it with a capacity or a collection and then obviously we have the count method which is going to return the total number of items in this stack and uh here we have Peak and pop that we just now explored in our custom implementation similarly we have push and apart from these common methods we also have some add-ons for instance you can convert this tag to array and here you can do a copy to you can search for one item based on contains and then you have the get enumerator implementation to do for each kind of loop on the stack so this is what we are having in cop the built-in stack implementation and this one which we just now explored is the custom and pretty basic implementation just to understand the idea behind the data structure show called [Music] stack in this lecture we'll be covering cu's a q is a data structure where data enters at the rear of a list and is removed from the front of the list so basically it's like like first in first out the two popular Operation on a que are NQ and DQ basically cued are used to store items in the order in which they occur for instance qes are used to order processes submitted to an operating system or a print spoler and simulation applications using cues to model customers waiting in a line so here we have created a custom queue implementation and then obviously we'll be also exploring the one which is provided by The NET Framework itself so here we have created a q class and if you take a look at it the Q has got these functions NQ DQ Peak clear q and count we are obviously making use of the array list to create this Q data structure now NQ is responsible for adding item to the Q and DQ is responsible for removing the topmost item from the list and here here we have Peak and clear Q so basically it's going to clear all the items from the list count is going to return the total number of items in the queue now if I have to use this over here you'll notice that we are doing the same operation which we did for stack but over here it's like adding it to the Q so we are making use of the NQ operation later on here we are removing one from the list and we're printing it over here so numbers. DQ and then we are doing a count the item has been removed what is the total number of items left in the queue then here we are using the peak operation and finally we are clearing the queue and then doing a total count and here the one which is provided by the doet framework itself inside this namespace system. collections. generic Q if I take you there here you can see exactly like stack we have three Constructors empty1 with one with capacity and the other one with a collection then we have count clear and some additional methods like contains and copy to the popular ones inq and DQ get and numerator is there to Loop through the items in the array so that you can make use of the for each kind of loop and then we have Peak to convert it to an array we have two array method and then we have trim access so that is what we have from the system. collections. generic namespace now let's go ahead and execute this and see it in action so here you can see the inq operation has been performed and total number of items in the list is 11 and then we are doing a DQ operation so item 96 was removed from the Q total count after that stands at 10 then we did a peak operation so next item in the Q is 15 we then clearing it it out so the total count becomes zero and that's how easy it is to create a q in [Music] cop in this lecture we'll be taking a look at dictionary data structure basically a dictionary is a data structure structure that stores data as key value pair and in NET Framework we have dictionary Base Class which is used as an abstract class to implement different data structures that all store data as key value Pairs and in this example we'll be taking that into account to create a custom implementation of the dictionary class so here we have created our own implementation of the dictionary class and as you can see it has got the bare minimum requirements first being the add method which is kind of adding from the dictionary base in a hashtable do add and the key that we have defined so the key is over here name and value associated with that key is fee status and that is what we are storing inside the hash table and then here we are getting the item based on the key and since key is name over here that's why we have the parameter name as name similarly for remove we have the remove method and here we passing the key and based on that key we are removing it from the inner hash table collection now over here I have created an instance of the dictionary class that we just created and here using the add method we have added three students and their fee status finally we are writing it over here based on the total number of items present in the dictionary the count shows that and here we are trying to find out one specific item based on the key value so here the key is drawn and its value will be coming up as due and then we are clearing out the dictionary collection that we have here if I show you this is the data that we are getting so it says there are if you see over here there are three students and then we have this John's fee status as due now here the other implementation that c.net framework provides is the system. collections. generic dictionary and here you can see we can specify the key value pair like over here we did for string and string here we can have something like string and bullion so if I take you to the implementation over here the generic dictionary you can see there are some overloads of the Constructor like dictionary then you can initialize with capacity you can provide an equality comparer then you can have a dictionary with key value PA and some more then here if you see you can get the count of it you can just get the keys you can just get the values here you can add items you can clear one you can use the search based on contains key you can search based on contains value then you have the get in numerator implementation so that you can you know Loop through the key value pairs in a dictionary here you have the remove method and some more okay so here we just explored how to create a dictionary object in NET Framework using [Music] cop in this lecture we'll be exploring hashing and hash table so basically hashing is a very common technique for storing data in in such a way that the data can be inserted and retrieved very quickly and in order to implement hashing we make use of hash tables and hashtable is provided by default in The NET Framework Library it resides under the namespace system. collections so here you can see some of the constructors for the hash table that we have and uh some of them that we will be utilizing is this one so you have a default hash table and then you have a hash table where you can specify the capacity and if you just explore this you'll find that capacity basically means the approximate number of elements that the systems doc collections. hashtable object can initially contain so here in our code if you see we have created a hash table with 25 as the capacity and here we are adding some keys to it like salary name age department and one more way of adding key value is using the index syntax so here we are saying symbols and then we're specifying the key and then the value associated with it after that we are looping through all the keys that we have in this hash table and then we are showing all the values that we have in this hash table and finally here if you notice we are showing the key as well as the value that it contains so you can see in order to retrieve a value you can use the index syntax so symbols and then you provide the key name and that will give you the value associated with that key in the hash table so let's go ahead and quickly run this to sit in action and here you can see the keys are being printed first name salary reg gender department age and then the values over here David the salary mail that's the gender information technology and then 45 and here you can see the key value pair being printed together now let's go ahead and take a look at some of the utility methods that the hashtable class provides so we have over here method called count which is going to return total number of items that are present in the hash table then we have clear this is going to to remove all the elements of a hash table and if you want to remove a single element from hash table we can make use of the remove method here you need to provide the key and the key value PA will be removed from the hash table and then we have this contains key which is uh used for finding whether a key exists or not so you can use this before removing an item from the hash table or key from the hash table similarly you have contains values which is exactly what contains key is for key and it also gives you a bullan result whether it's present or not so if you say this key is existing or not if it exists then you can obviously move ahead and remove it similarly if you want to find out whether a value is there in the hash table or not you can use contains value and it will return either true or false so that was hashing and hash table in net [Music] framework this lecture we'll be covering a new data structure called linked list now there are variety of linked list that we can implement but NET Framework provides doubly link list data structure so link list is like there are nodes and each node points to the next one in the list and that's how they are linked because one node contains information about the other node the W link list on the other hand allows us to Traverse back and forth so a normal link list will allow you to travel from first note to the last but a w link list will allow you to travel from front to back and back to front and then we have another ver of Link list called circular link list in that the last node contains information about the first node so in a way they are connected together so the first one will connect to the next next next and the last one will connect to the first one and that's how the circular link list is created now here we will be exploring the dou link list which is provided by NET Framework now there are two parts to link list one is called the node and the other one is the list itself so over here here you can see we have this linked list node and we creating one node at a time this is a generic implementation so here we have to specify what kind of node we are creating this one is a string node and here we have provided the name John so this is a node and then we have created a link list you can see that it comes under system. collections. generate linklist so under the system. collections. generic namespace we have this data structure called Ling list and here also you have the generic version so we are seeing this list is of type string then what we are doing is we are making use of the add first method and using add first we are adding the first node to this link list called names after that we have created another node called node one which is having the value Matt and then we are adding that using the add after method now add after if you see contains two par parameters first one which is the node after which you want to insert so we are saying after node we want to insert node one so in a way we are establishing a connection from John to Matt and then we have created another node called node 2 here also we are using the add after method and this time we are saying add it after node one so now math and mic are connected then we have just created a node three which is not doing anything at all it is a null value and after that we have created a new node called a node and in this a node from the link list we are assigning the first value to this node so basically we are saying assign John to this node and here we are checking while a node is not equal to null keep on printing the value that a node contains and after that we are assigning the next item that the a node is pointing to so if you look closely over here what we are trying to do is we are assigning John to a node and then we are assigning the next item that this is pointing to so we connected John with Matt so the next item would be Matt and when we say Matt the next item the Matt is pointing to is mic and that way the whole list will be printed out we can also find out values using the find method that the list provide and here you can see we are trying to find a word David So this this is not going to work but if I go ahead and change this to let's say Matt and then say enames do find mat obviously it is going to find mat and then the value will be assigned to this a node and here when we say a node equals name do first again we are pointing John to this a node and again the same Loop is being printed so that's how you can Traverse add items to a node and find node values in a link list let's go ahead and quickly run this to see an action and and here you can see John Matt Mike and then again John Matt mik is being printed so that was link list in NET [Music] Framework in this lecture we'll be exploring nonlinear data structure and the most common example of a nonlinear data structure is a binary tree a nonlinear data structure is used to store data in a hierarchical manner and talking about binary trees the benefit of this over traditional data structures like arrays and Ling lists is that one can search a binary tree very quickly and at the same time one can also insert data and delete data quickly from from a binary tree as opposed to an array let's first of all understand the definition of a tree a tree is a set of nodes as you can see from this example each node is connected by edges so here we can see that in binary tree the topmost node is called the root node and every node can have maximum two child nodes as you can see over here node 8 is the root node and it has got two sub no nodes or child nodes 3 and 10 and in the example you can also see node 14 is having just one child that's 13 so maximum a node can have two child nodes so a node can have 0 1 or more nodes connected to it and binary tree as per its name itself restricts it to two nodes per child or to two nodes per node if you want to further analyze it a tree can be broken down into levels let's call it as root node as level zero or at level zero and then at level one we have these two child noes 3 and 10 then at level two we have child nodes 1 6 and 14 and then at level three we have child nodes or nodes 47 and 13 one more way of looking at this binary tree is that we can divide this into left and right portions if you see from the root node there are two clear separations nodes appearing on the left side and then nodes appearing on the right side so for eight the left child is three and right child is 10 or left node is three and right node is 10 and the example that we will be exploring will be binary search tree in which we'll be exploring how these left and right nodes play a crucial role a binary search tree is made up of nodes so here as you can see we have a Noe class and if I explore this you'll find out there a couple of items or attributes in this class they are data and then left node right node and then we are also having a method called display node which is going to display the data assigned to a given node so now that we have our node defined we'll be not taking a look at how we can create our binary search tree so here's a CL called binary search tree and we have a root node so if you take the look at the example that we had this is the root node eight that we see over here is the root node the first item in the primary search tree so that will become the root node we have a Constructor which initializes root as null then in order to add items to a binary tree we have this method called insert so what we are doing over here we are sending a value let's say we are sending eight to this method as the first value so that will be assigned as root note now let's see how it does that first thing we have created an instance of the no CLA then using the data attribute of the node class we are saying this is the data which this node is going to have after that we are checking it if the root node is null in that case the new node that we have created becomes the root node so here we have our root node defined in case root node was not null in that case we would have to look where exactly this particular value will go whether to left or to right so here in this example if you see there are two places where it will go so left is three and right is 10 so in case this root node was already defined then it would be further searched where this particular value will be inserted in this scenario let's assume if root node was occupied then we'll have to find whether left node is available or not and if that is also occupied then we'll have to check about the right node and if it's available the value will be inserted at that position and that's what we are doing over here you can see here we have taken the root node as the current node and then another variable called parent has been defined after that we are assigning current to the node parent that we have defined over here and what we are doing we are checking whether the value I that we have to insert is less than the current data so if you see eight was the root node and if let's say three is the value that we have to insert what we'll do is will come over here we'll see 3 is less than 8 that's true so the lower values are kept on the left side or left edges and the higher values are kept on the right side so here if you see 3 is less than 8 in that case it will go to the left node and current do left becomes the current value and then again we check over there if that node is empty or not if it is then we make parent. left is equal to new node so the value three will then be inserted on the left hand side if that's not the case that is left is already occupied in that case we'll go to right and there also we check whether it's empty or not if it is empty then we put that new node as the right node for that particular parent and that's pretty much it in order to insert a particular node in the binary search tree now there are a couple of ways to Traverse the binary tree primarily we have in order pre-order and post order if you look closely in order is something which is going to print the value in ascending order that is from low to high so in that case you'll notice that we are storing the lower values on the left side and higher values on the right side so what it is going to do is it will first of all Traverse left nodes and then display the data and then Traverse the right node and display the data so that way it is going to show it in the ascending order then in pre-order if you see it is going to Traverse left then right so currently whatever node position it is on it will display that and then from there it will Traverse left once and then it will Traverse right once in that sense it is going to Traverse the only difference between in order and pre-order is that you can see the display is happening prior in the pre-order and here it's kind of sandwiched between left and right reversals then we have this post order where first of left nodes will be searched and then after that the right ones and then we display it over here apart from this we have couple of methods as well to find out the minimum and maximum value present in a binary search tree and that we basically do using the left node we have all the minimum values so we'll just Traverse the left notes to find out the minimum values and if you have to find out the maximum values we'll covers the right note only so you can see the difference now that we know where exactly the maximum values resides the minimum value resides and based on that we can say that binary search trees are faster because we certainly know where to find certain kind of values like the maximum Ones Will reside on the right side and here we have created one more method called find which is just going to find a node based on the key that we have provided so if the key is less than the current data it becomes the left becomes the current value and if it is greater than then the right becomes the current value and if there's nothing then we just return null and if we found something we are returning that particular node now let's go ahead and see all these things in action first and then in the next lecture we'll see how to delete nodes from a binary search tree so here you can see that I have created a small example wherein we are specifically mentioning what values we are trying to insert and the reason behind this to explicitly mention the Valu so that we can see how the traversal is working when we print out the results now here the insert method I have made few more changes so I would like to First explain what changes were made and then I'll take you to the demo so initially what we were doing is like when we were traversing from the root note to left and right in the explanation I forgot to to write some more code to change the current value from root to the left and right ones for instance if you take the example over here in program.cs first of all we are inserting 23 so this gets inserted as a root node then we are trying to insert 45 so 45 will be inserted on the right because it is greater than the root node value 23 after that we are inserting 16 so when we'll try to insert 16 16 will go on the left side of the root node that is 23 so now we have a root node with 23 and two values 16 and 45 16 on the left 45 on the right after that when we try to insert 37 37 will be first compared with the root note obviously 37 is greater than 23 so it will go towards the right now right is already occupied by 45 and that is where I miss out the code to change the current position from root to the next one so now that here in the code you can see that we are checking if the value that is being inserted is less than the current data then we are going to the left basically and uh if that's not the case then we are going to the right now once we are on the left side at that point we are making the current do left as the current so let's say we are on a 16 16 becomes the current value or current modde and then then if it is already having a value then I will go and change it from 23 to 16 so here the parent is now 16 and current do left will point to the left of 16 so if that's null then we'll insert the value over there if that's occupied then we'll go to the right of that node so that's how it is right now and let's run this now to see it in action over here you can see in audit traversal is actually printing it in ascending order so 3 16 22 23 37 45 and 99 are being printed over there and in pre-ordered traval you have 236 3 22 45 37 and 99 and then on post order traval you have 3 226 3799 4523 the Min value as you can see is three and max value is 99 using the find method we were able to find the node here 99. data so that also got printed now in the next one we'll be exploring delete functionality in Min search [Music] tree in this lecture we'll be taking a look at how to delete a node from a binary search tree the example that we'll be taking here is deleting a node with children so you can see that we have created a method called delete node and then we passing the root node itself in the method and over here if I take you to the delete node method what we are doing is we are first of all creating a node instance and then assigning the value that we want to delete as data of after that we are calling this method called delete where we are passing the root node and then we are deleting it now here the root node is already defined as an attribute and that is how we can pass it directly over here and then the instance that we create a delete node is being passed to this method called delete now if you come inside this method here we are checking if root is null in that case we are returning root itself so this is not going to delete anything if the root is null now after that we are checking if the data that we want to delete is less than the root data in that case we are going and calling the delete again and this time we are getting the root. left if the data that we want to delete is greater than root. data then we are doing this operation and this time we are saying root. WR after that if the data that we want to delete is found to be a root data itself so what we doing is we going inside this and here we are trying to find out whether there is any child nodes or not so in order to find out child nodes we are checking root. left and root. right now in this case our root node is having two Childs 13 and 45 so in this case this condition will not get executed over here this will also be skipped because root. left is not null in our case and here also this will be skipped now as we have both the child nodes what we are doing is we taking the root. wr. data so in this case 45 will be assigned over here and that will part of the root. data so 45 becomes the root node now and then we are deleting the value that we have passed and after that we are finally returning the data so now if I run this one here you'll see when we have deleted a node with children in order traversal no shows 31622 45 3799 earlier you can see that it was showing 23 as well now 23 has been removed from the delete node and rest of the items on nodes in the binary search tree are displayed over here so that's how we delete a node from a binary search tree [Music] in this lecture we'll be discussing a new data structure called set a set is a collection of unique elements the elements of a set are called members and the two most important properties of sets are that the members of a set are unordered and no member can occur in a set more than once a set is defined as an unordered collection of related members in which no member occurs more than once a set that contains no members is called empty set the universe is the set of all possible members two sets are considered equal if they contain exactly the same members a set is considered a subset of another set if all the members numbers of the first set are contained in the second set on this data structure we can perform Union intersection and difference Union is basically a new set is obtained by combining the members of One set with the members of a second set intersection this also produces a new set by adding all the members of One set that also exists in a second set then we have difference which results in a new set by adding all the members of One set except those that also exist in a second set intersection operation and Union operation are commutative which means that set 1 intersection set two is equal to set two intersect set 1 and the same is true for the union of the two sets intersection and unions are associative as well which means set one intersection set two intersection set 3 is equal to set one intersection set 2 intersection set 3 and this holds for Union as well now some of the operations that I'm discussing will be more relevant when we'll be covering it with an example so over here we have created a set class using the bit array data structure we have a Constructor which is initializing the data with five bit array elements and then we have some methods over here like add to add items to the BET array data collection that we have and then we have is member which is going to find out whether a particular value is part of the collection or not then we have remove which will remove the item from the set we we have Union which is as I mentioned is obtained by combining one set with the members of second set so that's what we are doing over here we're combining one set with the other so this is the current set and one we are passing over here and together we combining it and then we are combining it and returning as a new set then we have intersection and difference that we just discussed and then we have is subset function which finds out whether a particular set is a subset of a given set or not and then this one is the two string method that we have over here now in our program.cs file we have created a set called set a and here you can see it is having three items in it or members in it 1 2 and three then we' have created another set and this has got two members two and three a new set has been created called set C and here we are doing Union operation so you can see we are kind of adding two sets set a union set B so the new set C that we have over here will have all these values 1 2 3 and when we'll print it this is going to print the values of set a 1 2 3 and set c will be printing 1 2 3 next what we are doing is we are updating set C by the intersection method intersection as I explained generates a new set by adding all the members of One set that also exists in a second set so if you see set a and set B I've got these values 2 3 2 3 so set c will have that value and then the same will be printed then we have set a difference set B difference as I mentioned returns a new set by adding all the members of One set except those that also exist in a second set so if you see set a and set B over here 2 3 23 exists in both set a as well as in set B so the difference operation will result in a new set with value one and that is what we will get in set C over here finally we are trying to check whether set B is a subset of set a or not and if it is then we are printing this line B is a subset of a otherwise we say B is not a subset of a so let's go ahead and see all these in action now so here you can see so here you can see first it is printing set a values 1 2 3 then it is printing set C value with the Union we were getting this value 1 2 3 then for intersection we were getting 2 three and for difference we were getting 1 and then finally with the is subset we getting this B is a subset of a so that was sets in data structure using NET [Music] [Applause] Framework [Music] I