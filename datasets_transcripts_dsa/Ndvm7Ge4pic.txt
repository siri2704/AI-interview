algorithms let's talk about them matter of fact I have yours right here oh factorial why are you some kind of traveling salesman hey there my gorgeous friends on the internet and welcome to this new series I'm starting called data structures and algorithms that's that's not an original name the easy way for beginners they're all taken so we'll start off quite simple we're going to look at big own notation then from there on we're going to look at different sorting algorithms that we can use also different search algor ithms and then from there on we'll look at link list as well binary trees hash Maps hash brownies all of that good chance okay so let's get going so let's have a look at Big O notation before we write any code let me just show you a quick drawing here that I just made so the these are houses by the way and this is the road here in the middle so let's say we want to get to house number seven all right we're delivering food all right the programming didn't work out so we are here at the beginning right now how would you approach this right you you probably wouldn't go like house to house like this you go to number one and be like well this is not seven so I guess I'll go to the next one so you go down here that's two so I guess that's I'll cross the street and go to the third one right you're incrementally going from house to house trying to find the number that you're looking for so you get to Seven right so that's one way of doing it but there's different ways you can do it now a better way we could approach this is that we already know that these houses are in order right so if I cross down the street I know that the numbers are going to get higher so I could just maybe walk down to the middle of the street and then have a look in the back and see oh everything here in the back is probably not going to be uh house number seven uh because we're all in order right so house number seven is going to be from here on out forward all right so we can pretty much cut half of the size down right in the middle there and eliminate everything here on the left now the first example might not be too bad of going house to house here in this case because we're all just going to number seven right so at best we're doing like a a 10 minute cardio here right not even that much amount so let's say we get to a different neighborhood though and there's many more houses here all right so it's it goes the street has 1,000 houses on them and we want to get to 800 rent super high in this neighborhood so getting to 800 now is going to take us much much longer using the method that we use right going from house to house to house that's kind of like our algorithm that we used in real life uh so getting to 800 now going from 1 to two to three to four to five is going to be much much slower so that's kind of what Big O is it's way of mathematically kind of measuring the efficiency of an algorithm based on input size So based on how your input grows so if my input grows much much bigger if I have much many more houses will my algorithm be slower so the example we saw with the houses where we went individually to each individ ual house is essentially linear search so let's see how we can implement it in code and then we're going to talk about the time complexity so I'll do it in JavaScript and typescript we might do it in go as well just for fun so it would look something like this so let's define a function here and let's call this linear search okay and then here we're going to have an array that this is going to take in let's say it's going to be a number array and we'll also have a Target which is a number and finally here I want to return a number so if we just think about this a little bit what we want is to go through each individual item in this array and once we get to the Target we want to stop and return it otherwise don't all right so we can say something like four we'll do a loop we'll initialize a I set it to zero and then we'll say if I is smaller than array doll length right so we're going through the array then we can increment this by one so here we can say if the array I triple equals to the Target well then we got it so we can just return that I like that if it doesn't find it we can just return minus one at the end and that's essentially it so if we go down here and we do a linear search and let's say I'll pass in an array here two three four five just a bunch here 12 55 and then my target is going to be 12 and since I'm returning the number here we can also save it so if I do shift I I can go to the beginning here let's save it in a constant and I'll say yay this is my target element let's go down here at the bottom and do a console log yay and see if we get this and that's essentially it so if I go back here and console log this out for us as you can see we got back the number seven now that's the position of it uh because we ended up here returning just I if you want to return the actual element you can do array of I like that and if we run this again then we should get back 12 and there we go we got back 12 so the time complexity for this algorithm will be o of n where n here is going to be your data so the bigger your data gets it will the time for it to execute and operate will go linearly with the size of the data so hypothetically let's just say that this operation took a millisecond right to go through one of these elements well then that would mean that it's 1 millisecond time n right so linearly so if it's 10 elements in the array then it would take 10 milliseconds now you you might be like wait wait wait wait what if my number is here what if 12 is here right at the beginning what if it's the first item right then we don't have to go through everything right even if our data grows that but that's like assuming the best case scenario when we when it comes to these algorithms we usually tend to always uh want to look at the worst case scenarios because yeah the element that you might be looking for 12 here might be here at the beginning now or you might get lucky and it's going to happen again but eventually it's going to be somewhere at the end and then it's going to run much much slower uh so that's why we say in the worst case scenario the linear search here is going to be o of n okay now let's look at something else Let's see we have some users all right we managed to do it we got Bob on board on our crappy website we got Maria we got John and we got the noio Okay cool so what if I want to run a operation where I let's just I I'm trying to access John all right I'm going to go console log and we'll go to users and I'm going to try to access the second index here so this is something that you'd call constant time which means that it doesn't matter how many elements we have here all right this can grow to 10 bajillion here it doesn't matter because what I'm doing here is I'm directly going to that specific user all right it's like having a GPS with the house and going directly to that location I'm not checking what's happening before I'm not checking what's happening after I know where the address is and we're going to go to it all right so that's constant time now that doesn't mean that it's instant or anything like that it just means that in this case this is going to take one operation to do all right there might be an example where it takes three or four operations to do do that doesn't mean that it's linear time now that would still be constant time for example if I go here and do a for Loop so I say four let I set that to zero right and I'll say I is smaller than [Music] um let's say three like that right and then I'll do i++ so I'm explicitly setting the value three here uh if I do some whatever it is I'm doing with the users here console log users I for example what time complexity do you think this is this is still um current time complexity it's not linear because we are stopping at three here so no matter again how big the data goes here we can have 10 bajillion elements we're stopping after three so even though we're doing three operations here here we're just doing one operation which we're reading one uh one element of the array what is this thing that keeps popping up here we're doing three but when it comes to constants we don't really care you know we wouldn't say that this example here is an O of like three it took three operations to do something like that o of one all right so if we look at constant time here on the chart it doesn't really matter if it's one operation or two operations all we really care about that this line stays pretty much flat here and it doesn't increase our time complexity once the data grows now other examples I can give you here is if we push something to the end of this array so if we take users. push and we push in a new value here let's console log this out so we'll say users here all right let's just pop this open here and run this so as you can see we added the new value at the end there so in this case uh this is constant time as well because we're just appending a value at the end the pole array doesn't doesn't change in any way how however if we try to uh shift or unshift a value here at the beginning then we need to move every other element to the next location right so so in this case Bob here is going to have an index of zero one 2 3 4 but if we had a new element here at the beginning so if we insert something new there we go now Bob is going to need to go to this to the new position here to index one and then Maria needs to go from 1 to two and then John from two to three you see what I'm saying doing shift and unshift is an O of n so we pretty much saw how linear search worked let me also show you how binary search works uh because I kind of showed you in the initial example right linear search was where we went from house to house to house until we reached the Target in this case let's say 2030 with binary search what we did was we went down to the middle of the road and basically said hey anything before that could not be 230 uh because uh everything's sorted here all right so binary search only works on sorted arrays so what we do is let's say we're looking for 230 is we find the midpoint of this so somewhere in this case it would be I don't know let's say somewhere here right that's the midpoint of it 174 I know it's not the exact m point but whatever it doesn't matter so we check the MP point the array and we say hey is this the thing we're looking for is this 230 no okay well if it's not we can eliminate everything before that because this number 174 is lower than 230 so it cannot be any of the previous values so we essentially cut this in half and now what we can do is set our beginning point over to this next one so 177 is going to be our new beginning and now we'll cut it in half again so the half would be maybe somewhere uh here 264 right 246 that's our new midpoint now we check again hey is this bigger or lower than our value that we were looking for 230 in this case it's bigger so it cannot be anything above this right so we essentially cut this to like this length right here so then we check again we put the midpoint again and in our case if the myidp point just hits we keep doing this over and over again slicing it in half and half until we have one element left and that's going to be our 230 so in code to just make this a bit clearer it would the implementation would look something like this so that's Define a function called binary search and this is going to take in an array so we'll do the same we'll say an array of numbers and then we have our Target as well so the target is going to be a number as well and this is also going to just return us a number here in the end okay so what do we need well we need to get our beginning point and the ending point of our array so we can see let let's see left side or you can say uh beginning here but I'll say left because this is going to be a bit easier so that's going to be zero right uh that's going to be the first element in our array and then the right so I'll just Define this is going to be the length of the array okay so we got that so now we can do our Loop this is a while loop we'll say while I'll say if left is smaller or equal than the right which in this case it is uh what we're going to do is find that midpoint so we can say cons mid equals to I'm going to say math. floor and we're going to pass in the left plus right and divide all this by two so we'll say left plus right divided by two and now the first check we do is well if our midpoint is the target then we're done we finished so we'll say if a mid sorry array mid like that triple equals to the Target then we can return array mid like that now let's say our midpoint in this example is 195 so in case that this is smaller than our Target which is like 230 then our left here right our beginning needs to be set a new value we basically need to put everything else away here and set that as new midpoint so what we can do here is go here and say if array mid smaller than Target right what we want to do is left is equal to Mid + 1 all right so basically our left side now will be put to the new middle spot and I'm adding one to it because we already checked the middle right so let's say we checked 195 as a middle well now the new Left starting point should be 198 right and then our middle is going to be here somewhere now and then of course we can do the opposite for the right so I can just say else here because it's going to catch it I can say right equals to Mid minus one all right we'll do the opposite of it and that's it and finally here at the end we can just return minus one if the target's not found and let's give that a crack so let's do a test here and we're going to say binary search we're going to pass down the houses as the array and the second argument let's see we're looking for 243 like that now check it out I am also going to console L out mid here uh in the binary search and if we run this now you're going to see it only has like four or five operations that needs to do to actually find that number uh if we actually console log this out so you can see console log out test uh let's run this again and you're going to see that we do find the 24 D3 so what's the time complexity for this algorithm well we're essentially dividing it by two every single time right so we have 100 we divided by two we're left with 50 divided by two we're left with 25 elements we divided by two and so on and so forth until we're left with one element so this would be a o log of N and if we view it on the chart here as you can see the bigger the data gets this algorithm actually gets more and more efficient now I got a fun challenge for you but before we do that I want to challenge you to learn something new and you can do that with today's sponsor brilliant brilliant is a learning platform where you learn by doing with thousands of interactive lessons in math data analysis programming and even AI now we barely scratched the surface of these algorithms in this episode that's why I want to highly recommend the computer science fundamentals on brilliant they have over 43 interactive lessons here that cover everything from Big O notation to sorting arrays to finding the best best possible algorithm for your application the best part is these lessons are short interactive and straight to the point so whenever I have some downtime and I'm a bit unclear or I kind of forgot how an algorithm works I love to jump onto brilliant and do one of these interactive courses I feel like it really solidifies your learning so whether you're brushing up on fundamentals or diving into more advanced topics like data science brilliant makes it easy to learn anywhere any time so give brilliant a go by visiting the link in the description down below or optionally you can even scan this QR code and if you do you get 30 days for free and also 20% off your annual subscription thank you so much for brilliant for sponsoring this episode and let's get back into it okay so I want you to look at this code for just a little bit here and try to figure out what kind of time complexity it is so we have a function summon Max I didn't type it out but we got a zero here for the sum a Max and when you're looking for like trying to figure out the time complexity the easiest way you're going to actually see this is try to look for Loops all right Loops really give that away so as you can see in this case we have two Loops so we're going through ones adding the sum together here and then we're doing it one more time uh down here to add the max as well to find the maximum value okay so what kind of uh time complexity is here well we learned that just doing a simple Loop like that would be linear time so o of n so if we go down here right you'd represent this as o of n but in this case we have another loop so we have two Loops so you could do it's O of n plus n really right or o of two of n but when you have constants like this like 2 * n or n + n again we usually just ignore the constants so you'd get rid of the two and just say o of n so in this case we we don't say 2 N or even if you have like 10 plus n right we don't care about the constants here because they don't really affect it as much as something like oh of like N squared all right the way uh this increases on the chart you're going to see is way way crazier now before I wrap this episode up let me show you two other really popular uh time complexities that you might stumble upon so one here is a function that called it's called print all pairs so what we're doing for is we have a loop here as you can see and then in there we have another loop uh and as you can see we're just matching array I and array J together here so we're pretty much like trying to find all the different combinations we can pair uh these people together okay that's kind of essentially it so if we run this code here let's run this npm runev as you can see those are all the possible uh different pairings that we can do now in this case we are pairing the same people together here but it is what it is me myself and I okay don't worry about it h so what's the time complexity here well if we look at the outer loop here this outer loop runs nend times so linear right however the inner loop here runs end times as well so for every element here that we Loop over we're doing another full loop so in terms of complexity this will be o of n * n right right which is n by the power of two how do you do the power here like that o to the power of two so this would run in a quadratic time now last but not least I wanted to show you one more example here and this might not make too much sense if you don't know recursion or stuff like that uh but I wanted to show you an example of exponential time complexity as well so this is about getting a Fibonacci number here so as you can see we're passing down number which is n and we're checking our base case here is if n is smaller or equal than one then we return that's when we stop right I added the console log here so we can see which uh Fibonacci Sequence we're calculating and then here we're returning essentially we're calling the same function recursively with n minus1 plus nus 2 so we're calling this two times so every time we run and invoke this function it's going to create it's going to invoke two more of the same right so let's say we're passing down the Fibonacci number five here so it would look something like this when this gets invoked it's going to recursively invoke FIB FIB four FIP three and FIB four will invoke FIP three and FIP two and so on and so forth and this is why grows exponentially so basically if we'd run FIB two the amount of calculations we need here would be three on 35 on 49 on 515 and as you can see it just keeps going up and up and then as you can see when you get to like 20 30 it the number just exponentially grows here so essentially every time we add plus one here to n every time we add plus one we essentially double the amount of calculations that need to be done so the way we could represent this would be o 2 to the power of n and it looks really really crazy on the graph so there we go that's the gist of it we'll cover much more in detail in the next episode and if you want to see something specific let me know down in the comments below but thank you so much for being here with me and watching these episodes really appreciate it thank you for my wife as well for also getting these really cool lights in the background I really like them basically got me CSS background changer in real life don't believe me hey change the background to Big see it how cool is that all right catch you in the next one pee