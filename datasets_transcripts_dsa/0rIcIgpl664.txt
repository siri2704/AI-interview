arrays are the simplest data structures which are random aess random axess means two dimensional arrays are different to look at and mean the way we conceptually think of two dimensional AR is different and the way they are physically stored in the memory are different ml C and real these functions are actually defined so structures are going to be a kind of grouping I mean if you want to group different elements we are going to use structure for depth of the tree is also going to tell you how big this stack is required generally a single link list will contain nodes and uh these nodes are gener structure so one thing is I want to push an element I want to Define push know the building bi is to make the searching efficient so arrays arrays are the you know simplest data structures which are random access Random Access means in order to go to an element you need not um you need not cross all the elements you can directly go into that element okay so how is this possible it is possible that we could randomly access an element in the array because when we are storing this array in the main memory it will be stored continuously right since we are able to store the array continuously in the main memory or in some memory either hard disk or main memory wherever you going to store it since you are going to store it continuously and since you know the size of each element and the starting address of the array right you can directly go into whatever memory location you can want you want and you can access it but the same thing is not possible with link list isn't it so in link list what happens is they are not continuous so one element can be present there one element can be present here and it can be random right and only way to access these elements is to go through a chain or or list isn't it so in link list Random Access is not possible but in Array Random Access is possible you can go to whatever element you want very easily right so there are there is nothing much interesting about the single dimensional array there is nothing interesting in this sense if you have one dimensional array that one dimensional array will be completely stored in the memory and you can go into any element you want uh so there are two things whenever you talk about arrays one thing is what is the index starting with sometimes index might start with zero and sometimes index might start with one so that is the only difference I mean that is the only where uh point where you have to be very very careful so let us say uh the index is starting with zero okay so this index is zero this index is 1 this index is 2 this index is three let us assume that each element is occupying 1 by of memory 1 by 1 by 1 by 1 by 1 by right so in this case in order to reach an element a of I what is the address right which means in the main memory where should I go and look into so if the array indexes are starting from zero right then just observe it in order to reach the element two how many elements I should be Crossing exactly two elements which is equal to the array Index right therefore whenever array indices are starting from zero the number of elements that you have to cross in order to reach a particular element is equal to the index of the element which means in this case the number of elements you need to cross is 2 therefore you can write it as two will be the address of the uh you know this particular element assuming that the base of the array is zero right in case if the base of the array is not zero if it is something else let us say if the array is starting at 100 the location address 100 then what will be the index index will be 100 + 2 right so in this case 100 + I are you following it see I'm saying that in case if the indices are going to start from zero what is the location of the element two in case of uh you know onedimensional array so if the array is going to start at some base let's call it 100 here in this example then in order to reach element two I have to cross two elements isn't it so similarly in order to reach uh element I how many elements I should be Crossing I if the base of the array is 100 then 100 + I is the starting location of the element I that is what I mean to say right now what if the elements are starting with one which means indices one 1 2 3 4 5 now in order to reach element 2 how many elements should I be Crossing only one element right which means IUS one so in case of you know in case if the indic are starting from one then in order to reach an element I how many elements I should cross 100 + i - one this will be the address got it this will be the address of the element two okay now this is entirely now these formulas are when okay don't remember them as formulas you should be able to derive them on the go don't okay very simple by hearted now my question is what if what if it is uh you know every element is not of size one by here I'm that every every element is of size one by what if every element is of size 2 bytes two bytes means you know if this is the array it will be stored in the memory using two bytes so what happens is um the first element will occupy two bytes 0 and 1 the second element will occupy two BS 2 and three right four and five 6 and 7 therefore the element number Z will be present a of 0 in case are starting with z right a of 0 will be present starting at z a of 1 will be present starting at 2 a of two will be present starting at four and a of three will be present starting at 6 in case of the indices are starting from one a of 1 will be present starting at zero a of two will be present starting at two a of three will be present a of four will be present here are you getting this so now now let's consider the case see most of the cases most of the cases our ARR will start with indic zero and sometimes as is possible that they might give you even starting with one so assume that you know our ARR is starting with zero first and then let's formula work so now how many elements you should cross now watch it in order to reach the element two how many elements you should cross if the indices are starting from zero the number of elements you should cross is the same know which is equal to the index so in order to reach the element two the number of elements I should be Crossing is two right so in order to access a of I the number of elements I should be Crossing is equal to I elements right but then what is the size of each element size of each element is 2 bytes therefore the total number of bytes I have to cross is i i i into two got it and then in case if it is stored at location 100 at location 100 then this will be 100 this will be one1 byes this will be2 this will be 1345 right so not to SC even take that into consideration you can add the base what it so what is it now in not to access an element I in case if the starting from you know index zero then we have to multiply I into this is nothing but the size size of each element in bytes okay size of each element in bites or if it is word addressable if they are talking about words then size of each each element in words and then this is the Base address that is how you could you would you know get what happens if it is starting from zero let's see what happens if it is starting from one see in order to reach the element two how many element should you cross one element therefore in order to reach a of I how many elements I should cross i- one elements yes I'm going to cross i- one elements okay and then what is the size of each element here 2 i - 1 into 2 right plus what is the base of it 100 so in case addresses are starting with index one in the in the equ they're using starting with starting with one or zero they'll clearly mention they'll say that a is an array which is from 0 to n it means that indices are starting from zero they'll say that a is an array which is starting from 1 to n which means indices are starting with one right so in this case whenever addresses are starting with you know one indes are starting with one then how many elements you should be Crossing i- one elements and size of each one is two right and this one is base so what is it here this one is nothing but size of the element in verse right since it is bable in general what take is words okay they'll they'll give you that each many words so multiply with the size of the element okay and then add the base this is nothing but the Base address got it so coming to the binary how does the binary work is uh so the binary is nothing but when you are multiplying first you you find out the binary representation of this okay binary representation of one and then what you should do is you should multiply it with the base I mean let us say the size of the element is two and the binary representation of this okay in this case what is the binary representation of this binary representation of this number you know um how much 2 is 1 and then size of this one is got it and now in binary is nothing but so in case if you have a base then I'm going to write it as base and then this address base also I can convert it into this binary and I can write it with this right 1 0 base 2 understood this convert this into binary and then append those many zeros whichever is equal to the size right getting this so that is how you find out uh where is the what is the array address so most of the times they might not give you even the base so if they don't give you the base assume that it's starting with zero in case they have given you the base you can assume that it is starting with that base otherwise what you could do is most most of the times the uh a is a representation of the base so you can write here as a which means a represent the base of the array you can write it as a plus this much right so there is nothing much interesting about this onedimensional arrays two dimensional arrays are generally interesting the way the way you store the two dimensional see the way you store the one dimensional array there is nothing nothing interesting in the sense you'll take the entire array and save it as it is there are no design decisions that have to be made here so the only decision is you have to either you have to start with zero or start with one most of the programming languages they start with zero because our memory addresses they start with zero and it is logical to use zero and there are some questions which starts with one okay now let's look at the two dimensional arrs which will be interesting now let's see how to work with two dimensional arrays uh so the problem is two dimensional arrays are different to look at I mean the the way we conceptually think of two dimensional arrays is different and the way they are physically stored in the memory are different so once you understand how they are stored you can write better better programs okay so anyway Let's uh see the example then you'll understand it better let us say a is a two dimensional array of size 3x4 what does it mean it is having three rows and four columns and let us assume that okay there are two ways you know you can generally talk about arrays sometimes you can think that arrays are starting with index zero all the are starting with zero and sometimes you can think that they are starting with one let us take both of them initially I'll take the one with the indic zero and then and next the one with indices one so now if I have three rows the three rows can be row number zero row number one row number two and four columns can be column number zero column number one column number two column number three so these are three rows and four columns right then now now what is the index of index of each element is 0 0 0 1 02 03 1 0 1 1 1 2 1 3 2 0 2 1 22 2 3 so these are the various indices of the elements right and now in case if it is uh indices are starting from one then how does it look like so index one index 2 index 3 right so these are three rows and then columns are 1 2 3 4 columns then how does each each element index look each element looks like 1 1 1 2 1 3 1 4 2 1 2 2 2 3 2 4 31 32 33 34 right and now uh how to store it see even though if you're looking looking at the arrrow like this I cannot take this and then put it in the memory as it is right then the random access will fail Random Access is Possible only because the array is stored at continuous locations in case if you try to put it as it is in the you know main memory or anywhere in the secondary memory what happens is from here to here it is contous and then there is lot of blank space and then from here to here it is contous now what is the link between these two then you have to use a link list or something it is going to be complex so in order to still have that random access we have to put this entirely in a contigous manner how can I put it contigous manner then then you have to convert this two dimensional array into one dimensional array How can I convert it there are two ways One Way says that you take each row and put it in the main in this memory whatever main memory or secondary dis or Cache wherever and then you take the next row and you put it you know contous to the first row like that is called as row major order I'll just tell you see this so what is this row major order is row major order which means we are going to store it row by Row first row second row third row like that okay now assume that memory is going to start from here I mean from here the array is loaded then 0 0 0 1 02 03 and then 1 0 1 1 1 2 13 and then 2 0 21 22 23 right right so if you watch it we have placed it row after the row this is the first row and this is the second row and this is the third row we have three rows and we have placed the row after the row right now if I have to reach any element any particular element let us say I have to reach the element 22 right I have to reach the element 22 so whenever the programmer refers to the array array a and the element 2 two then we have to convert it the ARR reference in such a way that your you know the data bus will be able to go into this particular element in the memory and get it so now the main challenge is how are you going to convert the array references in two dimensional array into this uh you know uh memory references right so how can you do it so if you watch it this Element 22 in case if I have used the row major order which means row after the row if I place it in order to reach this element I have to cross all the rows ahead of I mean before it and after Crossing all the rows before it once I reach the particular Row in which it is present then I have to reach I have to cross the you know Elements which are inside the row right so in this case U if I if you are talking about 22 right the element know the indices 2 two then you are supposed to cross two rows two rows and then in the particular row then you are supposed to cross two elements right so that is how it should be happening so what what is that here is if I have to cross if I have to reach 22 2 two then I am supposed to cross two rows so the number of rows I should cross is two rows then how many elements are present in each row the number of columns are four the number of elements present is 2 into 4 which means eight elements are present in each row right so what does it mean in order to reach this particular element we are supposed to cross eight El elements right this 4 + 4 is 8 elements and then after Crossing these eight elements you are supposed to cross two elements in this row isn't it you are supposed to cross two elements then how can I get the two elements from the second are okay so actually instead of taking this one this is 22 it will be confusing for you I'll take 2 one it will be easy right so now once I reach this I'm talking about this element okay now once I cross this particular two rows then after reaching the required row I'm supposed to cross only one element this second index is going to tell you how many elements should you should cross in one row right then this is the total number of elements that I should be Crossing isn't it this is the total number of elements I should be Crossing so now know one more thing you should consider is how many words is each element occupying in case if the if every element ment is occupying one word you can directly say that this is the address if this array is starting from zero in case if this array is starting from 100 the location 100 you can add 100 and you can say that this is the address of this element right 2 one but then sometimes what happens is each element can be of you know various sizes like they can say that each element is two bytes or each element is two words in that case you should even multiply with the number of words so that you can get the exact address right are you following it these many elements I should cross in order to reach my particular these many elements I should cross in order to reach the particular element and after reaching after Crossing these many elements right I have to even see how many words in terms of words how many words I should cross so for that reason I should even multiply with the size of each element got it and then let us say size of each element is 2 bytes here right and then add the base then I'll get the appropriate answer right so in case if it is going to start with 100 then what should this entire number be check this 100 plus how much is this entire number if each element is having of size 2 9 + 2 is 18 so it is 118 right 118 is supposed to be the address for for 21 let's check that if every element is going to take two uh two addresses I I mean two words then if it is starting from 100 let's see what is the total size of it 1002 104 106 108 110 112 14 116 118 isn't it therefore know address this element 2 one the address is uh 118 got it so that is how you could know find out the address or convert the arror differences into the memory main memory elements right so now it can be extend extended even for a of i j let's say I want to refer to the element a of i j when a is um let us say the size of a is M by n which means there are M rows and N columns and now I want to refer the element a of IJ is it visible I want to refer the element a of IJ right in an array a and in this array the size of the array is m byn m rows are there and M columns are there and assume that it is row major order right then how in order to reach this particular element how many rows I should be crossing the number of rows I should be crossing here is equal to I I to cross I rows right which means how many elements in I rows so how many elements will be in each row if there are M by n is the size of a it means that every row contains n elements right there for I have to cross n elements I rows into n this is nothing but total number of elements no in rows or total number of rows in terms of elements I should be Crossing once I cross these many elements in all the rows then I'll reach the required Row in that particular row how many elements I should be Crossing J elements in order to reach the particular element right and now I should multiply with the size so this uh multiplied with size so this will this particular size is nothing but size of each word and then I can add the base got it so this is how you could represent it in terms of uh you know I and J let me write it like this again it is I into n this is nothing but the number of rows I should cross and I into n give me the number of rows I should be I should be Crossing in terms of elements and after Crossing these many rows I'm supposed to cross some more elements in that particular row so how many J elements right and this is nothing but the total number of rows I should be Crossing total number of elements I should be Crossing and if the size of each element is you know let us say size then this is the total number of words I should be Crossing in order to reach that particular element and if the element if this array is starting from some I know base then I add the base so this one will give me starting with some base right if this is where the array is loaded then this entire part is nothing but the address of the array now the same concept can be extended even for the case where indices are not starting with zero indices are starting with one watch it let us say I want to reach the same element here right 2 1 now which will be 32 here right now how can I reach this one in order to reach this in the row major order I have to cross two rows right so how many rows I should be Crossing 3 - 2 which means whatever is the first index that number minus one now The Element 32 right so the number of rows I should be Crossing is 3 - 1 the first index minus one right so which is nothing but two and after reaching that particular Row the number of columns I should be cross the number of know elements I should be Crossing is 2 - 1 therefore here the first index minus one represents the number of rows I should be Crossing and the second index minus one represents the number of elements I should be Crossing within that particular row right so if the same the same formula can be extended even for the case when indices are starting with non zero which is one but then you can directly write it as I - one J J minus one if you write like this the same the same formula can be extended even to this case right so if you don't have if if you have indices starting with zero you can directly write it as i j if you have indices starting with one then you can to write it as i- 1 Jus one and everything else remains same got it okay now this is how row major order Works let's talk about the column major order in column measor order what happens is we are going to store the elements column by column okay uh so the First Column is 0 0 right um 0 0 1 0 and 2 0 and the second column is 0 1 1 1 2 1 and the third column is 0 2 1 2 22 and the fourth column is 03 1 3 and 2 three got it so this is how you could represent all the columns isn't it so this is column number one this is column number two column number three and column number four right so now in order to access an element let us say I want to access the element again a21 so if I had to access the element a21 then how how going to access it first you have to cross some particular number of columns and then reach the particular column in which the element is present and after reaching that column you have to reach that particular number of element that particular element right so watch it watch this first of all you have to reach how many columns you should be Crossing in order to reach the element to one I should cross one column right this because it is present in the second column so the uh second index is going to represent how many columns I should be Crossing right therefore I should cross one column right and how many elements will be there in one column that depends on the number of rows if the number of rows here is three then the number of elements I should be Crossing in not to cross one column is three elements and after Crossing these number of elements I'll be reaching the exact column in which this particular element is present which means the second column right and once I reach that exact column how many elements I should be Crossing to reach the element the required element two elements right there four this is the total number of elements I should be Crossing in order to reach the required element right and if the size of each element is you know s let us say size of each element is 2 bytes right and if the memory is loaded from 100 then this is the address of this one right so how much is this it is uh 3 + 1 is 4 3 into 1 is uh sorry 3 3 + 2 5 it is 110 okay now check it so if the address is loaded with 100 if the array is loaded from 100 and if the first address first index is uh you know uh every element is two bytes or two wordss then where is this 2 one going to be loaded this is 100 this is 102 104 106 108 110 watch it so 21 is loaded at the address 110 you got it right so that formula works then okay in exam also you can do the same thing you can write it write them all down and then given the options you can directly check them if you don't know how to write it you can check in the options and you can get it also right so now let's see a of a let us say a is an array of size M by n right and I want to access the element a of I then how can I reach it you have to first in in case of column major order you have to cross these many columns how many columns J columns you have to cross J columns and what is the number of elements in each column that depends on the number of rows how many number of rows are there m rows therefore in order to cross J columns you have to cross these many elements J into M elements then you will reach the particular column in which your element is present after reaching it you have to even cross some number of elements to reach the particular element right so how can I cross it by adding I now this entire number is nothing but the number of elements you should be Crossing in order to reach the element a of IJ right in case if each element is of size s then this is the total number of bytes I should be Crossing in order to reach some particular element right and then you have to add the base then what is the base here let us say base is B this is the address of this element got it so this is the total number of elements I should be Crossing and this is the total number of words I should be Crossing and since the it is going to be loaded at some base B this is the total total address so in case if you are applying this for you know indices starting from one in place of J you have to write J minus one in place of I you have to write i- one you need not byart it you can just you know derive it on the go all right so this is how row measure and column measure order works so why is it so important that you should understand this low major and column major order is if you know whether your array is stored in row major or column major order then you can write your program in such a way that your program will make take advantage of this you know representation I'll tell you how about how does it work okay now this is the uh sizes or the formulas which are given in decimal now how to get the address in binary so this is somewhat difficult and um okay I want you to pay full attention here whatever I'm going to teach you is not that easy to understand I'll try to make it as simple as possible but then you please focus on this okay uh so writing the addresses in binary and decimal is straightforward but when when I try to convert the same addresses into binary then it is going to be bit tough in a sense okay uh so let's talk about this what is the address of a particular element i j in when the indices are starting from zeros so most of the cases our computers are going to have indices starting from zeros because the main memory is also starting with zero so it is natural to have indices starting from zeros so I'm going to take here assume that the indices are starting with zero then uh what is this see in order to get into a of i j right where a is a m by an array the indes are starting with you know zero then I told you that it is I into n + J into s where s is size of the element and plus base is anywhere there okay so this is the formula fine now I I want to write this entire address in binary that is what I want to get okay then now one thing you should understand is uh in computer science generally everything will be in the power of two so even the let us assume that even the array sizes are also given in power powers of two in case if the array size is also a power of two okay what is n here n is the number of columns remember so a is an M byn array which means n is the number of columns let us say let us say then what is the relationship between between J and N if n is the number of columns you can clearly understand one thing uh the relationship between J and N is 1 is sorry 0 is less than or equal to J is less than or equal to n minus 1 which means J will be definitely less than n right so the relationship between J and N is J will be less than n right now assume that N is a power of two and assume that n is 2 power K right what does it mean the number of columns we have is equal to 2^ K are following it the number of columns we have is 2^ K right and then now if J is a number less than 2^ K okay see J is a number less than n and I'm assuming that assuming that N is a Power of Two And if J is a number less than 2^ k then how many bits will be required in order to represent J the number of bits that will be required to represent J will be definitely less than or equal to K isn't it if any number is less than C if any number J J is less than n and n = to 2^ K what does it implies this implies that J is less than 2^ K right now what does it mean in order to represent J in binary we need less than or equal to K number of bits isn't it the number of bits which are used to represent J will be less than or equal to K keep that in mind okay now and you can even assume that the number of rows m is some 2 power L right then what happens then I is also less than 2 power L therefore the number of bits required to represent I will be L right so now uh you can write it like this I into 2 power k + J isn't it into you can even assume that size of this uh size of the element is also a power of two let us say 2^ X Plus base I'm writing everything in two parts right now what you could do is you could represent this I in binary let us say I have represented this I in binary this is the number I right and when I multiply any number with 2 power K in binary it is nothing but adding K Zer isn't it appending K zos so these are nothing but K Z's which is nothing but I multip with 2^ K and when I add J right I'm going to add J here isn't it and you already know that J is going to take less than or equal to K bits right therefore therefore the entire this entire representation can be represented using I can be represented in L bits and J can be represented in K bits so the total number represented is uh L bits plus K bits and then multiply with 2^ x therefore X bits will be here I don't know whether you understood this or not um okay I I'll even take a numerical example and explain you but anyway just try to focus here one more time see what is it I'm trying to say is okay maybe I'll I'll do it again this is uh not very simple concept to follow but then let's go step by step maybe you might understand it [Music] then okay so I'm talking about row major order H so in row maor order I'm talking about AIG J you already know that in order to reach a i j i have to cross I rows right so if I to cross I rows then how many elements I should cross number of columns I into number of columns is n these many elements I should cross in order to reach the particular row and after reaching particular row I should cross J elements in order to reach that particular element right so this is the total number of elements I should be Crossing and if the size of each element is yes in terms of words this is the total number of words I should be Crossing to reach the element a i j and you know base is B all it now I want to find out the address right so what is that I'm trying to do is now I'm assuming that m is 2^ L and N is 2^ K which means the dimensions are I'm assuming that in in the U dimensions are represented using you know powers of two without loss of generality right and now what about I the I is nothing but the row number row number will generally vary from if you assume that is starting with zeros the row number which means I will vary from less than or equal to 2^ l - 1 isn't it and what about column number the column number will also be less than or equal to you know 2^ K - 1 2^ K - 1 so what do you understand either in order to represent I or to represent J the number of bits required will be less than or equal to l isn't it see what is the maximum number that could be represented using L bits 2^ L minus one isn't it what is the maximum number that can be represented using two bits three what is the maximum number that would represented using three bits 7 right four bits 15 so 2^ L minus 1 is the maximum number that could be represented using L bits right therefore if you are never crossing the maximum number which could be represented using L bits then how many bits are used to represent the number I in worst case L bits right therefore you can represent any number any number I if its range is 0 to 2^ L minus 1 using L bits so L bits are enough to represent a to represent I what about J K bits are enough to represent J isn't it now I'll write this entire address like this the entire add address can be written like this I into 2 power what is n k plus what is J let me leave it as J and let me say the size of the each bite I mean size of each element is 2^ X words right then it is 2^ x + B got it so this is the number of words for each by each element right and now see how many bits are used to represent I in binary L bits so L bits are enough so using L bits I can represent I so I is I is represented using L bits right and now when I is Multiplied with 2^ K right then how many what does it mean whenever any binary number is represented multiplied with 2^ K it is nothing but left shifting this number those many k times right therefore I into 2^ K is nothing but appending it with K bits K bits and all K bits are zeros right so I is nothing but L bits and you know L bit I is represented and this entire number is this one and now I have to add J right so what is adding J adding J is nothing but convert J into a binary number how many bits are required to convert J into binary remember K bits right therefore you can get J which is represented in K bits and you can add it right therefore now this entire number is actually represented using you know k+ L bits isn't it so now this this entire number this entire number this entire number is going to be represented using here there are L bits and here there are K bits right and what is this this is I and this is J so I is nothing but the first index isn't it I is nothing but the row number and R this is nothing but the column number isn't it see if a i j is given I is nothing but the row number and J is nothing but the column number so you can represent row number here and column number here using the L and K right and we got this entire number in how many bits the number of bits required is l+ K bits right and then you have to finally multiply with 2^ X so what is multiplying with 2^ x appending x x number of zeros got it so this is the entire address of this element uh in our uh you know in binary right and finally anyway you can you have one more binary number which is base you convert this base into binary and you can add it right anyway that doesn't make any difference so only important part is this so what did you understand from this in order to represent any in order to get any uh address right you have to do this you have to take the uh you know take the address and then the least significant X bits is going to be the size of the element if the size of the element is four it is going to be two zeros if the size of the element is eight it is going to be three zeros and then in case of row major order you know here it is going to be column number and here it is going to be the row number right depending on how many other bits you you want to represent row and column right so this is how the address can be found out in case of row major order what happens in column major order the same thing right in column major order of same thing in you know you have to have this x number X where X is the size of the uh 2^ X is the size of each element and then here you should have row and here you should have column so why do you think that this way it is followed in row measure order and column major order is you know in row major order we have to cross first rows we have to cross first the rows and then after crossing the rows you are supposed to go into this uh after crossing the rows you are supposed to get into the row which is required and you have to cross the elements to get to that element right that is why row number is here and column number is here by writing row number here this will make sure that you are going to cross all the rows before you get into the desired row and after getting into the desired row you have to cross these many elements right see row and column doesn't mean that you have to put the number of rows and number of columns row and column means that what is the first index and what is the second index in case of column mejor order you are supposed to cross the columns that is why the second index here and then the first index here right so which means see this the instead of putting a row column and column row if you're getting confused you can even put like this so if a of you know IG is required what what I mean to say is this one is the first one this one is the second one right so in case of row major order put the first one here and the second one here in place of column mejor order here put the first one here put the second one here and then the first one here right this can be extended even to three dimensions in case if you have three dimensional array put the first one here second one here third one here and finally the size of the element right so it can be extended to any number right fine so this is how I know you can think of the array elements right so this is all about the row major representation and column major representation um so one thing is why is this important that you should understand all these Concepts is depending on the way in which you have written your program or depending on the way in which the memory is organized in the in the you know two Dimension array is organized in the main memory you can write the programs in such a way that they will take the advantage of this organization see in case if if you think that row major order is used then what happens this entire part will be placed together and then this entire part will be placed together and then this entire part will be placed together right and then let us say the entire part happens to fall in if this is the organization then what happens is in terms of paging the entire row might fall in one page right then you know if you try to load one element or if you try to access one element you will get all these elements in that page therefore you can write your program in such a way that it will make Advantage it will take advantage of this organization and immediately when you when you get one element you can try to access all the elements without any page fault so in case of row major order accessing the elements you know row by row is going to give you less number of page fults in place of column major order accessing the elements column by column is going to give less number of page FS why because whenever you try to load one m in case of row major order the entire row will be loaded in one page therefore if you try to access them row by row only for the first element there will be page fault and for all the remaining elements there will be no page fault got it so whatever the memory organization is you could still write some kind of program which will take the best advantage of it and give the best performance but then once the program is fixed which means once you have written the program and once it is fixed then the performance of the program depends on what kind of organization they have used in case if they have used row major order then the performance will be in one one thing in case of they have changed it to column maor order the performance will change right therefore knowing the organization well ahead and then writing the program will give you better performance than writing the program and then asking it to adopt to the uh you know organization are you getting this see what I'm trying to say is in case of paging if it is row major order there are chances that one row will fall in one page therefore when you get the first element you access all the elements of that row only in case of column major order then there are chances that one column will fall in one page therefore when you get the page for the first rence then you try to access all the elements of the First Column are you understanding it the same thing can be applied even for cache also in case of blocks and whenever you are using this row major order whenever you load you know one block there are chances that the corresponding Elements which are in the entire row will be loaded therefore you write the program in such a way that it will access all the elements row rowwise not the column wise see if you are using row major order and if you're accessing the elements in the column wise what happens is whenever you load any program whenever you load any word uh then the entire row will be loaded then immediately we will be asking for the next column instead of asking the next element in the row that is why depending on the or oranization of the you know uh two dimensional array either row major order or column major order you choose the program but not the other way around which means you don't write the program and then you you don't think that it will give the same performance in all kinds of organizations got it so what I mean to say is either it is row major order or column major order you could still write the programs in such a way that it will run efficiently but then only for one order let us say the given organization is R major order then I'll write the program in such a way that I'll try to access the elements rowwise then that will give the best performance if the program is column major order then I'll try to write the program in such a way that the elements are accessed column wise then that will give the best performance right so once you have fixed up the organization either row major order or column major order then it is up to you to write the correct program got it okay we shall see some questions on that you'll understand it better H so especially in C we shall see how to combine the arrays the concept of two dimensional array and the memory organization along with the blocks then you'll understand what is really going on okay fine now let's see the C program determine whether two array A and B have an element in common right so let's say the name of the function is is common and now we are going to have uh two it is going to take two arrays one is a and other is B it is nothing but you know we are having first argument as a pointer to an integer and second argument as a pointer to an integer generally address to the first element of the array which has to be processed will be passed to this and that will be held in this pointer similarly here also the address to the first element of an array will be passed and that will be held in this pointer right and then Inn inm okay so what is in and inmr they are the sizes of the array a and sizes of the array B generally when we pass strings we don't pass the size of the string the reason is every string is null terminated therefore the the function which is processing it is supposed to find out the size by itself by going to the null but coming to the integer arrays we don't have null terminated you know concept here right so for that reason we are even sending the sizes whenever we send the pointer to the starting of an integer array we also say this and this sides okay in t comma J for I equal to0 I than n i ++ for JAL 0 J less than M j++ now what it means is the logic here is simple let us say the array which is being pointed by a is this and the integer array which is being pointed by B is this okay and the numbers in this array are like this assume that it is 1 2 3 4 5 and the numbers here are like this 10 5 2 4 some six something like this now what we are trying to do is we'll first consider for I equal to0 which means we start indexing this one from zero and we first consider for every element for let us say for zeroth element we'll get into the second second Loop which means we take this element and we get into the second Loop which means we'll start J from here I will be pointing to this indexed into this and J will be used for indexing into this now for this element I'll search the entire array by using J whether this element is equal to any of the elements present here right so for J equal to Z J L than MJ ++ means all the elements here are being searched how they are searched is if a of I is equal to B of J which means I'll check whether this element is equal to any of the elements here right every time I take this element and I'll check with this if it is not equal I'll check with this if it is not equal I'll check with this that is what is going to happen with j++ right the next element is going to be searched now whenever uh let us say we didn't find element number one right and after this complete search is over we come out of this for Loop once we come out of the for loop again we go to j i ++ right now I is going to be the next element which means I is equal to 1 so we take this element and now we start sech searching with all of them again I start searching from the beginning which means I search with J equal to Z this element will be searched with this if it is not equal then this this condition will not execute therefore from here again I increment J next element will be searched next element will be searched let us say this element has been is is now about to be searched when will this hit whenever I = 1 and J = 2 let's see what happens I = 1 and J = 2 now if it checks Compares these two a of I and B of J which means a of 1 and B of two if it checks these two it is going to see that they're actually equal now the question is check whether they have any they have an element in common even if there is one element in common we stop executing the program there and we directly return to the calling function all right the function which is calling this function will go there directly without doing anything see if you look at break by using break we'll be coming out of the enclosing for Loop right by looking at continue we'll we'll not execute the statements which are after the continue but we'll go into the increment or decrement phase but if you have any written statement we directly come out of the entire function we not do anything we stop everything and we go back to the calling function got it now if we didn't go go back from this for Loop which means if this is never hit it means that there is no element common at all then we are going to come out if we have searched all the elements for all elements in a if you have searched all the elements in B and if you are not able to find the common element then we come here and we simply written zero zero means we didn't find anything got it so since the return type as an integer successful is going to return one on failure we are going to return zero got okay in see in the library string Library it has already provided us with lot of functions I'll just tell you what each function here means okay and later we shall see how to implement these functions ourself they are already provided in C you can directly call them just include hash include you know STD uh string.h and then after including it you can use any of these functions in your program now I'll tell you if you include this functions what you can expect later we shall actually Implement them by our own code okay now let's see this St strr c a s comma T concatenate t to the end of s now what it means is let us say we have two strings s is there and T is there all right let us assume that this string s is containing r a v i and at the end there is null is there okay and now string T is containing let us say b a bu U and at the end null is there okay so all these strings in general are null terminated otherwise we don't know where the string is going to end right now we want to concatenate s with t that is the meaning of this St Str c a t STS comma t means Our intention is to concatenate t to the end of s that is what this function is going to do concatenate t to the end of s now after this what is supposed to happen is T will remain as it is but then s is going to change all right so s is going to be r a v i and earlier wherever there was null from that point on it will take T and it will it will append it right which means in place of null now B will be copied and then b a b u everything will be copied and at the end anyway we are going to have null because every string has to be null terminated that is the reason right now St Str c a s comma T will work this way given two pointers these are generally character pointers okay this is a character pointer and this is a character pointer it will take the strings which are pointed by this pointers and then it is going to append appropriately now what will it return is it will return a pointer to the destination destination means in this case we are taking T and appending it to S therefore this this again the starting point this s will be you know returned which means the starting address of this one will be returned okay now if You observe it whenever you are declaring this uh string by using a character array you should remember one thing there should be space inside this character array to hold this otherwise we'll not be able to append it got it so there should be space here otherwise this one cannot be accommodated there right okay and the next one is St strn c a s t comma n it exactly acts like the St Str cat only only differences we are not going to append entire string T2 s we are only going to append concatenate only n characters okay only n characters will be appended to the end of the string now it is Car Star again it is also going to WR the same thing Car Store and St strr CMP s comma T right so if you want to compare two strings right you can use this now how the comparison is done is let us say the first string pointed by S is this and the second string pointed by T is this right let us say the values present here are a b c d and ab let's say CC okay now what it will do is it will for every character here at the same position which means it will take the character from the first position and the here the first position position and it will do the subtraction it will do s minus t right so this character minus this character whenever I subtract one character from the other character the ask values will be taken and the uh result is going to be the difference between those two characters right therefore if I do a minus a it is going to be zero as long as it is zero it is it is going to keep on it will keep on doing it right now again these two will be compared how will it be compared is from this one this character it will decrease it will delete this character this one minus this one again it is going to give zero now again zero now at the end if you see it when it does D minus C it is going to have one because SQ value of this one will be one greater than the SQ value of this one therefore you are going to get one right and at the end anywh there is null here got it so finally when it gets one it is going to return return that value now you say this return negative zero or positive value when when s is less than T when s is less than T we are going to return a negative number right now what will that negative number be this difference right so what do you mean by S is less than T is while comparing I came across a different character at the same positions in S and S and T and the character which is present in s is less than the character which is present in t that means s is less than T right in case if both are equal it is going to return return zero then it is going to return return the difference right if all the characters are equal then going different you know return zero if s is greater than three which means out of all the characters the first character which is different then we are going to compare that and if the if that character present in s is greater than T then a positive number will be returned got it and next one is St RN CMP it is going to act the same way but only difference is instead of comparing all the characters we are going to compare only the first and characters and the next one is St str cpy s comma T it will compare it will it will copy entire T into s okay so what do I mean by copy is let us say you have a string like this r a v i null and let's say one more string b a null okay now if it is given that St str cpy s comma T and if s is pointing to this and if T is pointing to this now what will happen is it will copy the entire T into s starting from the beginning which means this one will be replaced with b and this one will be replaced with a and null will be copied here therefore even though you have other part here that will never be read by anyone because generally when we start reading the strings we we stop it only till the null so that is that is how copying will be done got it and again if You observe it there should be space for this one to copy here if this the Char if the arrrow here is smaller than the this array then there will not be space to copy entirely then it is going to return return null right that is an error condition okay and in next and what will be return by this after copying all this two here the S will be returned I mean the initial the starting address of this array into which it has been copied has will be returned it is nothing but the destination isn't it so every time these functions are going to return the destination address next one is St strr cpy s comma T comma n so it means that we are going to copy n characters from T into s and next one is St l n s written length of s so this is simply going to return the length of the string provided by you yes right and the next one is okay anyway we are going to look into particular D exact details when we Implement them we are going to implement them one by one I'll show you that and the next one is Sr CHR s comma C it Returns the pointer to the first C in s or null if it is not present so it means that let us say you have a string which is RA a v i n d r a okay now if I say Str Str CHR if I pass to it the starting address of this string as the first argument and as the second argument if I pass the character let's say a right then what it will written is in this entire string it will check for the first occurrence of this character right in this case this one and it will return the address of this one right so that will be returned see this return the pointer to the uh first character C in this s right and if I want to see not the first character first occurrence but the last occurrence then you can use the next one St RR CHR s comma C now if I use that it is going to say the L of this right so wherever it has occurred lost that particular address will be returned in case this character if it is not present in this string at all then it is going to return null right if it is present it is going to return return that address okay now let's see this program which is written to reverse the uh string in your library in C library it is already implemented as St Str RV there is a function St Str RV you can actually call this and use to reverse it but then let's see how to reverse a string here how the code is written in that okay now see this one void reverse reverse is the name of the function and it is rning nothing void means nothing and it is taking as one of the argument car s array so it is nothing but pointer to a character right so s you can think of it as if it is a pointer to a character it is as good as defining it as Car Star s okay and now we are including string H because in the function I'm using S Ln that is the reason okay now if You observe it c i and J are you know first initially defined for i = 0 J = Str strr length minus one which means both are you know initialized like that so why is that initialize this way is let us take an example let's say I have a string like this r a v i and at the end let us say there is null okay so I I is equal to 0 let us say this is 0 this is 1 2 3 4 okay now initially I equal to Z means if I use I to subscript in this array it will be pointing to the first character in the array now Jal to S Str Ln minus 1 means if I use S Ln it will return 1 2 3 4 four as the Char four as the length so s or Ln is not going to count the null it is going to only going to return return how many nonnull characters are there in this string therefore s Ln is going to return return a value four and when you do minus one it is going to be three therefore J is going to contain three in this case and if you use it to subscript to this array it will be pointing to the last character which is Nal in this array right it is the first character and is the last character therefore I'm going to start I from here and J from here right and at every point I'm going to check whether I is less than J which means as long as I didn't cross J right I'm going to continue I ++ which means I will be incremented one at a time and J minus minus J will be moved one to the left at a time and once I enter the for Loop what I do is I'll take the character which is present which is pointed by I which is indexed by I so s of I is this character and I'll store into it into C and then I'll take the character which is present here and move it here right and whatever was earlier stored in C let us say in C it is STO R is stored here now that will be moved here so it is nothing but this logic is the spping logic so if you want to understand it simply we are going to take two uh we are going to take two pointers I'm going to start from left and right these two will be swapped first therefore I will be here and R will be here after this fapping is done I'll increment I by 1 and decrement J by 1 which means I is incremented by one and J is decremented by one right again I'll do the swapping logic then what happens is V will come here and a will come here right V will come here and a will come here right now I will be here and J will be here once whenever I decrement I increment I by One and decrement J by one they're actually going to cross over right so whenever they cross I'm going to stop it why this condition is going to fail I is less than J this condition fails therefore I'm going to out of the for Loop okay now let's see a program where we convert a number into a string so let us say we have a number like this 123 right now I want to put it in a string like this one here two here and three here right so I want to take this number and I want to take each digit in this number and I want to put it put it in this string as if it is a character okay so this number is an integer number now I'm going to put it in a array of you know characters okay so now how we could do this one is see simple thing is you take this last one so how how I could obtain the least significant digit of a number is you just take modulous 10 it is going to give you the remainder when I divide this number with 10 when I divide this number with 10 the remainder is going to be three right so you initially take that least significant digit and you place in the character array and then you eliminate this from the integer how can I eliminate it by doing divide by three if I take this number and divide by 3 sorry divide by 10 this is going to be eliminated okay and now take the next least significant digit how I could do it is again by taking modulus 10 then 2 is going to be here right and then you eliminate it by doing divide by 10 therefore it is going to be eliminated and again you take the least significant digit by taking modulus 10 then I'm going to get one all right so now if You observe it if the given number is 123 I got the number here in the array in a reverse order so once you get this reverse order you simply reverse it right so how I can do the reversal is as you have already seen the function that we have written to reverse a string in the earlier example we are going to use the same function here okay now in case if the number would have been a negative number Min - 123 then at the end at the last you you put minus here okay so you just remember that the number is a negative number and then at the end of this you put a minus and now if you reverse it it is going to be minus followed by 1 followed by 2 followed by 3 okay and at the end you just just put a null okay so now let's see how it is going to work see this now assume that this is the this is the function which we are going to write I to a and for this we are passing two parameters one is what is the number you want to convert into a string and the second one is where you want to place the string this is a pointer to the uh that character array right so it is as good as cap St s therefore you can assume that s is a pointer now in I comma sign so why do I need sign variable is I want to find out the sign of the number whether it is a positive number or negative number so that I can do something with it later see this if sin is equal to n less than zero so what does it mean I'm reading whatever number is given into the variable sign the reason is once I keep on modifying the number n later the number will completely be gone so for that reason I'm just storing the number into this variable sign and now I'm checking whether the number is a negative number or not see what does it mean sin equal to n less than 0 means whatever value is present in N I'm putting in sign and now I'm comparing sign with 0o if sign is less than zero it means that the given number is negative number right if if the given number is negative number then I'm going to converted into positive number so see this n = to minus N means if the given number is negative number then I'm taking that number and multiplying with minus1 therefore I'm I'm putting a positive number there right and after that I'll start doing this procedure do i = z i mean i equal to 0 do s of I ++ = to n 10 + you know Z as key value so the reason why we are doing this one is so if I write like this zero it means that it is going to be the asky value of this number all right now if I say the number is three which has to be stored here right now if I write like this it means that the asq value of three will be stored here as you know the ask value of 0 is 48 you need not remember it some value let us assume 48 and then 1 is 49 ask value of 2 is 50 ask value of 3 is 51 now if you want to store the SQ value of three you are supposed to get the ask value of three if you don't remember the SQ value of three then better whatever you you get the SQ value of zero and you simply add three you are going to get this that is why I'm doing this one right so if You observe this statement what we are trying to do is I'm trying to get the least significant digit of the number n and then I'm trying to add it with the SQ value of zero therefore I'll get the SQ value of the least significant digit right once I get this I'm going to store it in the array s right so I'm going to store it in the array which is pointed by S at the index s of I after I do it I'm going to go to the next location and wait there right now once you are done so when will you be coming out of this while loop is while n divided by see this so after every step n divided by equal to 10 which means this step is nothing but n = n by 10 so if you see this I have taken the least significant digit and if you see this step after that I'm eliminating the least significant digit by doing so if the number becomes zero then it means that we need not continue further the entire number has been already passed right so here if it is greater than zero then I'll have to again go into this and do it so the reason why we have written do while instead of writing while is we have to enter this loop at least once because the number in worst case will will at least be zero right in the case you'll have to take that zero and place it in the string and then come out of it if it is not a zero you keep on take deleting the digits from by one till it becomes zero right so once it becomes zero you can come out of it okay finally let us say you have taken the entire number and you have stored it in this string right so this is what is happened right and now you just check the sign in case if the sign is less than zero which means if the given number sign is nothing but given number is less than zero then it means that is negative number then we are simply going to put minus here this is the step okay now after this everything is done I'm going to append null to the end of the string got it now once this is done this entire number has to be reversed right because the given number is- 123 but here what we got is 3 2 1 minus now if I reverse it I get the actual output which is required now you just call the reverse reverse office we have seen it earlier reverse with s if you send it then it is simply going to reverse this string got it and now if you you know uh you can leave it there anyway s is going to point here right or if you want to return some pointer you can return it here we are not wring anything vo okay in case if you want to return s you can return that okay now let's see this uh function a to I ask you to integer I mean a to I is not ask you to integer this is a function name and it is used to convert a string given string into an integer number so what I mean to say is if you have a character array and a number is given in this character array like this 1 2 3 right and then null so this is actually an array not a number now if you if I say uh this is a character array and if I have to use this number I'll not be able to use it right what I mean to say is if you say in I equal to 123 okay this is different and this is different right now I have to convert this string present here into a number that is equation so how to do that is we are going to use this function again this a toi function is already present in the C library so you can use it now we are going to implement it on our one so the first thing is the parameter is going to take is the argument is going to take is r s and then this s symbol it is nothing but uh s is defined as a pointer to the character and the return type of this one is int now in I comma n n = 0 for I equal to 0 S of I greater than or equal to 0 and S of I less than or equal to 9 I ++ so what is that for Loop is going to do is it is going to start from here is going to start from beginning right and it is going to check whether the given character present here is between the characters 0 and 9 see even though when I'm even though I'm saying that one is present here in this cell it is not ex exactly one it is actually ask key value of one will be present here if this is a character array then every cell indicates a character and inside a character whenever I say this one it is actually asking number of one which means in place of one what you have is actually 49 the bit pattern which is used to represent 49 will be present here when you interpret it as a character it will be one right so what I mean to say is this if I say car c equal to let's say zero right and if you say print F percentile d m percent C then what will be printed is let us say percentile C percentile DC right now what will be printed is in C the bit pattern that will be represented is equal to the ask code of zero asq code of 0 is 48 now here you are trying to print the values or the bits present in this character c as a decimal number when you convert the bit patterns present in this C into a decimal number what you are going to get printed is 48 right if you want to print it as a character then you have to C you know you have to say percentile C then you are going to get it as character okay fine so whatever it is uh in a string even though you want to store Z One the actual number stored there will be the bit pattern of 49 right now let's see this first thing is we are checking whether the uh given character in this place in the zeroth place is between 0 and 9 or not right then only we are going to uh start conversion if it is not between 0 and 9 if it is some other character it is not actually representing a number at all okay now in case if it is a number between 0 and 9 if the characters are between 0 and 9 then I'll take the character and I'll subtract it from the asq value of Zer so what is the act SQ value present here 49 now if I write like this it means that it represents the SQ value of 0 now SQ value of 0 is 48 right so if you see this the 0 1 2 3 4 5 the SQ values of these are 48 49 50 51 like this you need not remember these SQ values right now if I want to convert the SQ value into the actual number one then you take the SQ value of one and then from that you are going to subtract the SQ value of zero this one if I do 49 - 48 it is going to be 1 so that is how you are going to get one so that is what we are going to do here s of I minus 0 so if I do this it is going to give you 1 here in case if the character present is one now I'll take that and initially n is initialized to 0 I'll multiply 10 with 0 it will be 0 0 + 1 is one therefore for the first character which is one here we are going to see in the output one first I mean we are going to see that n is going to contain one again we come here and then again we do it if again we check whether the next one I ++ means the next one is again falling between this range in case if it is falling between this range find out what is the value represented by this so even though 2 is represented as ask value 50 I'll take this and I'll subtract from this then I'm going to get a value two then I multiply it with 10 and again I add two that is what is being done right whatever the value of n is formed that is Multiplied with 10 and we are going to add the next value so which is two now this is going to be 12 right and the next one is again 51 right so so let us say 1 2 3 is present so whenever I is I ++ is done we are going to point to this again we check that is present between these two yes if it is present between 0 and 9 then again I'm going to find out its value so 0 3 51 - 48 which is 3 - 0 means 51 - 48 it is going to give you 3 then I'm going to multiply the N so formed so far formed with 10 and then I'm going to add three so it is going to be 123 so finally you are going to get 123 next time when you increment Ty ++ you are going to point to null and when you check if null is present between 0 and 9 this condition will fail right so this condition is going to fail whenever this condition fails we are going to come out of the for Loop once we come out of the for Loop we are simply going to return the value of n so what will be return 123 is return returned right so we are going to take take as input a pointer to the character and we are going to return you know an integer value so what will be written here 123 okay now let's see this program write a c program to remove all the occurrences of a character C from a string so what it means is if you have a string like this which is a character array let us assume that it is having characters a b CB DB like this and now I want to remove a particular character from it let us say I want to remove the character B now after removing B this entire string or this you know array character array should get transformed to something like this a c d null this is how it is supposed to get transformed into right so that is that is how we should write this function as even though the it is given as a program you cannot execute it unless you have main so if you want to execute it you can add Main and then execute it so let's see this uh function as it is now this function is going to take or I'll just explain the logic first so what we do is we shall start with two pointers or two indices you can call them now both of them will be starting with the beginning right and whenever we get a character which has to be replaced one of them is going to stop there right and the other one will go and search for the next character which is useful right whenever we see the useless character that has to be deleted we are going to stop there and useful character we are going to whenever we see that useful character we we copy it here right like this okay and then this one is going to be incremented like that okay so we shall see the logic and we'll understand it better so first thing is vo it is not wring anything and squeeze is the name of the function and one of the argument is car s array so it is nothing but uh declaring S as a character point pointer got it so car this this way of Declaration is nothing but declaring or declaring S as a character pointer in fact is a definition as well which means s is a variable and it is created in the it Space Storage is allocated for S and now in C so as the second argument we are passing an integer value which is nothing but the asq value of the character that we want to replace okay in I IA J for i = j = 0 s s of I not equal to null I ++ so initially we'll initialize I and J to zero in case if you use I and J to Index this array it means that both of them are going to point to the same value here these are the indices okay let's say six now both of them are initialized to zero and I'll check check whether s of I is equal to null or not which means whether we have reached the end of the string or not in case if we have not reached the end of the string then I'll I'll execute this statement if s of I is not equal to C which means I'll see whether this particular character has to be deleted or not right in case if it is not if it if it is not to be deleted right yes it should not be deleted then in this case it is doing s of j++ equal to I so if you have to understand this statement it means that first use the value of J and store into s of J whatever value you want to store in this case s of I and after that is over you increment the value of J so in this case when I I equal to Z J equal to Z it means that it is as good as writing this way right s of J is equal to S of I and after this is done j++ so this is as good as writing it this way if you're not able to understand it that way anyway we have seen how the post increment is going to work the value of J will be used yes the value of J is used and after that incrementation is done right okay now see this what will happen here simply s of J which means s of0 will be equal to S of again I is also zero so nothing is going to happen there right but then J is going to be incremented so J is going to the next one right and we come out of the for Loop for Loop has only these two statements we come out of the for Loop which means the body of the for Loop is over again we go into the condition here I ++ I will be incremented so I is going to be here right and again we get into this for Loop Body by because s of I is not equal to null and now I'll check whether s of I is not equal to C which means whether should I replace this C or not so is s of I equal to C so if you see this of I it is it is equal to the character that has to be deleted isn't it C is the character that has to be deleted ask value is same now we are going to we are going to come out of it because it is not equal and again I'll come out of the body and I do I ++ therefore I is going to be incremented now if You observe it what has happened is clearly we have found out the character that has to be deleted and J will be pointing to it and now I is incremented in such a way that it will find a useful character and once it finds a useful character next time this character will be replaced with this character that is the logic behind it okay now see this now what happened i++ has been done right and again we enter it s s of I is not equal to null and now I'll check whether this is useful character or not I is pointing a useful character isn't it in case if it is pointing the useful ful character then you then you copy this useful character into this useful useless place right so which means this useless character will be replaced by useful character C after doing this replacement J will be incremented J will be incremented and now what will happen to I again we come here and I will be incremented right now again I'll test whether of I is equal to null or not whether we have reached the end or not yes we have not yet reached the end therefore again I'll enter it and I'll check whether I is pointing to a useless character right yes I is not pointing to a useless character right s of I is not equal to C yes s of I is not equal to C isn't it what is C here if you're getting confused I'm writing this right just check whether s of I is not equal to B but s of I is equal to B therefore we are not going to enter it and again I'm going to do I ++ therefore I will be incremented so I will be here all right and again I'll check whether s of I is not equal to null or not as s of I is not equal to null and again I'll get into this and I'll check whether s of I is not equal to B yes s of I is not equal to B right why because it is not useless character now in that case s ofi if it is not equal to B now I'll just copy whatever is pointed in this I into J so whatever is present here it will be copied here okay and after that J is incremented which means J is going to point to this right and after this I is going to be incremented so I is going to point to this now again we we'll see if s of I is equal to null or not it is not equal to again we'll see s of I is not equal to B but it is equal to B it will not get executed again I'll go here right I ++ now finally I is again incremented right so and again I'll test whether s of I is not equal to null yes s of I is not equal to sorry s of I is in this case is equal to null therefore we come out of the for Loop completely after coming out of the for Loop now s of J is equal to null which means this one is made null right therefore the string is containing only a c d null even though we have other characters here we generally read only till the null therefore the string is supposed to be terminated here all right so if You observe it clearly initial string is a CB DB now after replacing this B BB whatever is remaining only a c d is remaining and after that null is there got it okay now let's see this function in main resistance in I = to 10 in St AAL to M percen print F percentile D star a return zero now if You observe it we are we are using the storage class so resistor and intern I mean sorry resist extern and the other one is static these are called as storage classes okay so register is a keyword which is called as a storus class when it is applied while defining a variable it means that we are telling the compiler to to store this variable in the resistor okay now if that is let us say some compilers will follow your advice and they will store the you know integer not in the uh you know activation record it will store it let us say in a resistor now once you have stored the i in a resistor when you try to get the address of I you are actually asking the address of a resistor generally memory elements will have the addresses but resistors might not have the addresses now you are trying to find find out the address of the resistor and you are trying to put it in the variable a right but this is the problem isn't it so some compilers might have already stored the variable in a resistor and they will not be able to get out the address of a resistor and so some compilers might give error and some compilers might give warning okay so it is compiler dependent and you are not supposed to write the program like this some of them might execute it some of them might give warnings and the other one is let's see the next one similar type now in I so it means that I is created inside the activation record and so it is going to have an address let us say the address that I has is M and this is the activation record created for main inside this tag and since I is an automatic or local variable it will be created inside this tag and so it is going to have some address now we are going to have one more you know variable which is a poter to an integer whose storage class is given as resistor right which means we are telling the compiler to store the value the to store the variable y in the resistor and not here right now depending on the compiler it might either take your advice or it might not take the advice if it takes your advice it is going to store it in the resistor otherwise it is going to store this variable in the uh you know uh activation record of the main now it is going to act accept the address of I now what is the address of I 100 so if it is going to be stored in the activation record in the memory 100 will be accepted or if it is stored in the resistor let us say in the inside the resistor you know a is stored this is the resistor 100 will be there so either a will the a will be in the resistor or in here so whatever it is a is having some storage and it is capable of holding the value that you are trying to store there now print of percentile D store a means whatever value is present in a that is the address of other V variable you go to that address and you print the value which is present there let us say here the value present is one then in this case one will be printed got it so here you will not face any problem right because you are not asking for the address of the variable which has to be stored in the registor in fact you are storing the address of other variable inside a variable which is either stored in the register or here okay now let's look at this problem prr now in Main in I equal to 10 resistor static in I equal to 10 now static is a storage class resistor is a storage class now by saying static you are explicitly asking the compiler to store this variable in the you know data section Now by putting resistor you are again asking it to store it in the resistor so you asking you to store it at two places you cannot say that right so this one will give you compiler error okay fine now let's say an example where I want to call a function and then I want to call it many times and after it is done I want to count number of times I have called it right so let us say example is here now int count function call so this is the function which I'll be calling many times and then later I want to find out how many times I have called it exactly right so in count function called void it is not going to take anything but it is going to return int int count equal to Z so initially we have a local variable which is going to be initialized to zero and the only purpose of this function is it will simply increment the count and it will keep on sending us okay now see this now in main we have called the function once so this function is called once and then this function is called second time and then the function is called third time so three times it has been called and fourth time I'm again calling it and see whenever you're calling the function the function is actually wring something but then we are not catching it in any variable that is perfectly legal you need not catch it in any variable you can leave it and print F percentile D you know percentile D times function is called count function call that is it so return zero now if You observe it what we can do here is you know what is done here is initially in this stack main will be done right this is the letter us say activation record for the main now what are the local variables of uh this main there are no local variables right so what will generally this activation record contain is one is all the local variables as well as the written address which means from here if it goes to any function call once it comes back what is the address it should you know it should execute that is also going to be present there now let me write for you know just for the sake of Simply let us say the address of this one is 1 2 3 4 something like this so now first uh this one will be called now when you call this function activation record will be created for this function right now what is activation record here it is for count function called let us say this is the activation record for this one now what will happen here is in this function whatever are the local variables they all will be created here so the local variable is given a copy here count got it now count is initialized to zero in case if you don't initialize it to zero what happens is always the local variables will have uh garbage value right and the global variables and static variables will always be initialized to zeros okay so now here since you are you have not initial I mean you have initialized it it is going to get in zero and then it is going to increment it right Plus+ count me increment it and it is going to return that number right so it is going to return whatever is incremented so what will be returned one will be return but you're not catching it here now this is over so once this function is over this acation record will be completely popped off and from the next line your main is going to execute right so the main is again going to call the same function then again one more activation record will be created for the same one right and now one more copy fresh copy of the variable count will be created and that count will be given a value zero and count Plus+ means it will be incremented by one right and it is done got it now once it is done again this this value will be popped off right and again you are going to call it third time now when you're are going to call it third time again the same thing is going to happen right so one more copy of count is going to be created and its value will be zero and when you increment it its value is going to be you know one and again this is going to be over now again you are calling it one more time here right printer will be called which means for printer also activation record will be done and printer is going to call you know count so again count is going to will be done here and which is going to contain its own copy right fresh copy will be created it will be initially zero and it will be incremented by one and once it is done it is over right so what will be return by this one so it will be return to the printf and printf is going to print you know percenti if You observe it printf is also a function call that is why one activation record is created for print f as well right now print of this is going to print that you know one time so person d means whatever it has written it has written simply one therefore it is going to print one times function is called right one times the function is called that is what is going to be printed even though we have counted you know we have called it four times finally we are going to get the answer as one time it is called why did this happen is if you see this count it is not uh it is not able to retain the value every time it is going to create a new copy and that new copy is actually used right so that is why it is not able to retain the value if it has to retain the value it is better that you declare it as some other variable right instead of automatic or local variable let us say we want to make it static variable right so if I make it static then what happens is instead of creating the count here it will be and static variables and Global variables will already be initialized to Z you need not initialize it right now it will be created in the data part it will not be created in this stag it will be created in the data section right in the data section count will be created and initially when you make when you do Plus+ zero will be made one and for the second call this one will be made two which means there will be no local variable it will be accessing this static variable and the third time this two will be made three and the fourth time this three will be made four and four will be return and four will be printed got it so by using this static storage class we are able to return return this variable because we are creating the copy or we allocating the memory for this variable in the data section and not in the you know uh stack got it okay now till now we have seen variables which are which are getting space allocated at various uh uh places in the process now you know we have seen something like this if this is a process resume that this is a process let us say this is text text section and then there is data section in which global variables and static variables are going to be uh allocated space here right and now automatic variables or internal variables which means the local variables will be allocated space in the stack right and the stack grows like this now there is one more part called as Heap right so exactly how how big is Heap that depends on whether stack takes up more space or heaps takes up more space now this Heap is used for this is the space right and now this Heap is used for dynamically created data structures sometimes you wish to create some variables dynamically and then you want to use it so what are the various reasons for them to be created dynamically is one is maybe before starting the program you don't know how much space is required in that case we cannot have the arrays that is why we go with dynamic memory allocation techniques and other other thing is you might not need that uh you know variable throughout the execution of the program and also you don't know the size in that case also you go with the dynamically allocated memory and once you are done with the uses you'll be freeing it up right so now what I mean to say is uh either local variables or Global variables you need not do anything specially to create the space for them but then for the dynamically created variables or the data structures you are supposed to create this space right so how how is that space creation is space is allocated and how to manage that is by using these functions right and these functions mloc COC and real looc so these functions are actually defined in the uh you know STD Li standard Library STD Li uh and then if you're going to use these functions uh without declaring them you better include the file Hash Hash include stdlib.h okay now let's see what is the how each one is used and what is it trying to solve now if you see this mloc size t n y star now it means that this is name of the function okay this is the name of the function now we are send sending to it as a parameter a a variable or a a number which is unsigned whose size is at least 16 bits now what is size uncore T is it stands for any data type which is unsigned and whose size is at least 16 bits okay now you can also send an integer now if I say mlog 10 then what will it give is if I say mlog 10 then it is going to allocate in the Heap a size of 10 bytes okay and now it is going to give you the pointer which means the starting address of this space is going to be returned now if you look at the return return type it is return returned as wi star which means you can use it to store any data type therefore depending on what data types you are planning on storing there you can just uh you know uh do the type casting and then you can store it there for example if I write like this in Star I then I equal to mloc size of let's say int okay size of is an operator which is going to return uh any you know a variable of type or which is going to return a number which is a positive and which is going to take at least 16 bits which means of this type siore T now it is going to give you the size of the int let us say the size of the INT in your machion is two now what does mlog do it will create two bytes of two bytes in the hip two by space in hip and now let us say the address of the first bite is 100 now 100 will be returned therefore what is return to you you are going to get a pointer right see this one is nothing but the address now the address type actually written here is a void star isn't it void pointer but then actually you are going to store in it an integer and later you want to access this space as a integer right that is why you just use the type casting and you convert it into integer Star right integer pointer and you store it here now why is this thing important is later when you try to access you know the elements in this now the elements in this will be aous blocks of zeros and ones now how to interpret it whether to interpret it as a character or an integer that depends on how you have declared here and how you are you know going to access here right so if I say i++ see why is it important is you will understand here if I say i++ now should I increment the I by either two bytes or one by or four bytes depend on what is the size of I is and that depends on what is the uh you know pointer that you have used here whether it is an integer pointer or a character pointer if it's a character pointer it means that all the elements present here are characters and when I do i++ it has to be incremented by only one if it is an integer right let's say if it integer everything has to be incremented by two in case if the integer size is two right therefore uh declaring some pointer and then converting this written type is important and also if You observe it it is going to give you this pointer of the address of the first bite of the you know memory dedicated or allocated to you and in case if it is not able to allocate the memory let's say because the Heap is out of space which means there is no space in the Heap that is why it is not able to allocate the memory in that case what it will written is simply null got it so that is why after you use this mlog you are supposed to check what it has return returned in case if it has written null then you should not go and access or you should not store anything at at that pointer got it and the next one is cog now Cog is exactly similar to mlog but here we are going to say uh the size in a different way right so here you have directly given the size that you wanted but here you are going to say how much space you want to allocate in a different way now you are going to say uh how many elements that you want to store and what is the each size of each element that you want to store there right for example example if I say 2 comma 2 it means that I want to store in this space two elements each of size two therefore totally you are asking for four bytes got it if I say 10 comma 2 now it means that I want to store in this space 10 elements and the size of each element is 2 bytes therefore you want 20 bytes right so this is one other way of specifying what you want to I how many bytes you want got it now what is the main difference between mlock and cck is if you use COC it is going to create the space and it is going to give you the pointer to the starting atos of the space along with that it is going to initialize all the you know all that space to zero which means if you look at mlog garbage values will be present there if you don't initialize it explicitly but if you look at C loog it will give you this space as well as it will initialize the entire space to zeros before it give you that is the difference got it and again the same thing it is going to give you the pointer which is nothing but the address of the starting bite in the space allocated right and one more thing either mlock or C loock will always give you the space in a contous manner in case in case if the space is not present in one contous block it is not going to give you the space right let us say you want 20 bytes uh and assume that 10 bytes is free here and 10 bytes is free here it is not going to give you these two block these two blocks it will it will actually give you 20 blocks if 20 bytes if available or it will not say or it will just simply give null which means memory is not available got it okay now again if you are going to use C lock you have to do the type casting as as I told you here so either you want to convert it to you want to store it in end pointer or C pointer depending on that and the next one is reoc real looc means let us say already you have been allocated some space assume that already you have been allocated some space which is 10 bytes okay using mloc and now you have already used it and you have filled it with some values let us say all the values of data is filled now you want to extend it okay you want to change the size of it to 20 bytes then what you can do is void real lo you just send the pointer which is pointing to the starting address of it to this function along with that you just specify what is this size you want that you know space to grow let us say initially it is 10 bytes now you want it to grow to 20 bytes then you can say that I want to grow it to 20 right then what will your uh this what will happen here is it will try to expand it to 20 bytes in case if the space is is freely available here otherwise at some other location it will create 20 bytes and it will copy the initial 10 bytes into this without losing the information got it so that is what is going to be done with real lock if it is not able to find that much space it will simply return return null right and next one is free now free is used to uh free up the space once you are done using with using this right let us say you have got some space using mloc and and you have done you are done with the uses then you can you can simply say free that space right free with that pointer if you call it then it is going to free the space which is which is earlier allocated to you now one thing is I know one problem here is how will free know see what does this PTR contain the starting address of the space that that has to be freed up isn't it now how will your free this free function know uh where till what point it has to free up all right so just to answer that now either while using ml lock or C lock let us say you want to create 10 bytes then instead of creating 10 bytes actually one more location which means 11 bytes or it is system dependent right some extra space will be created for you and in this extra space which is allocated it is going to store how many bytes has been allocated for this you know when you call this ml later free will read that information and free will only free those many byes initially allocated got it so that is how free is going to be useful now if you don't free up this space regularly what happens is uh even if you're not using using a space that space will still be reserved for you and it will not be given it will not be reused later right that is called as memory leak problem to avoid memory leak problem you are going to use free okay it is a kind of garbage collection okay let's not look at that garbage collection now you can understand that it is just used to free up the space which has been allocated earlier right sometimes it so happens that we might have to group uh things of different types like in arrays if you see an array an array is a group of you know more than one element isn't it if I have integers let us say I want a group of 10 integers to be together then I could return I could write a array of 10 integers but sometimes it so happens that the group of elements or the elements which I want to keep in one group organized in one group might not be of same type right then in that case structures are going to be very very useful so structures are going to be a kind of grouping I mean if you want to group different elements we are going to use structure it is uh you know you can think of it this way this way the classic example is you know if you want to store an employee record so if you want to store everything about an employee he will have a name so therefore we need a string which is a character array and he will have an A and maybe uh he will have a salary right so and he will have an address so there are various things that he might have therefore I want to put all these parameters in just one place and I want to give it one name and I want to keep it together right uh that will so that it will be meaningful for me to watch rather than declaring various types of data structures and keeping them at various places and then organizing with different names if I have them at one place it will be better right so and for this reason we have a special uh you know data structure which is called as struct structures right so the way we declare struct is like this let us say I want to put together a character and an integer I want to put them together tightly okay then what I do is I'll Define some something like this struct okay in I let's say and car c right so this is the Declaration which means just like int see just like int it is also a declaration of a data structure now we could create any variables of this data structure just just like int so you know this right so I could create integer data integer you know variables like this int X comma y comma Z isn't it similarly just like this I could even create X comma y comma Z so what happens is because of this definition there will be three structures created with the name X Y and Z right so what will these three structures will have is X will now X is now a structure which will have inside it an integer with name I and a character with name c similarly Y is now a structure which will have two elements one will have name I and other will have name c and Z is now a structure which will have two variables one is integer and other is character C right so this is how you can visualize it so this entire part see this name the name struct followed by the open brace and then Clos brace this closed curly brace or the right right brace and inside this there are there are a you know list of declarations now this entire thing will Define a structure now this definition right which means writing like this is going to create three uh VAR three structures and three structures will have all these members right and now you can access any member using the member operator for example if you want to write something in this then you can call it like this x do I = to 10 then this will be written or X do c equal to a then a will be written here got it so this is how you could access so every structure is going to have uh you know some some members inside it these are called as structure members right and in order to access it I'm going to use the dot this is called as member operator member operator so member operator is used as a connection between structure name and the structure member why should you use it is uh because without using the structure member If You observe it see I is there in three places right integer I is there in three places now whenever you refer to I which I are you referring to so just to distinguish it you you are even supposed to have the name of the structure followed by a DOT followed by the member name right and now let us say you after writing this you know at some point of time or later if you want to if you want to do any again this kind of Declaration let us say you want to declare another variable or you got to Define another variable of type this structure then again you have to write this entire thing and then know write this isn't it or let us say you want to define a structure which contains a structure then what happens now you have to Define see let us say you have to Define one more structure struct which contains inside it this entire structure then what should I write I should again write struct and then I should write no int C and I know like this so this entire writing this is you know going to be tedious therefore what I try to do is we shall write a name for this structure which is actually optional you need not write it but then it helps if you write a name let us say struct uh let us say example ex struct ex so if I write struct es ex followed by this curly braces then this is called as a tag okay this is called as a tag this particular thing right now having a tag is is you know is going to be useful because later when you when you try to refer this or later if you try to you know um declare any other variable you can simply use struct followed by tag or I'll tell you this see this you need not declare all the variables here what you could do is you could just declare the structure if I write like this what happens is this is called as template right template or blueprint so by writing like this I'm just trying to declare that this structure is having this this form and this one is going to be the tag right by writing like this no memory is actually created to any variable later the advantage is I can write like this struct I can Define structures using this tag without writing everything now I can write example x y z Now by writing this declaration and then by using this this kind of definition what happens is now x y and Zed are the three variables I the three structures for which actual memory will be allocated so by writing like this it will be useful to use the shortcut like this okay you need not use the entire you know declarations again so this is just a kind of shortcut okay and anyway here no memory is allocated that is why it is called as a blueprint or you know prototype and this one is uh this one is actually definition where space will be allocated got it and again you can access the members like this so anywh the tag is optional okay and now let us say you want to declare a nested structure then what happens is you can directly use the tag and you can declare it see this now I'm writing one more tag struct example one okay this is again the tag and I'm declaring all the members of it the members of a structure can even be other structures let us say the member of this is struct this one and you know a okay before going to this let's talk about how to initialize them directly sometimes what happens is you can even initialize them directly so you need not uh let us say I want to declare Define a structure X and even I want to initialize it then initializing is simple you can write like this and first member is you know integer okay see now structure example is this one first member is integer and second member is character now I'm going to write structure example and in this I'm going to Define a variable which is a which is of typee structure which contains these two variables inside and so I'm going to initialize them like this so first one is integer and second one is character so this is called as initialization so you can even initialize it like that now I'm trying to declare uh one more structure which contains as members the structure of other type right then struct example one it contains two members A and B okay by writing like this this is again a declaration just a prototype no memory will be actually allocated it is saying that example one is a structure which contains inside it two structures both are of type example only right then what happens is you can create a variable for this next time see now I can create a structure of type X1 example one uh let us say the name is t right then what happens is a structure will be created which contains T and inside that there will be two structures right so one is a and other is B and inside a there will be I and there will be C right and inside B there will be I and there will be C now how to access each one is watch it now a is a member of T therefore to first you have to access a so T do a and now if you have to access I then T do a do I so if I write T do a do I equal to 10 it means that this value will be taken as 10 right or you can write T do a do c which means this one t do a means this one and a do c means this one t do a equal to small a then you can go here right so like this you can Define any number any levels of nesting right this is called as nested structures right uh so this is how you can you know you can declare the structures and then you can declare the variables and maybe you can access them using the member members all it fine I I formed this question combining this structures arrays pointers and uh yes this access members I mean access uh this operators like Dot and um this okay so anyway uh if you can answer this question you'll be able to answer any question in Gate you know combine questions combining structures and pointers that way I formed it and it is not very easy to understand but you know what I suggest you is you please uh if you don't understand anything you please rewind the video and watch it over and again okay so before going ahead uh before solving this uh difficult question I'll just take some few small examples and we shall we shall practice on that we shall understand the concept then we shall solve this one okay so before solving this let's solve some small questions see this now let us say I have a structure okay let me call it as node some structure okay and in this I have two members this is the tag this is the structure this is the tag and I'm writing and I'm declaring the members inside it I have two members in I and in J these two are integer members right and this is how I Define the structure all right so this is called declaration and or prototype or template what ever but then no memory will be allocated to this right and now I'll try to declare uh this is called definition okay so definition is where when see declaration generally memory will not be allocated but definition is where memory will be allocated coming to structures okay so struct node let us say a is a structure and P is a pointer okay so what is the meaning of this so I think you remember how we associate you know the presidence so a is nothing but the structure node a a structure of type node right so that is a a is a structure of type node and what is p p is a pointer okay so p is a pointer which points to a structure of type node that is the meaning of it now whenever I write like this what happens is like you know a a structure will be created it is better you visualize the structure like this inside the structure see I'm just visualizing it actually memory what happens is in the contous array of cells you know integer I will be created and integer J will be created okay fine so this is what happens in reality but what I'm trying to do is I'm trying to visualize it in a different way okay this is what is what happens in reality okay so you just visualize the structure like this because it helps me later on for you to you know explain explain many things I and J let's visualize like this right and now H so this is a and whenever I declare p p is simply a pointer that's it so p is nothing but a pointer nothing more right so both are this is UN uninitialized and this is uninitialized and they are not containing anything right and now if I say p equal to m% of a right it means that you take the address of a and you put it in p and you can do it because p is a pointer which is capable of holding an address to a structure of type node and a is a structure of type node isn't it P is already a pointer to a structure of type node and a is a structure of type node therefore I can put the address of a in P so this particular move is going to take the address let us say address of this one is 100 starting address is 100 now 100 will be kept here which is nothing but P will be pointing to this got it now if I have to access I how can I access I is one thing is directly I can say I can write like this a do I isn't it a do I is nothing but a is the structure and then I this is the access operator is member member operator therefore I can access I fine if I want to use p and access I that is bit tricky see this now if I want to use p and access I see one way of accessing is a do I fine it works and now if I want to access this I using p then what I'll try to do is uh if I use the name p see this if I use the name p right it is nothing but 100 which means I'll be inside this whenever I use the name of a variable I'll be inside the variable inside the variable means I'm I'm having this right having the number 100 so having an address 100 is as good as standing here right standing outside the structure standing inside this you know pointer which is containing the address is as good as standing outside the structure now in order to access I I should get into the structure right so that is why I should put a star so when I put a star I'll get into the structure which means I'll be standing inside it right and after getting into it I have to access I therefore do I so this is going to access I but then there is a small problem here while writing I know that I have to get into the pointer and then access I fine but then if you look at the you know associated with the presence of The Operators the first row contains the member operator right the member operator means this dot dot is present in the first row and Stor is present in the second row therefore the implied parenthesize parenthesizes which means our compiler will parenthesize it this way which means it will take like this and then like this this is what our compiler will do then what happens compiler will you know by writing like this compiler is thinking that P itself is not a pointer p is a structure which is having a member I which is actually wrong here isn't it P is not a structure p is a pointer therefore first thing that has to be evaluated is star P not P do I right so if you directly declare it and leave it then it is going to be a mistake so what you are supposed to do is even though star P do I according to you means that P is a pointer Now by putting star P jump into the the structure pointed by P and then AIS I you should not write like this you should even give the parenthesis which means you are supposed to write like this by writing like this what happens is initially you'll be taking P which means you'll be inside p and inside stand you know inside the p as good is as good as standing outside the structure which means you'll be here right and now you try to jump into it by putting a star so you are inside it and after jumping into the structure you can access the member which means do I this way it is fine understood this so starp do I has to be used in order to access this so maybe you might now think that accessing a member of a structure using the pointer is complex using the name is simple isn't it so a do I is simple right and know these two are equivalent actually so both are actually accessing the same member I now you might feel that I know why are we using a pointer and then star and then this I could have used this right but still using the pointers is very very popular and very frequent in C in C programming language the reason is uh most of the times these structures are dynamically created and whenever a structure is dynamically created or anything is dynamically created by using mlog they will not get the name what they get is the address so whenever you want to access any element through address we have to go through pointers only therefore you know even though it looks so tedious it is very popular and very frequent in C programming language then what the designer thought is no uh when this is going to be used so many times why should we burden the people you know the programmers with this so they have introduced one more operator like this right so they said that if you write with a minus and greater than symbol if you write this operator right it is equalent to this which means you know it will be easier to type and it will be easier to read also right so P Arrow I is nothing but if p is a pointer then we can access the element I inside the structure pointed by P right without know bothering me about all this so from now on if there is a pointer then I'm going to use this operator without any parenthesis right and then one thing you should observe is now either Dot or this Arrow right both are both are defined in the first row right therefore they are having highest precedence compared to any other operator so in the first row if you remember what are the all the operators in the first row one is function calling or parenthesis and other is array subscripting and the other is dot member of operator and the other is this Shand right so this Shand operator right so these are all in the first row right therefore they are supposed to get the highest priority and next thing is um you know since they are all having the highest priority and moreover they are having left left to right associativity which means if in a single row or in a single statement if you find all these operators then you are supposed to evaluate them left to right got it so now just remember it we can assign a pointer I mean we can take the address of a structure using ENT therefore applying ENT to a structure name is perfectly legal and which is going to give you the address of the you know structure and then we can assign this address of the structure to a pointer it is also legal and then I mean it is also legal legal okay and next thing is once you have the pointer right you can access the elements of the structure by using like this star P do I or if you if you if you feel that it is too long and boring and TDS then you can obviously use this one got it or if you have the name it is better that you go with the name and most of the cases we don't have the name right so I hope that you understood this example that is how we access the members right and everything else is same so now if you understood this let's solve this one let's solve this one this question so what I'll try to do is okay uh so okay fine so let's solve this one first now what I'll do is okay before that um structures can be passed to a function as well as it can be returned by a function so whenever you are passing a structure so what happens is the entire structure will be copied so see this so let us say this is a structure is a node and this says that fun is a function which is taking two arguments and both the arguments are structures of type node and moreover fun is wring a function a structure of type node that is the meaning of it are you understanding it fun is a function which is taking two arguments and both the arguments are structures of type node and moreover it is wring a function no it is wring a structure of type node so what is the meaning of it is I mean how how does this happen is whenever you call this know this function with two nodes all the values of that particular know uh actual uh actual arguments will be copied onto this formal arguments so in case if your structure is very big then just this function call is going to be very costly because the entire two structures have to be copied from the call function to the called function inside this function so because of this reason CS copying is a legal operation on structures copying can be done and moreover when it is wring the function see this whenever you written a function you know it will be taken by it will be assigned to some other function that is called assigning so you can assign a fun a structure to other structure so in that case also everything will be copied so whenever your structures are too big then passing it to a function and wring it by a function is going to be costly because lot of copying is involved so it is suggestable that if you know generally people suggest that you go with the pointers so if you want to send a function don't send the sorry if you want to send a structure don't send the entire structure because it is going to take a lot of copying you just send the pointers to the structure that is what many people will do okay so anyway that is what my intention is in writing this line is this line has nothing to do with this program this line says this syntax which is used to send the structures and then receive the structures and really no good programmer will use it everyone will use the pointers to the structures okay so now let's see this this one so now what I want to explain from this is I'll I'll try to see this uh you know entire program right this one and I'll show you what will happen by the end of this all these lines and then I'll take each each line and then I'll show you what is the effect of that line if this is the context okay so now uh from here to here I'll just uh declare all the variables and then assign the pointers and everything and later I'll take the lines one by one and then I'll I'll show you what happens okay so as an exercise what you do is you can pause the video here and you copy the program and you try it on your own and later we shall verify what happens okay that way you can even practice it so first of all struct node you know it is a declaration see struct node it is saying that is you know a node is a structure which is this is a tag and is containing two declarations which means it is having two members one is integer and other is pointer to an integer these are the two members present in this know structure and next thing is we are they are defining some variables so stru node a of two so it means that a is a array okay so how can you know that a is an array or not because there is subscription right so it is saying that a is an array of two elements and both are arrays these two elements are of type struck node so which is nothing but what they mean to say is uh it is uh this a is defined as an array of structures and there are two members in it so each member is a structure and the next one is star P star P says that uh you know p is a pointer to a structure of type node okay so a is an array of a is an array of structures of type node and moreover p is an a pointer to a structure of node a so let's see how it works now you can think of here like this a is an array of two structures right and each structure is going to contain two elements right so one is I and the other is C and similarly here also this is a and this is a of Z and a of one isn't it so this is a of Z and this is a of one and I and C so this is how you could you could declare a you know array of structures a is an array of structures right and what about this p is a pointer to a structure so which means p is a pointer to a structure of type node that's it and now what about the next one uh integer B so there is an array B of two elements which means there is n b of two integers that's it so two integers and it is already initialized to 30 and 40 so this one is 30 and this one is 40 and next one is p = to m% a of0 which is nothing but p is now assigned with the address of a of0 so let us assume that the address of this one is okay now let us say this one is two bytes and this one is two bytes this one is two bytes and this one is 2 bytes if that is the case what is the size of each structure each structure is 4 bytes and assume that this is starting with 100 then what is the address of this one not4 isn't it so there will be four bytes here and four bytes here right and now this line is saying that P = to m% a of Z which means you take the AR a right a of Z and you take the know address of this which is 100 and you put it in P so p is going to contain 100 right and it is going to point to this P = to % a of0 and next one is a of 0 do IAL to 10 it is interesting watch it a of0 right do I equal to 10 so what is the meaning of it actually how many operators are there there are two operators one is array subscripting and other is dot isn't it there are two operators one is array subscripting right here and the other one is dot so out of these two operators which one is having higher priority so you know that the both both The Operators are having the same priority isn't it in the to in the first row this uh function calling array subscript Dot and this all are in the first row therefore all of them have the same priority now when they have the same priority which one should I execute first then you go in left to right right by because associativity says left to right therefore this one has to be executed first and then this one so what is what is the meaning of it go to to a of Z right so when I go to a of Z I'll be here a of Z and then you take go into I which means I'll be here it is initialized to 10 this one is initialized to 10 that is the meaning of this and next one is a of 1. I = to 20 which means this is initialized to 20 right and the next one is a of I do c equal to B okay which means sorry a of Z means this one do c means this one equal to B what is b b is an array so whenever B is an array What will what do we get from its name from its name we get the starting address of the array isn't it therefore this one is going to point to this got it so this is the entire declaration so till this line This is the chain of links we got what happened see now p is a pointer which points to a structure of type node and then there is a array of two structures and then one of the structure member is a pointed to a integer which is pointing to an array of integers so this is the chain we got till here now what I want you to do is or what I'll do is I'll take this you know all these lines one by one and I'll try to execute and then show what happens I don't want to do all that at once I'll take them one by one and I just want to show you what happens okay what okay uh okay so now what I'll try to do is I'll take these lines one by one right and I execute them um and after executing a line I'll just uh you know I I'll just have erase all the effects and I act as if that line has never happened okay so now I want to see what is the effect of this one on this entire context okay so the first one is Plus+ p i so whenever any such you know complex expression is given so one thing you should observe is how many operators are there and what is the the priority right presidence so now there are two operators one is Plus+ which is unary operator which is present in the second row and the other one is know this are accessing this sorry structure accessing right with a pointer now this one is in the first row this one is in the second row in the table which I have given therefore this one has to be evaluated first so the implied parenthesis is like this even though you didn't you didn't do anything you don't say anything this is already implied right then what is the meaning of It Go to the structure pointed by P and then get the element I so which means you'll be standing inside I which is pointed by P so p is pointing this therefore you'll be standing here and then they they are doing plus plus which means you increment it so because of this line this particular element will be incremented from 10 it will be made 11 I think it is clear right so what I mean to say what what happened is you know this this line is nothing but P whatever p is pointing to you know P arrow means get into the structure and then get into that particular variable so it is nothing but I'm getting here and now Plus+ which means I'm incrementing it initially it was 10 I incremented it to 11 that is the meaning of the first statement fine again let's restore it let's say it is 10 only now let's take the second see it's not a program I just wanted to explain you what is the effect of each line so first line has produced an effect that I value which is pointed by P has incremented by one now I want to see the second line what is second line watch it X = to Plus+ p and then I right okay so what is the meaning of it so earlier what happened was there was no parenthesis right when there was no parenthesis then which got you know actual see earlier I have given this the the earlier right then we parenthesized the implicit parenthesis says that you have to go into this p and then do it but now there is parenthesis which means you are not supposed to perform this operation you are supposed to perform this operation and moreover this is a pre-increment so whenever we have pre-increment first you increment it and do the remaining whenever you have po increment first you do everything and then you increment it so now here Plus+ P which means P has to be incremented now p is actually a pointer to the structure so whenever you increment P it will actually point to the next structure isn't it so when I when I increment P it will not get incremented by one it will get incremented by the size of the structure what is the size of the structure four therefore it will get incremented to one4 and so it will Point here not here got it okay and now it is pointing to this right now after this you have to you know evaluate this so what is It Whatever p is now pointing to you go into that structure and get the value of I so what is the value of I 20 therefore x value will be 20 now right so if there is a variable X now it will get the value 20 from here that is the meaning of this understood this okay now again again let's restore everything so p is actually 100 and it was actually pointing here and this is this is the scenario okay now let's see the next line so this statement is over next statement let's see what happens if I would have executed that statement X = to p ++ and then I so what is the meaning of it P has to be incremented and then I has to be you know accessed but then here it is a post increment post increment says that you perform everything else then at the end you perform the increment so which means uh even though P has to be incremented don't increment it now so first you perform P of i p of I means you go into that whatever is being pointed by P get that value and then you see which means X will get P of I first so which means X will get 10 and then I increment p++ when I increment p++ this will be the scenario it will be 1 4 so after that line is executed X will get 10 and P will point to this one what is the difference between earlier line and this one in earlier line X was directly getting the value I mean X was in P was initially incremented and then we are fetching the value of I but here we are fetching the value of I and then we are incrementing P that is the difference so earlier x value was 20 but now x value is 10 got it okay again let's undo it 100 and let's see the next line so this one and let's see what happens with that because of that okay xal to Star P I'll write it here x = to Star p and then C okay now how many operators are there actually there are three operators one is assignment other is star and other is this uh you know this member structure member operator right then which one is going to be higher precedence this one is this one has to be higher precedence which means first this one has to get executed and next this is in the second row next this one has to be executed and finally assignment assignment is at the end if you remember it you know I I think I told you ask blah BL right so B BL black you ask black and a is at the end so assignment will happen at the end okay now first thing is What will what will happen P of C will happen right so which means whatever p is pointing to you get into that and you get into C so whenever you see p of C this is nothing but you get into that pointer and you get into that variable so you are standing here standing here is as good as standing here isn't it so now you are just standing outside B of0 then you are putting a star so when you put a star you'll be jumping inside it right therefore the entire this entire sequence that that expression represent presents 30 the value 30 therefore X has to be you know in X we get the value 30 that is the meaning of it what it no incrementation is done therefore nothing will alter only Xing is done so how is it done see p of c means you know this p is pointing to this therefore you get into C which means you'll be here get into p and get into C that is the meaning of it P of c means get into whatever is pointed by P and then get into C now standing here is as good as standing here now when I put a star I'll be jumping inside therefore the entire expression value is 30 so what do I get x equal to 30 got it okay now let's see this one the next line so it is X = to Star P C+ plus okay uh so what is the meaning of it how many operators are there you can see that there are four operators 1 2 3 4 right and out of this what is the highest priority which one is having highest priority the highest priority is given to this isn't it and next which one is having higher priority these two are having same priority but then they are right to left and if you if you look at it these two are unary operators and both the operators are actually from you know right to left associated with Associated right therefore the parenthesis impli parenthesis is this you have to perform this and then this got it so what does it mean p of C which means you have to get into this which means you'll be standing here and now this has to be incremented but it is a post increment which means this one so what what will be incremented this particular C has to be incremented but not now see this parenthesis will show you what should be incremented right and then pre or post will tell you either it should be incremented now or later so P of c means you are here and and now you're standing here this is the meaning of this right and now these two uh this Plus+ is showing that you know you have to increment this particular value not anything else you have to increment this particular C right but then it is not now so leave it so remember that this particular C has to be incremented mark it but don't do it now and if you if you forget it then what is next one store P of C which means whatever is pointed by C C which see standing inside here is nothing but you're standing here right which means you're taking this so St P of c means again 30 so X will get again the value 30 that's fine but then uh what will be incremented c will be incremented that is why this parenthesis is important you don't know whether you should increment the value pointed by C or C but once you parenthesize it is clear that you know this this C has to be incremented because this entire expression is repres presenting that you are standing inside C therefore what should be incremented whatever is inside the C that has to be incremented now we know that c is a c is pointing to an array of integers so when you increment it it will point to the next integer right this is what happens so what happened so X has got the value 30 and C has changed this you know pointing now C is pointing to the next element that is the meaning of it what it again do everything and let's take the next statement okay so now uh let's let's uh do this next statement X = to X = to Star P C++ okay uh so again how many operators are there so 1 2 3 4 operators are there um then which one should be evaluated first uh if you look at this you know parenthesis inside the parenthesis it should be evaluated first now uh inside this there are two operators which one should be evaluated first this arrow is having the you know first highest presence therefore therefore this one has to be evaluated first and then this one has to be evaluated and then this one has to be evaluated now you you'll understand the difference see you please rewind keep on rewinding the video and just keep on seeing what is the difference between all these all these are actually looks like same but then inter you know internally they'll be somewhat different see this now you had evaluate this one so P of c means go into the structure pointed by P which means you'll be inside this and then going to C which means I'll be standing here so I I'm actually standing here when I'm standing here it is as good as I'm standing here right why because it is pointing to this then what should be what should be the next operation when when you are standing here you are supposed to apply this star so when I apply this star I'll be jumping inside so this this entire sequence this entire sequence right is representing this value this particular this particular cell which means I'm finally here I'm finally inside and then Plus+ is done so now when I apply Plus+ which is increment what has to be incremented this particular cell has to be incremented earlier this was incremented but now this particular cell is incremented okay but then this is a post increment therefore whenever you know you mark what has to be incremented so which means we know that uh you know this particular cell has to be incremented but then not now after everything else is over what is everything else even you know assignment is there so first you assign it so what will be assigned now X will get the value of 30 after that this value will be incremented to 31 all it that is the difference between the ear one and this one understood this uh see I'm going in the order of Precedence right and then after I know evaluating the presidence then I'm I'm seeing which one has to be incremented see whenever you have plus plus minus minus this pre-increment post increment the main thing is in the expression you should you should find out what has to be incremented then you mark it if it is pre-increment then you increment it then then itself if it is po increment you finish everything else and again come back and then you increment it so here even though the first value is 30 the actual value here will be changed to 31 so X will get the old value itself got it okay let's restore it back it is 30 and let's see the next one the next line this one The Last One X = to star p++ C okay now what is the meaning of it how many operators are there 1 2 3 4 so which one is highest presidence you know that highest presidence is this Arrow right so this one is the highest presidence and after this what is the next highest presidence uh both of these are highest presidents only but then you are going to come from right to left therefore you know this one will get highest presidence next got it and then this one right so P has to be incremented so what has to be incremented P has to be incremented this is the meaning of it plus plus applies to P now P has to be incremented therefore Mark that P has to be incremented and it is a post increment so whenever it is post increment act as if it is not there but then you mark that it has to be incremented later but act as as if it is not there okay I'm acting as if it is not there then what is it P of C so that is the next one right P of C so when I go for p of C then what happens P of c means I'll be here right and it is as good as standing here and then you apply a start which means I'll be inside this so what should I get so X will be 30 so x value will be here 30 inside X we get the 30 and later you have to increment P when I increment P it will be pointing to this this is the meaning of it see whenever you're talking about this pre-increment or po increment if you're not able to know how to do it then you could you could remove it from there first find out what has to be incremented and once you find it out you mark it and you know below it you can write that P equal to p+ one generally what what programmers will do it do is if you have an expression and then below the line is P = p++ or some increment line is there then see let us say it is not there no it is some expression and below it it is p to p+ 1 is there then while writing the program you know they can they can cut this line and they can put a Plus+ here that will be simple and easy to write okay so understood this if you understood all this okay first of all if you didn't understand all this my suggestion is you please um uh you know watch it once again from the beginning you'll definitely understand it and if you didn't understand also you know it is not a problem because they will not ask you so complex things I I cannot say that they might ask you this so but it is very rare event if you didn't understand it you can skip it if you would like but I really suggest that if you watch it three four times you'll definitely understand it if you can understand this question you can answer any question involving pointers structures incrementation arrays everything everything will be easy okay fine now in general in any programming language why do you write Y type program is uh to process something right so generally a program needs two things one is it needs the input and then it will process the input and then it is trying it will give you the output right so every programming language should have a means by which it could read the input and then it could process it and then it could write the output so processing all that we shall see later first let's try to understand how to read a input into the program and and then how to write the output out of the program okay let's see this these things first now as I told you that any program does three things one is taking the input processing the data and giving the output now the input operation involves moving of data from an input device so generally if your program is interactive then we assume that we have to read certain values from the user where user will be inputting some values at this you know keyboard and then we are going to read it from the keyboard right and we read it from the keyboard and then we pass it to the uh memory and from that memory our program is going to read the values okay this is one way and the other way is if you have already stored the data in the files then our program could read the data from the files so for now we shall see how to read the input from the keyboard later we shall see at the end we shall see how to open a file and read the input from a file okay similarly while in the input output operation the data moves from computer memory to the output device okay fine so how to do this now we shall see so C language does not provide any facility for input output the basic C language it does not provide anything but if you want to use it you will have to import the libraries okay which means along with the compilers you can download the libraries and the library is going to have the code using which you can read the data as well as write the data out of a program for output now the set of Library functions that generally perform input out output operations are known as are pres are present in standard IO Library okay so if you have to use any input output functionality in your program you are going to use hash include stdio.h right so that is a header file now what is a header file and why do we need to use this directive we shall see later but for now remember that if you don't have this you are going to get some matter okay I'll just try to explain you in simple words if you can if you can understand it understand it okay so generally in C there is a rule that before you make use of any function you are supposed to declare it okay first you declare it and then use it now if you use suddenly a function without declaring it you'll get an error now header files are the files which contain all these declarations okay and when you say hash include stdio.h then it means that you you want to include all the Declarations which are present in this header file in your program before you start compiling so that you don't get any compiler error okay so later we shall get into details of what is this hash include directive for now you can understand that if you have to use scanf and printf you need to write hash include stdio.h okay gradually we as we as we as we get into details you'll understand why to use it and where to use it what happens if you use it okay for now let's not complicate it and has include studio. means you want to include all the Declarations from the standard IO into the into your C program okay now similarly there are other header files like math.h string.h and STD library. stdlib.h right so these are used if you use math.h then it contains all the Declarations necessary in order to make use of any functions related to mathematics like for example if you if you want to find out 2^ 10 then there is a function there okay so like that there are certain mathematics functions like s cos all those if you want it if you want all those functions you can include this math.h and you can use those functions later we shall see all the other libraries whenever we need them okay so now there are various other libraries which you could include and now the main input functions are scanf and get care so there are various functions using which you can read the input put into your program but mainly uh the most frequently used functions are one is scanf and the other one is get care and similarly the main functions which we use for output are one is printf and the other one is putare a simple method of providing value to variables is by assigning assignment statement which means in a program if you don't want to provide any input from the outside you can directly provide the input inside the program itself while writing it but it is a static way static means if you write like this in Bal to 2000 cap Cal to S then once you write it like this and if you are not going to read anything from the user using either scanf or get care then your program is always going to be static which means it can never read from outside now the other way of giving the input to your program is other than this is one way the other way of giving the input to your program is by using the scan method Now by using the scan method if you write a know if you use scan method in your program then it can dynamically read the input from the user it can ask the user to enter some input and he can input it from the you know keyboard and it will read it okay that is a second method and for output we generally use printf right so printf and also putare is also popular and also there are other methods but first let's start off with scanf and printf later gradually we shall see what are all the other methods available okay fine now let's see how to read using the formatted input so what is a formatted input is let us say user is entering some input and you want to read uh many values into many variables for example let us assume that you want to read in a single statement you are trying to write in a single scanf you are trying to read one is employee name and the other is let us say employee is and employee salary and maybe employee address all this you want to read in just one scanf and so you are using let us say 10 variable addresses in order to read now how do you specify that which part of the input that is entered by the user will go into which variable right so for that reason we can use a format specifiers okay so this formatted input now format for integer input so if you're trying to read the integer numbers then you can use percentile D so this conversion specifi you already know it right and now if you write w it means that that is going to tell you the width which means out of all the things that are entered by the user for that particular width we want to read into this variable so I'll just tell you with an example here D is the conversion specification this one you already know it means that whatever user has entered you want to read it as a decimal number that is the meaning of it right uh so here D is the conversion specification character for integer value and W is an integer number specifying the maximum field width of the input data which means how how long the user can enter for example if you write here as percentile 3D it means that the user can enter the input for this particular variable using a maximum of three digits and if he enters anything more than that if you write three here it means that three digits if he enters anything more than that that will be truncated right now if the length of the input which means whatever the user has entered if it is more than this Max maximum field width maximum field me whatever is know specified here then the values are not stored correctly right so it is just an optional so you need not specify it all the time so it is just used to restrict okay it is an optional W is optional you need not specify all the time now for example if you write see this scanf percentile 2D percentile 3D mamp per A and m% B it means that whatever user has entered treat it as a decimal number and read it into first first one read it into a and the second one read it into B but then in the first one you read just the two digits and after that the next three digits should go into B so if a user has entered consequent consequently five digits then two digits are going to get into a and the remaining three digits are going to get into B right now when the input data length is less than or equal to the given field width which means if the user has entered less than this W then there will be no problem the input values are unaltered and stored in the given variables then that is not not an issue for example if for this statement let us say user has typed 7 space 495 now what happens is so this 7 is going to get into a right and then 495 is going to get into B without any problem the reason is you have said that a can take a maximum of two digits and there is only one digit here therefore that is not a problem and the remaining of space there is 495 so whatever is present that is supposed to get into B and here we are giving three digits and here also we are specifying a maximum of three digits that is why there is no problem so a is taking 7 and B is taking 495 and that is how a a has taken 7 and B has taken 495 when the input data length is more than the given field width which means let us take this example the input values are altered and stored as like know so they are not stored properly for example for the state same statement if you give the input as 369 and 495 now a is going to get into it or read it is going to read into a just the two digits a maximum of two digits why you have two here right therefore 36 is going to get into a right and and then into B it is going to take the remaining thing now what is remaining just N9 is remaining in this and so even though it can take three since you have a space here it will think that okay input has ended here and so it will just take nine so 36 will go into a and 9 will go into B in case if you would have not given this space here then 36 36 would have been gone into a would have been taken by a and 949 would have been taken by B right so again with examples you'll be able to understand it okay for now this is all about Theory when we look at look into examples you'll understand how all this works or you can also try out all the possibilities I know just play with it you'll learn more okay fine now you can format the output using again percentile WD where D is used to represent the integer numbers okay so later we shall see about other formats I mean what about floating Point number and what about things but for now we shall focus on only the uh integers so here it means that we want to write integer so if you are going to use it with print F that is what I'm saying and w means the width so here W is an integer number specifying the field width of the output data so if I write percentile WD it means that the output data should have at least minimum width of w right that is the meaning of it so even if the size of the variable or the size or the number of digits in that particular variable is less than W still the width as assigned or allocated to that particular variable should be at least W that is the meaning of it okay if the length of the variable is less than the specified field width which means let us say the variable name the variable is 12 which means 1 2 and you have written three here which means you want to allocate uh three digits to 12 the number 12 which requires only two digits then the most significant digit will be left blank and everything will be moved to the right so that is why the variable is Right Justified with Le leading blank spaces now we shall just see this example let us say you have you have written a statement like this print F AAL to percentile 3D and B = to percentile 4 d a comma B this statement means that whatever is present in a you want to print it now how many how many uh uh you know width what width you want to have for a minimum is three that is the meaning of it okay now in case if a is containing less than three digits then they will be right Justified and they will be stored in a field containing three spaces and in case if it the number of you know characters present or the number of digits present in a is greater than three then all those character all those letters will be displayed there or all those digits will be displayed with example I'll show you this this let us say this is the statement we have used a = to percentile 3D Bal to percentile 4 d a comma B right now what will be printed in the output is a a equal to equal to symbol is there percentile 3D is there which means 1 2 3 so that is why since you have written three three spaces are used and in this three spaces it will try to place the value of a if it is going to fit right so since a is containing a value 98 since it is going to fit there so 98 is you know kept there right justified in this three spaces so since it is percentile three three spaces are there and now the number of digits in a is just two that is why it is just right Justified and then a space is left in the beginning similarly if you see b b equal to percentile 4D which means it has to be placed in four digits and now it it is going since B is containing only one digit it is going to be right Justified so it is kept here and all the other other spaces are left as blank got it now the width specifier of the First Data is three so here the width width specifier of the First Data is three while there are only two digits in it so there are only two digits that is why it is right Justified right and here it is four that is why it is again right Justified let's see one more example you'll understand it now let us say a = 3D is given b = 4D is given here a is = 374 which means exactly equal to three digits but then B is equal to 2842 exactly equal to four digits in this case we got 374 and 2842 without any problem let us assume that a is 2 2641 and B is 28426 in this case both the a is containing more digits than specified here as well as B is containing more digits than specified here but still they are not truncated and they are completely printed so that is the difference between scan and print in scan F if user tries to enter more than the width that is specified by the program then it is going to truncate the extra digits but coming to this printf even if uh you know uh user specifies some width I mean program specify some width and if the number of digits present in that particular variable are greater than that still it is going to print everything without losing any data okay fine now let's see how to write output from a program which means our program has read the input and then done some computations on it and finally produce the output now where do you want to see this output from now there are various ways so one way is uh you can ask the program to write it onto a file and later you can open the file and see it or you can directly ask the program to write it on the screen right so now if you use printf it will directly write it onto the screen so in Linux the screen is also the monitor that is what I'm talking this monitor or screen is also a file and printf is configured in such a way that it writes into a file which is actually a keyboard here in this case Okay so output data can be written from a computer memory to the standard output device which means the monitor using printf Library function with this function all the typ of the values which means either numeric or character or string can be written as output the print of function can be written as now if you want to see how the print F function is written so this is the syntax so print F followed by the parameters so control string variable one variable two right so I told you that in scanf there has to be at least two parameters but in print f one is enough right and if you need you can add more parameters right and also this control string is going to contain uh the conversion specification characters like percenti percentile D percentile U all those as well as text for example you can write here the value of x is percentile D and that percentile D will be filled up by the value of the variable that you are going to place as the immediate following uh parameter of the control string all right now it should be enclosed within a double quotes So this one should be enclosed in double quotes the name of the variables should not be preceded by ENT so in this case the name of the variable should not be preceded by ENT but then in scanf they have to be preceded by ERS that is the difference okay and then if the control State string does not contain any conversion specifications the variable names are not specified if it does not contain any you know conversion specifications then you need not put any variables so when is that used is let us say you want to ask the user to enter some input then you can say enter an input and you need not write any variables later you can write scanf percentile d i something like that so we shall see a program on that you'll understand it so this is the this is how you are going to write print F so in Marx equal to 100 print of percentile D marks so it is nothing but marks is set to 100 and now you are trying to print the value present in this marks as a decimal value on the screen so you you you know what this is we have already discussed right so now if you see the difference between scanf and printf the same program here so scanf percentile D ENT marks is used which means you are reading a value from the keyboard as a decimal value and you are trying to write it into the variable marks but here percenti marks is used so here there is no ENT so that is the difference okay fine now let's see the conversion specifications so here I'll explain you the theory later when with with examples I'll explain you all the con Concepts so what is conversion specification I mean what it means is whenever you try to store data in a computer it will be converted into bits and it will be stored now when you show it to the user you have to show it in a form that he wants to see now if you look at the number all ones let us say eight ones are there now if you interpret it as a unsigned integer that represents 255 if you interpret it as a signed integer in complement it represents minus one now if you interpret it as a character that represents a different character altoe therefore there is a there is a possibility that many values will will have the same binary representation and so when you use this conversion specifications there will be a opportunity or a means provided to the user in order to specify what he actually means right for example if you write if you if you say 255 255 if you store it later if you read reads it as a sign number it is minus one so that is why you should always take what is what actually the user means right so the user he has a facility here to specify what actually he means so I'll just tell you with examples what it all means right so the functions scan F and print F make use of conversion specifications to specify the type and size of the data so scanf and printf are the functions which are used to read and print something onto the screen right now where do you read something from you read from the user or from a file scanf is generally used to read something from the user now how the user will enter the data through a keyboard now when he enters the data in a keyboard whatever is the bit representation for that key that all will be converted into resistors that all will be stored in a resistor now in that resistor again it is in the bit format now how many bits should you read in a go that can be determined by you know that is what you want to specify by the type and the size of the data so that is where this conversion specifications are going to be useful each conversion specification must begin with a percentile sign which means before you st you know in order to specify that uh this character represents a conversion specification we are going to use the uh sign percentile now let's see this so so whenever you write this so these are all the conversion specific specifications for printf let us say you want to print the information present in a variable now how do you want to print it do you want to print it as a number or do you want to print it as a character that you can you can specify using this right so by using examples I'll show you again this point for now let's go to the to this Theory now percentage c means whatever value you want to print you want to print print it as a character that is the meaning of it now percentile D or percentile I means whatever you want to print that value in a variable you want to print it as a decimal integer percentile u means the value present in that integer has to be interpreted or printed as a unsigned decimal number right so now if You observe it the difference between this one and this one is let us say you have a variable and in that variable if it is a you know eight bits and you have all ones in it now if you use percentile U it is going to show a value of 255 now if you use percentile D or percentile I it is going to show you minus one right and if you use percentile C to print the same value then it is going to show you a character right and that character will depend on what is the you know mapping that we have used or encoding that we have used and then percentile U we are done with it so percentile W print and un octal integer so this is used to print octal number which means whatever is in the binary form we'll convert it into octal number right so what is octal octal integer is uh I'm not going to explain that in this course but I'll just give you brief introduction now if you have let us say few bits you take three three three bits and you try to convert each three bits into some number integer number and you represent it that is nothing but the octal representation which means let us say you have uh you know 30 bits now you take you join 3 three three bits therefore you are going to get 10 digits all those 10 digits is going to be that octal integer okay but anyway you can read about it in detail in the number system Topic in the digital course or some other course you can read about it and coming to percentile X it means that we want to print an unsigned hexadecimal integer using a b c d e f so what it means is percentile X it is small X okay so we want to interpret the information present in bits as a hexadecimal number and when you use hexadecimal number we are going to have all the numbers from 0 to 9 and also we are going to use the letters a b CDE e f right now by using small X we are clearly saying that we don't want to use uh capital a capital b capital c like this we want to use only small letters that is the meaning of it and then percentile capital x it is same as the previous one this one but only difference is instead of using small letters we want to use capital letters and percentile F so it means that the information stored that has to be interpreted as a floating Point number which means you take that entire data let us say 32 bits now in that 32 bits there is going to be mantisa so there is I representation again what I representation of a floating Point number we are not going to discuss in the C course that is discussed in the number system of computer organization okay so what the brief essence of this one means whatever information we have in that particular variable in terms of bits we want to interpret it in terms of mantisa and exponent and then finally print that value as a floating Point number that is the meaning of this okay and percentile C Small E so it is also the same thing so print a floating Point number but it has to be printed in exponential format so what is exponential format is now we know 1.5 is a floating Point number and 1 E5 is also a floating Point number which means in order to represent floating Point number you can use a decimal point or you can also use Small E so that is the meaning of this one and percentile capital E it is same as percenti you know small e but instead of using Small E it is going to use capital e that's it okay and then percentile G so the percentile G is it is going to print the floating Point number in either percentile F or percentile e form whichever is shorter so sometimes some numbers can be written in a short manner which means using few characters in percentile of format and sometimes in percentile e c no e format therefore whichever is shorter it is is going to use it so that we can you know save some space in documents and then percentile capital G so it is also same as percentile small G only difference is instead of using this small e representation it is going to use capital E representation okay and then percentile s it is used for printing a string now what is a string in C we have we don't have the concept of a string directly but a character array can be considered as a string but if you look at other programming languages like Java there is string available directly but here we don't have string available in C so we have only arrays available and when you when you have an array of characters we call it as a string and then percentile P so it is used to print a pointer in hexadecimal format so what is a pointer pointer is nothing but a variable which contains some address so as of now you don't know anything about it later we shall see about it but for now if you have a variable which is called as a pointer which generally contains address of some memory location now percentile capital P says that you want to print the value of that particular address in hexadecimal format generally when we come to the addresses we generally use hexad decimal representation in computers when we talk about the addresses we generally use hexad decimal format to represent them or talk about them and then now let's see about the scanf the specific version specifications for scanf so till now we have seen the printf so printf is used for printing onto the screen so what it means is now if you have some data available in the memory as a variable if you want to print it you are going to use print F now you are going to say or you have specified how you want to print it on the screen similarly scanf is somewhat different scanf says that when you're trying to read the bits from the user how many bits you need to read and how to interpret that got it for example if it is a character you might have to read only eight bits now if someone Types on the let us say keyboard all the data is going to be converted into bits and it is going to be stored in registers now from those resistors or buffers how how does our program have to interpret it right so which means should it interpret it like a only 8 bit chunks or should it interpret like a 16bit chunk so that is all depending on the uh scan I me that is all about scanf now if you say percentile C it means that you read from the user let him input any number of characters but then you read from him only eight bits and you interpreted as a know character okay so which means it is just going to say how many characters you have to read how many bits you have to read okay and percentile d means you are going to read a decimal integer now depending on on the size of the decimal integer in the in this particular machine it is going to read either two bytes or four bytes okay so what is the size of an integer that we shall discuss later and then percentile I percenti I means it reads a signed integer and base is decided by the prefix of the input number which means here percentile I we are going to read the signed integer so what is signed integer minus1 - 2 + 1 + like that okay but then you can also have any base in this it could be either a decimal number or it could be a hexadecimal or it could be octal right now if you're going to use uh Z you know 0x it means that he has you know given the input as a hexadecimal number right and if it is having zero so 0o means he has given the input as a octal number right and otherwise it is simply a decimal number or getting this for example let us say you want to input um maybe 16 + 10 is um 26 so 26 is 1 a right so in in hexad decimal you want to input it then you can say 0 X1 a now if you write like this then uh the machine will understand that the machine will understand that he's trying to input a hexadecimal number and so it will re read whatever is entered after it as a sequence of bits and it is going to store it in the computer but then when we again get it back it is going to be you know interpreted by the same way that you want okay so with examples this point will be clear don't worry about it as of now and coming to let us say uh this one octal so octal if you look at this uh in 26 in octal it is going to be 32 right so 0 3 3 2 it actually means in octal you want to represent the decimal number 26 right so if you write 0 32 then this scanf method is going to read that and convert it into the decimal number and it is going to store it in that particular variable later again if you want to convert it into the uh let us say octal then you might have to use the percentile conversions in print F right so while reading we are converting and while printing we are converting finally we are going to store everything in bits right and then so if you don't specify any prefix it is going to be a decimal number okay and coming to this percent value it is it reads an unsigned decimal integer which means as it is saying that we don't want to worry about signs we are talking about only unsigned numbers here and percentile W it is used for it is used for reading unsigned octal integers percentile small X or capital x it is for unsigned hexadecimal integers percentile f it is used for reading floating Point number percentile small e or capital E again for floating Point number and small e or capital G it is also for floating Point number so small e or capital G says that he he might enter the uh input either in form of 1.5 or 1 E5 right so this says that he might enter a input in form of 1 E 5 or 2 E5 something like this and percentile s means we want to input a string okay so about strings don't worry about it as of now later we shall see about strings in in detail pointers and strings don't worry about it and along with this percentile U or this we can also have a prefix here L like that okay now see this that is called as modifier see we have percentile I like this percentile I right percentile D all this along with this we can also have before D or before I even more prefixes right they are called as modifiers now the modifier cap small H can be used before the conversion specifications d i o u small x capital x to specify short integer and the modifier L can be used before them to specify a long integer right which means here if you want to specify if you you want to specify uh let us say a small integer so what is the differ okay before that you should understand what is the difference between a short integer and a long integer generally depending on the architecture short integer might be two bytes and long integer might be four bytes let us say a user has entered something through the keyboard and now that has come that has been converted into bits and now that is stored in the buffer now from the buffer how many bytes should be read and stored into this particular variable so that you can specify by saying H or l in case if you specify H it means that you are specifying the program that you need to read maybe two bytes in case if in that machine short integer is represented by two bytes right let us take a machine where short integer is represented by two bytes and long integer is represented by four bytes and the sizes are variable I mean they can change from machine to Ma Mach implementation to implementation right now we are working on a machine where short integer is 2 bytes and long integer is 4 bytes in that case if you give percentile HD it means that you want to read only two bytes into that particular variable if you give percentile LD it means that you want to read four bytes into that particular variable and also that particular variable should have been already declared as a long or short okay otherwise there will be type error so later we shall see that conversions and all this so here let's see only the basics which are required to print and read okay the rules we shall see later now the modifier small L can be used before the conversion specification F small F small E capital E small g capital G to specify double while capital L is used to specify the long double now just like short in and long in in case of integers in case of floating Point numbers we have double and long double right so double is generally 32 bits and long double is generally 64 bits it is also called as you know signed sign extension sorry uh floating Point representation i e single precision and double Precision right so about the representation exactly we need not get into those details in C programming language if you are interested you can look at the computer organization topic there we have this floating Point representations right but what you understand is if you give small L you mean to say that I want to read 32 bits if you give capital L you are saying that I want to read 64 bits provided that the space in that variable should be that long right and also if you use small l or capital L it means that you want to print 32 bits as a floating Point number and you want to print 64 bits as a floating Point number depending on the context you have used it if you use if you are using it in scanf you are talking about about reading if you're using it in print you're talking about writing okay and for example if you see this percentile LD percentile HD percentile LF percentile HF so which means you can prefix d with L and D with h like this right so that is why they are called as modifiers right so these are the conversion specifiers D is the conversion specifier and L is the modifier but anyway you need not byard this terminology okay no one is going to ask you anywhere don't byart the terminology and also don't byart all these things anyway you can Google them out whenever they are required and in practice we generally don't use all these things we generally use either percentile F or percentile I or P percentile D or U and as we practice you'll get used to it no need of by Harding all this okay fine hi till now we have seen the uh fun programs which are actually reading from the keyboard from the user and they are writing something onto the screen but in real world I mean when you when you work in software industry and if you're trying to develop a product generally they don't print onto the screen and they don't read from the users right so there um know the input will be taken from a file and the output will be written to a file right for example if you see a log file right whatever happens while ex during the execution of a program will everything will be noted in in a log file right it will not be printed onto the uh screen all the time right and whenever a user want to see what has happened he is going to open the log file and he is going to read it right or some other program might open that log file and read it therefore input and output to a program in real world should come from the file and should go into a file all right it is not that we are always going to involve uh user to print you know to type the input and you know to and then the screen to you know read from therefore it is very important that you understand how to open a file read from it write into it or create a file or you know append something to the end of a file now let's see uh what C has provided Us in the standard libraries in order to handle files so first thing is C has provided a structure by name file in the standard library now the Declaration of this structure is present in STD iio H so before you start the program you include stdio.h so that all the functionalities of the structure are already declared right and then before you open any file you just Define this structure and you define a pointer to that structure let us here call it as FP right so what does it mean FP is a pointer to the file structure which is already predefined you are not actually going to declare it okay so no Declaration of file is required it is is already done in stdio.h just include it now after it is done once you have you know defined this FP you are supposed to open the file uh for using it now what are the various ways you can use a file either you might open it to read some information from the file or you want to write some information into file or you want to append some information to already existing file right therefore you can open a file by using this function call right F open now you just give what is the name of the uh file that you want to open in the string okay and then what is the mode in which you want to op use the file so what mode mode here means that how are you going to use the file that is it so either are you going to open the file for reading or are you opening the file for writing or are you opening the file for appending generally three modes are there for example you might want want to uh open a file slash slome slra something like this okay now you give this entire name here you put it in a charact in a string and then you pass it here or you can directly give it as this as a string okay and then let us say you want to open it for reading now you give that in the reading mode and then you can just write pass these two parameters to F4 now F4 is going to return a pointer to the file structure and you can catch it in the file pointer which is already defined right so you can simply write FP equal to this then what will happen is this file will be opened and you know that that pointer will be CAU there and then after opening the file you can do various operations on the file depending on this one so one thing you should be careful about is you cannot read from a file which does not exist so if you are trying to open a file in a reading mode which does not exist it is going to give an error therefore this function might return null in case if it is unsuccessful and second thing is when you are going to open a file which is already existing in for writing then what happens is all the information in the file will be deleted and you are again going to start writing from the beginning in case if you want to have the uh data inside the file as it is and if you just want to append it you have to open it in the append mode right now in case if you are going to open a file for writing which is not existing then a new file will be created and you know and you are going to get the pointer for accessing okay now let's see what are the operations or what are the functions that are provided in the library to to perform various actions on the file these are the various uh functions which are provided in the library now let's see them one by one F open as you have seen it is going to open the file we shall see F close later next one is get C it reads a character from the file by giving this okay what is the exact syntax we shall see it with an example here just understand that there is a function with this name now how to use it we shall see for every function some example later we shall see that now it reads a character from the file now put C it writes a character to a file now f scanf it reads a set of data from a file it is similar to scanf but then it is going to read it from the uh file okay and F printf it is exactly similar to print F but it is going to print the data onto the file instead of printing it onto the you know screen get W reads an integer from a file and put W it writes an integer to a file F seek so what happens is every time when you have opened a file and when you are let us say reading the file using get C or when you are trying to write something onto the file using see we'll just remember till what part in the file we have read so far or written so far which means we'll always remember using a pointer till what part we are done in the file let us say this is the file and till this part you have red and the next character to be red is let us say here okay then you are going to have a pointer which is going to say that till this part your reading or writing action is done now if you want to move this either back or or front you can use F6 right so now F6 sets the position to the desired point which means this pointer you can set it to either beginning or ending or anywhere right that is called as FC it you know you can compare it as if you are moving the read right head on a file and then F use the current position in the file which means it will just tell you which position you are standing in rewind set the position to the beginning Point okay rewind means you are again going will be setting from the you will be going back to the starting point and you'll be starting all over again got it now if you see this after this is done after everything is done let us say you have opened the file and you have read from it or you have written to it now it is it is always advisable that you close it so why closing a file is important is you know this there will be some resources which will be allocated for this structure while uh you know processing the file now it is better you close it so that all those resources will be freed generally what are the resources is some buffers will be allocated for that particular file in the Heap right in the Heap section of the process now when you do this close all the buffers allocated will be freed so that you'll have the memory back right so F close is simply going to give you uh what is the you know resources and they are all going to be closed so once it is successfully closed then you are going to get a status of this function a a negative minus one means it is you know this status is failure some error has occurred while closing a file you not able to close it properly otherwise if you get a non-native number it means that it is Success okay now let's see some more reasons why you should close a file using F close once your work is done so one thing is uh you know whenever you open a file using F open whenever you cat that pointer you know the point return return in FP it means that you know there some kind of relationship is established between the file you have opened and this file pointer later if you want to use the same pointer to point to the other file then it is better you close that you terminate that relationship right so when I close it then there is no longer a relationship between the file open and this pointer and so you can use uh this the same pointer to open some other file right that is one reason and second reason is there are you know uh see there is something called as system calls we are not actually going to get into it see we are trying to make as simple as as it is possible without going into the system calls now what happens is every Library function here you know we have seen let us say put C right or get C now every Library function it is supposed to call a system call in order to execute its work right now in order to optimize in order to optimize the code or in order to optimize the time so okay I'll just go into some details here if you are not able to understand it leave it completely right so what I mean to say is uh for every function call here related to the uh you know this files there will be a system call right and every time when I call this function if the system call has to be called then then we have to go from user mode to Canal mode and then again Canal mode to user mode and it is going to take a lot of time therefore what our uh you know uh C C library has done is instead of calling this system calls all the time it is going to locally maintain a buffer and it is it will just keep on accumulating the data right and once this buffer is full then for all the characters at once it might call the system call right now what happens because of that you know you you need not waste lot of time by calling the system call for every character you'll be calling the system call once and you'll be getting the work done very fast right now when you're using such a mechanism what happens is uh sometimes the buffer might still contain the valid data and you might have to uh you know uh you might have only filled some part of the buffer and so the system call is not at called and this value this this data is not stored in the file now whenever you call this F close then this entire data which is collected so far even though the buffer is not full will be flushed got it so there are there are you know there are certain things which are done for optimization we are not going to get into the details you might get confused so just understand that by doing F close you are actually uh you know uh not losing any data okay so always try to use f close and in case if you don't use f close what happens is when the program completely terminates when the program is over automatically F close will be called on all the functions which are and on all the files which are open right anyway this will be flushed at the end of the program not in the middle okay fun now let's see this program in this program we shall see what is the purpose of FSE and you know ft so these two we shall concentrate on these two functions so let's see the program how it is working here void main so first thing is we are declar we are defining a pointer to the structure file and then one variable is defined here int length fpal to fop file.txt comma R so what it means is we want to open this file file. text in the reading mode using this fopen function now now as usual fopen is going to return a pointer to the file structure which is going to be held by this which is going to be taken into this variable right this is a pointer now every time even though we didn't show you you know in some examples you should always do this whenever you open the file you should always check if FP equal to null or not right and this is the best practice why why we should do this is sometimes you know um whenever you are going to do this one some sometimes what happens is because of some error either if this file doesn't exist or because of the lack of permissions for you to open a file you know this is going to return null now if you don't don't test that condition and if you go ahead with using this pointer then you might see segmentation fault if you're going to use a pointer which is pointing to a garbage value some errors will be there while you know while you running run the program that is why Always test it in some of the examples we missed it out but then you should do it so what is it if a equal to null then printf error opening file and the next one is FS now now we shall see why FSE is used as I told you whenever any any file is opened let us say for reading let us assume that in this file we have a b c d some data and then end of the file character so character 1 character 2 character 3 character 4 and character five we have five characters out of which four characters are a b c d right now whenever you open the file for reading initially the read right head or the r pointer is going to point here which means inside the structure there is going to be various pointers one of the pointer will be holding the current position that you are that you are at initially when you open it for reading it will be at the beginning okay now by saying this fseek by passing this point to this function and by sending these parameters so two parameters are being sent so one parameter is zero and other parameter is seek and so what it means is we have three constants actually which are defined in uh you know that file the head of file using hash Define so secant is actually an integer constant uh which will be defined by hash defant I think three number three now let's see what are other constants we have and what their purpose is so we have all these three constants okay all these three constants so C underscore set it means that we want to start from beginning of the file C underscore current it means that we want to start from the current position in the file and see underscore end it means that we want to start from the end of the file right so these three are the integer constants which are being passed and you know they they will be defined as if it is z 0 it is 1 it is two right so just to increase the readability of the program we generally use this uh you know uh integer constants now whenever we send zero here to FC it means that you start from the beginning of the file and you move the cursor or you move that read write head these many bytes and you position The Rite pointer there right for example I'll just show you what it means let us say our function our our file is a b c d and then end of the file is there right now if I call the function like this fseek FP let us say FP is the file pointer which is linked to this file FC FP comma let us say two okay and now let us say it is zero right if I call the function like this here Z actually means indicates that you have to start from the beginning okay so from the beginning you move the read right head two point two characters to the right which means initially if it is at zero location zero it will move to two that is the meaning of it okay now if you say let's say one which means assume that the current position of the readed head is at two which means you are starting from the the current position that is why this this number is one and if I write let us say one it means that you have to move one position to the right therefore it is going to move one position to the right and we are going to place it so why is it useful is we want to skip some characters either while reading or either while writing so how many characters we want to skip and how to move the uh cursor that is all decided by this function right I mean cursor means that read head okay and the next one is let us say at the end so if you give it two two means we are starting from the end so it will be pointing here and if you want to move two characters to the left here you give min-2 when I do minus two it will move two characters to the left and it will point to here all right therefore you can tell this function where to start the initial position from and from there how many characters to move you can also say you want to move to the left or you want to move to the right depending on positive value or negative value generally if you give a positive value it means that you have to move to the right negative value means you have to move to the left right now if you look at the syntax of FS now FS is going to take one is the pointer to the file structure now this one is going to say or it is going to give the all the information related to the file and the second one is how many bytes you want to move the read right head and the and the third one is uh when V means from where you wanted to St start so either you can give zero or one or R2 here generally to make the program more readable instead of directly giving these integer constants we generally use this macros right so now if you see this name SE set will be if you give SE set it means that we want to start from the beginning SE also means we want to start from the current position SEC means we want to move till the end now this this function after taking these parameters it will do the appropriate moving right so inside it the logic will be written in such a way that this particular point will be moved to the beginning and from there how many characters you want to move or it will move to the end and from there how many characters you want to move left or right got it and what about the return type now F6 is going to return two values either it is going to return a zero or it is going to return a non zero right now in case if it return returns a zero it means it is successful in case if it returns a non zero it means something wrong has occurred there and that you know that that means it is a failure right the function has failed to perform the task that it is given now in case if you get a zero it means that it is successful right now let's see here if You observe this FSE FP comma 0 comma secant so what is that we are trying to say is go to the end of it and you don't move it right zero means don't move either to the left or right you just stand there that is the meaning of it got it and now if you start the character from zero 1 2 3 4 our our current pointer is positioning is being positioned at four right now the integer length is equal to F of FP now what it means is this function ft is going to open know take this as input again you know if you look at the syntax of this the way we have to write it see this now ft is going to take as input one pointer to the uh function file struct and it is going to written int long in right now what does this long int represent is the current position in the file that you are standing at that your Rite head is standing at in case if there is some error it is going to return minus one right so now if You observe it in this case if this is the file if I if my current position is here at this point if I call F giving it the input as FP then it is going to return four right that is where our current position is now if You observe it four is nothing but the number of characters which are present in the file which means it is also giving us you I mean we are finding out the file file size indirectly by using this method right now FP close so F close FP so it is nothing it is just a statement which is used to close the file print F the total size of the file text equal to percentile D byes length which means we are finally printing that the length of the file is so and so right here in this case it is four okay now there are one two more functions which are defined in you know sdio Library uh apart from printf and scanf even prf and scanf are also in the sdio library uh similar to that we have get test and put T these are especially to read unformatted data so earlier we have seen how to read the formatted data using scanf right so if you see this you can scan of what we did was now if I say I want to read percentile D percentile D two numbers then generally we are going to enter in the input let us say 10 20 10 comma 20 so our scanf will read the data till it finds a blank space and once it finds the blank space it will take this part as the first first one and then it will take this part as the second number and it will convert this into a decimal number and store it into the address given here right Therefore your scanf will not read the spaces given in between right so while you enter the data whenever you VI the spaces it will think that that is the end therefore scanf will read only until it finds a space but if you want to write know write something like this let us say my space name if you want to write something like this and if you want scanf to read it it because of the space present here it might not read it right or if you want to give a numbers a lot of numbers let us say you want to give 10 20 30 so on and if you want to read them all once it sees the space it will stop reading okay that is the problem with scanf now if you want to read the entire string as it is without stopping when it sees this space then your best thing is you go with gets now get us to the input we are going to give a uh pointer to the character pointer which means a string let us say Car Star s it means that if you give to gets an argument which is a character pointer which points to an array of characters then it is going to read the uh whatever string you have printed and it is going to read it and it is going to store it in the character array which is pointed by S right see this this gets function it reads a line from stdin stdi in means standard input which is nothing but the keyboard into the buffer pointed by S what is the buffer pointed by s a character array right a character array which is pointed by S until either a terminating new line or end of the file so when will it stop reading is either if it finds a end of the file or if it finds a new line so these are the two characters which will be used to stop stop reading but in case of scanf by looking at a space Also it will stop okay now it is going to read I mean it is going to take as an argument a character pointer and it is going to return a character pointer now what will be returned in case of successful reading it is going to return the pointer to S itself right which means it is simply going to return return s itself if you want to know the status of the you know function now in case if some error has occurred it is going to return null okay now the next one is put s this function writes the string s and a trailing new line to the standard output so now if you see this function puts it is going to write whatever is present in this let us say this is a character pointer okay now let us assume that this one s is pointing to an array of characters then this function is going to write whatever is present in the S onto the output okay at the end of it it is going to write a new line all right now this one is going to return an INT in case if it is successful then it is going to return a positive number in case if it is if it is a failure I mean if something has occurred some error has occurred while executing this it is going to return minus one so that is the status of this now let's see this example vo so hash include studio. H because since this is uh you know in library sdio I have to include all the head of files corresponding to that Library so that Declarations of these two functions will be taken care now car St Str 100 which means we are having uh you know an array of 100 size 100 now print F enter a character string now gets string which means into this Str Str we are going to read whatever the user has entered right and then put as Str Str so whatever has been read into this s Str that will be printed okay so that is example of it let us say if you have entered a name Ravi that will be read into this s Str and later when you try to print it is going to be printed right okay now how can you stop reading it is see this uh so let us say you have Ravi space r a v u l a Raa now you you are going to see this display enter a string and in the next line if you have entered Ravi space Raa the entire string is going to be red till this part right so when is it going to stop it is whenever it sees the new line therefore after entering this if you print a new line which means if you print enter that is nothing but a new line then definitely this entire thing will be red including this space if you have done the same thing with a scanf by looking at this space it would have stopped reading the remaining part okay now this entire part is going to be stored in this St Str right and next thing is when when puts so when you use this puts and when you try to print it this entire part is going to be printed on the output okay fine um in in Linux programming environment whenever you run a c program operating system is automatically going to provide you with three file pointers so one is sdn and the other is STD out and the other is SD err right so just to just to explain you in simple words you can assume that STD in is a file which is related to the input stream and so you can think of it as if it is related to the keyboard or associated with the keyboard right so what you can do is whatever you are going to type in the key you know type on the keyboard that will be streamed onto this file stdm and that file will be displayed to you on the screen and similarly STD Out means this is the stream which is related or you know uh which is related to the output screen right which means whatever you write onto this file right you are going to see it on the output screen right so whatever you read from this file is what you are going to read from the keyboard and whatever you write onto this file you are going to see it onto the output screen right and SDR we shall see it later okay and SDR is also related to the output only I mean the screen so whatever you write onto this file it will be given to the file it will be displayed onto the screen now if you want to use the functions which are provided by the uh STD IO without using printf and scanf if you want to use the file pointer and if you want to read and write the data you can use this two what I mean to say is see this now if You observe this get car is used without giving any parameters to it and by default it is going to read from the keyboard right now you can if you want to use it along with the file pointer you can use this function get C I mean it is going to give the same same functionality get C and where are you going to read it from from the input and the input keyboard is already associated with the file pointer STD got it so you could have replaced this statement with this statement and the program will work just fine and similarly if you want to display onto the screen you could have instead of using print F you could have used put C right so you could have used put C right CH comma what is the file pointer you want to write it onto the output screen and the output screen is associated with the file pointer STD out right by writing this here you are going to see everything on the output got it okay now let's see a small C program which will open a file read and uh you know it will open the file for writing and first we write some content into the file and later we open the same file and we read the content and print it onto the screen okay now let's see this program hash include Studio H void main file file pointer okay so we are creating a file pointer this is a pointer to the structure file now where is the structure defi declared it is declared in the uh you know this Library I mean h so when you include it that declaration is going to be present there and now car CH it is a variable now first I want to open the file right now let us say F open I'm opening the file whose name is test.txt it will be created in the same directory in which you're working in right and comma w w means we are opening this file in the right mode now in case if this file is already present then whatever contents are there they all will be uh deleted and again we start writing from the beginning right in case if it is not present then this file will be newly created remember it whenever I use write mode if it is not already present it will be created in case it is already present the entire contents will be wiped out and again we are going to start writing from the beginning okay fine now okay once it is done this FP is now associated with this file all right so now F now we are just writing print F enter the data now we are asking the user to enter the data now let us say user has started entering the data now what we are going to do is while CH equal to get care which means we are going to read the data which is entered by the user character by character and we are going to read it into the variable CH every time now and also we are going to test whether we have reached end of the file or not okay now how will we know end of the file either you can print put know contrl C while you are entering you can you can print control C then it is going to give end of the end of the file okay now let us say CH equal to get care we are going to get characters one by one and every time we get a character which is not equal to end of the file we are we are calling put C now what will this put put seed do is it will take the uh character and it is going to print it into the file which means it is going to write it into the file pointed by this pointer which means whatever user has entered that will through the keyboard it will come into the variable CH and then through CH it is going into the uh you know file so if you want to see what is actually happening now let us say this is the file when you open it we'll initially be pointing to the first location of the file and somewhere there is ch right and let us say this is the standard input which means whatever user is entering from the keyboard from the keyboard the character will come into CH and here we'll check whether this one is equal to end of the file in case if it is not equal to end of the file we are going to send it into the file and we are going to print it there right write it into the file now uh again this read right head will move to the next point and again we do the same thing right so for every character which is entered it will come into this variable and it will go here now how are we reading from the standard input to this variable know uh CH is by using this get care so here we are using get care okay now how are we placing this character into the file by using this put C all right so here we are using put C to place it here and get care to place it here right fine now what is the syntax of this one is If You observe it put C please look at the syntax here input C in C comma file pointer now if You observe it put C is going to take as a as an argument first argument is in C and the second one is the file pointer right so that is what we are doing here we are we are sending CH and then FP even though CH is a care there will be a type casting it will be converted into the integer and that will be placed there okay and after this is done now I want to open the same file and I want to read the contents uh already the file is opened for writing right but then now I want to read right so what the problem with this this one is by the time you you finish the writing let us say you have written file till here your pointer will be pointing to the L character which is present here got it the pointer will be pointing to the Lost character but then once you start reading you know there it will start reading from here onwards but then there is nothing after this right therefore you have to go to the beginning and start reading for this you can use that FS which will tell the point to go to the beginning you can use the FC and start reading or you can use rewind and then you can start reading but then we shall see those mechanisms later for now one simple mechanism is you simply close the file which means you you simply uh when you close the file everything will be flushed and now FP will be free to be used again now again you can open the file in the reading mode right so if I again open the file in the reading mode then automatically the pointer will be set to the beginning of the file here right and now I can start reading now how can I read it by using get C now get C FP see this now if I use get C the syntax is like this if I pass a pointer to the file structure then get C at every time is going to read one character and it is going to return it as an integer right and now I'm going to catch it in car right again the type casting will be done don't worry about this type casting even though we have declared it as a character and even though there we are working with integer it doesn't matter right the characters asky value will be given and that will be stored there and appropriate conversions will be done okay now if You observe this while CH is equal to get care not equal to end of the file so till we reach end of the file we are going to do this print F percentile C CH so we are going to take each character one by one and we are going to print it onto the screen now once it is done I'm simply closing it okay in order to understand and recursion what I'll try to do is I'll take the smallest recursive programs possible and then I'll show you how to trace out the recursion um then we shall actually do the big recursion programs while we get them okay so my my intention here is to explain you how the recursion Works how to trace it out and later when the problems uh you know we Face the problems where we need recursion with big problems we shall again do it anyway there okay so now I'll I'll take small problem and explain you how it works so let me take the simplest regression let us say um a is a function right and a is going to take an argument in integer if n is greater than Zer then let us say I want to print f I want to print F uh percentile D nus1 and then again I want to call a of n minus1 right so this a small recursive program isn't it why because the function a is again calling a now let's trace it out so there are two ways to trace it out I'll tell you the actual way I mean how it works at practice how the stack is going going to be used here stack is the data structure which is going to be used for recursion I'll show you how stack is going to be used in order to trace out the recursion first thing and next thing is without stack we shall use the tree method so uh when to choose what that depends on the type of the question okay let me just explain you this first now I'll take a stack and in this stack someone has to call this function right so initially assume that main is calling the function and you know inside the main let's say there is this main okay and inside the main somewhere a of 3 is called which means a a has you know a is called with the argument three now main will be created here right and while it's execution at this point a will be called so whenever any function is called an activation record will be created right this is the activation record for a of three a will be called with three so inside n the value will be three right why because a of three is nothing but the actual argument you are passing is three and the formal argument is n so it is a pass by value in C so what is pass by value we whenever a function is being called whatever is the value of the actual argument that will be passed to the formal argument formal parameter right it is actual parameter that is formal parameter now n is going to take the value three uh so n has the value three then it will check if n is greater than Z is it Greater than zero yes therefore what is the step print F and no print f percenti n minus one and then you are again going to call nus one what will be printed nus 1 will be printed therefore output will be two and again we are going to call a of n minus one so one thing you should remember is whenever we are keep you know keep when we keep on calling the you know functions again and again and when we keep on pushing the activation records you should always remember that while we written or when we written from the uh from the function calling you should know where to resume the function from you should know where to resume it all from right then what we do is that is the reason so because of that reason what we do is uh we have something called as instruction pointer IP so whenever you call a new function then for this particular function the calling function will save in its own activation record what is the instruction that it has to carry out next once it returns right so for that reason let me just number them so this is a small small example that you know we we have to number it and then do it it doesn't explain you but then still we shall we shall see let us say this is line number one line number two line number three line number four and even though it is not a line I'm putting line number six so that you know you'll understand that it's the end of the function now at this point see a of three has done with its uh you know printing and then it is calling a of two isn't it and once it returns from a of two the next statement it has to execute is five that is the reason I'll even remember this this is called as instruction pointer right instruction pointer is nothing but the next statement that has to be executed once you get back from the russion so you have to remember this so what will be present inside this tag of a function it's local variables and the instruction pointer what it now what about the next one yeah a of two will be called at this point a of2 will be called right so when a of 2 is called what will be sent to n n is equal to 2 right then what is then is n greater than zero yes then what is it print F percentile d n minus one right then how much is this print F percentile d n minus one means if n is 2 what is nus 1 1 and then a of 1 will be called which means this one will be called therefore we shall leave this activation record and push one more activation record on the top so when we come back what is the line we have to execute line number five so remember this in the IP instruction pointer right and what is the next one a of one is called when a of one is called what will be pass it to n n will receive one isn't it n will receive one now and uh you know this one is going to be n is greater than 0 therefore print f n minus one so what will be printed 0 will be printed and now a of n minus one so what is a of n minus one uh so now again a of n minus one means a of Z has to be called right so while I return I'll go to line number five a of Z will be called right and what happens to the a of Z check this a of Z is nothing but H uh a n is greater than Z no therefore it is going to stop so a of Z will simply return without doing anything right when a of Z has return where should we come back we should go to the calling function where is the calling function it will be immediately below the called function isn't it therefore I have to go to a of one and I have to start from line number five line number five is saying that it is the end of the function therefore this will also be over when this is over where should we go the calling function a of Two and a of two is also saying that we have to go to line number five which means it is also over right and after this again we have to go to a of3 a of3 is also saying that line number five which means it is over right and after this we to go to main so where should we go to main main also should remember it let us say this is I right then main also should have IP now main will continue from here therefore output is 210 and how many activation records are pushed or how how long is the how much big the uh you know stack is required 1 2 3 4 5 so totally five uh I mean for this entire function five activation records are pushed generally they'll not be interested in asking exact number of the you know iord pushed on this stag they'll be interested in asking the order right so what is it order of n isn't it if we are calling a function on a of n right in this case a of three then how many stacks are required 1 2 3 4 right four stack elements are required to compute a of three isn't it therefore in order to compute a of n how many stack stack elements will be required stack records will be required n + one which is nothing but order of n so the size of Stack required is order of n that is the space complexity then what about the time complexity time complexity can anyway do it right so T of n let us assume that the time taken to compute a of n is T of n that equal to how much so this is a constant time Printing and checking which means let's say c plus and what about this it is T of n minus1 right this is a Time complexity required all right and if you solve it right you are going to get how much I think you'll get around an order of n time complexity and space complexity both are going to be order of n anyway Computing the complexity is not my intention here explaining you how this recursion works is is my intention okay so anyway uh doing this you know doing this uh tracing out the recursion this way is this is the actual way how the recursion works but if the question if they ask you just to trace out a recursion then you know depending on the number of lines you know you can you can do it in a better way you can use the tree method so using the tree method how you could do it is um you know these are all not important what are the most important lines here print F and then this one so let us say this is print f is this and this is a of n minus one okay so only two lines are required then we shall go in the tree method so tree method says that a of three in order to solve a of three what do you need you need to call Print F first so print F what will be printed n minus one and then call 2 and in order to solve a of 2 again print f 1 and then call 1 in order to solve this print F1 print F 0 and then call 0 right and what about a of Z A of Z will will die here the reason is a of Z is not going to call this again because n is not greater than zero right so your equ will stop here so see this what is the depth of the three depth of the tree is you know n that is sorry n + 1 1 2 3 4 so that is why here we needed four therefore depth of the tree is also going to tell you how big the stack is required isn't it now how to trace it out see this way so first one is you Traverse it top down left to right and whenever you encounter anything printf you print it now what do we encounter print F2 therefore print two and again what do we encounter print one and again what do we encounter print zero yes and now this is how this one is done right so if you want to see the order in which the function calls are made a of three is called and then a of two and then a of 1 and then a of Z this is the order in which function calls are made and at any time how many maximum stack records will be present that will be equal to the depth of the tree this is the maximum length therefore how big this stack do we need at least you should be able to hold this entire chain got it otherwise your program will not be finished so anyway uh if the program is small so small like this only few few statements then you go with this method okay you go with uh stream method if the program is very big then anyway you cannot write all these statements like this if the program is having lots of lines you cannot write all the statements and then you cannot Trace them out like this right in that way in that in that case it is better that you go in this method okay stack method so depending on your convenience and uh you know whatever you like you can go with that fine and let me let me take one more example and let me show you how it works let us say I want to I want to use a tree method only so the program is a of n if n is greater than Zer I want to print FN and then call n minus1 and again I want to print FN right this is the program that I want to work on okay now how can we uh trace it out so let us say see how many lines are there just three important lines are there right then I told you that when we have only three lines it is better that we go with tree method let's go with Tree me let's go with threee method and see how it works H let's call this with a of three then a of3 is going to have three lines right so one line is print F3 and then call a of two and then print F3 and now again a of three is going to a of two is going to call three lines one is print F2 C why N means it is calling print FN are you following it a of n is calling print FN a of n is calling print ofn that is why a of n is calling print of N and a of n is calling a of n minus one that is why a of3 is calling a of 2 and again at the end a of n a of n that is why this right and a of one and print F2 and what about this a of one is calling print f 1 and then a of0 and then print F1 now what about a of0 it will stop isn't it now here also what is the size of the stack required just see the depth of the tree don't worry about the nature of of the tree either binary or turn know tary tree that depends on how many lines we have the number of children of the tree depends on how many lines we have because that is the way I designed it right now what about the depth of the tree 1 2 3 4 therefore what about the height what about the stack required four four elements in order to do this isn't it so space complexity is again going to be order of N and time complexity also you can you can just guess it so what is time complexity T of n equal to for this one this one this one constant time is required and for this one t of n minus one anyway it is again going to be order of n time right so now let's see what will be printed so in order to see what will be printed watch it so now here what we came across print F3 therefore 3 will be printed first and now a of two will be called and don't worry about what is called We Shall only see what is printed print F2 so two will be printed and then print F1 one will be printed and then zero it will be wring and again print F1 one will be printed and again print F2 two will be printed and again print F3 3 will be printed this is how you could trace it out all right okay now let's see one more example which is bit uh bit bigger let's do that let us say I want to construct this I want to trace out this function a of n if n is greater than Z then I'm going to call a of nus1 again print f n and again a of n minus one right don't worry about this syntax uh so now how many lines are there three lines are there okay now I want to see what will will be printed as the output fine so now in order to check this in order to check this so let's call this with a of2 when I call it with a of two I want to see what happens with a of two right so just see a of2 is calling a of one right and again print F2 and again a of one and what about a of one a of 1 is calling a of Z and print f 1 and a of0 right and what about a of 1 a of 1 is calling a of0 print f one and again a of Z right uh so now now watch it what will be printed initially one will be printed and then what will be printed two will be printed and then what will be printed one will be printed that's it okay now these are the only printing now how many function calls are made one 2 3 4 5 6 7 so do we need a stack which has seven elements not required the number of Records which are required which will be at in the stack at any time will depend on the height of the tree not in the you know number of function calls I already told you in algorithm so but then let me repeat it here even though we have seven function calls all the function calls are not present inside this stack at the same time all the activation records the number of activation records that will be present in this stack will be equal to the depth of the tree at any time the worst case number of elements so what I mean to say is see this now if you assume that this is this stag if you assume that this is this tag okay now initially what will be there a of two will be present in this tag fine and then a of two will call a of one right see the order in which the functions called functions will be called is depending on the traversal only top down left to right a of two will call a of one and a of one will call a of Z A of 1 will call a of Z right and now uh by this time whenever you see whenever you visit the function for the first time function node for the first time function call for the first time you can push a record and whenever you visit the function node for the last time you can pop it off that is how it happens which means you have seen it for the first time push it seen it for the first time push it seen it for the first time push it and seen it for the last time pop it right which means we are going to pop it off okay and then what about this one again we are seeing a of Z For the First Time therefore earlier wherever a was a of Z was there the second a of0 will be placed in the same place where the first a of Z was earlier there right and now this is the last time it is going to be visited therefore it has to be popped off so how many how many are required only only three uh stack records are required and only they are you know used here the reason is 1 2 3 three is the depth of the tree right and now next one we are visiting a of one for the last time here right so when you are visiting a of one for the last time that will be popped off right and again a of one will be visited this a of one will be visited for the first time which means it has to be pushed a of one will be pushed right and now a of Z is again visited so where will this be pushed see this is full this is full this is empty right a of Z will be pushed here right and this is the first time a of Z is vised so I pushed it and this is the last time a of Z is visited therefore it has to be popped off popped off right and print of one one is printed and again a of Z is visited therefore a of Z will be pushed right and what about this this the last time a of Z is wied therefore popped off right and what about this last time a of one is Ved popped off last time a of two is Ved popped off right so even though there are a total of seven function calls 1 2 3 4 5 6 7 but all the seven function calls are never present in this stack record at the same time how many are present at any time only three therefore what is the maximum depth of the or how many records are required in this stack in order to complete this execution three records right uh so anyway what is important here is to trace out not about this tag till now no question has been asked depending on you know how many stack records are required or how many function calls are required that is very unimportant but what you should really understand is how to trace it and what is the output printed that is what you should understand and one more thing is you know um in dynamic programming we have already seen it so whenever there is this excessive recursion which means a of one is being called so many times dynamic programming says that you see what is being done one time and then you don't call it if the same function is being called the next time you don't make that function call you you store it in the table and use that table and then see the result so in case if you use dynamic programming you can save some function calls that is how dynamic programming will be able to help us in reducing the time and uh you know anyway uh the time okay the time and the execution time required to finish it but then here my intention is not in introducing or you know saving some time I just want to tell you how it is executed I want to trace out a recursion function explain you okay so this is how a cussion can be done in case if there are less number of statements you go with the tree method if there are more number of statements then we shall go with this stack method and along with the examples whenever we I take up the example I'll just explain you again the recursion so recursion in this video I'm just introducing it but then don't think that it is over as and when any program comes I'm again going to take the recursion I mean I'll again take the rec cussion and show you how it works we shall do lots of examples okay fine as we have seen how to analyze or trace the recursion using two methods One is using the stack and other one is uh using the tree method see whenever the size of the function is too large then go with the stack method if the size of the function is too small and the main things in the function is only about function calls for example if you take a program like merge sort not the merge procedure M sort and similarly if you take the quick sort there most of the the main body of the program that just contains the recursive calls to the original function in that case it is always better to go with tree method and if you have a very big program and you are you know you are being called about this you know sorting at the end something like this I mean the recursion at the end or in the beginning only one line of russion and lot of other code is present then go with the stack method now apart from these questions how to trace the recursion some other questions which might be asked is see most frequently asked questions on recursion is it and find out the output that has been asked many times and the second type of questions which can be asked is only one time it has been asked the question is like this how many times a function has been called or one other kind of question is what is the time complexity and coming to time complexity I have already given you how to analyze the time complexity of iterative functions and recursive functions in algorithms but here I'll just touch that topic because we are already you know discussing about recursion I just want to touch it but the detailed analysis I did it in you know algorithms part so let me let me just show you uh how to find out the number of function calls in recursion let us say I'll just take a small example let us say f is a function and F of n right so don't worry about this syntax so F of N and if n = z let's say return otherwise let's say F of n minus1 is called and then print FN is done and again F of n minus1 is called okay so if You observe this this function this program is containing mainly the recursive calls right rather than having any other code so in this method in this case it is better that you go with the tree method so let's go with the tree method and try to analyze this and then I'll come back and show you how to find out the time complexity and the number of function calls so let's see what happens for f of 2 if you are calling for f of 2 say this F of 2 if n equal to 1 return so n equal to 0 written but it is not equal to Z therefore what are we supposed to do we are supposed to execute the three lines what are the three lines F of n minus1 which means F of 1 and then print FN which means print F2 and then F of n minus 1 which means F of 1 right and again this one see n is not equal to Z therefore again again three calls so what are the three calls F of 0 f of n minus1 is f of 0 and then print f one and then F of 0 and again three calls what are they F of0 print F1 and then F of0 all right and now if if you see this n is equal to Z therefore it will simply return it will simply written simply written simply written so that is how you can draw the tree and after that how to know which one is executed first Traverse it Traverse the tree top down left to right then you'll find out which statement is executed in what order therefore initially this statement will be executed F of2 now f of2 is going to call F of one F of one is going to call F of0 and F of0 will return and after that the second statement of this F of one will be executed what is that print FN are you getting this see now when n = 2 F of nus1 is called and F of nus1 is called when Nal print F of print FN is called isn't it that is why it is print F2 and F is one print f is one and here and here it is zero f is one print f is one and here and here it is zero are you following it okay now what will be printed print f one which means one will be printed and after that F of0 of this function which means this line of this function is called so one Beauty about this analyzing with the tree method is you need not remember which function you are in and which line because it is already clear there even without knowing that information you can directly do it right therefore F of0 and it will be returned and F of one it will be returned now print F2 therefore print two will be printed okay and again F of 1 is called and now F of 0 f of 0 will return return and now print F1 which means one will be printed f of0 f of0 will return that's it therefore what is printed 1 2 1 is printed that is okay we already know that how to trace it but my main question is how many function calls have happened here in order to analyze F of 2 how many function calls or how many times the function f has been invocated so if you see that the number of times the function has been invocated is 1 2 3 4 5 6 7 seven times the function has been invocated therefore they might ask you if we call F of 10 how many times the function is invocated so if you have to solve it it is bit difficult so one thing is maybe one one one small small thing you can follow is see this if F of 1 is called it is 1 2 3 three times it is invocated and F of 2 is called it is 7 times right and similarly if you find out for f of 3 it will be 15 times then you can directly say that it is 2^ n + 1 - 1 are you getting this one method of solving it is simple see this for f of 1 it is three times how do I get this three times because you see this F of 1 is called here and in order to execute this 1 2 3 three function calls are made and when F of 2 is called right now see this 7 1 2 3 4 5 6 7 7 seven calls are made and now when F of three is called you want to know how many how many calls are being made see this F of3 is going to call here F of2 and here printer and here F of 2 right and we know that this part is going to have s and this part is going to have 7 and this part is 1 therefore 7 + 7 + 1 is nothing but 15 so how do I know that this part and this part are seven because we have just computed it isn't it therefore by looking at it you can easily guess that maybe F of n is going to have 2^ n + 1 - 1 function calls isn't it therefore if you want to guess for to know this one 2^ 10 it is nothing but F of 10 is going to have 2^ 11 - 1 function calls straightforward so using this method you can find it out that is one way or you can even form the recursive equations and you can try to solve them so what is the recursive equation is now let us assume that the number of times the function f is called is f of n okay so the number of times the function small F of n is being called let us assume that we are representing it with capital F ofn so what does capital f ofn means it is the number of times the function f is called now what happens in function f of n we are going to call f ofn one time and inside it we are going to call F of N minus1 and F of n minus1 which means in order to complete the function f of n we are going to call this function once and then this function and this function now if number of times the function f ofn is called is capital F of n then how many number of times will will you know how many number of invocations are required in order to complete F of n minus one see again let me frame it clearly without any confusion what I'm trying to say is if the number of times the fun number of invocations required to execute function f ofn small f ofn is equal to capital F ofn then how many invocations are required in order to execute the function F of nus1 it is capital F of nus1 isn't it therefore the number of invocations required to finish the function f ofn is equal if it is equal to capital F ofn then the number of invocations required to finish this you know these two these two is 2 into capital F of N - 1 + 1 why this + 1 because one time already we are calling this function for that one and then for these two this function now if you solve it you can easily find out that uh the equation okay let's solve it so how can we solve that recursive equation that is an equation right recursive equation how can we solve it we cannot apply Master theorem because it is not in that format so let's use some other function so what is it uh back substitution this some other method not the function it is back substitution so now F of n = 2 into in place of f of n minus 1 I want to substitute it so before that let me write two more equations here if F of n = 2 into F of N - 1+ 1 in place of n if I substitute N - 1 then what do I get F of N - 1 = 2 into F of N - 2 + 1 similarly F of N - 2 = 2 into F of N - 3 + 1 got it fine now what I want to do is I want to keep keep on back substituting so what happens to F ofn let's call this one as equation 1 equation 2 equation 3 now I want to substitute equation 2 in equation 1 which means in place of this one I want to substitute this entire equation then let's see what we get then 2 into 2 into F of N - 2 + 1 + 1 which is nothing but 2^ 2 into F of N - - 2 + 2 + 1 got it now we have to substitute F of N - 2 so in place of f of nus 2 I'm going to substitute this this part from the third equation which is nothing but 2 2 into 2 into F of N - 3 + 1 already we have + 2 + 1 here so which is equal to 2 CU into F of N - 3 + 2 2 + 2 + 1 right now in general we can just generalize this this way F of n is = 2^ I into F of N - I + 2 power I -1 + 2^ i - 2 + so on + 1 all right now I have to get rid of this F of n- 1 so when can I get rid of f of n minus1 Only Cas is we know that from this function whenever n is equal to0 the there is constant time isn't it whenever n is equal to 0 there is constant time therefore I can write that F of n is equal to 1 when n = 0 right therefore whenever n equal to Z we are going to get one constant time constant time you can write with C or 1 not an issue let's go with one that way it will be simple now now uh F of this one if this one can be one then it will be easy for me if this sorry if this one is zero then it will be easy for me which one N - n- I which means if N - i = 0 it will be easy for me then what does it mean I = to n isn't it so assuming that I equal to n then if you substitute it here we get 2^ n into F of 0 + 2^ n -1 + 2 power N - 2 + so on + 1 which is nothing but F of 0 is already 1 2^ n + 2^ N - 1 + 2^ N - 2 + so on + 1 therefore this is nothing but sum of N + 1 terms from 2^ 0 to 2^ n there are n + 1 terms and the common ratio is 2 it is nothing but in GP if you start from here it is nothing but in GP and the number of terms is n + 1 therefore what is this what the sum is going to be a a is nothing but one a is nothing but this one right a into R power R is nothing but 2 total number of terms n + 1 - 1 / R -1 which is nothing but 2^ n + 1 - 1 got it so just be careful sometimes what happens is in this case if n = to one they will say return instead of zero they'll say n equal 1 they will say return then what should we do whenever equal to 1 the time is constant which means we have to try to make this one as one when we have to make this one as one what happens n- I should be equal to 1 which means I = N - 1 then here we get N - 1 which means we get from 1 to 2^ n - 1 which are just n terms in that case we get 2^ N - 1 so in this case in this particular case we got 2^ n + 1 - 1 therefore the total number of function calls which are required is nothing but 2^ n + 1 -1 now what about the time complexity so luckily time complexity can also be analyzed in the same way so see this in order to in order to you know uh execute this you can write the time complexity as if it is so 1 + 2 into time time required for this right F of n = to 2 into time required for f of n minus 1 plus one in of f you put T just to you know represent it as time then you'll find out that time is in order of n finally you'll get this factor which is in the order of n therefore the number of order of 2^ n therefore the number of function calls required or the time complexity is both going to be order of 2 power n in this case but then what about the space complexity for this space complexity will simply be order of n because see this the depth of the tree is always order of n that is the space complexity because in this stack we are never going to grow Beyond this so there there will be two will be called here one will be called here and Z will be called here after 1 Z is finished next Z will be called here after that next Z after that next Z like this right and after 1 one is finished one will be called here like this right therefore many functions are going to take place in the same record which are all of function zero right which are all having the argument zero and all the functions which are having argument one will take place here that is why space complexity is order of n right it is not going to be Beyond n so this is how you can find out the number of function calls as well okay so now keep this an analysis in mind later when we discuss about some other examples you know I'm not going to do all this analysis I'll try to Simply get the answer okay fine now let me explain you about single link list generally a single link list will contain nodes and these notes are generally structures and which are self referential self referal means every structure will have a pointer inside it and that pointer will point to the structure of same type so watch it see struck node which means there is a structure which is having the tag node and which has inside it uh two declarations one is car data some know data is present as a character and along with it struct node star link which means uh we have a pointer which is pointing to the structure of same type okay and generally we declare many we we try to dynamically create many structures and then we link them with one another like this so we can create many structures like this like you know here I have shown you six structures and then we can see that there is a pointer or there's a link between one to the other which means if you can reach this from here you can reach this from here you can reach this right so generally this is called as single link list it is called single link list because every structure is having only one link right so one link single link single link single link and we can only move in One Direction not we cannot come back and it is called as single link list so what is the advantage of having a structure as a data structure is you know uh one other alternative which you can go for is arrays so arrays and structures are the two popular you know data structures which are used to save the information either it's the input or you want to take it as the output then what is the main advantage of structures is coming to C arrs cannot be created dynamically we don't have Dynamic are Creation in a C programming language therefore if you don't know I know well ahead what is your requirement then you leave it to the structures so using structures the advantage is we can create the data structure dynamically but using arrays we cannot create it dynamically your need has to be static got it so now what I mean to say is here so on the go if you feel like you need one more element you can create the element and add it in the link and on the go if you find if you find out that you don't need some of the links some of the notes you can anywh free them up right uh so let's watch it first one is uh see this is the structure which is used to create that and in general there will be a pointer head which will be created initially which means like this struct node star head so every link will have a you know pointer which is going to point to where the link is starting from where the link list is starting from so without this pointer you you will not be able to keep track of everything got it and if you watch this this is a pointer to the structure of type node right and what about this head head is a pointer to this right generally always we have a handle handle means this pointer which will give you the access to the first element and once the first element is given you can go on searching the link and we can get into any element unlike arrays uh the link list are sequ not sequential sorry sequential access structures sequential access means in order to reach an element we have to start from beginning and we have to go to that element that is called sequential access coming to arrays arrays are Dynamic access Dynamic access means if you know the uh you know Base address right you can directly go to wherever whichever element you want how is it possible in arrays because it is possible because arrays are continuously allocated therefore if I know the base of the array I can get into any element by adding the offset right which is given as the index so it is very easy to get into any ARR directly but then if you know the head head pointer of the you know link list you cannot go into any element by adding some distance by adding some offset the reason is there is no guarantee that every element is at equally spaced from the head so they are dynamically created and they can be randomly present Anywhere But Here we know that all the elements are present at a distance of you know size of the element into number of elements right they are all contous here it is not the case so the one disadvantage of Link list is even though it is possible to allocate it dynamically the axis is sequential therefore searching for an element might take a long time if you want want to search for an element in this array this know uh structure it might take order of end time in order to find it out even though you know that you know the location of the element let us say you want to find out the third element even then you have to se you know Traverse it from first second third but then if you know that if you had to go to the third element in Array you can directly go to third element in one step so going to any particular element number in Array is order of one time but going to any particular element number I mean element number means the you know first element second element third element like that going to any particular element number in structure is going to take in this link list is going to take order of end time okay and searching any way is going to take order of end time either in Array or in the uh you know link list provided that array is unordered if the array is ordered binary search can be know impli applied but then if the elements are not ordered it is going to say it Tak same time okay so anyway let's observe this question and this question is all about this indirect selectors this arrows arrows right and you know that arrows have the highest precedence which means they'll be in the top row and they are left to right associative which means when you have many arrows many indirect selectors in the same uh in the same expression then we have to evaluate it left to right okay so when whenever see they have given these lines 1 2 3 4 five lines and in the Fifth Line they are talking about the print F so you are supposed to implement all this and then you have to print it right whenever such a question is given it really helps if you can write uh some numbers in the pointers which means it is it is better that you imagine every node is having a location some number and it is better that you put that number you know inside the pointers so that we can use the numbers while we are you know trying to evaluate this so assume that the starting address of a is 10 starting address of B is 20 like this 30 40 50 60 these are the starting addresses okay the addresses of the structures so this structure is stored starting at 10 the structure is stor starting at 20 it is just an assumption okay and now what will head contain then the pointer head will contain 10 what will this node contain this will contain 20 isn't it what will this one contain 30 which means it will be pointing to this what will this one contain it will contain 40 what will this one contain it contain 50 contain 60 got it so that is how you can you know you can place all of them so now let's watch it P equal to which means they have created a new new pointer P which can point any of these nodes p is a pointer to the structure of type node P equal to head so what is head head value is 10 right head of Link head of Link means whatever head is pointing to we are inside that so inside that is 20 this head of link is 20 are you following it now 20 means now this 20 of Link means whatever 20 is pointing inside that right so this entire value is now 30 see try to understand this what is head value head is 10 initially now head of Link L is 20 head of Link means whatever head is pointing to in that the link value is 20 and then head of link of Link which means 20 of Link whatever 20 is pointing in that the link is 30 now P will be equal to 30 so when you write P equal to 30 it is as good as p is pointing to this got it next one now watch it uh so what is the this one p so again p is 30 right then what about P of link so P of Link P of link is 40 this entire thing is 40 and what about 40 of Link 40 of link is whatever 40 is pointing to in that the link value is 50 right and what about 50 of Link 50 of link is 60 right so uh whenever you you are talking about the left side in the left side we are not worried about the value we are worried about the location which means in the left side what is this completely pointing to this is pointing to this particular element isn't it okay and one more thing how did I evaluate it I evaluated left to right which means I evaluated this one first right and then this one and then this one that is how I evaluated see what is p p is 30 right 30 and what is p of Link P of link is whatever p is pointing to in that the link value which means 40 now the center value is 40 now what is 40 of Link 40 of link is whatever 40 is pointing to and in that link link which is 50 and what is the 50 of Link 50 of link is 60 but I'm not worried about the value because it is present as the left hand side whenever you are present in the left hand side you are worried about the location not as the value which means we are talking about this location that's it right and now this location should be equal to P which means we should set this this particular location equal to P what is p 30 so we are going to place 30 here now what happened because of this it is going to 2.2 C all right this link is no more so this is permanently lost that 60 is permanently lost there is no way we can recover it okay and now look at next one so head of link so what is uh okay what is head head is 10 right so head is 10 head of Link head of Link means again we are talking about the left hand side so whenever we are talking about the left left hand side we don't want the value of that we want the location right head is 10 head of link is whatever head is pointing to in that the link value which means this one head of Link this one equal to right let's evaluate this so this one has to be initialized to something here P of Link what is p p is 30 right and what is p of Link P of link is 40 which means head of Link should be equal to 40 are you getting this p is 30 therefore I'll be here and P of Link means I'll be inside whatever p is pointing in the link which means 40 I want the value therefore here 40 will be placed right therefore this one is going to point to this got it okay which means this one is no more now this is how it is altered so because of these three lines the entire link list has been altered like this right and now what we want is we want to print the uh print something so see what we want to print here print head so what is head head is 10 okay head of link so what is head of link so head of link is 40 here right so this entire thing is going to give me 40 and next one is 40 of link so what is 40 of Link whatever 40 is pointing to in that link so which is 50 right and this one is 50 of Link what is 50 of Link whatever 50 is pointing to uh so yeah where is 50 yes 50 is pointing to in that link link is 30 right and now 30 of link so whatever 30 is pointing to 30 is pointing to this 30 of link is 40 right and 40 of data whatever 40 is pointing to which means 40 of data is D therefore D will be printed okay you understand this I'll do it one more time this last one observe this see with practice it will be very easy maybe you have to watch it two three times it'll be easy only don't worry so what I mean to say is see what is head head is 10 therefore 10 means this one and what is uh you know 10 of Link which means whatever is present at the address 10 in that whatever is in the link so which is 40 right and now we are in 40 40 means we are here right so 40 of link so 40 of Link means in this 40 node whatever is link which is 50 50 means we are here right and again 50 of Link 50 of Link means 30 right and now we are at 30 so 30 right and now 30 of Link 30 of link is 40 and now 40 of data so 40 of 40 me here right 40 of data is D so finally what they wanted is D what will be printed as output D got it D is the answer fine on any link list we generally perform three basic operations so one is traversing so traversing means we want to uh you know Traverse the entire list and maybe one example is print all the elements of the list right and the second one is uh we create a new node and we insert it so inserting and the third one is maybe we feel that some notes are not required and we try to delete it right so these are the three basic operations which we try to perform on any link list let's take an example of Link list and then we shall see how to do it uh let's say say link list is made of of the of the nodes like this structures like this struct node inside it there is an integer I and then struct node star let's say link so it means that our nodes are going to contain two elements one is an integer and other is a link link to the structure of same type and let's say we already have created a link and the link ising like this it has four elements okay and then I made the appropriate initialization so that they will Point like this the first one points to this and then I have a head so always we are going to have a head which is going to point to the starting one if we don't have this there is no way we can find it out see one more thing if you don't have this head then also we could access them given that they are created using the names which means if you create them as a local variable not as a you know dynamic data structure not using mlog then you can anyway have this names and names can be used if they are having names you have the handle you can access them but most of the cases wherever you go with the structures and Link list we create them dynamically and whenever we create them dynamically there is no way they have the names only way is you should have the uh these addresses and you should save the address somewhere if you lose that address it is as good as losing that node okay so now let's see how to Traverse it so the last node will always contain null so null means zero it is not any new value it is generally null means zero okay and let us say the value present here is 1 the value is 2 3 4 now I want to Traverse this entire list and then I want to see uh what is the value I mean what are all the values present in this so how can I Traverse it is so watch it see one thing is you can have have this uh head and you can take this you know first and then print it and then take this print it and then take this printed which means you can keep on moving the head and you can print it but moving the head pointer is really dangerous because once you move the head pointer to point to this node then this node is permanently lost in case if it is not having any name and if you have created it dynamically using mlog once you move this pointer this one is lost that is why you create a temporary pointer so we can have like this struck node star some temporary pointer T it means that it is a pointer which is it is a pointer to a structure of type node and now using this temporary pointer I can move which means I can take tal to head what does it mean it means that initially I have a t i mean a temporary variable T and T is also pointing to whatever head was pointing to right and now using this I can keep on moving and then I can keep on printing now what I'll do is I'll try to print T of what is it t data which means whatever is going to be in the data I'm going to print so don't worry about the syntax so let us say this is print printing right so I'm trying to print whatever is present in t right okay let me write it perfectly then I'm trying to print print F percentile d right new line whatever is present in this you know data pointed by T So T is pointing to something some node in that whatever is present in I I want to print so what will be printed because of this one will be printed then I should go to the next one and I should print it right so that is the reason I'll move t to the next node so what I do is t equal to T link T link so what does it mean so now T value will be whatever is present in the T link so let me just number them so I told you numbering is you know going to be helpful here let us say 10 is the address 20 is the address 30 is the address and 40 is the address of all this and initially this one will contain 10 this one will contain 10 this one will contain 20 this one will contain 30 this one will contain 40 right so now T of t equal to T of link so whatever is pointed by T go into that link and now take that value T of link is 20 now initialize t equal to T of Link which means this one will be pointing to this one will get 20 therefore now this one will point to 20 right and again I have to print it again I have to print it and then again I have to increment it that is why I'm going to put it in the while loop I'm going to put this Printing and incrementing in the while loop right so while what so till what point can I go till while T is not equal to null right T is not equal to null I can null means the zero value right so as long as I don't reach the end I'll keep on going right now just see this how it works now initially it has been one has been printed right and then tal to T of next means T of Link means it has taken this and now what will be printed again two will be printed right and after this tal to T of Link tal T of Link means whatever T is pointing to it will take the link from that which is 30 and we put it in this so which means we get 30 here right so it is again pointing to this right and again printf this data that I3 will be printed and again t equal to T of link so what happens T of link is 40 and that 40 will be placed in this T so which means 40 right and now we'll be pointing to this right and what happens again T is not equal to n therefore again print of this so what will printed four and again t equal to T of link so what is T of Link T of link is null therefore in inside T we are going to put null right so finally it is going to have null then watch it while T is not equal to null but T is equal to null now therefore it will break the loop right so this is how you can print the entire entire link list right so one other way of writing this is right see whenever you write any Loop like this while T not equal to null then where is that you are stopping you'll stop we we'll go to this node and then we'll take this and we'll stop there so we are not pointing to anything at the end okay so anyway one other way of writing the same statement is while T is not equal to null is equalent to isn't it this one is equalent to while T right this one also has the same meaning why as long as T is not not equal to Z we get into this and whenever T is z which means whenever T is equal to null we break the loop and we come out so this two are going to have the same meaning while T not equal to n and while T both of them have the same meaning got it so this is how we can Traverse the entire list so traversing the list can be done using this Loop and one thing you should remember is never take the head and keep traversing the list what happens is you can Traverse the list but by the end of it the list head will will become null and the entire thing will disappear right so don't do that you take a temporary variable and you can Traverse it fine now let's try to insert an element in the singling list so before you insert any element you are supposed to create it how do we create a single I mean element in a node a structure using mlog so let me show you how to create this I already shown you using this m you know mlog how much uh what is the size of the node that we want what is that we want to create we want to create a structure by name node isn't it therefore first you try to find out the size of the structure in your platform in your operating system and in your Hardware right then that is called platform so in your according to your operating system and platform let us say there is some size fixed so that one you can get it by using the you know operator size of size of is not a function called it is an operator okay so size of struct node why because I want to create this right and now this one I'll send it to the mloc so mlog will take as argument this uh this one right then what will mlog do mog will create memory of size of this structure right and mlock will generally return you void star so whenever it returns you void star you are supposed to type cast it type cast it to what you have type cast it to the pointer of type you know uh the node structure node therefore I'm going to typ cast it struct struct node star I'm going to type cast it right and now this typ casted one has to be captured and stored somewhere right so let's say I create a pointer s r u c struct node Star new so what happened because of this a a pointer called new is created okay a pointer called new is created and this new will point to a structure of type node and because of this ml call a new structure will be created isn't it that structure will contain uh the I and Link two values two uh two members two members are present in this structure and now inside this one is going to point to this that is what has happened till now right so whatever address is written by this mlop that address is captured here let us say the address is 50 then it will contain 50 which means we are holding that uh handle which means we are having a grip over where that uh particular element is present now I want to insert this new element somewhere in this let us say I want to insert at the beginning Case Case one is a insert it in the beginning insert it at the beginning so which means I want to insert it before this value right now how can I do it so one thing is if I have to insert it here then head has to point to this node right so which means if I have to insert it here so let us say it is created here I mean the placement doesn't matter but then it looks good if I write there isn't it and Now new is pointing to this new is pointing to this and its address is 50 right and now if I want to insert it here then what I should do is I should make sure that uh you know head should point to this but if I directly write this code initi if I directly write it as uh head equal to new which means whatever new was pointing to if I directly write head equal to new what happens is this will take the value 50 and suddenly this will point to the this now this head will point to this one and this entire one is lost isn't it the entire link list is lost so you should not do that so in order to see that this uh information will not be lost you should be very careful here whenever you try to modify the head pointer you should be careful so initially it is pointing to this right now before writing this step what are you supposed to write is you are supposed to link this one with this one and then you can link this one with this one then that will be fine so in order to do that so how what is this value this value is New Link isn't it so first step should be new link isn't it new link which means New Link this value should be equal to head which means I should get a 10 here right so new link should be equal to head so if I write like this if I write like this new link equal to head then what happens is you know this one got linked to this and after that you could say head equal to new head equal to new so therefore this one will point to this right so that is how you know you have made the first node to be this and you can you can even you know initialize some value that is okay you can put any value do you understand this so in thing is first you you make the new node to point to whatever is the beginning of the list and then you make the head to point to that then only this enter thing will work the other way will not work that is where you should be careful about right and next one is let's see let us say we want to insert the same node that new node not at the beginning but at the ending okay which means this is going to point to this itself right and there is no link as of now I want to uh place it at the end so case b is insert this at the end okay now how can we insert it at the end so one thing is in order to insert it at the end we should know where the end is right so if we have to insert it at the end we should we should place it in such a way that this particular pointer will point to that node right so we have to find we have to go till the end and we have to get it now how can I go till the end I told you so I can write a while loop right so while T not equal to null what is t t is a temporary variable you can create it struct node star T and we can initialize t equal to head which means T is going to start from the first node and then while T not equal to null which means it will go till the end right while T not equal to null if I write tal to T of next only one line in the uh I know this Loop then what happens is this T will be initialized with head right this there will be a new note T and T will be initialized to this and it will continuously move like this move like this move like this and finally it will become null so by the time you break out there will be null so which means will not point to anyone therefore you should not write like this where should you exactly stop you should exactly stop if you if you're starting from here if you starting pointing to this you should exactly stop when you point to the last node so only when you point to the last node you can make this node point to the new node right then you can add the you know required element at the end how can I make sure that I'll make this t stop exactly at the last node I I to write a different while loop here right in the while loop I should not say while T not equal to null what is what I should do is while this element if I'm pointing here then what will be the next T of next isn't it while T of next not equal to null if I write like this the you know this T will keep on incrementing keep on incrementing till the point where this uh T of next is not equal to null which means if I write like this and if I keep on incrementing we'll exactly stop at this point if you want to see how it is happening just watch it I'll just show you see now initially t equal to head isn't it now while T of next is not equal to n initially t equal to 10 watch it while T of next not equal to null is T of next equal to n no therefore we get into it tal to T of next which means whatever is here t Al T of next which means 20 T of next is 20 so this will be made 20 and now you are here now again you will check the while loop while T of next not equal to n is 20 of next equal to n no it is not equal to n therefore t equal to T of next which means this t equal to 20 of next which means 30 30 will be here again we'll come into the while loop right while T of next not equal to n is 30 of next equal to n not equal to n therefore we get into it and again tal to T of next so what is tal to T of next uh you know um this 30 of next is 40 which means this will be made 40 and again we check it right while T T of next not equal to null is 40 of next equal to n yes it is equal to n therefore it is where we are going to break so finally when tal to 40 we break this therefore we'll be standing exactly at this point or we got the axis of the Lost element so by the end of this Loop the temporary variable T will contain the value 40 which means it will point to this got it that is the meaning of it now what are we supposed to do we are supposed to add the newly created value after this end so how can we add it now we can take this uh uh you know t t is the end one right so T of next T of next equal to new if I write like this then what happens this T of next will now contain new value new value is 50 which means this one is going to point to the this one therefore now look at the link list now the link list has been added with the one more element at the end now we can make sure that this one this last one is null so in order to make sure that one you know whenever you create it it is better that you do it immediately right new of next oh I think we are I have been using next right so here it is link let's say this is next which means the link is uh no next so new of next so what is new of next yeah so new of next means this one new new of next should be equal to null always right got it so either you can write null or this one it is okay right so now this is how you could um actually add a element at the end so what is that should remember in this you should never go beyond that uh you know lost node if you try to write in this code while T not equal to null you will end up at a place where T will give you null right so you should not go till that point you should stop exactly at the Lost node how can you distinguish in the Lost node you can distinguish it only when by by using this condition what all the other nodes will not have t of next is is as null only the last node will have t of next equal to null therefore you are supposed to go till the point where T of next equal to n that is why this while loop is written in such a way that as long as T of next is not equal to n we keep on going forward and whenever we hit a point where T of next equal to n we stop there which means we are stopping at the Lost node got it and one other way of writing this is this is equalent to this while this is equalent to this while T of next you can write like this right now what is the meaning of it both are same T of next is not equal to null or t t of next both are same isn't it so whenever T of next becomes null this while loop is going to break and here also whenever T of next becomes null this while loop is going to break as long as T of next is not equal to n which means as long as the element is not the last one we keep on moving forward got it so once we keep once we go there we can add it understood this fine now let's try to insert a insert the node after the node which we want okay so first thing is maybe if they have already provided you the link so let us say um we have created new node and assume that the new node is this newly created node and then we assign the value of the newly created node to five and uh this is null okay as of now and this is B being pointed by new the pointer new right let us say it address is 50 and here it is present as 50 now we want to uh insert this new node after after the uh node which is pointed by this T there is one more poin at T which is pointing to this node and now we want to insert uh this new node not at the beginning or not at the ending but then we want okay so ending is this we we we don't want to put it not either at the ending or at the beginning we want to place it in the middle right after some intermediate node let us assume that this intermediate node point is already given or you know sometimes maybe they might ask you to insert it after the node whichever you want let us say they are saying that introduce it after the newly created node is this you have to introduce it after the node 2 then you are supposed to Traverse the link and then find out where the node 2 is present and you are supposed to stop there right so how can you stop there see this now you can say you can create the new let us say this is not given now the question is uh insert this newly created node after the node which is having a value two now we are supposed to Traverse and then stop at the node whose value is two and after that two you can insert it assume that all the values are distinct here right then struct node star T which means a temporary pointer is created which is going to contain initially the value head which means I created a new temporary variable T and which is going to point this one to this one right and now I'm supposed to Traverse and find out a node which is going to contain a value T therefore how long should I go how far should I go I should go as long as I don't find a note whose value is T therefore while T of I isn't it integer i t of 5 not equal to 2 which means as long as I don't find the value two as the data I'll keep on moving forward right tal to T of next since I have only one line in the while loop I need not put the braces right so what is the meaning of it I'll keep on moving this t as long as that value the integer value of that particular node is not equal to two and then when will I break when will I when will I stop I'll stop this Loop and come out only when T of I is equal to 2 as long long as T of I is not equal to 2 I keep on moving forward then what is the meaning of it initially T will be pointing to this then tal to T of next which means see this okay the condition is while T is not equal to 2 is T is T of I equal to 2 no T of I equal to 1 right therefore tal T of next which means this will be incremented tal to T of next means in this value this T of next 20 will be placed right which means I'll be pointing to this right and again this will be tested while T of I not equal to 2 is T of I equal to 2 yes 20 of I is equal to 2 therefore at this point we break we don't increase we break and we come out of the while loop right and after coming out of the while loop T is pointing to the node exactly whichever is needed whichever is required therefore I want to insert the newly created node after this particular node then how can I insert it see now T is pointing to the node after which we have to put the node which is pointed by new now what are the sequence of actions that you have to think about so think about it so till this point we reach the node after which we you know insert it you think about it uh first of all if this node has to be inserted in the middle this particular pointer has to point this and this particular pointer has to point this isn't it that is what we really think I mean we generally think it that way this one has to point this and this one has to point this then what will you try you'll try to do that t of next which which means whatever is pointed by T T of next you'll try to make it equal to uh you know new which means you try to make this one as 50 therefore this one will be 50 and so this one will point to this right and now you'll try to point this one to this but then even if you try to do that by this time this entire thing is you know gone there is no way there is nowhere you have have saved the value 30 in this entire thing see what are all the POS what are all the handles you have what are all the variables you have you have t you have new you have head but all of them together they don't contain anything pointing to 30 so if you try to do this this entire list will be gone so don't do that even though this one has to point to this and this one has to point to this first you see that this one will point to this and then you make sure that this one will point to this so that is why writing like this is wrong completely wrong so what are you supposed to do leave it like this 30 itself and leave it like this right now you see that you know this one first points to this and then this one points to this how can I make sure that this one points to this so this is new of Link isn't it New Link new link it should point to 30 what is 30 T link New Link equal to T link so if I write like this if I write like new link equal to T link then what happened is uh this uh this particular New Link here this is going to point to this got it which means 30 will be here right and now next line you make sure that this one will point to this so so how can I make it sure then tlink so this one is nothing but tlink isn't it tlink should be equal to new right so if I write like this T link should be equal to new which means this link will be equal to new new is 50 right which means this one got it so this is how we have inserted this newly created element in the middle right so e you know you can you can insert it anywhere you can insert it at the beginning or you can insert it at the end or you can insert an element in the middle right okay this function is iterative version to reverse a link list sing link list it is not just printing it is reversing so reversing is different which means the entire structure of the link list is going to be changed it is not what we see in the output it is what how it is actually stored right everything has to be changed and you know the assumption is that or or you know it is given that the notes of each each list the notes of the list are actually made of the structures right which means they have integer field and then they have a pointer which is called Next which is pointing to the which is going to act as the pointer in the structure okay so every every structure is having a member called Next which is a pointer to the stru node Star right and then this particular function is written so reverse see don't byard this because they might change the code there are more than one way to I know do the same thing so there are various functions what I want you to do is trace it out and understand how the program is working so how can they ask it in gate is they might miss out one of the lines and they'll give you a blank and you are supposed to fill it that is how the questions will be they they're not going to ask you to write the complete program right even if ask you to write the complete program in interviews there you know you can uh you can write it on your own you need not write the same one you can you can just see how it works and depending on the logic you can just get it so let's see the logic first okay so now this function is going to return a pointer and it's going to take a pointer so how will this function be called is from the main from wherever it is being called it will be called like this so you know reverse we want to reverse a link list then head will be sent to this which means from where you want to reverse the link list right if this is the link list okay uh then this particular pointer of this node will be sent right which means you want to reverse the entire link list pointed by this pointer right so reverse head so head will be passed and once you reverse the head this one will become the new head that is why it will be even saved in head which means once you send this you should even capture it why because now the head is going to point to the different thing right so if you still point to the same one as earlier after calling the reverse then what happens is the entire list should have been modified and now this turns out to be the last one see now this one becomes the first one this one will point to this this one will point to this this one will point to this and these links will no longer be there right and if you don't capture this or if you don't change the head head will actually be pointing to tail so the function is going to return a pointer to this node and you are supposed to update your head with this node which means here head has to change here got it then it will be reversing initially if it is a b c d in this order then after reversing it will be DC Ba got it okay now let's see how it is it is going to get executed so first one is stru node okay so let's talk about the logic first and then I'll tell you the explain you that so the logic is this see if we have to reverse it let us say the links are like this if you have to reverse this this one is going to become the last one so this one is going to be like this and now this link has to point backwards right but the problem is if you directly go here and directly change this link to point to the back one right this entire list will be cut off isn't it now there is no no way you can again cat this list if you simply make this point backwards this entire list will be cut off right so that is why we are going to maintain three variables one variable is going to talk about what is the current node you are you are working on and the other variable is going to see what is the next node right next node and the other variable is going to see what is the previous node then what we do is since we have already know caught hold of the next node we are going going to now make the current next point to the previous one so there is no danger of losing it then what happens next time I'll move the current here right so the current node will be pointing to this and the uh you know next node will be pointing to this and the previous node will be pointing to this right so I'll use these three pointers so that you know once I have the grab of the next node I can make the current nodes next point to the previous one so this is the logic which I'm going to use I'm going to have three pointers and three pointers are going to move you know along across the list in such a way that next node is always going to hold the remaining part of the link list and current node is going to hold the pointer to the uh present list present node and then previous is going to hold what is the node which is exactly behind the you know current one see why should we have previous because if you I'm standing here with with this know I can I don't know what the previous one is I can only know this one right that is why previous is important why is next node important because once once I make the current node Point backwards this entire list will be gone that is why next not is important that is why I'm using all this okay fine so now we are going to use three variables if I if I would have written the same program in recursive version I'll show you later the recursive version we need not have these many variables the reason is in recur the beauty of recre is a single variable can hold the you know can have multiple copies and so it can hold multiple data at various times right which means the same the same variable can be made to hold a different uh you know information okay in in when I talk about the recursive version it will be even more beautiful you'll understand there for for now just work on this so how to trace it out take the example and let's trace it out let us say there are four notes like this 1 2 3 4 is the data and the address is 100 200 300 400 and head is uh pointing to the starting one which means this one and the address in this is 200 address in this is 300 address in this is 400 and address in this is null which means this is pointing to this this is pointing to this and this is pointing to this okay and now uh watch it so when this function is being called head will be sent to the current which means the variable current sorry the pointer current CU C so current is C I just use the name c see even I use the names current previous and next note so that it will be meaningful for you and understand I could have you know used p and then TS you'll not understand it so just understand this next node is used to hold the address of the next one previous is used to hold the address of the previous one and the current is used to hold the address of the current one okay and see so current is going to point to this one that is initial right so whenever I call this with head then current is going to point to whatever head is going to point which means this will contain 100 I'm not I'm just not writing the numbers I'm just using this arrows to show you what it is currently holding and next previous and next node I have one more pointer which is previous and I have one more pointer which is next node right fine both are holding null initially null and null right now while current which means current not equal to n yes current is not equal to n current is point to something then next not equal to current of next which means you hold in this next node you point to what the current of next is pointing to the reason is we are going to modify the currents next if I modify this this entire thing will be gone so just hold it as of now hold it for some time okay that is what we are doing and then current of next equal to previous we are now modifying this we are modifying this to point to the previous node since there is no previous node for the first node right we are going to have previous as null therefore it is null initially previous equal to null because there is no previous node to the current node that is why previous was set to null and now it is going to be set to null why because after I reverse the list the first node is going to be the last node and the last no next pointer has to be null hope hope that you're getting it okay I'm fine now where are we yes so current next equal to previous and now previous equal to current now we have to move everything forward right that is why previous equal to current means previous you just point to this because now this one is going to be previous because current is going to move ahead right and current equal to next node which means I want to go and work at the next one the reason is this this one is already being modified right now I have to modify this one I have to see that this one points to this okay and now again I I I'll try to enter the loop while current is current not equal to null yes it is not equal to null therefore we enter then next node equal to current off next which means before you modify it make sure that we hold the remaining of the link list right uh next not equal to current of next and what about this current of next equal to previous so what is current of next current of next is this one it is equal to previous what is previous 100 which means since we have already we are already holding this now we can make this one point back right so this one is going to point backwards which means this one is holding 100 now got it this one is already over so I'm I'm just trying to reverse it see the way it works okay and now I just modified this and previous equal to current so what is previous again these three have to move forward right so previous equal to current means now you go and point this one right and current equal to next node which means you to point to the next one I want to work on this this is over now I want to work on this right and again I'll try to get enter it so is current not equal to n yes current is not equal to n therefore I'm supposed to work on this right so when I have to work on this you you make sure that you hold the next one that is why next node equal to current of next which means now the next node is pointed to the current of next right and current of next equal to previous so we know this is a previous so current of next means this one this one has to point back right which means this one has to point back current of next is now going to hold 200 which means I'm going to point back right and previous equal to current which means again I have to move everything forward so previous equal to current means previous is going to point to this node and current equal to next node which means since this is done you have to go and work in the next on the next node fine right and again I try to enter it so current equal to current of well current is current is point to something it is not equal to n therefore I to still work on this next node equal to current of next make sure that if there is anything you know remaining you hold the pointer of that since there is nothing remaining what is current of next null the next node will be made null so this one will be made null got it this one this one is made null right and now current of next equal to previous whatever this one is pointing current of next it has to point to previous one which means what is the previous 300 which means this one will be pointing to this right and previous equal to current so this previous everything is now again shifted and current equal to next node what is current next node next node is null therefore current is null which means we have modified all the nodes now again again we try to enter the while loop now while loop is just trying to see if there is any more noes to be modified but since current equal to null it means that all the notes have been modified no more notes are remaining right so at this point no more notes are remaining okay so you can stop actually here so we can stop here uh that is why see while current means it is checking while current is not equal to null but since current equal to null it will return false and therefore this while loop will break and we are going to return previous so what is return the previous what is previous here 400 now 400 will be returned to the calling function therefore the calling function is supposed to call you know head equal to reverse then in that case since we are wring 400 that 400 will go into the head which means 400 here so that is how you can point to this now watch it so what is the first node now four what is second node three what is third node two what is fourth node one and that is null right the entire list has been n you know reversed initially it is 1 2 3 4 and head is pointing to this now head is pointing to the last one and last one is pointing second L third L fourth loss like that all right that is how this function is going to work you know um maybe see I have I I tried to simplify this function a lot and even I worked on the name so that it will be easy for you to understand but then iterative functions are sometimes not sometimes most of the times difficult to write and difficult to read and understand but if I write for the same program a recursive version it will be very easy to understand and will very easy to write also and it will look really beautiful uh so next we shall see the recursive version you'll really like it okay data structures are very important to organize the data so what is the data structure is generally uh whenever we talk about any algorithm algorithm is nothing but we are trying to solve a problem then the problem should take some input and then the problem is going to create some output isn't it so the input and the output should be given in some format right that format is called as data structure and you know depending on the format in which you give the input to the you know program or the algorithm the time will vary for example if you're trying to search an element and if the input is given as a sorted array then the time time complexity will be lesser isn't it so if the input is given as unsorted array then the time will be more right so like that depending on the data structure your algorithm's efficiency is going to vary right and one of the most important and the uh you know very old data structure is stack so initially how this stack was designed is you know people have seen this drum so earlier what used to happen is they used to have this uh uh plates made of glass I mean the dining plates made of glass and they used to be kept one after one above the other on a pile and they used to to keep them on a table and very often it so happens that you know someone will try to take a plate and by mistake they'll just push it and all the plates will fall down and they get broken so what they did is in order to solve this problem they came up with an idea of a drum okay so they have kept they have taken a drum and in this drum they have kept a spring and on this spring they have kept all the plates like this one above the other right and they kept the plates one above the other and now this spring acts this way if you pull out a plate from the top of the drum then you know the spring below will push the plates so that the next plate will come on the top and in order to sterilize this plates what they did is they wanted to keep this drum very hot because you know you know that so when when we heat them they get sterilized right so they used to keep this drum hot which means you cannot put your hands down the drum you can only take the top plate so top plates is only reachable right so if you if you see the way it operates we can push the plates from the top and take the plates from the top right so the same way you know stack is organized in stack also you can push the data from one side and take the data from the same side you cannot uh you know push the data from one side and take it from the other side this is how stack is organized so there are various applications of Stack I'll just list out few there there are lots of applications you can come up with lots of applications but I just list out a few okay so one of the application is uh you know you you have already seen it recursion so recursion is the most popular application of Stack so using stack we are going to implement recursion and you know how this recursion has changed the way we think about programming right and the next one is um infix to postfix conversion isn't it and playing with the this post fix expressions and then um uh you know in parsing so in parsing we have already seen uh you know use of this stack a lot all the pares are going to use this stack and you know even some sub classes of parsing is like matching parenthesis isn't it matching we can do matching parenthesis right and we can even match tags tags in HTML language right so like this tags we can match them or in general we can match the items anything right matching parenthesis or you know matching ifs or whatever it is you know any parsing can be done for that we are going to use a stack right and maybe if you watch this uh you know browsing in browsing also we are going to use it right so browsers are going to use stack so you have seen this when we when we open a page and when we want to go back you can click on the back arrow and we go go to the page which is recently visited right and again when we go back when we want if you want to go to the earlier one again we click back again we click back how is it possible because all the pages or all the links which you have visited are arranged in a stack let us say this is page one and next if you click on a link that will be page two if you click on a link it will page three if you click on the link page four now if you are in page four when you click back then you know your browser will show page three if you click back it will show page four like this right and moreover in case of your you know editing also editors will also use this right so if you are using notepad or any any editing you are doing on your computer generally you want to do undo redo all this right so and for undo what we do is your computer is going to maintain right a stack of activities which means you know uh let us say you have pasted something then it will remember pasted something right or if you type something then you will remember what did you type and what is his his history and whenever you try to undo it it will go to this stack and undo and you know just undo that action again undo Undo It editors are going to use it right so likewise there are lots of applications you could think of even like this you know uh I didn't show you this set but then I'm going to show you don't worry so we have something called as tree tree traversals tree traversals and U you know uh graph traversals so what is traversing uh so when we we want to visit every knowde that is called as traversal I'll show you what a traversal is and some of the traversals are going to use stack and you know some other data structures implementation they will also take some support from stack I'll show you all these examples okay anyway before going ahead we have to look at at the implementation of the stack there are two popular methods or ways in which you can Implement a stack uh so the basic so whatever you want to uh Implement whatever you know data structure it is there are only two ways either you have to use an array which will have contous allocation and this size is fixed or you can use a you know uh Heap Heap memory so in Heap you can create a structure and you can use the links which means link list so either you can use a link list or an array to implement any data structure whatever data structure you take we have only two options either you use an array or use a link list or use a combination of these two these are the only two uh you know implementation methods we have so let's see how to implement stag using array first and then the link list okay so let us say we have know the problem with array implementation is we should always know what is the maximum size that you want to grow that is always the problem right and once you can predict that size which is very difficult to do in most of the cases if you if you can predict that then go with the array right and you know the advantage of using an array is in most of the cases implementation will be faster if you go with an array and if we can't predict this size then we can go with dynamic memory allocation and structures so you can use a structure to implement the data structures but the advantage that we get is flexibility we can grow and strring the data structure as you want but the disadvantage is in most of the cases no you know uh I many cases this link list might take more time in order to implement the data structure but we are lucky in case of stack in case of Stack either you implement it using a array or a link list right it is going to take same time it is going to take constant time I mean all the operations so what are the various operations that we have on stack if you have a stack of elements one thing is we want to push some element onto this stack so we need pushing and second thing is we want to take element out of this stack that is called pop so we have push and pop these are the two operations which are defined on this stack and let's see how to implement them in case we are using this uh you know array once and then let's see what happens in case if we are using the link list okay so let me let me show you what happens in case if you are using an array let us Define a global array stack of some size some maximum size okay and you have to Define this maximum depending on your need right fine and now we are going to have a variable which is going to Mark the top of it which means we will have we'll start with a variable and that variable will always show what is the top of the stack because we are supposed to take the element from the stack and we are supposed to push the the element you know at the top isn't it so we are going to have a variable uh top which which defines what is the top of this tag okay so let us say in top okay and assume that it is initial initialized with minus1 so why minus one I'm assuming that our stack is going to start with 0o index0 like this index0 index one index 2 right so initially top will point to minus1 which means nothing is there so minus one means stack is empty then whenever we want to insert something onto this stack we are going to increment the top and then put it put the value there so for now assume that we we want to implement a stack of integers which means the data which we want to insert and delete is all integers that is why I'm defining you know stack to be in right and now initially St top is pointing minus one and whenever I want to insert something I'll increment the top and I'll insert it there I'll increment the top and I'll insert it there right and whenever I want to delete something I'll delete it and decrement the top therefore top is always going to point whatever is the element that is on the top of this tag there are various ways to implement it you know implementation details doesn't matter as long as you provide with the API API means application programmers interface right it is all abstract abstract means I know we don't talk about the details to the other party whoever wants to use our stack we'll just tell them what are the function calls we implemented so that they'll just you know without worrying about how we implemented it either we used array or you know stack that link list or is the top pointing the you know top most element or is it pointing one below the topmost element all these details are unnecessarily unnecessary to the programmer he will just call the you know uh the functions so that is what I'm going to implement here all right so one thing is I want to push an element so I want to Define push so once we push we are not going to return anything therefore let me Define it as void push uh it is going to take an integer an item right so this item is going to receive some element which we want to push into this stag right then before pushing something onto this stag we should check whether uh you know we have reached the end or not which means whether we know the stack is full or not when will the stack be full if the entire array is filled up how many elements will be there in the array if you defined the know array to be of size maximum the last element in the array will be will be at the index you know Max minus1 isn't it so whenever top has pointed to Max minus one then we can think that the Elum the array is full therefore that is a overflow flow if the array or stack is full then that is called overflow so how can I know it if top is equal to Max minus one so it means that I have already reached the end right and there is no way I can push one more element because if I had to push one more element I increment the top and then push it there but there is no element there right so for that reason you have to you have to say if top equal to my no Max minus one then you have to hold this you have to check this condition print f overflow overflow means I cannot put it right so other else else means if this is not the case right so you can print of overflow and you can even return or let's let's write the return at the end else else means you know if this is not the case if it is not the Overflow then we shall do this so what is what is it we we want to do we want to insert the item into this stack so how can I insert it first top equal to top + 1 which means I increment the top and you know initially if it is pointing to minus one it will now point to zero and then stack of top which means wherever top is pointing to now there I'll place the item right this is called insertion and with this it is over right and at the end you can return or even if you don't write return also it will simply return return okay so this is the code for inserting pushing now if You observe this these writing these two lines you know uh is okay but then a better programming practice will be to use that you know shorthand representations which means if you can write it in you know in a short form it looks beautiful uh so what you could do is instead of writing these two lines see so you have to increment top and then place the value there right so what you could have done is you can write Plus+ top which means instead of these two lines even if you write like this stack of Plus+ top equal to item this one also works it still works and it is perfect there is nothing wrong in writing like this so what did you do we incremented the top right and then we have Plus+ means it is pre-increment so what is what is incremented top is incremented right and when is it incremented before you perform anything so it is in so whenever you have Plus+ top it means that top will be increment mented and the incremented value will be feted then at that location you are going to store this right so just using this one line you can write it okay uh now let's try to see how to pop what is popping popping is taking of the element so let us assume that we'll pop element and we'll return the element to the calling function then uh the return type of the pop function will be INT in Pop I want to pop it off right it will not take any parameter it will just return return an integer how can you write it so before checking whether you can you know before deleting an element from the uh you know stack it is better that um you try to check whether there are elements or not right if there are no elements in the in this stack and if you're are trying to delete element from the stack then that condition is called as underflow what is Overflow if the if the elements if the all the elements or the stack is full and if you are trying to push an element then that is called Overflow what is underflow if this stack is empty and if you're trying to pull an element out of it that is called underflow so first you should check whether this stack is empty or not how can you check whether this stack is empty or not if the stack is empty then top will be minus one isn't it so now watch it if top equal to minus1 what is the meaning of it this stack is empty then what can you do print F print F know underflow which means it is an error right print a underflow and return some variable minus one or something like this which will show it is an error okay else assume that you know whatever you are wring is not a part of the stack that you had agree upon earlier so what are the members of the stack and I mean what are the items that you are planning to push you know you have to use a you have to use a number which is not there else else means you know let us say it is not there then what we do is is h i mean what is that we have to pop so the top element right so wherever top is pointing to that element I want to pop I'll just show you how it works actually let us say you are pushing you know initially it is minus1 and you are pushing a number one then one will be first top will be incremented which means top will point to this and one will be pushed here let us say next you are pushing 10 then top will be incremented first and then 10 will be pushed next time if you push 20 20 top will be incremented and 20 will be pushed here got it so top is always going to point to the top element of this stack so what is that you have to return top element of this stack and after rning the top element of this stack you have to you know uh go back and point to the earlier element right so how is it done return so or you can even declare a local variable and you can do it right uh so because if I do return it will WR so int temp right now I'm going to know read that element from the top temp equal to stack of top so whatever top is there I'm going to read it and after doing this top equal to top minus 1 so what does it mean after ring the value after copying the value into temp I'm just decreasing the value of the top so that you know it will go back so actually you know popping me means we are not deleting 20 from there 20 will still remain there but next top will be pointing to the element which is below 20 below 20 which means here then what happens because of this action is you'll behave as if 20 is not there next time when you try to push an element you will override 20 right it is not that we are erasing the element okay uh so it is it is quite different from how we do it in a uh link list in link list whenever we delete an element we free it which means right we shall add it to the available space we free it but here the element is still going to remain but we just point backwards and later when we push an element we overr right on 20 okay so now yeah so what is it temp equal to St okay so top equal to top minus one and now finally after after either this condition or this condition right this is if okay return return temp or you can write even return ter here itself in the ALS condition right fine all it uh so if it is underflow in if condition itself we return if it is not underflow we we shall read the element and then we shall decrement the top and then we shall written at the end or you can put the written condition inside it anyway again if you watch it instead of writing these two lines you could have even written something better so what is it see now we are reading some element from stack of top and after that we are decrementing the value of top instead of doing this you could have even done the other other method right so what is the other way other good way I know you could have written it like this so you have to decrement it after the operation right after everything is done that is why you can do it in the post decrement so what is post decrement instead of these two lines you could have written like this temp equal to step of top minus minus so it is called post decrement so what happens so you know this decementation will be applied to top only but then first the actual value of top will be fetched and entire operation will finish and after this entire you know expression gets over then the decrement will take place so instead of writing like this these two lines you could have written one line all right so anyway this is the implementation of the uh you know push and pop so what is this time complexity required for this either you want to push or you want to pop time complexity is just order of one which means constant amount of time you are not you know whatever the size of the stack is you are not going to visit all the entire stack right so that is why this data structure is important I mean it is so popular because either you push element or pop element it is going to take just order of one time right okay fine let's see this stack implementation using the link list um the elements in the link list uh have to come from a structure isn't it let's define the structure first so let's see what have to be present in the structure and then the elements will be created from the Heap Heap memory so what is the difference between array and Link list implementation is we can create the elements in the link list dynamically and then put them in the list that is the main difference okay uh so now um let's define the structure first so let me use this uh again assume that our this stack is going to have integer integer elements therefore structure is going to have uh integers only okay struct node integer I and then struck node star let's say link so link is going to link to know point to the next node so using this structure we dynamically create the elements and then you know we keep on uh adding to the uh this link list so which is also here a stack so how do I implement this stack is I'll just tell you the logic see now if I have the link list like this okay let's say A B and C are the elements in the link list and now we know that head already points to the first one right so now uh this uh while implementing this link list I assume that the top of the stack will be present in the head of the uh the head of the link list which means in this you know if you see ABC like this it actually means that the top of the stack is a and then below the top it is B and below that it is C so if any element has to be know added to the top in of of adding it at the end I'll just add it at the head here so I'll create a new node right and then I'll I'll let us say I'll put this pointer here and I'll move this pointer here therefore this head is always pointing to the top right so inserting is just in a constant time I need not Traverse the list and then you know insert it at the end it is just inserting is a constant time operation and what about the deletion deletion is simply you know uh I'll just move this pointer 2 point to this and then I'll free this up that is deletion right so pushing and popping is just going to take a constant amount of time either it is array or the link list right so let's see the implementation I think you you understood the logic right so let's see the implementation here now push let us say they are sending you some item to push into this integer item this is the item which you are supposed to push which means here you are supposed to put it there so in order to do this first you create this entire you know link list I mean not not the entire link list at least one structure one node so how to create one node using mlog so how can I create create it struct node star which means this structure I'm creating a pointer P equal to mlog so you know that ml is going to return return the um void star pointer right but then I want the pointer to be struck node star so I'm going to use type casting which means that void star will be converted to stru node star and that will be given to P right so what is it I want to call mloc dynamically I have to allocate the memory and how big it should be the memory should be at least No it should be able to hold the structure isn't it so that is why size of stru node star stru node okay sorry so what does it mean first we find out the size of the structure and then we ml will allocate the uh you know memory size which is able to hold the structure and that memory's pointer will generally be given as void star which we convert to stru node star and that will be kept in the P now what does p hold p hold the pointer to the newly created node now therefore let us say this is a newly created node okay let us say this is a newly created node then what should I do now you know whenever you do this you should even check if this is valid or not sometimes what happens is you are actually creating this nodes from the hip sometimes we might run out of the hip because we might have overused it or you know many many cues or many stacks or many data structures are continuously going to use it therefore it might get exhausted which means there'll be no space in the Heap at all in that case you know this mlock is going to return error which means m is going to return null so you have to check if it is not equal to null okay so if uh this one let us say if um P equal to null which means ml has written an error it cannot you know you know have any memory then what you could do is you could say print F PF means print F I'm just writing the shortcut error memory error error of mlock you can say m mloc has written an error and you can return return simply right and you need not do anything so otherwise if it is not the case then we go to next statement then what should we do p data so in the P data I'm going to put whatever the item it is right whatever you wanted to push and then what about the P link inside the pink you are going to put right P link equal to uh you know null as of now you put null later we shall modify it okay so now uh how to initiate how to push it is so now here you need not check about the you know overflow because here it is not limited by this size so earlier while implementing using the array we are supposed to check about the Overflow right why because the size of the AR is limited but here you need not check about the Overflow in fact this condition itself is going to check the Overflow here the overflow will occur when the entire Hep Heap is completely full right so otherwise as long as YouRock is able to allocate an you know element you can still put it in the link list then how can you put it see head has to point to this but if you make head equal to P you know this enre list will be gone that is why before doing head equal to P you are supposed to do this P of link so which means instead of this line you would write this or instead of this line you can write like this also P of Link equal to head which means the newly created node is going to point to this see this is p and this is head isn't it now what about head head equal to P head equal to P right so why am I doing like this is why am I still including this and then still including this one is I just want to even handle the case case where you know this is the first element which is pushed onto the stack so in case if this is the first element which is pushed on to the stack then what happens is I'll see this then head head in inside this head element they will be null right head will be pointing to null and there will be nothing right then what happened here so P of Link equal to head which means here I'm going to put null and then head equal to P this will be pointing to this that is what happens right so you know this turns out to be not useful okay so you can even do like this all right so using this what is the time complexity time complexity required is just the time required to create a node and then time required to put it in the beginning of the list so how much time so now head is going to Point to P right now how much time is it going to take constant time therefore pushing using this uh you know link list is order of one time same as pushing using array that is Advantage here for this data structure for this stack either you implement it using an array or this or the link list the time is going to be same which is constant okay now let's try to pop an element let us say head is pointing to the some element all right so now you have to pop off this head is also top here okay so now you have to pop off of the element which is being pointed by that before that you have to written it you have to copy it somewhere and you have to written it and after rning it you know you have to make head point to the next element this one and you need to you know pop this off also right so one thing you should be careful is while you pop off you should be you should even check whether there are elements in this or not in case if the list is empty you cannot pop off that is called as underflow so first check for the underflow so pop is going to return return an element which is being popped off so that is why return return return type is pop int and then pop pop is being called right so now what is that we are going to check first thing is you check whether uh okay first let's declare this item which has to be return in you know item which is going to be return right and now first check if there is uh if there is some element in this or not if head equal to null then what is that we are supposed to do we are supposed to print a error right so printf underflow isn't it underflow and then what should we do so after printing that it is an underflow right we are supposed to you know return return some error code so you agree upon some error code initially let us say minus one is not used in your program I mean in your stack then you can say that minus one is the error code then when you return you know minus one they understand that is an error right otherwise if this is not the case then we can we can pop so what we should do is we should read it somewhere so item equal to whatever we want to actually you know return item equal to head of data so data is I isn't it structure is defined as I um and now you should even be able to hold it somewhere right because later you have to free it up so declare one one structure pointer also struct node star some pointer let us say p now what is use of p p is going to hold this item while you move the uh you know head to the next one so you can say p equal to head so that you are going to have a grab over this one p and now you can p is also pointing to this and now you can move the head to the next one so what is it head equal to head of next so in case if there is only one element then also since this element is going to have null it is this is going to work the reason why it works even if there is one lost element is since this element is going to be null right head is going to become null that is how it works right and after you move the head which means after head is pointing to this and P is pointing to this now you can free off this space which is pointed by P so finally you free off which is pointed by P so that this space will be later you know reclaimed by other other allocations all right so this is how you can run the pop so anyway since pushing and popping are done at the beginning of the list and since we are not traversing the entire list the time complex is required for pushing or popping either in case of array or in case of Link list is always constant so here also time is constant some constant time that is I'm going to write order of one time right so this is how you could Implement pop pop function okay just like stack Q is also a linear data structure right so the main difference between stack and Q is in stack we uh insert the element and delete the elements from the same side but then in Q we insert the elements from one side and we delete the elements from the other side okay that is the main between stack and the cube so like this I'll just show you uh see assume that we are implementing a stack a q using you know an array like this then we maintain two pointers one is called front and other is called RAR so initially front and rear will not be pointing to anything whenever we insert an element here when we insert an element into the quebe either you can call it as ADD right or we can call it as insert like you know in stack what is the terminology push push is used to say that we are inserting an element to the stack right similarly in Q whenever we want to insert an element we either call it as add or you know insert or NQ NQ n QE right see this NQ NQ means inserting right putting a element into the Q so now after we insert any element let us say we are inserting an element a here right then the front and rare both will point to this right and whenever we want to insert any a new element what we do is we try to increment the rare and then we insert it which means we increment rare like this and we insert the next element if you want to insert the next one increment the rare and then you know insert it therefore rare is the pointer which is used to point what is the latest element that has been inserted last element and print is the you know uh pointer which is used to say what is the last element which is inserted or what is the first element let's see let us call it that way so the first element which is inserted is pointed by front and the last element which is inserted is pointed by Rare okay and you know the main difference between q and a stack is in a stack we are going to insert the elements right let us say a b c the first one to come out is the last one that has entered that is why stack is also called as lost in in first out or first in L out right stack isn't it the first one to insert is the last one to come out or the last one to insert is the first one to come out but in Q it is reverse it is like just like this you know you can think of the Q as the normal you know que where we stand in many places right like you know we stand in a queue to to book any ticket isn't it the first one who enters the queue is going to come out isn't it similarly the first one who has entered the queue is is is the first one is going to be the first one who will come out and the last one who entered the queue is the last one who is going to come out isn't it therefore it is also called as first in first out or lost in Lost out data structure anyway while you are implementing this stack we need only one pointer to know what is the last one which is inserted therefore we are going to pull it out but when we are implementing Q we need two pointers one should point to the first element and other should point to the last element right why should we point to the last location because additions are being done at the end isn't it so that is how we are going to implement q but the problem with this kind of implementation is you know um see in Q what happens in stack what happens is since I know we are growing the array like this and we are shrinking the array like this at any time if any space is remaining that will always be utilized but but the the problem in but the problem in Q is uh you know when we are inserting we'll be inserting uh one way right and when we are deleting we'll be deleting also the same way right then what happens is at some point even though some elements are available some free spaces are available we'll not be able to use it see if I write the code in such a way that I'll increment the rare and I'll I'll just insert it there right then insertion let us say here rare will be incremented and D will be inserted rare will be incremented and D will be inserted and it's it that's it and there are no more insertions possible because the Q is full now let us say we have freed up some space let us say we have deleted this so whenever we DQ or delete an element right how where do we delete it from from the front so it is deleted and front will be incremented to point to this right and therefore one space is available here right but still rare cannot increment and it cannot use it so that is why this kind of implementation is rarely used in case of Q so what we generally use in Q is we Implement an we take an array and we act as if a array is circular right so we are going to use circular representation of the array we are not going to take any circular array we act as if the array is circular and then we perform the insertions and deletions on the array which is you know which we take which we think as circular it is not actually circular okay using that what the advantage we get is if there is any free space available in Q we'll definitely take it okay I'll show you how how to use that you know circular notation right now let's see how to use an array as a circular array and then know Implement a queue so what is advantage of using the circular array is we can use up all the spaces right okay let's see this even though the array is normal array I'll visualize it as if it is a circular array and I'll try to implement it that way okay so even though it is a normal array I'm just visualizing it that it is a circular array like this okay now this is element 1 2 four elements are there let's name this you know array as Q then it is Q of0 it is Q of 1 it is Q of 2 and is Q of 3 which means I have four elements in the array so if the size of the array is n right then I'm going to use it as if it is a you know nus one size Q which means I'm not going to use all the elements of the array to fill up you know with the elements of the Q I'll just leave one blank space why is that one blank space used is since it is a circular thing I don't know where the beginning is and where the ending is right so if I leave one space as a blank then I'll be sure that you know at least one side it must be the beginning and other side must be the ending right so you see if even if it is full I can I can be very sure that one side it can be beginning and other side it could be ending if it is completely filled up you know it leads to confusion all right I'll tell you what are the reasons why we should leave that one one particular you know cell with example I think it'll be clear okay watch it initially we are going to have two pointers one is front and other is rare initially front and rare both will be pointing to you know zero element front and rear and I'll initially leave zero as blank okay now whenever I want to insert any element the code is always I'll increment the pointer and I'll insert it which means I'll insert I'll increment the rare and I'll insert it let us say I want to insert the element 10 then what I do is I increment the rare pointer which means R will point to this and I'll insert 10 here right and if I want to insert 20 next next thing is 20 then I'll again increment the rare and I'll insert 20 which means I'll increment the rare like this and I'll insert 20 if I want to insert next element 30 then again I'll do the same thing again I increment the rare right and I'll incr I I'll insert 30 right and next time when I try to increment one more see I already told you that if the array is having a size of four I'll be using only three elements three spaces I'll not use completely four and all the three spaces are full isn't it now whenever I try to insert the next one I have to increment R rare and then I have to uh you know insert it so first thing is from three if I increment R it is not going to be four isn't it sorry it is not going to be zero it is going to be four that is the reason I use modular incrementing modular incrementing means I'll not do r = r + 1 I'll do r = r + 1 mod 4 then 3 = 3 + 1 mod 4 is 0 so when I try to increment it and know a mod will do a mod with four then R will point to zero isn't it so whenever R Points to zero whenever R and F both of them points to zero it indicates that the array is full right which means the Q is full that is used for overflow condition right so whenever I increment R are you following it whenever I increment R and if it equals to F which means rare equal to FR that condition is know going to indicate that the entire array is full you have taken the entire right fine then then you know so if it is full then we are not supposed to use it then what I do is I'll try to check it and again I set back okay I'll be standing there let us say after some time some elements are deleted now if I DQ which means if I delete an element where should we delete the element from from the beginning where is the beginning always the front pointer will will point to one item less than the beginning of the element right which means if you know if the first element added is 10 front will always be pointing to one element less now when we delete an element we have to we are supposed to return 10 that is what is deleted right then while deleting I increment the front pointer and I delete it right therefore I increment the front pointer and make F point to this and then I return return 10 10 will be there only but I act as if it has been deleted so whever f is pointing to that element is deleted right and the next element is the next one which has to be deleted Ed now if we try to insert the next element now we shall try to increment R now if I increment R it will become zero isn't it y 3 + 1 mod 4 which means R will come here right and you know R is not equal to F therefore insertion can be done let us say element 40 is inserted understood this now again if you want to insert one more element then what happens is again you try to do r = r + 1 mod 4 which is 0 + 1 mod 4 is 1 now r + one will be equal to F again there is they are equal therefore there'll be overflow so again I cannot insert any new element see this so whenever there are three elements I'll not be able to insert one more element so this is this is actually a benefit isn't it because earlier once we fill up the all the elements even though from one side it is emptied I'll not be able to use the old space but here you'll be able to use the space completely only one element you'll not be able to use that is advantage of the circular now let's see how how the underflow occurs underflow means how how do I know that the everything is empty right now let us say DQ so next time again I want to empty the Q then I mean delete one element from the Q then how do I do it increment F and delete from that so when I increment f f will be point to pointing to this and you return this which means 20 is returned right and again delete the next one F will be incremented from there and next one will be deleted and again delete the next one which means F will be incremented from here and F will be pointing to this and it will be deleted right so whenever now it is empty right so whenever Q is empty F and R both will be pointing to the same location it need not be pointing to zero they'll be pointing to the same location right so how there are two conditions now whenever you try to increment we are going to increment R and we insert the element there sorry whenever we try to insert an element or enq an element we are going to increment R and we are going insert it there but we should check whether it is overflowing or not what is overflowing condition when R = to r + 1 that if that that becomes equal to F then it means that there is Overflow right and you know uh so once we increment the rare if there is no overflow we are going to insert the element there then the second condition is delete or DQ how are we going to DQ so we are going to increment the front and whatever front is pointing to we are going to delete it or return it got it and and what is the underflow condition whenever F equal to r that is underflow condition got it so depending on this this circular Q is implemented using these functions so first function is used for NQ right so watch it NQ means adding an item into the Q right so first one is rare equal to rare + one mod which means I'm trying to increment the rare pointer why should I increment it because once I increment it then only I'm going to add the element there isn't it rare equal to rare + one mod and and then I'll check for the Overflow condition if after incrementing the rare see if rare + 1 is equal to front that is the condition for overflow isn't it that is the condition for Q is full so after incrementing it if there if it is full which means if after incrementing the rare front becomes equal to rare then that is the condition for overflow right then print F Q is full right and what about this uh then what what we shall do is in case if it is full we should not insert the element we should again reset the rare to where it was pointing earlier right then in case if the rare was point after incrementing it in case if rare is pointing to zero then I make it point to the earlier element what is earlier element n minus one which means in case if it is pointing to zero I'll again take it back and I'll put leave it there n minus one right else else means it is not equal to zero then I'll just decrement it which means after incrementing rare after you try to insert it after incrementing the rare if rare ended up somewhere here then I just decrement it then I'll point to the earlier one rare equal to rare minus one return else else means you know in case if it is not overflow then I have already incremented the rare I just have to put the item there then Q of rare equal to item and return return got it so here one thing you should observe is see for for checking the uh you know full I mean this overflow condition the condition is not actually front equal to rare the actual condition is rare + 1 more than equal to front but then here I'm writing the condition as if it is rare equal to FR why did this happen because I have already incremented the rare and then I'm testing the condition in case if you didn't do this what will be the actual condition to check the Overflow rare plus one mod if that is equal to front that is the Overflow condition don't get confused I didn't write away check if r equal to rare got it okay now when I try to delete the element so when when when I try to delete the element I should check whether the Q is empty or not so that is called underflow condition right so now DQ which means I'm trying to delete an element now condition is if front equal to rare so why is this this one used now if front equal to rare because uh the condition for the empty stack empty Q is front equal to rare I did not do anything directly front and RAR both are equal it means that you know there are no elements but what about the Overflow if front + one mod sorry if rare + one mod is equal to front then that is the condition for overflow right so maybe it is worth noting it so for overflow for overflow the condition that has to be checked is rare + 1 mod n if this is equal to front this is the condition for overflow then what is the condition for underflow the condition for underflow is you know if front equal to rare right but then while writing that program this one I'm checking this condition because incrementation has already been done here why am I incrementing already here because anyway I have to increment it later that is why I'm already doing it so since I have already incremented it I'm directly checking it actual condition has to be rare plus one mod it has to be checked with front so keep that in mind okay now if front equal to rare what does it mean it means that the Q is empty then that is underflow condition right then print F Q is empty and return minus one else else means uh you know it is there are elements in the Q then increment the front first why because front is always pointing one element less than the actual element isn't it so that Gap front will always be pointing to that Gap right now front equal to front + one model now we are making the front point to the element which is which is the oldest one in the Q then item equal to Q of front now we are going to take the element from the front and then return return true all right so actually I have to return item whatever is deleted I'm going to return it in this case if it is no false I mean if it is empty I'm wrting minus one under the assumption that minus1 is not a valid member of the Q right so it depends on what you agree upon which means if you initially agreed that minus if initially agree that minus1 is an element which will never occur in the you know Q then maybe you can go with minus1 right that depends on what you agree upon this written type okay so one thing you should be careful about is the conditions so now I think you understood what is the advantage of leaving that Gap I'm just leaving one gap which means even if the array is containing n elements I'll fill it only till n minus one element so that that one Gap is going to give me two conditions one is Overflow condition and other is underflow condition if I just fill it completely then what happens is I'll not be able to distinguish between these two conditions you know you can you can work out filling it completely if you fill it completely then what happens is both for overflow as well as underflow front will be equal to RAR then I will not be able to distinguish now if I give a gap if I just leave one element always then what happens is these conditions will be different now using these conditions I'll be able to understand whether the Q is full or it is not it is empty why should I understand it because when you're trying to insert an element you should never insert it if it is full and when you're trying to delete an element you should never delete if it is already deleted if there is no element isn't it so in not to understand that overflow and underflow condition I'm going to give a gap in the Q understood this okay a binary trees have got many applications in the field of computer science and B tree is like this any tree which is having at most two children is called binary tree okay like this know if I have a node this is a binary tree at most two notes at most two children is called a binary tree and you know many programs how they want to access binary trees is they want to store some information in the binary tree and later they want to see what the information is present in the binary tree that is called as I know uh traversing so traversing means we want to see what is information present in every node that is called traversing searching means we are searching for a particular node the main difference between searching and traversing is traversing is done in order to see everything in the data structure that is called traversing searching means I know once we find a desired you know element we stop that is called searching so coming to Binary trees there are various methods in which you can Traverse the information or you could Travers the tree there are various methods proposed but the most important methods which are used for traversing is this so one is in order so in order traversing and then pre-order pre-order traversing and then post order these are the most important or most popular traversing methods which are applied on binary trees in general these are applicable for binary trees only you know but then there there have been some extensions proposed in which you can extend it to any any type of tree like not just binary tree you can extend it to trees having three children or four children or at most five children also but anyway these are the most popular methods which are applied on the binary trees okay now uh one thing is let's see with examples how each of the traversal is and then later we shall see the programs for this and we shall analyze the time complexity and space complexity as usual okay so let us see let us say the notes here are a b c so what does in order Trav say is you know U you have to visit and Traverse the complete left left sub tree and then you are supposed to uh print the head or let us say root so there is a root which means whenever you are present at a node I call it as a root right then in order says that first first you finish the left sub tree and then you visit the root and then you finish the right sub tree okay so this is what in order says and pre-order says that uh first you finish the root and then left and then right and post order says that first you finish the left sub tree and then right sub tree and at the end root okay so in pre and post really mean about the order in which we visit the root node okay which means in in order applies that the root node is visited in the middle and pre-order applies that root node is visited you know before everything and post says that know root is visited after everything right and if you look at the order in which left and right left child and right child are visited uh they are consistent which means here left is visited before right here also left is visited before right and here also left is visited before right now for this example tree what does it really mean is you visit the left child which means visit B first and then visit the root which means visit a first a next and then visit the right so what is Right C right and coming to this uh preorder again uh visit root which means a will be visited and then left which means B and then C right and coming to post order same thing visit left left means uh you know uh B first and then right C and then a okay got it so this is how given a tree these in order pre-order and post order will be evaluated but since it is a small example and a simple tree I'm able to do it directly but if the tree is very big you know this is going to be complex so just to make things simple I'll just tell you a shortcut in which you can find out in order pre-order and post order you use this method in the exam okay so how to find out in order pre-order and post order is this way watch it whenever any tree is given see that every every uh you know node in the tree has children even the leaf the leaves are B and C they don't have any children even if they don't have any children you see that you put some dummy children like this which means I'm going to put it like this right and after that you start walking walking on the tree so I call what is a walk is uh you know top down left to right which I'll just show you see walk you know you can imagine it this way you can imagine as if you know these entire lines are some you know some beach and the entire everything is C and now walk as if you're walking on the beach okay now like this so y so whenever you visit a you print it whenever you visit any note for the first time you print it okay and now I'm going to B again I visiting B for the first time print it and now again I walk like this I'm visiting C I'm I'm visiting B right so B is now visited second time I'll not print it and again B is visited third time so if you watch it every node will be visited three times before I finish walking entire tree and go back to the initial Point okay and again a is visited second time B is Vis and uh C is visited first time so print it right and again uh C is visited second time C is visited third time and a is visited third time so if I in a walk in such a kind of walk every node is actually visited three times isn't it now if I print all the nodes whenever I visit them the first time the order I got is ABC right which is nothing but pre-order Watch it pre-order is ABC so the order I got is ABC right therefore when you print the uh nodes When I visit each node first time right When I visit each each node for the first time then it is called as pre-order now let's do the same thing what happens let's see when I visit and I print the notes When I visit it for the second time let us say the notes are a b c and I'm visiting them for the second time so first time I'll not print it first time I'll not print it second time I'll print it so this the second time visiting B therefore print it okay third time I'll not not printed second time visiting a therefore printed first time don't print second time print it right third time don't print third time leave it now if I print it in the second time then BAC C watch it BAC is nothing but in order therefore if I print the notes When I visit them for the second time then the order in which I print them is exactly equal to the order in which I print them in the uh you know in order therefore first time if I print it then the order is consist with the pre-order isn't it and second time if I print it the order consistent is in order right and let's see the third order obviously I think you might have guessed it so what happens if I print it for the third time obviously the post order right so let us say this for the same example A B C let's print the nodes When I visit them for the third time first time first time second time third time print it so B is printed second time first time second time third time printed C third time printed a right so b c a so it is consistent with the post order right so what did you understand from this uh you know uh so first time when I print the elements whenever I visit a you know when in the walk whenever I visit the node for the first time it is Con with pre-order second time in order third time post order so if you follow this order I mean this technique you'll be able to answer many of the questions directly especially when the tree is very complex you know if the tree is simple you might think that why am I doing all this but if the tree is complex these techniques are going to be very useful let's practice on one one tree okay now I'll give you a complex tree I mean not a complex tree kind of big tree let us say the tree is this way a b c d e f g okay so what what is there in this tree is a is having two children left child and right child but B is having only right child C is having only left child D is having only left child e is having only right child okay and now what I want to do is I want to print in order pre-order and post order all all the orders for the tree all right then then we we should not follow the ordinary method because it is going to take a lot of time so let's put that let's let's go in the shortcut so what is the shortcut uh you see that every node is having all the children and then you start the walk and whenever you visit a note for the first time print it and that order will be conent with the pre-order second time in order third time post order right so now watch it I'm just putting the Dum notes d D noes like this D noes right don't miss out anything all the D noes have to be there so now watch it B has got left dumin node D has got right dumin node e has got left D node F has got light and left dumin noes and G has got like this and C has got like this okay and now uh let let's go let's do all this so one is I want pre-order and then I want in order and then I want post order also right so whenever I visit a node for the first time I put it here then all the notes I got I get here is nothing but the order consistent with pre-order and if I visit a note for the second time I put it here if I visit a not for the third time I put it here right so by the end of the entire traveling I'll be able to get all the traversals right fine now I'll start from here so I'm visiting this for the first time so let me print it so what what has to be printed first time right so where should I put it yeah here and again B is visited for the first time so here see in general in the exam they'll ask you only one of them they will not ask you all the traversal they will ask you just one of them but then know I just want to do all of them because it will be easy for you to practice okay now B is visited for the second time so where should I put it second time is here isn't it D is visited for the first time where should I put it here and E is visited for f is visited for the first time I should put it here and F is visited for the second time so second time I should put it here and F is visited for the third time so I should put it here now D is visited for the second time so I should put it here D is visited for the third time isn't it this is the third time therefore I should put it here and B is visited for the thir third time right isn't it B is visited for the third time in fact it's the last time therefore I should put it here a is visited for the second time I should put it here C is visited for the first time e is visited for the uh first time put it here e is visited for the second time put it here G is Ved for the first time put it here G is Ved for the second time and G is vised for the third [Music] time e is vised for the third time C is vised for the second time and C is vised for the last time and what about this C is visited for the last time a is visited for the the last time therefore here got it so see this all the notes have been visited right 1 2 3 4 5 6 7 1 2 3 4 5 6 7 1 2 3 4 5 6 7 right got it so this is the pre-order in order and post order of this complex tree so any tree is given you can do this way and you can find out what is the order right but then it is better to understand how the algorithm actually works how the russion program works and how we are actually doing it so for that reason I'll write the program and we shall Trace out how it really works and why why should this method work first time second time third time and then we shall see what is the time complexity and space complexity it is very it is really important that you understand how the recursion program works on this tree or any such tree because in exam instead of asking you you know in order preorder and post order they might come up with a some with some other order then still you should be able to do that okay so let's see this now let's write the program recursive programs and and we should we'll see how the discussion actually works on this you know to implement pre-order in order and post order okay fine now I'll tell you one more method of uh you know analyzing or tracing out the recursion programs on the tree generally I told you this so whenever we have only less number of uh you know statements in the recursive program I asked you to follow the tree method but then now we already have a tree on the tree we are doing the recursion right so whenever we are doing some recursive programs on the tree one good way is to you know use the tree itself to find out what is happening so I'll just show you with an example and you know if you could understand this example whatever I'm going to tell you given any other any other program other than the in order pre-order postorder you'll be able to still you know solve it very easily and one more thing is if you want to do only in order pre-order post order just follow that method of visiting first time second time third time that works but given any other you know order or given any other program which is recursive and a tree binary tree as input or any tree as input you follow whatever method I'm showing you now okay I'll I'll just take an example and I'll show you with you know let us say in order itself okay now let us say the tree is like this a b c d e F G right a dancing tree okay now what I want to do is I want to trace out how the know in order works on this program on this tree so we already I'm not going to write the entire program we already know it right so what is that if you have in order in order if it is given at know you'll check some condition and then you'll see first you do in order of you know T of left we go to left and then we print if what whatever is present there and again we call in order of T of right isn't it these three statements are going to be there along with the condition checking and all they are not important so most important thing is know there are three lines okay and now this program will be initially called at the root so what I'll do is now since this program has to be executed completely with this uh you know root as the input I'll I'll assume that you know we have three lines there okay so 1 2 3 lines are there right now when we execute the first line this line what does it say it is asking us to go to the left of the tree which means a when you are here and when you call this one the program is asking us to visit the left note so therefore from here I'll go go here again here I have to execute three lines on this note isn't it now I'm going to tick the lines so that I'll remember that I finished executing line number one so that whenever I go back I'll start with line number two got it and now now I'm here right and what is the first line first line is asking me to go to the left tree of this node but then there is no left tree right therefore if it is as good as thinking like this we went to the left side and we came back where do we come back again here right now second line so what does second line say print F therefore I'm going to print B got it and now uh second line is over so what is the third line third line is going to say that um you know go to the right child so now I'm executing third line and therefore I'm going to the right side right and again in the right child of this I execute 1 2 3 now what does the first line say first line is asking us to go to the left side right therefore I'll come to the left of this so here I have to execute 1 2 3 what does the first line say go to the left but there is no Left Right therefore I execute second line what is second line print FF printed what about third line go right isn't it third line is go right but there is no right therefore all the three lines are done whenever three lines are done whenever you execute all entire code on this node we are supposed to go to the parent why parent call this function in this stack If You observe it you know in this stag this record for this one will be Above This Record therefore once this record is popped off we are supposed to go there right so now I go here now what now we have execute the second line what does the second line say print F what should I print D will be printed now what are the third line say it is asking us to go to the right side but then there is no right side right therefore all the three are over so I go to the calling one here here in the calling one all the three are over therefore I to go here right and now here I execute line number two got it so what is line number two print F so I'm supposed to print a yes printed and now line number three what does line number three say I to go to the right child yes I'm going to the right child and what should I do I should execute 1 2 3 1 2 3 I should execute this are you following it and now you you are supposed to start with line number one what does line number one say go to the left of it what is left of it here 1 2 3 have to be again started right and again line number one line number one says go to the left side there is no left child therefore line number two what do line number two say print a fe yes printed and now after this line number three what do line number three say go to the right child so right child is here 1 2 3 what does line number one say go to Left child nothing line number two print FG yes printed line number three go to the right side nothing right and now all the three lines are over go go back to the parent all the three lines are over go back to the parent now second line what do second line say print f c and third line is go to the right child there is no right child right and all the three lines are over go to the parent and all the three lines are over therefore function will stop so this is the order which gets printed so in case if You observe it this one will be the in order if you have any doubt you can trace it out see this so what do how does in order work whenever you visit any node for the second time you are going to print it right first time don't print first time don't print second time print first time don't print first time don't print second time print third time second time print third time third time second time print first time first time second time print first time second time print third time leave it third time second time yes print third time over right so if You observe it it is nothing but the in order right so one other way of tracing it is this way now why did I show you this example with this in order is you can apply this even if the program is not about you know in order or pre-order so if in order pre-order or post order is given uh walk the tree and print it first time second time third time it works but if some other order is given then you might get confused right that is why I'm doing this let us say they have defined some other order called as double order double order means I want to print every value two times just for fun okay so now let us say the program is written like this the program is like this you know double order double order T so what I try to do is I'll see if T okay if T then I'll try to print f t data I'm I'm not writing no exact code you just please look into the details and then then I want to go to T left is it visible and then I want to print f t data right and then I want to go to write T right okay so now what I mean to say is I'm trying to do some traversal in this Trav there are four steps you know and moreover whenever I visit any node I'm actually printing the note two times but then I know uh the printing is not directly straight away I know I have some inter living after printing I have execute something which means I'm actually going to some other node and again printing it right so whenever such a such a traversal is given it will be difficult for you to do in a shortcut uh the know the number of times we have seen I mean first time second time third time so instead of doing that I'll tell you one more method so this method really works and it will be really really helpful here so how many statements do you have 1 2 3 four statements you have right so now let's let me do let me see what happens on the tree with this program okay so let me write the tree b c d e f g okay so on this one on this tree initially at a the function will be called this program will be called right with this four lines right so you are supposed to execute 1 2 3 4 lines on a right so first first line we'll start with this so what is the first line say print of data which means a will be printed right and what does second line say second line says that go to the left and do the same so go to the left side here and again do the same 1 2 3 4 right and therefore you are no longer here control has shifted here now you are supposed to execute line number one what does line number one say print F so I'm going to print B got it and then what does the line number two say go to the left child but then there is no left child right so there is no left child so assume that it is done and now third line third line says that again printed therefore it is printed now what does fourth line say fourth line is saying go to the right child right so after executing fourth line I go to the right child so in the right child again I have to do four lines 1 2 3 4 right what does line number one say print F which means D will be printed what does line number two say line number is asking us to go to the left child isn't it which means here so again I have to start with 1 2 3 4 lines what does line number one say print F so print what do line number two say go to the left but there is no left so it is done what about line number three again print F so I'm here and I have to print F right now what does line number four say go to the right but there is no right therefore all the lines are over you have to go back to the parent now parent line number two is over now I'm supposed to do line number three what does line number three say print F what what should I print D got it and what does line number four say go to the right now there is no right isn't it there is no right here so you know this everything is over so you are supposed to go to the parent now in the parent also all the lines are over you supposed to go to the parent so here so line number two is over what about line number three line number three says print of data so what should I print here should be printed right and line number four says go to the right so which means I go here right 1 2 3 4 now line number one here says go to the left oh print so therefore C is printed right and yes print F and then line number two says go to the left so go to the left again I here I have to do 1 2 3 4 right and now again line number number one so what does line number one say print F which means e will be printed right and again what does line number two say go to the left but there is no left so consider it is done what about line number c says right print F so I had to print this so which will what will be printed e will be printed again now what what about line number four go to the right so it is asking us to go to the right 1 2 3 4 right now line number one says print F which means G will be printed line number two says go to the left there is no left it done line number three says no print F which means I to print G right what about line number four line number four says go to the right there is no right therefore it is done now go to the parent parent also everything done go to the parent only second line is done what is the third line third line says go to the right oh no third line says print F therefore print f c fourth line says go to the right but there is no right therefore everything is done go to the parent parent is also over so this is the order in which you know this devil order can be done so if you follow this way you can you know you can do any other any other big programs now let's see one more one more thing and on one more graph triple order okay let's see this triple order traversal on the trees see these questions are given in that horror book from the Excel have taken these questions so what do they mean by triple order and double order is double order means they are printing every uh value of every note two times triple order means they are printing value of every note three times so in this case here here and here three times we are printing the value of a data and you know in between we are going to visit some other notes see in case if all these printings were together then you need not do a lot of work you can actually see which order it is either in order pre-order post order and in you know instead of printing it one time you could print it two times or three times in case if all the printings are together right but here the print of statements are know differently located and now if this function is called with the uh pointer to the root node pass to this let's see what happens and PF means print F okay uh so what I mean to say is okay let's take an example and let's watch it see let us say the example is like this A B C D E something like this now I want to see what happens if I call this function I know with pointer to the root I know and execute it so no whenever this kind of recession is given it is better that you write the numbers 1 2 3 4 5 so five statements are present in this code right so whenever it is called here so the program is going to take this one as input and all the f file lines have to be implemented on this node isn't it so 1 2 3 4 5 right so first it will call line number one what is line number one print F which means a will be printed and next it will do line number two what is line number two you have to do the same thing on the left left side of the tree so what is left side again this one right on this one 1 2 3 4 5 is called now line number one what does line number one say print F so what has to be printed B and line number two what does line number two say do the same thing on the left which means on this one 1 2 3 4 5 now what does line number one do print F so print a right and what about line number two line number two is go to the left child but there is no left child therefore you need not worry about it right and what about line number three line number three says again print so we are here right so again D will be printed and what about line number four go to right child there is no right sh to d right so you can consider that D is four line fourth line is also over what about line number five print F so what will be printed D will be printed right so after this we return back here right so since all the lines are over we return back right now here we are in line number three so what does line number three say print F what has to be printed B right and again line number four what does line number four say you know we have to do the same thing on the right child since there is no right child right you need not worry about it what about line number five print F right so what has to be printed B has to be printed all right and now it is over and now we go to the parent now what does it do line number three what does line number three say print F so again you have to print f y right and after that line number four what is line number four go to the right side right so which means here I have to write 1 2 3 4 5 and execute all of them right now what is line number one it says print f c yes this data right and what about line number two line number two is again we have to go to the left child but there is no left child therefore again continue here so what what does line number three say print F so what has to be printed C what about line number four do line number four is asking you to go to the right child so here I have to call one 1 2 3 4 5 and execute right now here I line number one says print F so what should I print he should be printed isn't it and line number two says tripod on left child so left child is not there and line number three says print F what would I print e right and line number four says again trip R right child but there is no right child what about line number four line number four says oh line number three is our s now line number four says right child there is no right child what about line number five line number five says again print therefore he will be printed right everything is over so go to the parent so in the parent four lines are already over now it is Fifth Line what is Fifth Line just print f c will be printed all the F lines are over go to the parent what is the Fifth Line Print F what will be printed a will be printed so this is the output when you run this on this got it so this is how you should be analyzing it okay now there will be some kinds of questions on trees uh like how many trees are possible with these many not okay now let's explore that kind of question let us say we have one node if I have one node uh then how many binary trees are possible so if I have one node the number of binary trees possible is obviously one isn't it the node itself which is nothing but the root and if I have two nodes how many binary trees are possible so in case if I have two nodes the number of binary trees possible will be two isn't it one will be like this or the other will be like this there is no other way you can put it right and if I have three nodes how many binary trees will be possible so in case of three nodes the number of binary trees possible will be one is like this right and other is like this left skew it is also called a left skewed it is called skew skew okay which means left side completely right and the other one is right skewed okay and the other one is like this jig Jack right and the other one is uh like this so if I have three nodes the number of you know binary trees possible will be five and just remember one thing here so whatever we are talking about here here I know in this case I'm I'm talking about the unlabeled trees unlabeled trees means I'm not talking about the specific node name in case if you name the nodes then the number of trees possible will be even more right so I'm talking about the structure so how many structures are possible with three nodes number of structures possible is five so likewise we can go go on one node two node three nodes right so in general if you want to see how many nodes are possible or how many binary are possible with n noes the formula is this you can prove it with induction I'm not going to do the proof you can prove it 2N CN / by n + 1 this is the number of nodes I mean number of B is possible with n nodes for example if you want to see how many did we get here 1 2 3 4 5 so with number of nodes equal to 3 we got five trees isn't it now if I put Nal 3 then what what do I get 6 C3 ided by 4 isn't it then what is this 6 into 5 into 4 ID by 3 into 2 into 1 into 4 right then what is this it is 5 right therefore the number of trees possible with three notes is five right um and this is for unlabeled right so you can write it somewhere the number of binary trees possible with uh three unlabeled notes is this much now what about label noes if I try to extend this concept to label notes then what happens is label notes means I'm going to give the names to the nodes right then every tree is now it can be represented as you know three factorial trees in this sense let us say this structure if I take only that structure this particular structure right this one this one is actually if I label the nodes it is as good as or it represents nearly six trees exactly six six trees how see this in one of the tree a can be root isn't it in one of the tree B can be root right and in one of the tree C can be root right so you can you can imagine it like this there are three blank spaces three nodes and I have three names A B C how many ways can we you know fill these blank spaces with these three objects first one can be filled with three uh three uh combinations and once you fill one blank space then the number of combinations available for the second one is two and once you fill it up the number of combinations available for the third one is just one therefore 3 into 2 into one which is nothing but three factorial ways you can fill up these faes that is what I'm showing you here right so the root can either be a can either be B can either be C therefore three possibilities right and now the remaining they also can be of two right which means here I can have B here I can have C or root can be a and here I can have C and here I can have B right or here here also same thing right here I can have a here I can have C right or here I can have B here I can have C and here I can have a right or here I I have C isn't it now here I can have a here I can have B here I can have B here I can have a right therefore in case if I go with label nodes right every structure is capable of generating n factorial trees so if these many structures are possible and every structure is able to generate n factorial trees then in case of labeled nodes the number of binary trees possible with n nodes will be you have to multiply this with n factorial that will be total number of binary trees possible Right so the number of binary trees possible without labeling which means unlabeled nodes with unlabeled n nodes is 2N CN / n + 1 the number of binary trees possible with labeled n notes is this much all it so this is the formula which you can remember it right so there will be some questions like this how many number of notes will be possible now the next thing is um it is you know it is not just about the number of notes they'll even give you the number of nodes and then they'll give you they will say that this is the particular order we have okay I'll just show you in the next video okay binary tree is a special kind of uh sorry binary search tree is a special kind of binary tree um the main the main problem with binary tree is if you have to search for a node there is no particular direction you might have to end up you know searching everywhere so if you can uh insert the elements in some proper order in some order then what happens is searching an element will be easier so uh you know the trees which will help us in searching an element they are called as you know binary search trees these trees have special property which will be very useful for us you know while we search and in in general if you have a binary tree if I had to search for element it is a normal binary tree right if I had to search for an element then I might have to uh go through every node therefore time complexity taken may be order of n isn't it if I have to visit every note then the time time complexity is either pre-order or post order or in order it is going to be order often isn't it now uh with some uh good implementation we can produce binary search trees which which if if we could balance then they are called as balanced binary search trees uh which could generate a good performance in this sense search time can be order of login so that is the advantage of binary search trees binary search Tre are going to help us search you know better better and in order to have login complexity we do balance and binary searches we shall see all all of this let let us first start with the binary search tree so in coming to gate in Gate exam they they are generally asking you small questions about this you know insert these elements into the binary search Tre delete this element maybe what is the in order pre-order like that okay let's see this one now um so it is asked in Gate 1996 the question is insert all these elements into the binary search tree so binary sear tree operates this way if you have a root okay now if you have a element at this node then all the elements to the left of it will be less than this and all the elements to the right of it will be greater than this in general whenever we talk about a binary search tree you know uh we assume that the notes are not repeated because if the notes are repeated then it will be meaningless in the sense binary sry is applied for storing the keys keys ke Keys now these keys are going to point to some record now two records are not supposed to have the same key so that is the reason in binary SAR Tre we assume that always the numbers are distinct in case if the numbers are same maybe you could compromise and you can put it this way which means the number if a number is something is here then all the numbers less than or equal to that number will be in the left sub tree okay and all the numbers which are greater than that will be in the right sub tree got it so this is a compromise that's it so in general you know this is strictly B search is supposed to have distinct keys and all the elements which are less than this will be present in left sub tree and all the elements which are greater than this will be present in the right sub tree okay now let's try to insert these elements into the binary search tree okay now first one is 50 then what is inserted 15 is 15 less than or greater than 50 it is less than 50 right therefore it is it is inserted in the left or following this if element is less than this element I'm inserting it in the left right and what about 62 first compare with the root and then follow the flow right so compare with the root what about 62 62 is greater than 50 therefore it is supposed to be inserted in the right of the root right and what is the next one five so 5 is less than 50 and less than 15 therefore 5 is inserted in the left what about 20 20 is less than 50 and 20 is greater than 15 therefore 20 is going to be present here right what about 58 58 is greater than 50 and less than 62 which means 58 is going to be here right what about 91 91 is greater than 50 and greater than 62 therefore 91 is going to be here all right next one is three 3 is less than 50 less than 15 and then less than 5 therefore 3 is going to be here what about 8 8 is less than 50 less than 15 but greater than 5 which means 8 is going to be here next one is 37 37 is less than 50 greater than 15 and greater than 20 therefore 37 is going to fall here right and what about 60 UH 60 is greater than 50 less than this but greater than 58 therefore 60 is going to be here right what about 24 less than 50 greater than this and Les greater than this and less than this got it that is how you can organize it so you know in case if you have any doubt whether we did it right or wrong I'll tell you I'll tell you how to check it so whenever you do any modifications like insertion or deletion into the binary search Tre you can check it this way no you can directly check by going to every node which means every sub tree is you know if a tree is a binary s tree then every sub tree is also a binary s tree which means you can take any sub tree see this five less is here greater Is Here fine and what about 20 20 and 37 it is greater and then uh you know 37 and 24 lesser and this is also a binary tree so you can go to any sub tree which means the sub Tre containing only these two nodes and you can see that that is also a binary s tree it is a binary s tree right right and what about this B yes it is a binary sry so you can check everywhere that it is going to follow the binary sry properties that is one checkpoint second checkpoint is if you try to do the in order traversal of a binary s Tre then you are going to get all the nodes in the increasing order it is very important the in order traversal of a binary SE tree is going to give you I know sorted order of the elements which means you can insert the elements into the tree in a binary s tree and then you can print them in order then you are going to get the sorted list of the binary search Tre sorted list of all the elements okay now see the in order of this so before going to in order put the dummy notes in place so that you can know when we are visiting a note for the second time okay first time first time first time first time second time so three is printed so if You observe the first element which is printed is the leftmost element right and leftmost element is the least least element in the binary s Tre it is also important so if you want to see the leftmost element that is no sorry least element of the binary tree that will be in the leftmost so how to how to find it out you know maybe if given a pointer to the tree and if you are asked whether to find out the left more you know the smallest element then you have to come you know you have to keep coming down down left and the one which is in the leftmost position is the you know least element now how to Traverse it you can do it this way tal to T of left while T so while t means you'll keep on going until T becomes null right or while T off next okay I'll show you I'll show you how to write the code later anyway let's finish this off now I'm talking about the inorder second time when I visit it I'm going to print it it is the third time second time when I visit it I'm I'm going to print it right first time second time print it third time right third time third time second time print it first time second time print it first time first time second time print it third time second time print it third time third time third time second time print it first time first time second time print it first time second time print it third time leave it third time second time print it first time second time print it third time third time third time right so if You observe it right so all the elements which we get in order by traversing in order in a binary search Tre are now in the ascending order got it uh so you know uh in exam what they'll ask you is they'll say that a binary sry has so and so you know post order then what is the pre-order they'll ask you such question so let's solve one question like that then you'll understand what I mean to say okay now let's see how to delete an element from the binary SAR tree so this is a binary SAR tree okay now I want to delete an element so whenever you want to delete an element in binary sarry uh you are supposed to you are supposed to see what kind of element you are you know trying to delete there are three kinds of elements I mean in general you can classify the elements to be of three types when it comes to the deletion so one is um you know we are trying to delete a leaf what is what is the property of a leaf it will not have any children right and the second one is uh you might try to delete uh a nonleaf okay now a nonleaf can be of two types one is nonleaf means it is having children right so one is it is having only one child and the other type is it is having two children right now we have to distinguish between these three cases and deletion depends on which which case are we are dealing with are we are we dealing with the leaf case or are we dealing with a non-leaf with one child or are we dealing with a nonleaf with two children we have to deal with all these three right okay now uh whenever you are trying to delete a leaf then you need not do anything much see this let us say I want to delete no node number 40 so if I delete node number 40 nothing gets affected the tree will be intact right you not going to break it apart so therefore you can directly delete it without worrying about anything right so when you're deleting a Lea you need not worry about anything next one is when you're deleting with when you're deleting a non leavea yes then you should be careful I know there are two conditions one is that non Leaf might be having one child and other is it might be having two children let's talk about one child let us say I want to delete node number 25 right this one now how can I delete it if I delete node number 25 there is a chance that even 27 will go off right which means the tree will get disconnected so we have to protect 27 therefore the rule is whenever we have only one child if a node is having one child and if you are going to delete that node then make that child point to the Grand grandparent which means make this 27 connect to this 30 and then you can delete it which means when you're going to delete this one you you know you connect this 27 here so you can delete this but you have to connect this 27 here and then you can leave it so in case if 27 is having even more links then they all will come here got it and next one is deleting you know a node with two children so which means if want if you want to delete this node 15 it is having two children right then how are you going to do this see unlike one child if it had only one child then I could have taken this entire link and I would have attached it to the 20 right but then now by deleting it I have to deal with two two children isn't it so and these two children cannot directly go and connect to the grandparent okay now there are two methods one method says that whatever node you wanted to delete go to the right sub tree and you take the least element of the right sub tree and you put it there okay which means one one element one one algorithm will say go to the right sub tree one method you can use any of these two methods okay go to the right sub tree which means this one okay and now take the least element what is the least element 16 and you replace it here right why should this method work is uh see already every element in the right sub tree is greater than this isn't it now if you take the least element and you place it here the remaining elements will be greater than that least element therefore still it will be a binary s Tre are you following it see if I replace this element with the least element from the right sub tree that is also called as in order successor why if you sort the elements in order which means if you find out the in order you know 15 will be succeeded by 16 that is called in order successor so if you replace it with inorder successor which means if 15 is replaced with 16 then still the binary sry property holds the reason is this see already all the notes in the right sub are greater than 15 and now if I take the least from here and if I put it there right the remaining elements are still greater than this you know least element that is why it is it works I hope that you getting it or the other method is you go to the left sub tree and you take the greatest element which means you know you have to take 12 and you have to substitute here why why do you think that this method will also work fine because already all the elements here are less than this right now by taking the greatest element and putting it there the remaining elements will be less than this and all these elements will be greater than this which means again the binary s property follows right so what I mean to say is you can delete either 16 from here and you put it here in place of 15 it works check this all these elements are less than 16 because we are we are replacing the root with a greater element therefore if earlier you know 15 is greater than than all this then a greater element will be greater than all this isn't it and now these elements are all greater than 15 now I have taken the least element among them therefore the remaining element will be greater than this therefore again it is a binary s tree or you know instead of 16 you could have taken the greatest element from the left side right which means you could have taken 12 and you would have replaced it here got it and now what happens because of this uh see this now all the elements in the left side will be less than this the reason is I have taken the greatest element and I kept it there and all the elements here will be greater than this why anyway 15 was greater than this and now these all elements were greater than 15 and 12 is less than 15 got it so that is why any of these methods will work either you can follow this method or this method what it now whatever you do whenever you delete the element the height of the tree will either be the same or it will decrease by one it will not increase by doing deletions we should never increase the height of the tree by doing insertions the height of the tree might increase okay now um let's say I'm taking the 12 element number 12 and I'm substituting it here then what happens here 16 and 12 will be deleted why do you think that 12 will be deleted right so because 12 is a leaf and you can delete it directly in case if 12 is not a Lea leave then it will have only one child it will not have two children okay my question is this see now when you are trying to delete either the this one the predecessor of the in order predecessor which means the small largest node from the left side or you are trying to delete the smallest node from the right sub tree I'm saying that it will not have two children it will either be a leaf or it will have only one child why is that so can you think about it my question is this see either you are trying to delete this element which was 12 earlier right so it is 15 right either you try to delete the largest element in the right sub tree or or you are trying to delete the smallest element in the uh sorry largest element in the left sub tree or the smallest element in the right sub tree I'm saying that either these two nodes will be leaves or they'll have only one child why is that true can you think about it the reason is simple in case if it is having two children then it means that it is having both the left child as well as the right child right then this one cannot be the greatest element why because it is having a right child since it is the greatest element it is not supposed to have any greater element which means it is not supposed to have any right child therefore in case if it is not a leaf it could have only one child which will be less than than this which means left sub tree then when you are trying to delete it you can follow that case isn't it what is the case you take the child and attach to the grandparent got it similarly here also on the other side now if this is the smallest element then it will not have any any left child because if it has any left child then it means that there are even smaller elements than this which is a contradiction isn't it if there are any smaller elements than this then the small smallest element will be this I would have picked up this got it therefore when you're talking about the smallest element in the right sub tree it will either be a leaf or it will have only the right child which means it will have elements greater than this but it will not have any elements less than this right therefore in any case either it will have zero children or only one child right in case if it is having only one child you can follow this case right so one child case what is it you can delete this and you can attach this and you can take it there got it that is how you know deletion deletion happens now let's follow let's fix up to one thing and we can do it so what do you want to fix up let's say I want to delete the H inorder successor so what is inorder successor the greatest element in the right sub tree is in order of successor what is inorder of predecessor in order of predecessor means the greatest element sorry the least element in the right right sub tree is called as inorder successor and the inorder predecessor is the greatest element in the left sub tree okay now which one do you want to delete let's go with in order predecessor in order predecessor means um you know the least the the greatest element in the left sub tree what is the greatest element in left sub tree 12 so let's let's do this now 12 will be there 15 is deleted right and next time let us say I want to delete node number 10 so if I want to delete node number 10 what is the case it is having only one child and when it has only when a node is having only one child we directly connect it to the grandparent isn't it therefore 2 will be connected to 12 directly which means 10 will be deleted and two will be connected got it now let's say I want to delete two yes you can directly delete it because it is a Lea isn't it let's say I want to delete 16 yes you can directly delete it okay and let's say I want to delete 30 so how can I delete 30 right since it is having only one child I have to connect you know to the grandparent this one 27 all right and now assume that I want to delete 27 so you can directly delete it since it is a leave right okay now let us assume that I want to delete 12 now this is interesting case see now there is only one child now it doesn't mean that you have to take only one child and connect it the entire link will go and get connected right so when you you delete this uh 12 the entire link this entire link has to be connected to 20 which means 17 will go here and 19 will go here got it that is how it happens now let us say I want to delete 20 if I want to delete 20 right then it is the root and it is not having any right child therefore 17 will become the new root got it now if I want to delete 17 then 19 will become the new root then finally 19 will be deleted that is how we delation works okay fine now while we are deleting a note from the binary search tree um we have to sometimes find out what is in order successor and what is the in order predecessor either either in order pressor or in not successor we are supposed to find it out right uh so the problem boils down to this now given any pointer to any node right or given any pointer to the root of a sube or the root of a tree how can you find out the least element in this or how can you find out the greatest element in this see okay what I mean to say is this one let us say I have a tree like this [Music] less than 15 15 16 okay now what I wanted to do is uh see the problem is this way whenever you want to delete the node 15 you are supposed to find out either the inorder pricor in order predecessor means the least value in the left sorry the greatest uh in order predecessor means the greatest value in the left sub which means this one or you are supposed to find out the in order successor in order successor means the greatest value in the right side the least value in the right sub which means this one right so now given any pointer to a node right uh how can you find out the smallest element in the sub tree right or largest element in the sub tree given any pointer to a root of the root of the sub tree how can you find out either the you know smallest element in that sub tree or greatest element in the sub tree now that is the main problem right let us say if I have here 40 and I have here 60 right so now let's generalize this so if you can write a function in such a way that given any pointer to the root of a sub tree or a tree if you can find out the greatest element or the smallest element in that particular binary search tree rooted at that pointer right then that can be extended to find out any any question like this okay so now what I wanted to do is given pointer to this one I want you to find out what is the least element in the binary search tree or what is the greatest element in the bin sry let's now find out the least element in the binary sry why because once you find out the least element in the binary sry rooted at this point I mean if I give you give you this point this pointer then you can find out the least element if I give you this pointer right which means if the function is going to work if the header pointer is given to this then the function will also work if the head you know the pointer is starting at this point isn't it so now let's try to solve any of this now what I want do is given the pointer to this node the root node I want you to find the least element in the binary sry for that I want you to write a you know function now what are the properties that you would like to see in the least element so whenever you have the binary sry right the least element will be to the left of it therefore I I I come down to the left and again the least element will be to the left of this and again the least element will be left of this again the least element will be the left of this in case if it it doesn't have any left then definitely it is the least element right so given any pointer to the root I keep traversing down to the left side and if I can't go any longer then that particular node is the least one right so in this case I keep on traversing to the left to the left to the left until I find a node in which the left pointer is null right so finally the least element will have the left pointer as null right all the other elements will not have we'll have the left pointer some pointing to something isn't it the left pointer here will be pointing to this got it so now how can you write dative function now let us say the function is find in order predecessor right of you are given a you know node pointer T struct node star T which means you are given a pointer t T and now you are supposed to find out what is the least element in the sub tree pointed by T either that sub tree could be this the entire tree or the sub tree could be this right or the sub tree could be this starting with this right whatever it is I wanted to find the least element in that sub tree okay now the least element will not have the left pointer isn't it therefore what I'll write is while T left so what does it mean as long as T left is not equal to null right so why if I write like this while T left it means that as long as T left is not equal to n which means T left is pointing to something then you keep traveling left side right T = to T left so what is the meaning of it as long as you know you are pointing to Something in the left or your node is having some know left left side left side children you keep going down and when are you going to stop it so you are going to stop it whenever you don't have any left sh right which means if you are calling on this now the left is not equal to null isn't it t left is not equal to n therefore you know if you start from here your T will go here right t equal to T of left and again T of left is not equal to n therefore you will go here right and again T of left is not equal to n you'll go here right and finally since T of left is equal to n you are going to stop here here got it so this function can be used to find out the in order predecessor or you can say find out the minan in the sub tree right so you know it can be used like this find minan and you can know if you want to use this function in order to find out the in order predecessor while you are deleting the know node then then what you do is um you go to the right sorry you are you are going to call find the inorder successor using this okay so you go to the right if you want to delete 15 you pass to this function the node I know to the right of it then when you pass this pointer this function is going to find out the least element in this uh you know sub tree then once you find out the least element in this sub tree you can swap it all right so that is how you know this works all right so next one is let's say I want to find out the maximum element of the uh you know tree then find Max I to find the maximum so what is that the maximum element we have so when you are seeing this in order to find out the maximum element from here you go to the right because maximum element will find will be present in the right sub tree right then again you go right again you go right now you keep on going right until it is possible and you are going to stop when it is not possible so how do you know that the right sub tree the right pointer of the greatest element will be null right then how can I find it oh this is find Min right this is find minan function okay now I want to find Max so don't byard them see using your intuition you can write them so what I mean to say is don't byard these all these functions if you have to byard all these functions they'll be hundreds of functions you might have to by heart so just use your logic intution and you know with this practice questions with these many questions which we practice it will be easy okay now find Max which means you have to go right and uh you know you are supposed to find this so you will be given a pointer stru node star T and you are supposed to find Max of this right and before this you had to even check whether it is null or not right so sometimes if T might be null right in that case you had to even check this if t equal to n return you had to keep that you know checking condition also in place anyway let's look at the main logic here so while what should I do as long as I could go right right how can I know whether I could go right or not the T of right will be not null as long as T of right is not null you keep on moving right so what is it t = to T right okay this is how you could you could apply the logic now what happens initially if T is pointed here if T of right is not equal to null we go to the T right which means tal T right means we'll be here and again we go right tal T of right means here right and again we go right and from here T of right is not you know is null therefore this one will be broken and we we we stop here right so we'll stop whenever we find the maximum element now how do how could you use this function in deleting an element is you can go to the left sub tree and find out the max that is also called as in order predecessor right so find Max can be substituted in the place of inorder predecessor finding inorder predecessor given the appropriate pointer and find Min can be substituted for in order successor which means give it to the pointer to the right sub tree right then it is going to point find out the inorder successor and give it the pointer to the left sub tree and is it is going to find out the in order priser okay that is how I could use this the main intention of binary searry no the building binary sarry is to make the searching efficient uh no if you if you put all the notes or all the elements in a link list then the problem is search time may be as big as order of n right so in order to reduce this search time we are going to use the tree so we thought that just by using binary search tree the search time will decrease and in many of the cases it is going to decrease most of the cases but then the problem is sometimes the input sequence might be in such a way that uh you know even though it is a tree it might look like a list link list and therefore the search time will be again order of n the main intention of binary search Tre is to decrease the search time from order of N and in most of the cases it is true it is going to decrease right I'll tell you some examples in which uh a binary search Tre will look exactly like a link list and the time complex is going to be very very high let's see this let us say I have a binary search tree and I want to you know insert into the binary sry the elements like this 1 2 3 4 5 6 so on right then first one will be inserted and when two has to be inserted it will be inserted in the right right and when three has to be inserted three is greater than this greater than this and it will be inserted here and when four has to be inserted four will be inserted here right five five will be inserted here right so on right now if you look at it even though it is a tree it is looking like a link list isn't it now in order to reach any node we have to Traverse the entire list which is going to make the time the time taken to such a node is going to be order of n even for insertion right so if the insertion is in this sequence so time complexity for this searching is order of n right but then what is the advantage of a using a tree in you know if it is going to be exactly like a list then there is no use of using the tree isn't it therefore what people thought is you know let's re rebalance it so whenever we insert a tree a node into a tree then it is going to become skewed skewed means it is going to grow on only one side right or it is going to be imbalanced right then what people try to trying to do is they're trying to balance it so for that reason you know there are various balanced binary sries proposed so one such popular tree is AVL tree AVL okay so AVL tree means it is named after three Russian scientists who discovered it so AVL tree is the algorithm I mean AV AVL tree is a balanced binary SAR Tree in which if you have n nodes the height of the uh tree will be always order of login that is what is balanced binary SAR streaming so what is the main difference between binary sry and balanced binary sry every balanced binary sry is also a binary sry but then the order of height or the height of the balanced binary sry will always be order of log in but in case of ordinary binary sear Tre if it is not balanced then the height could be as big as order of n right and when the height is order of n then the search time is also going to be order of n if the height is order of log n then the search time is going to come down to order of log n right so AVL is one example of balanced binary s tree like this we have red black Trace and we have two three trees right and we have Fibonacci hips and many things right but then the I mean these are all the data structures which are generally used to help us in searching the in searching the data very fast right in login time and AVL is the most popular method so let's talk about AVL now okay so what does AVL say is AVL is based on something called as you know balance Factor so balance factor of a node is like this if a node is here and if it is having some left sub tree right and if it is having some right sub tree left sub tree and right sub tree then balance factor of this node is generally taken like this height of left sub tree minus height of right sub tree so we find the right height of left sub tree and from that we decrease the height of right sub tree so in case you know if the B if the balance factor of this node is either minus1 or 0 or 1 then these three are allowed in AVL trees anything other than this which means whenever any balance factor of the node reaches minus 2 or 2 it means that the tree is going to be unbalanced then in this case we are going to balance it okay so how are we going to balance it is I'll take examples and explain you how to balance it and all this I'll just show you uh see now assume that we are going to insert nodes like this 1 2 3 and it is inserted like this 1 here is three and here is two what is the balance factor of this Leaf is zero is0 right now what about the balance factor of this height of left sub tree minus height of right sub tree which is 0 - 0 so it is 0 so it is valid no problem with this right and now assume that um [Music] 1 2 and 3 okay uh so now let's uh let's define the height of the sub tree like this in order to Define this height okay in this problem let's define the height this way height of the you know Leaf is one let's start from there height of the leaf is one okay let's do it that way so height of the leaf is one then the height of this one is two okay for this problem see for every problem they are going to Define what the height is so for this problem I'm defining the height to be uh starting from one so most of the problems they Define the height to be starting from zero that is fine but but you know here I want the height to be defined this way height of a node of a leaf node is one and the next one is two and next one is three like that okay the reason is you'll understand it now okay now let us say 3 is the root 2 is left and one is left so this is the binary s tree now let's see what is the balance factor of this so balance factor of this is zero because there is no left child no right child what about the balance factor of this height of the left sub tree minus height of the right sub tree what is the height of the left sub tree it is 1 minus height of the right sub tree is no right sub tree therefore zero so balance factor of this node is one what about the balance factor of this height of the left sube minus height of the right sub tree what is height height of the left sub tree you know this one height of this one is zero sorry one and height of this one is two therefore height of the left sub tree is 2 and minus height of right sub is Zer therefore height of balance factor of this one is two this one is 1 and this one is zero now if You observe it the balance factor of this node this particular node is not no 0o or 1 or minus one therefore if it is not these three numbers we are supposed to balance it so it is called as l l imbalance right left left imbalance so whenever we have L imbalance we try to uh you know rotate it clockwise that is called as rotation all right so whenever we have ll in Balance then we are going to rotate it right rotate it clockwise so when I rotate it clockwise right by having two as the center see how do you know that two should be the center with practice you'll be able to understand it I'll I'll do a lot of practice questions here okay now hold this and tilt it then what happens two will become the root and one will become the left child and three will become the right child right that is called balancing now you check it this the balance factor of this is 0 0 and the balance factor of this is z by 1 - 1 is0 got it so this is how you settle down the unbalanced nodes now whenever you try to insert a node we are always going to see that the nodes which are going to be inserted into the tree are always balanced which means after every insertion we are going to check if the nodes are imbalanced right in case if they are not balanced then we are going to balance them that is how aval insertions work in any balanced binary sry how is it different from binary sry is in binary sry we simply insert and leave there but in case of balanced binary sry after every insertion we are going to check whether it is there is a imbalance there all right in case of any you know imbalance then we are going to balance it and then leave it okay so insertion in binary s balanced binary s is insertion plus balancing okay now this is this is one way of imbalance let's see if there is any other way of imbalance let us say one is inserted and then two is inserted and now three is inserted okay so after inserting the last element we are supposed to Traverse from that lost element till the root on the way we should check if there is any imbalance right so how do you check for imbalancing after element after inserting an element you start from that newly inserted node towards the root node on the way you see if there is any imbalance in case of any imbalance you are you are supposed to level it out okay now what about the balance factor of this it is zero why left side right side there's nothing what about the balance factor of this left side there is nothing therefore height of the left sub Tre is zero and what about the height of the right sub tree I told you that leaf is at height one right then 0 - 1 is - 1 then what about this one left side there is nothing right side there are two therefore 0 - 2 is -2 right now again there is a balance right so imbalance here so in order to you know balance it you have to tilt it anti clockwise got it so how do you how do you know which way to tilt with experience you'll be able to understand it or you can by hard this right so it is called as RR imbalance right and in order to level all RR imbalance you are supposed to tilt it left side okay now I'm going to rotate it I'm going to rotate it like this so it is anticlockwise right I'm going to rotate it this way then what do we get 2 1 three see after doing practice you will not need to by heart it you'll understand it and you'll be able to do it first don't worry about it initially it might be difficult so balance factor of this is zero this is zero and what about this this one is uh you know zero so it is balanced now one other kind of imbalance may be like this let us say an element is inserted like this three and then an element is inserted like this 2 and then an element is inserted like this one right so now what happened see the order in which I inserted the elements is three is inserted first and then two is inserted next and then one right why should I insert in only this way Graham law right if something is possible it will definitely be therefore I have to definitely handle all the cases right now watch it so what about the balance factor of this zero what about the balance factor of this left left know height of the left sub tree is one right sub tree is 0 therefore 1 - 0 is 1 what about the B factor of this left sub tree is zero right sub tree is 2 therefore it is min-2 again there is an imbalance right so what kind of imbalance is it it is right left imbalance how to find it out see after inserting any element newly added element you have to travel from that newly added you have to travel from the newly added node towards the leaf I mean towards the root and on the way you should check every node for imbalancing right if you find any imbalance then you have to balance out there right so now how do I know that you know it is right right left imbalance because from the node where we got the first imbalance again you try to travel towards the newly added node so it is saying you have to go to the right and then left that is why it is oral imbalance so whenever you have oral imbalance you are supposed to do two rotations okay one rotation is clockwise rotate clockwise right so if I rotate clockwise I have to hold this and rotate it like this tilt it like this then what I get is three here and I'm holding it and tilting it like this one here and two here right now what is it it is RR imbalance right now again this is also not balanced so one more time I have to rotate it so now rotate it anticlockwise now if I if I rotate it anticlockwise I have to hold this and rotate it this way then what do I get oh this is actually uh I went wrong here sorry so it has to be one and it has to be three and it has to be two okay now it will make sense it has to be one and it has to be two and it has to be three I got involved in the algorithm that I forgot to see whether the tree is a binary sry or not sorry for that okay and now you have to do it again clockwise so again I have to do it clock this sorry anticlockwise then what do I get two here one here and three here got it so now you know after doing everything you should check the balance factors and also you should check that the resulting tree is again uh you know binary search tree see this is the resulting tree binary SAR tree yes why it is less and is greater is it binary SAR tree yes less greater is it binary s yes so after inserting any element you are supposed to even check I mean after balancing out you are supposed to check the balance factors yes they are zeros but along with that if you did everything right then the result will also be a binary sry in case if the result didn't turn out to be a binary sry then you should understand that you did something wrong there okay huh now let's see one more type of you know imbalancing now let us say initially I inserted the node three and then I inserted node um 1 and then I inserted two where will I insert two two is less than this and greater than this which means two will be falling here right now let's see the balance factors so what about the whenever you insert any new node you should check for every node but then I since I know that it is not an imbalance I didn't check it but in general you should check whenever you insert any node from that node you should go to the root now from here the balance factor of this one is zero the balance factor of this one is 0 - 1 which is min - one why left sub tree is zero right sub tree height is 1 that is why minus one what about the balance factor of this you know height of left sub tree height of left sub tree is two and the right sub tree is you know zero therefore the balance factor is two so I have to balance it now what type of imbalance is it so in order to find out what type of imbalance it is you have to travel from the imbalanced node to the um you know newly inserted node so this is the imbalanced node and I had to go from here to to the newly added node so how can I reach there l r right therefore it is LR imbalance right now what do we do in LR imbalances we have to again see either it is RL or LR I to do two rotations in case of RR and LL only one rotation is enough right so now I had to do here two rotations so one rotation is I have to hold it and turn it anticlockwise so initially I to rotate anticlockwise okay so I'm going to hold it and rotate it this way then what happens 3 will be here 2 will be here and 1 will be here are you understanding it I'll hold this and rotate it this way don't worry with practice it will be easy I'm holding this and rotating it anticlockwise which means this one will come like this this one will come like this two will come here and one will come here right then what is it it is LL imbalance now we know how to level out L imbalance we have to rotate it clockwise right so again I'm going to rotate it clockwise so if I rotate it clockwise I can hold it like this and pull it down which means two will be here three will be here and one will be here balance factor is 0 0 0 that is how we balanced out got it see one thing here after rotations we got all the balance factors to be zeros but even if you don't get all the balance factors to be zeros even if you get them to be one or minus one it is okay you can leave it there but only thing is two is not allowed as long as you have a node with to we keep on rotating right so few things that you should observe is whenever I insert any node only one node is going to be imbalanced and once you balance it out it is enough all right and after inserting a node you should always travel from the newly inserted node towards the root to see on the path if there is any imbalance if there is any imbalance you are supposed to level it out how start from that imbalanced node and then start you know start going towards the newly added node then you'll understand what type of imbalance it is either it is LL or RR or RL or like this okay and then you could rotate it rotate them according to your wish and you'll get the answer right so let's now practice some questions about how to do this uh you know balancing okay we have seen some um abstract binary trees you know in case of abstract syntax Tre in case of compiler design if you remember them right so there are two types of you know trees one is abstract and other is concrete so normal past trees are also called as concrete syntax trees and there is something called as abstract syntax trees I'll just show you what I mean by that and these trees have got some significance when we are trying to travel or know do some traversal on them for example if I have a + b right the tree can be written like this the syntax tree this is also called as expression tree because we are writing the expression in form of a tree isn't it mathematical expression is written like a tree now you know uh this has got some significance in terms of traversals in the sense if you try to do uh let us say let's see in order pre-order and postorder traversal of this tree I want to see in order pre-order and post order right so what is pre-order first time visiting right so first time when use it write it plus first time yeah second time y third time y second time plus first time B second time B third time B third time plus right so if you see this on the expression tree if you perform in order pre-order traversal it is going to give you prefix expression if you perform inorder Trav traversal it is going to give you infix expression and if you if you do a post order traversal then it is going to give you a post fix expression that is the significance of it okay understood this maybe we can do one more example let us say I have a + b into C now what is expression tree for this now which one has got highest presence star so first you have to execute you know B into C and then you had to add a to this right then let's see what is pre-order in order and post order for this okay now pre-order is first time so first time first time second time third time second time first time first time second time second time first time second time third [Music] time third time okay here B has been Ved third time right so I missed it out right so third time third time plus got it so this is the prefix expression and this is the infix expression and it is the postfix expression got it so only thing you should be careful is about is you know with unary operators with unary operators when you try to write the you know uh you know this expression tree just see that the traversal the infix traversal gives whatever you wanted for example if I have minus a un expression right so definitely operator has to be be at the root should the oper hand be here or should the oper hand be here that is what I don't know right so should I put it here or here so if you want to decide it you know try try with both of them and then see uh which one infix is giving giving you the actual answer so if you travel in infix you are supposed to get minus8 so what is infix second time right so first time first time second time which means a will be printed first therefore and then second time right therefore it is not the infix expression which we required so this might this might not be the actual one so actual one must be like this isn't it why now see I'm just trying it that's it now if I see first time no second time print it first time no second time print it therefore infix expression is going to give me minus a therefore this must be the know expression tree representation of this expression if you have any doubt you have to see the infix know the inorder traversal that inorder traversal should match up with the given expression for example if you have a factorial right you know that factorial has to be always operator has to be at the root I mean at a higher level compared to the operant now I don't know whether I should put it here a here or I know I don't know whether I should put a here so I don't know where to put a then what I'll try to do is I'll try to Traverse it so first time no first time no second time yes so a is printed third time second time a factorial therefore a factorial is printed whenever I visit second time and this must be the actual tree for this expression got it uh let us say you have log so now log a Now log a is similar to minus a so where should I put so log should be here right and a should be here got it what if I have log a factorial right now we can combine these two so first I have to apply a factorial a factorial is having higher precence right so a factorial means it is kind of this right therefore you have to write like this factorial and then a this is going to give you a factorial and then log a which means you can take consider this entire thing to be log a you know you can consider this entire thing to be X then it is as good as writing log X then what should we do log should be at the root right isn't it and should be in the left yeah log should be at the root like this log factorial a is it I think minus a this one is right okay a factorial this one is right okay and uh log a I think this is log a has to be this one right see again log a is this one is not right I feel log a this one is right because it is similar to minus a right so just check this uh first time don't print yes second time log yes first time don't print second time a so this is log a therefore a factorial is this first first if I have log a factorial I should find out a factorial so let me put a factorial like this so which means factorial here and a here this is a factorial got it now after putting this a factorial I should apply log so log a is like this right so if I have log X then it whatever you want to apply log that should be as the right sub tree now I want to apply the log a factorial right so this entire thing should be the right sub tree to log log here and here right so now you you try to Traverse it in order and you are supposed to get log a factorial watch it first time second time therefore log will be printed first first time first time second time therefore a will be printed third time second time therefore factorial will be printed log a factorial got it so if you don't know how to put this you know unary operators you try with all possibilities and see that in order is supposed to give you that particular uh you know tree and see always see that operators are present at a higher level compared to operants operant should be present at the leaves and operator should be inner you know internal nodes so once you have internal node at the as the operator then you don't know whether to put it here or here that depends on the traversal try to Traverse it in order and find out whether it should be present here or here got it and when you have you know a combination of operators then you build it step by step for example here if you have log a factorial you know that a factorial has to be executed first that is why you construct the tree for a factorial and then you try to apply log as if this entire a factorial is X right so now you first you construct this for a factorial now this is what I got now act as if this is a single node and you try to apply log to that this is what we got okay um fine there are various ways to represent the trees U one popular way which we have seen is the structure representation every node is represent by a structure and there are Pointers which are pointing to the other nodes right that is the most popular representation which means you have already seen like this if I have a tree the root is represented like this right and then the left child and right child isn't it so this way of representation works well for the binary trees but there's a problem with this representation sometimes what happens is um you know the tree might not be binary in the sense the number of children might be more than two let us say the number of children is as big as 10 so the number of children is more than two and moreover all the nodes might not have all the 10 children so you you know declaring or having 10 pointers in every node is actually a waste of space isn't it see in this case it is fine but I'm saying that in some cases what happens is in some trees the children can be not two it can be 10 in that case it is representing it 10 pointers inside one node is actually waste of space given that all the nodes might not use up all the space even though you are declaring it right in that case the best thing to do is there is one more representation called as you know uh left child right sibling representation left child right sibling so what is left child right sibling is um if you have a child you know a tree like this four children there and then three children and then two children like this then instead of having 4 point in one node every node will have only two pointers one pointer will point to the leftmost child and the other pointer will point to the right sibling for example the root is having four children right then one of the pointer of the root will point to the leftmost child and even the every node will have right sibling right so right sibling pointer right sibling pointer right sibling pointer therefore just by pointing to this child it can get all the children right how it is having the right children pointer right now the right children the right child pointer of the root node and the right child po right sorry right sibling pointer of the root node and the right sibling pointer of The rightmost Sibling will be null why because they don't have any right sibling there right and the same representation is used for this also so this this note has pointed what its right sibling is and it will even say what it left child is which means this one it will point to this and that left child will point to it right siblings right this is the right sibling and this one's right sibling is this one right so that is how you know everything is represented if it is also having some child it is also going to represent like this right this is called as leftmost child right sibling representation which is used to save the poters so it is it is going to be useful for not for binary trees see anyway for binary trees we need only two pointers right but if you have more than two children which means if you have 10 children 20 children like that in your trees then it is is going to be very very useful this this representation right it is commonly used to represent arbitrary trees like 10 children 20 children like that it is not used for binary children binary binary trees where we have only at most two children right and the other representation is aror representation aror representation of binary trees is quite popular I'm talking about binary trees okay so coming to Binary trees one more representation popular representation is AR representation so what we do is if we have a tree like this all right let us say the notes are a b c d e like this then we represent all the notes in an array in such a way that uh searching for a particular element is easy searching for a particular element in the sense searching for what is the left child what is the right child what is the parent such kind of searchings can be done easily if I represent it like this so how is it possible is watch it now uh we place the root in the first index let us say this array is represented by some uh a then this one is going to be placed in a of one right and left child is going to be placed in two and it is going to be placed in three so how does it work is if a node is at index I then its left child is going to be at the index 2 I and the right child is going to be index 2 I + 1 so what is the advantage of using this 2 I and 2 I + 1 representation is you know multiplying with two in binary system is nothing but left Shifting the number by one which means if I have the number 1 Z what is the value of it it is two right multiply with two which is nothing but four so multiplying by two is nothing but left shifting it by one so 2 I Computing is straight forward just left shift it you are not multiplying right and what about 2 a + 1 2 a + 1 is left shift it if it is the number if I want to find 2 I + 1 if this is the I left shift it and then R it with one then I get this isn't it therefore it is very simple to find out the left child and right child if I use this representation right and moreover finding out the parent if I have a node X at point x then parent of the you know X is simply X by2 which means if this is the you know location of a of a node then its parent will be present at by 2 by2 is nothing but you know right shift by one so division is nothing but right shift by one even here also the parent of this one will be right shift by one if you right shift it we get one Zer right which means the least significant bit either it is one or zero will will go away and the remaining part is going to be the uh you know the parent got it so finding out the parent is e and finding out the left child and right child is easy using the array so according to these rules defined if root is at uh you know uh location one like a then where is the left Child Left child is going to be 2 into 1 which means here and right child is going to be 2 into 1 + 1 which means here right and again if 2 is here then the left child of 2 D where will will be 2 into 2 is 4 right therefore D is here and where should we place e see this parent is at 2 therefore 2 into 2 + 1 which means 5 got it and where are we going to place F so parent is at three then F will be in 2 into 3 which means 6 and where are you going to place g g will be in 2 into 3 + 1 which means 7 like this we can fill it up so binary this Arrow representation is going to be useful especially when we have to find go down to our children as well as go up to the parent see in this kind of representation we can only go down right and going up is not very straightforward once you are here going up is not straightforward unless you have saved the pointer to the parent right so here traversing is easy and that is why it is widely used in the implementation of heaps and you know in a heap we might have to go down as well as go up and moreover it is beneficial for Heap because Heap is a almost complete Banner tree and it is also almost full Tre which means in if you look at the order in which you fill up the notes in the Heap right we fill up the notes like this this way right which means this one will be filled first and then this one and even if you write the indices you know they will be index like this only right 1 2 3 4 5 6 7 8 9 so next one which has to be imp you know inserted will be here right therefore the way in which the indices are growing and the way in which you are performing the inserts are consistent right therefore representing a heap as a array is very beneficial because of the way it is growing isn't it you are growing it like this and even you are inserting it at the corresponding places right so representing an array like you know a binary tree as an array in terms of you know in place of that in the implementation of Heap is beneficial but the disadvantage coming to this AR representation is if the tree is skewed like this right so where are you going to place this one this one will be placed in one what about this 2 into 1 + 1 which means 3 what about this 2 into 3 + 1 which means 7 what about next one 2 into 7 + 1 which means 15 even if I have only four elements the array should contain as many as 15 indices which means the size of the array is you know 15 so in worst case if the entire tree is skewed and if it has got an element right then the size of the arror required is going to be 2^ N - 1 this big array you should require isn't it see this so for 2^ 1 - 1 which is 1 so for two elements 2^ 2 - 1 which is three for three elements 2^ 3 - 1 this is the disadvantage in AR representation as the tree grows cued the number of the array size becomes exponential which means even if I have to store n elements I might have to have a array as big as 2 power n this is the worst case so for all normal trees using this Arrow representation is not advisable only when you know that tree is going to be almost complete like this and it is going to grow in the level order right then it is better that you go with this kind of representation so especially heaps are perfectly suited for this representation that is why heaps use AR a representation of trees right and next one is one more representation is there which is not very very popular but then still it is in use sometimes people will use it but then it is not widely used uh they say that if you have a b c like this you can represent it in a nested form nested form means you can use a parenthesis to represent every sub tree so they say that you can either write like this b a c and you can say that the this one is left right leftmost uh leftmost Child Left child and this one is root and this one is right child or you can even represent like this you can represent it as root Left Right which means this one is root and this one is left and this one is right so whatever way you decide upon you can represent it using the nested form right let's see let's see an example how to represent in nested form a tree so one representation of nested form is is if I have a b c d e f g let us say I want to represent it in nested form in the form of root left right okay now what is the root a is z root fine what is left left is a sub tree right is a sube therefore left is a sub tree and right is a sub tree now let's go into left sub what is the root B then what is the left of it D and what is the right of it e right what about this one root is C what is the left of it f what is the right of it g all it so this is how we can use the ne representation so we have mainly four representations one is the normal representation where we use the two pointers to represent left child and right child in case of binary treeses right normal representation using structures right pointers using pointers and structures right and this second second one is also using pointers and structures which is going to use left child right sibling representation right and this is used for you know not for binary trees if the uh number of children are very high which means generally for an Tre where n is very very high n is very very high compared to two then we are going to use left child right sibling method here also we use pointers and structures and the third representation of the tree is AR representation and AR representation is very very useful in case of hips right and it is very useful whenever your application contains almost complete binary trees or almost full binary trees okay so if the binary tree is containing lots of nodes then you go for it in case of in case if your tree is going to be skewed then this representation is not very useful and the next one is this nested representation whatever I shown you it is not widely popular okay these are all the various representations and you can choose the representation depending on your algorithm so if your algorithm requires you know what kind of uh data depending on that you can choose one of them whichever gives you better performance all it okay graphs and graph Theory have been of great interest for computer science students as well as the researchers in the recent past see earlier graph theory was not considered a part of computer science it was completely not not all studied by you know computer science Engineers or anyone from computer science they have been kept aside but then with the Advent of internet right since 1980s there has been a great interest in in this area especially by you know people from computer science uh the first know the one thing is with the Advent of this internet what happened is they represented the entire worldwide web as a graph right so every web page is now a node and if there is a link L from one web page to the other web page then that is an edge therefore entire worldwide web can now be modeled as as a graph and we know we are interested in know knowing various properties of these graphs exploring various properties based on this search is going to be relevant and search times and everything can be improved right and moreover with the Advent of the social networks especially this Facebook and other social networking sites what happened is they they started representing this entire social network also as a graph if you are a if you are a person you you are a node in a graph right and if you are having your friends right all your friends are also notes in the graph and you'll have a uh link like this see I'll just show you what I mean to say is this see generally a graph is represented like a set of vertices and the set of edges isn't it a graph is represented like a set of vertices and edges right now there are various application of graphs one is in the you know worldwide web where every node is a web page and if there is a link between from one web page to the other web page then you know we can represent it as an edge right so and then in social networks what is happening what is happening is if you are if you are a person in a you know if you're having a profile in a networking site social network site then your profile will be represented as a node in the graph excuse me which means let let us say you are here this is you and all your friends in the networking site are going to be the notes in the network in the graph and there will be a edge between you and your friends which means if you know if you are friend with let us say a b c d right then you are having no edges between you you and all of them right and you are not a friend with let us say e f right and you don't have an edge got it so and if he is friend with someone right then they will have this Edge right and now there are various properties you might want to see for example you know in uh in Facebook you might see this friend sessions they might they might show you you know this person might be your friend right so how is that possible they'll do some traversals so there is till now we have seen some travels know in like um pre-order in order postorder in U you know that that particular you know trees right so while coming to trees the main difference between a tree and a graph is in tree it is connected which means from one particular node you'll be able to reach all other nodes but in graph it may not be connected right then what happens is in tree if you start you know walking from one node you'll be able to reach all the other nodes that is why it is called as traversal traversal means you'll be able to get to every node possible and such a kind of traversal might not be always possible on a graph the reason is if you start from one node there is no guarantee that you'll be able to reach all the other nodes in the graph because the graph may not be connected so which means this will be one component and you might have some other component in the graph right and these two components might not be connected so if you start from a node here you'll be able to reach all the nodes which are connected to this but you'll never be able to reach these nodes right in such case it is called as search search all right so traversal techniques mean that we want to visit every node that is traversal such techniques mean that we we may not be able to visit every node therefore we are interested in know visiting only the notes which are reachable and using this search we can Implement traversal how once we start searching from one particular node we'll visit all the noes which can be reached from this and then out of the remaining noes which are not at visited again we'll start the search got it so traversal means visiting everything search means visiting only the notes which are reable from some particular node if you are starting this search from that particular node okay and why am I talking about this travels and searching is the most important problems on the graph are all about travel Sals and search see now the information is present in the graph and now we have to get that information out so how do we read the information just by traversing or searching isn't it and you know let's let's go back to that Facebook problem let us say in Facebook you are going to have this problem as you know your friend solution so is he your friend is she your friend they'll ask you these questions right now how is that done now watch it see if you are here all your friends are nothing but the notes which are adjacent to you what is adjacency is if there is an edge between you and you know one between one node and the other node then these two nodes are said to be adjacent right for example let's say this uh this node is R okay now what is the adjacency what are the nodes which are adjacent to R all the notes which are adjacent to R are nothing but one is D other is C other is B other is a right these are all the notes which are adjacent to R therefore you know if I represent every profile as a node in The Social Network then what is the friend list friend list is nothing but the adjacency list so adjacency list in a graph is equal to friend list in the Facebook got it and now uh see if you standing here then there is a probability that you may know a person whom your friend might know right therefore you know we start from a particular node and we try to uh search so how do we search is we search in a bre breath fast manner breath first manner means we search for all the elements which are at a distance one right first these are nothing but all your friends and then we search for all elements which are at distance two distance two from you so what can you say about the notes which are at distance two from you they are the you know they are friends of your friends isn't it see if a node is at distance two then definitely you have to go through a node which is a distance one right now if this node is a distance two from you you have to go through your friend isn't it therefore he's a friend of your friend therefore all the vertices which are a distance to isn't it this one this one and in fact if you have someone here right all these vertices right in fact if you have someone here someone here these are all friends of your friends got it therefore when we search it this way bread breadthwise which means we search for all the elements who are at distance one and then we search for all the elements who are at distance to then you are going to get friends of your friends isn't it now the chances are that if a friend is if a person is a friend of your friend then you might be knowing him right therefore they are going to use a search breath for search exactly not breath for search they are even going to do some modifications like you know if a person is going to be in mutual friend list of many for example if this person knows him and this person knows him then the chances that this person you know you know this person is going to be high rather than this person if there is you know if he is only only a friend of one person right he might not be a well-known person to you com you know compared to this person so they are going to modify it anyway but then if you apply breath for search I'm just taking giving an example of an application if you apply breath for search if you start from a node here right and if you try exploring your friends and then friends of your friends and then friends of your friends like that then you might get people whom you might know so that is how Facebook will give you this a modified version of this now what about depth first search depth first search says that you go as deep as possible as far as possible and now you find the value know some person there then what does it mean if you apply the depth for search here then how does it work is first your friend will be explode and then his friend will be exploded in case if he's having any friends he'll keep on explode right now it will go and stop at somewhere in us if you are in India right it might stop at some person in in the US and you might not know him at all therefore depth first search fails here right but then both breadth first search and depth for search are equally popular and there are various applications for both of them right so these two suches such techniques have to be discussed and before discussing about any of the algorithms like search or traversal we should discuss about the data structures which are used to represent the graphs okay so there are various ways to represent the graphs we shall see the graph representations and then these algorithms okay there are two popular representations of graphs I'll show you both of them just watch it see let us say a graph is like this we have four nodes okay A B C D so generally what we do is we number them with some indices which means we assume that a is 1 B is 2 C is 3 D is 4 like that and then we go ahead but then you know to make the things simple I'll just have the names themselves and I'll show you the representation and the con is very straightforward okay so now what I mean to say is we not to represent this graph obviously we are not going to draw this diagram and store it in the computer and then and know use paint or something to store it right we have to represent it in some other representation in in terms of some data structure right uh so one popular representation is uh like adjacency Matrix right it is called as adjacency Matrix so what is adjacency Matrix is I'm going to have number of rows and number of columns equal to the number of nodes which means every node is going to have a row and a column for example since there are four nodes I'm going to have four rows each one dedicated for one one node and four columns each one dedicated for one one node right for example a b c d a b c d right now what about a to a a to a there is no Edge right what about A to B there is an edge right what about a to um a to c there is no Edge what about a to d there is an edge right what about B2 B2 a yes there is an edge what about B2 B no Edge B2 C there is an edge B2 D no Edge what about C2 a C2 a no Edge what about C2 B Edge what about C to C no Edge what about C2 D Edge what about D2 a edge D2 B no Edge D2 C Edge D2 D no Edge right so this is how we can represent it in case if it is a weighted weighted graph which means if the graph is having some weights then we are going to represent even weights there right this is one one popular representation and the other popular representation is having a know link list so we can have an array of pointers and you know this are will contain the number of elements which are equal to the number of nodes there and each element will have will be corresponding to one node if I have four nodes then I have four an array of four pointers right and now each pointer is going to point to a link list so this link list will contain set of all you know nodes which a is adjacent to now what about the a a is adjacent to B right a is adjacent to b and a is adjacent to D got it here is a link list and what about this a b is adjacent to A and B is adjacent to C right what about c c is adjacent to A and C is adjacent to D what about d d is adjacent to a d is adjacent to A and D is adjacent to C got it so this is a link representation of the graph right so we can even either represent the graph as this adjacency Matrix or the link list representation now which one to use what really makes sense that depends on the type of the graph if the graph is dense dense means you know if the number of edges are very very high right then it is better that you go with the Matrix right so which means for the dense graphs so let's define the density now so dense graphs means um if the order of edges if the number of edges in a graph is equal to order of vertices which means if the graph is almost complete I'm not saying that it is complete but if the graph is almost complete right if the number of edges is equal to you know order of v² then in this case it is better that you go for you know adjacency Matrix because we are going to use up most of the cells right so otherwise if it is par sparse graphs means um if the order of edges is equal to order of vertices which means if I have very few Ed edges then having this big Matrix and then having only ones here and there and complete the zeros is a waste of space right so in case if the graph is parse you go with adjacency list right in case if the graph is dense go with adjacency Matrix for example in Facebook right in I told you that everyone is going to be represented as a node and now your friend list is nothing but the adeny list now in that representation should I should I represent the entire Facebook as a adjacency matrix or adjacency gra know adjacency list which one makes sense adjacency list makes sense because a person is not going to be a friend to everyone right there are nearly 6 million users I don't know exactly how many number recently but there are millions of users in the Facebook right I don't know exactly how many million so with this you know these many million vertices are there but how many edges are there which means how many people really know all others right or how many people is one person adjacent to is one person friend to right they they are having a limitation that 5,000 isn't it so a person cannot have more than 5,000 friends right then in that case you know if you know deciding a or dedicating a matrix see let us say there are there are few Millions right so if I have to represent the entire Facebook as a adjacency matrix then what happens is I need to have the graph as big as Million by million Dimensions right and out which means every node will get million entries here right but then if you see their limitation they are limiting the number of friends that a person can have to only 5,000 members right which means out of this 1 million entries given to you you'll be using only 5,000 bus isn't it and all the remaining are going to be zeros out of few million entries you are given you are going to use only 5,000 and remaining are all going to be zeros right and many people are not even going to use 5,000 members right most of the people will have only 100 or 200 friends or 300 or right but 5,000 is a very big number even if you go for 5,000 most of the spaces are going to be zeros right so in this case representing the entire entire Facebook as the adjacency Matrix is waste of space so what is the best thing go with the adjacency list right so every person will have a pointer and that pointer will indicate who is the friends to him right for example if you're having you know 10 friends then your your your pointer to the you know friend list will contain 10 elements right so whenever you load that page you are going to retri the data from this got it so depending on the type of the graph we are going to go with this and one more interesting point about this is um how many entries will be there here in this in case of undirected graph which means like this in case of undirected graph the number of entries in the list completely will be 2 into e the reason is every Edge is going to contribute to one element right if there is an edge from A to B that will be present here as an element and then B to a right therefore every Edge is represented two times in this list therefore the number of elements that will be present in this link list the elements is going to be 2 into e in case of undirected graph like this right what about directed graph in directed graph what happens is we have directions like this okay then we have a Edge from A to B but not from B to a in that case every Edge is going to be represented only one time therefore in this space for every Edge we get one representation so in case of directed directed graph we have you know um e number of nodes in this in this list complet complely got it so just remember it that you know the size of this one is see in this one what about the total size the total size is going to be order of n Square the space required is order of n Square what about the space required here uh so for n nodes for n nodes n elements are required for every node one point is required therefore n plus and how many elements are required here e 2 e uh but then uh let us say this is V and means number of vertices these pointers will depend on number of vertices there are in the graph and then this entire total number of list contains two e in case of undirected graph right so you can write it as the space required is order of V + e you can remove that you know constant and you can write it as order of V plus C now in this case of adjacency Matrix the space required is order of v² right so order of V square is required in adeny Matrix and Order of B plus c space is required in adjacency list right now depending on which representation we are going to use that will have impact on the time complexity of the algorithms on these graphs okay we shall see the algorithms on the graph and then we shall analyze what happens to the time when graph is represented as adjy list or G is represented as adjacency Matrix okay fine now let's see how to Traverse a uh graph so rather than traversing let's call it search okay how to search the elements which are going to be noes which are going to be reachable from a particular node I'll take an example and explain you how it actually works let us say the graph is given like this node one 2 3 the nodes are numbered just for the convenience you could even have names and then later map them to some numbers not an issue but then know taking with the numbers is is going to be much more convenient when I'm working with the algorithms these algorithms okay so these are eight notes we have and now I want to start from one and I want to search all the notes which are reachable from one in some order okay there are two popular methods one is called as breadth first search and other is called as depth first search right so I'll just give you the overview of both the algorithms how they work and then we shall get into internal lers later okay so what I mean to say is uh see now when we want to search there are uh what you know searching is nothing but uh you know searching for all the notes which are reachable from the node one that is the search that is why I'm calling it as search right and in this process you know we can classify the vertices to be of three types right so some vertices have already been visited some vertices are not visited and some vertices are explored okay I'm going to use two words one is visited and other is explored like this visited and explored so these algorithms are based on these two words okay so visited means I have already seen that uh vertex which means I discovered it or I found it right or I printed it so visited means I have seen it okay kind of it and explored means I have seen it as well as I have seen all the vertices which are adjacent to this that is called explode so visited means if I see a Vertex then that is called the vertex is visited and exploded means if I have seen a vertex and if I have seen all the vertices which are adjacent to that vertex then it is called know explode so in general we can have various classifications so one is a vertex might not be visited so if it is not visited obviously it will it cannot be explored why before exploring a Vertex you have to visit it unless you know what that vertex is how can you know it's know neighbors see X Lo means visiting all the neighbors visited means visiting only that neighbor right so a Vertex might not be visited or you know and moreover its neighbors might not be explored that is one case and the other case is a vertex might be visited and it's neighbors might not have been visited then this is called as visited but not explored and the third category is a vortex is visited as well as all its uh you know neighbors are explored so we start off this algorithm these two suchar as either BFS or DFS with every node being unvisited and being unexplored and by the time we went the we end the uh you know algorithms we are supposed to visit all the nodes and explore all the nodes right or by the time we end it we are supposed to visit all the notes and obviously if all the notes are you know visited H they are always going to be explored isn't it so now in order to keep track of these two things we you know know these algorithms do various techniques so in order to know whether a node is visited or not both the algorithms are going to maintain an array so one array is going to be maintained an array right and this array in this array uh you know for every vertex like 1 2 3 4 5 6 7 8 for every vertex one cell will be dedicated and this array is called visited right and this array will keep track of what are the vertices which have been visited we initially start with one vertex which is visited we we assume that one Vex is visited and from there we keep on visiting all the nodes in some order right so if this array is containing you know initially it will contain all zeros doesn't it so if this array is containing a zero for an element it means that it is not at visited if it is containing one it means that it is visited right and how to keep track of you know either a node is exploded or not is if a node is not explored which means if a node is still having some neighbors which are not at discovered or which are not visited that is called unexplored right if a node is not explored then they go in two ways one algorithm will use a q one algorithm will use a q to keep track of all the nodes which are not visited not not exploded and the other algorithm will use a stack to keep track of all nodes which are not at explored right the algorithm which uses the Q to keep track of all unexplored you know what all unexplored vertices is called as BFS bread for search and the algorithm which uses a stack to keep track of all the unexplored nodes is called as depth first search so BFS and DFS are two popular known algorithms and they work this way see both of them have to keep track of various things one is whether it is visited or not and whether it is UN explored or not to keep track of visited or not they are going to use this array one array right and but then in order to keep track of explode or not they are going to use different data structures so BFS is going to use Q DFS is going to use stack right and anyway since both of them are going to at least use this array right now you can understand that the space complexity has to be at least greater than n why if there are n elements and nodes in the graph right then how many elements should be there what how big should be this S size it should be at least 10 right therefore you know to keep track of visited or not at least n elements are required so the space complexity is going to be at least n right so big go of n let's see if more space is required or not but then just for this array order of f space is required right and now at any at any time the maximum number of nodes which can be unexplored is nearly n order of n right except the first node all of them may be unexplored right and all of them might come and sit in the Que in one go in that case what happens is for this space taken will be order of n where n is number of vertices right and here also unexplored nodes May grow to order of n therefore both these algorithms are going to take space complexity of order of n so in order to understand the time complexity and how it works we shall take the algorithms and we shall work on it but basic concept is this right so bre why is the name bread for search and why is the name depth for sear is given is breadth for search goes in the breadth which means it will first cover the nodes at the first level and then visit the noes at the second level and then visit the notes at the third level and then visit the notes at the fourth level this is how you know breath for search works then you know you can apply permutations and combinations to find out what is the or how many possible sequences can be possible which means see after one you are supposed to visit either two or three therefore we have two combinations right and after two and three we are supposed to visit all these four therefore four combinations so you can bring that peration and combination into picture and we can even find out how many possible sequences are possible if I follow breadth first search similarly depth first search also produces the results which might not be unique in the sense you might get more than one order see in depth for search what happens is we grow we go in the depth like this right bread first search we go breadthwise level by level in depth first search we start at a node and we gradually go deep right this is depth first search and this is not the only way possible so there can be various ways possible isn't it I can go like this and I can come back or I can go like this and again come back or I can go like this and again come back right therefore you know there can be more than one sequence possible either you follow BFS or DFS then how many sequence are possible in order to calculate it you have to look at the structure of the graph one thing and second thing is you have to apply peration and combinations so various questions are possible like this so one kind of question is they'll say that on this given graph BFS is applied what are the sequences which are possible and sometimes they'll say DF is applied what are the sequences which are possible and which are not possible Right but before going to that let's take the algorithm and we shall analyze the time complex and how it works then we shall go to the questions okay fine now this is the BFS algorithm I'll explain you the algorithm and then take the graph and explain you uh see this first one first thing is BFS is called with a Vertex B which means we are always going to search start this search starting from a vertex and that vertex is given right and along with that we assume that the graph g g means any representation either the adjacency Matrix or the adjacency list any of the representations which is used the graph capital G and the array visited so I told you why visited is used just to Mark whether a node is visited or not I'm going to use an array and the graph and the visited are both Global and both are initialized to zero which means initially we start with the visited as zero which means we assume that no node is visited and that is where we are going to start and the algorithm is going to take a local variable U is going to be assigned a value V all right so what does it mean uh so we are going to start from it from know whatever the vertex it is that is going to be assigned to you so why did I do this is I'll tell you later okay for now keep it that way so we are going to assume that every note that we are going to explore now is always going to be you right why we shall see later repeat for all vertices W adjacent to youu which means uh whatever vertex you are examining now which means whatever vertex you are going to explore now what is exploring we want to see that see all the vertices which are reachable from it what are all the ad vertices which are adjacent to this that is what exploration is right now for all the vertices W adjacent to you which means we are trying to explore you right so now while while exploring you these are all the let us assume that W is the set W belongs W is nothing but one of the vertices which is uh adjacent to you right if it is already visited which means means if the adjacent node is already visited then you know sorry if it is not visited equal to zero means if it is not visited then I'm going to add it to the que why if it is not at visited then the chances are that it is not at explode isn't it therefore I have to add it to the que for later exploration but now since I have visited it I'm going to make visited of w equal to 1 are you getting this see I'm going to take a vertex and I'm going to explore it and how do I explore I just look at all the vertices which are adjacent to this and if they are not visited then I'm going to keep them in the queue for later exploration and moreover I to mark that they are now currently visited that is why I'm going to add it to the que for later exploration and even I'm going to mark them as visited currently right and if Q is empty then return return which means in case if if you have explored all the elements then Q will be empty right then you can return because if you have explored all the elements it really means that you have visited all the elements isn't it then if it is not the case which means if Q is not empty then we come here right then what we do is we delete the next element from we delete the next element from q and we call it as U that is why I'm taking U equal to V so that this entire Loop will be consistent otherwise what I should do is you know I should call this entire Loop once for V and then once for U so instead of that I'm just maintaining a value U and always one element is going to come into you from the Q okay so I'll take an example and explain you right so if you didn't understand it don't worry we shall see an example let us say this is the graph which we are trying to search and the search is going to start from one so if I start searching for all the nodes which are reachable from one let us see what is the order in which I visit the nodes right that is called as you know BFS order right so bread firstar order so we shall call this algorithm with you know V = to 1 so initially we are going to have the vertex visited right the vertex visited which is all initialized to zero Okay so so visited of 1 visited of 2 3 4 5 6 7 8 so all these eight values are initially initialized to zero now when you call it when you call the first one right oh there has to be a step here let us say visited of V equal to 1 why so once I call V on V definitely that is going to be visited isn't it so initially we are going to call this function with one and now U equal to 1 and visited of one visited of V equal to 1 which means the first node is visited that is what I'm going to remember right huh and now I'm going to get into this right so what is u u is now one okay for all vertices W adjacent to U so what are all the vertices W adjacent to youu now what are the vertices which are adjacent to one so 2 and three right 2 and three I have to do for each of them right I'm going to going inside this and this entire thing has to be repeated for each W which means for two and three now first thing is if visited of w equal to0 is visited of two 0 yes which means it is not ADV visited right then we are supposed to have a Q also right so initially Q will be there then what happens is inside the Q This is the Q right so if a node is not visited yes I'm talking about 2 W = to 2 first if it is not visited then add W to Q why because since it is not visited it is not explored also and later I have to explore it that is why I'm going to add it to the Q yes it is added add it to the Q and what is next statement visit of w equal to 1 so since we have visited two now from one we have visited two right I'm going to mark it as visited so two is visited but it is not at explode that is why it is present in the que got it and now uh you know again I have to come here so for Loop is over right so just hold on here so for Loop delete the element from the Q we should delete the element from the que after it so let's put one more parenthesis here and one more parenthesis here okay so which means this has to happen the for Loop has to happen Okay the F Loop closing is here so for Loop has to happen for all the vertices right and now I'm going to do it for the second vertex also W now what w is visited of w0 check this is Vis of w0 yes therefore what should I do it is not get visited therefore I have to add it to explore it and then I have to mark that it is visited so I have to add that it has to be explored later and I have to mark that it is visited okay fine now uh you know all the for all the vertices W adjacent to one they are all over therefore you come out of this for Loop so what is this if Q is empty is Q empty when will Q be empty if there are no more nodes which have to be explored then Q will be empty but since there are more nodes which have to be explored so Q is not empty delete a node from the delete a next node and add it to U which means I have to delete the next node and I have to add it to here so the next node which has to be explored is two got it H now watch it again everything has to be repeated for all the vertices W adjacent to U so what are all the vertices adjacent to two the vertices which are adjacent to two are 1 4 and 5 isn't it 1 4 and 5 and one more thing if You observe it I'm writing W = 14 and 5 in this order but it could be any order in general the you know the order which we get here that depends on the representation in the representation if you are having adjacency list representation and in which the list is containing 145 then they will be visited in that order therefore the visiting order generally depends on the representation see even though I'm taking 145 here it need not be always 145 right it depends on the way you represent it got it therefore depending on you know various representations they might sometimes take five here four here one here right then the first one which will be visited next will be five instead of this are you getting this okay let me write even the visiting order also one is visited and next two is visited and next three is visited isn't it and now I'm going to do next one so I'm going to explore two when I'm exploring two I found out that the adjacent values of two are 1 4 and 5 right and what does this for Loop do for each one right for all the vertices W Adent to you we are going to do this right so now I'm going to pick first one one if wed of w equal to 0 is it visited one is visited yes it is already visited it is not equal to zero therefore this one will not happen again we come back into the for Loop right and we take the next one if visited of w equal to 0 is visited of w 0 yes therefore it is unvisited therefore what are what is that we are supposed to do add it to q and Mark it as visited so next one which is added to the Q is four why because I'm considering four as the next element in case if you have considered five here right if you're implementation has given you five first then you would have added five first and we have made you know visited of five first but then here my I'm considering that my implementation is taking four first depending on that I got four right and earlier also I have taken two first and three first it need not be the order right it can be three first and two first depending on the implementation that you are following got it so now four is added to this and sorry yes four is added to this and four is marked as you know visited fine and again I to take the next one which means five again you check it so is visited of five true check this is visited of five equal to zero yes it is zero therefore what is that we are supposed to do add it to the Q and Mark it as visited right so therefore what is the next one which is visited visited five got it fine all of them are visited therefore for Loop will be over after for loop again we go into this if statement will fail again we delete the next element from the queue what is the next element to be explored three therefore you is going to take three right and again what happens all the elements which are adjacent to three we have to examine them so what are all the elements which are adjacent to three 1 6 and 7 1 6 and 7 even though one is visited we still don't know that right that is why I have to visit know it again so I have to consider it again now I'll consider one first now we find out that V of one is true therefore it will not be done in know this if will not be executed next one is six will be considered so visited of 6 equal to Z therefore 6 will be added to unexplored nodes and visited of six will be made as one so what is the next one which is visited six got it and next one is seven will be considered and since visited of 7 is zero it will be added to the unexplored nodes right and visit of s will be made one therefore 7 all right and next one is uh 7 is over right so 1 6 7 are over all of them are visited right all the vertices are explode therefore we are going to uh go for the next element from the Q so what is next element from the Q four so four is picked up picked up for exploration four is picked up right now what are all the vertices adjacent to vertices adjacent to four are 2 and 8 right now 2 and 8 will be explode see this first two will be taken and since wiard of two is one right it is already visited will will not do anything for it which means this if flu will not if if that if condition will not get executed now what about this8 visited of 8 equal to 0 therefore 8 will be added to the unexplored nodes and it will be made visited of 8 equal to 1 which means eight is marked as already visited right and now both you know all the vertices are already over so we need not do anything for this right so we are going to come out of this for Loop and again pick the next element so8 is the next one which is visited now what is the next element which will be picked up five right so when when five is considered right five is considered what are all the notes which are Adent to five 2 and 8 but if you look at two two is already visited eight is already visited therefore all all the adjacent noes are already visited you need not explore it further so nothing will happen for it in this for Loop right so next element will be considered which is six so what are all the vertices which are Adent to six three and 8 right but then instead of three is visited and then 8 is visited therefore nothing will happen here and again we pick up the next element what is next element seven so you will be made Seven right what are the vertices which are Adent to seven 3 and 8 again we find out that three and weight are already visited therefore nothing will be done right so what is next one which will be taken out eight so what are the what say Adent to8 veres which are adjacent to eight are 4 5 6 and 7 right and you see that 4 5 6 7 are already visited therefore nothing will happen in the if Loop so we we are going to come out right and finally Q is going to be already uh you know empty therefore we are going to come out of it return right so if You observe it the way we did it is um you know we started from one and then one is marked as visited and all the vertices adjacent to this are visited next which means two and three are visited and this can be in any order which means either you can write 2 3 or you can write 32 right depending on the order we add them to the Q the next element will depend on it right if the next element picked up is two for exploration then four and five are exploded five four and five are visited right and if the next element which is picked up is three then six and seven are visited right if the next element which is picked up is four then eight is visited right and it can be any other order in case if you have visited from one you know visited three first and added 3 to the Q first and then two to the Q next then what happens because of this three which is going to be explored next I visit six and seven first right or it could even be 7 and six right and after that when I take two for exploration then I'll visit four and five right or five and four also then when I take six for the exploration next then I'll visit eight therefore more than one order is possible here are you following it so the way we um you know explore the visit the nodes may be more than one it need not always be a unique right it depends on the implementation so you know in your adjacency list for one right in case you are using adjacency list in the adjacency list for one if you are having 2 three like this right then two will be added to the Q first and then three will be added to the Q next then in that case you are going to get 2 three here right and then depending on what is stored at two we'll get 4 five or 54 therefore it is completely dependent on implementation we might get more than one order but ultimately what we should observe is all the notes which are reachable from one will definitely be will definitely be printed I mean will definitely be you know visited so why am I trying to print I'm just trying to show you wherever we are saying visited I'm just saying that you know I'm just putting a print F line also then you'll know what are the what is the order in which they're printed see you know after this you can even put printf statement printf let us say w then what happens is you'll get this order this order is important got it let's now analyze the time complexity time taken to you know and run this program and then the space complexity okay now let's see DFS depth for search the main difference between breadth first search and depth first search is in breadth first search when we take an element for exploration we take it and we visit all the elements which are adjacent to it and we completely explore it and we leave it but in depth for suchar what happens is here depth for search we take an element for exploration and we start exploring it and as in when we find a new element which is unexplored we leave this element and we start with that and again that element also we do the same we we try to explore it and as in when we find a new element which is unexplored from that element we go to that okay I'll just take the example and I'll show you that will explain you anyway just see the algorithm see now BFS of V which means we are calling that sorry DFS of V which means we are calling the DFS starting from a Vertex that is why it is again a search because we are starting only from one vertex right visited of V equal to 1 so initially we are going to make visited of V equal to 1 see one more thing you should observe is either in BFS or in DFS you know before we start uh one basic assumption is visited at array is global and visited array is initialized to zero but then in this in this code we are not initializing it where are we initializing it see we intentionally didn't keep that initialization of V you know visited inside this code because you know this function might be called by other functions like uh you know traversal functions for example depth first search may be called by depth first traversal so traversal while before calling in you know DFS on any node it will initialize it so initialization is done by other program which is going to call this program therefore I'm going to take the time taken to initialize the array also into time complex analysis but then I'm not showing you that part here because that is done by the calling function right and even though that has to be done in here only that is true but then I want this to be reusable later that is why I'm just putting it aside see what happens if every time if you call this BFS or DFS if you try to initialize visited array is in case of that traversal right whenever we visited some of the nodes and again we call the you know BFS or DFS for unvisited nodes again that entire array will be flushed away that is why I don't want to put it in the code right but if you are going to call this independently individually only on one vertex then you are supposed to initialize it to zero before you start that is why in time complex analysis I'm taking even the time taken initialize visited okay fine so anyway let's see this so visited of V is one which means I'm considering that whenever I take a Vertex V that is I'm I'm visiting it right and then the exploration Starts Now for each vertex W adjacent to V which means I'm going to visit all the vertices which are adjacent to W right if visited if it is not visited then the problem here is I'll I'll start visiting that which means I'll I'll start exploring that node see DFS is nothing but the function DFS itself will be used for exploring a node exploring a Vertex right now initially when we started exploring a Vertex we say that it is visited and then we take up all the nodes which are adjacent to that particular vertex and then you know if you find any vertex which is you know not visited then we leave this vertex and we start we know exploring the other vertex right so it is better I'll take the example and explain you there is there's a lot of difference you might think that it is not different from BFS but actually there's a lot of difference between BFS and DFS in BFS we take a Vertex explore it completely and throw it away but in DFS we take a Vertex you know and then try exploring it start exploring it and whenever we find the first unexplored vertex we again go to exploring that and again we come back right I'll just show you how it works watch it let's take this example the same example which we used for even BFS also okay and one more thing I'm I'm intentionally taking all the all the graphs to be undirected but you could use the same algorithm on directed also only thing is if one you know a is adjacent to B in directed B might not be adjacent to a but here you know it is adjacent therefore the main difference between directed and undirected will be when you're trying to analyze the time complex so in case of time complexity analysis in adjacency list right we might encounter a note two times which means the time taken might be doubled by factor of two but the you know asmic analysis Sayes the same time right so just remember that these two algorithms can be even applied for directed as well as undirected graphs okay H now let us say I'm calling DFS on one so this is we we are going to have a visited array right 1 2 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 we are going to have visited array and which is initialized to zero initially all are initialized to zeros only right so this is not initialized inside either BFS or DFS any any function which is calling these functions is supposed to initialize it right and now let me show what happens in this stack this is the stack right fine so first thing is uh V is going to be one so it is going to we we are going to call DFS with vertex one as the starting node the seed right that is Al sometimes called as the seed right and now from V visited of V equal to 1 which means one is visited I made this visited as one right it is no longer zero it is one right and now for all vertices for each vertex W adjacent to V so what are the vertices which are adjacent to one so w can have two vertices what are they 2 and three isn't it for each vertex now we take each one one by one let us say I'm taking you know first W to be two see even I'm writing W as a set actually W as is an element so this is the adjacency set so the set of all elements which are Adent to one from that W is going to pick one of them either it could pick two or it could pick three depending on how you have mented it in implementation if two comes ahead of three then we pick up three right so first thing is we are going to take visit of one is visited and now we are going to take two and again we are going to call DFS on W which means we are going to call DFS on two so what happens again one more DFS will be called and for this DFS what will be the v v will become two got it and again the entire thing has to be executed so what is it visited of V equal to 1 so visited of 2 equal to 1 so this one will be made one which means 2 is the next visited node got it huh next thing is for all ver for each vertex W Adent to V so what are all the vertices adjacent to two if you look at two the Adent the adjacent vertices are 1 4 and 5 1 4 and 5 all right now we are going to take 1 by one W is going to be initially 1 Let's assume that it is 1 then what happens so if visited of w equal to Z is visited of w 0 which means is visited of 1 Z no it is one therefore the function calling will not happen and next four will be considered again it will check if this of four 0o yes 4 is zero therefore again we are going to call DFS on four DFS on four which means we equal 4 are you observing it see this first V is taken for exploration and whenever it has found one unexplored node we have left the exploration of V here which means we are not going to explore all the adjacent vertices we are going to two and whenever two has found one unexplored node we are going to four right so in BFS what happened is whenever we have taken a node for exploration all its noes will medent noes will be visited then only we move on to the next one but here whenever we find any new node we are directly jumping to that we are directly jumping to that and we and later we come back and then explore the remaining vertices right you'll understand it don't worry now coming to four so what are all the vertices so what is the first line dist of four equal to 1 which means this one will be made one right and the next one is for each vertex four is visited right for each vertex W adjacent to we do so now what are all the vertices which are adjacent to four 2 and 8 so w can be one of two either two or8 isn't it now two will be considered let us assume two is the head of 8 in the implementation and when two is considered now what is the check it will make if VIs of 2 equal to 0 is wi of 2 equal to 0 no therefore nothing will happen to this which means DFS will not be called again why because it is already called and now8 will be seen now again we are going to see8 so if DFS of 8 sorry V of 8 equal to 0 yes it is unvisited therefore this will be taken for uh exploration got it again DFS will be called in this DFS what is V V = to 8 right now what happens wi of 8 equal to 1 so this one will be made one and then for each vertex W adjacent to V so what are all the vertices W adjacent to what are all the vertices adjacent to 8 4 5 6 7 right all these vertices are adjacent to8 got it now we are going to take one of them is Ved of w equal to 0 is V of 4 equal to 0 no it is one therefore nothing will be done for this why already four four has been taken up for exploration it will not be taken off for exploration again right exploration again now what about five is Vis of 5 equal to 1 is zero yes it is zero therefore again five will be picked up for exploration which means again DFS will be called with v equal to 5 right now what happens so wi of 5 equal to 1 which means this one will be made one and now all the nodes which are adjacent to five will be examined for each node W adjacent to five so what are all the notes which are to five 2 and 8 2 and 8 right and now we are going to take first one two now we we shall examine whether it is already uh visited or not is visited of 2 equal to0 no it is equal to 1 therefore nothing will be done to this what about wi of 8 is wi of 8 equal to Z no wi of 8 equal to 1 therefore you know this for Loop is over for you know this DFS calling so what is it it is supposed to return so this is the first return right so if You observe it we have we are we are going like this and we are going like this and we have gone like this right and then we have gone like this and there is nothing to be explored therefore again we are coming back to8 isn't it are you observing it again we are coming back to eight so if You observe this we are starting from one and we went to two and then we went to three sorry four and then we went to 8 and then we went to five and five is useless anymore therefore we came back and again we came back to eight what it so what is visited in the order eight is visited right and then five is visited If You observe it one is visited first next two next four next eight next five this is the order in which we visited what it huh now next one is six is considered is visited of six zero yes therefore again DFS is called with v = 6 got it so this one is made one and and DFS is called with v = to 6 then what happens here uh so visited of 6 equal to 1 which means 6 is next visited and moreover for all vertices which are adjacent to six what what are all the vertices which are adjacent to six so one is 3 and other is 8 so first three will be considered is V of 3 equal to0 yes V of 3 equal to 0 therefore we are going to call again DFS on three so we = to 3 got it so what happens V of 3 = to 1 so next one to be visited is three got it so Vis of 3 equal to 1 and what are all the vertices which are adjacent to three check this what are all the vertices which are adjacent to three uh 7 and 1 so 1 comma 7 Now 1 will be considered but V of one is already zero sorry already one so it will not happen anything and again 7 will be considered and V of 7 equal to Z therefore we are going to call DFS again on 7 DFS on again vertex 7 right so when vertex on vertex 7 when DFS is called again we are going to do V of 7 equal to 1 which means this one will be made one right and for all vertices which are adjacent to 7 so 7 will visited what are all the vertices which are to 7 we are going to take one by one now 3 and 8 so initially 3 will be considered as W right but then we shall see that we see that you know three is already visited right and nothing will happen and 8 is also already visited nothing will happen therefore this one will be popped off right because this for Loop is over so this one comes out now again we are here so this one is already over right 1 and seven are already explode so this one also comes out and here here it will try to explore 8 so it will see if 8 is unvisited or not but then it turns out that 8 is already visited therefore for this function also the for Loop gets completed it one gets this one also gets uh popped off right and this one is over and here it will try to see if six is uh six is remaining right you will try to see if six is uh unvisited but then six is already visited and then it will try to see if 7 is unvisited but 6 7 is also visited therefore this one also will pop off next 8 is already over popped off next it will try to see if five is unvisited but five is visited popped off and then it will try to see if three is unvisited but three is visited therefore popped off right so this is the order in which we are going to explore right so if you watch it how this happened from 1 we went to two and from two we went to four and from four we visited eight and from eight we visited five and again we came back to eight and we visited six and from six we visited seven and from from sorry and from six we visited three and from three we visited seven right so this is the order in which uh we visited got it uh so what is the time complexity and space complexity analysis we shall see the analysis now okay see in most of the data structures the main operations that we would like to do is one is know the main reason why we use data structures is to store data either to give it as an input to an algorithm or uh to take the output from an algorithm so data structures main intention is you know to help us store the data and whenever we have a data structure any data structure in general the most common operations that we perform on a data structure is one is insert an element into the data structure right so we do insertion and after inserting the elements we might want to search for a particular element right so searching an element and then we might want to delete an element right delete and and very often it's you know at practice what happens is many of the data sets data set means the data okay many of the data uh let me call it data set don't get confused data set is nothing but the data okay so data sets are generally static static in the sense once you create the data it rarely changes we insert the elements and then we leave them like that without any changes or modifications that is what happens at you know many of the Practical cases then in those cases you know the main operation on data set turns out to be search search is the very dominant oper operation that that will be generally performed on any data structure right so many of the data structures are mainly designed uh with this in mind this searching so we want to search the data Foster right so now if you watch various data structures they really don't have you know very good time for searching for example if you see an array in an array let us say it is an unsorted array and I want to search an element how much time is it going to take I'm just listing out some of the you know uh data structures we have one is unsorted array right in unsorted array if you want to search for an element you know we might have to compare it with all the elements and the time taken might be as big as order of n now if you use a sorted array right so how much time does it take to search an element we might apply binary search and it turns out that we can search for an element in logarithmic time order of login right or in case if you use a link list right if you have a link list in this case you know if you want to search for an element again you might have to search the entire list right then the time complexity is going to be order of n right or if you use a binary tree then we might have to do that you know travel veral time taken is order of n right or if you use a binary search tree so we have seen that you know there is a binary search tree right uh so in binary search tree it is mainly designed in such a way that it helps us in the uh you know searching operation right but in worst case a binary search tree might become a link list right in that case the time taken is going to be order of an normal binary search tree the height of the tree can go as big as order of n in that case searching is going to take order of n time and in case of balance with binary search trees like AVL trees 2 Three Trees black red black trees they know when wherever we try to balance so if it is a height balanced binary search tree like AVL tree then the time taken is going to be order of login because height of the tree is going to be login isn't it and you know uh there is something called as priority so we don't want to search for any element we want to search for the minimum element or maximum element they are called as priority cues right so if I have priority cues like Min Heap and Max Heap right in this searching for a particular element searching for Min and Max is going to be order of one time but then searching for a particular element is again going to be order of end time okay so if you see any of the operating know any of the data structures always the least search possible on most of the data structures is going to be order of login the best best search right then what people people thought is if search is so frequently used on some data structures then why don't we minimize the time as much as possible and the solution comes in terms of hashing so hashing is the uh solution for the search time to minimize the search time if you use the hashing technique then on average the time com the time taken to search an element is going to be order of one which is constant time right we shall see how this constant time is possible right and uh earlier before using this hashing technique people used one more technique which is called as you know just like array okay which is also called as you know direct address tables direct address tables so what is direct address table is it is just similar to arrays let us say you have to store 100 elements okay so or we have to store 100 records in such a way that each record is having a unique key and that key is ranging from you know 1 2 three so on 100 so if you know that 100 elements will be inserted into your data structure and each element is going to have a key value and that key is going to be unique in and it is going to be in the range of 1 to 100 then the best thing to save it is in terms of an array right so we can we can define an array of size 100 and whenever you want to insert an element you insert it into the corresponding spot which means every element that has to be inserted is going to have a slot in the array right so if let us say you want to insert an element which is having key 10 then I go into the array into the index 10 and I'll insert it there right later if I want to search whether that element is present in the you know data data structure or not then I can simply go to that element directly and I can find it out how because since array is a um this Random Access uh data structure you know we can directly get into any index easily so so if the key itself is going to be the index then search time is going to be order of one so the first data structure which has supposed which has supported I know this searching in order of one time is called as direct address table in this table we are going to have an array and we are going to place an element according to the key value right and this method is uh useful only when you know the number of keys which are going to be in a small range and you know uh if the number of keys which are inserted is very Less in case let us say key values you know because I'm directly going to use the key values into the you know array indexes therefore there has to be a linear relationship between I mean directly proportionality between number of keys used and the size of the array in case if the keys used are very big very large in number but the total number of keys are less in number let us assume that totally there are 10 elements going to be inserted but the element each element is going to be of size 1 million let us say the keys inserted are like this okay and no something like this I'm just randomly taking the examples okay now if the keys inserted are like this but only 10 keys are inserted then even to put this keys I have to Define an array which is having as big index as this key right and this key itself is 1 ion therefore the aray size might have to be 1 million just to store 10 values right in the in such cases this direct address table is going to fail so direct address table was used very early when uh you know and it is useful in the case when the key size and the number of elements are actually close to each other which means if the key size is in hundreds and the number of elements which are going to be stored is also in hundreds then maybe defining uh you know one slot for each ment is useful in you know in such a way if the key size is very large and the total number of keys which might be inserted into the array is very small then having such a architecture is a you know waste of space so there we are going to use the hashing so I'll talk about hashing in next video okay fine the problem with direct address table is the size of the array the table is going to be as big as the key sizes isn't it um and many times we might end up declaring a array of very big size even though the numbers inserted out to be are very less right in order to solve this problem we use hashing so hashing says this see even though the number of possible keys that have to be inserted into our data structure are very large let's call it a universal set u okay but at any time the number of elements which will be present in our actual data structure okay are small which means the potential candidates which might have to be placed in our data structure are very large but then not all of them will be present in our data structure at the same time only few elements are going to be present in our data structure at some time right then instead of declaring a you know data structure whose size is as big as the universal set we just decare the dat data structure just enough to hold all the elements which might be present at any time right then what happens is now this data structure is very small or the number of slots that that are available in this table are small compared to the number of potential Elements which might compete for the slots right which means to say it in simple words let us say uh the value of keys ranges from 0 to 1,000 okay or let us say 0 to 999 this is this is the value of keys and our any of these Keys may be present in our data but at any time if we have to put only if I say that if at any time only uh you know 10 elements will be present in our data structure not more than that then declaring a data structure which is having 1,000 slots is a waste of space instead of that what we could do is we could declare a a space of just 10 elements right and then we could try to map so whenever any element is given we could try to map it into one of the slots right the mapping function which we are going to use is called hash function okay so what I mean to say is if at any time you are sure that our data is not going to go beyond 10 elements just for example okay then you can declare a table or array of size 10 and whenever any input is given you apply some function on it so that I know that that function itself will say where to put that element in a constant time and later when you search for that element again you apply the function on that element and go to that particular spot which is located by the hash function in case if that element is present we can say it is present in case if it is not present we can say it is not present therefore s time is going to take order of 1 one time I'll just take a small example and explain you let us say we have to insert you know Keys like this 121 145 132 999 right these are the keys which have to be inserted into a table right and the table size is let us say 10 0 1 1 2 3 4 5 6 7 8 9 10 okay now all these elements have to be inserted into this uh table in such a way that insertion should take place in constant time and searching should take place in constant time then what I'll try to do is I'll come up with a function which will take any of these keys and which will give as output some indices here right in case how many indices are here 0 to 9 let us say 10 elements are there 0 to 9 indices are there and what are the possible key values let us say the possible key values are 0 to you know 199 then what is a 0 to 999 then what is a hash function is Hash function is any function which will take the values from 0 to 999 in the range 0 to 999 and it will map them to one of the values in 0 to9 so this is called as a hash function simple words right so in this in the in the meaning meaning of this let us say the table size is you know 0 to M minus1 right then hash function is any function which will take a key from U and it will map it to one of the values from 0 to M minus one this is the hash function got it so in this case I can define a simple hash function to be mod 10 right then what happens is whenever you want to insert any element you just take the mod 10 value and you go to that particular element and you put it there for example if I want to insert 121 then I'll find out what is 121 mod 10 what is that value 1 therefore I'm going to put 121 here right or or a pointer here which will point to 121 whatever it is if you think if you say that you know directly key key is the data which has to be inserted I will directly put the data there if you say that that key indicates the record in which you know and the record is present at some other point then I'll place the record there corresponding to 121 the pointer to the record okay so anyway let's let's just put the data itself okay now where are we going to place this 145 121 is over so mod 10 gives 145 which means I'm going to place it here where are you going to place 132 mod 10 gives 2 therefore 132 is placed here where are we going to place 192 one sorry 999 it is going to be placed in 999 got it and all the other elements are initially the table is initially initialized to null so all the other elements are going to contain null right then insertion is simply done in order of one time and now let's talk about the uh searching if if I say let us let's say I want to search for element 150 then what I do is I'll find out 150 mod 10 why should I find it out because in case if 150 is present in this table then definitely 150 would have been present in you know 150 mod 10 so what do I get zero then I go into this table and search in the zero it says that the element is not present right it says that it is null therefore the element is not present therefore I can declare that the required element is not present in the table right so searching goes in that way for example uh if you want 145 right if you want to see whether 145 is present or not then I'll find out 145 mod 10 and it turns out to be five then I'll go into the table into the element five and then I'll see this 145 yes then I'll say it is present therefore you know search time is nothing but time taken to run that hash function and directly access the table which is going to be constant so insertion and searching is going to be take constant Time by using the hashing technique got it so this entire thing is called as hashing hashing is simply taking a set of very large numbers and then mapping it to a set of small numbers and the set of small numbers correspond to the indices of our data structure or the table which we are going to use that is also called as hash table got it and now once we do this mapping insertion is going to take place in constant time just the time taken to compute the in that index and searching is also going to take constant time and even deletion is also going to take constant time right but the problem is there is a problem called as Collision Collision is uh you know whatever function you come up with when we have to map such a large numbers you know large number of large amount of numbers into a you know smaller smaller element set smaller know smaller set it is a bigger set and it is a smaller set when we do such a mapping then obviously more than one element might map to the uh same cell for example here after inserting all these numbers let us say I want to insert 131 then where should I insert it then I'll find out 131 mod 10 then it says that you have to insert it in location number one then I'll try to insert it in location number one in which already 121 is present now 131 also wants to go to the same slot when two elements or two keys are hashed being hashed into the same value right into the same cell same slot then that condition is called as Collision so what is Collision when more than one value if they actually map into the same cell in the hash table then that is called as Collision so disadvantage of hashing is Collision or I I I don't say disadvantage the challenge right the problem the problem with hashing is we might definitely have collisions right then there are various Solutions proposed in order to deal with these collisions so one solution is they ask us to come up with a better hashing function in such a way that collisions can be minimized but however good your hashing function is see they like you know just like mod 10 you know maybe using a prime number might give us less number of see using mod 10 is nothing but I'm just using only the least significant one bit of the number I'm not taking into picture the entire number right so if you come up with better hash functions then maybe the numbers will be distributed well right so one solution to this solving this Collision problem is coming up with better hashing functions better hash functions right but the problem with this uh you know better hash functions is you could come up with better hash functions which is going to decrease the number of collisions but then the total number of collisions will never be zero which means you'll definitely be able to decrease the number of collisions but you can never say there are no collisions at all that is the problem with this so even if you come up with a good hash function still the problem of collision is there right so in order to solve the collisions the next Sol solution is chaining chaining so chaining says this you know in the hash table instead of putting one element in that slot right away you maintain a link list and whenever you want to place an element you try to place it in this link list let us say you want to place you know uh three elements are mapping into this same cell then all these three elements will be placed in this link list in case if one more element maps onto this same same cell then that element will also be inserted here so Collision resolution techniques are of various types the first Collision resolution technique is chaining so using chaining what we could do is we can place the uh elements in such a way that uh even if more than one element maps to the same slot they will they will be accommodated inside the uh you know link list so in this way actually the slots in the hash table are actually now point us to a link list and the link list will contain all the elements which have mapped to that particular cell right we shall see the examples don't worry about it I'll explain you later I'm just telling you the Collision resolution techniques right so first corion resolution technique is chaining and the next corion resolution technique is called as open addressing right so what open addressing says is in case if you have a collision which means means if you're trying to put an element at some point and if that if that cell is automatically you know already occupied then you again recompute the hash value you again recompute the hash value in and then find out where that element can be placed if you are lucky then next time when you recompute the hash value with some minor modifications to the input right I'll tell you what are the modifications then again the next recomputation of the hash value might lead you to some other empty vacant space in case if that space is also already occupied again you compute it right you keep on doing this until you probe all the values probing probing is nothing but searching for a empty space in which you want to insert an element that is called probing probing okay so open addressing says that whenever you come across any cell in which already an element is present and now your element present element also wants to go into the same cell then you keep on recomputing the uh hash function with changes in the input I'll tell you what the changes are right then uh that uh that is called as probing and this open addressing is implemented in various ways one is called as linear probing linear probing and other is quadratic probing quadratic probing and the other is uh you know hashing right so in general the main difference between chaining and open addressing is in chaining elements have to be stored outside the table but in open addressing elements are stored inside the table right and in chaining we are we are wasting some space for the pointers and in open addressing since we are not using the pointers we can effectively use the memory and we can increase the size of the table More Than This chaining technique and once I increase the size of the table the number of collisions will decrease as well as the space will be utilized you know better way just to accommodate the keys right so when do we go for open addressing and when do we go for chaining is chaining is uh you know advantageous in case if you want to delete the elements also if you want to insert and if you want to delete and if you want to search for an element chaining is better and if you want to insert an element and if you want to just search which means if you don't want to do any deletions then this one is better so if you want to go for deletions chaining is going to be better if you don't want to go for any deletions then open addressing is better so depending on your need you can choose one of them so just to summarize it what I'm trying to say is see hashing is mapping a set of elements from a larger set to a smaller set right and the problem with this is whenever I map I give such a mapping I know the chances are that two elements might map to the same element got it now that is called as Collision so in order to decrease the collisions you can come up with better hash functions right for example mod 10 is going to use only part of the number you can come up with various hash functions which might use better you know which might give you a good distribution of the keys right but still even then if you have large number of elements which are to be mapped on to a small number definitely there will be collisions I can never say that collisions will become zero right then what is that we are going to do we have to resolve the collisions then these are the Collision resolution techniques so one Collision resolution technique is chaining what we do is we'll never save the elements in the in the uh table itself hash table we'll save them outside in the link list so since we are having a link list which is a dynamic data structure even if more than one element maps onto the uh you know this uh table I can place them happily inside the think list any number of elements therefore I need not worry about collisions right and in open addressing the you know we are going to save all the elements in the table itself now what is the main difference between open addressing and chaining is in open addressing the number of elements which can be present in the hasch table can never exceed the size of the hatch table but then in chaining the number of elements which can be present in the hash table can be uh even can grow beyond the size of the hash table let us say if the hash table size is 10 then you could even insert know 1,000 elements in the hash table by using the chains right but here since all the elements have to be present in the hash table itself right if the size of the hash table is 10 I can only put 10 elements so after 10 elements you'll get a overflow error which means even if you try to put one more element it will say that there is no space got it so uh you know which one is better that depends okay so just remember this if insertion deletion and a search are all to be performed then chaining is better but if only insertion and search is search has to be perform performed then open addressing is better because it uses this space efficiently here it is going to take lot of space obviously there is trade-off if you can afford more space then you could get better deletion performance also but if you don't have a lot of space then deletion is going to take more time got it only difference is in terms of deletion so what we shall do is we shall see each technique and the advantages disadvantages along with the problems okay in chaining we have a hash function and a hash table like this okay so we'll have a hash table of some size right and then some hash function H let's call it h now what happens is if you want to insert any key K into this hash table then what we do is we compute the hash function h of K and now we go into this table let us say this table is represented by an array T then we go into this table into that particular location observe this we want to insert an an element with key k then we are going to find out the hash value of that key and it is going to give us some index Now using that index we'll get into the table right for example you know this this particular index is this one then we get into this index but instead of placing that element in this index uh you know we are going to put the element in the list if the uh that particular the list pointed by this particular entry is already existing then what we do is we put we create a new node and then we place it in the beginning how do we put it it is just like inserting an element at the beginning of a link list single link list right so how do you put it in the the whatever element is newly created we make the next of that to point to the uh you know head of the list and then we make the head of IT point to this that is how we insert it therefore in order to insert the element into the list or into this table hash table how much time does it take the time taken to compute the hash function and then the time taken to insert it at the beginning of the head so anyway it is going to be constant time why because we designed the hash function in such a way that that it is a mathematical function and the time taken to compute the hash function is always going to be the constant right and then inserting an element at the beginning of a you know list is constant time so insertion in case of chaining is going to take Al of one time all right and what about the other operation let us say searching so in worst case what could happen is if you have n elements inserted into this uh you know table all these n elements might map even in worst case that could happen right so all these elements might map to a single entry and the list of this entry might contain as many as n elements then in worst case I'm talking about the worst case in worst case a search could take as much as order of end time so what is that worst case all the elements are just present in one list right in the table and it is not evenly distributed then what happens is in order to search for an element you might have to search the entire list before declaring that the particular element is not there see again searching an element let us say all the elements I know are now mapped to one particular list and now we are actually we wanted to search an element which also maps to that particular list right then what happens in that list we might have to in worst case if it is not present we might have to search all the elements in the list so time taken will be order of n that is the worst case okay and what about the worst case deletion so worst case deletion is you have to search for the element and then delete it right so it is also going to take order of end time in worst case right but then it turns out that if you are careful and if you use some you know uniform hash functions uniform distribution hash functions means the hash functions uh which will not uh you know put all the elements into one one slot if somehow you know if you could distribute the elements then in average case you could see that you know if there are n elements right if you try to have a uniform distribution function for the hashing right then it turns out that each slot might get you know n bym elements are you following this see what is that I'm trying to say is in case if all these n elements didn't happen to be mapping to a particular uh one slot if they are very well distributed and every slot is going to get equal share of the elements then every list on average is going to be as big as n by m right so in this case on average this is called average right in this case average search time average search time is going to be T of how much 1 + n by m right and this particular n by m is also called as load Factor so this this has a name which is called as load Factor load factor is you know how many elements are present in the list I mean in the hash table divided by total size of the hash table if the hash table size is M slots and the total elements present in the hash table is n then the uh you know balance factor is n by m a load factor is n by m right so in this case the average search time is going to be Theta of 1 + Alpha where Alpha is the load Factor right and if you see that the number of elements which are present here right if this one is some constant into M which means if I always see that I maintain some constant into M elements only to be inserted into the table then what happens to alpha alpha becomes some constant K right in that case if Alpha becomes a constant then I can say that on average con time is taken to search the element are you understanding this so what I mean to say is it is not always going to happen in such a way that all the elements will map to a single slot which means all the elements will not be present in one list in general in average they will be distributed over all the list if it is distributed over all the list how many elements n elements or dist distributed over M list then how many elements does each list get n by m right in that case if each list is going to get n by m elements right then search time is going to be 1 + n by m so one time is taken to compute the hash function and then n by m time is taken to search the list right and N by m is also called as load Factor then 1 plus load Factor if you maintain this load factor to be a constant which means if you never exceed some particular load factor which means let us say if the size of the array is this table is 10 and if you say that I'll never exceed 20 elements then that is load factor is you know two in that case you know search is going to be constant all right and if this is the case for search deletion is also the same time isn't it then in this case average deletion time can also be analyzed in the same way right and average deletion is also going to be of constant time right therefore using chaining I can perform insertion you know deletion as well as uh Search Everything in a constant time on average in average case but anyway in worst case obviously you cannot miss it out all right fine then what is the other advantage of using this chaining is deletion is easy because when you delete one element you need not affect all the other elements but in case of you know open addressing if you delete one element you are supposed to you know rearrange all the remaining elements or at least you are supposed to do lot of changes right then because of that because deletions are you know simple in this uh chaining all right so what is the disadvantage of this chaining Advantage is you know deltion is easy and most of the operations are going to be on a constant time fine on average then what is the disadvantage of this chaining obviously you can see this the elements are not stored in the table they are stored outside the table for which extra space is given and moreover extra space is given for the pointers also right so disadvantage of this method is pointers why poins is a disadvantage because space is wasted right so here space is wasted right there are both advantages and disadvantages of chaining so this is all about the chaining okay fine so in quadratic probing it is exactly like linear probing only which means whenever there's Collision we are again going to probe next time but then when we probe the second time or the know next sequence of probes they are going to follow a different kind of you know hash function like this so for example you know this in linear probing you know if the actual hash function is H of K right then next time when we are going to prob we are going to take I into consideration h of k+ I right model this is what we used when we are doing this you know linear probing so why was it called linear because whenever there is a collision at some location let us say h of K then the next location which is going to be proed is at a linear distance from the initial prob position right that is why it was called linear probing which means if you are probing at a location if the initial probe position happens to be some location then the next probe position is going to be at a linear distance and in this case the distance turned out to be one all right so you know you can even do a modifications to this what if you do like this 2 I right then the next Pro Position will be at a distance of two isn't it but then you should be careful that if you do M successful probes they should all give all the uh you know locations in the hash table examined okay what I mean to say is whatever function you are using for probing right either it is linear or quadratic whenever you do M successive probes they all should make sure that you have visited all the slots in the hash table before you declare that the element is not present or the hash table is full something like that okay so in linear probing what happened is we are actually probing you know at a distance linear to the initial Pro position if the initial Pro position happen to be this the next prob Position will be at a distance of one and the next prob Position will be at a distance of one right therefore the displacement of probing is actually linear that is why it was called linear probing right now what does this quadratic probing say is whenever you are going to have a collision you know in the first probe position then the consequent probes have to be at quadratic distances which means it says that the next one has to be like this C1 into I + C2 into i s that is what quadratic Pro probing says okay I Square so it means that if your initial probing is somewhere here initial prob position then the next probe Position will not be linear it will be quadratic right and the next proposition will not be linear it will be quadratic got it so that is the main difference between linear probing and quadratic probing the distances between every probe will increases you know quadratically not linearly right so if you follow this it is called as quadratic probing now what is the advantage of quadratic probing compared to linear probing is I told you that there are two types of clustering one is primary clustering and other is secondary clustering primary clustering arises because when there is a row of or when there is a run of occupied locations let us say we have few occupied locations like this when we have a run off occupied locations right then the probability that the next slot gets filled is going to be increased because if the next key which has to be inserted happens to Hash to any of these values definitely according to linear probing that will definitely be fil know taking up this position either if it hashes directly to this location or it hashes to any of these location that element will be inserted at this location right that is the problem with you know primary clustering that is what is primary clustering and linear probing suffers from primary clustering right but this problem will not arise with the quadratic clustering the reason is if any you know if your initial probe position happens to Hash into any of these values right then the next probe will definitely be not this one it might go to some other location you know with a quadratic displacement got it therefore the probability that we get a continuous run of you know clusters is going to be reduced because of quadratic clustering right so are you observing this what I mean to say is if we are going to start here right then the next one might is not just this one right the next one is not just this one next one is not like this one in case of linear probing it was like that right but in case of quadratic probing the next probe sequence will be at a distance quadratic from your initial probe therefore the chances of building up a run of you know occupied cells or primary clusters is going to be reduced so it doesn't suffer from primary clustering but then secondary clustering is definitely possible what is secondary clustering is you know if initial probe position of two keys happen to be the same value then the probe sequence they are going to to follow is going to be same which means if h of K is same for 2 Keys then anyway this is going to be same for the you know for whatever key it is so since this factor is independent of the key and this factor is depending on the key therefore depending on the initial probe know position the consequent the consequent probe probe sequences will depend on that which means uh let take an example see this let us say C1 = to 1 okay let's not take that example why why I don't want to take any such example H before going to secondary probing that secondary clustering problem let me explain you what is the problem with these parameters no there is C1 there is C2 and there is M right the problem is I told you that any probing that you consider either it is quadratic probing or linear probing you should see see that by making M probes M successive probes you should be able to examine all the elements of the hash table and it happens in the linear probing which means see if linear probing Starts Here Right initial probe then in successive M probes if I do successive M probes then we are definitely going to examine all the positions of the hash table before we declare that an element is present or an element is not present or there is free space or there is no free space which means just by doing M probe sequences we should be able to examine the entire table but if you are not very careful if you choose this C1 C2 and M randomly it might not work that way I'll just take a small example and show you what is the problem with these parameters let us say the size of the table is 10 and so M value is 10 and the indices are from 0 to 9 the has table indices and C1 = to 1 and C2 = 1 okay and H of K let's say h of K is it doesn't matter k m 10 right so now assume that when when you try to put an element in some you know when you try to initially insert an element the initial probe sequence 0 1 2 3 5 6 7 8 9 assume that when you try to insert an element into the hash table the initial probe position happen to be one which means you are trying to put an element K1 then h of K1 turned out to be one right and let us say that value is already occupied then what I do is I'm going to again go and probe like this is H Das right H Das of k1a 1 I I'll Pro it for the next time then what happens if C1 equal to 1 and C2 equal to 1 then if you substitute in that value everything we already know that H1 of k h of K1 happened to be 1 therefore it is 1 plus right in C1 if you put one and I is 1 I is this one right C1 is this one and then C2 you put one and I equal to I know in one square I Square then you are going to get a value of three therefore the next probe will be at three let us say 3 is also occupied then where will be the next probe h- of k1a 2 isn't it the next probe will be at 1 + 1 + you know 2 square then what is this 4 5 6 right so the next probe is equal to here right then again we are going to examine it and let us say it is also occupied then where is the next prob going going to be h- of k1a 3 which is 1 + 1 + 9 so what is it 11 so the next probe is actually again we are proving the same location which we have already proved are you getting this already it has been probed once now I'm going to again probe the same location right because of which one computation is wasted and I told you that by by making the next 10 computations you are supposed to visit all the 10 location see if initial combination see if h h- of K 0 is giving you some location then I'm going to go till h- of k1a 1 h- of K1 comma 2 so on h- of K1 comma 9 right I'm going to make 10 probes to find out a location in which I insert the element and all these 10 probes have to give me 10 different sequences or 10 distinct elements or 10 distinct indic but then we have seen that h- of you know k1a 0 and h- of probably k1a 3 these two are actually giving me the same value which means by examining the all the 10 probes I might not be able to examine all the locations of the hash table then what happens then I'll examine 10 uh all the 10 locations or what whatever is given by this hash Pro know probing sequence then I'll find out that the table is completely full even without examining some of the locations that is the problem with this right so you should choose this C1 C2 and M in such a way that in such a way that whatever the initial probe position is if you make M probes you should you should be able to examine the entire table that is the problem and coming up with such a numbers is a challenge right and you know you can find it out you can randomly choose various numbers and you can observe it but then you have to do a lot of work on that so generally people don't go for this quadratic probing most commonly used method is linear probing for it Simplicity and there is one more method we shall see it later but anyway anyway this uh quadratic proving has this disadvantage that if you are not careful we might not end up examining all the locations we might end up examining only few of the locations right if you want to continue this see this I'll just tell you what the problem it is now H dash of k1a 4 then what is it 1 + 1 + 16 I square is 16 isn't it then 8 will be examined and 8 is already full right and again h- of k1a 5 then what is it 1 + 1 + 25 so what how much is it 7 will be examined let us say 7 is full then h- of K1 comma 6 then what is it 1 + 1 + 36 so what will be examined again it will be examined right 8 is already examined here and again 8 is being examined therefore that is what is the problem is right so out of the 10 probes many of the probes are actually leading to the same location which means we are not able to examine all the locations by using 10 probes even though there are only 10 locations we are not able to examine them right so that is the problem with this quadratic Pro probing you are supposed to choose the C1 C2 and M very well otherwise it is going to lead to problems right uh so and now how is this leading to secondary clustering is secondary clustering is somehow like this see if two values here in this case let's say let's take this one if the initial value happen to be one initial proposition then what is the next Pro position three right and what is the next Pro position next Pro position happened to be I think uh six right and the next Pro position happened to be I think one and the next Pro position happened to be 8 and next one happened to be seven and next one happen to be eight so on right now if initial probe sequence happen to be one these is these are the probe sequences possible right and similarly if some other key let us say this is for K1 for K1 the initial probe position happen to be one therefore the probe sequence happen to be this one let us say there is some other key K2 for which I know the initial Pro position also happen to be one then what will be the sequence of for the probe sequence it will be same 3 6 1 8 7 8 so on this problem is called as secondary clustering so secondary clustering means if two keys happen to have the same initial probe location right then they are going to have the probe sequence the similar probe sequence the reason is this one see only the initial probe sequence depends on the initial prob position depends on the key and the later probe sequence is independent of the key therefore even for when two different keys if they are having the same initial prob position they will have the subsequent probe sequences to be same that is called as secondary clustering so how will it lead to secondary clustering is watch it now some cluster will form here right and what happens is if any of the keys lead to this this particular cell which is already occupied then all such keys will go to some other location and they all form a cluster here all right and again if any of the keys map to this one again they all will form a cluster here and again they all will form some cluster there right so likewise the Clusters will be formed not continuously but then at at some distance and the distances between the Clusters will be quadratic anyway there is clustering possible because of this problem what is the problem the probe sequences are going to be be same right whenever the initial probe is same okay and now the next question is how many different probe sequences are possible by using quadratic probing the number of different probe sequences possible is you know every probe sequence depends on the every sequence depends on what your initial Pro position is and how many initial prop positions can be there exactly M initial propositions can be there isn't it because every probe every probe sequence is going to start with one number and how many numbers can be there m numbers can be there if the size of the hash table is M therefore how many different probe sequences can be totally possible because of quadratic probing exactly M probe sequences are possible getting this so this is same as linear probing which means quadratic probing didn't didn't give us any new probe sequences so it is also going to give me the same probe sequences as as there were in you know linear probing unless I have you lot of C sequences I cannot actually reduce the number of collisions there's relationship isn't it if you're always trying to insert some keys in some order then definitely if there is a collision first time then again there might be a collision second time again there might be a collision third time right so if I have lots of probe sequences then somehow the table can be used effectively in such a way that collisions will be reduced all right so the problem with either linear probing or quadratic probing is only the initial probe initial probe position is depending on the key and the subsequent probe positions are independent of the key which means either we are going to probe the next time at CI which means high in case of linear or in case of quadratic CI C1 I + C2 i s right and these two functions this one or this one is not depending on the key which means only the First Position will be depending on K and the remaining positions will not depend on K if you you can somehow make these two positions also these two functions also depend on the key or you know for a given initial probe uh you know initial probe position if you can you know if the remaining probe sequence differs depending on the value of the key that will be a better function isn't it so that is what is the next strategy we shall say it okay so anyway quadratic is better than you know uh this linear proving right but then it is not uh uh too good or it is not too efficient to implement the reason is you know choosing C1 C2 and this one is difficult and moreover it is not going to give us more probe sequences compared to the linear probing right so we go for the next next kind of proving okay fine