 Hello friends, welcome to Gate Smashers  In this video we are going to discuss  How to create the binary search trees  Binary search trees are an important part of data structure  And even if we talk about competitive exams  Or your college or university level exams  Then this is a very important topic  So guys, like the video quickly  Subscribe the channel if you haven't done it yet  And please press the bell button so
that you get all the latest notifications  So let's start the creation of binary search tree  What we have here  Keys are given, you can also say data  You can also say keys  What I have to make with this key is  To create a binary search tree  So the first point I want to tell you here  Why do we have to create binary search trees  Or is it actually there  So we have already discussed about binary trees  What does binary trees mean  Where every node has minimum 0 child  Or 1 child or 2 child  The simple difference of binary trees  Either 0 child or 1 child or 2 child  But there is no order in binary trees  There is no systematic way  You can make it any way  Let's say if I have first element 4  2, you put next 3  Put 6 here, 7 here  Put 8 here, 9 here  Any way  Means you can follow any order  What do you have to make in a normal way  You have to make binary search tree  So either 2 child or 1 child or 0 child  The simple difference of binary tree  Now I have made binary tree  Stored the data  Now after storing the data  Obviously what I have to do  Search it  So if I don't put the data in proper order  Then there will be a problem in searching it  So this is the problem in binary trees  Obviously if there is no systematic order  Then whenever you search  Then on an average you have to  Put order of n time  If you do pre-order traversal  Do post-order traversal  Or do in-order traversal  Then you have to put order of n time  To search the element  Which is equivalent to linear search  What is post-order, pre-order and in-order  I have already made a video on this  In which I have told you very well with a shortcut  That pre-order, post-order and in-order  Of any tree, whether it is complex or not  How to get it  And its link is given in the description box  You should also check that video once  So that this portion is also completed  So here we are coming to the binary search tree  So what did we do in the binary search tree  Binary tree is the same  Property is the same  Either 0 child, 1 child or 2 child  But what is put in between is search  What is the meaning of search  If I put data in order in a systematic way  Then searching will be easy  So we are going to discuss here  That in which order the binary search tree  Put in in a systematic way  So let's say if this is my root element  This is my left sub tree or left element  And this is my right element  So what is the binary search tree  That the left element should be  Less than the root element  Whatever you put in the left  It should be smaller than the root  And whatever you put in the right  It should be bigger than the root  This is the concept of simple binary search tree  So don't get confused in this  That heap tree and min heap or max heap are also these  What happens in min heap and max heap  Let's say if I want to make max heap  10, 8, 7  What is this  This is also a max heap  What does max heap mean  That the biggest element should be on the root element  But there is no difference between left and right  So here I am talking  Here it should be smaller on the left side  And on the right side the element should be bigger than the root  So you have to keep this point in mind  And you can design any binary search tree  Next point comes here  If in case element or keys are equal  Although this does not happen  Because whatever keys you have  They are not equal  The reason for this is  Like we read in the database  That our data is stored in the hard disk  You can take it anywhere  Any volatile or involatile memory  We have data stored there  Now the corresponding key values of that data  The unique values  We search the corresponding data  Like if we talk from the student's point of view  Registration number is a key value  So generally the key values  We store them in the binary search trees  So obviously key values are not equal  But even if you give equal  There is no problem  You can keep equal on the left side  Or you can keep equal element on the right side  Let's say if I am keeping 10 here  Then it should be small  Small means 8 will be here  Big element means 11, 12, 13  You can put any element  But let's suppose I have to put 10 here  Can I put 10 like this? Yes  You can either put equal on the left side  Or you can put equal on the right side  If you are putting equal on the left side  It is known as left biased  And if you are putting equal to element on the right side  It is known as right biased  But remember that you follow only one pattern  It is not like you have inserted one element  Left biased and the other one is right biased  No, either you would have been given in the question  That in case if any element is equal in between  Then you are using left biased method  Means keep equal on the left side  Or use right biased method  Means keep equal element on the right side  But any of the two has to search one  But I will tell you that in 90% or 95% portion  These unique keys will give you  So just remember that the smaller than root is on the left side  And the bigger than root element is on the right side  So let's start here  I have the first element or the first key is 4  So I have drawn 4 here  Next is 2  Now 2 is smaller than 4  So what I did is I drew here  Next is 3  Now see 3 is smaller than 4  But bigger than 2  So where will 3 go?  3 will go to the right of 2  But where is 4?  It is on the left of 4  So just remember this point  Whenever you see any binary search tree  Means if you see even a small portion of it  Then it will also follow the binary search tree  Next come to 6  Now see 6 is bigger than 4  So draw 6 on its right  Next 5  Now see 5 is bigger than 4  It is smaller than 6  So it means your 5 is on the left of 6  7  See 7 is bigger than 4  Means 6  It is bigger than 6  So bigger than 6 means 7 is drawn here  Next 1  See 1 is smaller than 4  Next is 2  It is smaller than 2 so  So draw like this  So this is your binary search tree  See this is balanced  Balanced means proper levels are getting full  But it is not necessary that the binary search tree will always be balanced  We will discuss that in the next video  The main point we have to discuss here  The first important point is  If I am making a binary search tree here  Then the first important point in the binary search tree is  That all our least elements  Whatever is the least element in the binary search tree  If you keep going to the left side  Whatever you keep going to the left side  Which last element you will get in the left side  The smallest element will be found  And if you keep going to the right side  Then the last element you will get in the right side  That key  Means whatever keys you have given  The biggest element will be there  Remember these 2 points  The third important point is  That is in order  If you check any binary search tree in order  Then it will always give you a sorted array  So you will know that yes  You have drawn the binary search tree properly  Now how do we check in order  I have already told you  That the link is given in the description box  Shortcut method  But still I will repeat it once  What is the method?  Make 2 nodes of every child  Means make 2 childs of every node  Means whoever has it, it has no problem  So there is no child of the leaf  But we have created a dummy  Why have we created that dummy?  We check in order  What happens in in order?  Whenever we reach any node for the second time  It is in order  So see let's start the journey from here  First 4  See 4 came first time  2 came first time  1 came first time  Now see I am roaming from here  I am roaming from this node  So as soon as I roamed  I reached the second time on 1  Means you write 1 first  Now see I reached the third time on 1  First reached here  Second time  Third time  Now see I reached the second time on 2  First was here, now here  So write 2 here  First time on 3  See this came second time on 3  So write second time here  This came third time  See this came third time on 2  See 4  We came first on 4  Now again came  So 4 came  Next see 6  We reached first time on 6  We reached first time on 5  See we came second time on 5  So write 5 here  Whenever you are reaching the second time  It is in order  Now see we reached third time by roaming  When you write third time  That is a post order  First time is pre-order  But we are concentrating only on in order  Next 6  We reached here before 6  Now again we reached here  Second time  First time on 7  Second time on 7  And third time on 7  So my traversal is complete  So see here in order what is yours  Sorted array  In ascending order you have an array here  Very important point is  In order of binary search trees always water sorted  And the element at the very last  On the left side  That will be your least element  And at the very last element on the right side  That is always your biggest and largest element  And second point is your in order related  Now here if we talk about last point  So height of a binary search tree  So if we talk about average case  Average case means  Where it is working in a balanced way  In a balanced way means  That levels are being filled properly  So obviously if we talk about average case of binary tree  So height is  Log n  So obviously if you search any element  Then how much maximum time you will take  It will take equal to height  Let's see if you are searching 7  So see what is the height  1  2  So see height is not 1 but 2  So see how many elements are there  1, 2, 3, 4, 5, 6, 7  So log 7  If you take base value of log 7  Because log 7 is 2.8 something  So obviously if you take lower value here  So value is 2  But we are talking about average case  So these are the main points related to the binary search tree Thank You.