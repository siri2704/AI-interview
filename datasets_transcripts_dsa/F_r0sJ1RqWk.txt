hey everyone this is kamran and our topic for today is heap data structure in our last video we looked at the three data structures where we used to have nodes arranged in a hierarchical order and they were connected using the edges we also looked at the binary trees where each node of the tree could have maximum two children there are different types of binary trees but let's look at the full and complete binary trees before we talk about the heap data structure all right so full binary tree is the type of binary tree in which each node of the tree has either no children or two children again no children or exactly two children we can't have a node with one child let's take an example to understand this better if you look at this tree you can see that all the nodes of the tree have either two children or they are the leaf nodes that is they don't have any children and because it follows the properties of a full binary tree so we can say that this tree is a full binary tree let's say that we remove the node g now in this case the tree will no longer be a full binary tree because the condition of full binary of having either zero children or two children is not being fulfilled because the node c has now one child but if we remove the node f now it will become a full binary tree because c is a leaf now with zero children next we have the complete binary tree in complete binary tree all the levels of the tree are fully filled except the last level which can be partially filled but the condition is that if we have any nodes on the last level they must be on the left most nodes again all the tree levels are to be fully filled and the nodes on the last level should be on the far left side let's take an example to understand this better so here we have a binary tree with three levels and you can see that all the levels are fully filled with nodes so we can say that this is a complete mandatory now let's say that we remove the node g now if you look at the state of the tree in this case level 1 and 2 are fully filled and all the nodes on the level 3 are on the far left side so it is still a valid complete binding tree now let's say that we remove the node e in this case the tree is no longer a complete binary tree since the condition for complete binary tree is to have all the nodes on the far left side and node f in this case is not on the far left side there are two ways to make this tree a complete binary tree we can either move f under the node b or we can completely remove the node f in both the cases the tree will be a complete binary tree alright enough about the trees let's look at the data structure heap data structure is a tree based data structure with two properties first it is a complete binary tree and the second it follows the properties of either min heap or max heap let's look at the min heap first in min heap the value of each of the parent node of the tree is less than or equal to the value of its children let's look at an example to understand this better let's say that we have this binary tree with these values now if you look at the node values you can see that the value of each parent node in the tree is less than its children so 5 is less than 10 and 12 10 is less than 21 and 22 and 12 is less than 24 and 89 and because the tree is fulfilling the properties of a heap and a min heap we can say that the tree is a min heap now before we go ahead if you look closely at this min heap you will notice two things first the value of the root node which is 5 is the smallest value of the tree and also if we keep going down in the tree the values keep increasing all right so next we have the max heap max heap is the opposite of the min heap that is the value of each parent node is greater than or equal to its children let's take an example let's say that we have this binary tree with these values if you look at the values here each pinner node has a value greater than its children so 99 is greater than 85 and 75 85 is greater than 21 and 65 and 75 is greater than 43 and 65 and because all the properties of heap and maxi are being fulfilled we can say that this is a max heap and also you can see that the value of the root node in a max heap is the largest value of the tree and also if we keep going down in the tree the values keep getting smaller and smaller alright let's look at the heap operations first of all we have the insert operation insertion and heap are done from the top to bottom and left to right let's see how it works let's start with node 40 which will become the root node because this is the first node of the tree the next item 31 will be inserted to the left of the root node 34 will be inserted to the right of the root node 98 will be inserted to the left of 31 9 to the right 33 to the left of 34 11 to the right of 34 and similarly we'll keep on inserting the new nodes from left to right all right now if we look at our tree we have a problem here it is not a heap because as per the properties of a heap it should be a valid complete binary tree which it is but it is neither a min heap because some parent nodes have a greater value than the children and nor it is a max heap because some nodes have a smaller value than the children nodes all right so how do we fix this issue to fix this issue after each insertion we compare the newly inserted nodes value with the parent node and we bubble the node up if needed let's see how this bubbling works in a min heap let's say that we have 40 at first because this is the first node of the tree so it will become the root node next we have 31 we will insert 31 at the left of the node 40 and after insertion will compare the new nodes value which is 31 with the parent node which is 40. in the min heap the parent node must be smaller than the child node so we will simply swap 31 with the 40 and 31 will become the new route next we have 34 which will be inserted to the right of the 31 now again we will do the comparison now 34 is greater than 31 so no swap or bubbling is needed next we add 9 which will be inserted to the left of 40. again we'll do the comparison 9 is smaller than 40 so 9 will bubble up next we'll compare 9 with 31 and again 9 is smaller so it will bubble up and become the new root node next we have 11 comparing 11 with 31 11 will move up comparing 11 with 9 9 is smaller so no more bubbling is needed next we have 85 85 is already greater than 34 so no public is needed next we have 10 we'll compare it with 34 so 10 is smaller than 34 so we will bubble it up after that we have 10 and 9 10 is greater than 9 so we'll stop here and no more bubbling and this is how the new nodes are inserted into a min heap we insert the node and keep bubbling it up if the value of the node is smaller than the pinup node in the similar way we have the max heap where we insert a node and keep comparing and bubbling it up if the newly inserted node's value is greater than the parent node the complexity of insertion in a heap whether it is a min heap or a max heap is logarithmic alright so next operation we have is the deletion operation while deleting a value from a heap if it is a min heap we delete the smallest value first after that we delete the second smallest value after that we delete the third smallest value and so on and similarly in the max c we start with the deletion of the largest value and after that we'd read the second largest value and then the third largest value and so on let's see how we can delete items from a min heap we know that the smallest value in the min heap is owned by the root node so we will simply delete the root node but now we have an empty space for the root to fill the space we pick up the last element of the heap and make it the new route but the issue with this approach is that the new route that we may pick it may not be the valid route so if you look at the current example we have the root node of 34 34 is greater than the children nodes 10 and 11. so our tree is not a min heap anymore to fix this issue we compare the new route with its children and bubble the node down till it reaches the place where it has to be so in this example we will compare 34 with 11 and 10. now 10 is the smallest of the three values so we will move or swap 34 with 10. next we will compare 34 with 85 now 34 is smaller so no more bubbling is needed so this is how the deletion works in heap we delete the root node move the last node to the root position and bubble the root down till it reaches its position let's take another example to make sure that we understand this better next we will remove 10 and we will move 85 to the root node now 85 will be compared with 11 and 34. 11 is the smallest so 11 will be swept with 85 now 85 will be compared with 40 and 31 31 is the smallest so 85 will be swept with 31 and with that our heap will be ready after the deletion the deletion in max heaps also works the same way the only difference is that instead of looking for a smaller node value we look for a greater node value when we bubble down the root node the algorithmic complexity of deleting a value from a heap is also logarithmic alright so now that we have covered what the heap is the types of heap and the different heap operations let's look at the use cases of the heap data structure the heap data structure is mostly used in the cases when we need to access the minimum or maximum values quickly they are used in the priority queues for example if you have a list of tasks with importance assigned to each task and while working on a task you move from the highest importance task to the lowest importance tasks in that case you might want to use priority queue or a heap they are also used in the other algorithms that we'll be covering on this channel such as heap sort and the dijkstra's algorithm alright so that is all for this one i hope you enjoyed this lesson if you have any questions or comments leave them below and i will see you in the next one