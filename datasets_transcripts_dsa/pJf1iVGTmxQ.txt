[Music] so it's time to implement the tree implementation I know the theory video has been uh uploaded 5 years back and I thought okay let me also write the code for it in the theory video of tree we have talked about different types of tree and we when you implement this we are going to implement that with the help of binary search tree now what's the difference between Baner tree and the ban search tree ban search tree is a tree the difference is the way you add values now in binary search tree what you do is you always make sure that the smaller element is on the left hand side and the bigger elements are on the right hand side that means if you talk about a root node the elements on the left hand side of a root node will be smaller than the root node and the elements on the right hand side of the root node will be bigger than the root node it's that simple that means when you try to create this tree how will you do it so let's say we have this values here now when you work with eight 8 becomes your root node okay that's so simple you always get your first first element make it a root node next you have seven now s is less than 8 so it will go on the left hand side so that is eight seven here then you got 12 now 12 is bigger than 8 so it will goes on the right hand side now of course for the root node both the nodes have been covered what about the next 15 where 15 will go of course you cannot create a one more node here that's not possible for for the binary tree so what you do is you travel now where to travel left or right now 15 is bigger than 8 so it will go on the right hand side but we already have 12 there now 12 have an option of putting 15 left or right now since 15 is bigger than 12 it will go on the right hand side so 15 goes here next element is two now two is smaller than 8 again we starting from root node so starting from eight it is smaller then it goes to seven it is smaller it goes on the left hand side of seven which is two here because it is Les less than seven next we have is five so we got we go to eight it is smaller than eight we go to seven it is smaller than than 7even we go to two it is greater than two so it goes on the right hand side of two so five goes here so this is how the ban search tree works now once we got the basic understanding let's start the implementation if I want to code that first of all we need for sure we need a class called node right in fact I will not be writing this here let me just remove it what I want is I want from my main method basically I want to create a binary tree there are some in classes but we're not going to use it so let's say binary tree and we'll call this as a tree equal to new binary tree so we want to build a binary tree okay you can see we have some inbuild methods we don't want to use them so let's use a binary tree we don't have this class yet so what I will do is I will just go back here and you can see is importing this package we don't want any inbuilt things so if I go back here and if I say hey I give me suggestions more actions I want to create this class but the same package and you can see we got it I will just move this on this side I don't want to see the project structure so you can see on the left hand side we have a main on right hand side we have a binary tree so basically in this binary tree I want to do all those stuff now when I say I want to do stuff basically we have to say tree dot I want to insert value in this tree so I can say insert and I can pass the value let's say 10 I don't know what values I'm passing here or maybe I can I can f the same value which we have in our notes so we have 8 7 12 15 2 and 5 let's add that okay but unfortunately we don't have this insert okay so what we need to do is we need to create this method called insert inside this B and you can see we got insert method okay but when you say insert that means we have to make sure that you're inserting a node of course you're passing data here but it should be added to a node right and we don't have a node implementation yet so I can create a node implementation by saying class node now what every node will have now if you go back to link list a node will have two things the data and the next value now in terms of this node here which is a tree node it will have three things data the left node and the right node so I can say int data then we have to say uh node because when you say right node left node they are itself nodes right let's first right left and then right so yeah so we got data we got left node and we can we got right node I think the only problem is in some of the class I think in linklist we already have a node here that's the problem so what I will do is let me just move B tree and this main to some other package I I will just move B to package say package com. cod. three so sometime you have to solve the problems in a go need to import the package from here now importing done okay so problem solve the problem was I was having two classes with the same name in the same package I just moved it to different package okay so now uh you don't have to do that if you're just writing the binary code you can just skip this line anyway so we got a node and then we are referring to left node and right node so that's node done but also what I want to do is maybe when I create a node I will I want to have a Constructor here which will take the data from me and and I will asside that data so I can say this do data to data and that's it so we are basically done with the node concept but how will you implement this tree so every time you want to insert the data in a tree how will you do it so if you say this is a tree of course we don't let's say we don't have a tree here and let's go with the same value I don't know what values we have I can just use this copy okay so we got this value so if I want to draw a tree so let's say someone is giving you the value eight initi so what you do is you create a root node now we know that we don't have a node in the tree so basically the tree is empty in that case you will make this as a root node okay so how do we do that so when you say insert basically we have to create a root node that means every tree need to know about only one thing which is a root node right as I mentioned before for a tree the most important thing is root and then tree don't have to worry about other nodes the root node will take care of the next two nodes so what I can do is I can say node root and then every time I create insert and then imagine that this is a first time so what you will do is you will create your root node here so you can simply say root is equal to new node that's how you create a node just create the object and pass the data and that's it you got your root node in fact you know instead of using this variable as I it should be data it will make much more sense so now if you can see our code this is the thing we have done so we created a root node called 8 and that's your root node which looks good but then what about if I insert one more data here so if I say insert I want to insert the next record what's the next record is is seven so when I insert seven where the seven should go now don't to think the seven should go on this side is because we are implementing B search three seven is less than eight so it should be on the left hand side so when I say seven it should create a new node and we are doing it you can see every time you say insert it creates a new node but don't you think this time is not a root node it's a left node of the root node how will you do that and how do we even know that this is not a root node so in that case we need to do is we need to check if the root is null then you create a new node I mean then you create a root node otherwise you don't create root node every time so root node will be created only once if the root is null what else if it is not null then we can check for something else now see if you talk about eight yes this satisfies is because root is null till this point when you before executing eight but when you insert seven we already have a root node right then we have to go for if Els now the question is now we know that this is not a root node we have to either go for left or right so what you do is you basically check for data if the data is less than root. data then you go on the left hand side so when you say you go for left hand side what what you simply do is you say root. left do data is equal to data that's what you do but then we have one little problem here because see this will work for this data okay so we will get new new uh thing but we not even creating a new node okay so that problem is we need to modify this to something else why something else let's say we have adding one more which is 12 goes here and then you add 15 now by our logic if the value is greater than root node just add it to the right hand side but 12 is already there right then we have to move to 12 and it becomes a right hand side of 12 that means we have to jump from root to the next element and then the next element oh that's a recursive process now so that means we have to add a recursion here that's one thing second problem is every time you insert data we need to get a hold on root you know writing the logic here is not efficient way what we should be doing is create another method which is called let's say insert Rec and we'll say this will take two things because when you want to do recursion we have to get a hold on root element or root node so that means we cannot do that in this insert because the moment you a recursion every time you call the method we need to get the hold on the Node where you're calling this so this will not work but that doesn't means we have to remove this I will tell you in sometime why so basically we have to say node root comma data and here okay this should return a node because we're going for recursion so it should return something and now here instead of doing all this logic this logic should be a part of this not this so here we can simply say root is equal to insert record so every time you call insert it will call insert Rec in which you are passing the root node and the data so when you say recursion it will go into recur we will be using recursion on insert Rec not on insert so we have to change some logic here so this is correct when you say root I'm only concerned about this part so how do we implement this one so when I say I want to add element on the left hand side so if you have let's say two now we know that two should go here but then we have to jump from 8 to 7 7 to two that's a recursive recursive process right so what you will do is let me uncommon this now this is not how you do it so basically you say root do left and then you call the function once again by passing The Root do left because now we we need to follow the tree right as I mentioned before when you talk about the sub trees if it is not eight left then we have to consider this sub tree now this seven becomes your root so how will you send this as a root so you have to say root left now this becomes a new root so when you call this function which is insert Rec here this becomes your new root and then you have to pass data as well so you're passing data but what if this is not small smaller then you have to go on the right hand side so I have to say root. data if data is greater than root. data then you do the same thing but for the right hand side so we'll say paste here so this should be right and this should be right and then at the end you know your root node so just return root that's it so this is the recursion call which we are getting here so that's how basically you create a tree now this is tree is created but how will we know that this tree is created we want to print also right and the way you can print it is like this so if you want to print this tree so let's say we have this tree here and this tree is created by the way we have defined this example here how will you print this now to print we basically have to Travis or we have to travel to different elements here the way you do that is we have different travel cell for tree so when you talk about tree travel cell uh we have to follow certain things first there are three three options here we have in order traversal we have pre-order traversal and we have post order the difference between these three is the way you print your root node okay so when you talk about in order basically what you do is you first go to the left then you go to the root then you go to the right so which is 7 8 12 when you talk about pre-order here you first go to root which is 8 so it will print8 then seven which is left and then 12 which is right when you talk about post it means first it will go for left then right then root which is 7 12 and 8 okay that's your post Auto traversal here we are going to go for in order so in order simply means first you print the left one then you print the not exactly printing but you go to the left one then you go to the root node and then you go for the right one so that's your in order now the way you can do that of course this is also recursive right uh so in order to do that what I will do is I will create a function called public white in order then you can work here but then since we know that in order is actually or traversal is basically a recursive operation where you go to each sube and print it or do some operations for the recursion I will create another method which is public void is because I don't want to return anything so I will say in order Rick so here we just want to print it now when you say print it how exactly we going to print how we going to travel this of course the output will not be similar to the value we have inserted it will have a different order so what it will do is first it will go for it it will print the left one right so when you start from here it goes to eight but then we cannot work on the eight because that's a in order then you go to the left one because in in order you first go for left hand side left sub tree and then from Seven also you can't print seven because seven becomes a root node for the two so we have to go to two now we don't have any left here right this is empty so in this case you will first print two okay so you will go for two but then you go for right since we don't have a left we print the root node because we are considering this sub tree now so so you will print two and then you will print five so here we have five then you go up then you print seven because we don't have anything so that's a parent for two so we'll go for seven then we print on the right hand side we don't have anything right hand side right so this is empty then you go up you print 8 then you go for the right hand side right hand side is 12 on 12 left we don't have anything so it will not print anything but you can print 12 and then you can go for right hand side which is 15 and if You observe you got a sorted values so that's why we use BST which is sorted values it is is easier to search as well okay this is the in order traversal okay so let's implement this so how do we do it so first we'll start from the left hand side but also we want to verify if the tree is empty if the tree is empty how will you print something how will you travel and how do you know if the tree tree is empty by using the root element so we can simply check if root but how do you know the root because root will keep changing depend on tree right uh so we have to also accept root here so we'll say node is root and then you check if the root is not equal to null then only you do it now how will you do it now first of all this is a recursive function right so basically you have to call itself so we'll say in order right and then you have to start from the left hand side so always start from left and then keep going till you find the last left element okay and then once you do that then you have to go for the middle one middle one is root itself which we got here right so we can print this value here so I will say print and if You observe for every node for every sub tree there is always a root node If You observe for eight seven is Left Right but don't you think seven in this sub tree is a root node so that's a root we are printing when you go to two two becomes a root node right when you go five five becomes a root node for their child which we don't have then we can so we can print data here so we can say root do data and then we can print a space in between as well just to differentiate the values and also I can skip the new line now once you have done with the root element of course not just printing you can do some other operations as well maybe you can add all the values if you want and then here I can say in order but this time you will go for root dot WR that's it this is how basically you print the values but from in order we have to call in order Rec by passing The Root node so you will call this only once in order so that means I can simply create a tree by adding values here first of all now what values we have let me just do that quickly okay so you can see we have added all the values and now it's time for traversal so I will just print in order and it should do the job for us let's try so I'll just run this and you can see we got the values we got 2 5 7 8 12 and 15 that's what expected it is printing in order but let's say if you want to do Post order so what I can do is I can just change their names I maybe I can say pre-order so I can say preorder and of course everywhere you have to do that now the only change you have to make is in pre-order first you print the root so that means this line will go up that's the only change you have to make in pre-order okay nothing much let's run this and see if this works save this code and run and you can see this is now pre-order so root element is something which will get print first I think this is the sequence in which we have added no different sequence but anyway you got the point so this is pre- order you can also do it post order let me know in the comment section if you have done that and yeah that's how you implement tree