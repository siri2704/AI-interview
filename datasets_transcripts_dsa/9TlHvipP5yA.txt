welcome that I relate few pieces of code and show you how to analyze them how to find out the time complexity for them this is a simple loop I am not reading a complete algorithm I have this written a piece of code in which one statement is there but we are already familiar with this one we know that this will execute for n plus 1 9 and this way is good for and we don't want this time because anyway when we are at the order of be writing a degree so this will not affect the degree at all so it will be same only so just you need to move the statement how many times it is executed so that's it so this is order of n you can avoid this one skip this one next if suppose this loop starting from N and the condition is greater than 1 or 0 and this was getting subtracted so this loop is decrementing then also this statement will execute for n times and it sort of in whether you go from one to ten ten steps or come from ten to one then also ten steps so you go from one to ten or ten to one signal process so that's how n to 0 at us so it's also all wrong and if this is starting from one and condition is less than N and I is being incremented by 2 so this statement will not repeat for ten times but half of the end times and by two if it is n by 2 also if I say function s and by 2 what is the degree of polynomial and only search part of n again so in this case also it sort of end even if it is incrementing by 20 then this is 20 degree of a polynomial is and so resolves forever friend so end by anything this whatever the number of times it is implementing the time will be same nice we are already familiar with this one these are two loops nested loop one inside another and this we know this relates q4 n times so this is also n times and resolves right times actually is n plus 1 but what about this one again this is repeat for n plus 1 times and so they before any time and this is all rough and squared the next is again nested for loop this looks similar to the previous one but not see I did travel 0 I less than n but G takes value G less than I so here is a defense so let us analyze this by tracing this one and find out how much time it is checking so for this I will take I value and J value and paste them let us start initially I is 0 when I 0 J starts from 0 and 0 less than 0 no it will not execute for any number of times so here I have to find out how many times the statement is executed so number of times so it will not execute at all so 0 times then this loop ends again I am plus plus I becomes 1 I is less than n in suppose it's enters inside then again this group 0 0 is less than 9 yes then J plus plus J is 1 1 is not less than I so for 1 it will not execute so how many times it has executed one time and then goes up again I plus plus I becomes 2 then J will execute for 0 1 and when it becomes 2 it will stop so this will be 4 2 times and when I is the 3 J will take 0 1 2 & 3 so this will be 4 3 times and this process continues see when I was 0 it was never executed when I was 1 it was executed for one time this is statement I was true it was a spirit for two time three rate and so on so on up to what and so total when it is n right how many times this will execute n times when I was three so three times so if it is reaching till n actually it is less than n but let us say m is reaching till 10 so it will execute for 10 times so total how many times it is executed this one right so I am assuming that it is going till then no it is not didn't this less than n times 1 plus 2 Plus 3 plus goes on to and this is nothing but n into n person by 2 what is the degree of this one F of n as n square plus 1 by 2 Davy's square so all Roth and square for the time complexity is order of n square though this is not similar to the previous one but if you're analyzed answer is coming 2 and square only the degree of the polynomial is n square only next for is here Beasley's rest with you and as a loop does not get very good for n times C the speed P is less than equal to n it's not a less than equal to n so the condition is different then what is P P is initially 0 and every time I is added to P so now we don't know how many times it's going to execute let us analyze I will take I value and B value initially this is 0 and this is 1 so what happens first time this one is added and it becomes 1 the next time it will be do so it will be 1 plus 2 so it will be 3 then next time I will be 3 and this will be 1 plus 2 Plus 3 then idle before it will be 1 plus 2 Plus 3 plus 4 goes on how many times it's going to execute it's going to execute for K times so what this will be 1 plus 2 Plus 3 plus 4 plus goes on to K time my hope K here is not reaching it is not repeating for n times definitely it is red waiting for some number of times so that we don't know we are sure that it still not execute for n times this how many times because the conditions so I said let it be came and let us find out that came so if it is repeating for K times then what is the tradition we are seeing that P has became greater than M so when P became greater than n it is stopping we assume this as long as E is less than equal to n it is repeating so when P becomes greater than n it is stopping right since P is what CP see it is getting to k plus 1 by 2 P is akin to k plus 1 by 2 so what's the condition K mu K plus 1 by 2 is greater than n so when it will stop when k k plus 1 by 2 has became greater than n it'll stop so what is K roughly as limit as K square so what is K gains and K is a root n so this loop will execute for order of n times let me show you quickly I assignment 1 I P is less than equal to n I dismiss this is not I less than equal to n so we don't know how many times it is repeating II's here P is here so either these are incrementing and every time I is added to P so we don't know how many times so let us say K times and this will be 1 plus 2 plus 2 K well so that K s P is gain k plus 1 by 2 now so we know that this was repeated as long as P is less than equal to so if you'll stop then P becomes greater than n so then P becomes greater than n if it stops okay and keep us on white goo becomes greater than it will stop so this is K Square and K is okay in the next video we'll find more examples right so different type of course I will show you and I'll show you how to analyze them so this is all by tracing you canonized n so in the other video next video also you can find few more algorithms that the Tracy