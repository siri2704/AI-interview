I have solved 554 lead code problems but you don't have to it took me 500 plus problems to realize that there is an easier way to become better at coding problems and that is just focus on the patterns that repeat over and over again in this video I'll show you eight such patterns let's start with sliding window pattern the sliding window pattern is used when you need to process a series of data elements like a list or string in the sliding window pattern you find specific things in a list by looking at a smaller part of the list at a time the part of the list that you are looking at is called your window this window then slides one step at a time until the entire list is scanned when do we use the sliding window pattern if a problem asks you to find a subset of elements that satisfies a given condition think about sliding window pattern your input would be a linear data structure like an array string or a link list and you would have to find the longest or a shortest substring or subarray that satisfies a particular condition for example look at this longest substring with K unique characters problem your input is a string and you need to find the longest substring that satisfies unique characters condition it's a classic sliding window problem next we have the subset pattern the subset pattern is used when you need to find all the possible combinations of elements from a given set repetitions may or may not be allowed depending on the problem in the subset pattern we need to explore all the possible Arrangements of elements from the given set take for example this permutations problem from lead code to solve this problem you can iteratively build all the subsets level by level start with an empty set at each level consider all the ways to add the next element to the existing subset and create create a new one this approach is very similar to breath first search or BFS next we have the modified binary search pattern the core idea of binary search is to divide the search space in half again and again in the modified binary search pattern the core idea Remains the Same but we need to adjust the logic a little bit to solve the given problem let's take the example of search and rotated sorted array problem here the array is sorted but rotated at an unknown Pivot Point you'll need to modify the standard binary search to figure out which half of the array to search in one thing that helped me a lot to solve modified binary search problems is understanding the core binary search algorithm really well for the core binary search algorithm you need to be able to visualize where left and right pointer end up if the array contains duplicates or if the array does not contain the target let me give you a good way to improve your visualization of binary search bisect module in Python contains two functions bisect left and bisect right Implement these two functions in the language of your choice and your understanding of binary search will improve a lot before we talk about the next pattern I want to make it very clear that you need to have a good understanding of data structures and algorithms to solve the problems that we are discussing today if you want to know how to master DSA and how much DSA you need to learn before you can solve these problems you can join my free 5-day email crash course on interview.io moving on the next pattern we have is topk elements pattern the topk elements pattern is used to select K elements from a larger data set given a particular condition think about this pattern whenever the problem asks you to find top ranking elements from a data set the input would usually be a linear data structure like like an array or a list for example given an array of numbers you need to find the kth largest number efficiently to solve this problem you need to keep track of the K most important numbers that you have seen so far since you care about the kth largest element the largest K elements you have seen so far are most important so you would store them using a data structure called Heap we'll come back to why we use a heap in a moment anyway the smallest number on the Heap would be the K largest number we have seen so far if the new number is larger than the K largest number so far you will remove the K largest number so far and add the new number to the Heap we use a heap here because it makes finding and removing the smallest number very efficient next we have depth for search of a binary tree or binary tree DFS pattern binary tree DFS helps you visit every node on the tree focusing on one branch at a time generally you would use recursion to do this here is how the flow looks like you will start at the root node after that you apply DFS recursively to the left node this process continues going deeper and deeper into the left subtree until it reaches a node with no children once the DFS reaches a dead end on the left side it backtracks now it focuses on the right node if it exists and applies TFS recursively Again by doing this you explore the entire right subtree for example in this very popular problem called maximum depth of binary tree you need to find the length of the longest path from the root node to a leaf node for this you simply keep track of the depth as you do a binary treat DFS and whenever you reach a dead end you update the maximum depth if the current depth is more than the maximum depth it's that simple next pattern we have on the list is topological sort the topological sort is used to arrange elements in a specific order when they have dependencies on each other it's particularly useful for directed a cyclic graphs whenever the nodes of a graph have one-way connection between them and there is no cycle it's called a directed a cyclic graph think of topological sort whenever you have a prerequisite chain let me explain what I mean by this imagine that you're building a complex program some parts of the code might rely on some other modules being written and tested and these modules can in turn depend on some other modules topological sort can help you figure out the order in which you should write your modules by analyzing the dependencies between different modules it creates a sequence where each module is processed only after all its prerequisites have been completed try this course schedule problem on lead code where instead of modules we have courses as prerequisites for other courses next we have breath for search of binary tree or binary tree BFS pattern so we already covered binary tree DF BS in binary tree DFS we go deep into a branch and explore it completely then we move on to the other branches in binary tree BFS we take a different approach BFS explores all the nodes at same level in different branches first to do this you'll need to use Q data structure in the beginning the queue would only contain the root node after that you're going to repeat the process I'm going to show you again and again you'll remove a node from the front of the queue and do any operation that you might want to do with it then you add both its children on the Queue you keep keep doing this until the queue is empty by doing this the elements at the same level of the tree will always remain next to each other on the Queue this way you can process them one after the other a problem that is a direct application of this pattern is called level ordit reversal of a binary tree it's exactly the same what I just explained lastly we have the two-pointer pattern the two-pointer pattern is used to solve problems when you need to iterate through a sorted array taking a hint from the name itself we'll be using two pointers in this pattern each pointer will keep track of an index in the array by moving these pointers smartly we can often solve the problem in a single pass making the algorithm more efficient let's take the example of the two sum problem you're given a sorted array and you need to return the index of two numbers that add up to a Target sum to solve this problem you can use two pointers the first pointer starts at the beginning and the second one starts at the end of the array depending on whether the sum of the numbers at the pointers is less than or greater than the target sum you will either move the left pointer to the right or the right pointer to the left this works because the input array is sorted another variation of the same problem is when you need to find triplets that add up to zero in a sorted array so far we only covered some popular lead code patterns but your job is not done yet you need to find some problems that fall in each of these patterns and solve them one by one but before you do that learn how to master data structures and algorithms by signing up for my free email crash course on interview.io my name is sahil and I'll see you in the next one