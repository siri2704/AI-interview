so I created a leak code roadmap and made it free for everyone but before I show you make sure to like And subscribe never mind let me just show you it's sort of like a non-linear video game where you kind of have options of which order you want to complete each Topic in except of course this is leak code so it's definitely not going to be as fun but the reason I made this is that I've kind of had a visual map of this in my head I kind of know the relationship between these topics like for example linked lists are kind of your introduction to graphs where you have nodes and edges and then right after that you learn about trees most people will learn this in a computer science course but there's definitely a lot of topics here you probably won't learn in class things like tries which naturally come after trees but remember that trees also cover binary trees and before you learn about binary trees I think it makes sense to learn about binary search because it's kind of the same algorithm that you use binary trees for I've been wanting to make this for a very long time but I just finally had time during the holidays it feels good to have a visualization for my thoughts but I think also the this will help a lot of people whether you're a beginner being introduced to these topics the first topic is arrays and hashing you don't really need to know a lot of data structures and algorithms to you know solve this topic you just need to have programming knowledge about loops and conditionals and of course basic data structures like arrays and hash Maps but you don't really need to know how they're implemented and after that you learn more complicated things but you do so in a very structured way and if you're completely brand new to data structures and algorithms you can always check out my courses and get lifetime access to them we recently started adding articles to complement all of the video Solutions that's my short little plug but moving on I consider most of this math pretty objective I think most people would agree that two pointers should come before binary search because binary search is sort of a specialization of two pointers the same thing could be said about sliding window and similarly linked lists a lot of these linked list problems require two pointers so I think it makes sense to learn two pointers before that and of course trees should come before linked lists it's a more complicated version of a linked list and then right after trees things get pretty open-ended like I said we have tries but we also have heaps which are a specialization of binary trees they are also a bit more complicated I think and we also have backtracking which I think makes a lot of sense to learn after trees because backtracking is essentially just a big decision tree like looking at one of these thumbnails you can kind of see it here backtracking problems are naturally suited to trees at least in terms of visualization and then after backtracking things get even more open-ended we move on to graphs which we already kind of learned about with trees and linked lists and many graph problems require recursive backtracking usually depth first search so I think it makes sense to do it in this order also we have one-dimensional dynamic programming dynamic programming is kind of a specialization of backtracking where you you add caching and then you know there's the true dynamic programming solution which looks a bit more concise something like this and that usually doesn't involve recursion but I still think learning backtracking and getting good at it before tackling dynamic programming will make it a lot easier and the reason I have two dimensional dynamic programming after graphs of course we have it after one dimensional dynamic programming because two-dimensional dynamic programming problems typically involve graphs I think unique paths is one that does involve like a two-dimensional graph the longest increasing path in a matrix you can imagine that's also going to be related to graphs but we also have advanced graphs which are kind of more academic related algorithms things like dixtra's algorithm with network delay time you'll need extras algorithm and that algorithm also involves a heap it's the shortest path algorithm so it makes sense to have advanced graphs come after the heaps category at this point I'm sure you're starting to get an idea of what I'm talking about all all these topics are related to each other and learning it in that way can kind of help you solve individual problems if you couldn't solve a problem in one of these complicated categories there might be a reason for it might be because you're lacking in one of the more simple categories and it can be very difficult to figure that out because as you're just going through a single big list of leak code problems in a random order you don't really know that it's hard to figure out what you're good at and what you're not good at and what you might need to practice more on and some of these I will admit are a bit opinionated things like intervals why would you need to learn intervals after you learn about heaps well there's not necessarily a good reason though interval problems typically require sorting which is different from Heap sorting but the main reason I put this here after heaps is because first of all intervals are probably a bit less important than Heap problems but also because one of these uh problems does require a heap but most of them don't so you you could you know make an argument that some of this list could be a little bit different you could say the same thing about these greedy problems definitely not all of these greedy problems will require a heap I think most of them will not but still I think greedy problems are less important than heat problems then last couple ones we have bit manipulation again I put this after two dimensional or one-dimensional dynamic programming because one of these I think does involve dynamic programming but other than that there's no reason that you should learn bit manipulation after dynamic programming but I do think it's generally less important than dynamic programming so it makes sense and math and geometry though I think this one makes a bit more sense because you should learn this after you learned graphs because a lot of these are related to matrixes or matrices and some of these also do involve bit manipulation I think these three do but I guess if I wanted to make this map as accurate as possible instead of having a topic like arrays and hashing and then right after that we have new topics like two pointers does it really make sense for somebody to have to solve all of these problems even some of the more difficult ones before moving on to some easy two-pointer problems like some of these are pretty easy I would argue definitely not so I'm also thinking about creating a new version of this graph that's much more detailed like essentially we'll have multiple nodes for two pointers we'll have multiple blocks and maybe one of them will be the easy two-pointer block and then after that you can solve easy binary search problems and then maybe after that you can solve medium two pointer problems but if I did that you can tell that this graph would have been ginormous it's already pretty big so I wanted to first start out with like a simple version but if people are interested in me creating a more complex one that's a bit more granular I'm happy to do that but can you believe that this is free every single one of these when you open it up it has a list of problems every single one of these problems has a video solution that I created on YouTube it also has code in multiple languages not just python but Java JavaScript and C plus we're working on adding even more than that feel free to contribute on GitHub I also added a few more quality of life features things like being able to sort by the problem name also by the difficulty things that people have been asking for a long time you can also star problems some people were asking for that so feel free to you know star all the problems you want also you have to admit that it's kind of neat that this is a graph when we're learning about data structures and algorithms which you know graphs you know you know what I'm talking about and you know you can play around with this you can enable dragging which will let you kind of move these around but you know if you do that and you let go of it it's gonna end up opening uh the panel sorry if that's annoying and yeah I mean did I mention that this is completely free so definitely try it out if you want to do me a favor tell everyone you know your friends your parents your girlfriend away uh your dog tell everyone and especially please please tell me any feedback you have any suggestions I literally read everything I don't always have time to respond and I don't always have time to actually implement the suggestions but I read every single one I literally obsess over May making the site better and providing more value to people I'm really looking forward to what you guys have to say oh God somebody turned that light theme off I don't even know why I implemented that but thank you so much for watching hopefully I'll see you pretty soon