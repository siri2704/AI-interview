hey everyone first up a very big thanks for actively tuning in to all our tech oriented videos talking about tech we bring you an exciting tech savvy week with full-on cutting-edge tutorials based on software development starting from the fundamentals of data structures and algorithms to mastering the state-of-the-art frameworks and getting involved into the latest and trending projects for your portfolio so without any further ado let's get started with our day one of the software development journey so on day one we get to start with the fundamentals of software development where we get to master the data structures the data structures act as the foundation of any software program it's important for the developers to have a comfortable understanding of data structures and learn the knack of implementing them in real time the sole reason for which we have devised and strategically organized all the critical data structure tutorials along with the real-time examples in the learning order so how does algorithm work in real life so we'll have a use case here on my screen we have a lady and she is shreya shreya wants to make some tea and for that she is following some steps so the first step is she will take a pan and fill it with water and place it on a gas stove followed by that the second step is she'll make sure that the water comes to a nice boil and then she adds some tea leaves and sugar followed by step 2 we have step 3 where she'll allow the leaf to be fully expanded and she'll add some milk after that next we have the step 4 where she will wait for the tea to come for a good decent boil next we have step 5 where she'll turn off the gas and she'll take the pan off from the stove and the tea is ready to get filtered and lastly we have the step 6 where she is all set with the t so in computer science an algorithm is a method or set of rules that we must be following to perform some specific calculations or other problem solving operations as a result an algorithm is a collection of rules or instructions that govern how a work needs to be conducted step by step to achieve the desired results to accomplish a task we first provide some input and then follow a sequence of steps to acquire the required outcome of the input so that is the fundamental definition of an algorithm and we also had a use case and now we will move ahead and understand the characteristics of algorithms so basically we have six characteristics of algorithm so the first one is it should be clear and unambiguous the second one is that it has to be well defined inputs and the third one is that it has to be having well-defined outputs as well the fourth property of an algorithm is its feasibility followed by that finiteness and finally we have language independence now we will look into each one of the characteristics in detail so first we have clear and unambiguous so this statement is the one which states that the algorithm should be straightforward simple and easily readable each one of its steps should be distinct in every way and lead it to a single conclusion so the next one is it should be having well-defined inputs so this means that an algorithm should indicate what output can be expected as well as the input should be properly well defined now we have the third one similarly we should also have well-defined outputs so the well-defined output characteristics of an algorithm means that the algorithm must clearly indicate what output can be expected as well as the output should also be well defined followed by the third characteristic we have the fourth characteristic that has the finiteness of algorithm so the finiteness of algorithm says that the algorithm must be finite and it must not result in infinite loops or similar situations so followed by the fourth one we have the fifth characteristic that defines about the feasibility of an algorithm so feasibility of an algorithm states that the algorithm must be really simple generic and practical it must be able to be executed with resources available now the last characteristic of the algorithm as being independent of the language so it means that the algorithm should be defined in such a way that it is completely independent of the language it must be simple instructions that can be implemented using any programming language so these were the six major characteristics of algorithm now let's move ahead and understand how to write an algorithm writing an algorithm does not have any hard and fast rules next algorithms are never created to support a specific programming language as we all know algorithm should be capable enough to support the conditional statements such as if if else switch etc an algorithm should be capable enough to execute some of the conditional statements such as if if else switch etc and also it must be capable to execute the iterative statements such as for loop while loop do while loop etc we usually create algorithms in a step-by-step manner however this isn't always the case after the problem domain has been well defined algorithm writing is a procedure that is carried out we build an algorithm to find a solution to a problem a problem can be resolved in a variety of ways let's look at an example of how to write an algorithm consider the following scenario we need to create an algorithm to determine the largest number among the three given numbers x y and z as a result the initial solution to the problem can be written in this manner so we begin with reading all the three numbers and in the second step we will have a condition that says if x is greater than y we will proceed to step four else we will proceed to step five next in step four we establish a condition that if x is greater than z then x is the largest of the three numbers otherwise z is the largest if y is greater than z z will be the greatest number otherwise y will be the largest number amongst all the three in step five and the procedure will be terminated let's have a look at what the next solution has to offer in this algorithm we begin by reading all the three variables then compare all the three numbers in the third step to determine the largest number which is if x is greater than y then there is another if else statement that states that if x is greater than y then x is largest otherwise z is the largest then there's if else statement which says that if y is greater than z then y is greater otherwise z is the greatest of the three numbers so this is how we have multiple solutions to the same problem so after discussing these solutions we will move ahead and understand algorithm analysis the algorithm may be studied in two levels first before it is made and then after it is created the two analysis of an algorithm are as follows the first one is priori analysis and the second one is the post analysis so first we will talk about the priori analysis priori analysis refers to the theoretical analysis of an algorithm performed before its implementation before implementing the algorithm other parameters such as processor speed might be considered which does not affect the implementation component next we will talk about post analysis a practical analysis of an algorithm is called as posterior analysis and it utilizes any computer language to build the algorithm the purpose of this analysis is to determine how much time and space the algorithm takes to operate now after being understood the algorithm analysis we will be able to comprehend the algorithm complexity two methods can be used to assess the algorithm complexity the first one is time complexity which states that the amount of time required to finish algorithm's execution is known as its time complexity followed by time complexity the other one is the space complexity which is calculated by the quantity of space required to solve a problem and produce an output of space complexity of an algorithm let's take a closer look at these complexities now we will begin with time complexity of an algorithm the big o notation is used to express an algorithm's time complexity the asymptomatic notation is used to depict temporary complexity of big o notation the time complexity is mainly determined by counting the number of steps required to complete the task let's take a look at an example to understand this time complexity in a much better way if we want to find out a multiplication of n numbers we can do it by executing a loop from 1 to n then calculating multiplication when the loop ends then multiplication holds the n numbers multiplication and last we return the calculated multiplication the loop statements time complexity will be at least n and when the number of n increases the time complexity will also increase while the code's complexity that is returns multiplication will remain constant because its value is unaffected by the value of n and it will obtain the result in every single step next we will discuss about space complexity which is expressed with big o notation just as time complexity these four items are stored in space complexity it initially saves program instructions then stores constant values then stores variable values and finally it keeps track of function cells jumping statements and so on the sum of auxiliary space and input size is used to calculate space complexity the extra space or temporary space used by an algorithm is referred to an auxiliary space after learning about algorithm complexity we will look at some of the algorithms pros and cons so let's start with the advantages of algorithms firstly algorithms are easy to understand next algorithms are step-by-step representation of a solution and lastly the problem is broken down into smaller bits or steps in an algorithm making it easier for the programmer now an algorithm also have various drawbacks one of which being it takes long time to write hence it is time consuming second con of the algorithm is algorithms make it harder to demonstrate branching and looping statements so followed by the advantages and disadvantages of algorithms we now enter into the final segment where we discuss the differences between algorithms and programming so the first difference is that an algorithm is a type of programming on the other hand a program is more directly associated with the computer performing one or more tasks but an algorithm is more of a notation a technique for solving a problem now let us discuss the second difference an algorithm can be decoded or run by a human whereas the program is only run or decoded by a set of compilers of the computer now the third difference basically an algorithm is a design of the solution to the problem here we can only analyze the solution but we can never run it but whereas on the other hand programming is completely a different ball game here you can directly implement a certain phase or an entire program and test the programs and get an output so the fourth and the last difference between an algorithm and programming yes an algorithm is written using natural human vocabulary whereas programs are written using any programming language such as c c plus plus java python etc now let's get started with our first concept that is what are data structures data is an information that has been translated into a form that is efficient to movement or processing in computing as it relates to trades computers and transmission media data is an information that has been converted into binary digital form the term raw data refers to the data in its most basic digital format after defining data let's look at what data structure entails a data structure is a data organization management and storage format in computer science that allows for efficient access and modification or a data structure is an algebraic structure about data that contains a collection of data values their relationships and their functions or operations that can be applied to the data we will now understand why exactly we need data structures now that we have already defined what is a data structure so let us have a look at some of the data structure characteristics the first one is each data structure allows data to be stored differently following that the data structure allows for more efficient data search and retrieval then specific data structures are chosen to solve specific problems last but not the least it enables the management of large amounts of data such as large databases and indexing services such as hash tables let us now look at some real world examples of data structures first and the foremost we have the dictionary assume that we are looking for the word simply learn in the dictionary and we know it begins with the letter s so we can search for this word beginning with the letter s and then this is an example of array data structure as a result this dictionary can also function like an array data structure following by that we have a music player example if you have a playlist with three songs the second song will play after the first and the third will play after the second so these will be played without any interruption because all these three songs are linked with each other using linkless type of data structure so followed by linked list the next example we have is the data structures the stack of books analogy is a perfect example of the real-time working of the stack data structure subsequent to that assume there is a line of people at a ticket window and the person who comes first gets the ticket this particular movie window queue is an example for the real time implementation of queue data structure last but not the least google maps google map is the graph data structure in which all the cities and states are connected if we want to go from one place to another there may be many ways to do so so we can use some algorithms to find the shortest path as a result the google map is a perfect example for the graph data structure working analogy following that we will look at some different types of data structures in this tutorial so the first type is the linear data structure the elements in the linear data structure are arranged subsequently one after the other they are simple to implement because the elements are arranged in specific order followed by the first type the second type is the non-linear data structure which we will be discussing a bit later so in linear data structures we have four different types the first one is the array data structure memory elements are arranged in a continuous order in arrays and arrays elements are of same type the software program also determines the type of elements that can be stored in arrays so followed by arrays we have linked list link lists are completely similar to data structures data elements in linked list data structure are linked together by a series of nodes furthermore each node contains the data items as well as the address to the next node the third data structure is the stack data structure elements in a stack data structure are stored using lifo principle in other words the last element stored in the stack is remote first in stack operations can only be performed in one end namely the top and the last data structure is the queue data structure unlike stack queue data structure operates in the fifo principle which states that the first element stored in the queue is remote first in a queue insertion and deletion are carried out from opposite ends now we will discuss the second type of data structures which are the non-linear data structures the non-linear data structure is the second type of data structure non-linear data structures do not have elements in any order as opposed to the linear data structures instead they are arranged in hierarchical order with one element connected to one or more others so the first one in the non-linear data structures is the tree data structure a tree data structure is built using nodes and edges each element in the tree data structure is called as node or vertex each vertex or node is connected to the other nodes or other vertices using edges and the second one in the list is the graph data structure a graph data structure is completely like a tree data structure it also has the vertices and edges each vertex in a graph data structure is connected using edges the only difference between a tree and graph is that in tree you can have n number of vertices but in graph you will have only two vertices after discussing the graph data structure we will move ahead into the last segment of this tutorial that has importance of data structures so the first one data structures are widely used in almost every aspect of computer science both for simple and complex computations next data structures are used in all areas of computer science including artificial intelligence graphics big data operating systems and much more after that the data structures are an essential component of many computer algorithms because they allow programmers to manage data efficiently lastly a proper data structure of selection can improve the efficiency of a computer program or algorithm there are various programming languages that you can learn to help your code data structures we will discuss c language c plus python and java let's discuss them in detail first up c language is a general purpose structure programming language c language can be used to develop programs like operating systems compilers databases and so on c language has a vast library that contains numerous built-in functions next up c plus plus language c plus plus is also a general purpose programming language c plus plus supports seven styles of programming like functional structural and object oriented programming is also used in creating operating systems browsers and games etc next up python programming python is the most significant programming language because the syntax of python programming can be easy to understand to every learner's level and this programming language is also loaded with the full of libraries that helps in implementing scientific computing working and deployment of python are supportive and easy in any environment finally java programming language in this modern era java is the best language to choose nearly thousands of applications softwares and development tools are built using the java programming language the technology is primarily used in creating websites such as youtube google amazon flipkart and many more moving forward now that you have a better understanding of which programming languages you would like to code with let's understand what are the prerequisites you need to learn to get started with the data structures and algorithms first up basic syntax before you start writing any code you need to have basic syntax on your tips or you may run into various errors next up data types if you want to make your code perform various operations and you will need to understand data types and their syntax next up operators variables and functions these are the elements that makes a code functional or operational the data types are essential in declaring them next up conditional statements or loops let's say if we want to print only a specific part of the information when certain conditions are met then we can write conditional statements if else if we were going to print a lot of elements like all natural numbers from 1 to 100 with a bit of code then we can write some loops like for loop or while loop then we will discuss object oriented programming object oriented programming or oops is built around objects which are data structures that contains both data and the code next up we will discuss data structures we will start with arrays linked list stack queues trees graphs and heaps now let's have a closer look at them first up arrays an array is collection of elements stored in consecutive memories an array is the most basic data structures the majority of data structure and algorithms can be implemented with the help of arrays next up is linked list a linked list is the linear data structures made of nodes these nodes are made up of two parts data and the address to the next node linked lists are easier to work with and they are faster at insertion and deletion next up stacks stack is a linear data structure that follows a particular order from which the operations are performed we can perform insertion and deletion only from the top this is also why stacks are called lasting first out or lifo based data structures in stack insertion is referred to as push operation and deletion as pop operation next up queues queues is also and abstract data structures but unlike stakes a queue is open at both its end one end is used for insertion also referred to as nq and the other is used for deletion also known as dq this is why the queue is regarded as first in first out or fifo based data structure following trees a tree is a hierarchical data structure made up of nodes the first node of the tree or the node which has no parents is called root node else all of the other nodes can have a maximum of one parent and can have multiple childrens each node contains some data and links to its children's next up graph a graph is a non-linear data structure consists of nodes and edges the nodes are sometimes also referred to as vertices and the edges are lines and arcs that connects any of the two nodes graphs are often used to represent networks finally heap a heap is a special case of trees heap is a complete binary that is it can have maximum of two children and all level except for the last level should be filled a he is of two types max heap and min heap when every node has a value greater than its parent then the heap is called max heat and when every node in a heap has less value than its parent then that the is called minha now that you have firm grasp of basic coding and data structures we will discuss some algorithms we will first discuss searching and sorting after that we will discuss divide and conquer then greedy algorithm dynamic programming and backtracking let's discuss them in detail first up searching searching algorithms are intended to search and retrieve an element from any data structure in which it is stored next a sorting algorithm is used to rearrange the elements of an array or list based on the comparison operator on the element efficient sorting is critical for enhancing the efficiency of other algorithm that needs input to be sorted list next up divide and conquer this algorithm requires to divide the whole problem into sub problems and solve them and then combine them back to get a complete solution some algorithms follow this approach like quick sort merge sort and stances algorithm divide and conquer requires that there must be more than two sub-problems next is greedy approach the greedy algorithm aims to build up a solution by selecting the most beneficial option greedy is best suited to problems when picking locally optimal also leads to a global solution the greedy can also be used to solve huffman coding job sequencing and knapsack problems next up dynamic programming a dynamic programming technique that produces smaller sub problems and then uses the sub problem solutions to solve the more significant problem dynamic programming is nothing but optimization of recursion problems simple optimization can change the time complexity from exponential to polynomial next up backtracking backtracking is an algorithmic approach to recursively solving problems by attempting to develop a solution progressively one piece at a time then discarding any solution that do not fulfill the problems criteria at any point in time backtracking is also used to solve problems like end queens sudoku hamiltonian cycle etc we have now discussed both data structures and algorithms now let's have a look at top coding contests or platforms to hone your skills we will start with hacker rank then code beta geeks coding challenge code jam and at last code chef let's discuss them in detail first up hacker rank hacker rank is a technology hiring platform that is standard for assessing developer skills hacker rank organizes various contacts like aha rank hack fest and hack the interview next up code vita code vita is coding platform where one can compete against people from all over the globe for the world's best quarter title data constituency services or tcs organizes code beta winners usually win prices like cash prizes or free vouchers it also opens up a door for career opportunities for its learners next up geek coding challenge key coding challenge is a three-day event organized by geeksforgeeks in gcc learners can participate and challenge themselves in solving coding problems to win prizes next up code jam code jam is a google hosted and managed international programming competition the competition consists of collection of algorithing tasks that must be completed within a specific time limit at last court chef court chef is a website that aims to assist programmers in succeeding in algorithms computer programming and programming competitions code chef often organizes various contexts like cook-offs and lunch time we have now discussed various coding platforms or competitions to hone your skills first up let's say if you can't solve a problem in under an hour you should put it aside for the time being and move on you can always return to it at a later time next up even if you answer the question correctly i recommend that you read the discussion and look at other solutions you could come up with a better way to answer that question finally if you are having trouble understanding a solution then i recommend you to dry run of the code introduction to time complexity the time complexity of an algorithm is the amount of time it takes to run as a function of the length of that input the length of the input determines how many operation the algorithm will do it will provide the information about the variance increase or decrease in execution time as the number of operations in an algorithm increases or decreases next up types of time complexity we will start with the constant time complexity then we will discuss linear logarithmic quadratic time complexity now let's have a look at them in the detail first constant time complexity when an algorithm is not reliant on the input size n it is set to have constant time of order bigger of 1. the runtime will always be the same regardless of the input as you can see in the code every line has the runtime of 1 and they are all independent of any input size so the runtime is always constant next up linear time complexity when an algorithm's running time increases linearly with the length of an input it is said to have linear time complexity when a function checks all the values in an input data set it is said to have the time complexity of order of big of n as you can see in the code the loop depends on the size n so the time complexity rows up to n next up logarithmic time complexity when an algorithm lowers the input data in each step then it is said to have the logarithmic time complexity binary trees or binary search functions are some of the algorithms with logarithmic time complexity as you can see in this code by finding out the mid in every iteration the run time will decrease every step making it approximately logarithmic runtime next up quadratic time complexity when the execution time of algorithm rises non-linearly up to n square with the length of the input it is said to have quadratic time complexity in general net nested loops falls into the quadratic time complexity order where one loop takes big o of n and if the function contains the loop inside the loop then it multiplies as you can see in this code because of the nested loops the time complexity rose to n square now that you have the firm grasp of time complexity and its type we will discuss essential steps to evaluate the time complexity to understand this we will take an example of fibonacci number this code prints the fibonacci numbers till n we will divide this code into three parts isolating all the loops that play a significant role in altering the time complexity let's look at the first part it consists of some independent statement which give constraint run time for each statement next let's move it on to our next part that is for loop since this loop runs n times this will give linear time complexity on n next up the third part which also has the constant time complexity now let's take a total of runtime which comes out to be n plus 5 we will then discard the constant part to find the time complexity which does not affect the overall time complexity now we will have the final time complexity of bigger of n we have now discussed time complexity and how to evaluate it now let's have a look at the time complexity of various algorithm we will look at the time complexity of insertion sort merge sort quick sort bubble sort and some searching algorithms like linear search and binary search let's look at them in the detail first up insertion sort as you can see in this code we are using nested loops so in worst case its complexity comes out to be n square now in the best case scenario the complexity will be linear time complexity next up merge sort in this case whether it is the worst case or the best case it will always remain and login as every statement in this code will run the same amount so no matter what its time complexity will remain the same next up quick sort the time complexity of quick sort in the best case is n login and and in the worst case it is n square next up bubble sort as you can see in this code we are using nested loops so in the worst case its complexity comes out to be n square now in the best case scenario the time complexity will become the linear time complexity that is n and after that we will discuss some of the searching algorithms first up linear search in the best case scenario if the statement to be searched is at the first position then the time complexity will come out to be constant whereas in the worst case the time complexity will come out to be n finally binary search in the best case scenario if the element is to be searched is at the mid then the time complexity will come out to be the constant whereas in the first case scenario the time complexity will come out to be big of log n we have now discussed the time complexity and how to evaluate and the time complexity of various algorithm now let's sum up what we have learned from this session first up the execution time increases with the types of operations we make using the inputs next up the lesser the time complexity the faster is the execution finally if a code is of hundreds of lines then it takes a toll on the pc's processor so it is essential to check and reduce the time complexity as much as we can let's get started with what are pointers a pointer is a variable that points to an address of another variable it is declared using a star symbol also called asterisk and then we allocate a memory of a variable to it we can access a variable's address using the ampersand symbol in the same manner as the pointer declaration let's write a code we will declare a variable a is 5 and a pointer ptr then we will assign this variable a's value to pointer ptr now let's write a print statement to directly access the variables value using variable name let's write another print statement to print the value of a using pointer let's try and execute this program as you can see we have successfully accessed variables value using both variable name and pointers let's get back to our slides now let's discuss different types of pointers first up null pointer void pointer while pointer and dangling pointer let's discuss these in details first up null pointer it is a kind of pointer that points to a null memory as you can see in the figure here is a pointer which is pointing to a null memory to get a better understanding let's try a simple program in the code editor let's write a code first we will declare a pointer where and we will assign its value to null now let's try to print the statement let's execute this as you can see since this pointer points to another or nothing that's why it doesn't print anything let's get back to our slides next void pointer when a pointer is created with data type void then this pointer is called void pointer if we want to print the variable's value then we have to typecast this pointer to avoid any error for better understanding let's get back to the code editor and try it with a simple code first we will declare an integer variable a is equals to 5. and avoid pointer ptr now we will assign address of a to pointer ptr let's write a print statement to print this pointer let's run this program as you can see we are getting an error that's because we can't print a void variable in this we have to typecast this variable to integer let's do this we can typecast a variable like this now let's print this as you can see we can print it now let's get back to our slides next while pointer when we create a pointer but don't initialize it by assigning any memory to it then this kind of pointer is called while pointer these pointers can be very tricky they can even cause a program failure or a segmentation fault let's get back to the correlator and try it with a simple code first let's declare a pointer ptr but they will not assign it with any address let's write a print statement to print it this time we will directly print it let's execute this as you can see we are not getting any results because there is no value assigned to it sometimes it may even show segmentation error let's get back to our slides next dangling pointer let's suppose there is a pointer p which is pointing at a variable now if we delocate this memory using a free function then this pointer will point at a free space or a non-existing memory then this pointer will become a dangling pointer to get a better understanding of this pointer let's try it with a simple code let's declare a pointer ptr here we will dynamically allocate memory using a mail of function to do this we will put int star in a bracket then dialog function and in another bracket we will put memory size to be allocated now let's declare a variable a and assign its address to the pointer now to make it a dangling pointer we have to diallocate the memory of this pointer we will use free function for that now let's write a print statement to print this pointer let's execute it as you can see since we have diallocated its memory that's why it is pointing to nothing hence it doesn't print anything let's get back to our slides till now we have discussed pointers ways to access variables and types of pointers now let's talk about use cases of pointers we will talk about point arithmetics pointer to pointer array of pointers call by value and call by reference now let's dive right into it let's talk about point to arithmetics we can use four arithmetic operations on pointers increment decrement addition or subtraction of an integer from a pointer since pointer operates on addresses it only makes sense if we apply pointer arithmetics on sequential data structures like arrays or strings let's discuss them in detail first up increment if we apply this operator on a pointer then it will shift this pointer's address to its sequential successor as you can see in the figure as we increment the pointer's value we shift to the next index of the array let's get back to the code editor and try it with a simple program let's declare an array of size 3. let's give them some value we will then declare a pointer and assign it to the arrays first element now let's write a for loop to traverse this array in this for loop we will increment a pointer's value and print this pointer's value to traverse this array let's try and execute this program as you can see we have traversed this complete error let's get back to our slides next decrement if this operator is applied on a pointer it will shift this pointer's address to its sequential predecessor as you can see in the figure as we decrement this pointer we also shift to erase previous index let's get back to the code editor and try to implement it let's declare an array of size 3. and assign it some values now let's declare a pointer and assign arrays last elements address to it now let's write a for loop to traverse this array in this for loop we will decrement the pointer's value also we will keep printing this pointers value to travel this array let's try and execute this program as you can see we have traversed this complete array from the back let's get back to our slides next the addition of an integer to a pointer if this operator is applied on a pointer it will leak forward accordingly if the integer is 2 and our pointer points at the first element then the pointer will sequentially skip one element and shift to the next element let's implement it in the code editor let's declare an array of size 7 and assign them some value then declare a pointer and assign it to the arrays first element now let's take an integer n to add in the pointer now let's write a for loop to traverse this array in this for loop we will increment the pointer's value with integer n and we will keep printing the pointer ptr value let's execute this code as you can see we have traversed this complete array skipping one element at a time since we have skipped three elements that's why we are getting last three values as garbage values let's get back to our slides next subtraction of an integer from a pointer if this operator is applied on a pointer then accordingly it will leap backward if the integer is 2 and our pointer points at the last element then the pointer will skip one element and shift to the previous element let's try and implement it in the code editor first let's declare an array of size 7. and assign it some values and declare a pointer ptr and assign it to the array's last element now let's take an integer n to subtract from the pointer now let's write a for loop to traverse this array in this for loop we will decrement the pointer's value with integer n also we will write and print statement to print this pdr's value now let's try and execute this program as you can see we have traversed this complete array from back skipping one element at a time since we have skipped three elements that's why we are getting last three values as garbage values let's get back to our slides let's talk about precedence of these operators operator asterisk and ampersand have the same priority as the unary operator increment and degreement these operators are evaluated from right to left let's understand this concept with an example suppose if a pointer p points to a variable x then we can swap x with pointer p in that expression in the first row we have y is equal to x plus 1 which means we are storing an incremented value of x in y similarly if we replace x with a pointer p we can store incremented value of pointer in y in row 2 and row 3 we are incrementing x and storing incremented value in x itself we can do this with pointers as well in row 4 we are attempting to execute pre-increment with a pointer p in row 5 we are attempting to execute post increment with pointer p here we have to put star p in braces because these operators are evaluated from right to left so to give more priority to pointer p we have to use braces as they have highest priority let's talk about another use case pointer to pointer basically in this situation a pointer will point at a variable via another pointer we declare it with two statistic symbol let's discuss it with an example suppose a pointer 1 points to a variable and another pointer 2 points to that pointer 1. this way pointer 2 will indirectly be pointing to the variable let's go to the code editor and try implementing it first we will declare a variable where a pointer ptr1 and a pointer to this pointer ptr2 then we will assign this variable vars address to ptr1 and ptr1s address to ptr2 now we will write a print statement to print variable var ptr1 and ptr2 now let's try and execute this program as you can see ptr1 and ptr2 shows variable vars value as ptr2 is pointing to ptr1 and ptr1 is pointing to that variable so indirectly ptr2 points to the variable var thus it prints the variables value let's get back to our slides let's discuss the array of pointers as the name suggests it is an array that has all its elements as pointers these pointers can be pointing at another array it is declared as an array with asterisk symbol let's discuss it with the program first we will declare an array a of size 3. then we will declare a pointer array ptr of size 3. now we will write a for loop to assign a's elements address to ptr's element then we will write another for loop to traverse ptr and print its element let's try and execute this program as you can see it prints the value of arraya's elements because array ptr's elements are pointing to arrays elements let's get back to our slides next call by value we don't use pointers in this concept but it is very important to understand this concept to get better understanding of the next topic call by reference in call by value we call a function and directly pass the variables value as parameters in this situation a copy of those variable is created and get passed into a function as parameters if we modify these parameters it will not affect actual variables rather these copies will get deleted as soon as the function body ends let's try implementing it in the code editor let's write a code first we will declare a variable x equals to hundred then we will write a function called to function func with argument x next we will write a print statement to check if any changes happen due to the function now let's write definition for this function we will take a void function with argument as x in this first we will set x equals to 200. and then we will write a print statement to print this value let's try and execute this program as you can see here when we get back to the main block from function its value again reverted back to 10 because in call by value program we only pass variables copy into the function not the actual variables let's get back to our slides next call by reference in this if we call a function but this time we pass the variables address as parameters then in this situation actual variables will get passed into the function as parameters if we modify these parameters it will modify the actual variables even outside the function scope let's try implementing it in the code editor first we will declare a variable int x equals to 100 next we will write a function call for function func with argument as address of x then we will write a print statement to check if any changes happen due to the function now let's write definition for this function it will be a void function with argument as pointer x in this we will first set x equals to 200 then we will write a print statement to print this value of x now let's try and execute this program as you can see this time variable access value didn't revert to hundred that's because in call by reference we pass actual variables address two functions so it will modify them as well let's get back to our slides during the course of this video we have learned a lot about pointers let's discuss some advantages of the pointers first up pointers are useful to access a memory location pointers are also an effective way to access the array elements pointers are used for the dynamic memory allocation and its distribution pointers are also used to build complex data structures like linked list graph tree stack queue etc now let's talk about some disadvantages as well first up pointers are difficult to understand so a programmer needs to be careful while handling them they might raise some errors like segmentation error or access some unrequited memory and course program failure if a pointer is pointing to an incorrect value then it might corrupt memory pointers may also cause memory leakage also pointers are slower than variables so to understand this let's go through a simple concept let us imagine that we have some data and the data is related to students right so if we wanted to store the marks of individual students then we had to declare a variable for each of the student so you can see we have student 1 student 2 student 3 4 and 5 and their individual scores so the score 1 is assigned to student 1 and so on with student 5 being assigned to score 5. so in the real time this might be a little clumsy we have here just 5 students so that is ok but what if we had 500 students or 5 000 students right that might be an issue there we have to create some 500 or 5 000 variables and it would be a little tough to handle that right even if we wanted to apply some operations collectively on all the variables that might be a little tedious so what if we had one variable which could store all the five students or 500 students or 5 000 students all together and make it really easy for us to apply some operations collectively on all the students right this sounds a little bit logical so similarly we do have a data structure which can do that which can collectively store all the data elements in it as a single variable and it will also help us to apply the operations which are logical or mathematical on all the variables and their values together as a whole so that is the purpose why we had created arrays that is the purpose why we needed arrays so far we have understood what was the necessity for arrays now we will understand what exactly are arrays so basically an array is a linear data structure that stores the elements in a sequential manner one after the other and when you declare an array the variables will be stored one besides the other that is adjacent to each other in a sequential order now let us understand how the array is represented by the compiler now the next part that is the memory representation of aries now let us imagine that we have declared an array which stores character type data and another important point to remember about r is when you declare an array it stores only a single data type typed elements only for example here we have declared a character type array right so we cannot store integer type data or flow type data in it we only have to save character type array or character type elements in this particular array so now let us imagine that we have created an array which is of character data type and these are the elements which are a r r a y now how does the compiler represent it in the form of memory so when you create an array these are formed that is the index values and the address so basically compiler will select a block of memory and it has addresses to that block and it can be anything right here we have 11 12 13 14 and 15 and in real time it might be a thousand one thousand two thousand three thousand four thousand five the main motto is assign a sequential block of memory and this is the array and the elements are a r r a y and this particular one which is the last one is the index of the array that is the position of the array for user so using this index you can access the elements in the array more on that in the accessing part so let us imagine that we wanted to access the element r so how to access it we might not know the address right in that instance we will use the index this is for our reference so we will tell i want the element from array index number 2 and then we'll have the ar r element so in the practical form this is how we use the index now let's continue with the lower bound and the upper bound so the first initial location is called as the lower bound and at the last or the max value of the array is called as the upper bound now let us jump into the next topic where we will understand the different types of arrays so these are the different types of arrays one dimensional arrays and multi-dimensional arrays in multi-dimensional arrays we have two more types that is two-dimensional arrays and three-dimensional arrays so how are arrays different from each other right so the first one will deal with the first one that is the one dimensional array now how is an array declared as one dimensional for that we need subscript so one dimensional array requires only one subscript to specify the number of elements in an array so how is it actually represented so here you can see an example right on my screen so here is how a one-dimensional array looks like so here we have the data type that is integer data type and marks is the name of the array and this is the size of the array and here the elements will be stored and here it is the index value of the array and remember the index value of array always starts from zero in the previous example that was only for basic understanding so i just started that with one in the practical way the array index always starts from zero so followed by the one dimensional array we will deal with the multi-dimensional arrays in that we have the following the first one is the two-dimensional array and the second one is the three-dimensional array in the multi-dimensional arrays we require more than one subscript in the previous example we had one dimensional array so the subscript is just 1 that is 10 columns right so we just had one single row and 10 different columns but in the multi-dimensional arrays we need multiple rows and multiple columns right so we need two subscripts for two dimensional array and more than two subscripts for three dimensional arrays so first we have the two dimensional arrays the 2d array is organized in the form of a matrix which can be represented as a collection of rows and columns so here is the example as you can see on my screen we have three columns and three rows and we have two subscripts that define the number of rows and the number of columns and the elements in each and every row so the one two three confines the first row four five six confines the second row and seven eight nine will be the third row now similarly we have three dimensional arrays a 3d array is a collection of 2d arrays which consists of three subscripts block size row size and column size so here we have an example for that so we have three subscripts that is the first one is block size the second one is the row number and the third one is column number so this happens to be the first block this happens to be the second block and this is how a three-dimensional array can be represented now we have the next stage where we will understand how to declare the arrays and the syntax is right on my screen you need to specify the data type of the array which is integer float or character any selection which you make followed by that you need to select an array name for your array and inside that you need to declare the array size and sometimes you can also eliminate the array size if you wanted to you know have a dynamic array and here is an example for that you have integer data type name of the array is example and the array size is 6. so the compiler will allocate continuous memory block of six integer type blocks so these are the few more methods to initialize the array so here you can see integer data type array name is a element size is 5 and we have 5 elements the method 2 is remember i have said you can eliminate the size of the array right so here you can use this way as well integer data type array name a and no size here and you can directly declare the elements and the method third so here you have the name of the array size of the array and you are allocating the elements to the individual memory locations there is also another method to initialize array and method 4 is using a forum you can just initialize a for loop and the i value will be stored in the array locations starting from 0. now let us understand how to access the elements in an array so to access the elements in an array you need to specify the name of the array and memory block where you have that element that you want to access so here we have an example which is integer data type name of the array is x y z and the element we wanted to access as 5 so here we have an example that is integer type array iron name is xyz and it has the size 5 and now we wanted to access the first element in an array that can be done using the first index that is xyz of 0 index that is the first element and accessing the second element and so on x y z talking one will be the second element x y set of two three four will be the third and fourth and fifth elements now let us understand some basic operations that can be performed on the array elements so the following are the operations that can be performed on the array elements that is the traversal insertion deletion searching and sorting now let us get into practical mode and try to execute some examples based on traversal of the array insertion of an element into the array deletion of an element from an array searching for an element in an array and sorting the complete array so at first we'll carry out the traversal operation so here we have an array that is a of 5 and the elements are 1 2 3 4 and 5. now we're going to use a for loop to traverse through this array and print all the elements sequentially now let us execute this code and see the output so as you can see the code got successfully executed and the elements that is 1 2 3 4 and 5 from the array a are printed sequentially now moving ahead we'll try to execute some examples based on insertion of element into the array so on my screen you can see an example for inserting an element into the array at the starting position of the array now let us try to execute this code and see the output don't worry about the codes these code documents will be attached in the description box below and you will be able to have an access to it and run these codes in your personal laptop and get a better learning experience now you can see the code got successfully executed and now it is asking for the size of the array let's declare it as 5 and now let's enter the elements into the array now it is asking for the element to be added at the beginning of the array now we have 2 3 4 5 and 6 existing in the array let's add the first element one and there you go the resultant array is one two three four five and six the element which we added at the ending which is one is supposed to be in the first or the beginning part of the array which is here at at the first index location as planned now let's get started with another example on the insertion now let's try to insert an element at any given location as per the user's choice so as you can see we have a program on my screen and running this program must help us to insert an element into any given location of the array now let's try to quickly run this program and see the output so there you go enter the elements into the array let's enter 1 3 let's try to run this program and see the output so there you go the program got successfully executed and now the output is asking for us to tell it the number of elements in an array now let's say four elements so now let's enter the four elements one three four five and 6 okay so the four elements which is 1 3 4 5 are been inserted now it is asking for the location where you want to insert the element now let us insert it in the second location now let us set the value as 2 and there you go the resultant array is 1 2 3 4 and 5 and the element which is 2 was supposed to be added in the second location and it has been successfully added now let's try to execute another example based on insertion where you will try to insert the element in the last position now this program on my screen will help us to add an element at the end of the array let's quickly run this program now it is asking for us to enter the five elements of the array let's enter that now it is asking to enter the element to be inserted now let us enter the element and this element should be added at the end location as discussed the resultant array is 1 3 5 7 9 and 11. now let's continue with the deletion operation now the program on my screen is an example for deleting an element from the beginning position of an array now the program got successfully executed and it's asking for us to enter the size of the array let's enter the size as five and now let's enter the elements of the array that is one two three four and five now the element from the first location that is one has been deleted and the resultant array is 2 3 4 and 5. now the code on my screen will help you to eliminate the element from the ending location of an array now let's try to quickly run this program and say the object so you can see that the program is successfully run and it is asking for us to enter the size of the array let's enter 4. now let's enter the elements of the array that is 1 2 3 and 4. now after eliminating the last element from the array that is 4 we have the resultant array that is 1 2 and 3. now a little hover for you guys let's try to execute an example for deleting an element from any location of an array this will be a homework now don't worry try on your own and if you don't get that you can refer to the comment sections below where you have the code document attached in the description box and you can refer to it now let's continue with the next operation where we will search for a given element in the array so you can see that on my screen we have an example which will help us to sort the elements in an array let's quickly run this so there you go the program got successfully executed and now it's asking for the array size let's enter five and now let's enter the elements in a random order [Music] now the resultant array should be sorted so there you go the array after being sort is it's 2 3 5 14 and 21 so there you go the array got sorted so now we have finished our practical session let's have a quick overview again so traversal in an area is a process of visiting each element once traversal can be done by various means that is by counting the array elements printing the values sorted in the arrays and sum of all elements present in the array and many more so this is how we traverse our array from the first location to the last location again the insertion operation insertion in an array is a process of including one or more elements in an array and it can be done at the beginning at the end and at any given index of an array which we executed for all the three types of examples now next we have the deletion operation so deletion operation or deletion of an element is a process of removing a desired element and reorganizing the array and it can be done at the beginning at the end and at any given index so we have executed the example for at the beginning and at the end and the homework was at the given index don't worry if you don't figure it out you can always refer to the example document which is mentioned in the description box below now the search operation searching is a process of finding a given value in the list of values and it decides whether the search key is present in the array or not and we have executed an example on that and again the sort operation where we will sort the given array if the given array is not in the default order or in a given order that is ascending or descending then we can sort the order of the array by the user's choice given it is ascending order or descending order now in the next section of the tutorial we will discuss the advantages of using arrays so the first one is array stores multiple elements of same data type with same name next one elements in an array can be accessed randomly using just the index number array memory is predefined so there is no extra memory loss array avoids memory overflow and finally 2d arrays can represent the tabular form of data in a very efficient way now let us also have a look on some of the disadvantages of using arrays the first one the number of elements in an array should be always predefined so there is no chance that you can add some extra element in the last moment array is static in nature so its size cannot be varied after declaration what if consider that you wanted to store 10 student data in one array and you end up having just seven students so the remaining three is a waste right so you are wasting memory there that's the problem and insertion and deletion operations in an array is quite difficult as the array stores elements in a continuous form and finally allocating excess memory then required mainly to memory wastage now we have the final key takeaways of the arrays so we discussed why do we need arrays then we discussed what are arrays followed by that we discussed types of arrays next we had a declaration of arrays accessing elements from an array initializing the arrays and basic operations on ira that is the practical demo part and finally we have discussed the advantages and disadvantages of using an array so we will see a brief definition of arrays the array is a data structure that stores elements of the same data type in a sequential order two dimensional arrays are considered as an array of arrays two dimensional arrays represent the information in the form of rows and columns which is completely similar to a tabular form of data following by the definition and briefing of the two dimensional arrays we will understand the need for two dimensional arrays so the main advantage of using a two-dimensional array is the elements can be represented in the form of a matrix that is rows and columns using two-dimensional arrays we can initialize access and print multiple elements in the matrix form by just running one single code segment you can see an example right on my screen here this is an example of marks list suppose a class has three subjects namely english science and maths we have four students and we wanted to represent the data in the form of a database so here the marks of the four students can be represented using two dimensional arrays now we will see the syntax of a two dimensional array so here the syntax at first we need the data type the data type can be integer character float string etc then we have the name for the two-dimensional array and later we can have two subscripts which represent two dimensions that is the rows and columns the first subscript defines the number of rows and the second subscript defines the number of columns and note that the column number can never be null and the end we have a semicolon to terminate the syntax and here we have some examples of two dimensional arrays so in the first example we have the name of the two dimensional array and we have three rows and four columns and followed by that we have another example which is of character data type and the name of the array is names and we have 7 rows and 15 columns next we will see how to visualize two dimensional arrays we read earlier that two-dimensional arrays are a collection of rows and columns let's see an example of two-dimensional array we will consider an array with six rows and four columns as you can see on my screen we have integer type array and the name of the array is array and we have six rows and four columns the product of rows and columns will give us the total number of elements present in a two dimensional array in the current example we have six rows and four columns and the product is 24 so we must have 24 elements in this array next we will see how to initialize two dimensional arrays so there are two ways to initialize a two-dimensional array so in the first method we declare the elements in the set of curly brackets this array consists of three rows and three columns note that the index always starts from zero here we have three rows it means the row starts with zero and ends with 2 the same goes for the column but sometimes this method might be a little confusing so we have a better method the advantage of this method is clarity we can visualize all the elements with better clarity compared to the previous method so the first three elements are 9 6 and 1. they are present in the first row and in the second row we have 144 70 and 50 they comprise the second row and finally the third row in which the elements are 10 12 and 78 so far we have learned how to visualize and initialize a two-dimensional array so we have done it by using the index values that is the row index and the column index so the row index value was three and the column index value was three for accessing an element in the two-dimensional array we need to pass the name of the two dimensional array followed by the row index value and the column index value for example let us assume that we wanted to access the element 9 for doing so we will pass the name of the array followed by the row index value and the column index value as shown below that is int first zero comma zero and an important point here is indexing always starts with zero we will now start printing the two dimensional arrays so to print a two-dimensional array we will be using two nested for loops so to understand the process of printing the two-dimensional array let's get back to the practical mode and we will work on a code so on my screen you can see an example for two dimensional array so here we have declared an array with the name first and we have three rows and three columns and inside that the first row of elements is 961 and the second row of elements is 144 70 and 50 and the third row of elements is 10 12 and 78 followed by that we have two counter variables which are i and j so we are using the first counter variable i in the order for loop and the second counter variable j in the second inner form and inside the inner follow we have a print statement which is used to print the elements in the array now let us try to execute this code and see the output so you can see the code got successfully compiled and we have our elements here which is 961 144 70 50 10 12 and 78 now let us understand the logic so here we have declared the counter variable as 0 and the condition is i should be less than 3 which is true so the control will enter into the second inner for loop here we have j is equals to 0 and j should be less than 3 which is true so here the condition or the statement is valid and it will print the first element 9. followed by that j will be incremented again j is now equals to 1 and j is less than 3 so again we'll print the second element 6. again j value will be incremented to 2 so 2 is less than 3 then we will print the third element that is 1. now when you increment the value of j from 2 to 3 the condition will fail because 3 cannot be less than 3. so the control will enter into the outer follow here we have i value is equals to 0 which will be incremented to 1. so 1 is less than 3 again the control will enter the inner follow here again we will check for j is equals to 0 which is true so we will print the second row of elements that is 144 70 50 in the same way how we printed the first row right so j will be equals to 0 so then we'll print the first element so j will be incremented to 1 and 1 is less than 3 then we will print the second element that is 70 and again j will be incremented to 2 and 2 is less than 3 so we will print the third element that is 50 in the second row and again j will be incremented to 3 now the compilation of the condition will result in false so it will exit the second follow-up and but it will come back to the first outer for loop now the value of i will be incremented to 2 so 2 is less than 3 the control will enter into the inner for loop again then we will print the third row of elements that is 10 12 and 78 in the same way how we printed the first row and the second row after printing the third row the condition will fail when j value is incremented to 3 and it will enter the order for loop here the i value will be incremented again from 2 to 3 and the condition fails now the overall control will come out of both the for loops and it will terminate here so that's how we got 9 6 1 44 70 50 10 12 and 78 so with that we have come to the conclusion and so far we have learned the following things what are two dimensional arrays why we need two dimensional arrays syntax of 2d arrays visualizing 2d arrays initializing 2d arrays accessing 2d elements and finally print the elements of two dimensional arrays let's get started with what is linked list a linked list is a linear data structure made up of nodes these nodes consist of two parts data and reference to another pointer typically a linked list starts with a head node which goes all the way up to the last node which is called tail next let's discuss why do we need linked list a linked list is a linear data structure like arrays but an array can only offer a fixed size whereas a linked list can dynamically increase its size also operations like insertion and deletion are much easier in a linked list than in an array now let's try to implement the linked list in the code editor let's start by creating a node to create a node we need a class let's declare a class node we will declare its member as public the first member is end data and the second member is node pointer next now we will go into the main block and initialize our first node to initialize a node we need to use node star the node name had equals to similarly we will create more nodes do and our last node tail now we will allocate these four nodes in the heap to do that we will use a node name equals to new node star new node braces now we will allocate all the nodes in the same manner now we will assign data to our first node to access the member of the node class we will use error formation then we will use data equals to let's give it a value as 2 now we will link this first node with our second node to do that we will use head same error formation and next which will be equals to our n1 node and now we have created our first complete node now let's create other nodes as well n1 arrow data is equals to let's give it three and one arrow next is equals to n2 and to arrow data is equals to five and two arrow next to arrow next is equals to tail now tail is equal still arrow data equals to 7 and tail arrow next is given null now let's call up function to print this list we will give head as the argument as we can only traverse a linked list from its head let's write a definition for this print list function this function will be a void function argument is note star a we will use while loop to traverse this linked list we will give its fit condition if a is not equals to null done c out is a data and l now we will change our cursor from the current node to the next node to do that we will use a is equals to a arrow next now let's try to execute this code as you can see we have traversed our complete linked list now let's get back to our slides now let's discuss different types of linked list the first are singular link list next is the doubly linked list the circular linked list and finally we have the circular doubly linked list let's discuss each one of these in details first up single linked list it is a unidirectional linked list while using the sinclair link list we can only traverse it in one direction that is from head node to the tail node next up doubly link list it is a bi-directional linked list we can traverse it in both the directions in this linked list the node has an additional pointer that points to the previous node next up circular linked list it is a regular linked list except for its last node points to the head node programmer needs to be careful while traversing it or they might get stuck in an infinite loop next up the circular doubly linked list it is a combination of doubly linked list and a circular linked list its last node points at the head node and the previous pointer of the head node points to the last node it is also bi-directional linked list so that we can traverse it in both directions we have now discussed the linked list why do we need linked lists and types of linked list now let's learn about some operation we can apply on linked list we can use majorly two operations on linked list first up insertion and deletion we can perform these operations in three different situations first at the beginning at the last or at a specific position after a node next we will discuss these operations in detail first up insertion we will discuss first insertion at the beginning we have to give the first nodes address to the new nodes next pointer to execute this next up insertion at the end we have to give the new nodes address your last node's reference pointer next up in session at a specific position to do this we will have to change the reference address of the previous node to the new node's address and the new node's reference pointer to the next node's address now let's discuss deletion first up deletion at the beginning we have to change the first node's address to the null to execute this next up deletion at the end we have to change the second last node's address to the null next up deletion at a specific position we will change the reference address of the previous node to the next node's address we have learnt a lot about linked list during this session now let's discuss some benefits of linked list first up a linked list is a dynamic data structure that is we can dynamically increase its size next it offers easy insertion and deletion then other linear data structures like arrays and string since it can dynamically increase its size resulting in no memory wastage next it is pretty handy in implementing complex data structures like stacks and queues etc now let's talk about some disadvantages as well first up since the linked list is made up of nodes it takes extra storage for storing data and reference pointer next the traverse cell in the linked list is a bit harder than other data structure reverse traversing is easy in doubly and circular doubly linked list but since it uses one extra pointer it takes extra storage making it another limitation let's get started with introduction to single link list a single linked list is a linear data structure made up of nodes these nodes consist of two parts data and reference to the another pointer nodes can be traversed using pointers it starts from the head node all the way up to tail node now let's try to implement the singly linked list in the code editor start by creating a node to create a node we need a class let's declare a class node we will declare its member as public the first member is end data and the second member is node pointer next now we will go into the main block and initialize our first node to initialize the node we need to use node star the node name had equals to similarly we will create more nodes and at last repeat and our last node tail now we will allocate these four nodes in the heap to do that we will use a node name equals to new node star new node braces now we will allocate all the nodes in the same manner now we will assign data to our first node to access the member of the node class we will use error formation then we will use data equals to let's give it a value as 2 now we will link this first node with our second node to do that we will use add same error formation and next which will be equals to our n1 node and now we have created our first complete node now let's create other nodes as well n1 arrow data is equals to let's give it three and one arrow next is equals to n2 and to arrow data is equals to 5 and 2 arrow next to arrow next is equals to tail now tail is equal still arrow data equals to 7 and tail arrow next is given null now let's call up function to print this list we will give head as the argument as we can only traverse a linked list from its head let's write a definition for this print list function this function will be a void function argument is node star a we will use while loop to traverse this linked list we will give it it condition if a is not equals to null then t out is a data and l now we will change now we will change our cursor from the current node to the next node to do that we will use a is equals to a arrow next now let's try to execute this code as you can see we have traversed our complete linked list now let's get back to our slides we have now introduced the singly linked list now let's discuss some of the operations we can apply on a linked list first up insertion we can perform insertion at three different situations like at the beginning at the last or at a specific position after a node next up deletion similar to the insertion we can perform it in three different situation as well at the beginning at the last or at a specific position after a node let's talk about them in detail first up insertion at the beginning to execute this we have to give first node's address to the new node's next pointer next up insertion at the end to execute this we have to give new nodes address to the last node's next address next up insertion at a specific position to execute this we will change the previous node's reference address to the new nodes address and the new node's reference pointer to the next node address now let's try these operations in a code editor as you know a linked list is made up of node so we should start by creating a node to create a node we need a class node and we will define its members as public print data and node pointer next now we will create a function to insert a new node in front of the list for this function as an argument we will give the reference to the head of the list and integer dot new data now in the definition we will allocate a node newnode equals to now we will put in the data in the new node we will use arrows to put to access the data equals to new now we will make the next of this new node as head now we will move the head to point to the new node now we will create another function to insert a node after a specific position as arguments we will give it the address to the previous node and the integer new data we will first check if the given previous node is null it is we will print given note and not and then we will return the function otherwise otherwise we will allocate a new node and then we will enter the new data in that now we will make the next of the new node as a next of the previous node and then we will move the next of the previous notes as new node now we will write a function to insert a node at the end of the list as an argument we will give it a node pointer to pointer and integer new data we will first allocate a new node we will also create a last node and give it now we will put in the data in the new node since this new node is going to be the last node so we will make its next as null now if the link list is empty then we'll make the new node as head to check that we will use if starhead is equals to equals to null if it is then we will do star head equals to new node else we will traverse it to the last node file last next not null last is equals to last next now we will change the next of the last node as new node now we will write a function to print this list bye node is not null out code arrow data and then and node equals to node now we will write the code for the main block first we will define a head node and mark it as null now we will start using those functions to make a linked list first we will use append function to add six in it next let's let's use another function push and add 7 in it now we will try to insert one at the beginning so we will use push again comma one now let's try to insert four at the end so far the list looks like one seven six four null now let's let's try to insert eight after seven to do that we will use insert after as argument we will use head next as 7 is present next to the head comma 8 now let's try to print this linked list see out created link yes and list let's execute this as you can see we have created the linked list in the correct order let's get back to our slides now let's talk about deletion first up deletion at the beginning to execute this we have to change first node's next address to null next up deletion at the end to execute this we have to change the second last node's address to the null next up deletion at the specific position we will change the previous node's reference address to the next node's address now let's try these operations in a code editor we will start by creating a class in this class we will declare the members as public print data and the node pointer next now to insert the data in the node we will use a function push as argument we will give pointer to pointer node header and integer new data we will allocate a new node we will give this new node the data as new data and and new nodes next as head now we will write a function to delete the node as argument we will give a node pointer to pointer head and end key now we will store head in a temp node and we will create a node prev as null if head node itself holds the key to be deleted we will use if amp is not equals to null and temp data is equal to equals to key then head equals to next now we will free the old node else we will search for the key to be deleted else while is not equals to and temp data is not key so prev equals to temp and temp will be hydrated to its next if the key is not present in the linked list then we will just return the function else we will unlink the node from the linked list and delete now we will write a printlist function to print the list its argument will be a node pointer node while a node is not null layout less than node data and we will iterate this node using node equals to node next now we will move on to the main block we will start with the empty list node star head equals to null now we will add the element to this list so push ampersand head comma seven next push head comma 2 push next push ampersand add comma 9. now see out created test and list add now we will use delete node function delete two we will use argument as ampersand head comma 2 now we will check the linked list 2. test let's try and execute this as you can see we have deleted the two from the linked list let's get started with an introduction to double a link list a w linked list is a linear data structure made up of nodes this linked list is a bi-directional linked list that is we can traverse it in both direction these nodes consist of three parts first up data reference to the next node and reference to the previous node now let's try to implement the wa link list in the code editor as you know a linked list is made up of nodes so we will start by creating a node to create a node we need a class node its members should be defined as public int data node pointer next and node pointer now we will write a function to insert a node at the beginning of the doubly linked list void push argument will be a node pointer to pointer add and end new data now let's allocate a node node star new node pulse new node now let's put in the data into the new node since we are adding at the beginning its previous is always null now we will link the old list of the new now we will change the previous of the head node to the new node we will check if head is not null then heads previous is equals to new node now let's move the head to the point to the new node now let's write a function to print the given delay limitless its argument will be a node we will iterate it until the node is not null layout node data and and node equals to node next now let's write a code for the main block we will start with the empty list now we will use a push function to push values in the function another push function add comma 3 push function ampersand add comma five push function head comma 7 now p out then we will call the print list function in the double linked list let's execute this program as you can see we have successfully created our first doubly linked list let's get back to our slides we have now introduced doubly linked list now let's discuss some of the operations we can perform on a doubly linked list we can perform three operations on a doubly linked list first traversal insertion and deletion we can perform a traversal in two ways a normal traversal and reverse traversal and we can perform insertion and deletion in three different situations at the beginning at the last and at a specific position after a node let's discuss these in detail first up normal traversal we can traverse a doubly linked list using a next pointer starting from head to all the way up to tail node reverse traversal similar to the normal traversal we will use previous pointer we will start from the tail node to go all the way up to head node now let's try to traverse the doubly linked list in the code editor let's start by creating a class node we'll define its members as public print data node pointer next and node pointer rev now we will write a function to insert a node at the beginning of the doubly linked list i push its argument will be a note pointer to pointer head and integer new data now we will allocate a node our new node new node parenthesis now we will put in the data since we are adding at the beginning so its pref is always null now we will link the old node to the new node now we will change the previous of the head node to the new node now we will move the head to the point to the new node now we will write a function to traverse the linked list normally voip traverse node pointer while loop mode is not null therefore keyout node data node equals to node next now we will write a function to reverse traverse it its argument will be a node pointer to pointer add we will create a node tail equals to add while is next is not null this loop is enabling us to reach to the tail node so that we can traverse it from back side now while loop until tail is not equals to head out in goes to tail prep data handle this last c out statement is only because we are not traversing till the head pointer now let's go to the main block let's start with an empty list note star add goes to null now let us create a linked list to test the function so we will use push function add comma 2 another push function ampersand head comma three push add comma 7 since we are inserting at the beginning so the actual link link list looks like 7 5 3 now we will print the original linked list first see how original traverse and reverse traversal first traversed linked list now let's try and execute this program as you can see we have traversed it in the normal way as well as the reversed way let's get back to our slides next up insertion at the beginning we will create a node with the previous pointer pointing to a null and the next pointer pointing to the head node then we will change the head node's previous pointer to the new node and we will change the new node to the head node next up insertion at the end we have to give the new node's address to the last node's next pointer and change the new node's previous pointer to the last node next up insertion at a specific position we will change the previous node's next pointer to the new node and the new node's previous pointer to the previous node and the next pointer to the next node and vice versa now let's try these operations in a code editor we will start by creating a class node public note pointer rev node pointer now we will write a function push set a note at the beginning of the list its argument is note pointer to pointer add into new data we will first allocate a new node node star new node plus new node parenthesis now we will put in the data node arrow data is equals to new data now we will make the next of the new node as head and previous as null and new node previous equals to null now we will change the previous of the head node to the new node first we will check if the head node is null then star head previous equals to new node now i will move the head to the point to the new node now let's write another function to insert a node after a specific position void insert after argument will be node pointer rev data if we first check if the given previous node is null yes then we will give it c out given node b and we will return to the function or else we will allocate a new node let's do new now we will put in the data now we will make the next of the new node as the next of the previous node equals to ref node now i will make the next of the prep node as new node and make the prev node as the previous of the new node now i will change the previous of the new node's next node if new node next new node next f is equals to new node now let's write another function insert a node at the end of the list void append argument will be a node pointer to pointer head and new data first we will allocate a new node equals to new parenthesis now we will create another node last to head now we will put in the data the node data first to new data now since this new node will be the last node so its next will be null yes and equals to equation null null and star head equals to new node return or else we will traverse till the last node i'll first next is not null last equals to last next now we will make the last node as the previous of the new node that now we will write a print list function to print this list argument is a note pointer node code is not null nope put data or is equals to node next now let's write the main block we will start with an empty list we will start by inserting 6 so the link list becomes 6 null and ampersand head six now we will insert 7 at the beginning push 10 percent head comma seven now we will insert one at the beginning also now we will insert four at the end till now the linked list looks like one seven six four now now we will insert eight after seven so insert after add text comma eight now let's print this linked list let's try and execute this as you can see we have created our linked list in the correct order let's get back to our slide next up deletion first up deletion at the beginning we have to change the first notes next to null and second nodes previous to null next up deletion at the end we have to change the second last node next pointer to null and delete the previous node to free up the space next up deletion at a specific position we will change the previous node's next pointer to the next node and next node's previous pointer to the previous node now let's try these operations in a code editor we will start by creating a class node click print data note pointer next put pointer f now we will write a function to delete a node in a doubly linked list void delete node its argument is pointer to the head repeat its argument as pointer to the head node pointer and pointer the node to be deleted now we will check the base case condition that is f add is or note to be deleted is null and return now if the node to be deleted is a head node then is equals to now if next node of the dell hot null that is if the node to be deleted is not the last node then else next abs equals to that's now we will change prev only if not to be related is not the first node so if then rev not equals to null then del rev next equals to del's next finally we will free the memory occupied by the dell free now let's write a function to insert a node at the beginning of the waylink list void counter to the head node pointer and enter new data we will allocate the node now we will put in the data since we are adding at the beginning so prep is always null now we will link the old list of the new node now we will change the preview of the head node to the new node now we will move the head to the point to the new node now let's write printlist function note pointer node file node is not equals to null payout code first to node next now let's get started with the main block we will start with the empty list now we will create new nodes push percent head comma 2 push ampersand add comma 4 push ampersand add comma 6 push percent head comma 8 now let's print this list original list then list now we will call the print list function header now we will delete the node from the doubly linked list here we are deleting the first node next let's delete the last node now the modified list should look like 4 8 let's try and print this see out defined list header let's try and execute this as you can see we have deleted all the nodes except for 6 and 4. let's get started with introduction to circular linked list a circular linked list is a linear data structure made up of nodes it is like a singly linked list except its last node points at the head node these nodes consist of two parts data and reference to next pointer these nodes can be traversed using the next pointer now let's try to implement it in the code editor we will start by creating nodes to create a node we need a class node we will define its members as public into data and node pointer next now let's write a function to insert a node at the beginning void push we will use arguments as a pointer to node pointer had and enter data we will define a node new node equals to new node parenthesis our head now we will put in the data into a new node since we are inserting at the beginning of the linked list that's why this new notes next should be the head pointer if linked list is not null then set the next of the last node as head file next is not equals to head damp is equals to temp arrow next now then next equals to new node else new node next is equals to new node r head equals to new node now let's write a function to print this linked list void print list node star head node star temp is equals to head if add is not equals to null then do see out data equals to temp next while amp is not equals to head this condition is important to stop this loop so that it doesn't go infinitely now let's go to the main block let's initialize this list as empty node star head equals to null now let's insert some nodes in this linked list push ampersand ampersand push ampersand head comma 11 head comma 5 now this linked list looks like 5 11 9 2 then it will again go back to 5. now let's try to print this c out circular list now let's try and execute this as you can see we have successfully created our first circular linked list let's get back to our slide we have now introduced the circular linked list now let's discuss some of the operations we can apply on a circular linked list we can perform two operations on a circular linked list first up insertion we can perform insertion at three different situation at the beginning at the last and at a specific position after a node next up deletion we can perform deletion at the three different situations first up at the beginning at the last and at a specific position after a node let's discuss these in detail first up insertion at the beginning we have to give the first nodes address to the new nodes next pointer to execute this next up insertion at the end we have to give new nodes address to the last node's reference pointer next up insertion at a specific position we will change the previous node's reference address to the new node's address and the new node's reference pointer to the next node's address now let's try these operations in a code editor so far we have implemented a linked list using classes now let's try to implement it using structures we will start by creating a struct node with its element as int data and struct node next now we will write a function which can only insert a node to an empty list struct node star add empty new data now since this function is only for the empty list so we will have to check if the link list is empty or not if last is not equals to null then we will return last now let's create a node dynamically struct node start temp equals to struct load star malloc size off we will copy this statement because we will need it in the future functions we will assign the data to this new node temp data is equals to neutral data last is equals to temp now we will create the link to that we will use last next is equals to last since we are in an empty list so the first node will always point to itself return start node start we are creating a function to insert at the beginning of the linked list struct node star add again as argument we will use struct node comma and data if last is equals to null then we will return empty last data now we will create a node dynamically i have already copied the statement for the ease now we will put in the data data is equals to data and next is equals to last next last text is equals to return last now we will write a function to insert a node at the end start node star add and and if last equals to equals to null then return add empty last comma data now we will dynamically create a node and put in the data data equals to data temp next is equals to last next now last next equals to temp and last equals to return now we will write a function to insert a node after a specific node so struct node star add after fast item this item is a node after which we have to insert the node if last equals request null then return struct node our temp comma star p p is equals to last next now do if those two item equals to we will dynamically create a node here temp is equals to struct node star lock size of struct now we will put in the data so temp data is equals to data temp next is equals to next a p next equals to temp if e is equals to last the last is equals to temp return next while p is not equals to last next item not present in the list return last now we will write a function to print this list void print list construct node star lost struct load starting now if last is equals to null then see out list is empty and return else we will point to the first node of the list so p is equals to last text to traverse the list we will use do while loop so do c out data is equals to p next while e is not equals to last text now let's write a code for the main block we will start with an empty list struct node star last close to none now last is equals to add empty last comma six last equals to add begin last comma 4. last equals to add begin last comma two last equals to add and last comma 12 last equals to add after last comma one comma four list let's execute this as you can see we have created the linked list in the correct order let's get back to our slides now let's talk about deletion first up deletion at the beginning we have to change the first node's address to the null to execute this next up deletion at the end we have to change the second last node's address to null to execute this next up deletion at a specific position we will change the previous node's reference address to the next node's address now let's try these operations in the code editor let's get started with creating a node to create a node we need a class node we will declare its members as public and data node pointer next now we will write a function to insert a node at the beginning of the list void push a pointer to the node pointer header and new data now let's create a node and make head as next of it star node equals to new node parenthesis let's put in the data new node data is equals to new data and new node next is equals to head if linked list is not null then set the next of the last node as the first node if star head is not null then they will find the node before head and update next to it so node star temp is equals to star head file next is not equals to head temp is equals to temp next temp next equals to new node else new node next is equals to new node and star head is equals to new node now let's write a function to delete a given node from the list so void delete node its argument is a pointer to the node pointer add and end key now if linked list is empty then we will simply return it if starhead is equal to null then return otherwise if header data is equals to key and add next equals to head then free add add is equals to null return now node last is equals to star head comma star d now if head is to be deleted then star head data is equal to key then while last next not equals to star head then last is equals to last next now we will point the last node to the second node of the list now we will free this head our head equals to last next now if either the node to be deleted is not found or the end of the list is not reached then file last next is not equals to head and last next data is not equal to key and last equals to last if note to be deleted was found then if last next data is equals to key then d is equals to last next and last next is equals to these next now we will free d or else c found now let's write a function to print this list void print list node star head node star temp equals to head if head not null see out is equals to next while temp is not equals to that see out now let's write a code for the main block we will start by empty list so node star head equals to null now we will push ampersand head push ampersand head comma five push ampersand header comma seven push ampersand head comma eight and push ampersand head comma 10 now we will print the list before any deletion operation see out list before deletion list head now let's delete add let's delete seven see out last after deletion print list let's execute this as you can see our deletion function is working perfectly in this particular session we will discuss the differences between the two major data structures that are the arrays and linked lists so at first what exactly is an array so an array is a linear data structure that stores homogeneous data elements in a continuous form so homogeneous in the sense you will be able to store only one single data type of elements in an array for example consider that you have declared an array and you wanted to store some elements in the array so you can declare a data type first after that the name of the array and if you declared that the array should store integer data type then you can only store integer elements in that particular data type you cannot store any other data type like float or character that is the meaning of this particular definition and it stores the elements in a continuous order that is in the adjacent format as you can see in the example here 10 20 30 40 and which are located in the adjacent locations that is 0 1 2 and 3. now let us understand what exactly is a linked list so similar to array even a linked list is a linear data structure but the only difference is it is a dynamic data structure here you can increase or decrease the size of the linked list in runtime the only difference is here the memory locations are not adjacent to each other but they are taken from the memory heap so there is a huge memory chunk out of that the linked list will borrow some of the memory locations and one after the other the memory nodes will be interconnected using pointers so that was the difference between array and linked list and similar to arrays even the linked list store homogeneous type of elements that is if you declare a linked list of float data type then you can only store float data type in it you cannot store any other different data type like character or string now followed by that let us understand the types of arrays so basically we have three different types of arrays those are the one-dimensional arrays and inside multi-dimensional arrays we find two more types those are the two dimensional arrays and three dimensional arrays now one dimensional arrays will be having only one subscript that is where they'll be having only one single row whereas in the two dimensional arrays we will be having two subscripts that is it will be having rows and columns and in the three dimensional arrays it will be having three subscripts that is the row column and the block address now followed by the types of arrays we will understand the types of linked lists so similar to arrays even linked lists are divided into three types they are singly linked list doubly linked list and circular linked list the difference between them is a singly linked list will have two parts that is the node address and node element in this particular segment the element will be stored and in this particular second segment the address that points to the next node will be saved and similarly in the circular linked list the only difference between the singly linked list and the circular linked list is at the end of this ingredient list we can see a null pointer which indicates the end of the linked list but in circular linked list the address will not be null instead it will point back to the head node that is what which makes it as a circular typed singly linked list or a circular linked list when it comes to the third type that is the doubly linked list we can see there are two address locations the first starting node will have null as its first address location then we'll store the element and the second address location will point to the next node and you can see in the second node will have element and the first address location will point to the previous node and the second address location will point to the next node and at the end the second address location will be pointed as null which indicates as the end of the linked list now that we know the types of linked list and arrays we will look into the fundamental differences between arrays and linked lists so the first fundamental differences between the arrays and linked list is the array element can be accessed randomly using just the index values but whereas random access is not possible in linked list if you want to access any element in linked list you need to perform the traverse operation sequentially the second difference between the both is array is static which means memory size is fixed which cannot be changed in runtime but whereas in the linked list the memory is dynamic which means you can either shrink or expand the memory in runtime according to your requirements followed by that the next difference is each element in array is independent in nature that is you can access any element just by giving the index location whereas in linked list the elements are interdependent on each other whenever you want to access a specific element you need to go through the other elements or traverse through the other elements next one is the array takes more time in operations like insertion and deletion whereas linked list takes less time to perform the operations of insertion and deletion followed by that the next difference is accessing any element is faster in array as random access is possible and the array data structure just by using its index values but whereas accessing an element in linked list is slow because we know that we need to traverse through all the node elements to access a particular element now the next difference is in case of an array memory allocation is done in compile time whereas in linked list the memory allocation is done during the run time memory utilization is inefficient in an array as it is allocated as in static and it is allocated during the compile time in case of linked list the memory utilization is very efficient as the memory is allocated during the runtime if getting your learning started is half the battle what if you could do that for free visit skillup by simplylearn click on the link in the description to know more what is a stack so basically stack is a linear data structure just like arrays and linked lists the only difference is that it follows a specific order when an operation is implemented on it so what is the specific order that it follows that is lifo last in first out or philo first in last out in the next part we will understand this order in a much better way all operations can be done only at the one end of the stack that is on the top now we will discuss much about that in the operations part of the stack now let us understand the first fundamental that is a representation of stack that is how do you represent a stack normally so a stack can be represented using two different methods that is using an array or using a linked list so in an array we will be using the continuous memory and in stack we will be using a non-continuous memory and the stack will behave like a dynamic stack or a dynamic data structure now the first method that is the array method so in this method an array is used to represent the stack as you can see in the image below we have a stack so the name of the stack is stack itself and you can see two more things here that is top is equals to 2 and max is 4. so the max is the value of the array or the length of the array the maximum length of the array and top is the position where the last element of the stack is present here in this case 56 is the last element in the stack and top is inclined or it is addressing to that particular address that is two and now let us discuss about the linked list representation of stack so in this method a dynamic data structure that is a linked list is used to represent the stack this representation leads to a dynamic stack it does not need to define the maximum number of elements present in the stack remember in arrays we had to define the max value in the previous example we had the max value as 5 but in here you need not to assign the max value as the stack itself as dynamic the pointers links are used to store the address of the upcoming nodes and the variable used in this method is top so the top is holding the address of the topmost element in the linked list representing the stack now moving ahead we shall understand the basic operations on stack now here we will understand the previously discussed definition that is push pull etc in a much better way so the basic operations on a stack are push pop or pull and peak now let us discuss each one of them in a detailed way the first one is push operation so the push operation is the mechanism of inserting a new element into the stack as you can see we are trying to insert the elements from the top so the push operation basically involves the following steps check if the stack is either full or not so basically whenever you are trying to insert an element into the stack you need to make sure that the stack is empty or it has some space if it is full you cannot insert an element into the stack step two if the stack is full produce an error and exit that's what i was talking about now the step three if the stack is not full increment the top buy one that is when you're inserting an element then you need to update the top value for example in the previous slide when we had the array representation of a stack we had the top value as 2. so if you try to include an element into the stack then you need to update the top value from 2 to 3 that is incremented by 1. now the fourth step add data elements to the stack where the top is pointing and finally success the push operation has been successful so this is how you insert or push an element into the stack now followed by push operation we have pop or pull so the pop operation is a mechanism of eliminating or deleting or removing one data element from the existing stack so we shall understand the pop operation in a much more detailed way the operation involves checking the stack is empty or not if in case the stack is not empty then you can carry forward the pop operation but in case if the stack is empty then you have to provide an exit status and exit the control and leave the stack so if the stack is not empty approach the data element at the top that is at the top position for example in the previous array example remember right we had the top position pointing towards two so you need to take the control to the top position and pick out the element and pop it and finally decrease the top by one so when you eliminate the top element then the top value from two will be decremented to one so this is how the pop operation is carried over on a stack next one is the peak operation the peak operation involves returning the topmost data element from the stack without moving it so here you can see the top is pointing to the element number four and you're picking the element number four and you're not removing it from the stack you're just returning the topmost data element you're passing the value of the top element so to understand the push pop and peak operations on stack in a much more better way let's carry out a practical example now we are on the practical mode and here you can see on my screen we have the code example for the stack now first we'll be checking if the stack is empty as per the steps mentioned in the previous discussion we will check if the stack is empty or not if it is empty then we will return else we will continue and again another step we also check if the stack is full if the stack is full we will exit else we will continue with the operation whatever it is peak pop or push and here we have an example for the peak operation that we discussed previously and followed by that we have a pop operation we are trying to exclude an element from the stack and another one we have the push operation where we'll be trying to push the elements into the stack so these are the three functions for push pop and peak now we'll try to push in the elements and also pop and try to involve some functions on it or run some operations on the stack now let's run this code and see the output so you can see that the code has successfully executed and we have the statements here the first one says the stack is not full that is false and stack is empty that is true right and after that you can see that the elements which we tried to push into the stack that is 11 76 71 15 and 66 are been pushed into the stack and if you clearly observe it we have the element 11 in the bottom 76 upon that 71 upon that and 15 and last 66 so the order is first in last out that is the first element was pushed first and when you are trying to eliminate the elements from the stack then you will first pick out 66 followed by that you will pick out 15 followed by that you will pick out 71 and so on so this is the rule what stack follows now i hope i made myself clear with the example now we shall continue with the applications of stack so these are the few applications of stack the first one is expression conversion so you can see we have the infix notation prefix notation and postfix notation so the infix notation is no rocket science there is only one thing here to learn that is we have two operands a and b and we have one operator that is the addition operator in between those two operands and when you use the prefix notation you will have the operator located at the first place then you will have the operands followed by it and in the postfix one you will have the operands first and followed by the operands you will have the operator so basically all the infects prefix and postfix notations give out the same results but the only difference is the representation of those operands and operators now let us understand this in a much more detailed way so conversion of expression from one form to another form is the main application of stack so we have the first one that is in fix to prefix and infix to postfix now let us see an example here you have one plus 2 star 3 plus 4 so this is the normal in fixed notation and when you try to present the same expression in the form of prefix notation so this will be the result and this is the result for postfix the next one prefix to postfix and prefix to infix and this is the way you write the prefix notation and if you want to convert that to infix this is how you can write it and this happens to be the result of postfix notation and finally postfix to prefix postfix to infix and these are the results now followed by expression evaluation the next important application of stack is checking parenthesis and you can see if the parenthesis is set properly the expression gets evaluated if not it will not be evaluated now the last one memory management and function call the very useful thing of using a stack is the memory will not be allocated to your stack elements unless the function is called here you can see it is the main function and these are the elements that you wanted to declare into your stack and unless you make a function call the elements will not be declared their memory or the elements will not get the memory allocated for them now another good application of stack is the backtracking problem or the end queen problem the end queen problem is an example of backtracking problem the end queen solution to this problem is to position the queen in such a way that the opponent queen cannot attack your queen now another example is string reversal you can see on my screen we have a string that is a b c d and e now using stacks you can reverse this right so you're basically eliminating an element and relocating it to the first place and finally after reversing your string this will be your result a b c d and e followed by that we have conversion evaluation so stack is used to evaluating the expression as shown in the example since parenthesis has the highest precedence five plus four gets evaluated first and it will result in nine then multiplication and division have the same precedence now the associativity comes into picture so the associativity is always from left to right so first 4 into 9 will be executed which will result in 36 and then 32 divided by 4 which will give us 8. now we have 36 minus 8 which will give us an answer that is 26. now the last application is the tower of hanoi so the tower of hanoi is a mathematical puzzle consisting of three rods and n discs this puzzle consists of some rules the first rule states that one disk can move only at a time the second rule is that the disk can only be moved when it is at the uppermost position on the stack the third one no dusk is allowed to place on the top of the smaller disk so this is how the tower of hanoi works what is a stack so a stack is a linear data structure that follows fifo or first in first out principle all the operations on the stack are done only from one end that is the top so you can see this image here and this particular image of box can be considered as stack and you can see that the addition or elimination of elements that are spokes in this particular case is happening only through the top section now we will understand what are the basic operations that can be performed on a stack so the basic operations that can be performed on a stack are push pop and peak so this particular image on the right side will help you understand what exactly is push pop and peek as we discuss the elements will be added into the stack from the top so when you add an element from the outside into the stack it will be pushed from the top that is the push operation and if you want to eliminate an element from the stack it will be eliminated from the top that is the pop operation apart from these two that is push and pop we have another operation that is called as peak the main intention of p is just to see the element which is on the topmost part of the stack it will just retrieve the element from the top it will not pop it or it will not push any other element onto the top it will just copy and it will just print what is present on the top so these are the main operations that is push pop and peak now let us see how to implement this stack using array so implementation of stack data structure can be done in two ways that is array and linked list now in this particular session we will learn how to implement stack using array data structure now without further ado let's get started with the implementation of stack so we will be performing push operation that is inserting a new element into the stack now followed by that we will be performing the pop operation onto the stack that is eliminating or deleting an element from the top position of the stack and followed by that the last operation that is the peak operation where we will be just retrieving the topmost element from the stack without removing that element from the stack or without adding any new element to the stack now that we have a detailed understanding of what are the basic operations that can be applied onto the stack let's get started with the practical implementation now you can see that on my screen we have the basic fundamental operations onto stack that has the push and pop now without further ado let's get started with running this code don't worry about the code this particular code will be present in the description box below or if you need it you can always write down to us in the comment section below and we will have it sent to your mail id so that you can have a better understanding of the code and try to execute the code in your local system now let's run the code and see the output as you can see the code got successfully executed and the topmost element is a and the topmost element is b after the element is being popped away and it says that the element b was popped out and after that the topmost element was a and after that the element a was also popped out and now the top is pointing to -1 which means to say that the stack is empty in this session we will learn about linked list implementation using stack so first up what exactly is a linked list so linked list is a dynamic data structure it allocates memory dynamically the nodes are maintained in a non-continuous memory that is in linked list we have nodes so each and every node is connected via a pointer which points to the address of the next node each node contains next pointer that is the next pointer's address which keeps the reference to the next node and it also has another section which stores the data the topmost node always contains null in its address and this is how a linked list looks like so this is the top which is the beginning position of the linked list and this is the address of the first location and this is the next node this is the following node then this is the last node and this points back to the head node so this is how you can implement a stack like data structure using linked list you can see that we can perform stack like operation that is the elements are located one above the other and the top is pointing to the head node now let us go through the implementation of stack using linked list first we will go through traversing of stack using linked list so displaying each node of the linked list representing stack is termed as traversing copy the head pointer to the temporary pointer and then move temporary node through all the nodes and display values of each node so you can see the animation here will explain you how the traversal goes through the linked list in real time now another link list implementation of stack is the push operation so adding a new node to the top of the stack is termed as push operation generally in stack we have three operations that is push pop and peek so one of the operation is push where you add an element into the stack in the same way using linked list you can add a new node to the stack and point it as the top of the stack or the first element which represents the top in terms of stack now create a node first and allocate a new memory to it if the list is empty and node consists of data and null is the address it will be inserted as the first node if there is some node already existing then add a new node at the beginning to avoid violations so the following animation will help you understand how we add a new element or the top element to the stack using linked lists now followed by the push operation we have the pop operation so now let us go through the pop operation removing a node from the top of the stack is termed as pop operation in the same way we will be eliminating the first node from the linked list which is termed as top underflow condition may occur when you try to remove the node if the stack is already empty in stack node can be removed from one end only therefore the value stored in the head pointer must be deleted and the node must be freed followed by the pop operation we have the peak operation retrieving the top most node of the linked list representing stack without removing the linked list node from the top of the stack is termed as peak operation generally when you're using a stack data structure just retrieving the value of the top node is called as peak operation you're not going to eliminate or you're not going to add a new element to the top you're just going to copy the element or you're just going to retrieve the element which is pointed as top this operation is called as peak now in the linked list you can also perform this operation of peak now with the theory discussed let us execute a practical program based on stack implementation using linked list now on my screen you can see a code example using which we will implement stack using a linked list now here we have the pop operation push operation and top and then the main function don't worry about the code this particular code snippet will be attached in the description box below or you can also request us and we will have it sent to your mail id and you can understand the code and try executing in your local system now without further ado let's directly run the code so there you go the code got successfully compiled and we have tried to add some elements into the stack that is a b c and c is being the top most element of the stack and that element has got popped and followed by that the element on the top currently after c being popped out as v and the node element b got popped again and the only element which is present in the stack is a and that element is also popped out after performing the pop operation and now currently the stack is empty you can see that we have tried to push the elements a b c and also we try to pop the elements a b c let's get started with introduction to queue you know that all of us depend on messaging applications like whatsapp facebook messenger instagram chats to communicate with our friends and family members and while using them you must have observed that the person you are trying to communicate with receives messages in the same order as you have sent them now the question that arises here is how is this happening how are these applications maintaining the order of these text messages and the solution to these questions bring us to queue basically in these applications a queue is maintained for each user containing the messages to be delivered to the user when the user connects to the network all the text messages in the queue gets delivered and once the messages are delivered empty queues get deleted this example clearly illustrates the importance of data structures so let's dive further and understand the structure of the queue in depth but before doing that let's look at a real-life example of cues to understand it more clearly the most common and relevant example of a queue is a movie ticket counter in the movie ticket counter you must have observed that both of its ends remain open also these ends are fixed with the help of barricades and that is why no one can enter in between these ticket lines additionally the person who enters first receives a ticket first and the person who enters last will obviously get served at last cues and data structure resembles all these properties of a movie ticket counter which makes them better at creating virtual first-come first-served systems basically they are defined as a linear collection of different data types that allow insertion at one end and deletion at another unlike any other data structure the queue ends remain open allowing it to have different functionalities at both ends the end at which insertion takes place is called rare and the end at which deletion takes place is known as front furthermore there are two approaches to consider the structure of the queue and both of them depend on the approach of the programmer that means being a programmer if you consider the left hand as front then your red node will be at right end otherwise if you consider the left hand as rare then the right end will be your q's front node unlike arrays and linked lists elements in the queue cannot be operated from their respective locations here they can only be operated from the front or rare position moving on let's discuss the operations in queue data structures one by one the first operation is enqueue it is used to store the elements in the queue next up is dq this operation is used for removing them further we have isful and is null operations is full function scrutinizes if the queue is full or not and the is null operation evaluates if the queue is empty we also have a peak operation that helps you get the element from the front of the queue without removing it let's now understand how these operations work with the help of the following examples here we will look at nq5 and q1 and q minus 2 then is full then dq peak and is null but before explaining these operations it's essential that we initialize the queue data structure by assigning some random size to it for example int q of 3 by this declaration we are assigning only three spaces for insertion and q also at this phase there is no element in the queue as it's empty so both the front node and rear node will point to the same location with null memory space in the storage system let's consider that null index to be -1 for ease of our convention now the first operation on our list is nq of 5. as we discussed previously enqueue operation is nothing but the insertion of data into a queue data structure it begins with checking if the queue is full or not if the queue is full then the previously assigned memory is completely filled with data elements so insertion would not be possible this is also known as overflow error in terms of programming but as our queue is empty so the insertion can be performed here for that we have to increment the rare pointer to index 0 from index -1 and once we do that the data element 5 will be added to the queue also for front insertion both front and rear will point to the same location as there is only one element present in this queue let's insert two more elements into this queue with the operations nq1 and and q minus two for that we have to increment the red pointer to the next index which will be 1. now as the point is incremented so the data will be entered into this position next up is nq minus 2. again we have to follow the same process of incrementing the rare pointer we will increment the rare pointer to point towards the next index that is index 2 and hence the data element with value -2 will be entered here the next operation on our list is is full in this operation if the rear pointer points to the max size then the queue is considered to be full as there is no space left for insertion in our case the max size of rq is 12 bytes additionally we are considering to enter only three integer elements and one integer data element takes four bytes of the memory space that means three integer elements will take 12 bytes hence this function will prompt q is full on the screen now we will discuss the dq operation if we want to access data from a queue we have to perform two sub tasks the first one is access the data where the front is pointing and another is to remove the data after access and this complete process is called as dq operation the first step of this operation is to check if the queue is empty if the queue is empty then there is no element available for deletion this is a case of underflow error but as our queue is not empty we can proceed with the next steps we will be accessing data from the front node and later we will be incrementing the front pointer in order to remove the link to the previous node so that the data gets removed now front will point to the index 1. thus the data value 5 will be removed from the queue and will also be prompted on the screen therefore this function comes with an integer return type next up is peak operation in this operation element at the front node will be accessed without deleting it the algorithm for this operation begins with checking if the queue is empty or not if the queue is not empty then data at the front node will be accessed with temporary variable and printed on the screen advancing further let's perform two more dequeue operations here first is dq of 1 and another one is dq of -2 the data at a front node will be accessed primarily and the front pointer will be incremented to point to the next data element when we do the point incrementation the link to the previous node gets removed which results in data deletion similarly we will perform a dequeue of -2 operation here now the front will be pointed to null memory space as there is no element left in rq and the data -2 will be removed the last operation on our list is is empty this function checks if the queue is empty or not in the previous procedure we mentioned that if the front points to the null memory space then the queue is empty and in our case the front is already pointing to -1 so the output of this function will be q is empty this is all about operations in the queue i hope that you all are clear with these operations next we will discuss different types of queues and their structures at a glance basically there are four types of queues linear queue circular queue priority queue and double ended queue the structure which we have discussed till this time is that of a linear queue so now we will move on to circular queue the circular queue is almost similar to the linear queue except that the last node of this queue is connected to the first it is also known as ring buffer as all the ends are connected to another end additionally this circular queue is a better version of the linear queue as it removes the drawback of insertion in the linear queue the empty space available in a circular queue can be filled with the new element by simply incrementing the value of the rare position we will learn about this in detail in our further sessions a priority queue is another special type of queue data structure in which each element has some priority assigned with it based on the priority of each element the elements are arranged in a priority queue if the elements occur with the same priority then they are served according to the first in first out principle in the priority queue the insertion occurs based on the arrival while the deletion occurs based on the priority the above figure shows that the highest priority element comes first and the elements of the same priority are arranged based on the first in first out structure the last type of queue is dq dq is a linear data structure in which the insertion and deletion operations are performed from both the ends we can say that dq is a generalized version of the queue dq can be used as stack as well as q as it allows the insertion and deletion operations on both the ends if the insertion takes place at one end and deletion at another then that eq is known as a linear queue and if both addition and deletion are performed at a single end then that eq is called stack advancing further let's discuss some applications of queues to gauge an insight into the importance of queues the queue data structure is used in computers printers and applications to utilize the benefits of the first come first serve technique in computers whenever you work on documents or ppt you must have observed that whichever key you press on the keyboard appears in the exact same order on the screen but when your processor is too busy with other tasks you might notice that the keys you press appear on the screen with some delay after you press them basically those keys are stored in queue and when the processor becomes free it processes in the order the keys are pressed that means the key pressed first will be written in a word document first so this is how computers use a queue to eliminate dead locks when multiple processes are in a ready state next up is printers a queue data structure is used in printers to maintain the order of pages while printing that means the pages are stored in a queue in the order that you want to print them and once the page is removed from an ordered queue it gets printed another most common application of queue data structure is their usage in web or mobile apps applications like domino swiggy uses a queue for maintaining food order status if you place an order from an online portal your order id enters the queue and once the previous orders before your order id gets scattered then your order will be catered as well from these examples we can clearly say that queues are used whenever there is a need for an fcfs strategy in software development so whenever you work on projects that need a first come first serve approach then remember that you have to implement a queue data structure to complete it successfully finally let's have a look at some key takeaways that we discussed in this session we started this session by examining the structure of the queue we learned that the queue is a linear data structure after that we talked about different operations of queues in which we learned nq and dq are responsible for data manipulation in a queue later we discussed different types of queues as well finally we discovered some applications of queues and how they fulfill the need of fcfs systems we have also made it clear that queues can handle multiple data types as well having said that let's dive deep into the strategy to implement queue data structure until now we have understood that q is a special kind of list with some restrictions on insertion and deletion and there are two approaches to deal with queue implementation the first one is array based and another one is linked list based in this session we are going to focus on array based implementation initially let's say we want to create a queue of integer elements for that purpose firstly it is essential to declare an array of random spaces let's take 100 as the size of our array that means our array can have a maximum of 100 integer elements the declaration of an array is made with this line of code in q hundred where int represents integer data type and q is the name of our array and hundred is its size the array that we just initialized is going to store our queue by that what i mean is that any random index of an array queue is going to start with two marked ends front and rear in this array i'm showing front of the queue towards the left and rear towards the right for making those end nodes we need to initialize two pointers front and rear at this moment as our queue is empty so both of those pointers should point towards -1 so initialization of these pointers should be done as in front is equal to -1 and int red is equal to -1 when the insertion or deletion happens in queues these pointers will be either incremented or decremented so they are an essential part of this queue implementation process now you must be clear with the array and pointers declaration part so let's dive further and formulate code for queue implementation using a one-dimensional array in c plus plus it is essential to include header files into our source file as we cannot access standard c plus plus functionalities without them that is why here we are going to load io stream and standard input output files along with using namespace sdd once this is done we will initialize our array along with front and rear pointers remember we always have to declare the size of an array before compilation that means we cannot update the size of an array at runtime this scenario is the biggest limitation of queue implementation using arrays having said that let's proceed with pointers declaration now we are done with the initialization process we will now work on implementation of queue functionalities let's first work out supportive queue functions like is null is full and peak isn't function validates if the queue is empty and as per our previous discussion when both front and rear points to -1 then the queue is considered to be empty so the condition to determine if q is empty will be if rare is equal to is equal to -1 and front is equal to is equal to minus 1 it will return q is empty the queue does not satisfy the previous condition then it is not empty so by using the else condition we can display the queue is not empty next up is is full function this function validates if the queue is full and we can clearly say that if the rare pointer is equal to the max size of the queue then our queue is going to be completely full next is peak the peak function extracts the element where the front pointer is pointing without removing it from the queue for this functionality to work our queue must contain data elements in it what i mean is our queue should not be empty if our queue is not empty then data at the front node can be accessed this is how we implement supportive queue functions let's immediately dive into the development of main queue operations nq and dq for enqueue operation if the queue is full then our function should prompt an overflow error for that to happen we have to put this condition if the front pointer is pointing to -1 then we have to increment the front pointer to 0 manually otherwise it can be incremented by rare plus plus after pointer incrementation we have to ask for a data element to enter into the queue once the data is given it should be inserted at the position where the rare is pointing now finally let's quote the final main queue operation called as dq if the queue is empty then there is no element for deletion so it should prompt an underflow error on screen also if there is only one element left inside q then both pointers should again be pointed towards minus one for that let's write another condition here if both the previously mentioned conditions are false then deletion of an element can be achieved by just pointer incrementation we have implemented all the queue functionalities here but we haven't implemented a function that can show us how our queue looks so for that let's implement one more function with the name display this function should prompt the elements of the queue on the screen elements will only be printed if the queue is not empty hence we have to check for the emptiness of the cube first finally we are done with the hard part so let's arrive at the main function to contemplate these operations in order to visualize outputs we are going to use a switch case to take a user command thus not to waste your time on this let me just get done with this block asap that's all we are done with the queue implementation using arrays let's just examine if our code works fine or not by compiling it this program should return a console that asks the user to give commands for performing different operations so as you can see on your screens if i input 1 i can perform insertion in a queue let's perform some insertions now we will insert four elements first three then 21 next 78 and finally 12. after inserting these elements we will print the state of the queue using case 3. let's also check the dq function if we perform a dq operation then 3 should be remote from the queue let's check if it is remote using the display function and yes our code works just fine now if you're concerned about this code then don't be as we can send it over to you if you drop your email ids in the comments section below additionally you can also try to run it on your local system to have a better understanding of the concept we discuss the implementation of queue using arrays we discussed the limitation of fixed size according to that limitation an array will always have a fixed size and it should be declared before the compilation of program furthermore once all the positions in an array are taken or it is exhausted then we only have two options we can either deny insertion by saying that the queue is full and we cannot insert anything now or what we can do is we can create a new larger array and copy elements from the previous array to the new large array the time complexity for this copy operation will be proportional to the number of elements inside field array in other words we can say that the time complexity of this copy operation will be big o of n but again as we are giving random larger size to the array there is a possibility of massive memory loss like right now in this array 70 of the memory is unused and the memory is a crucial resource that we should always be protecting it's not that some amount of unused memory will be real problem in today's modern day computer but it's just that while designing solutions and algorithms we should always analyze and understand these implications regarding memory along with this memory wastage there exists another sort of memory management issue that occurs while utilizing an array to implement a queue data structure the space of an array which is used to store elements can never be reused to store the queue elements because items can only be inserted from the front end and the front end's value may be so high at that time the space before the pointer will be lost for eternity let's have a look at an example to understand this drawback more clearly in this example of array representation of q a queue of size 10 having five elements is shown the value of the friend pointer is 5 therefore we cannot reinsert values in the place of already deleted elements before the position of front that means the space of the array before print pointer can never be reused for storage purpose these drawbacks represents the need for a more appropriate method to implement queues and by using a proper dynamic data structure like linkedlist these drawbacks can be easily removed on that note let's discuss about the representation of queue using a linked list a linked list as we know is a collection of data elements that we call nodes these nodes are stored at non-contagious locations in memory further each node contains two fill one to store data and another to store the address of next field or the reference to the next node let's assume that the node in this figure are at addresses 200 400 and 500 respectively i have filled these addresses in the address field as well the identity of the linked list that we always keep with us is address of the head node we often name a pointer or reference variable at which we store the address as head so now we are saying that we want to use a linked list to implement queue data structure and the basic definition of queue conveys that a queue is a linear data structure in which insertion is performed at the rear node and deletion at the front node it's really effortless to enforce this property of a queue in linked list we can simply pick one side of a linked list for insertion and another site for deletion if the head node is considered to be front then the tail node will be the rear otherwise if the head node is deemed to be the rear then the tail node will be the front end whatever side we are picking for whatever operation we just need to make sure one thing and that thing is the operations that we are carrying out must take a constant time or in other words that time complexity should be big of one i hope that you guys are clear with the representation of a linked list as a queue data structure now moving forward we will discuss about its implementation but before that let's have a look at the time complexity management challenge which occurs in queue implementation of a linked list in the case of linklish the cost for insertion or removal from the head side is bigger of one but the cost for insertion or removal from the tail side is big o of n so here is the d in a standard implementation of queue using linklish if we insert element at one side and remove them from other side then one of these operation nq or dq depending on how we are picking this side will cost us big of n but the requirement that we have specified before for q implementation suggest that both these operations must take a constant time so we'll definitely need to do something to ensure that both nq and dq operations take constant time let's call this side front and this side rear so i want to enqueue a node from the tail side and i want to perform a dq at the headset we are good for dq operation because removal from the front will take a constant time but insertion or enqueue operation will be costing us big of n let's first see why insertion at the tail will be costlier and then maybe we can try to do something to insert an element at the rear end what we will have to do is first we'll have to create a node let's say i have got this node at address 350 and the integer that i want to enqueue is 7 the address part of this node can be set as null now we have to build a link with this created new node and to do that first we'll set the address part of the last node as the address part of this newly created node but the only identity that we always keep with us in case of linked list is address part of head node so to get a pointer to any other node we need to start at head that is why first we'll create a pointer variable tem and we'll initially set it to head node and now using this temp pointer will traverse to the end of our linked list that is the tail node and here using this pointer temp we can write the address part of the newly created node at the previous tail node to build this new link this traversal of pointer from head to tail is taking all the time for insertion we use a statement like temp is equal to temp dot next to move the next node what we can do is we can avoid this whole traversal with the help of pointer variable just like head node we can call this variable tail or even rear let's call this variable rear for now and also the variable with storing an address of head as front in any insertion or removal we'll have to update both run and rear now but from now on whenever we will perform enqueue operation we can directly check where our rear node is and update its address to formulate a new insertion link this simple addition of one pointer resolves a problem with the cost of insertion let's understand this scenario with the help of an example previously we were traversing from head node to the tail node but now as we know the location of tail node there is no need for any traversal we can directly update the address part of rear node to make a link for new node here the new node with data element 7 will be linked to the previous node and the rear pointer will also be updated to point towards the newly inserted node now the complexity for both the operation will be big of 1 which means we can now begin with the coding implementation of queue using a linked list so let's dive directly into that in order to get started with our coding implementation we'll need to load some dependencies that are called as header files i have already included those header files here so first of all we'll declare a structure to create nodes for our linked list and inside the structure we'll initialize data and address part so let's get started with creation of this structure struct node now the initialization of data and address part and data struct node star next now using this created structure we will initialize front and rear pointers so let's create this front and rear pointer struct node star front is equal to null similarly struct node star rear is equal to none the declaration of variables that we have done here is in global scope the reason behind that is to make sure that these variables will be accessible to all the functions so moving forward let's work out the primary queue operation we'll start with enqueue operation so let's create a function for that void enqueue and inside this function will pass an argument in x to insert a element now inside the enqueue function will take an integer as an argument in this function we'll create a new node for purpose of insertion so let's create that new node struct node star temp is equal to struct no so with this size of function we have allotted the size of address part as well as the data part one more thing i want to tell you guys is i am using malloc in c here for dynamic memory allocation if you want to implement this code using c plus plus then you can use new operator instead of malloc the purpose of using malloc here is to create a node in dynamic memory now moving ahead we can start working on two cases of enqueue operation primarily there won't be any element inside the queue so for the first insertion we'll manually set both front and rear to the address of this newly created node so to do that first we'll have to create an if condition if front is equal to equal to null and and rear is equal to equal to null front is equal to rear is equal to 10 which is nothing but the new created pointer variable and will return the control if this condition fails that means there are already some elements present inside our queue so using else condition we can write another statements rear dot next is equal to 10. and rear is equal to 10. basically these two lines of code are just updating the address part of the next node along with setting the temporary data into rear node's data field this code will be further clear if i'll show things moving in simulation so let's revisit powerpoint for that purpose let's say initially we have an empty queue so both front and rear will be null null is only a macro for address 0. at this stage let's say we are making a call to enqueue function passing number 2 as an argument now let's go through the enqueue function and see what will happen first we'll create a node the data part of this node will be set as 2 and the address part will initially set as null let's say we got this node at address 100 so a variable named temp will store this address right now the front and rear both are null so we'll go inside this if condition and simply set both front and rear as hundred after the first enqueue operation our queue will look like this let's say we are making another call to enqueue function at this stage passing number 4 as an argument once again a new node will be created let's say i got this new node at address 200 this time the queue is not empty so in this function we'll first go to the statement rear dot next is equal to 10 so we'll set the next part of this node at address 100 as the address of a newly created node which is 200 so we'll build this link now and now we'll store the address of this new rear node in this variable name rear so this is how my queue will look like after the second enqueue operation i hope that you guys are clear with the implementation of enqueue operation and the working of its code let's deal with the next queue operation named as dq in our code editor now inside this dq function i'll create a temporary pointer to the node in which i'll store the address of the current front or head node so that we can directly delete it so the statement i'll write for that is struct node star 10 is equal to front now the first condition that will write in this dq function is underflow error so let's begin with if lock f front is equal to equal to null printf q is in empty state slash n and return the control to the next function otherwise in next case when both front and rear will be equal we'll set both these pointers to the null manually so to do that we'll insert another if lock if front is equal to equal to rear front is equal to rear that's equal to null this if block will get activated when there is only one element inside the cube in all other cases we can simply make a front point to the next node so we'll simply do a front is equal to front dot next so for that we'll write else block else front is equal to front dot next in all three previous mentioned cases we are trying to remove elements and that can only be done by implicit call of function pre so let's call function free to delete the front node from our queue so the statement that we'll write is front free the temporary variable which is actually storing the head node address next we'll work on peak operation and for that we'll create a new function in peak basically the peak function is used to extract the value of print pointer for front pointer we will simply check if the queue is empty if it is empty then obviously there is no element at front node to extract but if it is not empty then we can extract a value from print pointer so for that we'll create a if block if front is equal to equal to null which also means the queue is empty then we'll return printf q is empty slash and otherwise we will return the data present at front no now we have implemented all important q functionalities but we won't be able to check the state of queue with the help of these functions so let's formulate one more function called as print to visualize our queue so let's define this function void print inside this function will create a temporary pointer struct node star temp is equal to front we are initializing this temporary pointer to the front so that we can traverse the whole queue elements using iterator element so moving forward let's create this iterator element using a while block so the statement that will write for that is while temp is not equal to null printf modulus d comma temp dot data and we will set temp is equal to temp dot next this is nothing but the traversal of linked list now we'll also print f slash n so that all elements will be printed in order with this we have completed the implementation of print function as well now let's work on our driver method called as main function to contemplate the output of our program and set this we'll make call to the enqueue function and queue to and we will print the state of our queue using print function next we'll make call nq 4 and we will also print this state using print function next we'll make call to enqueue 6 and we'll also print the state of our queue at this instance now after this will dq few elements dq and will print state next we will enqueue one more 11 and q a now that we are done with the coding implementation of queue using linked list let's execute the program and visualize the output this is the output that we have received let's compare it with the calls that we have made in order to judge its correctness the first call that we made was nq 2 so the print function has printed 2 over here after that we inserted 11 4 and 6 and our print function has printed the state after these operations as well next we deleted the element present at front pointer which is 2 so after deleting 2 the output that we got is 4 and 6. finally we inserted one more element to check if it is getting inserted at the rear end and that element was it which is exactly inserted at the rear end of queue introduction to priority queue primarily we will have a look at the real life example of priority queue to understand it better a hospital emergency queue is almost an ideal example of priority queue when you go to the hospital you must have observed that the person who needs immediate medical attention will be treated first irrespective of his arrival at the reception that means treating a person who is in agonizing pain or in emergency medical condition is the priority of the queue of patients priority queue in computer science also works with same approach so what exactly is this priority queue well a priority queue is an abstract data type that operates similar to the normal queue except for the fact every element has certain priority assigned to it this definition of priority queue suggests that this particular type of queue also follows the same restrictions for insertion and deletion of data elements the insertion in the priority queue will only be achieved at one end and deletion at another or opposite time additionally the priority of data elements will determine the order of removal the elements which have higher priority will leave the q at first and the elements which have lower priority will definitely leave the queue at large as a side note i would like to tell you guys that the priority queue only supports the elements that are comparable meaning the data that we are going to insert into priority queue must be orderable the compiler should not be facing any difficulty while comparing these data elements otherwise the execution of a priority queue will definitely fail moving ahead let's have a look at an example of priority queue in this priority queue we will insert 7 to 45 23 and 12 respectively these elements are not ordered so how the priority queue is going to store them in order well at the time of insertion the priority queue conducts a comparison of each element with every other element present inside a queue to store them in order but as there is no element inside a queue so the first insertion that is an element with value 7 will be attained followed by that the next element will be inserted in a queue since the newly inserted element is smaller than that of previously inserted element will swap their positions in order to maintain order remember the element with least value will have a higher order and the element with greatest value will have a least priority or order now we will insert the next element in a queue that is 45 as 45 is a larger element than the elements inside the queue there is no need to shuffle elements when we make the next insertion the element 32 will get inserted at index 3. now this element is smaller than that of 45 so the algorithm will have to swap the locations of these elements now we will perform the final insertion into our queue we will insert 12 at index 4 now but as you can see this element is smaller than both the previous elements thus the algorithm will have to swap their positions now 45 will reach the end of q as it is the element with highest value and 2 will remain at the front of q as it is the least valued element as a humans we could see the numbers visually inside the priority queue and further we can easily arrange them but how does the machine know this does it restore all the elements inside the priority queue before each insertion no obviously that would be highly ineffective as there will be n comparisons for insertion of n elements leading to time complexity big o of n square this is an enormous time complexity which we cannot allow in any software application we will understand how the priority queue manages to reduce this time complexity in upcoming topics but right now we will contemplate different properties of a priority queue that we have learned from previous example the first property of priority queue suggest that each element has a certain priority assigned to it that priority might depend on value of data element it can be either larger or smaller the next property states that element with higher priority will leave the queue at first where the element with least priority will leave the priority queue at last further if two elements have the same priority then the element will be removed from the priority queue based on their arrival that means the element which arrived at first out of the elements having same priority will be removed first now moving ahead will deal with the representation of priority queue using a linked list as usage of arrays is not an ideal way to implement priority queue if we consider array implementation of priority queue then inserting items into the sorted array will cost us big o of n and in general processing each element will further cost us big o of n square as discussed previously so in this tutorial we'll just look into the linked list representation of priority queue we will understand the representation of priority queue with the help of an example initially let's say there are three elements inside a link priority queue and all of them are in order three being the least element has highest priority where 43 has the least priority the purpose of keeping three at the head node is that we want our priority queue to delete elements according to their priority now we want to insert a new node consisting of data element 2 and as the data element is smaller than the element at head node that is 3 so this new node should be inserted prior to it this particular scenario of insertion seems pretty perfect but it does not cost us more time but what if the element is significantly larger than all the nodes in queue for instance let's say we want to insert 45 as a new element in that case primarily it will be compared with element 2 and as 45 is larger than 2 our temporary pointer will move to the next node for comparison now 45 will be compared with element 3 and again the temporary pointer will be moved to the next node for comparison after two comparisons the temporary pointer has reached element 17 for performing the next comparison and here also 45 is larger than 17 so the temporary pointer will again move towards the next node now finally our temporary pointer has arrived at the tail node consisting of element 43 again in this case the element 45 is larger than 43 thus the new node will be inserted after node containing data element 43. from this specific example of insertion into a priority queue we can clearly see that there are n comparisons leading to the time complexity big of n where the complexity of deletion remains constant that is big o of 1. while understanding the representation of priority queue we came across some packs that make priority queue implementation using linked list quite vulnerable so here we will again try to recall them the first drawback of priority queue implementation using linked list is that it cost us big of n for inserting a new element further it also cost us big of n for peak operation and as memory and time management is the purpose of data structure hence we must try to analyze other implementation strategies that is why in upcoming slides we'll look into different approaches to implement the priority queue there are three approaches that implement a priority queue with complexity less than big of n square we have already discussed the linked list so let's also look into other two approaches binary heap and binary tree provides almost similar complexities these approaches cost us big of log n for insertion and deletion and big of 1 for peak operation but which one of these operations is most optimal approach to implement priority q well to answer this question we again need to discuss about memory management in the case of both this data structure you guys know that binary heap data structure is implemented using arrays and since it utilizes arid there is always a better locality of reference as well as operations become more cache apprentices the binary search tree uses pointer to implement front and rear node which definitely takes up more space in memory due to that building a self-balancing bst cost us big o of n log n where binary heap just cost us big o of n these facts clarify that the binary heap is the best data structure to implement a priority queue now you must be thinking about what exactly the heap is and how does it work so moving forward we'll look into the definition of heap and its properties basically a heap is a tree based data structure that satisfies the heap in variant or in simpler words heap property the heap invariant states that if a is a parent node of b then a is ordered with respect to b for all nodes a and b in heat what that means is the value of parent node is always greater than or equal to the value of child node in the heap or other way around the value of parent node is less than or equal to the value of child node for all nodes in a heap further there are two types of heap named as max heap and minimum heat first we will look into maxi the max heap is heap in which value of parent node is greater than the value of child node for this particular example of max heap you can see that the root node is the biggest element in tree and each child node is smaller than its parent node the next type of heap is minimum heat the mean heap is heap in which the value of parent node is less than the value of child node in this specific example you can observe that each child node is larger than its parent node and the element at the root node is smallest element of the heat both the structures that we have discussed are binary heaps as every node has only two children in upcoming slides we'll discuss some complex structures of heap data structure to better understand how we can judge if a tree like structure is heap or not okay so you can see a tree like structure on your screen and we are supposed to check whether if it is a valid heap data structure or not but actually here i would like you all to give it a try by yourself you can also pause this video if you want but here i will provide you with a short moment to inspect this structure all right i can clearly say that this is not a valid heap data structure as you can observe the highlighted part is violating the heap invariant moving forward let's analyze another tree like data structure to consider if it is a valid heap or not well yes this is a valid heap because even though this one is strangely structured we are free to move around the visual representation of nodes to make it organize now you all must be thinking how we can do that well we'll understand that scenario in upcoming slides now how about this one is this a valid heap no right this is not a valid heap this structure is not even a tree as it forms a closed cycle and every heap must be a tree so it's pretty clear that this is not a valid heap now what about this one is this a valid heap yes this is a valid heap as it satisfies the heap invariant that all the child nodes must be greater than or equal to or smaller than or equal to its parent node now this is the last structure that we are going to check if it is a valid heap or not what you guys think is this a valid heap well i think it's pretty clear that this is not a valid heap but it can be converted into a heap by making a one small change now if we make six as our root node then this structure will get converted into a maxie which is absolutely a valid heap i hope you all are clear with the heap invariant and how to judge if a given tree is a valid heap or not now moving ahead we'll discuss the different types of priority queue basically there are two types of priority queue based on the priority of elements if the element with smallest value has highest priority then that priority queue is called as min priority queue and if element with higher value has the highest priority then that priority queue is known as max priority queue furthermore it's vividly clear that the mean priority queue can be implemented with a minimum heap where the max priority queue can be implemented using maximum heap moving ahead we'll deal with the operations in priority queue considering the heap as implementation strategy the common operations that we can perform on priority queue are insertion deletion and peak but there is one more hidden additional operation that gets performed during these operations that operation is called as hippify heffify manages the priority of data elements in a heap by shuffling the data elements after new insertion or deletion first of all we will understand how insertion in priority queue happens with the help of an example in this example we are inserting a new data element that is 43 but due to this insertion the structure disobeys the priority queue invariant that the parent node of the max priority queue must be greater than its child node now the hippie pie operation solves this problem by rearranging data elements by carrying out the comparison in this particular case 43 becomes the parent node where 40 becomes the china the next step is deletion as we know the highest priority element will be the first to leave the priority queue and further it is stored at the root node of a max heap so definitely the element present at the root node will get removed but due to this operation the order of priority queue gets affected however the hippify operation comes to the rescue it reshuffles the elements of the priority queue to rearrange them in order the next operation that we are going to discover is peak the peak operation simply returns the element present at root node without removing it and it is easily accessible thus the time complexity of this operation is big of 1. i hope you all are clear with the operations that can be performed on priority queue moving forward we'll try to implement them with the help of minimum heat as discussed earlier while implementing a heap data structure we know that all the elements will get stored in an array and we don't have any pointers pointing to either child or parent nodes so how exactly does the heap data structure remember nodes like parent nodes and its left or right nodes well if you have learnt binary trees then you must know the formulas present on your screen these formulas determine the left child right child or even the parent node of any binary tree let's understand how this phenomenon works with the help of an example we'll begin with index 0. if we enter 0 in this arithmetic expression then we will get 1 and 2 as output that means the element at index 1 will be the left child and element at index 2 will be the right shell and tree structure will look like this now moving ahead let's take an example of index 1. for index 1 the left child will be at index 3 and the right child will be at index 4. similarly for index 2 the left child will be at index 5 where the right child will be at index 6. using these formulas we'll be implementing heavify and primary queue operations so note them down for further reference now moving further we will visit code editor to implement priority queue data structure using c programming language i mentioned that heap is implemented using arrays so to begin with heap implementation primarily we will create a structure consisting of different variables or objects needed to implement heap data structure so let's create a structure struct heap consist in size and count variable and in star heap array which is a dynamic array that we are creating here and next we'll also declare a pointer to heap structure along with size and count variable in a global scope so let's do that end star heap comma size comma count will create one more variable and initial underscore size to represent the initial size of our priority queue and let's assign it value 4 for now okay now it's time to allocate memory to our heap array for this purpose we'll create a new function called heap underscore init so let's create this function void heap underscore init and inside it will pass an argument struct heap star h which is a reference of this structure that we created previously okay in this function let's initialize the variables that we have created inside this heap structure so for that we'll initialize h arrow operator count is equal to zero similarly h arrow operator size size is equal to initial underscore size and edge array is equal to end star malloc size of end star 4 this statement is just allocating 4 integer variables to our heap array basically our heap array is dynamic data structure that's why we have to provide it with dynamic memory using malloc if you are using c plus plus programming language to implement this data structure then you can use new instead of malloc moving forward now we'll work on our condition f not h arrow operator allocates memory to heap array then printf error while allocating the memory and slash on next we will write exit command okay okay with this we have successfully implemented our heap init function now moving ahead let's implement heavify function to move the nodes for that we will create a heavy five function void max underscore hippify end star data end log and count so all these are required variables to implement this hippify function that we have passed in argument for this maximize function now let's create few more variables that we need and left comma right comma largest comma temp now as discussed earlier left will be equal to 2 star location in array plus 1 and right will be equal to left plus one now let's say largest is equal to loc and we'll work on conditions now f left it's greater than or equal to count and and data left it's greater than data largest that it's the location we have stored in largest variable then largest is equal to left with this block what we are doing is we are checking if the element at location left is greater than the element at recent position and the value at left is also greater than the value of recent location if these conditions are true then we will set the recent location as left and here we are getting signal that there is semicolon missing over here so we'll add it okay now let's work on next condition now we will check the value at right position if the recent location is greater than the right and the value at right is greater than the largest value then element at largest will be set to right so for that we'll write condition f write its beta count and data right it's greater than data largest then largest is equal to right otherwise if largest it's not equal to location then we will store the data present at location in temporary variable and data loc is equal to data largest this is a swapping operation that we are carrying out here and next data largest is equal to 10. and now we'll make recursive call to our hipfi function max underscore if i data comma largest comma count with this we have successfully completed our hippify function now we will work on insertion operation on priority queue let's call this function heap underscore push because we are treating this structure as heap right so in heap insertion is called as push operation so we'll call it void heap underscore push and we'll pass arguments struct heap star h end value and inside this function will create few more variables and index and parent if you guys remember the initial size that we have allocated to our array is 16 bytes you can verify with this statement here that we are providing 16 byte size to our heap array but what if you want to insert elements more than four then what we'll do well for that we'll need to increase the size of our heap array so we'll do that here for this resize will create if condition f h dot count is equal to equal to h dot sides then h dot size plus equal to 1 and h dot heap array is equal to real lock edge dot heap array size of end star h dot slides basically we are using reallock function in c to extend the dynamic memory space for our heap array and in order to increase the size we have to increment the size variable first so that's what we have done in this statement here and now once done with this we'll check if our dynamic memory is getting allocated or not so for that we'll add one more if condition instead this if block so it can be called as nested if you guys want dot keep array then exit minus one now we will move out of this if block and we will set index variable to h dot count plus plus basically we are iterating with help of index variable here so next we'll add for condition for loop index to index is equal to parent and then set this condition will make parent node is equal to index minus 1 by 2. this is nothing but the formula that we have discussed in previous part now we'll add one more condition inside this for loop f h dot heap array parent it's greater than or equal to value then we will break this for loop otherwise h dot heap array index will be equal to h dot keep array parent now we'll move outside this for loop and we'll add one more condition of insertion that is h dot heap array and at position index we will add the value provided by user using argument to heap push function okay with this we have successfully created our heap push function now we will move towards the next function that is heap underscore delete for that we will create new function heap underscore delete and let's make this function integer and we'll pass struct heap star h as an argument we will create one more variable temp it's equal to h arrow operator heap array and inside this will pass a negating index that means we are using this temporary variable to traverse through all list of elements so for that we'll write dot dot minus minus h arrow operator count which will decrease count one by one now next we'll add condition f h arrow operator count it's greater than or equal to edge arrow operator sides plus two and and h arrow operator size it's also greater than the initial underscore size okay then what we will do is we will set size to negate itself by one for each iteration and then we will and h arrow operator heap array is equal to real lock edge dot heap array comma size of end star arrow operator and size sorry size and semicolon so basically what we are doing here is we are checking if count is smaller than the size of heap plus 2 and and the dynamic size of q is also larger than initialized size that is 4 then what we are doing is we are reducing the size for deleting an element using this statement and in next statement we are reallocating the deleted space so this is how this ip block works now moving forward we'll add a condition to check if memory is getting allocated or not for that will write condition f not h arrow operator heap array then what we'll do is exit with -1 okay now let's move out of this block and now we will set this removed variable to h arrow operator heap array and index 0. so if you guys remember 0 is the index of the highest element in our maximum heap what i mean here is the element with highest value is stored at index 0 for maxi now moving forward to delete this element what we'll do is we will set h dot heap array and index 0 is equal to temporary variable or pointer that we have created previously and next what we'll do is we'll call max underscore hippie five function to rearrange the structure of our priority queue which has been shuffled due to this delete operation now for that we'll pass arguments our heap structure that is heap array and next the index which was removed and the count variable and we'll return the remove element okay with this we have successfully implemented our delete function now to understand the order of deletion in priority queue we will implement one more function called as mtpq so let's create this function and in this function will pass the reference of heap structure in order to operate on it so let's pass the structure he star h and insert this function we will create a while loop h dot count is not equal to zero then printf modulus d and recursive call to keep delete function in which will pass h now we are done with this empty pq function further we will create one more function to visualize our priority queue let's call this function void heap underscore display and inside this will pass structure heap star h and now we will create one iterator element and using that iterator element will create for loop i is equal to 0 to i it's greater than arrow operator count plus plus i and insert this for loop we will print the elements present in our queue using this format modulus d and we'll call heap array but for that we'll need to call structure as well if array and will pass this iterator variable into it okay and then next we'll get outside this for loop and we'll print f is to the next line using slash n okay now we have implemented all the required function for our priority queue moving forward we'll work on our driver function that is main method to contemplate the result of our program so for that we'll first call struct keep edge then we'll call init function to create heap structure so heap init and we'll pass address of h next we will call heap underscore push function to insert element and h comma 1 next i'll copy this part will paste it to insert another element now we'll insert 5 here next paste and we'll pause 3. next we'll insert element seven next we'll insert element nine and after this we'll insert element eight okay so now let's display the elements inside our key using heap underscore display function and let's pause and edge object print it and again we'll call mtpq function empty pq h and after deleting all elements it will return the state of our heap array again or our priority queue so finally we will add return zero statement and now our code is ready so let's compile it and check it if it works fine or not so we are getting four errors here guys so we'll need to resolve them first we'll need to check line number 82 so for 82 okay here we haven't added semicolon so i think this should be fine now still we have two errors before i it's there so let's recompile it and check it if it is working fine now so we have received our output now now if you look at our output our output is printing elements 9 7 8 1 5 and 3 and deletion of elements is also happening according to their order so 9 is getting deleted first after 8 7 5 3 and 1. so that means our elements are getting removed in proper order further we can say that our program for priority queue implementation works fine now if you guys are worried about this program then not to worry we have you covered you can mention your email ids in comment box below and we will send it over to you remember guys we can make comments private to protect all your data so you can fearlessly put all your email ids in comment box below now we will discuss applications of priority queue to understand its importance the first application that we are going to discuss is use of priority queue in google maps you must have used google maps several times to navigate from one city to another or from your location to nearest desired location have you ever wondered how google maps managed to do that how does it provide an optimal path to reach your location well dijkstra's shortest path algorithm implemented in google maps actually manages to do that by gaining access to all possible paths this algorithm uses the priority queue to maintain all the paths in order let's understand how it works in detail now when you provide the location of place you want to reach via your mobile device google maps feeds the data of all possible path to digicastra's algorithm those paths or road are stored in minimum priority queue considering the distance as parameter for priority assignment and we have learned that the minimum priority queue maintains the lowest value at the print or root node this is how the priority queue helps google map to search for an ideal path for reaching destination location the next application that we are going to discuss is data compression in winzip or gzip these applications use hubman encoding algorithm to reduce the size of files hupman coding is a lossless data compression algorithm and in this algorithm a variable link code is assigned to input different characters the code link is related to how frequent characters are used most recurring characters have the smallest codes and longer codes are for the least frequent characters this is how the generated codes will maintain the complete data while utilizing less memory space let's understand how this process works with the help of an example let's say our text file contains these random characters the hubman encoding algorithm creates codes for each character based on its number of occurrences for instance the frequency of character a is more prominent than b and character c has less frequency so the length of code a is smaller than b and length of code b will be smaller than c now according to the amount of generated code the priority queue will determine the priority of characters and will store them these codes takes less size than the actual characters in memory space and due to the mapping of occurrences data does not get lost i hope now you guys understand why the priority queue is treated as an abstract data structure itself and why it is the better version of queue data structure what is dq dq is an abbreviation for double ended queue and as the term double ended queue suggests it is a type of queue with some advanced features at both of its ends but previously we have learned that the basic queue data structure must perform insertion from one of its end and deletion from another or opposite end so what new limitation of feature does this particular type of queue brings well the dq extends the concept of a linear queue by implementing insertion and deletion at both of its nodes by that what i mean is the dq data structure is acquainted with the possibility to insert and delete new elements at any node that is why dq is concerned as more generalized version of queue data structure now moving ahead we shall understand the key properties of dq the first property of dq states that the dq can use the lipo principle for inserting or removing elements the last in first out principle is used while implementing stacked data structure and according to this principle the queue elements must be inserted from one end and should also be removed from the same end for instance we are storing some elements inside the skew structure which is performing both insertion and deletion from one end however when deletion begins the element inserted at last will be removed first whereas the element stored at first will get removed at the end this property clears that the dq can inherit all the properties of stack data structure the next property of dq states that the dq can use the fifo principle for performing both insertion and deletion operations that means the element which enters inside the queue at beginning will also leave the queue at first further the element which entered at last can leave the queue at last both of these properties displays the uniqueness of this particular type of queue data structure now in upcoming slides we will understand different types of the dq the first type of dq we have is termed as input restricted queue this terminology itself suggests that this particular type of dq will have some restrictions while performing nq or insertion operation in this type of dq the insertion can only be performed from one end where deletion can be performed at both of its ends the representation of dq shown below explains how the operations in this type of dq will get accomplished the next type of dq is output restricted dq this term makes clear that this type of queue will have some restrictions while performing deletion operations in this specific type of queue the removal of elements can only be performed from one eight where the insertion can be performed at both of its eights this particular structure of a queue explains how the different operations will take place in this type of dq now here is the interesting question that we want you all to answer based on the properties of dq that we have discussed till now which of the following data structure will be more ideal for implementing dq in data structure what i mean by ideal is the time and space complexity for implementation strategy that you decide should be minimum the options that we have are circular array singly linked list and doubly linked list it will be interesting to see how many of you guys will get this right so guys do leave your answers to this question in comment section below in a week's time we'll be announcing the right answer and you all can check it out on that note let's dive further and understand the representation of dq using circular queue and yes circular queue is one of the answers for previous questions we'll understand why it is best in upcoming slides but please check the complexity analysis of other two strategies to decide your answer for the previous question as multiple answers can be accurate for that question now let's understand what a circular queue is well a circular queue is nothing but the extended notion of linear q as it follows the first in first out principle with the exception that the last position of this particular queue is connected to its first position making a circular link the circular link is responsible for naming of this queue as circular queue or ring buffer let's understand how a circular queue operates with the help of simulation this is the illustration of a circular queue having size 5. as the position of rear pointer keeps increasing a new element will be inserted in this queue until the rear pointer reaches the end of q but what if we perform dq operation now if we perform the deletion then the empty space will get created at front of q however this space can further be utilized in this particular type of queue by making circular incrementation of rear pointer or circular link so if we increment the rear pointer from its index 5 to index 0 we can utilize empty space by making new insertions using this feature of circular queue we can implement both insertion and deletion at both the ends of queue let's understand how we can do that in upcoming slides the first type of insertion is a pretty ordinary one in this insertion we'll increment the position of rear pointer to insert a new element the arrow shown in blue is rear pointer and the arrow shown in orange is the front pointer so as you can see once we increment the rear pointer new elements get inserted this is how the insertion using rear node happens now what if we want to perform insertion using front end in order to perform the insertion using front node we'll have to make front pointer reach to the end of q the only possible way to achieve that is to set front pointer equal to max size -1 manually this command will allow a front pointer to reach the end of queue for performing insertion and for further insertions we'll just have to decrement the front pointer location for inserting new elements this is all about insertion now that we have implemented insertion from both ends let's move on to the deletion operation primarily we'll look into the deletion using front node in order to delete elements using front node we'll have to increment the front pointer until it reaches the end of q and once it reaches the max size we'll use circular incrementation to bring the front pointer to the beginning of queue while performing these incrementation meanwhile the elements will be removed from the queue next up is deletion using rear end for performing deletion using a rear pointer we'll have to decrement its location once we decrement the rear pointer location the element will get removed from the cube now moving ahead we'll look into the different operations that can be performed on a double ended queue basically there are four primary operations in the dq which we have already understood in the representation of dq using circular queue these operations are insertion and deletion at the front and insertion and deletion at the rear additionally the circular queue implementation of dq cost us big of one which is the most optimal complexity that we can hope for having said that let's dive into the implementation of these operations using a circular queue we'll implement a double ended queue using circular queue in order to do that we'll use c programming language and one dimensional arrays so without wasting any time further let's move to the code editor now in order to get started with implementation of dq we'll have to create array and pointer variables so let's do that and we'll name this array as dq and we'll provide 100 as initial size next we'll create pointers and rear is equal to minus 1. now we'll also define the maximum size for our queue using define call size as 5. after done with this initialization process will start working on insertion from front node we'll declare a function named as void front insert so let's do that void front underscore insert and insert this function will pass an argument into z to insert an element now while performing insertion we should always check if the queue is full or not because if it is full then the insertion won't be possible so for that we'll write condition if front is equal to equal to zero and and rear it's equal to equal to size minus 1 inside and braces or front is equal to equal to rear plus one printf tq is full insertion it's not possible okay otherwise if both the front and rear node are pointing to null memory index or minus 1 will manually set our front pointer to index 0 to make the first insertion into the queue and we will insert the element at new location or index 0 where the front pointer is pointing so for that what we'll do is we'll write another condition with lc block else if front is equal to equal to -1 and and rear is equal to equal to minus 1 then make front is equal to rhea is equal to zero and dq front is equal to z now if we want to insert the element at the last node of q then we need to set front pointer to the max size -1 location to do that we'll write this condition else if front is equal to equal to 0 then front is equal to size minus 1 and dq front is equal to z if all these above mentioned conditions fail then the front pointer is already at the last part of q and it just need to decrement its location for inserting element in empty spaces as discussed previously so to do that we'll write one more condition using else block so let's do that else front is equal to front minus 1. and dq front is equal to z now we have successfully implemented a front insert function so let's move forward and work on another function that is called as void rear underscore insert and will pass g as an argument to insert an element now as done previously we will first check if our queue is full or not so let's do that using if condition if front is equal to equal to zero and and ria is equal to equal to size minus 1 inside braces or front is equal to equal equal to equal to rear plus 1 then printf dq is full next if there is no element in an array we'll manually set the rear pointer to index 0 for new insertion so for that we'll write condition else f front is equal to equal to minus 1 and and rear is equal to equal to minus 1 then set rear is equal to 0 and insert dq rear is equal to z otherwise if rear pointer is already at the end of q then we will bring it to the beginning of q so for that we'll write condition else f rear is equal to equal to size minus 1 then being rear to index 0 and dq rear is equal to z if all these mentioned conditions fail then what we'll do is we'll write else condition and we'll simply increment our rear pointer to make an insertion so for that what we'll do is we'll create else block and we're inside it we will do rear plus plus and we will set dq rear is equal to z with this we have successfully implemented void rear insert function so now let's move into deletion functions first we'll create void front dq function void front underscore dq and there is no need for any argument for this function to begin with this function first we'll have to check if dq is empty because we cannot delete elements if there is no element to delete so for that we'll write f condition f front it's equal to equal to minus 1 and and rear it's equal to equal to minus 1 then printf there is no element to delete inside this dq in the next condition we'll check if there is only one element inside the dq if there is only one element then we'll set both front and rear to minus 1 manually for that what we'll do is we'll create else if condition else if front is equal to equal to rear then printf i'll add slashing to take this to the next line the deleted element from the front is modulus d comma dq front and we will set front is equal to minus 1 similarly rear is equal to minus 1. now if both these above mentioned conditions fail then we will delete the element from our front node the first removal will be in a case when the front pointer is at the end of queue so for that we'll write condition else f front it's at end of queue that is size minus one and what we'll do is we will printf slash and the deleted element from the front edge modulus day comma dq front comma and another condition will be when the front pointer is at the beginning section of a queue for that we'll write else condition printf slash n the deleted element from the front is modulus d comma dq front with this we have successfully implemented our front dq function now let's move towards next function that is deletion from the rear end for that we'll create new function name void dq underscore rear and this function also does not need any argument so next what we'll do is we'll create condition to check if the queue is empty or not so if front it's equal to equal to minus 1 and and rear is equal to equal to minus 1 then printf printf slash n there is no element to delete inside the queue now let's move to the next condition in next condition i'll write else if front is equal to equal to ria then printf some statement and set run is equal to minus 1 along with rear is equal to minus -1 and that statement will be the deleted element from the d2 using rear node as modulus d comma dq rhea now if both these above mentioned conditions fail then we'll have to delete the element from our rear node the first removal will be in a case when rear is at the beginning portion of a queue for that let's write a condition else if rear is equal to equal to 0 that is at the beginning part of q then printf some statement and rear is equal to size minus 1 that is setting it to the max size of cube and the statement that we will return is backslash n the deleted element from the rear node adds modulus d comma dq rear in other cases we'll just have to decrement the size of rear pointer and delete the element so for that we'll write else condition printf some statement and set rear is equal to rear minus one that is decrementing the size of rear pointer and the statement that we'll write as backslash n the deleted element from the rear node as modulus d and comma dq rhea well here is one spelling mistake so let's remove it okay so with this we have successfully implemented our void dq rear function now we will implement one more function to display the state of our dq the name of that function will be void display and this function also does not need any argument so we'll begin with implementation of this function for this we'll create an iterator element and we'll set it to the front pointer and we'll printf backslash n elements inside the dub double ended queue are next line will enter into while loop to print those element i not equal to rear printf modulus d comma dq i and will increase the value of i by i plus 1 modulus size and outside this while loop we will print f modulus d dq rhea okay with this we have implemented all the required functionalities for our dq so let's work on driver method that is main function in order to check the output of our program so let's work on this main function first we will insert few elements into our queue so i will insert first element using front insert next let's insert one more element from front node using function front insert and this element will be 23 next we will insert elements using rear node underscore insert and we'll pass 17 now next we'll insert 12 and we'll insert one more element using this rear node only insert 47 now we will display the state of our q after performing all these operations and next we will dequeue few elements so for that we'll use front dq function and next we will dequeue from rear node so dq here and after performing deletion operations will also display the state of our queue so let's call display once again and let's add one more command return zero okay so with this we have successfully implemented our program for dq implementation so let's run it and check if it is working fine or not okay so we are getting output here but uh display function is printing output in weird manner so let's work it out so all we have to do is we'll have to add space before modulus t here and here as well so once done with this let's recompile our code okay so now our output is clear so let's check if it is perfect or not so the first insertion that we made was -5 second was 23 from the front end so 5 should be getting inserted before 23 so minus 5 is getting inserted before 23 but as we are inserting it using front pointer so 23 is remaining at the front now after these two insertions we are performing insertions using rear pointer the first rear insertion was 17 then 12 then 47 and these elements are getting inserted so let me show you how they are getting inserted in exact same order so look here so elements inside the double ended q are 23 minus 5 17 12 and 47 that means the insertion is in right order after that we deleted the element from front node so the front node is at 23 so 23 is getting deleted after that we deleted the element using rear node so 47 is getting deleted from the rear node we are still getting 23 here that means the dq function is incomplete so we'll have to change it so let's go to the dq function and i guess it was from front end so we'll need to change code for our front dq so okay so in this case we haven't brought our trend pointer to index 0 so let's do that here and once we do this let's recompile our code again okay so now you can see that the 23 is getting deleted with this we have successfully implemented our dq function now let's move back to the powerpoint and understand few applications of dq the first application that we are going to discuss in detail is palindrome checker you all must have heard about the term palindrome the palindrome is a specific word or number which reads the same backward as forward for example the word radar it reads the same from both the ends so using the dq we can implement the palindrome checker program with complexity big of one the string which you need to check will be inserted into a dq and after that it will read from both sides if the reading is the same then that string will be considered as palindrome the next application of dq is its use in multiprocessor scheduling but what precisely is multi-processor scheduling and why do we need it well the system implemented in the old days use single processor scheduling to manage the computing processes when multiple processes need to be executed by a single core or cpu then the process take more time to implement and thus the system lacks computing power but the multiprocessor scheduling implemented in modern computers resolves that problem using a double ended queue suppose we have three processors in our system and each processor has some processors to execute each processor maintains a dq that contains threads that are ready to execute the processor executes a process and if a process creates a child process then that process will be inserted at the front of the dq of parent process suppose the processor p2 has completed the execution of all its threads then it steals the thread from the rear end of processor p1 and adds it to the front end of the processor p2 the processor p2 will take the thread from front end therefore the deletion takes from both the edges this is also known as a still algorithm in process scheduling in this session we will learn about stacks and queues in data structures what is a stack so to define stack in a more generalized way we can consider stack as a linear data structure that follows lifo order or lost in first out order or another way of putting it down is first come last out order so some of the basic operations that can be performed on stack are insertion and deletion and that can be done only at the end which is called as the top of the stack now let us understand the basic operations on stack so the three fundamental operations that can be applied onto a data structure like stack are push pop and peak so the push operation involves inserting a new element from the top of the stack the pop operation involves removing the element from the top of the stack and finally the peak operation which returns the topmost element from the stack without removing the element from the stack now we shall go through some generalized examples of stack so some of the generalized examples of stack are you can see a stack of books here and a stack of utensils stack of coins and stack of dollars of bills now let us go through a practical example based on stack and data structures we shall be using c programming language for this particular example so you can see that on my screen i have an example for stack data structure don't worry about the code this code will be attached in the description box below and you can always have access to it and you can run the same code in your personal system so that you have a deeper and better understanding of the program now let's quickly run this program so there you go you can see the program is getting executed now so you can see that the program got successfully executed and the elements are being inserted into the stack now the elements are a b and finally the elements are popped back again that is b a and the last element that is popped away from the stack is a and you can see that the stack is currently empty so top is pointing to -1 now with that let's get back to the presentation again now let us understand some of the applications of stack so one of the applications of stack is function call or recursion the recursive function call is also known as the called stack whenever a function is called then the function goes to the top of the stack now another important application of stack is expression conversion there are three types of notations that is prefix notation infection and postfix notation so these particular notations can be taken care by using stacks in real time now the next one is checking parentheses stack is used to check if the given parenthesis are balanced or not sometimes if you forget to add a parenthesis then the compiler will throw an error so using stack this can be found if there are balanced parenthesis used in your program or not balanced parenthesis means opening and closing brackets are of the same type that means if you have two open flower brackets then you need to have two closed flower brackets it should not be an equal it should be completely equal to complete the code segment now another application of stack is expression evaluation stack can be used to evaluate the expressions as you can see here we have an expression that is 6 plus 2 star 3 minus 12 divided by 4. now this particular expression will be evaluated based on the precedency table so the stack is used to check the precedence and then the expression gets evaluated into the result which is 21 right over here now another application is the tower of hanoi tower of hanoi is a mathematical puzzle which consists of three rods and n number of disks of different diameters all the disks are placed on one rod one over the other and in ascending order of size similarly into a cone-shaped tower now we will enter into the next segment where we will discuss about queues so what exactly is a queue a queue is a linear data structure that follows the fifo order that is the first and first out whereas stack followed first in last out so this is one of the fundamental difference between stacks and queues so we'll be discussing those in the next section for now let's continue with the operations on queue the queue is an ordered list in which insertion is done at one end that is called rear and deletion is done at another end which is called front the operations on qr nq operation that adds a new item to the queue if the queue is complete then there is an overflow condition dq operation is the operation which deletes an item from the queue and if the queue is empty then there is an under flow condition through as an exception now let us understand some of the basic examples of q you can consider the patients at hospital registration and you can also consider an example of customers making use of atm now let us understand the types of queue so there are basically three types of queues those are circular queues doubly ended queues and priority queues now let us understand the circular queue in a circular queue the last element points to the first element to form a circular link circular queue is also known as ring buffer insertion is done at the rear and deletion is done at the front as discussed before now we will go through the doubly ended queue in doubly ended queue both insertion and deletion can be done at both rear and front of the queue now the last one the priority queue in the priority queue the notes have same predefined priority insertion can be done as the arrival of the notes note having the least priority will be the first node removed from the queue now we will go through a general practical example of queues and then we will go through the applications of queues now on my screen you can see an example for cues don't worry about the code this code will be attached in the description box below and you can always have access to it and learn executing this on your own system so without further ado let's start to execute this code so you can see that the code got successfully executed and the terminal is asking for us to give an operation so the first one is to insert an element into the queue second one is to delete an element and the third one is to display the elements in the queue and the fourth one is the quote let's insert so now let us insert an element into the queue that is 10. now let's try to display the elements in the queue for that i need to select the option number three and there you go the queue has element number 10 now let's try to delete that element so that we might have to choose the second option so you can see that the element got deleted from the queue and the element deleted from the queue is 10 and you have another choice now so let's try to quit it now for that i need to select the option for because we have seen how to insert view and delete the element let's not make further delay and let's quickly enter into the next part of our session that is the application of queues so the first application of queue is breadth first search breadth first search or bfs traverses a graph in a breadth what direction and uses a queue to remember the next node to start a search the second application is level order traversal entry level order traversal processes all the nodes of a tree by depth first the root then the children of the source next one is first come first serve cpu scheduling first come first serve fcfs is an operating system algorithm that works on queued requests and implements them according to their arrival now the fibonacci fibonacci heap is a data structure that implements priority queue operations consisting of the collection of heap order trees now our last segment that is the comparison between stack and queue so at first both stack and queue are linear data structures and stack follows last in first out whereas q follows first in and first out and when you're considering stack the insertion takes place at the top and deletion takes place from the top as well whereas when it comes to stack the insertion starts from rear but deletion or elimination of the element from the queue starts from the front in stacks the insert operation is called as push and deletion process is called as pop in queues the insertion is called as enqueue and deletion is called as dq in stacks we mainly maintain one pointer to access the list that is called top which always points to the last element present in the list in queues we maintain two different pointers the first one is the front pointer which always points to the front element or the first element inserted in the list and the next one is the rare pointer which always points to the rare or the last element inserted into the list stack is used in solving problems that work on recursion whereas q is used in solving problems having sequential processing so these are the fundamental differences between stacks and queues in this session we will learn about linear social algorithm its complete logic and how to program and implement it in real time now let us try to understand what exactly is searching searching in data structure refers to the process of finding the desired element in the set of items the selected item is called the target element any data structure such as an array linked list tree or graph can be used for searching a set of elements in data structures searching can be categorized into two types first type is the sequential search in which we check the elements in a data list or an array one by one in data structures searching can be categorized into two ways the first type is a sequential search in which we check the elements in a data list or an array one by one an example for sequential search is linear search now let us learn about the next type of searching approach the next type of searching approach is the interval search approach interval search divides the search in half by repeatedly targeting the center of the data set the binary search algorithm can be an example for interval search we will go over the binary search algorithm in detail in our upcoming video after understanding the logic of search and the types of search we will get into understanding what is linear search algorithm the linear search method is a simple search technique in this type of searching approach we perform a sequential search across all objects one after the other every element is examined and if there is a match found then the specific element is returned otherwise the search will continue until the data gathering is complete let us go through an example for better learning experience on my screen we have the following elements 50 10 20 30 70 40 90 60 as randomly distributed elements let us imagine that our target element is 70. we found that our target element was 70 using linear search strategy so how does it work in the next segment we will look into the working terms of linear search algorithm the simplest method of searching the data collection is the linear search starting from the beginning of the data set each element is examined until no match is found the linear search is completed after the item has located in the first stage we compare the first element that is 50 to the searched element that is 70. we will go on to the next element because 50 and 70 are not matched we will compare the second element which is 10 to the search element that is 70 in the next step and once more there is no match found then we have the element 30 as the next comparison and 70 and 30 are not matched we have the next element that is 20 in the fourth phase and there is no match when we compare 20 with 70. moving on to the following stage we have the data element 70 and after comparing 70 with the search element there is a match we will now have the searching and display index as 4 and this index contains the searched element we now comprehend the pseudo code of the linear search algorithm after learning the working terminology of linear search algorithm first we have a function called linear search which has two variables in its parameters the arrays name which is an array and the search variable which is the value then using a follow we must search for our target variable by analyzing all the data elements in the data set with the condition that is the search item is identical to any sets value we must return its index value now we must stop searching once the searched value has been discovered then we will close our if and for loop as well as the linear search function we will now look into the complexity of linear search algorithm after comprehending the pseudo code the complexity of linear search algorithm is divided into three categories the best case which is the big o of one the average case which is the big o of capital n and the worst case scenario which is same as the average case which is the big o of n here n is the number of data items to be sorted let us look into how all these complexities of linear search algorithm play out in detail first we have the best case which is big o of n as a result the best case scenario happens when the search element is found in the data sets first block as a result the search takes a constant amount of time here is an example of an array with 50 10 40 20 30 as the elements now our search element is 50 which is located in the first location of the array then there's the typical case of linear search algorithm which has big o of n and occurs when the search element is in the middle of the data set or any point of the data set with the array containing the same search element 50 we can easily see that the element 50 is present in the center of the array at the location number 2. finally we have the worst case which is big o of n which is same as that of the average case of the linear search algorithm and happens when the search element is in the last block of the data set as a result of the number of searches required is proportional to the number of elements as demonstrated in this example the search element 50 is found in the last block of the array index which is 4. in the next segment we will look into some real-world instances of linear search algorithms according to the first application of the linear search algorithm linear search is particularly efficient when it comes to discovering a particular string next we will look into the second application of linear search algorithm when a data set has only few elements linear search is the simplest to implement the final real world application of the linear search algorithm is with the help of telephone directory you may find out the name of a person with the phone number 123. can be implemented easily using linear search algorithm now let us have a look at the linear search algorithm working in practical demonstration so on my screen we have an example for linear search algorithm we have included three libraries standard input output standard library and console input output library then we have entered the main function where we have declared an array with maximum size of 50 elements a counter variable i a variable named target where we would store our searched element and finally num variable where the number of elements in the array is recorded then we have a printf function to ask the user how many items are there in the array and then we use a scanf function to allow input from the keyboard so we have added percentage d format specifier to the scanner function which is used for numeric values and num variable then using a for loop we will try to print all the items in the array starting with 0 and ending with num variable which is the last element then we will enter our search element which we want to find among all the elements of the array and as previously said we'll store the found element in the target variable following that we will use the for loop to examine all the elements in the array then we use the if statement to check for the element is identical to our searched element or not if the element is found we exit the forum and we will break the keyword and if the target values location is less than the number of elements in the array then we will return the location otherwise if the value location is greater than the number of elements in the array then the search will be unsuccessful and we won't be able to find the searched element now we will compile this code and see the output so there you go the code got successfully compiled now it is asking for the number of elements in the array let me give us five elements now let us enter the elements into the array let us enter some random elements now we have entered the 5 elements let me provide the searched element as 2. now we have found the target element to be found in the location 2 that is 0 1 and 2 yeah 2 is located in the second index location and with that we have reached the end of day 1 so far we have learned the data structures on day 2 of software development learning we will reveal the next stage where you get to master the algorithms thanks for watching and don't forget to subscribe to stay tuned for more from simply learn hi there if you like this video subscribe to the simply learn youtube channel and click here to watch similar videos to nerd up and get certified click here you