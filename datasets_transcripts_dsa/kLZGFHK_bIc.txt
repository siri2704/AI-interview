foreign [Music] can I get a plus one in the chat if I'm clearly audible as well as visible okay so without any delay we'll be starting today's lecture okay thank you Irish Patel for the confirmation I wish okay so uh in today's lecture like uh first of all welcome everyone and can I know from everyone like whether uh you were able to solve yesterday's last question which I gave you in the homework yes or no okay so without any delay we'll be starting today's session and in today's session I'll be discussing few of the important algorithms and that are going to be Advanced algorithm right so basically I'll be teaching you a technique that is called disjoint sets so basically an entire New Concept will be covered in the session and along with that I'll be discussing uh tries as well okay so I'll be giving you the idea about what is a tri data structure and we'll be solving a few of the questions on try data structure okay so is it clear yes or no in the chat box okay I see okay so let's uh start today's session without any delay so how many of you know about uh disjoint sets what is a disjoint set so basically have you heard the term disjoint set so I've shared one of my screen so is my screen visible yes or no in the chat box if it is visible plus one would work for me okay so let's start with this session and in today's session we'll be seeing disjoint sets thank you okay so someone answered sets which does not have any common element right okay so that is correct if we just give me a minute I think I have some technical issue with my laptop okay so anyone else what do you understand by disjoint sets thank you so now am I clearly Audible and visible I guess I'm clearly audible I am back I had some issue with my uh so just a minute I'll be getting back in just a minute [Music] foreign [Music] [Music] okay good evening Aditya good evening okay so I guess my screen is visible to everyone clearly right okay so I was talking about disjoint sets okay disjoint sets so basically you might have heard about components in a graph right we have heard about components components of a graph so we know that what is a component right like a graph can be made up of different different components component one component two component three component four and completely this is called a graph right we know about what is a component now we also know that let's say uh an entire graph can be a single component as well right and in each and every component let's say this is the component in which this many nodes are there this is component number one and this is component number two right so basically let's say this is the second component and I am sure that I cannot Traverse from this node to this node in this second component right so basically a set is something like that so design set means you can consider this component as a set number one and you can consider this component as set number two and you know that there are some number of elements or some some number of nodes that will not be present in this S2 okay so S2 has also a different set of nodes I mean different set of elements and both the sets are not going to have any common element so that means they are called disjoint sets so is it clear yes or no in the chat box clear yes or no in the chat box if it is making sense plus one in the chat box will work okay so that is a disjoint set now what we have to do let's say what we are going to study inside this joint set so first of all let me give you an idea about uh some elements okay so let's say I have a set of elements one two three four five six and seven okay and now I am creating a set of each and every individual element okay so over here this is an element one element two they are individual they are not at all in the same set everyone is in a different side okay four five here is six and seven and every set has a root node okay every set has a parent node you can call it as a parent node and with the help of that parent node the entire set is being identified okay so everyone is parent of itself for now and now we can observe over here that if I want to now let's say if I want to say that I want to combine this two different sets I want to combine the set in which parent is one and I want to combine the set in which parent is two I want to combine them so how will the combination look like so the combination will look like this so now this is a complete set and both the elements 1 and 2 are present inside this set okay and now as I mentioned that each and every set is going to have a parent node so I can make either this one as a parent or either two as a parent so let's say I uh given the privilege to one and now one is the parent node now let's say I want to combine these three elements I want to combine this set and this set right so what I'll be doing I'll be doing the same thing let's say will create a bigger set in which all the three elements will be present and I need a parent node let's I have created this as my parent so now how many different disjoint sets are visible how many different sets are visible over here can anyone from the audience how many design sets are there over here right now is it 2 3 or 4 5 what is the number this is set number one this is set number two this is site number three and this is set number four so whether there are four different design sets Okay so basically you can keep on combining two different sets Okay so that function or that process is called Union of two sets set one and set two everybody correct so this process is called Union of two different sets so now based on this I I will be having a question I'll be sharing the link of that question in the comment section and then we'll be discussing that okay so the first question which will be discussing today is called the union find okay I've shared the link in the comment section so we'll be understanding the disjoint set entirely a new topic with the help of this question okay so and we'll be implementing that algorithm Union and find over here in this question so basically we are going to understand with the help of this okay so over here there is something called as Union and find and there are different number of queries given to you okay so let's first of all go through the problem statements we'll be having a better understanding what actually we need to do so this problem is to implement this joint set Union there will be two incomplete functions namely Union and find and you have to complete these functions so basically it means it is saying that these two functions have to be completed right and what is Union join two subsets into a single set and what is is connected determine which subset a particular determine which subset a particular element is in okay so is connected means you have to find out that uh whether the set 1 and set two which you are passing as an argument the elements of those set are they connected or not so that is is connected function will return will return true or false based on it right and this can be used for determining if two elements are in the same subset so basically it means that two elements are in shape subset or not that can be determined with the help of is connected method so example number one it says there are n different elements so I can see over here five different elements are present in this and there are four different queries so first query is Union you have to combine the set containing one and three so basically let's take this example and let's try to understand what is the function Union okay so basically there are five different elements and over here first of all you'll not focus on the number of queries we first of all need to understand the uh algorithm or the Union process right so n is equal to 5 that means five different elements one two three four and five they are different set they are different sets okay and each and every side is a parent node so this is having a parent node this is having a parent node and they are parent of themselves now over here let's say the first argument given to us is Union 1 comma 3. so what does it mean so it means that you have to combine these at one or the element in which set one is present you basically have to combine the set that contains element one and the set that contains element number three so basically I want to combine this two so after combination the elements in this set is going to be 1 and 3 right but now who is the parent so earlier they were parent of themselves so what I'll be doing the parent of this two different set is one and three so what I'll be doing let's say I'll be making one as the parent of three I'll be saying that parent of 3 is equal to 1 and 1 is going to be the parent of this entire set Now 1 and 3 are present in the same set in which one is considered to be the parent load so now I have you applied the Union on element one and three is it clear till now are you getting what is the union process actually a plus one in the chat box if you guys are able to understand what is the process Union okay so I see I see no one okay so if one is parent shouldn't uh 1.23 so basically over here either you can make one as the parent of three or what you can do you can do the other process as well earlier it was one was parent of one and three was parent of himself so I want to make 3 as the parent of his entire set so I can do that as well I can do that as well so what I'll be doing one will be saying that now my parent is equal to 3 and 3 is the parent of this entire set both of them can be done and both of them are correct as well okay okay I hope it makes you clear so now basically I'm saying that one is the parent of this set now again let's say we have one more functionality that is Union I have to say Union let's say the this set in which element 3 is present and let's say five I have to do Union of three and five so I can see I'm saying this Union is trying to say that combine these two set that means these two assets needs to be a union right so now basically how to do that over here first of all we need to know that who is the parent node of three I mean the set in which 3 is present this is the set in with 3 is present and who is the parent of this entire set so I have to figure out who is the parent of the set in which 3 is present so now basically over here I am able to see that for this set parent is 1. right so parent of 3 is equal to 1 and now for the 5 for this element 5 as well we need to do the same thing so I have to see that who is the parent of 5. 5 is parent of itself right so are the parent of both the elements same is 1 equal to 5 yes or no no 1 is not equal to 5A basically it means that they are not the part of the same set so now what I can do I know that parent of 3 is equal to 1. and parent of 5 is equal to 5. so now this is a complete set different set and this is a complete different set so now what I'll be doing I'll be combining both of these sides I'll be combining both this that is either I will be saying that 5 is the parent of 1 or I'll be saying that 1 is the parent of 5. so now let's try to visualize so basically I am trying to say this needs to be than Union and now what I'll be saying 5 is parent of itself so what I'll be doing I'll make one as the parent of 5. now this is a completely new set are you getting my point what is the union process on element basically this is what union means okay so now there is one more algorithm that is find algorithm so basically or whether you can observe that parent of 3 is equal to 1 so how to know who is the parent of element three so that algorithm find algorithm will help you to find the parent of any element okay so basically with your final algorithm I can find any elements parent so find algorithm how does it work so let's say I am I want to find the parent of the set in which 3 is present right so basically I want to find the parent of the set in which 3 is present so I'll be calling find three so what will the uh what what does the process look like so basically this is what currently I am standing at this node 3. now what I'll be doing I'll be going to the parent of three so I can see parent of 3 is equal to 1. now I want to find the parent of this entire set right so now I'll be asking the question that who is parent of one and we know that only only parent will be the parent of itself I mean the node which is called the parent node will be parent of itself okay who is the parent of one one and you can observe that one is the parent and its parent is also itself basically if you got it you got it right so basically one is the parent of itself I I can see that who is the parent of one if this is the condition for any of the node if I am saying that parent of some node is equal to node itself then that means this node n is called the parent node so I can see this condition is Satisfied by 1 and 1 is the parent of this three so basically this find function will return 1 that it says that the set in with 3 is present as the parent one similarly to similarly if I try to find who is the parent of node 5. so again the same process I'll be checking who is the parent of 5 I can see the parent of 5 is 1 and now I'll be asking the question who is the parent of one I can see one is different of itself right so find Phi will return 1 and this find function will be returning the parent node and this find function can be used over here this part okay so that is how it works so basically over here there is nothing like duplicacy or something needs to be handled it is see as I explained you can imagine this sets that is this joint set as a component of a graph we know that there are different different components right no this set data structure it is not like the set data structure okay it is completely different from that okay so basically imagine set as a component you can observe over here in the graph as well in the graph as well you can observe that there are different different components of a graph right and if you want to combine the elements of this two component you need to have an edge between them right so that is how a design set looks like so that you can imagine them as a component a basic idea of what you might have missed out so now let's try to understand this with the proper algorithm okay so basically now let's say I'll be having this many elements n is equal to five number of elements are present okay so that means one two three 4 and 5. so now there are let's say different different queries that Union three and four Union five and let's say one and then let's say find the parent of 3 and let's say find the parent of let's say five again Union something Union two and five okay so now let's try to understand how we will be able to implement this part okay foreign okay so basically now let's say I have this many elements and I need to apply all these queries so imagine them inside an array imagine them inside an array so elements will be the indexes one two three four and five right and now over here I have let's say I've created an array of size n plus one so this is what the element looks like these are the elements I will treat the indexes as the elements and now this is called the parent array this this is called the parent array which will be helping you to find that who is the parent of this node okay and initially I want every node to be the parent of itself I want every node to be the parent of itself okay so basically I want every node to be dependent of itself so I'll be storing the values one two three four five as it is inside this so this is not required this 0 is not at all required because we do will not be having any element equivalent to zero so I am just erasing but you can imagine that 0 index is also present inside the array and now I have denoted that every node is the parent of itself so I have five different disjoint sets whenever you see this kind of condition is equal to n then that means the node n is the parent of that set so now over here let's try to apply the first query that is Union 3 comma four and three and four so how will this Union process look like so now as I mentioned that first of all you need to find the parent of this 3 and 4 that which is the set in which this 3 and 4 is present so you need to know you have to call the algorithm find 3 and find four so find 3 will return so how will this find function work so let's first of all understand the find function let's say I have to find the parent of node number three so what I will be doing this is a recursive process and what is the condition of parent node this is the condition of parallel the condition is that if parent of the node is equal to its index I mean the value is is equal to E equals so basically if I is equal to the value then that means that is the parent node if you face this kind of condition that parent of n or the element at the index n is equal to its index okay so if this is the condition then that means n is your parent node so this will be a recursive function and it will be returning the node n let's say the argument looks like this integer and you have to find the parent of this node n and now what if this is not the case if what if this is not the case I have some different value at the current index n so in that case what I'll be doing I know that parent of an will give you the parent of node number n parent of any value will give you its parent right so what I'll be doing let's say it is equal to U so I'll be again finding the parent of U and I'll be checking who is parent of U let's say it is V so I'll be again checking who is the parent of V and if let's say if this is the condition that parent of V is equal to itself then that means you have got the parent node and V is your parent node so what I'll be doing I will be again calling the recursive function to find the parent of its parent of the node number n who who is the parent of node number n so that is the function find function will be finding its parent and this this function will return the parent hence I'll be using a return statement that means whatever is the parent of this n will be returned by this find function so now let's try to visualize I gave you an idea about how the algorithm looks like so let's say I have to find the parent of three and let me copy this array over here oops one two three four and five so this find function I will be finding the parent of node number five so I'll be checking whether at this index the value and the index are same or not yes I can see parent of 5 is equal to 5 I can see value and the index is same so that means 5 is the parent of itself so 5 will be returned okay let's say now I am finding find three so I can observe at this position also 3 is part of itself so this functional return will return 3 and now let's say over here this is the condition let's say I'm just changing one value now again if I have to find the parent of 5 what will be the process so find the parent of 5. so is the parent of 5 this value it is equal to 3 so I'll be checking who is the parent of three so again find the parent of three I can see 3 itself so 3 is the parent of the entire set in which five is present till now was it clear yes or no in the chat box foreign so this is how the find function works like and this is the visualization of the algorithm to find the parent of any node okay and over here there is one more technique that is called path compression technique which I'll be explaining uh to you that what is path compression and Union by rank okay so first of all let's complete find the basic find algorithm is this algorithm and now in order to advance this algorithm we can have path compression to find the parent of any node okay so I'll be explaining that part along with the other rest of the part okay so this is the basic algorithm to find the parent of any node now let's say I have to Union three and four so first of all let's get back to this question that was Union three comma four so first first of all I need to find parent of three and we know we know that how to find parent of three and where is our array our array is over here so I'll be going to the index number three and I'll be checking who is the parent of three I can see three three himself is the parent of three so this function will return three so now again doing the same thing with find 4 who is the parent of 4 I can see the parent of 4 is himself so 4 will be written by this algorithm so now I have got is the parent of both the functions both the elements 3 and 4. now what I need to do I need to combine them right because this is the part of our Union function so I need to combine this set let's say parent of 3 is equal to 3 and parent of 4 is equal to 4. now I need to combine this set 3 and 4. so how will we do that so what I'll be doing I'll be making let's say I'll be doing I'll be saying that parent of 4 is now 3 or you can say parent of 3 is now 4. so basically storing something like this and I'll let's say I'm calling it as u and v so let me name three and four as well let's say 3 is called U and 4 is called V right so I'll be finding the parent of 3 and 4 or you can say find the parent of u and v find the parent of U is equal to 3 and find the parent of V is equal to 4 so this will be returned and let's say I am storing it in a variable called as p u and PV so what is the value of pu I I know that it is equivalent to 3 because 3 is per end of himself and 4 is parent of himself so now what I'll be doing I will be making 3 is the parent of 4 so that means parent of 3 is equal to 4 or I can write it as parent of 3 3 can be called as pu is equal to PV okay so I have said that now this is the statement that will combine both the elements both the elements means both these sets so basically let's reflect that thing over here so I'll do I was doing the union of three and four so let's make so let's make parent of 3 is equal to 4. so now this will be the change over here okay so this is the thing and this is actually the union process this single statement is the union process okay and over here actually this is not Union is not a recursive process defined function or the final algorithm is a recursive process and here you can directly and this Union method so if I convert this part into algorithmic statement it will look like this so I'll be calling the function let's say pu parent of U is equal to I'll be calling the find function to find the parent of U and PV is equal to what find the parent of v and now this statement as it is that parent of p u is now PV and this is the algorithmic visualization of this process okay and I can write down it inside a function that is Union of let's say element u and v so that can be written as first of all pu let's directly copy this part foreign this is our uni algorithm Union is it clear till now yes or no in the chat box if it is clear to everyone we have Union and we have fine function as well now let's imagine uh disjoint said something like this let's say 3 3 is the parent of himself and let's say 4 is like this and two is over here that means parent of 2 is 4 and let's say over here something like this and one is the parent of itself okay so this is a completely different design set and over here one is also a part of it part of a completely different design set so now let's say this kind of condition takes place where you can observe that you have two different design sets Okay so let's uh denote it inside the parent array as well so I can see that parent of one is one and parent of five I can observe over here parent of five is what three parent of 4 is also 3 dependent of 2 is equivalent to 4 and who is the parent of 3 3 is the parent of himself right so now over here let's say in this kind of scenario when you apply different different Union uh algorithm over this entire disjoint set then now if I want to find let's say what will be the time complexity of this final algorithm now I'll be explaining you the path compression technique so basically I'll be explaining you why this basic find algorithm is slower compared to the path compression technique okay so basically it will increase it will decrease your uh like work for finding the parent node okay so the path compression technique is very much important so let's try to find the parent of let's say for example let's say I want to find the parent of 2. so what I'll be doing I'll be going to the index number two and we'll be checking who is the parent of two I can C4 so I'll be going to the index number four and I will be checking who is the parent of 4 again C3 so I'll be again going to the index number three and we're checking who is the parent of three I can see three so this find function so I was following this path from 2 I went to index number four and from 4 I went to index number three and over there over here after reaching at index number three I was able to find that this is the parent mode right so this was the path which I was supposed to follow I was doing I was writing over here right and we came to know that this is the path find find the parent of two and the parent of 2 came out to be 3 at the end right we need to Traverse this much of path because we have not stored that for each and every element what if instead of storing the parent of 2 as 4 and parent of 4 has 3 what I'll be doing let's say if I apply this kind of modification to this uh parent of every element okay so what I'll be doing I'll be saying that I don't want to keep this 4 as the parent of 2. so what I'll be doing I'll be telling that two your parent is directly equal to 3 that means the parent of the entire set and similarly you can observe that now three is parent of itself and 5 is directly connected to the parent node 4 is also directly connected and 2 is also directly connected to the parent node so now there is like very less amount of distance that you need to Travis to reach the parent node right over here this was the depth of this uh tree right this can be called as a tree as well if over here you can observe the depth of this tree is equivalent to 2 or the height of this tree is equivalent to 2. now over here the height of the tree is equivalent to one okay got it so if you reduce the height of this tree then your path compression technique can be implemented basically reducing the height of this tree is what the path compression technique does that means it compresses the path from the node to the parent node parent of what the entire set it reduces the path from node to the parent node that is what the path compression technique does over here we reduced the path right it was directly pointing to 4 and what I did I changed the path and made the pair root node or the node number three as the parent of every other node as well this is what the path compression technique is so basically how does it like how can we implement this so let's get back to the uh process again and the process was to find the root element or the parent of node number two that was the question right so I will be explaining how we can Implement path compression so let's say find the parent of 2 and over here inside the array observe carefully okay so I'll be going to this index number two and I'll be seeing that to who is dependent of 2 I can see 4 is dependent of 2. so where I'll be coming to node number four and I'll be seeing that who is the parent of 4 I can see if 3 is the parent of 4 and I'll be going to index number three and we'll check who is the parent of three and three says I am dependent of myself so basically this was the path you followed right from 2 you went to four and from 4 you went to three so now whenever you find the PATH and backtrack foreign to the previous node what you will be doing now now I'll be returning the data about the parent node so three will be saying that my parent is 3 and 4 will be informed so 4 also will be storing the information that 3 has uh told him right so 4 will store that okay from now onwards three is my parent although 3 is already present now now onwards will be again saying that 3 is my parent so now 4 will inform to its uh parent uh parent method that is parent node the two so 4 will inform its child node that over here I can observe that 3 is my parent so 4 will inform that uh 2 actually 3 is your parent node so I'll be changing the value and now 3 will be stored over here so basically I reduced the path you will be able to observe how the path has been reduced now okay so now these are the modifications which we have done on this entire array now let's say again you are supposed to find the parent of node number let's say 2 again so how will you find the parent of node number two so what you'll be doing you will be going to index number two who is the parent of R2 I can see three so you will be directly going to the parent mode and over here you can observe three is dependent of himself and this path was reduced earlier you you were following this path and now the path is directly to the parent node so this is what what the path compression technique is is it clear yes or no in the chat box a quick confirmation from everyone so that we can move towards the next question as well right a quick plus one in the chat box if this part is clear to everyone any doubt then you can post it on the comment section okay fine so now inside this algorithm how will you like implement the path compression technique what are real life applications so basically this algorithms are used the union and fine algorithm is basically used inside graph techniques okay so you might have solved the question find whether like you have solved the question of connected components in the graph right you have to find out how many connected components are there connected components for undirected graph so in that question what were you doing basically you were following the basic approach to check whether a cycle is present in the graph or not so with the help of this Union and find that can be done in a very less time complexity and graphs where do you use graph the real world application is very much visible to everyone right you use graphs in storing information about your mutual friends use the graphs to store the like let's say to know the shortest path from this city to that City so real world applications are those applications so basically it does not directly have real world applications but indirectly it is affecting at a larger scale okay it because it reduces the time complexity there are many different uh algorithms let's say you have to find the cycle in a graph okay basically inside the crucial algorithm or let's say the find the minimum spanning trees equation in which you have to find the minimum spanning and inside that while creating this set you are constantly looking at whether a cycle is detected or not if I am adding this Edge will I get a cycle in the graph or not right so you need to check whether this will create a cycle or not and for that you can use this unit and find algorithm okay so I hope now it makes it clear to everyone that where can you use this thing okay now so now coming back to the path compression technique you can write down plus one in the chat box if this was clear why in the chat box path compression right so over here now how to implement path compression so what I was doing actually at each and every path let's say let's say uh this is the path to the parent node and currently I was starting from this point so now at each and every point I will be making the parent as the actual parent load so I'll be removing this part this part and I'll be saying that each and every node is having the parent of the entire set so basically single statement over here a single statement that whatever value is returned over here will be stored in the index as well I will not directly pass the information to the parent function but I'll also store the information at my index because that a value which was written by the uh other function was very much valuable and that was the information about my parent of the entire set so I'll be stored I'll be storing that value at my index as well and then passing the information to the calling function I hope this makes it clear but you're able to visualize this part okay so that is what path compression is and this algorithm is very much faster compared to the general find algorithm because you will be decreasing the height of the 3 and now what about the Union function now let's understand what is Union by rank okay so now let's quickly understand what is Union Bank rank so now Union by rank means first of all you need to understand let's say uh let's visualize let's try to give the rank to each and every set over here for this set and for this set let's assign some of the ranks so what is the rank so the rank of this set is going to be 1 and the rank of this set is going to be 2 or you can call it as the height of the tree the height of this tree is one and the height of this tree is equivalent to 2. so now we can observe we can rank is nothing but the height of D3 okay so the rank of this tree is equivalent to two and the rank of this 3 is equivalent to 1. so now again along with the parent information I will be storing the rank of each and every element as well okay so now let's try to store the information of each and every uh I mean what's the created with each and every node so for one the rank is one now for two what is the rank the rank is the rank of the entire set it is equivalent to two for four what is the rank the rank is equivalent to two for three what is the rank the rank is equivalent to 2145 what is the rank is equivalent to 2. so this this is the information which I have stored over here now what is Union by Rank and how it is helpful so first of all now let's say if I want to apply a union of one and five what options do I have I have two different options I can make one as the parent of three or I can say three I can say uh 3 is the parent of one I can do either of that thing let's say I was uh I I was supposed to find the union of one and three so let's say one and let's say four I was supposed to find the union of one and four so what I'll be doing I have I had two options first of all I'll be finding the parent of one I can see it is equivalent to one similarly find the parent of three I can see three I mean find the parent of four not three and who is the parent of four let's say I have applied path compression to this entire thing let's say I I have not applied path compression also okay so basically this is what actually it is now what is parent of four I'll be saying parent of 4 is equivalent to 3 and now after this process as I am going to uh do the union of 1 and 4 I can do any of this thing right parent of p u is equal to PV or I can do parent of PV is equal to P so basically means I can make 1 as the parent of 3 or I can say that 3 is the parent of 1 either of them works so now let's understand let's find out the rank of the final set after applying both the process so let's say if I'm making 1 as the parent of three so what will be the 3 so the three will look like this oh I am saying that first option first option is I can make one as the parent of three and over here this is 4 and over here this is 2 and now the 5 as it is so this is a completely new set right and now what is the rank of this set it is it is equivalent and parent of 1 is equivalent to 1 and this is dependent of this ENT asset it is equivalent to the height what is the rank one two and three three is the rank the rank has increased by making one as the parent of three now let's say always you have to focus on decreasing the rank okay you should not focus on increasing the rank because rank is nothing but the height of G3 and now let's say if I was supposed to find the parent of 2 then I was supposed to Traverse this much of distance right and now let's understand over here if I was supposed to find the parent of 2 what is the distance I need to Traverse I need to Traverse distance equivalent to the rank that is three one two and three and now let's say the other possibility was I can make 3 as the parent of one so I am saying that 3 is the parent of 1 as well five four and two so now what is the rank of this set the rank of this set is equivalent to 2. the rank has not at all increased so now let's say again I was supposed to find the parent of 2 for this set what is the distance I need to Traverse I need to Traverse only distance equivalent to 2 and earlier over here in order to find the parent of two I was supposed to Traverse distance equivalent to three so basically Union by rank says that the Union by rank says that whichever set is having lowest rank should merge with the should merge with the set having the highest tank let's say this is the set one and this is the set two and the rank of set 1 is equivalent to 4 and the rent rank of set 2 is equivalent to two so basically Union by rank is trying to say that you should make or merge set to completely inside set number one because set number one has highest rank between highest rank between both of them right so basically set two will be present over here and now what is the rank of set to set two's rank will remain as it is its rank will remain 4 and 4 only okay so over here you can observe rank of one was lesser than the rank of node number two and over here in this process I merged the larger tree with the smaller smaller tree and over here I merge the smaller tree into the larger tree and merging the small letter into larger tree will not increase the rank it will not increase the height of the tree okay so that is what union by rank says every time try to merge the yeah merge the smaller tree into a larger tree okay so whoever is having higher rank will be will be the final tree and the smaller rank uh subset or the design set will merge inside the larger one so now over here along with this and now how to store this information okay so how to store this information and when you should change the information so let's say again let's go to the basic thing let's start from the beginning in order to understand when to increase the value of rank okay and when will the value of rank be increased if till now everything was clear to everyone can I get a confirmation from everyone if this was clear okay which day structure is this which day structure I didn't get you okay thank you for the confirmation so now let's understand so when to increase the when will the rank of the final three be increased so let's say you have two different uh set this set contains one is the parent of itself and two is different of itself now you have to Union this two sets and what is the rank of each and every set or these every tree has rank equivalent to one both of them are having rank equivalent to one now if I'm merging them so I can do either of that either of the thing right so what I'll be doing I'll be saying that 2 is now the final parent and the parent of two I mean the parent of one is now two not one in itself right so over here in this case the rank has increased from one to two so basically you can increase the value by one only okay if the rank of both the node is equivalent then that means by merging them the rank will be increased that means basically the height will increase for the tree only in this condition when the rank of both the thank you Bank of U is equivalent to rank of v in this case whoever is the final parent is rank will be increased by one okay and that will be the final rank of the new disjoint set okay so that is what I was trying to explain so now let's add these conditions inside this method quickly so basically now over here I will not directly choose any of the node as the parent node I will choose very smartly so that the path is not increased that is the height of the tree does not increase okay so now I'll be checking the rank if the rank of the Pu is equivalent to rank of PV if this is the case then what I'll be doing first of all I can make any of the node as the parent nodes so let's say I am making P USD final parent node so I'm saying that PV is the final parent node so now the rank of only the set in which PV is present will be increased by one sir pict okay and now if this is not the case if I'm applying Union by rank then that means you have to merge the smaller tree or the three with with the Lesser rank in the tree with the rank highest higher higher rank right so else what I am going to do I'll be checking which parent is having lower lowest rank else if the rank of picture is not clear increase the uh video quality which picture is not clear okay so else if the rank of pu is lesser than the rank of PV then that means what I'll be doing I'll be merging that means I'll be merging the small letter into the larger tree so the parent of PU will be now equivalent to PV okay and now if this is not the case then I can say that the rank of PV is going to be smaller than the rank of pu so I can add that part inside else con condition else it means that the rank of PV is lesser than the rank of PU it is lesser than the rank of pu so now I'll be making parent of PV because PV is equivalent to PU okay because PV was having lowest Rank and now I merged the entire PV into pu because p u was the larger tree okay so this is what Union by rank means so I have covered the entire disjoint set part actually there's no inserts I have explained the path compression technique so let's uh again summarize what we covered till now so I explained about finding the parent of any node then we saw how to do the union of two different nodes u and v 2 and V and the other thing was path compression what is path compression and we understood what is the rank what is a rank and what else we also saw Union by rank right so these are the things which we covered till now and now the question is very much simple if you have understood this many algorithms then we can implement the entire question as well so basically let's again understand what the question was trying to say quickly again revising the question so that we can understand what algorithms do we need to apply okay so you can observe that these are the two different Union and is connected function in which I need to if Union function is called then pins you have to join two subsets into a single set and if is connected is called then that means you have to determine whether two elements are in the same set or not okay so it's connected with written true or false so now let's uh completely understand the test case number one so earlier now n is equal to 5 and there is going to be Q is equal to four number of queries so first function is equivalent to Union of Union of one and three okay and now let's first of all create a parent array parent array 1 2 3 4 n is equal to 5 and this is your parent error and where is your rank array this is this is your anchor and initially everyone is going to be the parent of itself so parent of itself two three four and five and everyone is going to have rank equivalent to one initially because we know that a single node has height equivalent to one only now I'll be applying Union of one and three so how to apply Union so basically the unit Union algorithm first of all I need to find the parent of 1 who is the parent of one I can see one is the brand of one and who is the parent of two parent of U parent of U is equal to one this is U and this is V how is the parent of V that is parent of three himself and now Union by rank Union by rank say is that what I have to do I have to merge the uh smaller smaller tree into larger three over here I can observe both of them are having same amount of rank right so basically I can merge either of them and what I'll be doing I'll be making parent of parent of U is equal to parent of V so basically I am saying that parent of one I'm saying that I'll be making three that is this node 3 as the parent of one so over here I'll be storing one okay parent of 1 is equal to 3. so now the rank of the parent node will be increased by one who is the parent node three is dependent node so it will be increased by one and now this is going to be the rank okay so this is the Union function which we have applied right now so basically Union function will not print any kind of output but is connected method whenever you encounter is connected uh query you have to print either true or false but it will be printed in the output itself okay so now it's connected one and two now we have to check whether one and two are in the same set or not how to know is connected you have to find the parent of one and you have to find the parent of two right basically in this manner who is the parent of one parent of one is equivalent to one who is the parent of two parent of two is equivalent to 2 is 1 equivalent to two are both of is like do you see both of them have the same parent no so that means 1 and 2 are not connected one and two are not connected so this will return false that means 0 will be printed in the output okay now the next thing is Union till now was it clear or not parent of one is equivalent to 3. okay yeah yeah okay I forgot to apply this part I forgot to apply this modification and basically parent of 1 is equal into three and then also then both of them are not having the same parent then that means they are not connected so it's connected is connected will return false in that case so 0 will be printed now the next thing is Union of 1 and 5. 1 and 5. so first of all find the parent of one okay so that is equivalent to Union of one and five this is U this is V parent of U that is always parent of one I know parent of one is equivalent to three and who is the parent of 5 who is the parent of five I can see 5 is having parent as himself now what I have to do as I am doing going to do Union I need to merge the smaller tree into larger tree so I need to check rank of both of them what is rank of three I can see it is equivalent to 2 and what is the rank of 5 I can say it is equivalent to one so I'll be merging the small letter into larger tree so I'll be merging 5 into 3. so basically what I'll be doing I will be making parent of 5 is equivalent to 3. so now S3 is the larger sub 3 I'll be making it as the final sub 3 so I'll be marking the smallest sub tree into the larger one so parent of 5 is now equivalent to 3 so you can apply this part so parent of 5 is now equivalent to 3 so this modification has been done okay so that was Union of 1 and 5 and now what is the other query and now let's see what is the other query it it is is connected connected 3 comma 5 what is disconnected three comma five I have to check whether parent of 3 and 5 are same or not parent of three that is parent of 3 is equivalent to 3 and who is the parent of 5 it is equivalent to 3. parent of three is equivalent to 3 and parent of 5 is equivalent to 5. yes see path compression is applied whenever you call the find function okay so basically you don't need to call any path compression separately as soon like as many times you apply the find function you apply the uh find algorithm at that many times path compression will take place okay if it is required then another thing because if already you have done a path competition on this path then no path compression obviously will take place right but whenever you call the find function the next time it will be uh on the same tree if you are on the same path if you call the find function for the next time you'll be getting the answer quickly and fast to the previous manner okay so parent of 3 is equal to three and parent of 5 is equivalent to 5 3 who is the parent of three okay so parent of 5 is not 5 right now one end of five is equivalent to 3 and both of them are having same parent so the last is connected will return true and you can see in the output 0 and 1 is the output so that is what the entire Union and find is and as we have already seen the entire algorithm Union as well as the find algorithm as well as these connected I'll start directly the coding implementation so first of all I'll be writing B if you have any kind of doubt to mention mention it right now okay so first of all I'll be writing down the find function find function will turn V parent of the node right integer let's say and now inside this I will be applying the path compression as well so if the parent of n is equivalent to n that means I have found the parent node and I'll be returning n if this is not the case then what I'll be returning first of all I'll be applying path compression and then I'll be calling the find function and I will be finding the parent of n and this is path compression find function with the path compression and now let's over here inside Union what I need to do I need to find the union of find and parent and the methods or the arrays Rank and parent have already been created and you can observe the initialization each and every parent has been initialized with himself first and rank of every node is initialized as one so you don't need to create any parent and rank function there have been already been created foreign function so now what I'll be doing I'll be doing the union method so I'll be finding the parent of a who is the parent of a I'll be storing it inside PA and who is the parent of b b and qualified now I will be comparing and I'll be merging parent a and parent B using Union by rank so if B rank of PA is equivalent to rank of PV then that means both of them are having same height so I'll be making let's say parent of p a parent of PV will now be equivalent to PA and rank of PA will increase by 1. okay and if this is not the case and that means let's say rank of PA is less compared to the rank of EB if this is the case then what does it mean so it means I need to merge the smaller train to the larger tree so what I will be doing I will be making parent of Pas PV and as if this is not the case then that means rank of PB is lesser than rank of PA and I'll be making the parent of smaller tree that is kind of PB is now equivalent to PA okay so this is the entire Union by rank is it clear and any doubt in uh in this part so now we can write down is connected method it is very much simple first of all find the parent of a so call the find function find a find the parent of B all the find function find B and I need to check if PA is equivalent to PV or not so basically I'll be written whatever this inequality operator suggests okay so I have covered the entire disjoint so you don't have to worry about disjoint sites if you want to practice more you can go through the Articles and re-watch this video in order to understand what is design sets and now you can directly use this in order to solve graph questions as well okay now let's try to compile and run and see if we have any kind of errors okay and we can see parent okay so everywhere you have used PA entire name so let's change this as bad over here as well okay and let's compile and then again and inside the find function we need to pass the parent array as well because dependent array has not been passed whenever you call the find function also pass the parent array okay and now let's again compile and run and see if we have any different errors okay find apparent of N and passing B and we can see the compilation was successfully completed and let's try to submit and see okay and the problem was successfully submitted and we have completed entire design sets so it is a part of your Advanced data structure this technique helps you to optimize all many of the graph algorithm especially in which you have to detect a cycle in which you have to find number of components and so and so forth okay so I hope this part was clear to everyone a plus one or yes in the chat box if till now we've got everything which I explained regarding these joint sets so we can move towards a new topic that will be an advanced data structure and that goes by the name try data structure okay so I'll be explaining that uh data structure in same beautiful manner as I explained this uh design sets are you guys able to understand it very easily was it difficult for you how was your experience so uh design sets see directly you might not get any questions based on design sets but you can get it uh as a part of let's say optimization of the algorithm or optimization of the solution which you have written right so they can ask you to optimize in this time complexity which can be helpful and which can be achieved with the help of Union joint or Union disjoint set yes it's easy it's not that much difficult you're welcome pratik so I I generally try to figure out an interesting way so that you can get a broad idea and shorter amount of time so now let's try to understand what is a dry data structure and why do we need it right I hope my screen is visible so let's move down towards the question number two and this is also the basic uh algorithm implementation of advanced data structure I'm sharing the link of this in the chat box as well you can have a look at the question simultaneously so basically first of all we need to have an idea about what a try data structure is so you might have heard about or you might have learned about binary trees as well right so we know that inside the binary trees what is the let's say or inside the let's say binary search tree okay if I say if I give you an idea about binary search then what is the time complexity to look for an element inside binary search tree so inside the binary surgery we know that the time complexity is equivalent to login with logarithmic of n right we know that the time complexity is equivalent to LOG of n log of n to the base 2 and now let's say if we have uh ternary Tree in which if I'm converting this entire binary 3 into a ternary tree let's not take the binary search tree or turn the research tree just a simple binary tree this is a binary tree and let's say this is a different terminatory and now let's say if I want to convert this entire into a terminatory that means each and every node can have three and the last one will be having a single node and what will be the rhyme complexity foreign complexity look to look for any of the element it will be around logarithmic and do D3 okay n to the base 3. so basically this will not like let's say if you keep on increasing the base now the value will be decreased eventually okay let's say log is to of let's say 100 so what is log base 2 let's see when observe it is equivalent to 6.6 and let's say log base uh J log B is B of 100 for 2 it was 6.6 right and for 3 Let's see what is the answer is log base 10 let's say it will be like eventually you will be getting a lesser and lesser answer let's check it so what is the answer it is equivalent to so it is equivalent to uh some something around 4.1 so basically if the base increases each and every time if the base will increase yes yes okay so don't worry let's we got it so basically it is around something 4.1 that is log uh 100 base 3 is equivalent to four point something and log 100 B is 2 is equivalent to 6.6 so basically the value decreases if the value of Base increases so if you increase if you have a such kind of tree in which there are n number of nodes and by and and erratri if you have this kind of a tree then the searching process on this three can be reduced and array search three okay so basically you will be having some kind of searching pattern inside this tree so the time complexity of looking for any of the element will be around logarithmic m to the uh n okay so let's let's uh imagine try as a law try as a binary tree only try as a tree in which there are there can be at Max 26 number of child nodes for each and every parent node okay so basically try is nothing but a node or a class let's say what is a try I mean let's say what is a tri node basically we need to understand what does a tri node look like right because we already know what does a binary tree look like binary tree node looks like this the reference of left child the reference of right child and the value for this node so now what is the visual visualization of a tie node so Tri node has a Boolean value that says true or false and you'll be able to understand the meaning of this as well so try notes is there is a Boolean value true or false and there is an array of 26 length okay there is an array of length 26 and each and every uh index value is capable of assorting the address of a node so basically 26 array tree can be it can be called as 26 area3 so this is what a try node looks like okay so basically uh what does it denote so basically each and every Tri node if I want to create a try data structure then try data structure helps you to helps you to find out the searching process of string let's say if you want to find out uh inside let's say if you will look for something you know if I am writing down okay so you can observe that let's say there are many many different let's Geeks for gigs now observe there are many many suggestions Geek Squad geek Setter gigs Hood rank gigs right so everything which has gigs as the prefix has been listed right this is what we get when we try to search anything so basically the Thai data structure can be helpful in order to find out all the strings which have same prefixes or the questions for Strings which are based on prefixes searching and all the strings then that can be done very quickly with the help of this try data structure okay the searching uh questions based on strings can be done very quickly with the help of try data structure so that is the basic use of it okay in order to store the data about especially characters and strings you can show the other values as well you can include all 256 different symbols as well you can simply change the size from 26 to 20 to 256 to make it more useful for now I have used it as a string so I'll be using the try data success to store the data or the strings only so let's say I am taking this entire array of strings and I'll be storing or I'll be creating a try data structure of that entire string array so the words are the and then there is there t h e r e there and let's say any and by b y and b y I have selected few of the words and now I'll be creating a try data structure for it so how to create a Time data structure so there will be a root node just like different trees we have a root node for dry data structure and inside the root node initially I have said that there is a Boolean variable as well so Boolean variable will be true whenever you reach the node that is going to be the end of the entire word will be coming to that part okay so basically here is our root node and inside the root node now I want to store the inside the tri data view I want to store phe the so each and every character will be stored inside the dry data structure separately so first of all inside the root inside this array I'll be checking that whether we have any reference of T node or not if we don't have any reference then what we will be doing you will be creating a new node and you will be giving the reference to that particular index so now a new node has been created and that node represents the character T so now this is your current node okay so now I am storing the next alphabet that is H so again initially the value remains false for the Boolean variable now again what I'll be doing now for this current node I'll be looking whether I have a reference of H or not I don't have any reference so do nothing just create a new node so a new node has been created that represents H and its initial a Boolean variable is false so now the next character is e and this is your current node so now I want to check whether the uh alphabet e is present or not the reference node it is not present so do nothing but create a new node and you have the Boolean variable so now this is the entire node number e and this is your current node so now do we have any other alphabets remaining inside this word no nothing is remaining so the last node that is the last node e will have the Boolean variable as true this indicates that this is the end of the word said some word is ending at this node itself okay so this is the use case of the Boolean variable is it making sense is it making sense regarding about uh regarding the try data structure uh plus one or uh write down yes in the chat box if you are getting the idea what actually the Thai data structure is now again we'll be storing one more a word as well and that word is next word is a so I'll be storing a so again I'll be starting the traversal from the root node itself so now currently my root node uh so your current node is going to be the root node for now and now over here inside the current node try to find the reference of a because I have to store the alphabet a so I can see no reference of a so what you have to do you have to do nothing just create a new node that represents alphabet a and initially its value is going to be false its Boolean value so now let's look for the next word is it there no nothing is present so the last uh node is going to have the Boolean value equivalent to true now let's say I want to store the next word so the next word is there t h e r e so let's insert the last word and let's try to jump towards the process of insertion okay so now let's write the current node who is the current node I can see this is my current node and now which is the first word t so do we have a reference of T no I cannot see any reference of T over here so let's create a reference of T So T has been created and initially its value is going to be false and this is my current node right now next is the word Edge so do we have a reference of H inside this no we don't have so let's create a new node and this is going to be my current node for now so the next alphabet is equivalent to e so do we have a reference of e inside this node no we don't have so let's create a new node this node represents e this node is represent in h and the values you going to be false and this is my current node so now which is the next alphabet it is equivalent to R so do we see any reference nothing is present so R will be created and this is the node representing R this is your current node and Boolean value will be false for now and now let's say what we need to do next alphabet is e so for the current node do we have any reference of E from here no we don't have create a new node and store the Boolean value as true because this is this is going to be the last word so after E I cannot see anything so the Boolean value for the last node is going to be true so now this is going to be the end node and it has been marked as green the last note is marked as green because this is indicating the okay and over here a where is a this also indicates the end node okay so this is how we can store any string inside the dry data so this is how the tri data structure looks like and now instead of an array the array is containing nothing but it is containing the mapping of alphabets and the nodes that represent those alphabets okay so arrays trying to store this mapping the alphabet or the characters mapped to the try node its character represents which try it out so this kind of mapping has been stored inside an array but you can use a hash map as well to store this mapping okay so this is how the try data structure works like and this process in which I was inserting a node is called the insertion process okay and the question is also the same first of all in this question what we have to do basically you have to uh let's try to read the problem statement now okay so the name of the question is try insert and such both the algorithms will be covered over here inserting part and searching part orally we have just directly seen the insertion how the insertion process takes place and now let's try to read the problem statement try is an efficient information retrieval data structure okay use this data structure to store Springs and searching the strings your task is to use try data structure and search the given string a if found print one else zero so basically with the help of try data structure you will be having an array of keys store all these things inside your try data structure and you will be required to look for a word inside this file data subject whether it is present inside the array or not okay so we can use linear search we can use binary search but over here we are working inside try data structure okay we are not working on an array I hope it makes uh the idea about try data structure clear so linear search binary search for looking for searching for a string will be like let's say good enough but it will be not as good as try data structure in all the other terms related to searching a prefix string or a string okay a plus one in the chat box if you are you guys are able to understand what if you have any doubt till now just paste it in the chat box okay so let's see the example number one over here in the example you can see the key value is equivalent to uh it represents the different strings okay the a their answer any by by and there and you have to search for the word th and this word is present inside the key we can directly observe and say but you have to use try data structure searching algorithm so th is present hence output is one the problem statement is pretty straightforward okay nothing fancy or nothing uh trickier in the language so now what we need to do so now let's try to create first of all the try data structure for this entire key array Okay so we already have created but I'll be not writing down the array details and something something I'll be writing down only the nodes okay so let's copy this part and let's create the try data structure okay so insertion process is required in order to insert any element inside my try okay so the words are t h e a t h e r e ens w-e-r and the other word is any the other word is y by and there will be having a very huge try data subject so let's see so this is going to be my root node okay so starting from the root node this is currently my current node okay so starting from from this one do we have reference of T no we don't have so let's create a node representing T now the next word is H so this is not having any reference for X so node H has been created and now the reference of e will be created because this was my current node and it does not have any reference of e so node representing e has been created and now this is going to be my endnote so I'll be marking it as a green so what key thhe has been inserted so now let's insert the next word a so starting from the root node do we have a reference of a no we don't have so let's create a node a this is the node representing a and as it is the last node of as it is representing your word the end of the word so I'll be marking it as the end node so Boolean value will be true over here so the next one so the next one is t h e r e there so let's start the first one is T so starting from the current node T is already there so this is going to be my current node now the next word is H H is also there the next word is e so e is also over there the next word is R but R is not there so let's create r a node representing R this is current node next uh word alphabet is e so this is going to be the end node so mark it as a green okay so this is how the insertion process takes place so the next is answer okay so let's start so a starting from the root node again starting from the root node this is your root node current node do we have a reference of a yes this is my current node and not present so n will be created this is current node s not present so create this s w not present so create this w e not present and are also not present so this will be e and this will be r and this is the last node end of the word variable is going to be true so answer has also been stored the entire word has been stored with the help of all the alphabets so prefix reusability also takes place okay if uh two strings have same prefix then they will be you reutilized to store the data about the other string so till now was it clear yes or no in the chat box till now this is what my try data structure looks let's quickly complete the entire try so any this is my current node I have the reference of a I have the reference of N and this is y and this represents end of the node it is it and now let's see what is the next word it is b y starting from the root node B was not present B and then there is y so this node is the end node so the next word is b y e what is b y e let's start from the root node B is there Y is there e is not there so e and this is the end node again the last one is there so let's see T is at H is there e is there IR is not there right so I will be created over here I and R and R is the last node so store it over here okay so this is indicating the end of the word so this is the entire data structure all the strings have been stored inside meta I data system now how will you look for the element inside your Tri data structure let's see now let's include the searching part till now was it clear yes one in the chat box quickly uh yes one in the chat box if this was clear to everyone okay I'm waiting for your replies to mention down in the chat box if it is clear to you okay I might be getting late replies because of uh latency of the connectivity so let's say now I have to search for the word let's say what was the question the question was saying Search the word t-h-e it says search DHE so now let's see how to search for an element as I mentioned everything starts from the root node so this is my root node currently you are standing over here so now what is the String which you are looking for it is t h ether so this is the first one so you have to look whether the reference of T is present inside your current node or not yes I can see this references present so this is going to be your current node for now so the next word is H do you see the reference of H present over here for this word t for this node T yes it is present it is over here so this is your current node now and now the last alphabet e so for this from this node do you see any node connected which represents e yes or no yes at represents and this node and this is your current node for now and now after this no word is remaining no alphabet is remaining so it means this is the end of the word and you have to check whether the node at which you are currently standing should also be the end of the word because we know the end of the word represents the word th right because it indicates the end of an entire word this green indicates the end of a word and over here as well this string has also been completed hence it should match if it is matching that means the searching is complete th E string is present inside your Tri data structure okay so now let's do the same thing for other kind of strings any other different things okay so till now watch this example clear yes or no how to look for a word inside your try data so let's say you are supposed to look for some other thing let's say let's say you were supposed to look for DHE and I you have to find out whether this string is present or not okay so let's start t h e and I so this is the first word and currently you are standing at the root mode from here any node representing T yes this part so this is your root current node and the next word is H any node representing H yes so this is your current node so the next word is E from H any word or any node representing e yes this one so this is your current node from here is there any uh from here you have to find out is there any of the node representing the alphabet I yes it is over here so this is your current node now what is the next word next alphabet is not present so now that means you have reached the end of the entire string so it is for sure whatever is your current node it should also indicate that this is the end of the one then only then it means the string is present but this last node at which we are currently standing does not say that this is the end of any word no a word is ending at the node I any word which is ending at I that is t h e i this kind of word is not present if it might have been present then this node would have been green instead okay so now I hope it makes sense so over here this searching although we were able to look for the entire string but actually this string is not present a prefix of it is present in different strings okay this is a prefix of other strings which is present inside your Tri data structure okay so that is how the searching process in try data structure looks like so now let me give you the algorithm part so first of all we'll be looking at the class structure of the node okay we'll be looking at the node structure of a trinode so let's say you have created a class that represents try node and over here inside it as I mentioned an array representing the entire alphabets will be present so that will be capable of storing nodes of or the objects of try node and this will be called as let's say edit and the other one let's say what will be the value it will be a Boolean variable it says is end of word okay and this is what a try uh class looks like you can use a Constructor to initialize all these things and the size of this uh try array will be equivalent to let's use the Constructor as well to initialize both the values okay so the size of this array is going to be equivalent to 26 because over here I am only storing all the alphabets or these things that are in lowercase that's all the 26 alphabets okay and is end of the word will be initialized as false in the beginning because I want it to be not the end of any word initially can we use inheritance in this why do we need to use inheritance which part why do we don't need any two different classes you know thank you there is no requirement of two different classes that's the reason okay so this is the structure of the dry node are you guys able to understand the High data structure any doubt till now anything from your end okay so basically this is the class and you have you can also try out the implementation on your own okay so this is the entire try node now let's write down the algorithm for inserting an element or inserting a word inside might try so basically as I mentioned Tri will be having if you focus on the question you can also inside the function you can have you can have insert a method and the arguments passed is the root node of the try data structure and the string which you have to insert so basically we need a root node and what else do we need we need the key that I need to insert it okay so first of all from the root node my current node will be initially pointing to the root node right and one by one I'll be going through all the characters of these strings that is key this is my key that I need to insert so I'll be iterating over the entire uh characters of this key okay and while iterating what I will be doing this is my current character so I'll be extracting you are extracting my current character in this let's say in a variable ch okay and now after extracting the current character I need to look whether your current node has any uh child node which is representing the character CH or not okay so I'll be checking if inside this current node this is an object right so current dot parent or let's say current dot array so do I have any reference of ch inside my current load or not if this is not equal to null now what is this let me explain you if I have any reference then that means your current will be equivalent to the reference of that position or the reference of the child node if this is not the case then what what else you have to do you have to create a new node a new trinode will be created so a new trinode let's call it as temporary I'm writing a Java similar code but you can understand it in this manner so new Tri node has been created and what you have to do this new try node its reference will be stored at this array in which at the index representing the character a is equal to its reference will be stored over here and your trinode was created and inside the array this is my current current try node and now let's say my current word or current word current word was equivalent to C but reference of C was not present it was a null initially so what I did first of all I created a trinode this step indicates it and then what I did at this index inside your current array instead of the current node inside your current array I stored the reference of this node that is representing C okay so that is what I did and now what else do we need I have inserted it I have iterated and now at the end you need to update the current or do you need to update the current node so that means as a new node has been created so the new node is going to be your current node so if it is not equal equivalent to null then that means what you'll be doing you will be going or jumping through that node so I'll be adding it over here as well so basically I'll be going to the new node which has been created in this manner and after the end of this for Loop you can directly conclude that the node has been inserted and this is the end of the insert function so this is how the insert query looks like is it clear [Music] so is it clear yes on any chat box if this part was clear to everyone quickly a reply from everyone if this part was clear to you okay fine so this is the inside entire insert operation okay so let's quickly write down the code of this so that we can get little bit uh coding part also okay because this code is going to be a lengthier one because now here it will be the explanation of the searching process foreign ly doing first of all I need current node so try node current is equal to root node okay now what else do we need the Second Step says iterate over the entire characters over all the characters of your screen so I will be Trading writing the code in Java but I'm also mentioning these steps okay so now after iterating I need to extract the character and let's what is the character present at the Authentics whatever is the character now I need to check whether the reference along with this I need to check whether the current node is reference of CH or not so I'll be looking right there the current node and inside the current node you can observe inside the uh class declaration inside the class Declaration of try node the array is going by the name children so I'll be checking whether I have any kind of child node which represents CH or not so CH is actually uh the ASCII value so basically I'll subtract the R square value of a and I'll be converting it into the range 0 until 25 because the indexes will be from 0 to 25 as the array is of size 26 so I'm directly mapping the alphabet to the a will be at zeros index B will be at the index number one so I need this mapping and this mapping will be achieved by just doing a simple subtraction so if this is not equivalent to null then I can directly jump to that null so I'm writing down what if it is equivalent to null if this is equivalent to null then current dot children will be equivalent to new triode I need to create a new try node so I will be generating a new try node and its reference will be stored at that particular index and now I'll be jumping to the new trinode my current will be pointing to the new I know so I'll be writing down current is equal to your new dry node that is children of CH minus a and if this value was not equal to null then and also then you you would have uh applied this process that jumping to the new childhood to the actual child not right but and but over here as well both these steps are common in if and else part so I have written down in general and now afterwards after the insertion is complete nothing is required to be done so this is the entire insertion process okay over here I have written down a files and everything because this step can be directly avoided without this if condition as well you can write down this last step right because this step will be executed does not matter if condition or else condition is executed and this if condition only contains the last step that is jumping into the new current Norm and at the end the most important thing after the iteration over the interesting is complete the last node will have the Boolean value that is is end of the word as true because that will be representing that this node represents the end of the word that's why you need to write down is end of the word for the last node is going to be true that is wherever your current is for that is end of the word will be marked as 2 because that node represents the end of a word okay and now let's so this was the insertion part now let's uh do be part of searching let's understand how the searching algorithm Works searching algorithm let's first of all write down the algorithm and then we'll be writing down the implementation so so for the searching part what else do we need the argument says a root node and a Keynote a root node and over here it is the key node so how to look for a word how what was the process first of all you need the current node standing at the root position so current node is standing at the root position now what else do you need to do I need to search for key so I'll be checking each and every character so I need the iteration over the characters of the key so try is also very easy data structure okay so it's not difficult to understand the length of the entire key eyelid rate so we one character will be present inside the I'll be extracting the character at ith index and put it inside CH so now I'll be checking this is my current node and I'll be checking whether any reference of CH is present or not so if for the current node or the current node current dot let's say it's called children do we have any children representing CH or not if we don't have let's if we don't have that means the value will be equivalent to null at that point right that means no node or no try node is representing the alphabet CHF this is equivalent to null then that means the word is not present and you can directly return false from this point okay if we don't have any of the try node representing let's say word e then that means that enter string is not present elsewhere might have created so if this is condition if this condition is not true then what does it mean this condition is not true then that means a child node is present a child node is present representing CH so your current will jump to that child node current will jump to that child node okay and at the end we observed that some of the strings might be the might occur inside the try as a prefix of the other string just like t-h-e-i it was present then testing is present but it is a prefix of some other string so at the end after looking or after iterating over the entire uh entire string key you need to look whether the last node at which you are standing is having the Boolean variable true or false so you will be checking whether the Boolean value for the last variable for the last node that is it's it's is end of is end of word true or not if is uh it's this variable Boolean variable value is true then that means you have found the entire word else it will be concluded that this string is not present okay so you can return the value of this entire Boolean variable itself so this is the entire search algorithm okay so this is your search algorithm this is your class try node and this is your insert algorithm any doubt till now do you guys have any confusion in this search algorithm here is look I see no doubts coming so I think we can directly jump to the coding implementation for the same so let's code the algorithm search okay so again noting down each and every steps of the algorithm so first step is to get the root node that is current is equal to root and the next step is to iterate over the entire string so I'll be trading over the entire string one by one and let's extract the character so accepting the character and now I'll be checking if the current node has any child node representing CH or not okay so I'll be checking whether current node is any child node representing CH or not that means let's say if it is equivalent to false it means if I don't have any charge no representing c n then I'll be returning false that this key is not present okay else what I'll be doing else I'll be jumping to that child node else my current will be now the reference of the child node and penetrating over each and every character luckily let's see you very so uh able to trade over the entire string key so at B and you need to check what is the value of the last node and what is the value of its Boolean variable is end of the word what is its Boolean variables value is it true or false if it is true then that means you have found the entire string if it is false then that means you don't have uh the string present inside your trial okay so this is the entire search algorithm so now let's try to see if we have any kind of minute errors or syntax or compilation error okay so one thing I forgot over here that is conversion that is conversion of ascially into range and now we can see the compilation was successfully completed so now let's try to submit it and see okay and the problem was successfully submitted so what will be the time complexity of inserting any word so basically inserting any vertex the time complexity equivalent to the total number of words present inside the array called as key okay the insertion process will take total number of words I mean the alphabet total number of characters present inside the key that is going to be the time complexity of insertion and what will be the time complexity of search operation it will be equivalent to the length of the entire key okay so basically if you want to insert a single string no then it's a Time complexity is going to be the length of the key only because you can observe this is the entire uh what do we say it is the iteration over the length of the key and if you want to search then and also then it is going to be equivalent to this that is the length of the word you can observe the expected time complexities order of M plus search so basically searching will take length of the string time complexity you can observe rewards the length of this string and M M denotes the time complexity required to generate the entire try data structure okay it is the sum of the length of all these strings which is present inside the key basically total number of alphabets present okay so that is the time and space complexity and this was the medium quotient a basic introductory equation for an advanced data structure data structure so I would like to know from the audience do you have any kind of doubt regarding this or else we can move towards the next and last question that I'll be giving you in homework do you guys have any doubt I'll be waiting for a few minutes and then we'll be jumping to the last question Mark true which part okay I guess that was a previous comment any doubt anyone please write down y or plus one in the chat box so that I can know that we can proceed further this is okay so now let's uh see the last and final question it is under the same try data structure the concept is little bit different or the algorithms which you need to do are little bit different but over here you're going to observe this quotient comes around a phone directory I mean I mean the difficulty level of this question is hard question okay yes this is a good problem so basically I gave you an example about looking for a word like let's say you want to search for oh and if I look for oh and I can get this many different different suggestions right which has a same prefix on online SBI online fans etc etc on one plus one drive right we have this kind of suggestion in which the prefix is common the prefix is common and prefix is equivalent to o n so basically if you want to implement this kind of uh functionality you can utilize the try data structure okay so basically whatever you can see in this suggestions part can be implemented with the help of try data structure so you'll be having a set of let's say contact in inside your phone directory there will be different different contact let's say this is the first Contact X for gigs and gigs for for test and etc etc so what will be do doing you will be you have to find out that for the given string s you will be going through all the prefix substring of this string s and for each and every prefix substring you will be finding that how many strings are having this as their prefix string so basically let me give you an idea let's copy this part first and first let's go through the problem statement so given a list of contacts that goes by the name contact of length n where each contact is a string which exists in a phone directory and a query string s the task is to implement a search query for the phone directory that means Run a search query for each prefix T of the query string s from index 1 to the length of the index that prints all the distinct contacts which are the same prefix as p in the lexicographical increasing order please refer the explanation part for the better understanding note if there is no match between query and context print 0. so let me just copy and explain it with the help of an example okay for this it will be very much lengthier to create an entire try because the words are very lengthy okay so I'm not going to create a try data structure for this for this one okay so basically what the question is trying to say you will be given a string that is s and you will be given a list of contacts of the phone directory yes this is auto complete yeah you can call it autocomplete as well I am new here okay so welcome mahinder yes this is autocomplete the feature which we observe in Google in any of the search options right so now what you have to do this string s is given to you okay so basically they have tried to make this question lengthy length here right so basically for the given string what you have to do in this contact list you have to find out for each and every first of all for this string s find out all the prefix substring so that would be g g e g double e g double e i d double e i b and g double e i p s now for each and every uh prefix substring you have to find out that inside the contact list which strings are having G as the prefix so I can observe this this and this and in the output you have to print them in increasing order so gig is test then Geeks for gigs and gigs for test it has been printed for this G okay now for the other substring GE you have to print out the same thing you have to find out how many strings are having prefix as GE so I can say G geek is test Geeks this string and this string all of them are having the prefix G so again they will be printed in the output but in increasing order okay in lexicographical order now the next string next thing is g double e so for this g double e how many strings have g double e as a prefix all of them so you can observe this is for g double e now here comes the uh different part in which you will be able to observe properly that what should be printed GE and then this is G this is GE g double e and now for the last one that is g double e i which strings which things have g double e i as there uh prefix only one string so this is for g double e i and now the next one is g double e i p how many strings I have g double e i p as it's prefix string no none of them so for none of them the output will be zero and for the last thing how many strings inside this contact have g double e IPS as the prefixing none of them so for that it will be having output as zero okay so this is what the question is trying to say you have to print this many strings in the output based on the given string s so basically you have to create a try data structure of this entire contact for this entire part create a try data structure and you have to apply the search query for each and every substring of the given string s that is what the question is trying to say I hope you got the basic idea about the try of this question so I got an approach let's try it out okay let's I don't know what you have written but I kind of like Javas to the last node in s ource to all Leaf nodes in left first Direction okay so whatever is the approach that is coming to your mind you can mention down in the chat box as well and if you are watching this video after the live session is completed then you can mention down your thought process that okay I was able to think uh for the first time I got this approach in my mind okay so I'll read down the approach and I want to know what different different things can be done for this uh for this question okay and do mention down uh like do share your solution for this question in the comment section it does not matter the solution was completely correct or partially corrected I need to see the efforts if you are uh spending this much of time watching the session right we need the output of this okay so and let me give you a hint you have to create a try data structure and while applying the search query on each and every string just keep the track of the last word which you visited inside your try try data structure okay so that was it and let me share the link of this if I uninsured okay I have shared the link also so do you guys have any kind of any kind of doubt regarding anything I will be waiting for a few minutes and then we'll be ending this session right away so if you have any doubt you can mention it right now so how was this session did you guys really enjoyed the session was any part difficult for you to understand I would like to know from everyone okay so I see no doubts coming and so think we are good to go with the session ending part and tomorrow that will be an interesting session on the uh D is a topic only so basically let's emit in the next session and if you really enjoyed this session and if you uh are looking for such a amazing content then first of all uh like this video and share it with your friends as well okay and do comment down the solution of the question which I've given to you in the homework bye programming package Okay so what time will be the session it will be at 8 pm only 8 to 10 okay if you are doing like it's a computer science and you are into competitive programming or let's say you are good ideas apart you can get a very good package like you can get somewhere around 10 LP as well but I don't think it will be difficult for you because computer science is very open to everyone non-cs people also can get a good package okay suggestion if you put Topic in video title description more people will be able to reach it later okay suggestion okay yeah I will keep that in mind okay so that was it for today's session I hope you enjoyed the session and let's meet tomorrow in the next session thank you everyone thank you for joining the session have a good day and good night bye bye