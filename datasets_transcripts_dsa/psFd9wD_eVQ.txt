all right guys in this video we are going to be doing lead code problem number 1762 buildings with an ocean view this is a medium difficulty array problem and let's take a look at the prompt but before we do that this video is actually taken directly from our latest iOS interview mastery course you guys can check that out on the new website at appstuff.io we got a brand new website here guys i'm super excited about it uh the link for this is in the description and you guys should definitely check this out if you want more interview practice with data structures and algorithms and as you can see we also have a full and complete data structure and algorithms course that is a deeper dive into data structures and algorithms so you guys can check that out as well the link for that is in the description now let's go ahead and get back to the problem there are n buildings in a line you are given an integer array of heights of size n that represents the heights of the buildings in the line so we're going to get an array of integers and each item rep in the array represents the height of a building so how do we determine if a building can see the ocean or not well the ocean is to the right of the buildings as we see here in this input example which we'll break down in a second a building has an ocean view if the building can see the ocean without obstructions formally a building has an ocean view if all the buildings to its right have a smaller height return a list of indices that are zero index of buildings that have an ocean view sorted in increasing order so let's take a look at these examples to break this down so if we get this input of these building heights right the ocean is to the right of them we want to return all of the indices or indexes whichever one you want to say of the buildings that can see the ocean so we see that building at index zero two and three can see the ocean so why is that well one can see the at the three index can see the ocean because there is nothing to the right of it but the ocean so that's where we get index 3 index two can see the ocean because three is this building is larger than the only building to the right of it so therefore it can see the ocean two or the uh value at index one cannot see the ocean because it is blocked by this building and last but not least at the index of zero four is taller than all the buildings to the right of it therefore it can see the ocean and this is our expected output here we see that all buildings can see the ocean because each one is taller than the next and here the only building that can see the ocean is the last one because all of this last building here is taller than all of the previous buildings so that's the problem guys let's go ahead and see if we can dive into a solution so as always I want you guys to pause the video try to think about this at least try to think about how you would solve it and how you would start articulating your solution to the interviewer talk out loud think through the problem and come back to the video and maybe even try to implement a solution on your own and then come back to this video all righty so as always I like to get started with uh you know defining my function guys so I'm going to make a function called funk find buildings with an ocean view and look at that xcode hooks me up there man so we have our function defined and it takes in some integer array of heights and returns an integer array that will represent the indices of the buildings with an ocean view so guys one way of doing this is the brute force approach right so we could use a nested for loop to look at the current building loop through the rest of the items or the items to the right of that building and then calculate you know which building has you know how many buildings have an ocean view so I always like to start with like the potentially nonoptimal solution and improve it from there right um depending on how much time you have in an interview this can be good to do um I actually received this problem in my interview for Meta and uh I did start with that brute forced approach just to make sure I got something down and then I improved my solution and explained why it was better so that's what we're going to be doing here so I'm going to create my results array and we've already sort of talked through how we want to solve this problem with brute force we just need to implement the solution now i'm going to say return result so let's go ahead and get our nested loop situation set up so I'm going to say 4 I in 0 up to but not including heights.ount and then we're going to say 4 J in I + 1 up to but not including heights.ount right so let's break down looking at the first item in this heights array and what the nested loop would look like and what we want our logic to look like in order to get the desired solution here guys so my main loop is going to start at four so I'm at index zero and then it's going to fire off the sub loop first thing and it's going to look at these subsequent items in the array and essentially what I want to do is say that if I ever see a building that is taller than this current building that I'm looking at in my main loop then I know it does not have an ocean view and I need to stop there if I do get through the entire array without seeing a building taller than the building I'm looking at currently which in this case is four then I know that I do have an ocean view and I want to append that result so here's what we're going to do we are going to use this boolean property we're going to say var has ocean view and we're going to set it to true and we're going to in this array at each iteration check and see if heights j is greater than or equal to heights i we're going to say has ocean view equals false and then once this loop completes we're going to say if has ocean view results.append the uh index of i right and we can actually go here and improve this a little bit not that it really matters but and say break because we know that if we see a building that's taller than us we don't need to keep going through this sub loop right we just set this property to false and then if at after this loop has completed whether we break from it or we go through the whole thing then we know that we want to append that uh element or that index to our result array so I think that looks pretty good guys and what's interesting about creating this has ocean view property within this for loop is every time the loop restarts this or goes to the next iteration this will default back to true that's important to understand here because if we put that here then that value would persist uh in each iteration of the loop so if I set it to false one time it would stay false but putting it inside the uh main loop there sets it to true or resets it to true every time the loop restarts so that's a cool little technique there let's go ahead and test our solution now so we're going to grab our heights here we're going to say let heights equal that and we're going to say find buildings with ocean view heights and we're going to run our solution in this playground and we should see that we get 023 which is the expected result let's go ahead and do this guy here run it again 0123 which is the expected result and let's do this guy boom and run it again and see if we get just three and perfect man so this is albeit an a suboptimal solution it is still a solution guys so you might be asking yourselves like why did you do a suboptimal solution here well the reason for that is it gets a solution for the problem down right so worst case scenario you still solved the problem a mistake I've seen interview like candidates make when giving interviews is trying to find the most optimal solution right away and not being able to get it right completely and then they end the interview without having a working solution to the problem to be clear it is better to have a working suboptimal solution than a non-working potentially optimized solution so that's point number one point number two is if you are on a time crunch and don't have time to get the most optimal solution down you just go with whatever you can do in the given time frame that you have once again a solution is the priority all you would need to do is explain to the interviewer why this is a suboptimal solution so let's go into that next we would say this is suboptimal because we have a quadratic runtime here we have a nested for loop and this would not behave well at scale so that's why this solution is suboptimal we do have linear space complexity but we have quadratic runtime complexity so that's why this is bad so guys I'm going to say here brute force to make that clear and we can get rid of that function call so next up I want us to try to find an optimal solution so let's go ahead and copy this uh line of code for our function and just remove the brute force and let's think about how we can optimize our solution so the optimal solution for this does have linear runtime complexity and linear space-time complexity um you could even argue that because we have to return an array that that doesn't even really count towards our space complexity um because we have to return an array no matter what but the goal of this problem is to get this to work with a linear runtime complexity so that's what we're going to do now let's start with what we know right we know that in this scenario the ocean is to the right of the inputs right so I know that automatically the last item in the array will have an ocean view so that's something that we can use to our advantage and then it's like okay well naturally after that I would probably go and check this the one before that and see if that has an ocean view and then in this case that's yes and then I would check the one before that and the one before that so what we're doing there without even really realizing it maybe is working through the array backwards instead of forwards because when we did it from a forward direction we had to use this brute force approach to check all of the items after the first one well because we know this is to the right we can actually loop through this thing backwards and just do a single pass and uh calculate the buildings that have an ocean view that way so that is a much more optimal solution because we only do a single pass through the array and it will achieve that linear runtime complexity for us there is a little bit of trickiness involved in it though we are going to have to keep track of the tallest building we have seen at that up until that point right so as we loop through this we need to keep track of sort of a running local max value or local tallest building value that will help us gauge whether or not the other buildings can see over it to the ocean so what we would do is say hey uh at this point in time the current max is one right so and we know that one will have an ocean view no matter what then I get to three and it's like okay now I have to update my maximum value the tallest building I've seen thus far is three but three is taller than one so I know that this also has an ocean view so this is where the max comes into play when I get to two do I update my max no because the tallest building I've seen up until that point is three therefore I know that two is blocked by three and it won't be able to see and then I get to four and I update the max to four and I say because you know that's taller than the previous max which was three and then I know that I can subsequently add that to my buildings with an ocean view so let's go ahead and do this now guys so we're still going to create our results array and return that result and we are going to use a pointer here to loop through this array backwards so I'm going to create that pointer and I'm going to call it I and say it's equal to heights.count minus one and then I'm going to create another variable to keep track of my max height or my tallest building and we're going to set it to zero so now I'm going to say while I is greater than or equal to zero and you guys don't have to use a while loop here you could use the stride function in Swift you could also reverse the array and loop through it there but note that reversing does require um I believe a linear runtime complexity to perform that operation so the other option you have is saying like for i in stride from like blah blah blah right something yes stride from 2 by that's another way you can loop through something backwards but I'm using a while loop cuz it's honestly just easier to write so I'm going to say if heights i is greater than my max height result.append I and then I'm going to say my new max is max height is equal to the heights I right and then I'm just going to decrement I pretty simple so I'm pretty sure that's all we're going to have to do let's just go ahead and go through our loop iteration by iteration and make sure it makes sense and let's start with this example up at the top so let's see guys my max height is zero and I'm saying is one greater than zero yes so I'm going to append the index there which in this case is 0 1 2 3 because remember you we're using an index an indexed pointer here and then uh I'm going to go to the previous item right here and set my max height to one before I do that so right now max height is one i always do these sort of comments and go through the loop iteration by iteration just to make sure it all makes sense and you should do this in an interview too because you don't usually get access to a compiler and you just have to go through this with the interviewer yourself so you you you don't have the option of just running your code and seeing if it worked so next up now we say is heights I at I which in this case is now three that's the height greater than my max height yes so now I append that to my result so now um I believe my result is what it's uh let's see right now it's uh index at three and two yes okay now max height is three or we have it up here right and then I minus equals 1 so now I is looking at two so we go through this guy again is height is two greater than three no so it doesn't care it just skips that whole thing and it decrements I and now we're at four is four greater than three yes okay so now we append index zero max height equals heights I so now that's four but we're done with the loop so we don't care so an interesting thing however is that we have our array our desired array in reverse order so we would actually need to go here and say result.reversed so um this to me is a optimal solution we have decreased our runtime from quadratic to linear because we're only doing a single pass this uh will also just result in a linear runtime but I think we're it's going to have to uh be O2N right which is still way better than uh O squared which is what we had before so now it is time to check this in leak code guys to see if we got this right so let's see i'm going to pull up this problem and get our code pasted in there paste submit and check that out absolutely awesome all of our test cases passed we ran in 0 milliseconds beat everybody because we're ballers let's look at our complexity linear perfect space constant perfect love it man all right guys that's going to wrap it up for this video hope you guys enjoyed that breakdown we'll see you in the next one peace