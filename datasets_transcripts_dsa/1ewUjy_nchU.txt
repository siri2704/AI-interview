complexity as well correct go step by step things will be manageable going back discuss and now it's time we will continue with the mer sort first mer then we will go on a quick sort what is mer sort what is mer sort more or less it is similar to the binary search everything is going online the story is like everything you know exams directly earths answer booklet he's supposed to complete the MCQ exam he used to complete that and after completing he need to mention answer booklet at the end at the end we collect all the answer papers obviously since So sir so 200 students you're sorting like 1 2 3 4 this is impossible i hope you're getting my point staff room so we just divide it and what you do you sort it at your own level you sort it at your own level sorting now let us begin merging so we start with one number so number one number two number two number three number three number four number four number five number okay five number six number seven number eight number and this way we are just taking it all and then we are having all 200 papers in a sorted order what is the logic over here the logic over here is that the whole area of 200 is divided into six seven partitions the six seven partitions are sorted individually are sorted individually and once they are sorted individually they are again clubed together they are again clubed together but while clubbing them together we are collecting it collecting it collecting it and then we get it everything sorted so sorted partitions this is nothing but logic behind merge sort are you got the point as far as paperwork and code is concerned I will explain you i'm just first telling you the philosophy behind it is the logic is clear what is the idea behind it the idea behind is that array you divide the array into multiple partitions step number one you sort each partition individually you sort each partition individually and then you partitions they are sorted partitions then you merge those partitions then you merge those partitions that is the idea behind merge sort so let us do it on paper merge sort you divide array into two equal partitions or two almost equal partition divide the array into almost equal partitions sort both the partitions individually sort both the partitions individually and then take the smallest one at a place smaller and then you sort everything minute let me give you the example pay attention recursive code if you understand the first pass writing code become very recursive first pass the topmost pass so you take a look at this so first of all I want to divide the array into two parts if this part I'm saying left a this is right how do you find middle can someone recall middle how to find middle middle is equal to exactly middle is equal to left plus right by two go ahead left + by right by two i find that this is middle and if this is middle I'm saying that now I have got two partitions pay attention i got two partition first partition is left to mid and second partition is mid + one to right first partition left to mid and second partition is mid plus one to right now what I'm saying what I'm saying go ahead and sort go ahead and sort these partitions individually sort this partition individually suspense I'm saying that somehow you sort these both partitions individually continue further if you sort the first partition what is the result the result would A result would be 1 2 3 5 5 6 okay that is great second partition you sort it individually that comes out to be 6 7 8 and 9 right don't worry because you know you are listening so many big algorithms it find overwhelming so merge sort it is okay big it is quite easy we are going to do it step by step on paper and we are going to write the algorithm as well so I really don't think not a problem if we have got like this so things are done and now the things are done please pay attention if things are done I'm saying that let us take two indexes let us take two indexes one if this is left index this is a left index you continue further we got another index this is let's say right index I or J a1 is I and J and let us create one temporary array let us create one temporary array temporary array now what I'm saying listen carefully left partition element right partition element compare smaller that I need to copy that I need to copy so you find that you copy that just copy listen copy increment or temporary array increment you continue further again you compare the left element the left element with the right element two now whichever is smaller whichever is smaller you continue further you copy that element you copy that element and then just copy increment or increment again you continue further again you continue further you find out that which one is smaller again I say that if this element is smaller this element is smaller jo smaller you copy that element increment that index increment your temporary array index and you repeat the process whichever is smaller you copy that element you increment this index you increment next index and you continue further and then whichever is smaller whichever is smaller you decide Don't you think that elements append elements and that's it this is nothing but you call it as a sorted array is ready this is what a merging technique I guess and with a new array we will try to do it once again where we will have literally elements in more randomized fashion and taking some numbers let's say numbers is let's say eight let's say two or let's say three let's Let's say 9 let's say 1 let's say 5 let's say 7 let's say uh 2 let's say 6 let's say four these are kind of elements that I have arranged up yeah I guess random numbers and if these are random numbers let's see how it goes how it goes process repeat and don't worry we can repeat it one or two more times if it is needed so what is the step again first focus on merging technique first focus on insertion if you understand insertion learning insertion sort is very easy on the par line first focus on a merging technique if you understood merging technique merge sort is very simple merge sort is very simple we will go ahead whatever array is there let us divide array into two parts to almost equal parts even number 5050 odd number that is absolutely fine and continue so what is the first step the first step divide array into the two parts then what is second step sort the left partition how somehow sort the left partition if you sort the left partition can you please tell me left partition sort to in this case sorted left partition sorted left partition i guess it is 1 3 5 8 9 1 3 5 8 9 good a sorted right partition go ahead sort the right partition it is 2 4 6 and 7 up take three create a temporary array go ahead create a temporary array temporary array which can accommodate which can accommodate the whole left partition plus right partition which can accommodate both left partition plus right partition okay that is good so I have taken an array now take three indices index I at the beginning of the left partition index I at the beginning of the left partition index J at the beginning of the right partition at the beginning of the right partition and index K at the start of at the start of temporary array good you compare I element and J element whichever is smaller can you please tell me which one is smaller i'm saying that it is I element and J element or index yes I element is smaller i element is smaller go ahead copy this and then increment I ele increment I index increment K index again you compare I element and J element which one is smaller oh now in this time Z element is smaller so you copy Z element you copy Z element you increment z element you increment kth element oh you continue further now which one is smaller i element and j element yes I found that three is smaller a three is smaller let me copy three let me copy three increment i increment j you again continue now you find that now you find that the smaller element is j element whichever is smaller you copy that element you copy that element increment increment increment continue further continue further which one is smaller i element you increment it i element you copy I element increment I and then increment K again you continue further which one is smaller z element is smaller so six you copy six you increment J and you increment K you repeat once again which one is smaller again J element is smaller so you copy seven increment J and increment game and as as I was telling you earlier as I was telling you earlier right you never know depending on the values but when one partition is completed what is to be done a 1.11 partition is completed what is to be done copy the remaining elements of the second partition and append it to the array copy remaining element of the second partition and append it to the array one by one i J just copy paste now is your main array sorted is your main array sorted not really your temporary array is sorted please note that data temporary array temporary array sorted oh go ahead go ahead and overrite temporary array back to the over original array make temporary array back to the original array original array copy where your whole array is sorted where whole array is sorted now is the logic clear is merging logic is clear should I repeat it once again yes no problem i'll repeat once again no problem please pay attention pay attention please go ahead i'm just going ahead i'm just going ahead and what I'm saying is that what is your step number one step number one divide array step number one hk it is okay if it is still required for reise it will not take much time huh divide array into into two equal partition mid is equal to left plus right by two you divide into the two equal partitions we have done that what is next job to be done divide into the two equal partition what is next job to be done apply apply logic to sort the left partition and then you sort right partition independently partition to right partition left to mid or partition mid + one to right okay good next step next step is that allocate a temporary array allocate a temporary array auxiliary allocated temporary array or you can say auxilary array or which can hold both left partition plus right partition a left plus right partition total elements compare it will be like 8 8 - 0 + 1 total nine elements are there 8 - 0 + 1 total nine elements are there so that is something in front of you if this is clear if this is clear let us continue further let us continue further pay attention continue further take I is equal to left j is equal to M + 1 i is equal to left at the beginning of the left partition j at the beginning of the right partition correct and K at the beginning of the temporary array obviously it will be K is equal to zero you start you start comparing you start comparing whichever is smaller i'm going now a bit faster pay attention whichever is smaller you copy that a one is smaller you copy one you increment that index you increment K now 2 and three you find two is smaller you increment this and you increment this three and four three and four you copy three you copy three and then you increment I you increment K uh five and four okay you copy four you copy four you increment J you increment K five and six five and six you copy five you copy five increment I increment K 8 and six 8 and six go ahead you copy the smaller element six you copy six you increment J increment K i'm saying that you keep continuing until any one partition is exhausted so you find that 8 and 7 again seven is smaller you take this you copy J you increment J you increment K i found that in this example right partition is completed if right partition is completed go ahead and copy remaining elements of the left partition this is done but is it has it sorted my main array no it has sorted your temporary array temporary array sort original array so that the whole array is sorted now is this clear sure great now if it is clear wait for a minute if it is clear now the next question next question but we didn't discuss we didn't discuss how you are going to sort the left partition and how you are going to sort the right partition you just divide into the two partition you sort left partition you sort right partition now question is that how do you sort left partition and how do you sort right partition so bubble sorts I said no it is poor idea instead of bubble sort and insertion sort why don't you apply merge sort once again yes absolutely it is a divide and conquer problem you can again continue further pay attention you can again continue further and you can try to again divide this portion into the two parts you can again divide it into the two parts and you can think of sorting it further i hope you are getting my point and then so sir how do I sort the next one again you divide it into the two more parts and try to sort it together and you want to try to sort this again you divide it into the two parts and try to sort this much i hope you people understand that if element if array has got a single element if array has got a single element then then single element is always sorted i hope it is highly philosophical you know if there is a single element then it is always sorted there is no one to comparison no so it is always sorted and then you start merging partition and then again you continue sorted partition sorted partition merge and this way you continue the story and you find that the whole array is sorted wait for a minute let us just focus on this part uh for time being I want you people to focus on this part which part let's say that just a minute let's say that this is my array and let's say that this is my array and this is my array see it carefully this is my array i want you people to focus onto the right partition i want you people to focus onto the right partition i want you people to focus on right partition now tell me for this partition right partition focus for right partition what is left and what is right what is left index what is right index for the right partition for the right partition I'm talking about this much of part and I'm saying that how this is going to be sorted Yes in this case can I say that if this is nothing but left if this is nothing but left and this is nothing but right you agree with this oh this is left this is right so it is five and 8 by the way how do you get its middle how do you get its middle middle 5 + 8 divided by 2 that comes out to be six agree a so this is middle and this is middle + one so I can simply say that I can simply say that this is partition something like this then you continue further you continue further you try to sort this individually you try to sort this individually please pay attention you sort this individually you sort this individually sorted 72 sorted 72 sorted is nothing but 2 and 7 right and 64 sorted is nothing but four and six okay that is good that is good and now you need the indexes once again I'm saying that this is this is left index i hope you agree this one is again right index J in this case the temporary aror can you please tell me what should be the size of a temporary array in this case four how four tell me the calculation four number 4 say 4 say I'm saying that it is 8 - 5 + 1 8 - 5 + 1 I hope you're getting that 8 - 5 is 3 + 1 is 4 so total there are four elements so the temporary array I'm very sure that temporary array the temporary array should be should be of four elements okay No problem so obviously K point K will point to the zero of this K is pointing to the zero of this is indexes 0 1 2 3 please pay attention follow up I and J which one is smaller which one is smaller i see two is smaller so let me copy two and then increment I increment I increment K good you continue once again which one is smaller j element is smaller let me copy four let me copy four you increment J and increment K again continue further which one is smaller still J is smaller why not copy six increment J increment K hey what I see one partition is exhausted if one partition is exhausted what is to be done append the remaining one okay I appended the remaining one i appended the remaining one is my main array sorted no but temporary array sorted temporary array sorted what is to be done what is to be done i need to override temporary array back to the original array temporary array back to the original array is that correct my question is that how do you copy temporary back array back to the original array can you write a piece of code for me that is my question loop so do you want to copy something like this do you want to say something like this error of I or X whatever is equal to temporary of I is it how you want to copy is it what you want to copy isa is zero element zero element element please understand that you agree with this you want to copy it from left onwards for the inner partition it is left no for the inner partition it is left so I'm saying that is zero please pay attention zero that will go on a left is one that will go on left + one is two that will go on a left plus two is three it will left three you agree with this it's zero it will go on the left is first it will left plus one two it will be left plus two and it will left plus three and so on so forth in general what I want to say is that the last loop the loop I need to be careful I need to write it left plus I is this clear to everyone [Music] And if you people have understood this trust me rest of the code is very easy super easy code super easy code let us just go ahead and let us think of implementing it i'm going ahead sorting then yes I got a merge sort new class merge sort main okay add some package done finish and don't worry so don't worry about it we will follow the same technique for the whole module let me know should not be a problem here I'm main and I want to write public static void oh static void merge sort please keep your Eclipse ready i want to pass the array i want to pass the array and I want to pass the left i want to pass the right okay I'm ready with this i'm ready with this logic what is the first step can you please tell me yes divide array divide array in two two equal partitions equal yeah almost equal equal partitions okay that is the first step what is second part second step what is second step left partition sort left partition and then sort right partition so left or right partition individually sort okay that is good by the way left partition left partition a left partition is left to mid am I correct and right partition is mid + one to right a right partition is mid + one to right okay I got that next up I'm at high level high Yes create temporary array don't forget temporary array to accommodate accommodate accommodate both partitions so partitions accommodate okay I got that as well what is next step next step at the higher level merge two sorted partitions partitions into temporary array index and we will do that don't worry about it and what is the final step what is the final step overwrite overwrite temporary array back to back to main array back to original array at appropriate position is overall logic is clear to everyone obviously index so that you can always do it accommodate anyway to accommodate uh create sorry merge merging what is that what is that compare compare elements from both partitions and copy the smaller one smaller one until until any one partition partition is done is done in completed and then next next if one partition is completed then copy remaining elements elements from other partitions other partition I hope now this is very clear let us go ahead and start writing code step by step line by line integer mid is equal to left plus right by two it is equal to mid is equal to left plus right by two is it done you continue further sort the left partition oh this is very easy job now because we are using recussion a r left to mid a left to mid and you continue further you follow the similar one mid + one to right is this correct these are the recursive calls so apply to the left partition apply to the right partition or you continue further create the temporary array to accommodate both the partitions okay so let me allocate a temporary array temp is equal to new int or or mathematics right minus left + 1 so temporary array to accommodate both the partitions we have done that as well ob logic compare two elements a compare two elements from both the partitions and what is that copy the smaller one integer I equal to left J is equal to mid + 1 and K is equal to Z i hope this is clear i equal to left J is equal to mid + 1 and K is equal to Z what you want to do you want to follow it in a loop compare if error of I is less than a of Z error of I is less than error of Z i can simply say temp of K is equal to a error of I a temp of k is equal to a error of i and then you want to increment k then you want to increment i i'm just writing a minimum number of lines i repeat once again i + what to do yes it is post increment operation that we are doing what is else else what to do else temporary of K is equal to A of Z or just copy A J increment j increment or K increment okay we have done that this is also done by the way until until any one partition is done okay so I want to find out until any one partition is done so what I'm saying have a look at this while left partition left partition left to left to mid so I is less than or equal to mid and J is less than or equal to J is less than equal to mid + one say yes it was still right so J is less than equal to right oh that is fantastic it will come out it will come out let us assume and let us assume that let us assume that the right partition is finished if right partition is finished what I need to do if right partition is finished what I need to do append the left partition oh yes append the left partition see my code append the left partition while I is less than mid just say temp of K is equal to A of I element partition left partition copy okay that is good but what if what if if this condition is false what if if this condition is false if this condition is false what is to be done if this condition is false what is to be done you go ahead and you follow the right one okay while J is less than or equal to right temp of K is equal to error of K error of J right so you need to take a call up false please pay attention it will copy the elements from this it will copy the element from this obviously condition false other way around pay attention to this condition is false and it will copy the rest of the elements from the other partition i hope you got the point this is what we need to do it merging logic merging temporary array what is the next job to be done temporary what is the next job to be done i want to copy this data back to the original oh back to the original continue further i equal to0 i is less than Tim i ++ and how do I copy how do I copy should I copy like this should I copy like this no no no no what we need to do extra I guess error of left plus I is equal to temp of I done so code is completed almost almost process we have explained in terms of itself what is left we have explained process in terms of itself what is left recussion oh oh recussion base condition oh you think of a best condition what is best condition if partition is invalid a partition is invalid or or have single element or have single element then return correct no what I'm saying is that a partition is invalid partition is invalid your left is greater than right a left has to be always less than right if left is greater than right it is invalid partition or if left is equal to equal to Right left is equal to right left is equal to equal to right left is equal to right or there is a single element if there is a single element then just say return nothing must to be done like a terminating condition that's it i say you could have made it make it more readable you can make it more readable by simply saying left is greater than or equal to right i hope you got the point it should why not you test it you go ahead you declare the array array and I'll take up the same array let's say 8 3 9 1 5 7 2 6 4 Yes I have got the array and you continue further what is next job to be done next job to be done let us just print it first arrays arrays dot to string you pass the array this is before sorting i'm printing the array after sorting I'm printing the array just tell me what should be the call to the merge sort i'm passing a r what should be left what should be right left is left is zero and right is right is a r last element now last element length minus one a r length minus one that's it so is this array sorted right click run as Java application is this sorted yeah quickly copy paste and execute it then we will do the paperwork once again quickly copy paste and execute it 4243 no problem please let me know line number 4243 uh all right part no problem i'm repeating repeating don't worry why temp.length okay that is a question coming back to the point and that is the reason I draw this diagram see what I said is that I never know left or right or length will be zero right or right i hope you agree left or right so I'm just taking one example second recursive call it is done for this part for this part this is going to be the middle element so my array is divided into the two parts left and right left part is sorted individually right part is sorted individually this is done if this part is sorted individually this part is sorted individually temporary what is the length of temporary array four elements 8 - 5 + 1 so total four elements obviously the temporary array has got four element to first of all first of all as someone has asked the question why template I need to override only four elements elements and that is the reason loop is written something like this for i=0 i is less than temporary array temporary arraylength i ++ I hope this part is here is that part is clear okay now I'm contining further i'm continuing further right element zero element element first second no not at all z is left one right is two is left two right and then is three is 3 + I hope you understand and if you understand that and if you also understand that now it is very simple All we need to follow All we need to follow is a loop the left a left plus 0 left plus 1 left + 2 left + 3 in general it is left plus I in general it is left plus I and then I element I'm putting left plus I is that clear now everyone good h now uh Jep was having one And that is the reason that please visualize that right so that is there i hope code is working for you can you please check quickly if it is working for you let me quickly do the paperwork for last time let me quickly do the paperwork for last time and then we'll wind up i'm just going through all the steps i'm just going through all the steps suppose that this is the array and now please pay attention to my opinion you still we'll continue further step number one Yogesh temp is equal to right minus left + one please repeat okay have a look at this yogesh yogesh in this case In this case temporary array yogesh in this case temporary array element four elements or four element count how do you count the four element it is 8 - 5 + 1 so partition last number partition first number index and that plus one listen carefully scholarship question number 11 to role number 20 how many students are there in a sequence all role numbers are there role number 11 to role number 20 how many students are How do you calculate it role number 11 to role number 20 total students count I simply count it 20 - 11 + 1 that comes out to be 10 i hope you got the point so numbers we say that higher number minus lower number plus one that gives me all the element inclusive both the ends yogesh you got the point i said that this is something that I learned in the fourth standard you know this is problem right index left index total number of element right minus left so inclusive both ends I have got total four elements it's very simple anyway I hope you got that and that is the reason we have allocated the array temporary array of the four elements and then I'm continuing further let us do the whole let us do the whole story once again doing a whole story once again you find that let us divide the array let us divide the array this is the left partition and for this this is the right partition so my first recursive call goes something like this the first recursive call where left is equal to mid a left is equal to zero and mid is equal to 4 and then mid + 1 is equal to 5 to right is equal to 8 that is the first recursion call chat is not responding no problem let us continue further you continue further divide it is over here this is over here so it will be again divided into two parts okay that is still not a problem but what about the right side right side right side directly sort it will be again divided into the two parts okay no issues you continue further you continue further 839 partition that partition will be again further divided into the two parts this part is again divided into the two parts one five partition it is again divided into two parts 72 partition it is again divided into the two parts 64 partition it is again divided into the two parts okay you continue further 83 partition problem it has to be again divided into the two parts finally finally we reach to the position 8 or three let us merge them together let us merge them together let us take a temporary array and a temporary array merge copy or element copy and now it is three and 8 now this 3 and 8 this is sorted you go back you override on these two elements i hope you are getting my point so the element sort you continue further now now you go to the outer call outer call you got 38 outer call you got 38 and then you have got 3 8 3 8 and 9 outer call you got 38 and 9 you again continue further again you continue further what you want to do follow the process copy so temporary array is now my sorted array and now this sorted array of three elements it is overritten back to the original back to the original that is good you continue further you continue further and you follow the rest of the part rest of the part one or five say one or five here you find that one and five sort okay that is good and if it is good take a look at this this is what we have got and again now let us merge them together once again as you merge them together once again smaller is copy then smaller is copy then just smaller is copy I guess right partition is exhausted copy the element from the left partition 8 and 9 and now you find that have a look at this at this moment I can say that my left partition at this moment I can say that my left partition is sorted my left partition is sorted temporary sort And I'm saying that now the whole this array is like sorted partition s what about right partition continue on right partition at the right partition you take it seven please pay attention you take it seven individual you take two individual you create a temporary array you create a temporary array this part is sorted if this part is sorted copy this much of part you follow the same story once again if we have got six we have got four again say create a temporary array create one more temporary array into the one temporary array copy copy copy the rest of the element so you get this you overrite onto this that is still fine and then you continue further you continue further segor temporary sorted and this part is also sorted again you continue further you create a temporary array of the four you create a temporary array of the four and you continued with this copy the smaller one copy the smaller one or two is copied then four is copied then six is copied copy the remaining elements so ultimately ultimately this part is overritten back to the original finally we reach to the last iteration last iteration in the sense the first iteration left partition I got the left partition in a sorted left partition sorted right partition sorted or it's paperwork already i hope you recall that that part so you take a time you copy the 1 2 3 4 5 then you continue 6 7 left partition is completed you copy 8 and 9 and this whole temporary array is sorted which you can go back and overrite onto the main array once again main array once again and that's it this is nothing but the whole sort but that is the reason I'm saying that recussion but still if you want any s letter you can get it from here you can go back recall the video if you need it once again right I hope mer is clear to everyone Done that is great if it is great I guess we should stop over here if you have got any doubts you can wait if you do not have any doubts you can leave bye-bye uh we will meet Monday we'll quickly finish quick sort and then Monday Tuesday we will focus only onto the graph graph implementation time complexity complexity or mer similar so we can talk at that time right [Music] [Applause] [Music]