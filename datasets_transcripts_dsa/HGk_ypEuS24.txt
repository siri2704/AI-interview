hey everyone welcome back to the channel I hope you guys are doing extremely well so this will be another lecture from the Strivers a toz DSA course just in case you for the first time here this course is India's most yes most indepth course on DS algo why do I say that the course has 4506 module you can go to the market buy any of the paid courses check out any of the free courses none of those courses on DS algo will have 456 problems or modules solved so this is definitely by far one of the most comprehensive course on DS algo and this is the only thing that you'll be requiring if you are preparing for placements so in the previous videos we have covered the step one and now we will be going to step two now the step two states you have to learn important sorting techniques in order to start your journey with Ds algo sorting is something which you have to know even if you're going for placements they might ask you sorting algorithms and the Sorting one which is Step 2.1 we have three algorithms selection sort bubble short insertion sort so if you're appearing for placements they might ask you hey can you please tell me the code for insertion sort and you have to tell them right and sorting two will be based on recursion so we'll be covering that in the next lecture so without waiting let's start with selection sort so before moving in the video let me tell you about learn base so learn B is an Tech platform that offers you data science and full stack development programs dedicated to professionals only so at learn B you will be getting 100% live online classes where you can interact with the faculties directly and get your doubt Result One Is to one one thing I did like about learn is you'll be getting an opportunity to work on industry based Capstone projects which will be certified by IBM so you're going to get a global accreditation which will be beneficial whenever you present that project anywhere that's going to be very very helpful you Al get an one is to one personal mentorship and you also get a one is to one daily doubt session where you can actually get all your doubts resolved also they have project innovation Labs across the country in Kolkata Pune Bangalore Hyderabad and a lot of other places so you can go over there and create your projects in the offline mode as well once you enroll for any of the courses you three years of subscription so you can have all the learning modules and all the videos for 3 years in this program you'll also be getting 100% job assistance by their dedicated placement cell and in the past people have got got hikes up to 250% and they have partnered with more than 250 companies like UI Intel sap and a lot others Lear B alies have also got placed in top companies like Amazon t cap gini Etc so what are you waiting for there's a link in the description click it and get your free 1 is to one career counseling session the question what is selection sort does the name recommends selection what do you select we select minimums remember this as the name name recommends what do you select we select minimums so as the name recommends select minimums so what you will do is you look at the entire array and you will say who is the minimum and it states nine is the minimum so you'll take that nine and you'll place it here perfect I place the nine here and if this nine is the minimum and you're placing it at the first place where will 13 go 13 says okay no issues I will go to your place because n has to come at first and now I'll write the remaining guys over here that's how you do it so that is the step one of the algorithm the step one States get the minimum from the entire and youve got the minimum you place it at the first whoever is at the first goes to that minimum simple as that so swapping select minimums and swap is what the algorithm is all about this is step one remember this this is step one what is step two let's see so the step two states okay I know the first I know the extreme smallest guy is at the first now we should select the next minimum we know one thing if the minimum is over here this array is sorted which portion of the array is not sorted that is this let's find the minimum can I say in this 13 is the minimum so if 13 is the minimum I know 9 will stay where 9 is if 13 is the minimum 13 will come at the first place it will and if 13 comes here where will 46 go 46 will go to 13 so 46 goes here and the rest remains as it is perfect step two done let's do step three so can I say after two steps I got the first two minimums and this portion of the AR sorted I can now we are left with this portion what to do get the next minimum who's the X minimum 20 as usual 930 stays 20 comes in if 20 is coming in here where will 24 Go 24 will go to 20 so take it to there and 550 to 46 stays step three is completed let's do step four at step four can you say that that this portion of the array is sorted you can which portion is not this one so in this which is does minimum 24 place it 9 13 20 24 52 goes at its place 46 let's do the step five so can I say at step four this is sorted and this is unsorted who is the minimum 46 so 9 13 20 24 uh sorry 46 will come here and 52 will go here now at step five if this is done do you need to look like do you need to sort one element one element will always be sort so apparently can I say the entire array is sorted at step five 1 2 3 4 5 six six elements but actually took five steps to sort the entire array what I did was get the minimum and swap it and swap it then what I did was get the minimum and swap it then what I did was get the minimum and swap it so get the minimum and swap is the algorithm now the question comes okay we've understood the algorithm but how do I implement this in code I'll be writing the pseudo code so that you can write it in C++ as well as in Java as well as in Python so in order to implement algorithms you have to have something like observing power let's start observing what the first observation in the entire array very very in the entire array we figured out the minimum can I say figured out the minimum and whichever index the minimum appeared whichever index the minimum appeared I swapped it with the first guy zero thing that's what I did that's why 13 is here and 9 is here the 0 to 5 is what I went next I took this which is from index one to index 5 and I got the minimum which is 13 and I swapped it with 46 thereby I got so I went from 1 to five and the swapping happened with one and the minimum minimum next in this I got the minimum and the swapping happened from two so can I say first time swap happened at index zero and minimum index next time swap happened at index one and minimum index and this minimum index is from the array 0 to n minus one this minimum index is from the array 1 to n minus one next time can I say swapping happened at index two because till that 0 and one are sorted and minimum Index this time is from 2 to n minus one so can I generalize this and can I say this will go like 0 1 2 till what are you doing for the last guy are you swapping the last guy is just still here you got 46 and you swapped can I say you'll go till n minus 2 index why n minus 2 index why because the last index is n minus one in arrays so can I say okay spping is happening zero 1 2 and it'll go till n minus 2 thereby can I write this as like this a pseudo code okay zero first time it will go zero next time one next time two next time three and it goes on till n-2 and I ++ can I see this the first and whenever I is 0 I find the minimum from 0 to n minus one whenever is I is one I find it from 1 to n minus one whenever I is 2 I find it from 2 to n minus one so can I say you need to find the minimum guy minimum so we know one thing I will be 0o 1 2 and there has to be an internal Loop why because you have to find the minimum in this range minimum in this range minimum in this range so the internal Loop Can You observe something from 2 to n minus one write the internal Loop what are you waiting for write the internal Loop so can I say the internal Loop will be from Jal to I till J lesser than n minus one because that is the last index until j++ and you need to find the minimum I know the internal loop as well I know the internal loop as well now what is the next thing you have to do in this range in this range you have to find the minimum how do you do it very simple can I say initially I will keep the mini just imagine just imagine since your array is from 0 to n minus one I will say okay while we start let's consider this guy to be the small while we start for this let's consider this guy to be Min while we start for this let's consider this guy to be minimum so I will say hey my minimum PS at index I itself at index I whoever is the first guy let let's assume he's the minimum I'm like okay then I'm saying if array of J is smaller than array of whatever minimum index you are considering what does this mean when I'm iterating when I'm iterating element by element I'm saying hey element are you smaller than what I considered if you are can I say minimum okay you are smaller so my minimum appears at the J index not at this guy I updated so can I say once you have iterated can I say once you have iterated in the entire thing you will get the minimum index stored at the mini variable you will you will right so once this is completed what did we do let's go back to the algo what did we do so if you're iterating over here what will happen let's see minimum initially is zero the index right the minimum is zero what happened let's see in iteration we're taking 13 it's like 13 lesser than 13 because minimum is zero what happens array of zero lesser than array of mini because mini is zero it's not there so it doesn't works next it goes here array of one lesser than array of many it's like 46 lesser than no next time 24 lesser than 13 next time 52 lesser than 13 no next time 20 lesser than 13 no next time N9 lesser than 13 so the mini gets updated to five so you know at the fifth index the mini is what did you do you took the mini index and you took the ith index and you swab and you swab so you can just do a swap you can just do a swap of whoever wherever is the mini whatever is the value with the first guy because if you have to take that mini and place it at the first first will go to that mini index the swap is also done simple as that so by the way how do you swap two numbers it's very simple imagine I have array of I and I have array of mini okay these are the two numbers that I have to swap imagine this is 15 and and this is 12 so what I'll do is I will take a temporary variable that's another third variable that I'll take and I'll say array of mini to go there so what will array of mini what will temporary have as of now 12 because array of mini is 12 and that was put in to the temporary now what I'll do is I'll say array of mini can you replace yourself to array of I so what will be the value of array of will not be 12 this value will go here and this will become 15 right now I will say array of I hey array of I can you take the value of array of many but it is replaced to 15 this is where since you stored in the temporary that works and he a temporary can you get it the temporary will get it and this will become 12 that compl got 12 so this is the swap that you have to write this is the pseudo code of swap function so if I had to code it up imagine I've given the N I take it as the input then I take this array of N and then I go across and I say this so this is basically nothing but the array input that I'm taking now I have to write the selection sort so maybe I can say selection I'll just pass it into the function I'll pass it let's write the selection s so void selection and this will be sort and I'll say let's take the array and let's take the nend so so I'm passing this and I'm assuming this will do it and post this what I'll do is for I I equal to z i lesser than n i++ can I print the array values to see if they are sorted or not okay let's see if they are sorted or not and what we can do is we can take the same example that we took it had six numbers 13 46 24 52 20 and 99 the same example over here let's quickly write the code so whatever pseudo code I did write that I've converted into code now over here and if I go across and run this particular task you will see that this particular array is sorted over here in the output.txt so you have understood the selection sort algorithm in depth it's time to analyze the time complexity of this particular algorithm let's see can I see for the first time when the loop gets inside this particular Loop runs for n times exactly yes next time when it gets in then this actually runs for one lesser it's it runs for 1 to n minus one so can I say it runs for n minus one next time when it gets in it runs for one lesser so it's like nus 2 next time when it gets in runs for one lesser nus so so on it kind of runs for till last last that we run for this is still here that's for two times so this is kind of kind of if I just try to take it to some near near formula stuff can I say it's something like 1 + 2 + 3 plus dot do dot till n which is nothing but the summation of the first n natural numbers which is n into n + 1 by 2 can I say this I can if I can say this what is this n² Plus n by 2 can I say this is how it looks like and if you remember the time complexity Remember the Time complexity leure we did we ignore smaller things because n by2 in comparison to n square is very small and we ignore constant thereby I can say that the time complexity is near about beo of n² and this is the best this is the worst first and this is the average time complexity for this particular algorithm so we can say that we have completed selection s successfully now it's time to understand bubble shot bubble shart so when we talk about Bubble shart you have to remember it pushes the maximum to the last and opposite to the selection because selection s was taking the minimum at the front if you remember pushes the maximum to the last how does it do it by adjacent spping adjacent swapping is the key over here how how does the algorithm work let's understand first two elements Compares are they in the sorted order 13 and 46 they are because 13 is smaller than 46 do not do anything go to the next two are they in the sorted order 46 before 24 no swap it okay 24 24 4 perfect let's go to the next 4652 are they in the SED order yeah they are why will you do anything next 50 to 20 are they in the S order no 20 should be before take 20 here take 52 here so 20 52 let's go to the next 50 to 19 are they in the sorted no so take here take here so let's 2 9 and then 52 so can I say after adjacent swaps like this like this like this like this like this one complete round of adjacent swap checkings Do You observe something the max 52 is at the last the max 52 is at the last done so the max 52 is at the last what should be your next step this this portion of the array is kind of sorted so I need to work on this perform the same algorithm again let's do it 1324 is it okay it is 24 46 is it okay is 4620 no no no no swap 46 here take 20 here let's swap it 20 46 let's go to the next 469 are they no no take 9 here take 46 here 9 46 do you compare the last two there's no point because 52 is already in the sorted F there's no need you only do it till here can I say no in this particular array 46 was the maximum and it's at the last thereby after two steps the last two are in the correct orders so Step One is done step two is done let's do the step three so this is done this is done let's do the step three step three means this portion should be making sure that the maximum is over here let's do it 1324 are they they are 2420 no no no drop it 2024 next 249 no no drop it done in this 24 was the maximum eight at the last step three done step four can I say step three means last three elements done this is left 1320 correct 29 no SWAP SWAP SWAP 920 can I say for this 20 was the largest and it's at the last so thereby post step four this is done next step five what is step five this let's do a comparation no ST 913 for this portion 13 was the maximum and it's at the last so for this portion 13 was the maximum and it's at the last so thereby this portion is sorted post step five do you need to do for a single element you do not thereby the entire array is sorted if you see so uh so you have understood the algorithm but now the key factor comes in which is implementing this two code because that is where the key lies let's try to do that what are we doing observation is the key 0 1 2 3 4 5 we're going till the first step we went everywhere and we did adjacent component so the for the first time we can kind of went till 0 till n minus one and we did adjacent swaps if if it was not in the order next time we went like 0 to n minus 2 because the last was s next time we went from 0 to nus 3 next time we went to 0 to nus 4 can I say this is what we are doing and the next time time 0 to nus 5 and so on can I say I will just do till 0 to 1 not till 0 to 0 because one element will not matter to me if you carefully observe first Loop should run from here to next Loop should run from here to here so kind of can I say I can probably keep the value of I from nus one till I can I keep I can so if I do it I = to N - 1 I greater than 1 and IUS one this is what I have and internally I can always run the loop from J equal to Z till J lesser than I and j++ is it similar is it similar observe 0 to n minus1 0 to n minus1 for the first time next time I is nus 2 so 0 to n minus 2 next time I is nus 3 so 0 to nus 3 so I have made sure the looping is done what is the next thing that you doing the next thing is very simple you take up two elements and you compare you take up two elements and you compare so when you're looping from 0 to n minus one it's kind of this is J so you're comparing J with J + 1 and if they're not then you swep right so you're kind of comparing what are you comparing if a of J is kind of greater than J + 1 it's not in the correct order then you're saying swap then you're saying swap both of them a key thing to notice over a very key important thing if you are going from here to here that is wrong because for 52 it will have no one to compare with you actually go from here to here because of 46 gets compared with J + 1 which is this you actually Loop till here so what you can do is you can go over here and say instead of going till I exactly I will go till I minus one because if I go till here if I go this will compare this will compare this will compare this will compare and 4652 will be compared because I'm doing j+ I'm taking the next index I don't need to go till so you can just go till one lesser in and if you do not do that what will happen for 52 it will look for the next index which is not present and if you are accessing ing an index which is not present it will throw a runtime error remember this if you are accessing an index which is not present it will say runtime I did not it's a runtime that's why it's very important to run your Loops perfectly that's when you swap and once you have done this all steps at the end of the day the array will be sorted so what we will do is now we will write void bubble sort we'll do the same thing array and n and instead of calling the selection sort we will say hey bubble so I will just quickly go and write the same pseudo code so if you remember this was kind of array of J if greater than array of J + 1 then you swap and in order to swap I've already taught you how to do that swapping you do this and then you say Okay array of J + 1 can you store array of J and in Array of J can you take the value of the array of J which is j+ one which is stored in temporary once you have done this entire thing the array will be sorted I'll just go ahead erase this output.txt and now go across and say to run it and see if the bubble shot is actually producing it it is it is producing so if I have to analyze the time complex lexity can you analyze the time complexity for me for this particular case is quite similar to The Selection s first time the algorithm kind of runs for n then for n minus one then for n minus 2 then for n minus 3 so kind of it's similar to selection sort where I say it's n + n minus1 + n minus 2 plus so on the last is two it's something if you just add a one to it it's similar to sum of N natural numbers so again n into n + 1 by 2 which is n 2 by 2 + n by 2 smaller constants dissolved so the complexity is B go of n² can it be optimized that's my yes it can be it can be optimized this is the worst complexity this is the worst complexity and you can also call it as the average complexity in most of the cases this will be the most of but imagine if I give you a array which is something like 2 3 5 15 and 20 if I give you an AR L you'll be like tror this is sorted yeah it is sorted so do you run the loop for n Square do you go across every time every time no so what is the algorithm correct order no swaps correct order no swaps correct order no swaps correct order no swap dude if everything is in the correct order and you're not performing a swap if everything is in the correct order what does it signify the array is in the ascending order if everything is in the correct order the array is in the ascending order so in the first check you did not find a swap to be done because everything was in the correct order so can I say if I do not do any swaps if I do not do any swaps that's when I stop I do not per so it's kind of if no swaps done I don't need to go if on the first check no swap is done I don't need to go for this for this for this for this we stop so the loop the best case will run for B go of n if we do some optimizations let's go and do some optimization can I say if I say in did swap equal to zero and over here if I just can say did swap equal to one which means if any if at any moment a swap happened then it's okay but if did swap at any time is there was no swap then I break out I will not go if the array is sorted it will just check for the first time and it will break post it right this also runs I'll I'll prove you uh this one I'll prove you this one so I'll give you an example see 6 5 4 3 2 1 now what I'll do is I will just go ahead and print this how many times the array runs okay and runs and I'll just give it and you can see how many times it runs now terminal and I'll go to run task this is a descending order and it runs for five times because the size is six it runs for five but if I just change it to something like 1 2 3 4 5 six and now see how many times the first fall Loop let's see uh did it one just a minute SL one okay let's run it run it did you see something it never came to this because it it did break over here so it just ran for the first did not Swap and broke so can I say can I say the best time complexity will be nothing but B go of n the time complexity for the best of bubble shot is beo ofen this might be asked in an interview you have to critically tell them the use case you have to explain them in the dry and tell them the worst and the average might be n square or if the AR is sorted out I will break out and I will end up getting a linear time complexity because the array is already so so the bubble shot is done now let's move on to the next one that is the insertion sort algorithm so talking about insertion sort you need to remember one thing it always takes an element and places it in its correct position takes an element and places it in its correct let's start yeah the algorithm starts with looking at the first element as an array and you will say that if this much is the array the element 14 in a size one array is at the correct if I look at this much and I ask you is nine at the correct position you'll be like no nine apparently should have been here and 14 should have been here this is what you do you go to the next element and you ask on the left side where 9 should have been and that is where you take so you basically do it like this 940 perfect so then you go ahead to this one and you ask is 15 at the correct position for a size three and you say then you go ahead and say is 12 at the correct position for a size four and you say no app 12 should have been here 14 should have been here 15 should have been here so do you see a pattern it's like 14 will come here and 15 will come every one right shifts by one and 12 kind of goes in its correct qu so what you can do is you can take 12 and you can say Okay 12 15 15 will come here 12 will go here then you can say 12 14 so you can 12 here and you can pass 14 here you can go to the left and SWAP SWAP SWAP till it can be swapped till it can be swep so if you do like this 12 goes here it's like 12 and 15 then 12 14 so 12 goes here and 14 comes go to the left till it can be can 12 be swapped with 9 no because that will distort the order it just goes till here simple so what will happen it'll be like 12 14 15 perfect next is six if you look at six where ideally should be six in this array it should be here 9 should be here 12 should be here 14 should be here 15 should be here so can I do this can I take this six here but I have to I have to write shift every one by one how do you do it you take six you take 15 and you say Okay swap your sir what happens is six goes here 15 goes here swept next you take six 14 14 comes here and six goes here here next you take 6 12 12 comes here six goes here next you take six and 9 six goes here 9 comes here simp if I have to do it it's like 6 15 not in the correct order let's swap it 15 comes here and 6 goes here 14 6 no 6 comes here 14 goes 6 12 no 12 comes here six goes 69 No 9 comes here six Co perfect it's like 6 9 12 14 15 so I have to write it by raising it's like 6 9 12 14 15 perfect I just went down to the left till it could have been SWAP SWAP SWAP right next eight in this particular array where does eight will go where will eight go in this particular array where will eight go ask yourself the answer to that is eight will go here so if8 has to go here 9 has to go here 12 has to go here 14 has to go here 15 has to go here so again what do you do 8 15 you say Okay 8 goes here 15 so left can 8 14 can8 go till 14 yes 14 comes here 8 goes here can it go more left yes it can 8 goes here 12 goes here can it go more left yes 9 goes here8 goes here is it in the correct to yes how do you know it because when you compareed 8 with six it was not compared D and dusted 689 12 145 689 12 145 remember this 6 8 9 12 14 15 next 13 is the next guy that you are comparing can I say 13 ideally over here should have been here so do it again 13 goes here 15 comes here 13 goes here 14 comes here can I do a 13 12 no stop can I say post the last the array is sorted why because you picked up every element and you did put it into its correct so how did it work I picked up one first time I picked up the first guy next time I picked up the second next time the third next time the fourth next time the fifth next time the sixth next time the seventh picked up every guy I'm running from index 0 to n minus one that's for sure that's something for sure I'm running from 0 to n minus one and what am I doing what am I doing every guy I'm looking at the left are you greater swap are you greater Swap and until I can do it like for 13 I could do till here till it is possible on the left so I'll be like okay maybe J is I and I can keep while J greater than zero and I can say and and okay hey left J minus one because the last that you can compare is still here is still here that's the last you can compare so imagine this was not 13 I'll give you an example if this was like 14 15 and this is seven the seven would have last gone here or imagine this was five for an example if this was five what would have happened five would have gone like till here and then five would have got compared with six five standing here five standing here would have compared it on the left that's why you don't go till zero because right before zero you do the last comparison that's why and that's why J minus one the last comparison if it is greater than a of J if it is greater that means can you please swap so I'm not writing the swap you know how to write you say a of J minus one and a of G that's what you say right and that's when it ends and you can just do a j minus minus over here because what am I doing is I'm taking the element and I'm saying left CH left small left small okay and go left again come back left small slap again go left left small go the moment it's not small stop and go to the next guy why simp so now time to write insertion s right so void in insertion sort in Array and in N so as usual we can just do this as insertion s okay and I'll quickly write the code until here you know the pseudo code why J greater than Z why not greater than equal to imagine if J goes equal to Z this J minus one like when J is zero J minus one will be minus time that's all right so over here you can go ahead and swap it in temporary equal to AR of J minus one and then array of J minus one is array of J and then you can go ahead and say array of J is equal to Temporary and once you have swapped let's go more left so J minus minus now let's go ahead and quickly run this and see if this is sorting this particular thing yeah it is sorting done simple if we analyze the time time complexity what will be the time complexity imagine for a reversed array like something like five 4 3 2 1 What's happen for the first time five no swaps next time it comes to four and does a swap it's like four five next time it comes to three does a complete like three goes here then three goes here next time it so it's like 3 4 5 2 1 next time it comes to two two goes here two goes here two goes here two kind of goes here it's like 2 3 4 5 1 next time it comes to one one goes here one goes here one goes here one goes here so it's like 1 2 3 4 5 it's kind of going extreme left to the to the extreme left this Loop for the first time ran for zero times when it was at five when it was at five when it went to four it sted one place next when it was at three it swapped two places next when it was at two it spped three places next it was when it was at one it went left four places it's kind of again going into the similar direction of summation of natural numbers which is n cross at n + 1 by two makes it near about the time complexity of n squ if you remember the time complexity class so I can see the kind of worst case is n² the average case is also n s but what about the best case imagine I give you something like 1 2 3 4 5 1 2 3 4 5 and I go back to the code and I go back to the code so imagine it give you a completely sorted and I go back to the code and let's see how many times this Loop runs go to the terminal and try to print it this Loop will not run a single time because for one there's no one on the left for two there's no one on the left three is already in its correct position four is already in its correct position five is already in its correct position six is already so this putting them into the correct position never happens so apparently only this Loop runs for check a be it's a b ofen the best case for this is nothing but beo of n complexity because there is no swaps that happen everyone is at its correct order just go to everyone that is what the time is taken for in case of insertion s so so with this I can tick mark insertion sort and it is completed uh the time is 5:29 yes because I do take a lot of retakes while recording because I want it to be perfect like a lot of times I teach two or three times so please uh please for this effort if you understood everything do consider hitting that like button and to follow our ritual please do comment understood if you understood everything and if you have doubts you can definitely put that into the comment section I'll be uh replying to them and if you're new to our Channel what are you waiting for hit that subscribe button and follow sters A2Z DSA course share your learnings with the hashtag and yes if you haven't followed me on Instagram Twitter LinkedIn all the links will be in the description make sure you follow me with this I'll be wrapping up this video let's put in some other video till then bye-bye take care whenever your heart is broken don't ever forget your golden I will find a light