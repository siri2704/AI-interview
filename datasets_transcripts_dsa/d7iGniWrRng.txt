hey everyone welcome to simply launch youtube channel in this session we will be learning all the sorting and searching algorithms in one tutorial but before we begin let me tell you guys that we have daily updates on multiple technologies so if you're a tech geek in a continuous hunt for latest technological trends then consider getting subscribed to our youtube channel and don't forget to hit that bell icon to never miss an update from simply learn now without further ado let's get started with the agenda for today's session at first we'll start with bubble sort algorithm followed by that we have quick sort algorithm binary search algorithm insertion sort linear search algorithm bfs or breadth first search algorithm depth first search algorithm bucket sort algorithm counting sort algorithm and radix sort algorithm followed by that we have heap sort algorithm merge sort selection sort shell sort algorithm and finally we'll wind up this session by learning greedy algorithm so all these algorithms will be explained with detailed theory along with their practical implementation i hope you will have a pleasant learning experience of all the searching and sorting algorithms in one tutorial and if you require the code for all these algorithms please feel free to let us know in the comment section below and we will be sending them off to you as soon as possible now without further ado let's get started with the first algorithm over to our experts let's try to understand what is a bubble sort algorithm the bubble sort algorithm is one of the fundamental and simplest forms of algorithm used to sort a collection of elements the collection of elements can be either a set of numbers or characters the control iterates through a sequence of numeric or character type elements in the bubble sort algorithm and rearranges them into ascending or descending order the bubble sort algorithm rearranges one element at a time the bubble sort algorithm is also known as the sinking algorithm here we have some random distributed elements which are 30 10 20 50 and 40 and after performing the bubbles out algorithm all the elements are sorted as 10 20 40 and 50. so how is it done we will see in the next segment where we will understand the working terminologies of bubble sort algorithm the bubble sort algorithm will not get implemented on the entire array in one go instead it compares two adjacent pairs of elements in an array if the elements are not in the correct order then they are swapped so the largest of the two moves towards the right and this process continues until the most significant element or bubble is moved towards the highest position after the first process is finished the search for the next most significant object starts and the swapping continues until the whole array is in correct order this process is employed when you want to arrange the elements in ascending order to understand the logic in a better way let's go through an example the example on my screen consists of five elements according to the bubble sort algorithm logic we need four iterations to sort all the elements in the ascending order or in descending order the elements in the array are as follows they are 3 8 4 2 and 12. so in this array the index begins with 0 and ends with 4 and each time the bubble sort algorithm goes through the data element list and it is known as a pass let us analyze the total number of comparisons required to sort the array in the correct order according to the formula if n is the total number of elements in an array then the total number of comparisons needed to sort the entire array can be calculated by a simple formula shown on my screen that is n is equals to n minus 1. so in this scenario we need 5 minus 1 that is 4 comparisons or passes to sort the entire array in the first pass there are 4 steps let us select the first two elements that is 3 and 8. according to the requirement we need to sort this array in the ascending order hence when we compare 3 and 8 clearly we get 3 as the least number so we do not need to swap them next is the step two comparing the second and third elements which are eight and four here we need to swap these two elements because eight is always greater than four and it requires placing the elements in the ascending order now moving ahead we have step three moving on to the third and fourth elements which are eight and two and here again we need to swap eight with two because eight is greater than two and in the step 4 we have we have the last elements which are 8 and 12 there is no need to swap because 8 is already less than 12 so you can see it clearly so now we enter into pass 2 and in past 2 we need three steps so the first step in the second pass let us select the first two elements which are three and four no swapping is necessary as they are already in order next we have step two in step two we need to select the elements two and four as you can see two is always less than four so there is no swapping required next we have step three in step three we need to compare the elements 4 and 8 and here we may not need any switching because 4 is already less than 8. now here you can see that we are not comparing 8 and 12 because the last element is already sorted now we have come to the last pass and here there is only one step the step is to compare the first two elements 2 and 3 and then swap them as 3 is greater than 2. now the array is finally sorted and we do not need to do any more comparisons after understanding the working process of the bubble sort algorithm we will see its pseudo code in this pseudo code there is a function named as bubble sort the bubble sort function includes an array of collections of sortable elements let us consider n as the length of the array after that we have to repeat comparisons for the first element to the last element of the array if the first element is greater than its next consecutive element then we must swap both the elements and place them correctly we do not need to switch after closing this repeated statement and getting out of the loop this bubble sort function will end after understanding the pseudo code of the bubble sort algorithm let's learn about the optimized bubble sort algorithm so we can optimize the algorithms in a loop by programming it to avoid the comparison at n minus 1 position after every iteration since the nth element is already sorted in the previous iteration more generally more than one element may be placed in their final position on a single pass all the elements after the last swap are sorted in every pass and do not need to be rechecked optimized bubble sort algorithm allows skipping over many elements this results in a worst case that is 50 improvement in comparison count and adds little complexity because of the new code sub sums the swapped variable next we will learn variations of the bubble sort algorithm so there are two variations of the bubble sort algorithm they are odd even sort and cocktail shaker so odd even sort is a parallel version of bubble sword for the message passing system whereas cocktail shaker is a sort of bi-directional bubble sort that first goes from beginning to the end and ends to the beginning after knowing the variation of the bubble sort algorithm now we will see the complexity of bubble sort algorithm so the best case of the bubble sort algorithm is big o of n where n is the number of elements being sorted and worst and average cases of the bubble set algorithm are big o of n into n and lastly the space complexity of the bubble sort algorithm is big of one here n is the number of data elements being sorted let us understand when this complexity occurs the best case of bubble sort algorithm is o of n which occurs at all the data elements in an array are already sorted here we have an example with some data elements in an array which are already sorted that is 10 20 30 40 and 50. next talking about the average and worst case the worst case and average case of the bubble set algorithm is o of n to the power 2. that is n squared or n into n it occurs when all the data elements in an array are reversely sorted again we have an example that consists of data elements that are reversely sorted that are 50 40 30 20 and 10 in an array lastly we have space complexity the space complexity of bubble sort algorithm is o of 1 because only one additional variable is required to implement bubble sort algorithm that is temporary variable we came to the last topic where we will understand four main applications of bubble sort algorithm first application of bubble sort algorithm states that this sorting technique is used to sort the elements in a specific order the bubble sort algorithm uses less storage and is the second application of bubble sort algorithm third the real-life application states that the bubble sort algorithm is used to store the students based on their height in a line lastly bubble sort is used to create a stack pile up the elements based on their height after covering all the bubble sort algorithm topics we will now see a practical demonstration of bubble sort algorithm now on my screen we have an example for bubble sort algorithm so let us get started with the code in this code at the first position we have some header files that is standard input output standard library etc after that we will define the main function in the main function we will declare an array with maximum size of 50. so here you can see that we have the first array variable that size is 50. size will be defined with declaration only because we cannot change the array size in the run time after that we will declare four variables that is a b num and temp num variable will store the number of elements of an array after that we will ask the user how many elements are required for the array using printf function so here is the printf function where we will be asking the user to enter the number of elements in an array and the user will enter the elements and this will be done using scanf function then finally we will print all the elements that the user wants to store in an array using another printf function we will have three loops firstly there will be a loop from the first element to the last element of the array so this is the first for loop we need then second the for loop will use the variable a for the rotation purpose as we know rotation equal to number of elements minus 1 so it will make a loop from index 0 to number -1 the last loop is used for how many passes will be required for the implementation and we already pass equally to the number of elements minus number of rotations minus 1. so there is the loop from index 0 to number minus a minus 1 then there will be the if condition stating that if the first element of an array at index b is greater than the element at the index b plus 1 then we will make swap then we will come out of the loop and we will print all the array elements after performing the bubble sort algorithm now let's quickly execute this program and see the output so you can see the program got successfully executed now let us enter the number of elements let me choose 5 now let us enter the elements in a random order so this was the array input 3 2 4 1 and 5 and here after executing the bubble sort algorithm we have the sorted array that is 1 2 3 4 and 5. let's get started with an introduction to quick sort a quick sort is a highly efficient sorting algorithm and it is based on partitioning an array into smaller sub arrays and then we will sort these two resulting sub arrays in the same manner this algorithm is quite efficient for large size data sets as its average and worst case complexities are big o of n square now let's discuss algorithm of quick sort let's say we have an array first we have to select a pivot we can select either the first element or the last or medium or any random element as pivots this pivot will dissect the array into two sub-arrays then we will shift all smaller elements then the pivot element to the left then we will again apply the same operation for the left subarray and take pivot like we did for the main array we will perform the same for the right sub array as well we have now introduced the quick sort and its algorithm now let's implement this algorithm in the code editor we will start by creating a function swap so void swap int star x comma end star y am equals to star x star x is equals to star y ry is equals to temp now we will write a function which will partition this array this function will take the last element as pivot and the pivot element at its correct position in sorted array and places all smaller elements to the left of the pivot and all greater elements to the right of the pivot so int partition and arr comma and low comma and i so end pivot equals to ar high now end i is equals to low minus 1. so for end j is equals to low j less than equals to high minus 1 a plus plus now if current element is smaller than the pivot so if arr at j is less than pivot then we will increment the i then we will swap ampersand array i comma ampersand array at j and we will swap ampersand array at i plus 1 comma ampersand array at high and then we will return i plus 1. now we will write the main function that implements quick sort so void quick sort and arr bracket comma end low comma and high so if low is less than high and pi is equals to partition arr comma low comma hi now we will separately sort elements before partition and after partition so quick sort arr comma low comma pi minus 1 and quick sort arr comma pi plus 1 comma hi now we will write a function to print this array so void and array and arr comma and size and i so for loop i is equals to zero less than size a plus plus c out array and now we will write the main block so end array and comma 7 comma 8 i will find the size so int n is equals to size of array is divided by size of array element at zero now we will call quick sort for array a comma 0 comma n minus 1 now we will print this so c out sorted array print eric err command now let's execute this as you can see we have successfully sorted our array let's get started with introduction to binary search tree binary search tree is a set of nodes organized in such a manner that they all have the same binary search tree characteristics a key and a value is assigned to each node the requested key is compared to the keys in binary search tree so during search if the key is found then the corresponding value will be retrieved next up properties of binary search tree first up the left subtree of a node contains only nodes with keys lesser than the parent node next up the right subtree of a node contains only nodes that are greater than the parent node the left and the right subtree each must also be a binary search tree next let's discuss what are the operations we can perform on a binary search tree first up insertion last deletion let's discuss them in detail first up insertion we can insert a node in a such a way so that we obey binary search tree rules that is the new node should be either less than the parent node if it's a it's on the left subtree or if it's on the right subtree it should be greater than the parent node let's execute this in the code editor we will start by creating a class for the binary search tree so class pst and data and bst pointers left comma right next we will define some functions publicly public first default constructor and a parameterized constructor a function to insert the value and a function to traverse the node now let's write default constructors definition so bst pst now let's write the parameterized constructors definition bst and value data is equals to value and left is equals to null and right equals to null now let's write the definition for the insert function so bst bsd star root comma end value now we will check if the tree is empty or not so if root then we will insert the first node we will return new pst value otherwise we will insert the data so if the value is greater than root data then then we have to insert it in the right subtree so root right is equals to insert right comma value else else the value should be inserted in the left side root left is equal to insert root left comma value and then we will return root now let's write the traverse function so void tst drivers tst star route if root and we will return otherwise we will first traverse left side then we will print the root data then we will traverse the right side root right now let's write the main block so we will start with an empty tree so bst b comma star root is equals to null root is equals to b dot insert d dot insert equals to root comma 10 b dot insert gonna be root comma 30 d dot insert root comma fifty sorry we already use 50 so we will use sixty a dot insert root comma let's use 20 let's try to traverse this so b dot traverse root let's execute this as you can see we have successfully created and traversed our first binary search tree let's get back to slides at last deletion we will delete a node following the binary search tree rules that is the value of the left subtree should be less than the parent node and the value of the right sub tree should be greater than the parent node let's try these in the code editor let's start by creating a node this time we will use structure so struct node node start left comma star right now we will create a utility function to create a new binary search tree node so struct node star new node and item equals to product star malloc size of node next temp will be assigned the key is equals to item amp left equals to null and stamp right is equals to null now let's write a function to traverse the tree traverse product node star root so if root is equals to null traverse route left see out root e traverse route right now let's write a utility function to insert the new node with the given key in the binary search tree so struct node star node comma and key so if node is equals to null then we will return new node key otherwise we will recur down the tree so if e is less than the node key then we will insert in the left subtree so node left is equals to insert node left comma key else node right could be inserting now let's return the node now we have given a non-empty binary search tree so we have to return the node with the minimum key value found in that tray so we will start destruct mode start men value node note star mode node star current is equal to node so we will loop down to find the leftmost leaf so while current and parents left is not equals to null so current should be equals to current return current delete node product node star loop comma and key if equals to null return root now if the key to be related is smaller than the roots key then it lies in the left subtree so we will check if e less than root key then root left will be equals to delete node root left key comma key now if the key is deleted is greater than the roots key then it lies in the right subtree so else if e is greater than root root right is equals to delete node root right comma okay if roots dot left equals to null and root dot right is equal to null and return else f root left equals to null then struct node star is equals to root right and free root return temp else if roots right is equals null then struck is equal to root three route return amp now note with the two children get the in order successor smallest in the right subtree so struct node star temp is equals to min value node root right now we will copy the inorder successors content to this node so root is equals to temp now we will delete the inorder successor so root right first to delete node root comma temp now we will return route now let's write the main block we will start with an empty tray note star route is equals to null now root is equals to insert root comma 2 root is equals to insert root comma 5 root is equals to insert root comma 3 root is equals to insert root comma 4 root is equals to insert root comma 7 and root equals to insert root comma 6 let's try to traverse this so c out traversal of the given i was root now first we will delete a value c out delete to our root is equals to delete node root comma true see out traversal after deleting drivers route let's execute this as you can see we have successfully deleted to and traverse the tree again let's get started with an introduction to insertion sort insertion sort is basically a sorting algorithm in which each item in the final sorted array is sorted one at a time and it is significantly less efficient than more sophisticated algorithms like quick sort heap sort or merge sort on larger data sets now let's discuss the algorithm of insertion sort let's say we have an array we will start with traversing the array from index 1 to n minus 1. while traversing we will compare elements at the current index to its predecessor if the data at the current index is smaller than its predecessor then we will compare it with the element before that after that we will shift bigger elements to an index up to make space for swapped elements then we will shift the bigger elements to an index up to make space for the swapped element and then we will iterate the same steps again to sort the complete array we have now introduced the insertion sort and its algorithm now let's implement this algorithm in the code editor we will start with creating a function to sort an array using session sort so void insertion sort we will give it argument as end array arr comma int size we will declare variables and i comma key comma j now we will create a loop for loop from i is equals to 1 to i less than size i plus plus here we are traversing this array from index 1 to the size n minus 1. so key is equals to arr at i and j is equals to i minus 1 now we will move the elements of arr 0 to i minus 1 that are greater than the key to one position ahead of the current position so while j is greater than equals to zero and arr at j is greater than key and we will swap these so a i r at j plus 1 is equals to a r f j and j will be equals to j minus one and then we will assign arr j plus one is equals to key now we will write a function to print this array of size void and array we will give its argument as end array and size size we will declare end i is equals to zero for loop i is equal to zero i less than size i plus plus c out arr arr bracket eye and say out and now we will write the main block so end arr is equals to 12 comma 11 comma 15 comma 9 comma 6 comma 7 and size is equals to we will find the size using size of so size is equals to size of arr divided by size of arr at index 0. now we will print this array without sorting so c out unsorted array we will print array error comma size now we will call insertion sort arr comma size c out we will print this array sorted now we will again call print array argument as arr comma size now let's print this as you can see our function is working flawlessly it has sorted this array now let us try to understand what exactly is searching searching in data structure refers to the process of finding the desired element in the set of items the selected item is called the target element any data structure such as an array linked list tree or graph can be used for searching a set of elements in data structures searching can be categorized into two types first type is the sequential search in which we check the elements in a data list or an array one by one in data structures searching can be categorized into two ways the first type is a sequential search in which we check the elements in a data list or an array one by one an example for sequential search is linear search now let us learn about the next type of searching approach the next type of searching approach is the interval search approach interval search divides the search in half by repeatedly targeting the center of the data set the binary search algorithm can be an example for interval search we will go over the binary search algorithm in detail in our upcoming video after understanding the logic of search and the types of search we will get into understanding what is linear search algorithm the linear search method is a simple search technique in this type of searching approach we perform a sequential search across all objects one after the other every element is examined and if there is a match found then the specific element is returned otherwise the search will continue until the data gathering is complete let us go through an example for better learning experience on my screen we have the following elements 50 10 20 30 70 40 90 60 as randomly distributed elements let us imagine that our target element is 17. we found that our target element was 70 using linear search strategy so how does it work in the next segment we will look into the working terms of linear search algorithm the simplest method of searching the data collection is the linear search starting from the beginning of the data set each element is examined until no match is found the linear search is completed after the item has located in the first stage we compare the first element that is 50 to the searched element that is 70. we will go on to the next element because 50 and 70 are not matched we will compare the second element which is 10 to the search element that is 70 in the next step and once more there is no match found then we have the element 30 as the next comparison and 70 and 30 are not matched we have the next element that is 20 in the fourth phase and there is no match when we compare 20 with 70. moving on to the following stage we have the data element 70 and after comparing 70 with the search element there is a match we will now have the searching and display index as 4 and this index contains the searched element we now comprehend the pseudo code of the linear search algorithm after learning the working terminology of linear search algorithm first we have a function called linear search which has two variables in its parameters the arrays name which is an array and the search variable which is the value then using a follow we must search for our target variable by analyzing all the data elements in the data set with the condition that is the search item is identical to any sets value we must return its index value now we must stop searching once the searched value has been discovered then we will close our if and for loop as well as the linear search function we will now look into the complexity of linear search algorithm after comprehending the pseudo code the complexity of linear search algorithm is divided into three categories the best case which is the big o of one the average case which is the big o of capital n and the worst case scenario which is same as the average case which is the big o of n here n is the number of data items to be sorted let us look into how all these complexities of linear search algorithm play out in detail first we have the best case which is big o of n as a result the best case scenario happens when the searched element is found in the data sets first block as a result the search takes a constant amount of time here is an example of an array with 50 10 40 20 30 as the elements now our search element is 50 which is located in the first location of the array then there's the typical case of linear search algorithm which has big o of n and occurs when the search element is in the middle of the data set or any point of the data set with the array containing the same search element 50 we can easily see that the element 50 is present in the center of the array at the location number 2. finally we have the worst case which is big o of n which is same as that of the average case of the linear search algorithm and happens when the search element is in the last block of the data set as a result of the number of searches required is proportional to the number of elements as demonstrated in this example the search element 50 is found in the last block of the array index which is 4. in the next segment we will look into some real-world instances of linear search algorithms according to the first application of the linear search algorithm linear search is particularly efficient when it comes to discovering a particular string next we will look into the second application of linear search algorithm when a data set has only few elements linear search is the simplest to implement the final real world application of the linear search algorithm is with the help of telephone directory you may find out the name of a person with the phone number one two three this can be implemented easily using linear search algorithm now let us have a look at the linear search algorithm working in practical demonstration so on my screen we have an example for linear search algorithm we have included three libraries standard input output standard library and console input output library then we have entered the main function where we have declared an array with maximum size of 50 elements a counter variable i a variable named target where we would store our searched element and finally num variable where the number of elements in the array is recorded then we have a printf function to ask the user how many items are there in the array and then we use a scanf function to allow input from the keyboard so we have added percentage d format specifier to the scanf function which is used for numeric values and num variable then using a for loop we will try to print all the items in the array starting with 0 and ending with num variable which is the last element then we will enter our search element which we want to find among all the elements of the array and as previously said we'll store the found element in the target variable following that we will use the for loop to examine all the elements in the array then we use the if statement to check for the element is identical to our searched element or not if the element is found we exit the for loop and we will break the keyword and if the target values location is less than the number of elements in the array then we will return the location otherwise if the value location is greater than the number of elements in the array then the search will be unsuccessful and we won't be able to find the searched element now we will compile this code and see the output so there you go the code got successfully compiled now it is asking for the number of elements in the array let me give us five elements now let us enter the elements into the array let us enter some random elements now we have entered the five elements let me provide the searched element as 2 now we have found the target element to be found in the location 2 that is 0 1 and 2 yeah 2 is located in the second index location first we'll build a breadth first such algorithm which begins by traversing the root node and then moves on to all the other nearby nodes the breadth-first search approach repeats the procedure for all the nodes until the desired node is found the queue data structure is the data structure that is used for breadth first search algorithm for a better understanding we look at an example of breadth first search algorithm the blue color indicates that the note has been already explored while the pink color indicates that the node has not been explored yet or visited yet next we'll have our output we will use a queue data structure to keep track of all the nodes visited and all the nodes that are unvisited so to begin let's look at the algorithm as a result we'll have node a which is added to the output and marked as visited we must verify all the unvisited addition nodes of a that is node b and node c and add b and c notes to the output and enqueue to the queue according to the breadth first search algorithm then we'll look at any node between b and c we'll start with node b node d is unvisited adjacent to node b so we'll add node d to the output and q and since node b is now being visited we'll dequeue it when it goes to node b the next unvisited node is node e add node e to the output and enqueue to the dq once node d has completed its traversal dq from the queue now in the case of node e the addition node is node c which is already visited thus we will dequeue node c from the queue now that the pointer is pointing to node c and node f is the next unvisited node after the node c we will set node f to output and q here the pointer leads to node f which has no unvisited adjacent nodes so we will dequeue f from the queue and q is empty so we'll come to the halt here here's what we got that is a b c d e and f after understanding all the theoretical aspects of bfs algorithm let's look at the code of bfs algorithm in c programming language now we are on the practical mode on my screen you can see an example for bfs algorithm we have declared a two dimensional array with maximum row and column size of 10 and two arrays the first one is a square of a maximum size of 10 and second one which is a visited that stores the maximum size of 10 as well some variables n i j and finally we declared front which is initialized with 0 and rare variables which is initialized with -1 we perform a loop from index 1 to the size of an array visited in this function with the condition that if two dimensional array of column one and visited array of index is not one we initialize variable i to the front of the queue then one is set as the front of the queue index of the visited array and we use the breadth first search function with the vertex as the front of the queue until front is less than or equal to rare then we enter the main function where we define the variable x that stores the graphs vertex and then we use the printf function to enter the number of vertex that will be stored in variable n then we perform loop from index 1 to queue size and visited array in which we initialize 0 to the queue and index 1 to the visited array then after that we'll enter the graph value in the form of matrix of two dimensional array by performing the loop with two variables i for the graph rho and j for the graph column then we print the source node which is saved in the variable x then we print the source node which is saved in the variable x and we call the breadth first search function or method which takes a vertex x as parameter and we print which nodes are reachable by looping from index 1 to the size of the visited array if index 1 of the array is visited otherwise breadth first search is not possible so this was the explanation of the program now let's try to execute and see the output there you go the program got successfully compiled and now it's asking for the input now it is asking for the number of vertices let's enter the number of vertices as 3. now it is asking for us to enter the input in the form of matrix so the first row will be 1 2 and 3 so these are the first rows the next rows will be 2 three and four so the last row elements are three four and five so we have successfully given all the three rows of elements now let us select the source node so the source node would be two now all the nodes that are reachable from the source node 2 are 1 2 and 3. so there you go that's how you implement the breadth first search algorithm now let's get started with the introduction to depth first search so what is a depth first search so basically a depth first search is an algorithm for traversing or searching the tree or graph data structures the algorithm starts at the root note selecting some arbitrary node as the root node in case of graph and x plots as far as possible along each branch before backtracking so dfs starts with the initial node of the graph then goes deeper until it finds the goal nodes or the leaf nodes or the nodes that have no children that is the end part here you can see 4 and 7 are the leaf nodes so the depth first search algorithm runs till the end of all the nodes that is 8 10 all these are the leaf nodes are the last gold nodes in dfs the backtracking starts once all the nodes are explored and the dfs algorithm uses stack data structure for its traversal now that was a brief introduction to the dfs algorithm now for a better understanding let's go through a practical example so here we have a graph data structure with elements a b c d e and f so we will be running the dfs algorithm and we will be traversing through all the nodes of this particular graph and the traversal will be recorded using a stack data structure and we have two different colors which will be used to indicate the element's color so the black color is for the nodes which are not visited yet and the blue color will indicate the nodes which are being traversed already now this is the stack data structure that we will be using for the traversal and we have another part which declares or which gives out the output of the traversal of the nodes of this particular graph now we will begin with the first one that is a now followed by that we will move ahead to b then after b we will go through d then after d we have e next we have c and last we have f so that's how we traverse through the graph using the dfs algorithm now for a little more understanding let's go through a practical example where we will be executing a program for implementing the dfs algorithm so this particular program on my screen is an example for dfs algorithm so here we have the structure node so followed by that we have also the methods which will create the edge and which will also print the graph elements and finally we have the main class now don't worry about the code this particular code segment or the complete code document will be added in the description box below and you can have access to it and try to run it on your local system and have a better learning experience now without further ado let's try to run this program and get the output and see how the dfs algorithm gets implemented and traverses through the graph there you go the program got successfully executed and we had the graph elements that is 0 1 and 2 and 3 so it has visited all the elements that is 2 3 1 and 0 according to the stack data structure and we have found the output over here what exactly is a bucket sort algorithm so the bucket sort algorithm divides the unsorted array into several groups known as buckets so each bucket is sorted using any suitable sorting algorithm or recursively applying the same packet sort algorithm i know it it's a little complicated to understand so let's go through an example so on my screen we have an example of an array consisting of numerical elements that is 12 6 37 29 11 35 21 and 22 now we will create some buckets with different ranges so here we have different buckets ranging from 0 to 7 8 to 15 16 to 23 24 to 31 and finally the last bucket with range 32 to 39 so 6 will be stored in the first packet followed by that 11 and 12 will be stored in the second bucket followed by that we have 21 and 22 stored in the third bucket followed by that we have 29 in the fourth bucket and finally the last two elements which are 37 and 35 stored in the last bucket in the next stage all the elements are sorted according to an order that might be ascending or descending in our case we have the ascending order so the final result will be 6 11 12 21 22 29 35 and 37 so this is how the bucket sort algorithm works in real time now the next topic that is working off a bucket sort algorithm in a detailed way so now we know the briefing of a pakistan algorithm now let's learn the working of packet sort algorithm in depth suppose we have an array consisting of decimal values or floating values as the input so the first element is 0.47 next we have 0.39 0.23 0.55 0.29 0.41 0.59 and finally 0.31 then we will create an array of size 10 and store 0 in each block and each block of an array is used as a bucket for sorting the elements next we have step 2 insert the elements into buckets from the array and all elements are inserted as per the range of the bucket packets ranging from 0 to 1 1 to 2 2 to 3 up to n minus 1 to n here n is the number of elements in an array so for our example 0.23 will be multiplied by 10 which is the size of an array and that gives us 2.3 approximately equal to 2 so finally we will insert 0.23 into the bucket number 2. in exact we will insert other elements into other respective buckets followed by that we have step three elements of each bucket are sorted using the stable sorting algorithms and finally the step 4 in step 4 all the sorted elements of each bucket will be gathered and represented in the form of an array as pseudo code is an informal programming description that does not require any strict programming language syntax similarly we will understand it effortlessly so in the pseudo code first we will create n empty packets next we will insert all the array elements into buckets by multiplying the size of an array we have to keep doing this for every array element as we understood this in working of the bucket sort algorithm after that we have to sort individual buckets using insertion sort and finally we will concatenate all the sorted buckets next we will learn about the complexities of bucket sort algorithm first we will see about time complexity so talking about the time complexity we usually have three cases to summarize the time complexity so first we have the best case so that the best case is o of n plus k next we have the average case that is o of n into n and finally we have the worst case that is o of n here n is the total number of elements to be sorted and k is the number of buckets so let us understand all the three cases one by one so first we have the best case so the best case occurs when all the elements are uniformly distributed in the bucket with an equal number of elements in each bucket if insertion sort is used to sort the bucket sort algorithm then overall time complexity is o of n plus k o of n complexity is for making the buckets and o of k complexity is for sorting all the elements after understanding the best case now we will see how the worst case occurs in the bucket sort algorithm the worst case occurs when there are elements of close range in the array they are likely to be placed in the same bucket it makes the complexity depend on the sorting algorithm used to sort the elements of the buckets complexity becomes worse when all the elements are in reverse order and if insertion sort is used for sorting then time complexity becomes o of n into n and lastly we will learn how the average case occurs in a bucket sort algorithm the average case occurs when the elements are randomly distributed in the array it occurs even when the elements are distributed in uniform way bucket sorts run at the linear time the average case holds true until the sum of bucket sort sizes is linear and in the total number of elements next we will see about the space complexity so the space complexity of all the buckets algorithms is o of n plus k lastly we have stability so talking about stability so yes the bucket sort algorithm is stable after understanding the complexity of packet sort algorithm now we will compare the bucket sort algorithm with other algorithms so first we will compare the counting sort algorithm bucket sort can be worked as a generalization of counting sort algorithm and if each bucket has size 1 then the bucket sort degenerates to counting 0. the variable size of buckets or algorithm allows it to use o of n memory instead of o of m memory where m stands for the distinct value that gives counting sort o of n plus 1 worst case behavior next we will compare the buckets or algorithm with quick sort bucket sort with two buckets is a practical version of the quick sort where the pivot value always selects the median value of the value range another meaning of choosing the pivot in quick sort such as a randomly selected pivot makes it more resistant to clustering it in the input distribution after that we have the merge sort the n-way merge cert algorithm starts by distributing the list into n sub list and sorting each one then the sub lists created by merge sort have overlapping ranges and cannot be recombined by a simple concatenation bucket sort lastly we have one more sorting algorithm that is radix sort for comparison top down radix sort can be a particular case of bucket sort where both range of values and the number of buckets has contained the power of two this approach can accelerate the scatter phase since we only need to examine each element's prefix of bit representation to determine a bucket at last we have one more topic to learn that is the applications of packets or algorithm the bucket sort algorithm consists of two main applications first by using bucket set algorithm input is uniformly distributed on the range and second by using bucket sort algorithm there are floating point values now let us go through a practical demonstration of bucket sort algorithm now on my screen we have an example for packet sort algorithm so we will begin with the header files followed by that we will define a function namely buckets out algo this particular function is to implement a bucket sort algorithm in the functions argument there will be an array namely arr and a variable num which will store the number of elements in an array after that we will define two counter variables which are i and j and declare one more array namely array 1 with the same size of an arr array so this particular second array will be used for displaying all the elements in the array1 we will have a for loop which will run from index 0 to the entire size of an array and for this array we will use the variable i as the counter variable we will have another for loop to print all the repeated numbers with frequency in an array we will run another value from index 0 to the last element of both the arrays and elements of array and array 1 will assign to arr array now we will exit from both the loops and now we will enter into the main function where we will declare an array namely array with the size of 100 and two variables which are num and i next we will ask the user to enter several elements of an array using printf function and now the user will enter number of elements and we will scan that using the scanf function now we will ask the user to enter the elements of an array using printf function and the entered elements will be scanned using the scanf function and next we will print a before sorting and an array after sorting using for loops by calling the packet.algo function and in this function we will pass the name of an array that is an array and the size of an array that is num now let us try to execute this program and see the output so there you go the program got successfully executed now let us try to enter the number of elements that is five now let us enter all the five elements two three one four and five so the array before sorting was two three one and four five then the array got sorted using packet sort algorithm and the resultant array is one two three four and five in ascending order let's get started with an introduction to counting sort counting sort is a sorting algorithm that sorts the elements of an array by counting the number of occurrence of each unique element in the array the count is stored in an auxiliary array and the sorting is done by mapping the count as an index of that auxiliary array now let's discuss the counting sort algorithm let's say we have an array first we will find the largest element in this array to evaluate the range of the elements and we will create a count array to store the count of element from the array then we will update the count arrays element with a cumulative count at last we will output each element from the array followed by decreasing its count by 1. we have now introduced the counting sort and its algorithm now let's try to implement this algorithm in the code editor let's start by creating account sort function void count sort its argument as int arr comma and n we will declare an array output size 10 and an array count again with the size 10 and an integer variable max is equals to arr at zero now we will write a for loop to find the largest element of this array so for i is equals to one i less than n i plus plus if a r at i is greater than max then max will be equals to arr at i now we will initialize the count array with all zeros so for and i is equals to zero to i less than equals to max plus plus i count at i is equals to zero now we will store the count of each element in this array so for loop and i is equals to zero i less than n i plus plus count at arr bracket i is plus plus now we will write a for loop to store the cumulative count of each array so 4 and i is equals to 1 where i is less than equals to max at i plus plus count at i is equals to plus equals to count at i minus 1 now we will find the index of each element of the original array in count error and place the elements in the output array so for end i is equals to n minus 1 i greater than equals to 0 i minus minus so output account at arr i minus 1 is equals to arr at i and then we will decrease count arr i by 1. now let's write a function to print this array so void print array so end arr bracket comma end and so for loop and i is equals to zero i less than n i plus plus i out handle now let's write the main block and arr is equals to we will write the element now let's find out the size of this array so end n is equals to size of array divided by size of arrays first element now we will call the count sort function arr comma and now we will print this array so print array arr comma n now let's try and execute this as you can see we have successfully sorted this array using counting sort let's get started with an introduction to radix sort radix sort is a non-comparative sorting algorithm it avoids comparison by creating and distributing elements into buckets according to their radix and for elements with more than one significant digit this bucketing process is repeated for each digit while preserving the ordering of the prior step until all digits have been considered now let's discuss radix sort algorithm let's say we have an array first we will find the largest element in the array to decide maximum number of significant digits we will need to compare to sort this array we will go through each significant place and sort the array one by one first we will solve the array according to the units place then we will sort according to the tens place and then we will sort according to hundreds place and so on till the array is sorted we have now introduced the radix sort and its algorithm now let's implement this algorithm in the code editor we will start with the utility function to get maximum value in this array so int get max with an argument as array arr comma size n we will declare variable int mx is equals to arr at 0 and we will write a for loop where i is equals to 1 to i less than n at i plus plus if arr at i is greater than mx then mx will be equals to arr at i and then we will return the value of mx now we will write a function to do counting sort of array arr according to the digits represented by exponent so void sort at end arr comma and n comma exp we will declare an integer array output and i comma account array of size 10 where all elements are zero now we will store the count of all the elements of the array arr so for loop i is equals to 0 i less than n to i plus plus count error at i divided by exp modulus of 10. plus plus now we will change count i so that count i now contain actual position of this digit in output so for i is equals to 1 i less than 10 i plus plus count i plus equals to count i minus 1 now we will build the output array so for loop at i is equals to n minus 1 to i greater than equals to 0 and i minus minus output count arr at i divided by exp modulus 10 minus 1 is equals to arr at i and now count arr at i divided by exp modular 10 minus minus now we will copy the output array of arr so that arr now contains sorted numbers according to the current digit so for i is equals to zero i less than n i plus plus arr at i is equals to output now let's write the main function that will sort the arr using radix sort so void red x sort and arr comma and n m is equals to max arr comma n now we will do the counting sort for every digit note that instead of passing digit number exp is passed exp is basically 10 raised to the power i where i is current digit number so for exp is equals to 1 and m divided by exp is greater than 0 while exp is multiplied equals to 10. we will do count sort on arr of size n with the exp now let's write a function to print this array so void and array n for and i is equals to zero i less than n i plus plus layout array now let's write the main function we will declare end arr bracket with values 170 comma 45 comma 75 comma 90 comma 802 comma 24 comma 2 comma 66 now we will find out the size of this array arr and is equals to size of arr divided by size of arr first element now we will call the radix sort function and we will print this array now let's try and execute this as you can see we have successfully sorted this array using radix sort hey everyone i'm bebo khandelwal and i welcome you all to simply learns youtube channel in this session we will discuss heap salt we shall begin our session by introducing what is a binary heap then we will discuss the implementation of the heap sort after that we will check out various applications of heap soap finally we will sum up what we have learned from this session but before we begin make sure you have subscribed to our youtube channel and clicked on the bell icon below so you never miss an update from simplyrun let's get started with what is a binary heap it's a complete binary tree with all levels completely filled except the last level where all leaves are to the left as far as possible a binary heap can be either min heap or maxi in a min binary heap the elements at root must be minimum among all elements present in the binary heap max binary heap is like min heat where root must be maximum among all elements now let's discuss implementation of heap sort first we will start with creating a max heap of elements present next up we will remove the elements at the root and put it at the end of the array and put the smallest element at the root after that we will reduce the height by 1. finally we will repeat 5 the root element again and repeat the process from step 2. now let's try to implement this algorithm in the code editor we will start by creating a function to epify a subtree rooted with node i which is an index in array arr and n is the size of the heap so void apify i now we will initialize largest as root so end largest is equals to i now we will define the left and the right subtree so end l is equals to 2 into i plus one and end r is equals to two multiply with i plus two now if the left child is larger than root then if l is less than n and arr at l error at l is greater than arr at largest so the largest will be equals to l now if right child is larger than the largest so far so if r is less than n and arr at r is greater than arr at largest so largest is equals to r now if largest is not root so if largest is not equals to i we will swap arr at i with a arr at largest and then we will recursively call ep5 for the affected subtree comma and comma largest now we will write the main function to do heap sort so void deep sort and arr bracket comma and n now we will start by building heap so for and i is equals to n by 2 minus 1 where i is greater than equals to 0 at i minus minus we will call heapify for arr comma n comma i now we will one by one extract an element from the heap so for and i is equals to n minus 1 where i is greater than 0 at i minus minus now we will move current root to end so swap error at 0 to arr at i and we will call max epify on the reduced heap so he p5 error comma i comma zero now we will write a function to print this array so void and array and arr comma and n so for and i is equals to zero i less than n plus plus i we will do c out arr bracket i is and a c out and l now let's write the code for the main block so second arr is equals to a comma 18 comma 12 comma 14 comma 5 comma 6 comma 2 now we will write a statement to find the size of this array so end and it's equals to size of arr divided by size of the first element of the array arr0 now we will call heap sort function so heap sort for a r comma n now let's print this array so c out sorted array is print array at arr comma n now let's try and execute this program as you can see our sorting function is working flawlessly let's get started with what exactly is divide and conquer algorithm a divide and conquer algorithm iteratively divides a problem into two or more sub problems of the same or relative type until they are simple enough to be solved directly the sub problem solutions are then integrated to solve the original problem there are three steps involved in the divide and conquer principle that is divide conquer and combine the first step is to divide the significant problem into smaller sub problems the second phase is to conquer the solutions to all divided sub problems then the final step is to combine and merge all of the solutions to create a definite solution we will understand this by an example right here on my screen suppose we have a large problem we can use divide and conquer technique to divide it into n number of sub problems such as problem 1 problem 2 problem 3 problem 4 and so on until we reach the problem n then we conquer all the solutions to the specified sub problems as solution 1 2 3 4 and so on and finally we match all the solutions to get one definitive solution now that was divide and conquer algorithm followed by that let us get into merge sort algorithm so merge sort is one of the most efficient sorting algorithms it is based on divide and conquer strategy merge sort continuously divides a list into numerous sub-list until each sub-list contains only one entry then merges all those sub-list into a sorted list there are four elements on my screen we have 7 and 3 in the left half and 5 and 2 in the right half after dividing the four elements in half we combined all the items in ascending order that is 2 3 5 and 7. in the next segment we are going to understand how it happened and we are going to learn the working procedure of merge sort algorithm there are two approaches to implement the merge sort algorithm the first method is top-down approach and the second method is bottoms-up approach the first method that is the top-down approach implies that it begins with the large picture from then it's broken into smaller chunks now the second method that is the bottom-up technique which starts with a specific number of jobs and works its way up to the general let's have a look at how to implement the merchant algorithm using top-down approach the top-down merge sort approach is the methodology that uses a recursion mechanism it starts at the top and proceeds downwards splitting the array into two halves making a recursive call and merging the results until one gets to the bottom of the array for a better understanding of the top down approach method consider the following scenario right here on my screen we have an example of an array of size 6 consisting of elements 7 3 9 5 6 and 4. starting with 0 and ending with 5. using the following formula we'll divide the array by its middle that is middle is equals to left plus right divided by 2. we have 3 elements on the left and three elements on the right near the middle so according to the drop down strategy we divide the given array in half resulting in three elements that is 7 3 and 9 on the left and 5 6 and 4 on the right next we sort all these elements in ascending order by doing so the first half will be 3 7 and 9 and the right half will be 4 5 and 6 and after merging all of them we will have the sorted array that is 3 four five six and nine next we will understand the bottom sub approach an iterative process is used in bottoms up merge sort approach it starts with a single element array and then joins two neighboring items while also sorting them the combined sorted arrays are combined and sorted again only until one single unit of the sorted array elements remains now let us look at an example right here on my screen in the first iteration we will merge pairs of array sizes by 1 sorting each of the 2 elements when you iterate the array by size 1 the elements 7 and three become three and seven similarly nine and five become five and nine and finally six and four become four and six we will merge the pairs of array size by two in the next iteration with the bottoms up method as a result the elements 3 7 and 5 will become 3 5 and 7 and the same way 9 4 and 6 will become 4 6 and 9. in the last iteration merge pairs of array size by 3 so that after sorting 3 5 7 4 6 and 9 becomes 3 4 5 6 and 7 as sorted arrays after understanding the working procedure of merge cert algorithm we will now see the pseudo code of merge sort algorithm we have a function called merge sort in this pseudo code and parameter of the function contains an array named as array and two variables named as left and right if the number of elements in the left is greater than the number of elements on the right we will get a middle using formula left plus right divided by 2. the merge sort is called and this function now has an array a left variable and right variable by calling merge sort we have array left as middle plus one and right variable and finally by calling merge sort we have left middle and right variables in our upcoming segment we will implement the merge sort method in a practical demonstration in the next section we will discuss the complexity of merge sort algorithm first we will look into the time complexity of merge sort algorithm as we all know time complexity in data structures is divided into best case average case and worst case the best case of merced algorithm is big o of n into log n average case of merced algorithm is big o of n into log n and the worst case of merced algorithm is big o of n into log n the number of elements being sorted is given by n merge sorts time complexity is big o of n star log n in all three situations that has first average and best because it always divides the array into two halves and merges the two halves in linear time it takes up the same amount of space as the unsorted array as a result it is not a good idea to use it to search big unsorted arrays moving on to the space complexity of the merced algorithm the space complexity of the merge sort algorithm is large o of n in the merced algorithm we store the left and right parts of the merged array in the temporary arrays and then utilize the original array to keep the entire merged array in the worst case scenario the left and the right sub arrays will each be n by 2 in size and then the total auxiliary space will be big o of n resulting in a space complexity of big o of n following that we will look into several applications of the merge sort algorithm so the first application is merge sort is an efficient way to sort link list in big o of n log n time subsequent application of the merchant algorithm is for linked lists merge sort implemented without taking up more space followed by that the mozart method is used to count the number of inversions in a list last application states that in internal sorting the merge sort is employed now let us look into some of the drawbacks of merge sort algorithm so some of the drawbacks of merchant algorithm are for smaller assignments merger algorithm is slower than the other sorting algorithms for temporary array the merge sort technique requires an additional memory space that is space of big o of n now let us look into a practical demonstration of merge sort algorithm on my screen we have an example for merge sort algorithm to define constants or micro substitution we use the hash defined as preprocessor directive with a constant variable max of 10. following that two arrays array 1 and array 2 are declared we declare array 1 and initialize it with elements like 8 4 7 6 2 3 5 9 10 4 and 1 array 2 is used for temporary array then to implement the merge sort concept we declare a merge sort function we specify three variables in this function parameter that is left right and middle the left variable is used to display the left part of the array1 the right variable is used to display the right part of the array 1 and middle variable is used to indicate the middle or center of the array in this function we utilize the for loop in this function setting the left 2 level 1 the middle plus 1 to level 2 and the left to variable i with the condition that level 2 is less than or equal to the middle and level 2 should be less than or equal to the right of the array we have a condition in this for loop that if level 1 of array1 is less than or equal to level 2 of array1 we will initialize all the consecutive elements of level 1 of array1 to array2 else we will initialize all the successive elements of level 2 of array1 to array 2. out of for loop all subsequent elements of level 1 of array 1 will be initialized to array 2 until level 1 is less than or equal to the middle all successive elements of level 2 of array 1 will be initialized to array 2 until level 2 is less than or equal to the right of the array using the loop which will run from i equal to the left of i is less than or equal to right we initialize all the items of array 2 to array 1. we have declared one more function in this code namely sorting out of the merging sort function in which only the left and right variables are defined we specified the middle function in the sorting function with the condition that if the left is less than the right the middle will be calculated as left plus right divided by 2. then we call the sorting function passing left as middle as right and then another sorting function passing left as middle plus 1 and right finally we use the merge sort function passing left middle and right to the sorting array 1 otherwise we will return nothing we entered the main function out of the sorting function where we declared the counter variable i and printed the array before sorting using the printf function in for loop where i will run from index 0 to the array's maximum size after that we invoked sorting method passing left as 0 index number and write as the iris maximum value finally after doing the merge sort process we will print the array using the printf function and for loop we will run from 0 to the array's maximum value then we compile the program and run it now let's try to quickly execute this program and see the output so there you go the program got successfully executed and the list before sorting is eight seven six two three five nine ten four and one and the list after sorting is one two three four 4 5 6 7 8 9 and 10. let's get started with an introduction to selection sort the selection sort algorithm is an in-place comparison based method that divides the list into two halves with the sorted portion on the left and the unsorted half on the right then the smallest element from the unsorted array is chosen and swept with the leftmost element and that element is added to the sorted error now let's discuss the selection sort algorithm let's say we have an array first we will divide this array in two sub-arrays unsorted array and sorted array then we will divide the minimum element from the unsorted array and swap it with the leftmost element of this unsorted array after that we will add it to the unsorted array we will keep repeating this process until there are no elements left on the unsorted array we have now introduced selection sort and its algorithm now let's implement this algorithm in the code editor we will start by creating a function swap will be integer pointer x comma integer pointer y you will declare an element temp to store the value of pointer x then we will store pointer wise value in x and we will store temps value in y and that's how we can swap them next we will write the definition of selection sort function void selection sort this argument will be end array arr comma and n we will declare variables and i j and a min underscore idx variable to store the minimum index now we will one by one move boundaries of unsorted sub arrays so for loop i is equals to 0 where i is less than n minus 1 i plus plus we will find the minimum element in this unsorted array so min underscore idx is equals to i now for a is equals to i plus 1 j less than n j plus plus if error element at j location is less than array at the min index then min idx will be updated with j now we will swap the form minimum element with the first element so we will call swap function with argument as ampersand arr at min idx comma ampersand arr at ith location now we will write a function to print this array so void array argument as int arr and its size and n 0 i less than n i plus plus v out arr at i layout and l now we will write the code for the main block so end arr is equals to 4 comma 2 comma 1 comma 8 comma 3. we will find the size of this array so end n is equals to size of array arr divided by size of this arrays first element now we will call selection sort function argument as arr comma n then we will try to print this so c out sorted array and we will call the function print array to print this array arr comma n now let's try and execute this program as you can see we have successfully sorted this array using selection sort algorithm let's get started with an introduction to shell sort shell sort is a sorting algorithm that is based on insertion sort algorithm and it is very efficient when the smaller value is on the far right and must be shifted to the far left then this method avoids significant shifts as in insertion sort now let's discuss the algorithm of shell sort let's say we have an array we will initialize a variable h this h will represent intervals then we will divide this array into h intervals it will create some sub arrays then we will apply insertion sort on these sub arrays after that we will reduce the interval edge by 1. then we will repeat this process recursively until h counts down to 1. we have now introduced shell sort and its algorithm now let's try to implement this algorithm in the code editor first we will start within function to sort an array using shell sort so int cell sort we will write argument as int arr bracket comma and n will start within big interval then we will reduce this interval by one so for loop and interval equals to n by two interval greater than 0 and interval divide equals to 2. now we will do a gapped insertion sort for this interval so for and i is equals to interval i is less than n i plus equals to 1. and amp is equals to arr packet i now we will shift earlier gap sorted element up until the correct location for arr i is for so and a so for a is equals to i and j greater than equals to interval and and arr bracket j minus interval greater than temp and j minus equals to interval now arr at j is equals to arr j minus interval now we will put this stamp in its correct location so arr bracket j is equals to temp now i will return zero now let's write a function to print this array so void print array so for loop and j is equals to zero a less than n j plus plus c out arr bracket j now we will write the function for the main block so end arr is equals to 12 comma 34 comma 56 comma 85 comma 2 comma 9 comma 11. comma five now let's find the size for this array so int n is equals to size of array divided by size of first element of this array now see out array array before sort print array arr comma and sort error n now see out erase after sorting we will again print array here comma n now let's try and execute this as you can see we have successfully sorted this array here we will look into the real life example of greedy algorithm in order to understand it better this is alex he's quite wealthy and intelligent as he works for one of the most reputed it firms and this is alex's best friend rachel rachel is in dire need of 85 right now however she needs money in such a quantity that the number of coins is kept to a minimum so rachel shared this issue with alex and asked him for help now alex is thinking about rachel's issue which he can easily fix because he has a limitless supply of 50 ten dollars and five dollar coins stashed in various bags although this being said alex needed to think about the constraint rachel told him about he needed to give her money such that the number of coins utilized must be minimal to do so alex began making a list of the various coin combinations in which he could present money to rachel however after a while he became confused due to the vast number of conceivable combinations so he decided to use his programming ability to solve real life problems alex developed a program that will provide him with the optimal number of coins that he can present to rachel this generated program was iterating through the different possibilities to choose the best solution at each iteration the program added the coin of the largest value that was not taking aleks past the amount to be paid which is 85 in this case for eighty five dollars the largest denomination id can start giving is fifty dollars now id is still short of thirty five dollars to reach the amount so that the next largest coin program can take in as twenty dollars but since the program still requires fifteen dollars to meet the threshold the next highest denomination it can accept is ten dollars followed by five dollars the best part about this program was that it allowed alex to present 85 dollars in just four coins which is fairly incredible the vital thing to note here is that after each loop the program makes a greedy choice providing the coin with the highest potential value what i mean here by greedy is that locally optimal choice is picked at every step to reach the global optimum solution now moving ahead we will formulate the idea of greedy algorithms basically a greedy algorithm is based on a problem-solving method that involves making locally optimal decisions at each stage in the hopes of achieving a global optimum that means at each stage we choose a locally optimal value in the hopes of arriving at the optimum possible end result furthermore this algorithm is an optimization technique that can find either minimum optimum result or maximum optimum result the best part about this algorithm is that it is simple to understand and implement as well additionally the runtime complexity for this algorithm is pretty reasonable however the fundamental disadvantage of this strategy is that we only receive the globally optimum value in a small percentage of cases having said that you must be thinking about when to implement this algorithm for solving particular problems as it does not always produce globally optimum results well let me tell you guys that we have two conditions to judge our problem for implementing greedy algorithms the first condition is the greedy choice property this notion states that making locally optimal judgments can lead to the global optimum solution for a given problem the second condition is about optimal substructure the problem has an optimal substructure only if an optimal solution to the entire problem comprises the optimal solutions to the subproblems in simpler words that means the problem can be split down into multiple sub-problems and the solutions to these sub-problems can collectively lead to a solution for the entire problem if both the above-mentioned properties are satisfied by the problem then we can create a greedy solution for that particular problem moving forward we will look into the steps for constructing a greedy solution finding the substructure or sub problem that can lead us to the final answer is the first step in building a greedy algorithm because in this algorithm we are just trying to operate with local optima to reach the global optimum solution the second step is about determining the type of solution the given problem can result into that can be either the largest sum or minimum path the final step for creating the greedy solution is about creating an iterative process for traversing through local stages and making decisions to reach a globally optimum solution now you might be confused about how we can do that well let's go through an example to understand the approach to implement a greedy solution the example that we are going to deal with is called the traveling salesman problem in which a salesman is supposed to reach the destination from a given current location the representation of cities and parts connecting them is done using graph structure where each node is considered as a city and edges connecting them as parts having edge weight as the distance between the two cities now in this case we are supposed to find the minimum path between two cities so to do that we will begin from the current arbitrary position from this node called as starting location there are three possible paths but the path towards city b has less distance hence we will traverse this edge primarily as it is an optimal local route we have reached city b now and from this node we have two possible parts out of which one part directly leads us towards the destination city having distance 20 but the other path leading towards the city f has edge weight value or distance value as 2. hence according to the local optimal decision we will choose the edge connecting cities b and f for traversal we have reached the city f now from this node or city there is only one path leading us to our destination hence we will traverse it now we have reached the destination city the path highlighted in the green shade is the global optimum for this tsp problem you can verify that by calculating the edge weights for all other possible parts since the solution allows us to reach the global optimum by making optimal decisions at the local stage this strategy to solve the problem will be considered a greedy approach now moving ahead we will look into the demerits of using greedy algorithm we have learnt that the greedy algorithm makes decisions based on local optimum instead of analyzing the broader picture of the whole data hence there is a possibility that the greedy solution might not be the best optimal solution for some problems for example consider this travelling salesman problem in this problem the highlighted part is a created solution to reach the destination city from the current location using a greedy algorithm but if you observe this graph the selected solution is not the global optimal solution for this problem in contrast it is the worst generated solution to reach the destination that is why the greedy algorithm is considered to be prone to correctness issues even if the algorithm is correct proving why it is correct is difficult thus it is deemed to be trickier to solve specific issues now we will discuss about applications of greedy algorithms to understand their importance the first application of a greedy algorithm is its use for constructing minimum spanning trees the coding approaches that we use to generate msds is based on the greedy algorithm both prim's algorithm and crystal's algorithm are known as greedy algorithms as they make decisions based on locally optimal decisions the next application of the greedy algorithm is it's used to implement huffman encoding and decoding algorithms the huffman coding technique is a lossless data compression method the concept is to give variable length codes to input characters the lengths of which are determined by the frequency of the related characters the smallest code is assigned to the most frequently occurring character whereas the largest code is assigned to the least frequently occurring character this process is carried out by making local optimum decisions hence it is also considered to be a greedy algorithm the final application of the greedy algorithm is its use for developing solutions to well-known coding problems those problems are the activity selection problem job selection problem and fractional knapsack problem all these problems generate solutions by making decisions at each local stage so the solutions for these problems can be developed quite easily using the greedy approach so this was all for today's session i hope this session was informative and interesting if you have any queries regarding any of the topics covered in this session or if you need the code for all the coding algorithms discussed in this particular tutorial then please feel free to let us know in the comment section below and our team of experts will be happy to resolve all your queries until next time thank you stay safe and keep learning you