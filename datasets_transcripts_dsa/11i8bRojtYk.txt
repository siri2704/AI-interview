see is very flexible and well-established programming language thus making it the mother of all programming language many essential libraries firm wills and operating system are implemented using see for example in Linux more than 85 percent of job is done using C getting into any tech giants like Google Amazon Facebook or Microsoft you need to have a solid knowledge on data structures and that's what we are going to learn in this session hi welcome to this session on data structures using C in this session we are going to cover c programming language data structures arrays link lists stacks and queues then we will talk about binary tree binary search tree heaps then we will talk about hashing and try to implement hash table and finally we are going to conclude our session with graphs let's talk about c programming language so c programming language was designed by dennis ritchie in 1972 right if you want to save you some files written in c programming language you have to use an extension of dot h dot c right so why was it developed it was developed to make assembly work assembly language work much easier what do you mean by that basically if something is written in an assembly language if you might have used some time maybe somewhere you have seen its code it is similar to a low-level language right it is if I explain it in a naive way right it is similar to a machine language that is zeros and ones except it is written in words right we have words to write an assembly language so we can see if I'm comparing it with a machine language right so it's it is not a machine language it is a low-level language basically yeah if I'm comparing it with that so it has to be or it is much complex right so instead of using assembly language what then is retreated he designed a C programming language but is a high level language so it is I ended in 1972 right so it is a procedural language what do you mean by that it has to you have to follow some suit winds of steps to get the desired output right so it is much faster so I have read somewhere read so and I have tried it myself also so if you try a simple program maybe some addition of two numbers or any simple program maybe a linear search right so if you try to do it in five different languages maybe C C++ Java go and maybe JavaScript if you try to do it and if you try to execute all those and Python as well Python takes much much much much time so if you try to execute all the simple program written in all those languages right so you will see that si performs much better I'm talking about simple programs though there is a huge difference between C programming and all those object-oriented languages right but I'm talking about some simple program we not discussing or we're not dealing with those object-oriented features right so yeah C works much faster okay it handles a low-level activity much better these are certain points that I have basically we are dealing with data structures these are certain points that you should know what do you mean by this low-level activity right so basically if you're trying to store something or if you're trying to allocate memory and you're trying to free that memory you are responsible for that using malloc and free right so there is no garbage collector in it in C right so it handles that low-level activity you you see that handling those allocating those memories and using free to to free the memory right you are responsible for that so that is what this means there are other things that this line means but I'm looking at bigger picture right so you are responsible for this okay so some of the applications or operating systems that are written in the UNIX operating system RDBMS PI Square both of these are written in C okay now let's talk about data structures so if you see there are two words in it right data and structure what do you mean by data well something that is related to information or facts or something like that right so data information or you want to store that information but there should be some structure to it right wherein you store this data how you store it data so that's what we're in data structure comes into picture right it is a way to arrange data in computers okay some of the data structures that we are going to study in this lecture linear data structures and nonlinear data structures what do you mean by that so if something is stored in a linear fashion something in that is in sequence right there is a order to it right so those data structures are called linear and there is though there is an ordering hierarchical data structures as well if we talk about nonlinear data structures right trees grass these are nonlinear data structures and linear data structures are arrays link lists excuse these are all linear data structures okay we are going to study about them one by one you don't have to worry right now so that's what this session is all about okay so these are the list of data structures we are going to cover today right so the first is arrays then link lists stacks queues binary tree finally search tree he hashing and graphs so let's get started so any isn't linear data structures what do you mean by that if you want to store something it will be in sequence right there is five and there is two and there is three you want to store these data structures but what do you mean by contagious memory allocation basically if you're trying to store an element which is of type the data type of that element is integer right so I'm talking about 32-bit operating system in okay the size of int is - if it isn't 64 it is what for right yes if you want us to those data in your memory right so if five is stored in let's talk about some arbitrary address right it is 100 so talking about 32-bit Ric 32-bit operating system int will be of two bytes so the next data that will be the at was given to it will be 102 okay 100 102 104 so there is a sequence to it right you see so that's what I mean by array is stored in a contiguous memory allocation if there is no contiguous in memory location of 3 bearing I can store this data so it can't store it right this is a baby there are three is present in a memory but you can't store it meaning not if they are jumbled or the if there are somewhere else you can sort them so it has to be contiguous memory locations okay so can be excess randomly in arrays can be excessive elements randomly in array so yes you can access elements randomly using its index as we all know name of the array depicts its base address okay as we all know base of the address is represented as name of the area okay so there is name associated to an each array so it represents its base address so yes we can access elements randomly using its index we will check all those details I mean how do we declare how we initialize and then I will give you a bonus question as well related to arrays wherein I will teach you also how efficiently we can solve problems right so can we store different data types different data types of elements that means is can we store float can we store int and can we store a character in a single area in the same array no we can't it is homogeneous that is we have to store similar elements okay how what is the syntax of array okay first we have to give a data type right I was talking about earlier a 32-bit operating system where in size of int s 2 then there will be 102 then there will be 104 right so there is a data type associated with array right so yes we have to whenever we are declaring an array we have to give its data type for example int then its name as I already taught you a name is very important because it represents its wave vectors right so yeah name is important so in ARR and then we have to kill its size right it's not dynamic it has to be static and we have to give a size to it maybe size can be omitted wherein we are declaring and initializing in any in the same line as giving as I have told you you can omit size when you are trying to declare and initialize and marry in a single in the same line okay wherein I have given an example that data type bad name and then brackets square brackets are empty and then as then I have written element 1 element 2 element 3 and it went for there is no signs right so why there is not set of any size because I am declaring and initializing at once okay so here let's go what are the advantages of arrays okay random mixes I can access elements randomly right it's easy for sorting and I trading right I can use single loop to iterate through an array right the placement of multiple values what do you mean by this thing so someday I have told you that please store 50 students or 50 role numbers how do you do that do you use int X int Y in Z in one in two and three written in words I mean not later not a numeric one can't that is not a right way to declare and variable right so you will use in - Oh anyone then along the way - 50 is that an efficient way no right now you can use an array of size 50 that will do the thing right yeah so this is an advantage one of the advantages right so what are the disadvantages there this seems to be your thing right we have to fix the size right if and if your declared an array of 50 then you're trying to store 51 elements can you do that no right difficult to insert and delete why it's difficult because if you're trying to delete something maybe you can't delete in array size right so if I told you now the God forbid and xx student has died so you have to remove it can you remove it no you have to swap all the elements from 20 or maybe or 20 we have all we have swept all the mence to its right one by one by one position right so it is difficult to delete an insert an element so now I told you a 20s again like magic right yeah so I told you somehow I told you yeah I was lying or he was saying something someday he came back no or any other student came right he's dead right he can't come back and I have to give the same rule number to him twenty one number right so how would you do that again we have to Reese web elements by one position if I'm having a size of fifty right so there is the size of 50 so I can if my array is full and I am storing all the 50 students in it I can okay and the one more thing which I told you earlier that it needs to be contiguous right so if there are chunks of memories available but not they are not what I want as a contiguous memory location which are required to store in Erie we can't use that we can't store in area elements right it's capacity is more than this occupancy is less so yeah then there is another point which I want to discuss also so what if I told you I have 50 students but only 20 came okay you declare an array of 50 you so you are storing only 20 elements in it so yeah you are wasting some part of your memory right so this is the disadvantage of having a fixed size right so yeah what are the applications of arrays for storing information in linear fashion yeah you can you can store elements in a linear fashion right yeah the other application is that it is suitable for applications that requires frequent searching there is something called binary search and linear search there there in wherein we use these algorithms to search something in an array so let's get going demonstration of Eddy so how we declare rate how we initialize it or we print elements in an array that is what is written in this so I believe that you are familiar with the language so I don't have to discuss these things right glue and studio door edge and mean I don't have to discuss these things so I will get to the business end right so to declare an array you have to use IND in front then the name of the array and the size okay so then we loop around to insert each element in an array using an ampersand sign that is to get the address and then store an element on that position right so yeah then we loop around again to store to face the values from that address you see we are not using that star sign right why we are not using we are fetching something from and maybe this is not a pointer but you are dealing with addresses right so that's what I was saying that this rule number two pegged said space address okay they're going to that base address and we're saying that at 0th index please fetch that element okay so that's how we deal with arrays okay so you see that scanf and printf why these functions are not declared because we are using the library pseudo Rajesh okay so now the arrays are completed so now I was talking about one bonus question right I will try to include a bonus question after every module or every data structure that we cover okay so the question is I am using first I will tell you what I am using I am using dave c++ for executing my c code you can use your editor or you can use any ID we have different different IDs or gate code decal gigs right or if you find this question on any of these computer programming websites you can't load okay so the question is you have an area right in that array every element is repeated twice okay every element is repeated twice so if there is an element 1 1 1 it will be repeated once okay - it will be repeated twice it will if I there is 3 it will be repeated twice ok so every element is repeated twice except one for example let's say 4 4 is not repeated then there is 5 5 is repeated so problem is that we have to find this for okay right this is highlighting so every element is repeated twice except one so we have to find that element so how we would do this think about it pause the video think about it okay then I will show you the solution now let's get to the solution okay so you have different different solutions maybe I think I hope that you have paused the video and write yourself and let's go to the solution so a value there are many ways you can solve this question right I will use the most optimized or most optimal solution I won't go with I won't deal with those solutions which are not optimal I will straight away and go into the optimal solution okay so first we will include to the library yeah and into me okay so I will clear an area and initialize it in the same night okay so in ARR okay so every element is twice one two three then two three one four five and five and six and six okay so every element is repeated twice so what I'm going to do here so I believe you have heard about bitwise operators by twice operator so have you heard about XOR operator written like this caret sign okay have you heard about this so what does this - so one X or one what will be the result it will be zero right and if we are doing zero X or 0 that means I'm talking about the number okay zero X or 0 it will again be zero right so we know that if same elements are absorbed with itself co2 elements are which are saying that are exhort they will give a zero right so if they are different then we will calculate it for example if for is ex-ored with with five right how we will do is we will calculate what 100 is the pi is the binary representation of four right one zero zero right I don't know I don't want to go in details how I calculated this I believe we were already knowing it right and the binary representation of five is one zero five right so one and one will give me 0 right 0 and 0 will give me 0 and 0 and 1 will give me 1 right so it will be 0 0 1 right so yes then this is the result right so we are going to use something similar to this how we use it is the version right so we have the area I will loop around it right I'll use a for loop into I equal to 0 I less then what the size of the array is 1 2 3 4 5 6 7 8 9 and 10 are these 10 elements 1 2 3 4 5 6 7 8 9 10 11 11 elements are there right so I will use less than 11 and I plus plus okay so why will we get the result right I will use some variable here for storing the result okay starting is zero so if I do something like this result is equal into result X or yeah five what and this will give me my result are you confused guys if yes I will explain so anyways I'm going to explain this okay so this will give me the result please don't compare it with your solutions maybe your solutions are giving the right answer but they will be not optimized I have sold it in a linear time the contain complexity of this is worse time complexity Big O of n right so every element if I'm talking if my element which is my answer is at the end that means one is at the end of the array or I am traversing anyways to the end of the array right there are 11 elements and I am traversing 11 times so yes it is solved in linear times now the question is how so first try to print this printf right and person D comma let's do this again okay then person a and then result so what will what should be the result so let's first save this file and yes I try to save this file and try to xq it too to compile and run include through your hash is missing right solid save it again and run it so for is dancer right for is the only element which is not repeated right so there won't be any you might be confused that if other number is repeated or other number is missing no the question is very specific that every element is repeated twice except one we have to find that one element okay so we found our answer now let's try to debug it right this is solved in linear time y'all guys get it right so how we got to the result so one is ex-ored with one basic let's go over to Eddie so if I am talking about if I exhort to say this this way one is exhorted with one then that will be absorbed with something else then do is exhort with two right then this will be absorbed with something else then three will be exhorted with three and this will be absorbed with something else then there's five exhort with five right similarly 6 is exhort with similarly 6 is exhort with 6 and then it's exhort with but no 4 right 4 is a missing so there are 11 limits right what will be the output of this is or think about it it will be 0 right what will be this 0 this 0 this 0 this 0 so 0 exhort with 0 0 exhort with 0 0 X or with 0 will be 0 right so it will be 0 so what will be their result of this so 0 0 0 not considering all those zeros I am only considering do that that many bets which I need ok so yeah this is this will be exhorted this right so what will be the result before right so that's how we got to there and that's why we are execute that's how we are executing this ok so yeah that's will be right so ok cool so we have done this question please compare it with your question and think about the complexity that you used or you try to solve this problem if some someone is able to do this problem using same approach well done if someone is not no need to worry right these things come bedtime okay you don't have to worry about anything so we are done with arrays okay now let's talk about linked lists as we saw earlier there were many problems associated with arrays right we have to give sighs sighs whoa static we can't store elements if the memory is not available in a suite Wayne's right if the chunks of memories are available here and there we can't store our elements right so these problems were solved by linked lists there were some similarities or there are some similarities between arrays and linked lists right both of these are linear ater structures right both of them can store homogeneous elements that is similar elements right elements can be stored as per memory availability this is the key point here if memory chunks are available here and there with the help of link as the name suggests we can store our elements okay we can access elements in a linear fashion only there is a bit difference between the XS how we access elements in arrays and in linked lists that how we access the elements we have to traverse through the linked list if we want to access any element say for example we want to access element which is present at index five in arrays we can simply write that index I'd index minus one we can get that index right but in linked list there is no index rate we have to traverse to that element okay so there is easy insertion and deletion there is a difference again between arrays and linked lists you know in a way that if we want to insert or delete an element we need to swap elements in arrays right but in linked lists we can do that easily by changing the links for example if we want to insert some node right we just broke break the link from that node which are earlier connected with each other okay we can easily connect that node with the other node and the other node with that node okay I will show you later okay don't get confused but there is one key point here all right always we have a node which is called a head node and we don't change it no matter what okay we keep the head node if we for example somehow by mistake change that I'll change that head node we will lose our we will get an operated list okay it might be some elements will be included in it or it might be the case wherein we lose some elements or nodes okay let's go ahead and talk about advantages and disadvantages so what are the advantages dynamic in size right no wastage of capacity as we don't have to give a size so that if we somehow used less elements in areas as compared to arrays wherein if we we gave a size of 5 right and then we only stored two elements in it but the memory is wasted right that is not in not the case here okay easy insertion and deletion only a single link needs to be manipulated efficient memory allocation right if chunks of memories are available here and there we can easily and we can easily insert our elements right we can still in allocate memory to elements right what are the disadvantages head node is key if it is lost linked list is lost no random X's as explained earlier we have to traverse so what are the applications if memory is limited use linked list okay if the application that requires frequent insertion and deletion has computer arrays we need to swap but in linked list we don't need to swap so we can use linked list there let's see the demonstration of linked list so why do we include standard stdlib.h right why do we include this file this library okay because we are using a function called malach here okay so for that to use that function we need to include this file studio dot H why do we include this file because we are using printf and scanf statements right so these functions we don't declare these functions we just include the libraries what is the skeleton of node right the structure is defined here of type node right wearing there are two elements one is data and another is the address part which is of type node okay the pointers then how would we traverse okay you know we have given a display function right which takes argument as a node right a pointer of type node okay so how would we traverse first we check if the element the node without we send if it's null we are sending a head node right with the help of head nor we can traverse to the end of the linked list so first we check if that node is null that means there is no list okay then how we going to travel is it okay then we just print the data in the linked list and then we shift a link to the next node okay that is what we do if we want to access any element in a structure how would we do it we just draw this arrow right okay so this is how we traverse let's go ahead and quickly go into the details okay first we have declared a node of pointer to a node which is called head to know then there are two temporary nodes or temporary variables of pointer type then we have declared two pointers okay temporary pointer second and third okay how we allocate memory we allocate memory with the help of malloc function it takes argument as the size of the node and then we tie passed it to the node similarly okay similarly those two second and third I have been given the memory okay then how we assign our values okay we just do head arrow data right data is equal to 10 and then we assign data to second node which is 2010 third node which is 30 okay how we linked nodes for example head node is linked to second so how would we do that so what we do please go and whatever is in the second nodes address or whatever is the address of second no please put that address in heads next okay so there is a link between head and the second node then second node and third node and then third nodes next contains null because our list contains only three elements that is head second and third that is 10 20 and 30 with data and then we call a display function which is or which we in which we pass our head with the help of head we traverse through the linked list and finally we print out our output as 20 20 and 30 okay now comes the time wherein I give you a bonus question okay so the question is we have to find the middle element in a linked list for example you have a list of 1 2 3 4 5 you have to find the middle element what is the middle element 3 right go ahead and give it a try pause the video and then we will start with the solution okay so now let's quickly go ahead and check the solution of this question okay there is one key point that you have to notice okay what is it so if the list contains for example these elements okay I'm writing it here 1 2 3 4 5 6 ok so there are 6 elements how would you know if the element 4 or 5 is the middle one so it will be defined in the question we will go accordingly for example in my case I'm defining that this is the middle element 5 okay though you have a choice between 4 and 5 it will be defined in the question ok so if the 7 is not present then it's easy right 4 is the middle element it can be seen right so it will be defined in the question ok now I haven't written the entire code okay I have just given the function which is giving me the output as the middle element so I have passed the head node to this funk then I define two-pointer slow and fast to head I have assigned them to head okay for example if one is the head here so all these three elements that is head slow and fast will be pointing to one okay so let's go ahead first we will check if the head is not null right there is no list and how will we find the middle element right make sense okay so this is for that if this is not present then we don't do anything okay then if head node is not null right in the case as we are defining for this problem written here okay let's forget about this how what I have done here let's first check out what I have done what is the approach so I am using two pointers as you might have heard about this famous saying that rabbit and wrote eyes thing right rabbit goes fast and tries move slowly so what here fast is moving two pointers okay and this is moving single type and this is moving twice so this is the concept here I am using two pointers one is pointing to the next next and one is pointing to the next okay for example now for the starting node what I have done so please assign fast NeXT's next so first will be pointing now do four right so at starting it will be at one so next is three and next next is four so it will be pointing to four basically it will be pointing to the address that is presented that is having a data or four so now right now I am just for the simplicity for the sake of simplicity I am using four as its value okay so where were they so slow will be at three okay so let's quickly go ahead is fast none no it is not null what is fast fast is for and is fast next null know what is fast Nix force next is five so both these conditions are true there is an and statement and operator used okay so both these statements have to be true so now what happens so now four will be pointing to host next next that is six four will be at six right so now Frost will be at six and slow will be at four right then we move head and check the condition is fast now no it is six okay and then is fast next now yes it is we don't have any element after six so this becomes null so can we execute this while loop no we will go out of this while loop and print what is whatever is in the slows data part what is in the slows data part that is four so is is for our middle element yes it is now the case comes when we have even element seven for example now let's continue where we exited our foil loop so is fast next null no it is not it is seven so this will be pointed to sevens next next widdy's not so fast will be null here and slow will move ahead to five now we will again execute this is fast null yes it is so are we executing this part no this is the property of and operator if this is what a true then only we will go to this condition okay so this will exit the loop and we will print whatever is in the slow state apart so what is it fine so I told you earlier that I am using the example that in my question it is given that five is the L at five is the middle element whenever we are having even elements in a linked list so you got the point please compare it to your problem what you have written or whatever you have tried so you compare it and then check it okay now let us talk about stack stack is also a linear data structure but there is one property that it has to follow let me take an example first if we have a stack of plates or stack of chairs how can you remove can you remove the last element last plate no or the last chain no whatever is at the top you can remove only that that is whatever came in the last was removed first so it follows leaf of structure kind of a thing light last in first out only the top element is available to be accessed you can't access the last year right or the last plate you have to access you get the exes from from the top okay you can only remove the top of the element okay insertion and deletion takes place from the top as obvious right it is obvious that if we can only remove from the top and only insert from the top whatever is in the top we get to remove only that there are four major operations associated with stack push that is pushed the element or insert the element at top of the stack pop pop removes the element from top of the stack is empty checks if the mi stack is empty then it returns to else it will return false we will use this function very very frequently in our programs okay the stack is a very important data structure then there is another operation that we have in stacks that is beak so whatever what do you mean by beak beak is how it is different from pop basically both these pop and peek exude in the same similar fashion only thing is that pop will remove that element and peek will not be we'll just check whatever is in the top it will give it to you okay all these operation works in constant time as we have as we will use one variable top which will be with which we can get the access of the top element and we will use that or element only to push pop and check if it is empty and beak with the help of that variable top which will be defined okay so all these operations will be of constant time will take constant time okay now let's talk about advantageous and disadvantages of stack so stack advantages that stack maintains data in leaf or manner right we have explained it earlier what a leaf or means the last element is readily available for use right self-explanatory this line right all the operations or take constant amount of time now let's talk about discernment ages okay what is manipulation is restricted right we only get to choose the element or we only get the excess of the top of the element which is present in the stack right there is no much flexibility in stacks right we are stuck with this thing that we have to access only the top of the element or we have to remove element from the top we can insert element from the top so there is not much flexibility so applications is whenever we recursively do a program or we are using recursion in our program inside this recursion we are using stack as in data structure okay now passing is another application browsers write in a browser if you type something in a Google then you move to that link then in that link you move to different link so if you do PAC which is present in the tab tab section right if you press back then it will go back the previous link then back then it will go through the previous link so it maintains the stack there right editors in editors you might have seen undo write undo and redo operations those are also using stack right let's move ahead and try to demonstrate how the stack works I have used array implementation similarly you can use link less implementation as well that is a small assignment for you guys to implement stack using link list I have explained the link list make it a static one you don't have to be do fancy stuff just make it a static one and try to implement stack using link list okay so here we have defined some there are three libraries that we need write standard Lib for my log studio for printf and scanf now let's go ahead and check the skeleton of the stack so stack in here we are using arrays so we have to define the size right size of theory that is going to be right and there is a pointer we is pointing there is an integer as an element right and there's another element which is top top needs to be there because this is going to help us a lot okay how would we create a stack basically for creating the stack we need a structure that is there we use that structure because at the end we are returning the stack which is a pointer so a pointer type of a pointer is returned from this create stack operation so there is an argument unsigned size right which will help us to allocate memory to the array if you can check the statement which is just written up oh the return statement that we are locating sigh we are allocating memory with the help of this size that has been that has been given to us as an argument we are using that size and then we are typecasting it to an integer right we have an integer array then there is top which is at present at minus 1 that means there are no elements in the stack right now and then we assign size which is which is present to the size which is associated with the stack okay and also we are locating memory to a stack okay these are the operation that we need to follow then after that there is one of the function that I have written here that is to check if the stack is full or not right if the stair top of the stack is equal to the size minus 1 right we are using arrays so index minus 1 will be the last element that will be present in the stack so if that size and the top of the stack are at same position that means a stack is full let's go ahead and check other functions is empty right if the top of the stack is at minus 1 that means we are at the we don't have any elements in the stack right so the add I how we can add an item to a stack so this is a push function then there is pop then there is speak okay so how we how we going to push it so we need to check two conditions right the overflow condition and the under flow condition what do you mean by all so for example we are talking here about arrays so if an array size is five that means we can include five elements right so we need to check this condition that we are not including the sixth element in the stack right that is what is written here the if condition so is full function is checking that if the if we can insert an element in the stack then we simply add element to the index to that index with the help of top it is a pre increment so first we increment because it was at minus one so we first increment the top then assign value to it right similarly the next time we first increment that then assign value so this is the push function how we remove though how we remove element from the stack basically we check the underflow condition here if the element is if the stack is that minus one that is we can't remove any element right there are no element so we need to check that condition that is the end of flow condition then we simply remove from the remove element which is present at top and then we decrement it is post agreement then that means first we remove that element then we decrement our top okay this is how we do it and then finally we check for the peek function so peek just returns whatever is at the top it doesn't alter any thing or it doesn't alter any way to the stack okay it just returns it also checks the underflow condition that means if there are no elements then it will return simply return okay and then the I have written the in T int mint so you can return anything for example you might return one hundred or thousand or ten thousand basically just to define that if I'm getting thousand as the returned value right so that means there are no elements you can return anything right there so after then then we have this return stack that means please get me whatever is in the top of the stack without altering the stack okay just give me the last element that's it now let's talk about the main function right so here we have created a array which is of hunter and right which is of size hunter then we push into a stack 10 20 and 30 sorry 10 20 and 20 right then we try to pop the element so whatever is at the last what is at the last 20 20 will be popped again we are popping so again 20 will be popped and then we check if the stack is empty is our stack empty no there is 10 present in our stack right so that's what I have printed in the output section so it is printing not empty okay this is how we do it so now let's talk about that bonus question okay what is the bonus question regarding stack so have you guys heard about postfix evaluation this is the classic example where and we can use stack right so what happens in the postfix expression I will show you just give it a try for example postfix expression works in a fashion that the operators are written at the last for example if I wrote 2 3 2 3 and plus so that this means that this is if we convert it to an infix expression that we means it will be 2 plus 3 but in postfix it will be written in written as 2 3 and plus so the operators will be at the last ok so pause your video and give it a try so I have written here the postfix expression right please find the postfix evaluation of this expression 2 3 1 multiply sign plus 9 and minus sign okay so how would we use a stack here so basically how we gonna use this please give it a try I am just discussing the algorithm so right you have to find a way to solve this yourself ok I am just explaining a little bit so that you get the idea so that you can implement you these data structures it's all about learning right so what we are going to do here first whenever we see an operand operator we will execute the pop operation ok whenever we see the operands right - we are going to push it in the stack so I'm going to just write stack down okay so we saw to push it the stack okay who is understand we saw three push it in the stack we saw one push it in the stack now we saw now preterm multiply what do we will do we will since all these operations are binary so we need two operands right so we are going to pop one and three right and just check we can use a switch here for checking if it is multiply then we multiply if it's addition then we might ready add them if it's negative sign or it's if it's minus sign then we subtract those elements okay so similarly for mod and what are those things keep it simple okay so now we saw multiply sign so we will just multiply three into one right we get the output and we will just push that output again into a stack which is three so three is in this time now what we saw we saw another operator right we are going to pop both these elements two and three and add them both of these are popped add them and then the output is 5 again insert them into the stack then we saw a 9 right we saw nine and we going to push it in the stack then we saw the subtraction operator the minus sign then we are going to Akane pop these elements and do a subtraction so whatever we popped nine and then 5 so 5 minus 9 will be negative 4 your answer should be negative 4 okay got the gist please give it a try so now let's talk about Q so Q is also a linear data structure like arrays stacks and linked lists so it follows the FIFO manner while inserting or deleting an element what do you mean by that first in first out if you have observed when we stand in it in a ticket counter to buy tickets for a movie or a nor a bus we stand in a line what is that line whenever a new person comes he goes from the rear side right and whenever a person buys this ticket then he removes from the friend of the queue or friend of the line right so in the similar fashion queue also works okay whenever the insertion takes place it takes place from the rear end and deletion takes place from the friend end right so there are some major operations that we do in a queue those are n Q DQ big first and peak last what do you mean by these operations NQ it means to insert an element at top right we are inserting an element then we have dequeue we are removing the element peak first we are picking the first element and peak last to get the last element of the queue so all these operations are done in a constant time that is Big O of 1 how if you think about this queue linear data structure you might think that we have two pointers right one for the front side and one for the rear side so if we are inserting we know the last point of both these pointers right if we insert an element we have the point of that is rear pointer help us out right so we use that pointer to insert an element for last and similarly to delete a element we have the friend right so we delete from the friend side so all these pointers helps us to make this queue data structure and all these operation in queue data structure to work in a constant time now let's talk about disadvantages and advantages so what are the advantages the advantages is quite similar to what we have it follows a FIFO manner insertion and deletion takes place in order one time these are some advantages what other disadvantages manipulation is restricted as we see that we only can insert from rear side and delete from front side so the restriction is there right not much flexible you see what are the applications dueling algorithms right CPU scheduling disk you dueling blood for sirs these are some applications maintaining a playlist is another application and finally we have interrupt handling if you have some idea about how operating system works if there is an input and output buffer right we have IO buffer sometimes an interrupt comes that has much more priority than what we are executing I mean do we have to remove that process and chipped it in a queue to execute the process which is having much priority then we have then what we are executing right so then that process will execute will finish its execution then whatever is in the queue goes to the prod goes into the execution so you see therein we need a queue ok now let's see the demonstration so we are implementing our queue data structure using arrays similarly you can do with the help of Linkous again you have a small assignment it's not about just watching this video and not learning anything you have to solve these problems right if you don't face a problem that means you are not learning right so I'm giving you these assignments so that you can think yourself maybe you were stuck you are stuck somewhere that is what makes it this interesting right so that's how you learn by stucking by watching something by watching some more videos so yes you see this is how we learn so I'm implementing this using arrays similarly you can do it using linked lists so let's go through the skeleton quickly though so the structure we are using here contains three elements right first we have friend there and sighs okay then we have unsigned capacity and then we have an integer array so what do you mean by this unsigned capacity right in linked list you don't need this because there in the size is dynamic but since we are using arrays we have to define a size so that's why unsigned capacity now let's go to the creek how we create a queue so basically it is turning a queue right so we need a pointer right and it is it's argument is unsigned capacity so that we can assign it to the size of the area right in the second last statement if you can see we are using malloc function to assign memory to the array right we are typecasting it to an int let's go to the third line from the last so we are then assigning the rear the capacity size minus one since we are using arrays indexing starts from zero then friend or and the size are zero because we don't have any elements right now in the queue so they are pointing to 0 then we have capacity the two capacity is equal to the capacity of the array right there in we can store only that much elements in the queue which are present in the array size right the size defines the capacity of the queue then we are allocating memory to the queue okay in the first step now let's check out some operations that we are doing ok and qdq and then also we are checking the underflow and overflow conditions right in the queue so the first operation that we are doing is full right it checks the underflow candy the overflow conditions right so then we have how we add an item in a queue first we check if the queue is full then we can't end in element right then after that if we are done with this and we can insert an element in the queue then what we did here you can just forget about this line for now we're in I'm using modulus operator so let's check about the other operation the other statements that are present in this function okay first we insert element in an array then we increment the size right and then we print that element that we have inserted this element in the queue and cue to cue item then we are printing this item right so what do you what have I done here by using the modulus operator you see we have a pointer which is pointing to the rear side right which is used for inserting an element so what we did we inserted the element in and inserted up to the last right the capacity size minus one so you see all the elements are there 1 2 3 4 5 6 7 8 9 10 for example the size of the arrays then the capacity is 10 like we have inserted all those elements now what with the friend with the help of friend pointer we are removing all those elements and we are at the last element so you see now if I trying to insert any element I can't right but there is the capacity right 9 elements are left which are not assigned to anyone right the 9 indexes the 9 elements are present there but I can't assign it so modulus operator helps me in assigning values to those empty elements also of the array ok so that's why I am using this modulus operator then there is a function that is is empty to check if the queue is empty or not okay then we dequeue that is the last element the last operation that we are doing is dequeue right the moving element from the queue so first we check if is empty is false that is there are elements in the queue only then we can remove right the end of flow condition if the queue is empty then we are trying to remove something we can't right so this is the under flow condition that we are checking first and then we are removing from the friend size again similar fashion so that if somehow we have we have done whatever we taught earlier right I told you that if we are deleting all the elements then we are present then my friend entry at the same position so I cannot remove anything right because the last element is removed so after that what happens and I am insert I have inserted all those elements when my friend is pointing to this so modulus operator helps me to remove all those elements in the similar fashion then we decrement the size of the queue then return the item that has been removed now let's see the friend and the rear side how we use those things so basically the friend oh if we try to get the first element we just print out whatever is in the front right we just return that element and to even get the last element we just return what is at the rear side okay this is the main function that at that time we are just inserting few elements in the queue ten 20 30 40 and then we DQ'd one element what will be dequeued 10 right and then we say what is the front element then it will be 20 and what is the rear element it will be 40 right this is the output of the program that we just saw okay now let's talk about binary tree this is the most important data structure that we are going to study right it is a it is not a linear data structure like arrays linked list stacks and queue it is a hierarchical data structure right in that it means if we are doing something that there is a parent there is a child then there are sub parents and sub child's every node is connected to the topmost node in somehow okay but it's a binary tree so at most there can be two children's of a parent right every node can have at most two children's right we are talking about binary tree right the topmost element is known as the root of the tree right can we access randomly using index yes we can access elements randomly using its index for example if you have seen a file system right if we are talking about any five file systems there is a root folder at top then we have processes libraries and all those are connected to that root element right some common traversals we are going to study in this lecture okay that is pre-order postorder and in order so basically what do you mean by pre-order so if we talk about tree then we have to childrens at most so first the pre-order it first prints that node then it goes to the left side okay then it prints that node then goes to the left side recursively right then it prints again then it goes to the left unless and until it has no left then it goes to the right okay print left and then right okay similarly the postorder works in such a fashion that it goes to the left left left unless there is no left that to the right if there is no right then it prints that right element okay we will see one example in order works it first goes to the left then prints that then goes to the right okay now let's see how these works first we will talk about some advantages and disadvantages so the advantage is that we can represent data with some relationship right there is a there's a relationship between nodes right there is a relationship insertion answer and if we're trying to insert or search any element it is much more efficient okay now what are the disadvantages the sorting is very difficult if we try to sort these binary trees okay not much flexible we will talk about it in this session as well some some some binary trees which are much more flexible than binary tree what our eyes the applications there are multiple variations to the binary tree like we have BST we have AVL tree we have red black tree all those are variations of binary tree right what are the other applications filesystem hierarchy is another application which uses the same structure okay now let's see its demonstration the node that we are using the skeleton for tree we are using that it contains three elements right the left pointer the right pointer and the data so how we create a tree first we allocate memory to a tree with the help of malloc okay how we assign our data is similar to what we have been doing right we go to the nodes data part and the assign the data then we have left child and the right child that is the left pointer and the right pointer at now they are now and then we finally return the node okay this is how we create a tree then we talk about traversals so we are using recursively you can give it a try to solve it in a non in recursive fashion right in recursion we are using stack internally right we know that so we can avoid that stack by iterating with the help of loops right we can use some other things too without recursion right we have to try that out okay so now let's talk about Travis okay so hearing we have used three traversals right postorder pre-order and inorder so let's talk about post order so post means that we are printing elements at the end so if we check this function right here and we have used first the statement that node is equal into null right then return so basically if there is no node in the binary tree so what are we going to travels right and this also is our base condition for the recursion that we are using okay if there is no element to be if there is no element on either side of the left or the right child then we return ok so then first we go to the left side then to the right side and then we print our data so how does this work basically if we are if we have 4 elements 1 2 and 3 and 4 elements right we have 4 elements and they are built in such a way that one is the root element and 2 & 3 are its child that 2 is the left child and 3 is the right child and whose left child is 4 okay so we have this tree right so I am passing you the head node right so the node head is present so herein we have 3 function calls right left right and print print statement these are the three statements we are going to execute right so we check if left sub node is present yes it is present then we go on the left child else we are present on the on - which is the left sub child okay then again it is having three statements what left the right end print three statements are present then again function call goes to the left side right so on for now we are in for all right so now we are at four so again it is having three statements left right and pray so now we are going to the left again but in the left it is now so our node is equal to null so we return from here okay now on foe we check if there is a right child there is not so returned will help us again and it will return the control okay and then finally we are going to print so in the given a binary tree that I just told you first element in post order that will be printed is for okay and then we have covered the left child of the two then we go on the right side since there are no right child on the two so we come back and print the two so the other element that is going to be print is 2 so after that now we are present at the one that is the root node so left side is covered then we go on the right side when we go on the right side we are at 3 so 3 is left is null right is null then we print the statement write print statement is there so we print 3 then finally it will come back and print the root node which is 1 so if the tree that you have written and I have told you so if the tree is 1 and its root node is 1 and its left and right child are 2 and 3 and the tools left child is 4 if we are drawing this tree then the postorder of this tree will be 4 2 3 1 now let's talk about in order right so in in order if you see this this function carefully only the print statement is changed rest is same now we first traverse to the left side then print our statement and then print our nodes data and then we go to the right side so these are the three statements L P and R what do you mean by L go to the left side P means print and R means go to the right side so similar tree we are drawing for this as well trying to debug this okay 1 2 & 3 then we have 4 okay so similarly root node is 1 then one's left child is 2 and right child is 3 and twos left child is 4 okay now let's see first we are at the root node and it is having 3 statement LP and are okay so it goes to the left side right now it's also having LP and are we are at - so it goes again to the left side okay then we are at four and it's also having three statements right left print and right so when we are poor it goes to the left it checks its null and then it returns then we print so print we will we are printing for first in in order traversal then it goes to the right side it is now it comes back then it goes back to its parent which is two so to stay second statement is bending so it will print so the second element will be two four and two are printed then it goes to the right there are no elements in the right then it goes to its parent which is the root node that is one so left side is covered then we print one and then finally we are at the right side and the three will be printed so in this case 4 - 1 3 will be the output of this tree now let's talk about fee order so similarly only the statement that is changing is the print statement so we first print a element then we go to the left then we go to the right now same tree we are drawing 1 2 and 3 with 4 with 1 as the root node 2 is left child and 3 it's right child and twos left child is 4 okay now let us try to debug this as well so first one will be printed because print left and right are the statements that we are going to execute so print is done then we move to the left so then we move to the left then print is done that means 2 will be printed then 4 will be printed and then 3 will be printed so the output of this will be 1 2 4 3 if we're talking about pre-order so you see 1 2 4 3 is of pre-order 4 2 1 3 is of post order 4 2 3 1 is a post order and 4 in order it is 4 2 1 3 so this is the main function that we are going to run for this program so you see here in we have a route then we created the first node then we second node and the third node and the fourth node then we executed all those statements all those functions we try to execute those functions right pre-order this then in order of this then finally the postorder functions so you can do it on yourself it is again a little assignment for you guys you can just change the nodes or insert some more nodes and try to figure out what is the preorder and postorder then you will execute that code and check if you are doing it in the right way okay now let's talk about bsd binary search tree we have given B binary tree and additional responsibilities and restrictions okay what do you mean by that we are building a tree in such a fashion that elements to the left side of the root node are less than the root node okay if we're talking of if four is the root node then the only child which will be present on slave side that means I'm talking about the left child will be less than four and all the elements which are present on the right side will be that is the right child will be greater than four and this is true for every sub node okay every child this is true for example if I'm talking about left node the left nodes left will be lesser than the root node that is the parent node right now will be less than that and all the elements will greater will be greater than that so the left child must always be less than the roof node for every node I am talking about okay and similarly the right child must always be greater than the root node insertion deletion and search operation if we're trying to do these operations are much more efficient than binary tree now let's talk about some advantages and disadvantages so it maintains order in elements right you see if we're trying to insert a elements in a binary search tree in such a fashion that it maintains some order and can easily find a min and Max nodes in the tree right we can easily find minimum element and maximum element right in order to reversal gives you sorted elements this is the most important line if we talk about binary search tree we're in the inorder traversal gives you sorted elements we are going to solve many questions with the help of statement I'm going to give you one bonus question as well in the end of this binary search tree wherein we are going to use this statement what are the disadvantages of BST random access is not possible similarly as we talked about binary tree in that also random access was not possible ordering adds complexity since we are adding some responsibilities it adds to its complexity what are some applications it is suitable for sorted hierarchical data now let's see the demonstration of BST so similarly there will be a key and the left child or under right child the key here is the data okay so first now we are trying to create a BST so first we have the item as its argument and we are returning the node first we assign memory to the node right then we insert value in it the item then we assign the left child and the right child as null so what is the inorder traversal it is same as in what we did in B binary tree okay so this is the demonstration of now how we going to insert and the main function so how we going to insert so every time if an element is less than its parent node or any node it is going to be inserted on the left side and if it's greater than then we are going to insert it on the right side so this these calls to the insert function we are again using recursion if you want to study about recursion you must study about these trees because every time if you're facing any competitive programming questions regarding binary trees you always are going to use recursion okay so it really helps so we are calling every time the insert function again and again so if you can see carefully we are again using a base condition wherein we check if the node is now then returned all right so this is the this is the code for insertion and the main function in the main function we are just inserting 50 30 20 and it will be ordered semi there is will be a order maintain to it okay what order we have already studied that so this is the output of this program so this is the output when we try to when we try to find in order traversal on these elements which we inserted what will what will be the answer if you can give me any cases if you told it will be a so it will be in sorted order then you are right absolutely you see 20 30 40 50 60 70 and 80 this is the output because we are using an inorder traversal okay so now it's time for the bonus question let's say you are giving a binary tree or you are given a BST and you have to check if it's a valid BST or not what are you going to do give it a try pause the video give it a try right so all this or try to thing you have to check if this tree is a balanced BST that is if this tree is a balanced binary tree that is by if this tree is binary search tree or not a valid binary search tree or not if you said you are going to use in order traversal then you are correct in this question we are just going to implement our inorder traversal if the output comes to be sorted then this tree is a valid BST okay this is similar this is the most simple application or most simple program that one can think of right this is very important that every time if you try to traverse in an inorder fashion in a BST it will always give you an output of in a sorted manner okay so now let's talk about heap data structure basically we are going to represent heaps as an array but we will visualize it like in complete binary tree what do you mean by a complete binary tree basically a complete binary tree is a tree where in every node has two children except the leaf nodes and in the leaf nodes the elements are filled from left right such that we can to present it in the form of array we're in the element present at 0th index will be treated as a root node okay so this is how we're going to implement binary heap we are going to visualize it like a bi complete binary tree and we are going to store elements in the form of array length of the array is represented by length a and heap size is represented by heap size of n array okay generally when we are dealing with minimum and maximum elements we go with heaps so if we talk about heaps we generally have two variations a mean heap and a max heap basically in min-hee root node is always less than its child or parent node is always less than its children and it will follow for every node in the heap similarly if we talk about max heap in max heap root element or parent element will always be higher than its child and it will also follow for all the nodes in that heap okay so what is written in this chart the parent I minus 1 divided by 2 what does this mean basically when we represent our nodes in the form of array so if we talk about any particular index for example 3 I'm talking about this third element which elements are going to be its left child and which element is going to be its right child how are we going to find it out basically if the index of this third element is 2 so we multiply 2 by the index 2 that is 4 4 + 1 5 so 5th indexed element will be its left child and when we multiply it by 2 + 2 so 2 into 2 that is 4 + 6 + 2 that is six so the element at sixth index will be it's right child can we find out for a particular index or for a particular node who is experienced yes we can for example if the element at index two we have to find its parent right we know it's zero but how are you going to calculate it first we will do 2 minus 1 right 2 minus 1 is 1 1 divided by 2 basically we are doing here integer divided by integer so 1 divided by 2 is 0.5 which is 0 so 0 element will be its parent which is true similarly we can find it out for rest of the elements so this chart is very important we are going to use this chart in the rest of this and we are going to follow this structure okay this chart let's now talk about some advantages and disadvantages can be of two types we know mean heap and maxi min heap keeps the smallest element and the max heap keeps the largest which is present at the top right that means if we're talking about max heap the element present as 0th index will be the maximum element in the whole heap okay similarly if we talk about mini the minimum element will be present at the top so when we are trying to find out minimum element and maximum element we can easily find it in a constant time right so the time complexity for Phi for removing the top element or finding out which is maximum or which is minimum is order of 1 for insertion and deletion if we talk about these operations time complexity is of log n which is depth of the tree or the depth of the heap okay so how it is log n basically if we're trying to remove the element which is present at the last that is the last index of the array so it can be done in order of one time but what if we are trying to remove the first element right at that time we will replace the first no with the last note okay once we replace the air elements let's talk about in arrays okay so we will replace the 0th index with the last index then we will swap them then we will remove the last index easy right but now our heap has been deformed we need to Max apply it if I'm talking about max heap so now we have to make CP height so we will bubble up and find out what what which is the largest element so that we can put it on that top so for this we will need log of n type similarly when we are trying to insert something first we will insert it at the last index then we will bubble it up and find its appropriate position so that it follows the property of max heap so this time we'll also this for this operation time complexity is also off log n what are the disadvantages then the mixes is not possible right only min heap and only minimum and maximum element is available for accessibility right so we only know that only the element which is at the top we can access only that and that will give us the appropriate results since this is the only element which will be maximum if we talk about other child's of this root node they won't be they won't follow that property they will be maximum in that tree or in that subtree but they won't be the total maximum okay they won't be the next maximum for example the root node is first maximum then the second maximum is this then the second Maps maximum is this we can't deduce that okay what are this application when we're dealing with priority we can use heap when you're using we can use it while scheduling algorithms scheduling algorithms right caching we can use it in caching right so let's now see the demonstration so I am building a maxify similarly you can make some changes it is your assignment once again to build a min heap so let's talk about first heap maxify so we have to point to variables right left and right so we are using that same property to into I and 2 I 2 into I plus 1 basically why I have changed this formula you see here I have written 2 into I and 2 into I plus 1 because in this case I was choosing my index 0 to be my root node right but here in I am using first element as in my root node so that if I multiply to for example the root node Espaillat present at 1 index 1 so which one which will be its left child so 2 into 1 right that is 2 and 2 into 1 plus 1 you mean 3 so third element will be its right child so that's why I am changing the formula then we will check if it is less than the heap size and if the left element is greater than the right and then the index that we are then the largest element is this then if not then the largest element is the index so similarly we can find it in the other subtree okay so this is how we build a max-heap so we will build it on each parent node so you see we are doing C by 2 in the build max-heap right so then we max simplify that parent node similarly we will do it or for all the parent nodes okay basically why we are using this heap size and why you as why we are using the max-heapify property here basically we are trying to build a max heap such that it follows the property of that the element at the top of the heap is the largest element and element as the or if we are talking about min heap the element at the top of the heap is a minimum element okay we are following this property try to drive in this code and you will get to know what exactly is happening basically we are checking if this node if the root node is less than or greater than this then we check which one is the greatest so that we can wrap those elements once we swap those elements then we check the element that has been swept is that following the same property if not then we are calling the max-heapify again you see and just above build max-heap there's a max-heap if I called again because once we swap the elements then maybe we might we might have deformed the max-heap that is we might have we might not be following the same property so that's why we are calling for the other element as well which have been changed so in this way we will build our max-heapify now how can we find the element which is maximum simple we will return the first element I will and tell I was telling you earlier also that I am using my first element to be at index 1 so that's why I am returning a of 1 in your case if you trying to implement it with zero then you have to return a of zero because that will be the only element which is maximum throughout this array how we can extract max so once we have extracted our maximum then we have to change it right once we have extracted our max maximum element we need to find out the other maximum so that we can replace it with that ok what we will do first we will replace this maximum element with the last node that is the last index once replaced with that we will remove the last index so that is our extraction of maximum element but now we will check is this element greater than this greater than its left child and greater than its right child if yes then we will do nothing if not we will find out which one is the maximum of between these two right we are calling the max-heapify you see and we also decreasing our heap size because we can't decrease our array size right we can decrease our heap size that's why we are using heap size and arrays heiresses will remain same but in heap size we can remove it since we are not dealing with 9 elements or 10 elements now because we have extracted one element so a heap size is decreased now we are calling max-heapify function again so that we can check does this one's removed does this follow the same max-heapify property or not so we will find out the maximum between these two with the help of max-heapify right earlier explained right so that's why first we will check it with the left then the right and then once we have found the largest if that is the largest which we had already then we make no changes if not then we will make the changes and replace that max a maximum element with the root node once done that then we will check if this is the property that is following this is the this node that we have changed is this element also following the same property or not if not with again called max simplify on it similarly once all these elements follow this property only then we can be sure that this heap is following a property of max-heapify that is the root node or the parent node is always greater than its children right so this is how we do it now we will see the main function here and we have declared an array a heap size then we are calling build max heap then we are finding the maximum value we are printing that value right which one will be the maximum maximum will be 16 here right so maximum element is printed we display the element of the maxi priority right display the element of the max is priority then we call the function and extract maximum right this is these are the steps we are doing in this program okay what will be the output the output will be the maximum element is 16 right then we displaying the heap priority that 16 14 10 8 7 this is the maximum numbers that we will be extracting this is these are the maximum numbers in the heap right then we are extracting the maximum value that is 16 so this is how we conclude our heap topic so now let's talk about the question or the bonus question that I try to give after completing topic so the question is you have to find the largest element in an array right but not the first largest the largest can be any number I'm talking if I'm talking about the first largest the second larger the third largest you have to give me that just number for example in an array in this area right now shown on the screen you have to give me the fourth largest number okay what will be the fourth largest number sixteen is the first fourteenth is the tenth then ten is the third and nine is the fourth so force will be the fourth that is the fourth largest element is nine so you have to give me this number so the first approach that you might be thinking and which is very intuitive that you will sort this array and you will just give me the element present and the fort index but the time complexity is much high right so the second approach is and by far better than this is using a heap you will you can easily create a max-heap and you will just remove the first element from it then the second and the third and the fourth the fourth element will be a nine so try to implement this okay use Mac simplify use the same approach that we are using here try to build a max-heapify then extract max four times call this function four times Mac and it basically depends on which element you are trying to extract for example here I am talking about fourth element I might be saying that the key element you have to give me the key element that means if I will give you K equal to five you have to give me in the filth helmet so that many times we will call our extract max function okay so let's conclude this topic here and let's move ahead with the next topic so now let's talk about hashing basically hashing is not a data structure rather it's a technique which we use to implement our data structure that is hash table so now let's stop before talking about hash tables let's talk about this hashing basically in hashing we use a special function called function which we use to map our elements to a particular address for storage for example if we are using a hash function say X modulus 10 right so what is X X is an element right X is an element here on which we do an operation of modulus we do a modulus operation and divide that is modulus by 10 so what will be the remainder remainder will be zero so we will try to implement this technique so how are we going to implement this technique depends on the data we have so for example let's suppose we have 10 elements 1 21 145 132 and so on to 999 we will try to mod it by 10 so how many space how many spaces we are going to have in a hash table right if we try to do modulus by 10 so what will be the remainder or really the possible remainders right it will be from 0 to 9 so we will try to do modulus operation to all the elements and map them to these particular locations that is from 0 to 9 okay with the help of this math this hash function ok so why do we do this why do we need a hash function basically hash function helps us to search an element in a constant time also we can perform deletions in a constant type so while we modulus anything by 10 for example we have modulus we use a modulus operator on 121 when we model when we do a mod operator on 121 that is 121 mod 10 what will be the remainder 1 so we will map this one to an index 1 okay so the element that one 21 32 right we will try to get with the help of this hash function we will try to add we will try to map this element to address for this storage so basically what we do we will get this 2 and map this to that in the array the everything that we got that is from 0 to 9 we will map this so let us suppose we have 10 20 30 40 50 60 so all these elements will be mapped to a particular location that is only one location right because every when we mod them by 10 all of these elements will give a zero remainder right so we are trying to implement we are trying to map these elements to a single location so during this time there is a collusion right what do you mean by collision when we are trying to map one or more elements to a particular location so there is a collusion so this collusion how are we going to handle this basically we have a resolution techniques for this basically the first technique is try to build a better hash function so that we can minimize these collisions but this hash function every time when a person is trying to build a hash function why will he build a hash function which is not suitable right so this approach is quite arbitrary right so try to build a better hash function now what are the two main techniques of resolution with which we can minimize our collision so the first one is chaining what do you mean by chaining basically whenever a collision happens for example 10 20 30 40 so there's a collision four elements are we are trying to map four elements to a particular location right so now what in chaining what happens basically a linked list is created so in zeros position where we try to build a linked list so 10 will be linked to 20 will be linked to a 20 will be linked to 30 30 will be linked to 40 so if we are having it elements that is 10 20 30 40 50 60 so all of these elements will be linked to us the particular location that is 0 with the help of a linked list we will link all these elements in that particular address right on this on the address where we have written zero right so this technique is called chaining we are using a linked list okay but I mean is this technique efficient no why if we are trying to implement 10 play if we are happy if we are having elements 10 20 30 40 50 60 so all of these elements will be mapped to a particular location using a linked list but when we are trying to find any element let's talk about in worst case if our element is at the end of the list so how much time do we take to access that element linear time right that is not the point all right we are trying to access elements in a constant time can we do that the help of chaining I am talking about worst case No so these this is one of the techniques but it doesn't solve our problem maybe in some cases it might solve but right now the example that I am giving it's not solving so this is another technique called open addressing which ever address is open try to access or try to insert element at this position so in open addressing we have three techniques three types like linear probing quadratic probing and double hashing what do you mean by linear problem so basically what do you mean by probing probing means searching okay so in linear probing what happens we are trying to build a hash function wherein we add collisions what do you mean by this thing basically we write now if we're talking about earlier case we were using a hash function of X modulus 10 now what we will use we will use X plus I modulus 10 where I represents the IATA collision for example now element we have the first element 10 I insert it in the zeroth location right so next time 20 comes now the collision this this time happens now this time the first collision happens so it will be 20 plus 1 the first collision is happening so 21 mod 10 so output will be 1 rather than 0 or output will be 1 so what we did we just shifted it to the next location okay so if there is an element then we shift it again so open it whichever address is open we try to insert our element in that location so how this is help helping us or helping our cause so basically if next time 30 comes let's suppose 10 is 10 is inserted at zeroth location 1 is in 20 is inserted at first location next time 30 comes so it will be the second collision so 30 plus 2 more 10 what will be the result 2 so it will be mapped to second location now what happens here basically if in this in this chaining method there's one problem associated with it we have seen that right in open addressing we are talking now about linear probing now there's also a problem what problem basically if if I am having elements 10 20 30 40 50 60 all these elements will be inserted in a locations like 0 1 2 3 4 ok now if we're having 10 to 40 alerts now if I if I am having 55 65 75 85 all right these also will be mapped to 5 6 7 8 so basically if I am talking about a larger picture wherein I am doing modulus by 100 if I see the broader picture there will be memory chunks right so there will be a memory chunk of 0 which will give me the output of 0 there will be memory chunks of elements which will give me the which will give me the result as 5 then I imply increment them with the help of this I at look at collision right X plus I mod 100 which I am doing right now so there will be memory chunks available there will be no proper distribution of elements right so to do a proper distribution of these elements in open addressing we have another technique called quadratic probing okay wherein we where in the hash function which we use is X plus I square mod 100 or mod tent so with the help of this technique we are trying to distribute our elements in such a way that there are no memory chunks that we are using so we are trying to distribute our elements even this another technique in open addressing for example now in this case what happens if 10 is present at 0th location now 20 comes so it is the first collision so it will be mapped to 1 but if 30 comes it is the second collision so 30 plus I square it is second collision so I square is 2 square is 4 all right so it the result will be 4 so you see instead of 0 1 2 we are we are inserting it into a location or mapping into an address wherein we are using 0 1 and then 4 so we are distributing it we are trying to distribute it evenly so there is 1 no problem in this open addressing technique that is quadratic probing we are not able to distribute that much right so if we see if we try to implement some example wherein we see there are even this is not distributing evenly so the final technique that we are using to rasili to reserve for the resolution of a collision in open addressing we have double hashing basically in double hashing what do we use we use two hash functions okay wherein we use first hash function plus the ID collision into second hash function so this is the techniques these are the techniques that we use to avoid collision or to minimize collision and also keeping in mind that we are evenly distributing our elements okay so let's talk about now advantages and disadvantages so what are the advantages hash function helps in fetching element in a constant time okay with the help of hash function we are able to employ we are able to fetch elements in a constant time it's an efficient way to store elements as we have seen all the techniques right what are the disadvantages we need to have we need to increase complexity why because of these collisions right we have do is we have to find a way to avoid or minimize these collisions so this is the disadvantage that we have with hashing what is it suitable for or what are its application the application is when we need a constant time to fetch an element or to delete an element okay and these are some advantages and disadvantages okay now let's try to implement this hash hash table now with the help of hash function we are trying to implement our hash table so we define an item right we are defining an item here structured by a structure item whenever we talk about hash tables we have to keep in mind that we have one key and we have data so with the help of that key we will fetch our data so that's why we are having two elements in this data and key then also we have to define a hash array size right the size is the the operator that we are using right that every time a time when I said that modulus by 10 modulus by 20 so this size represents that thing okay then we are also having an item the item that is we are using the dummy item wherein we I will show you where where to use this to me item okay so let's talk now about hash function or hash code which we get so the here we are using for simplicity we are using the simple hash function where then we get a value we modded by the size right similar to what we were we were expose explaining to you earlier okay so let us talk about now how to search an element okay in a hash table for example in a hash table we have five elements and the keys are one two three four and the elements are ten twenty thirty forty okay this is the hash table that we have how do we find an element so basically for how we insert it in element into this hash table using the hash code right using a hashing function so similarly we will use the same function hash code function wherein we try to search an element so that's why the first line in this search is we are trying to we are calling the function hash code function to get the hash value so once we got the hash value we will check if this is present in our hash table okay if it's not then we will return null because it's not present in her hash table so how are we going to search it then what we will do we will with the help of key we will check if the element that I got if that the element that I got its key is equal to the element which I have in the hash table are these keys equal if yes then we return a hash value okay then we return a hash value we return that element and similarly we will do some operations like incrementing our hash value and checking if the hash value mod sighs we are with the help of this if is a collision we will try to resolute that as well we will try to find a solution to that as well okay this is how we do our we search an element in a hash function now let's talk about how we're going to insert an element so first we declare our item that is the dummy item that we that is the item that we are going to use in this way when we are trying to implement hash table or when we are trying to insert element into it we need a data part and a key part so within when I am calling this insert function I am sending from the main I will be sending both these values right you see here insert the key is one and twenty is the value so I am trying to insert these values into our hash table so first I have locate memory then I assign these values to it then I find a hash code right with the help of which I will map it to the some particular address then I check if it's already present in that element or if it's pro or already present in the hash table then what will I do I will just move along okay then if it's not present in the hash table and its key is minus one all right if it's not present and its key is minus one okay I will increment our hash value which I have found with the help of this hash code I will increment that and I will insert my element you took this hash table okay this is how we do an insertion you see in the while I have used two conditions first wherein I am checking that this should be not null that is the hash value that I got this should not be present already in it and the second that if its key is equal to minus one so we got the point right how we are trying to insert elements into the hash table so secondly when we are trying to delete an element first we have to check if the element is present in that hash table or not if it's not then we return null if it is present then what we will do we will first find the hash code and then we will try to check where it is so with the help of key we will check if this key and the key which you got are similar then we will define and we will find a we will we will locate memory or we will define an temporary variable a temporary pointer wherein we store the element which we have to delete in that and then we return that element so that that can be printed that we will we have deleted this element right in such a way we will define our insertion function and deletion function and earlier what we cover what we studied there for how we search an element in the hash table so in this way we have implemented all the three function search delete and insert so now let's talk about the main function main main function we are first allocating memory then to a dummy variable right dummy item so in that dummy item we are defining that the data is minus 1 and the key is minus 1 okay then we have called insert function several times then we have tried to search in element 37 is it present in the hash table yes it is so we are checking if the item is not equal to null so if we got and if we got a function right let me check show you first the search function what it returns if the element is not present then it will return null and if it if the element is present then it will return that element so in the item what do we have we have 37 so item is not equal to null so what we will print we will print element found and the items data okay we will return we will in the item we will get the address part right we here return temp so in this temp we will be having address so address is not equal to null that means we have the element so whatever the ad whatever we got the address for example if we got 1000 address please tell me what is the data at that right that that address so this is how we are going to implement our this function search function and we are trying to print that element okay so if we didn't find our element then what we will print element not found then we are trying to call the function delete item okay s and we are deleting the item then we are again searching for 37 right we have deleted it first we got we search for 37 we got the 37 element we printed it and then we deleted that item then we searched again for it what will be what will be the result that element will be not be found okay this is why we are having two statements that is one the element found is 97 okay yes the I theta 37 is the key and 97 is the element so the data part is 97 so that's why we have here element found 97 and element not found because once we got the element here when we first called the search function we got the element 97 we printed it right then we deleted that item right so next time when we call for the same function as for the same key 37 the third element is not present so that's why element is not found comes second time so this is how we implement our hash table okay please guys try to implement these because this is the most important data structure if you talk about if we are talking about time complexity and competitive programming this hash table plays a major role in that now let me give you a simple example or wherein we can use this table for example if you have to find the frequencies of all the elements in an array right you have to find the frequency for example there are 10 20 30 40 50 60 70 then this la these elements are repeated okay so let us talk let me give you a simple example or example so for example if you are having an array in which we have 1 1 2 2 3 3 3 then 4 then 5 you have to build an array in such a way that your you have to if I am giving you an element you have to tell me what is the frequency of this element if it is even present in that area you have to also tell me that so easily we can implement a hash table right we can implement a hash table for example 1 and its frequency 2 and its frequency 3 and if and its frequency so whenever I will give you an element say let's suppose 1 you will check if the if that key is present in your hash table if yes you will return me the frequency right the data part so if I am giving you so let's suppose 100 and it's not present in your hash table what you will give me what will be the output at that time there is no such element found or for example the frequency of this element is 0 since it is not present in that hash table so easily with this having the help of this data structures this problem of finding out the frequency got very simple right this is the most important data structure in in terms of competitive programming so try to implement this ok so now let's talk about graphs so graph is also a nonlinear data structure like trees basically a graph contains nodes also called as vertices and edges to connect them a graph is represented in the form G V comma E where V G represents the set of vertices and E G represents the set of edges basically a graph is used to define a relationship between arbitrary objects or arbitrary data a graph can be directed or undirected what do you mean by that a graph which contains arrows is called a directed graph and in which where there are no arrows is called an undirected graph when we talk about adjacency lists and matrixes then we get to know the big difference between making how to make a directed graph and how to make an undirected graph graph can be connected or disjoint what do you mean by this if all the nodes are connected with each other or if all the nodes have a edge between them is called a connected node and we're in a node is not connected with one node is not connected with another road basically for example if five nodes are present and one node is left alone and four of them are connected in any manner so that will be a disjoint graph now let's talk about advantages and disadvantages so a graph is used mainly because we can find the shortest path with the help of graph a minimum cost can be reached wherein we have to find a way wherein we have to minimize our cost from one for reaching from reaching from one point to another we can easily use graphs to find the minimum cost minimum spanning tree shortest path for example if you are looking to find a shortest path between you know from route a to route B we can again use graphs to find a connectivity between between objects or between data we can use graphs okay now let's talk about disadvantages basically when we are trying to implement edges in C list and indigency matrices they can lead to complexities because in edges in C list we are using a concept of linked lists and in adjacency matrix we are using the concept of 2d array so basically in this session we are going to deal with EDC lists but I will tell you how to make an decency matrix basic if there are four nodes or four vertices so basically a matrix will be made of four cross four okay so when we have four nodes we are making a matrix of four cross four so if somehow we are having 50 nodes or 40 nodes so you see how complicated it gets to build a matrix which is of 40 cross 40 right and similarly if they are directed and undirected graphs if we're trying to build an undirected graph therein we have to create we are we have to insert elements in place of those if in place of the edges for both these for example if we are placing up for example there is an edge between 0 & 1 so we go into the matrix and we find out where is where is the location of 0 comma 1 that is zeroth row and first column we find their location and insert 1 in it if we are talking about undirected graph so once we did that then we also have to do the same thing for 1 comma 0 that is first row and zeros column we have to insert 1 in an innate right so this is how we create an engine C matrix by going to into that particular row and column and inserting 1 for undirected if it is a directed then we don't have to reverse the row and column thing okay so this is quite simple so complicated much complicated as Edison see list we are going to deal with that thing in this session okay now let us talk about applications it's suitable for circuit network it's a it's suitable for applications like Facebook LinkedIn it's also used in medical science now let's talk about now how we are going to build a graph basically what we are going to define two structures one is node and another is list in our node we will be having vertices a vertex right the node in our node the node structure we will be having a data which will store our data the vertex data right it is represented that let's keep it simple we are defining a node just like we define in a linked list therein we have a data part and a link part similarly we are defining the same node but instead of data I'm using we will present a vertex and we also define a structure that is the list which is a which contains a date which contains an element of head which contains an element which is off type node so basically what we are trying to create here a lists we are trying to create here a list the for example if you can see the last line on your screen wherein I have created an adjacency list which is an array of type list wherein I have explicitly defined that I am having five nodes and all of them are initialized with minus one so basically I am keeping it as static for simplicity and keeping it static basically if you want a variable in vertices you can easily define a macro here at top and give it some kind of a name that is number of nodes and you can put that thing in this instead of five okay when if I by defining a macro for simplicity I have decided that I am going to insert five elements five lists okay and I have to find the size of the array as five let's go ahead and check how we are going to create an H first let's go into the main so that I have a clarity okay so basically in main we are defining a loop which runs for which runs five times this basically we are allocating memory to the this array list basically what how we are representing these things in every air the elements in the array will be of type node and for every node and that means for example if I am 5 vertices 0 1 2 3 5 okay in that array every node will be linked to all the nodes to which this vertex is connected okay for example if 0 is connected with 1 2 3 and 4 so the first element will be for the zero to node the head will be present here and all the elements to which or all the vertices to which it is connected will be connected through the with the help of linked list so we are using a concept of arrays and linked list here wherein or every head node is present in the array and with the help of head node we can traverse through the all the nodes which are connected to a particular vertex for example if zero is connected to one two three four we can traverse through this array first will go into the 0th index and then we will traverse through the linked list so basically here we are allocating memory for all the nodes which are present right now we have five nodes so we are allocating memory and putting them in the array at the next pointer of all these all these nodes are null so there is a misprint in this slide so basically it's arrow next equation --ul and also there's a missing parenthesis in the for loop okay check that out so then once we have allocated memory right then we are going to add edges basically from there's the edge between 0 and 1 between 0 & 4 1 & 2 1 & 3 1 & 4 2 & 3 & 3 & 4 now let's see how our EDH works so basically at H we'll take two arguments write the source and the destination okay we have also created three temporary variables or 3 temporarily no type of variables where in first if we check if this is the first time that the source is present then this will execute and if it's not then if then this if will not be executed so since this source 0 is the head part of that is null right the source on in the array all right it's head section is now so we'll execute this so the first line and that represents that if we only insert the head in the array if it is present for the first time so we allocate memory to that then we assign values to it that means the vertex and the next part becomes null and then in the head section we will just give the value right the source the zero value will be present in the array similarly we will do it for all the nodes and when the next time zero and three comes at that time what we will do we will allocate memory to the next portion what do you mean by that by destination now now zero is present and it is connected to one so next time zero comes and it is connected to three so how will we connect this zero basically we are not going to replace the array element right we are not going to replace the array so a source of the source which is present in the array we are just going to with the help of that we are going to traverse through the linked list and add at the end the next node with to which it is connected okay so this is how we going to do it the while loop helps us to traverse and then finally we will put the temporary node which we have defined here in which we have right now we know that we can't change the head right it cannot be changed of any list so what we did we put that head in a temporary variable we help it to traverse and finally what we did we just put the destination node on to the next of this temporary node that is connected okay this is how we're going to do a graph add an edge in a graph okay now before concluding let's see the takeaways of this session in this session we covered arrays and linked list we saw their differences and their similarities how they are similar with each other right we talked about stacks and queues how they are different from each other we talked about binary tree then we try to implement the strict form of binary tree that is binary search tree we talked about heaps we try to implement max-heap right then we talked about hashing and implemented hash table and then finally we covered pit graphs thank you you