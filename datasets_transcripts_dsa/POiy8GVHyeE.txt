we can go back and we will talk about something called as a quick sort so quick sort it is there that go so things are like very simple going ahead should we start with quick sort so good so let us move on talk about what is quick sort probably the last sorting algorithm that we need to discuss and uh good thing is that the quick sort is again quite simplified sting algorithm we will see how it goes on paper you people also do it on paper once once you are comfortable let me know and then we will go ahead we will implement it in the code right so what quick sort algorithm uh it says the quick sort algorithm the quick sort algorithm we say this is smaller than the mer sort algorithm why the name is quick sort because it is found to be the fastest sorting algorithm it is found to be the fastest sorting algorithm for the N number of elements so as your number of elements are growing people have seen that the quick s does far better as compared to the other algorithms and that is the reason again the quick sort is very popular algorithm AR sort algorithm Java sort so your AR sort is kind of internally again using a quick sort many of the liaries f so most of the places I have seen that people prefer having quick s in place anyway so sir why it is called a quick sort as I told you that uh quick sort is kind of a sorting algorithm which is very fast but on a lighter note uh I said on a lighter note I many time feel that you know quick sort is such an algorithm which you likely to forget quickly Ali [Music] so quick a quickly forgetable sorting algorithm so possibility is that anyway and we will try to do quick basically IDE quick basic idea we will be having one of the element as a PE element you can say PE element or you can say kind of a reference element once you find a PE element you need to find the elements greater than PE you should be finding element greater than PE and other way around from right side you need to find the elements less than P once you find the element greater than P once you find the element less than P you need to swap them you need to swap them and you continue the story again from left side again from left side again you start finding a element greater than P again from right side again you try to find out number less than p and again you found it again you found it again you swap them okay and the story still continues again you keep finding element greater than p and you keep finding element probably less than be the story continues story continues till what until this left side marker and right side marker doesn't cross each other doesn't cross each other so I'm saying that and St will keep on repeating like moment they are crossed each other moment they are crossed each other the Z element let's say for example for example is somewhere over here so what element that will get swapped that will get swapped with the PE element that will get swapped with the PE element and that completes your one pass that completes your one pass that's it over that is also not a problem but you first try to remember to P you consider one of the element as a p element from left side find the element greater than Bu from the right side find the element less than bu moment you find that you swap these elements you swap these elements again you continue you swap these elements so say smaller small to understand the philosophy and this way you are continuing I or cross once they are crossed once they are crossed p element that you are trying to swap it with that element with that element all elements greater than will go to the right side and all the element less than P will go to the left side in other words in other words this element is reach to its final destination this element has reached to its final destination it only means that it only means that this element has its final destination apply quick sort to the left partition and apply quick sort to the right part partition that's it and your sorting algorithm is completed apply quick sort to the left partition and apply quick sort to the right partition and that's it your sorting algorithm is completed it is that simple job to CH us make our comfortable and then we will continue further right so I'm just starting with and let me consider one of the element as a p element okay so this element is a p element okay from this okay now from left side try to find out element greater than p is it greater than P not really is it greater than P yes I found a number greater than P from left side I to find out a number less than or equal to P okay is this number is less than or equal to P yes I found that the last element itself is less than equal to P what is to be done nothing much you swap you swap this element with this [Music] element again you continue again you find a number greater than p is it greater than P not really is it than P not really is it greater than P yes it is greater than P this element is greater than P you continue further you try to find out a number less than P less than or equal to P is it less than equal to P not is it less than equal to P not is it less than equal to P yes it is less than equal to P what you do you continue further and you sol this sort this and Swap this and again you continue the story again you want to find out element which is is greater than p and I find that 7 is greater than P I want to find a number less than or equal to P is it less than equal to p no is it less than equal to B yes this is less than equal to B but at this moment I found that I and Z crossed each other now I is no I need to swap that Z element with the p element so Z element is to be swapped with the p element so two comes over here and this element goes over here this actually completed your one pass and actually completed one pass what I observed all element to the left of this are smaller than that all elements to the right of this are greater than that all element less than this are you know H uh smaller than this are to the left and all elements greater than this are to the right this completed your one pass and if this completed your one pass I'm saying that apply quick sort to the left partition now consider and follow the same technique and then apply quick sort to the right side right side is consider go and find the greater find the smaller and continue the same process that's it this is nothing but the quick sort algorithm I hope the quick sort algorithm is cleared still I'll repeat it once again I'll repeat it once again and now I request you it will be good if you could do the paperwork with me if you could do the paperwork with me probably you'll be in a better position I'm just going ahead and finding out CH uh what is the first thing let us consider one of the element as a bu for my example I'm considering the left most element as a p if leftmost element is P I want to find out a number greater than P I want to find out a number greater than in other words element this is less than equal to P go ahead this is less than equal to P go ahead yes this is something element greater than P okay good I want to find out a number which is less than or equal to p and I find that or this particular element is less than or equal to P what is to be done yes I need to swap 9 and four so four comes at the place N9 goes at the place and yes you continue the story again you try to find a number greater than this is equal or equal to the equ in other words I found a number which is greater than P you continue further I try I want to find out [Music] number yes is this greater yes is this greater yes this is greater so I can simply say J minus minus okay that is going good what is to be done now with eight and two left side say I found a number greater than from the right side I found a number less than PE go ahead and swap these two numbers so I swap these two numbers and you continue your story further you continue your story further you try to find out a number greater than PE you try to find out a number greater than p and you try to find out number less than P now should I swap I and j i element because at this time I is not less than J I is less if this condition is false probably yes element I need to swap it with the p so two goes over here and the p goes to its place so Z element is swapped now now with the peod and what we achieved I told you all element to the left of the peod are smaller than that all elements to the right of the perod are greater than that now what is to be done what is to be done just go ahead and apply a go ahead and apply apply quick sort to the left partition left partition take a look at the diagram and tell me left partion left partition I'm asking index wise yes so it is zero 2 J minus one so I can say that left left 2 J minus one right left 2 J minus 1 and what about this this one is J + 1 J + 1 to write it is J + 1 to right so left partition left to J minus one and right partition j+ 1 to write I hope that is clear is algorithm understood to everyone correct should we go and implement the algorithm good so let us continue further what we'll do is that I hope Cod sharing or you are able to see the code basic quick even it is empty quickly and we will do the complete paperwork complete paperwork in the sense till last I want to write uh public void quick sort quick sort okay and what you need you need a left index and you need a right index quite similar to the mer s what I need to do consider consider uh leftmost element left element as peod okay consider the left element as a peod what is next step what is next step you continue further you find that from left from left with I'm saying that I index from left find element greater greater than P than P okay and then not only that you continue further from right side from right side Z index find element less less than or or equal to the perod yes equal to the per so we are following this rather like one two this is done then what do you need to do if if what that they are not crossed if I is less than less than Z swap I element with Z element right and then you continue further I said repeat a repeat steps 1 2 3 until I becomes greater or equal to J correct so I is less than or till I is less than J so left side marker is smaller than the right side marker you repeat the above steps but after that what is your next step now it is to be done once that Loop is completed continue further you want to swap Z element with P element right with Z element with the p element again we have taken care here and after that after that apply apply quick sort to apply quick sort to left partition partion you saying that left to J minus one and you continue further apply quick sort to the right partition and your right partition is from J + 1 + one to right by the way then what should be the terminating condition what should be your terminating condition what should be the Bas condition if array has single element partition a partition has single element element or invalid partition invalid partition just written this is exactly same condition as of MOT exactly same condition as of MOT mot and if you understood and now it is time we can go ahead and write a code for that let us continue further so from left find element greater than P so from left how do you find element greater than PE let just continue further one by one so we need I is equal to 0 see it carefully and I'm saying that J is equal to right correct left right say so it is there or is nothing but of left right left most element for this demo to work consider so from I to find the element greater than b while while of I pay attention where R of I is less than or equal to while R of I is less than or equal to uh less than or equal to the P element is equal to P element I can simply say i++ Obviously condition false it will come out of the loop or condition false when you find that the number is greater than P I hope you got the point the second step is the reverse of this so here you want to find out an element which is less than or equal to P less than or equal to P so you continue further AR of J is greater than ARR of left greater than AR of left you are saying jusus condition true sorry condition false when you find a number which is less than or equal to the period that is second I'm continuing further if I is less than J if I is less than J you need to swap I element with J element so how do you swap I element with J element so actually I'll just do one thing just to keep it more readable just to give it more readable I'll prefer writing one special function just to swap the number of elements uh swap two elements so I want to swap let's say let's say x index with the Y index so how do you swap this oh you know that temp is equal to R of X just to keep it more readable error of X is equal to eror of Y and error of Y is equal to Temp all right you continue further and then you go ahead you simply say swap element I to swap with Z element just as I said that I just want to make it more readable otherwi I'm just want to keep it more readable okay but you are saying that you want to repeat these tips okay 2 you want to keep repeating this okay as you are saying this we have repeated this until like I is less than Z you continue further now swap Z element with the p let me continue left most element or let say Z element with the left most element okay that is also done you continue further and you apply quick sort to the left partition well how do I apply quick sort to the left partition go ahead and let us apply quick sort to the left partition simply make a call recursive call to the quick sort you pass array and left partition is left to J minus one okay that is good and again you apply quick sort to the right partition which is J + 1 to right this also done and story is over only base condition is left let me just go back and handle the base condition if if left is equal to equal to right it means that it is having a single element if left is greater than right then it is a invalid partition so I'm simply saying that if left is greater than or equal to right I do not want to continue further I just want to say return return done so is it completed almost completed let us just check whether it is working or not let just check whether it's working or not and the array is somewhere like this it is 2 3 4 1 5 7 8 6 6 n yes I got the array and I want to print this BL array print this array arrays two string I know that but still I have just kept it there yogesh sorry yeah got the point M original 5 3 9 1 8 7 2 6 and 4 okay now this is good and then let me make a call to the quick sort at a place quick sort and left most index is zero rightmost index you understand that same as mer length minus one and check whether it is working or whether it is giving me any bug let me check is it working working working working working oh yes my IRA is in like a sorted order I hope you got the point it is working well obviously you can copy past obviously you can run it but let me tell you that this code still has got a bug still has got a bug so sir what is a bug there to understand a bug I want you people to do one little paperwork one little paperwork to paper and go step by step go step by step so having code on a Cod sharing and you see that at certain place this code is going to fail and I want you people to tell me at which place this code is going to fail so suppose that I got array like 4 3 2 and 1 if this is is my array if this is my array now I want you people to tell me how how this will work do the paperwork and let me know what went wrong repe of any number that will still work just go and change some numbers let me know if it is facing any issues is paper and tell me is it getting failed anywhere problem cre please participate it will help you to understand it better I said at one point it will create a problem only do it only one pass in the first pass itself it should create a problem what errors will be there ising question yes you people are saying that we are not able to find out a greater element okay yes you are not able to find out greater element error question will it cause any error will it cause any error and if it is causing any error what is the error that it is causing that is a question yes may that you are right that it is like index out of bound exception please note that find a number greater than P find the number greater than P sorry find the number greater than P sorry find the number greater than P sorry find the number greater than P sorry and find the greater number greater than P moment you reach to this P point this point will cause array index out of bound exception Loop you are trying to find out number than you'll find that it will give you exception because element please go ahead please go ahead and put it into the code and you cross check put it into the code and you cross check integer let me create an array and with the array like a 4 3 2 1 even though it worked for some code does doesn't mean that your code is perfect and now you are able to see the exception and you find that this exception is at the line number this which is saying that at this line number 27 element access this element is out of range is that clear problem this problem is clear yes and now if you understood a problem if you want to understood the problem obviously in this Cas listen carefully in this comp that's why I say that please do the paperwork at your side as well it will be like very tough for you people to digest exactly if you just only listening mode it will be like tougher job for you so I'm saying that I to this is a p this is a p find a number greater than P oh this is a great than p no so you say I ++ is it great than p no I ++ is it great than p no I ++ is it than p no i++ and now you are seeing I ++ so your I is at the index 4 your I is at the index 4 and you are trying to compare this element this element with the p element but AR element this is going to give you exception index four is out of Bound for the length four element is that clear yeah now wait am I correct El that is meaningless that is meaningless correct so partition S I need to confine myself into that particular partition itself right so I'm saying that this is nothing this was nothing but my left and this was nothing but the right I hope you know this left this is right so instead of length minus one I can write it only right and I can check have a look at this if I is less than or equal to right if I is less than or equal to right if the first condition is true then and only then check for the second condition if the first condition is true then and only then you check for the second condition which will ensure that this exception will never occur which will ensure that this exception will never occur I element compare that is in front of you so you find that the I will become four but you are not comparing that element and then you continue further you want to find out a number less than p and I immediately found a number less than P but have you noted that in this BL case your I and J they are I and J they are crossed each other since they are crossed each other I need to swap jet element with the p element and it AB element with the p element and then I found that yes this element reach to its final position and then you apply it to the then you can continue further and you can apply it to the left partition apply it to the left partition and then you can again think of applying it to the right partition right partition itself is invalid partition to you can focus Only onto the left partition and this is nothing but now this code become perfect so so do you want to say that now this code will work yes this code will work and you cross check is it really working is it really working yes it is absolutely working you don't worry now this is a perfect code now this is a perfect code it is working for this big array it is working for that small AR as well or good that I'm assuming if not I'll wait for one more minute let me know if it is working for you and if it is working for you then we can go ahead we will try to make ourself comfortable and once it is comfortable we can quickly talk about its uh time complexity and another possibilities we can talk about that as well and after that we will wind up with the Sorting algorithm and we'll move on to the New Concept that is good good now most of the people have done it let me go back and let me do the whole algorithm once again for you please pay attention please pay attention I'm just going ahead and what is algorithm algorithm says that you consider the leftmost element leftmost element as a PE okay this element is a PE this element is a p i want to find out a number which is greater than P find find out a number which is greater than p and from the left side I'm to find out a number which is less than P all right you continue so find a number greater than P I found a number greater than P they should do it with me so find a number greater than I want to find out a number less than oh I found a number less than P there itself what is to be done this element is to be swapped with this element 9 and four they are swapped with each other and then you continue further again you try to find out a number greater than PE I guess this is not greater than PE but I found a number greater than PE find out a number less than or equal to P how do you find out number less than or equal to P okay J minus minus jusus yes I found the number less than or equal to P what is to be done go ahead swap it once again so you swap two with it and again you try to find out number greater than P you find a number greater than P I found a number greater than P you find a number less than P I found a number less than P but what is this what is this well I understand that in this particular case it is I and Z crossed with each other what is to be done what is to be done swap Z element with the p i SW Z element with the perod that's it I done that that is good my pass one is completed the pass one is completed now you want to apply quick sort to the and now you want to apply the quick sort to the left partition and to apply quick sort to the right partition May left partition it is this much on which I want to apply the quick s and your right partition is this much for which a again you want to apply the quick sort I hope this is very clear quick let us continue further give me a minute let me put a box for it and I'm looking good and then you again continue your process you continue your process what you want to do for left side so again this is from left this is from right but from left from right I'm saying that you consider this as a p you consider this as a p and try to find out a number greater than P I found a number greater than P I want to find out number less than or equal to p and this number itself is less than equal to P what is to be done go ahead and to swap three with one so one comes over here three goes over there this is done and then again you continue you try to find out number greater than P again you want to find to find out a number less than P I found a number less than p and what happened what happened I and Z crossed each other if I and Z crossed each other what is to be done go ahead and apply apply uh what is that Swap this J element with the p element swap J element with the p element this is done and if you are done now you find that two all the element smaller than that are to the left of that all the element greater than that are to the right of that okay that is still good and now again you go on say that apply quick sort to the left partition and apply quick sort to the right partition as you apply quick sort to the left partition see it carefully as you apply quick sort to the left partition what I said okay only element one is there nothing else is there that is good and then you want to apply quick sort to the right partition for the right partition again what I see is nothing but element four and three and then left partition what will happen with this partition what will happen with this partition for this partition I'm able to see that the left is equal to equal to right and if left is equal equal to right there is a single element partion I hope terminating condition is reached so this part left part is sorted now you go to the right part right part what you need to consider right part I need to consider this element as a p and you want to continue further going to continue further from left side find a number greater than p and I found that this is not greater than P this is not greater than P again you go there and you stop there just now 431 it is something like this it is going Beyond right so it will not be compared you go back and then I have got a number less than PE I found a number less than P but what is done in this case what is done in this case well in this case I find that this element is like swapped with Z element P swap with Z element this is done oh good now you apply quick sort to the left partition you apply quick sort to the left partition and apply quick s to the right partition a left partition is left partition partion left partition has got only one element left partition has got only one element so you see that again left is equal to equal to right the condition is false by the way what is the right partition a right partition is J + 1 to right A J + 1 A J + 1 to right J + 1 it is at which index J + 1 it is at which index not this is 0 1 2 3 this is zero this is okay one CH two 3 and four so this is like a index indexes in front of you so J + 1 comes out to be four not J + 1 is 4 J + 1 is 4 and and right is three a right over here is like three so left or right cross I hope you want that J + 1 to WR A J + 1 is 4 to3 4 to3 4 to3 partion I'm saying that in the right side partition in the right side partition left is going to become four and right is going to become three right is going to become three so which is a invalid partition in itself invalid I in itself so that is tering condition but still I'm very sure you are able to see that your array is still sorted 1 2 3 four so the elements are in a sorted position okay that is good by the way left partition sort what about right partition or to sort the right partition what is to be done you continue further a right partition what is to be done if we have got this and what is next job you consider this as a PE and you continue the story you want to find out a number greater than PE I found a number greater than PE you want to find out a number less than PE I found a number less than PE and then I want to swap these two six comes over here eight goes over there continue further again I want to find out number greater than p is I found a number greater than PE I want to find a number less than PE again I found a number less than PE that is good what is next job to be done what is next job to be done I and they crossed each other so you swap this element with the peod okay six Z element with the p you have swap that okay that is done and if you done that if you done that apply quick sort to the left partition when you apply quick sort to the left partition applying quick s to the left partition left partition contains only one element contains only one element that is six and where I understand that left is equal to equal to right so there is is nothing a single element you continue further and you want to apply it to now the right partition okay the right partition is 8 and nine all right this is eight and this is like a nine okay that is good then you consider this element as a PE and try to find out a number greater than P I found a number greater than P I want to find out number less than or equal to p a I found number equal again you found the number less than or equal to P what is happening in this s again the Z element is swapped with itself so eight element is spped with itself now you apply to the left partion partition is from J to sorry left to J minus one left to J minus one something like this 5 6 7 8 this is five 6 it is s and 8 so J minus one comes out to be six A J minus one comes out to be six and left is nothing but s so in this Cas you'll find that left left 2 J minus one so left s or right kind of a six J minus one which is somewhat again invalid partition now you go to the right partition right partition May element and that element is nothing but nine that element is nothing but nine and if this is the element you're talking about this is element that you're talking about I'm able to see that in this case left is equal to equal to right so nothing much I need to do with this as well this is done and I'm saying that theow of recursion tree so your first division is like this your second division is like this your third division is like this your fourth division is like this and your fifth division is like this so this is how the elements are organized recursion tree depends more or less up to your luck Lu like I was talking about the earlier example you see that earlier example you noted that oh left partion so what you need to do carefully partitioning so you need to work on array of 1 3 and two as you are working with the area of 1 3 and two as you working with the area of 1 3 and two again you try to apply you try to make this one and then you applying what is that you find the number greater than again greater than you understand that or less than or equal to P sorry my mistake you find a number greater than p and you want to find a number less than or equal to P less than equal to P again I find that this element itself is less than equal to P so Z element is swapped with itself actually it is swapped with itself what is the next job to be done the next job to be done is that apply quick sort to the left partition which is invalid partition apply quick sort to the right partition and to apply quick sort to the right partition again again take a look at this now you need to again consider the array of two elements please note AR of AR four elements elements and again you are trying to apply something similar logic again you're trying to consider one of the element as P element you try to find out a number again greater than P or I do not find anything greater than P you find a number less than P I found a number less than p and what is the next job to be done next job to be done you want to swap Z element with the p you swap Z element with the p you have Z El to the P okay that is pretty good and the last thing the last thing that I understand over here is that is right side partition invalid or left side partition there is a single element and that single element that you need to handle single element that you need to handle which is again a kind of a terminating condition so this is done not with the array of four elements literally bar literally bar recursive call but this is unlucky unsorted in the sense descending ascending sorted at that time you you'll find that number of partitions or number of passes that you are able to see are nothing but three passes in turn it is kind of n minus one passes you are able to see however in this assignment number of passes they are like reduced I hope you are able to see what I want to tell you is that quick per Qui every time you get the element in between every time you get the element in El I would say that it is highly inefficient it is highly inefficient element after one pass so you find that it is equal equal division equ equ division so you will find that the quick sort is at its best case and then it looks quite similar to the mer sort isn't it to left plus right by two are you there mid is equal to left plus right by two so m s me it is always division by complicity the time complicity of quick sort expl in a best case I said that quick sort in a Bas case is like mer sort and the like mer sort so time complexity will again continue to be o of n login o of n login but in a worst case in a worst case a it is simply going kind ofus obviously in worst case in a worst case it will be o of n into n minus one and it is into n minus one you know that n into n minus1 n sare - n minus n is to be ignored you can say that the time complexity comes out to be o of n sare time complexity comes out to be o n Square what the complexity so if you want to understand this better please go back and take a look at the time complexity ascending or descending act and that's why the actual number of passes that you face is around n minus one passes to to in that case I'm simply saying that that comes out to be nus that and that is quick take a look at this the quick s PE element can be first element or it could be we will go on a random basis and we will select the random number as a p we can take it like a random number of a but ideally you can always say that you can find out a median of array what is median what is median of the array median I said AR s sorted ARR element that is called as a median that is called as a median to to be frank in this array five was almost a median but what luckily left I hope you got the point you got the point so that is again to be counted so we just done ass we will take the first El as what is med I say that middle element in sorted array of mathema cations medium Qui I found it good but again it is purely mathematical explain I guess that was like a more easy to understand [Applause] [Music]