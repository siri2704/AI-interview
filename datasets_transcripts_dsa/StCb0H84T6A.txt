hey everyone welcome to simply launch youtube channel in this session we will be learning complete data structures from scratch but before we begin let me tell you guys that we have daily updates on multiple technologies so if you're a tech geek in a continuous hunt for latest technological trends then consider getting subscribed to our youtube channel and don't forget to hit that bell icon to never miss an update from simply learn now without further ado let's get started with the agenda for today's session we will begin with having a brief introduction to data structures followed by that we will understand what exactly is time complexity after that we will start understanding each and every data structure starting from pointers in c moving forward we will learn arrays in data structures and then we will learn the types of fires that is two dimensional arrays and multi-dimensional arrays followed by that we will learn linked list in data structures then the types of linked lists that are singly linked list doubly linked list and circular linked list and after that we will dive into stacks and data structures next after stacks we will learn queues and priority queues in data structures later we will learn how to dequeue elements from a queue data structure followed by queues and dqs we will learn three data structures and in three data structures we will understand tree traversal and later the types of trees that is binary tree binary search tree b plus tree etc followed by trees we will understand graphs and data structures next we will learn spanning trees and spanning tree implementation so these are all the data structures that we will be learning today now without further ado let's get started with the first topic that is introduction to data structures let's get started with the agenda for today's session first we look at the definition of data structures after that we will understand why we need data structures later we will discuss the different types of data structures finally we will look at the importance of data structures hope i made myself clear with the agenda now let's get started with our first concept that is what are data structures data is an information that has been translated into a form that is efficient to movement or processing in computing as it relates to trades computers and transmission media data is an information that has been converted into binary digital form the term raw data refers to the data in its most basic digital format after defining data let's look at what data structure entails a data structure is a data organization management and storage format in computer science that allows for efficient access and modification or a data structure is an algebraic structure about data that contains a collection of data values their relationships and their functions or operations that can be applied to the data we will now understand why exactly we need data structures now that we have already defined what is a data structure so let us have a look at some of the data structure characteristics the first one is each data structure allows data to be stored differently following that the data structure allows for more efficient data search and retrieval then specific data structures are chosen to solve specific problems last but not the least it enables the management of large amounts of data such as large databases and indexing services such as hash tables let us now look at some real-world examples of data structures first and the foremost we have the dictionary assume that we are looking for the word simply learn in the dictionary and we know it begins with the letter s so we can search for this word beginning with the letter s and then this is an example of array data structure as a result this dictionary can also function like an array data structure following by that we have a music player example if you have a playlist with three songs the second song will play after the first and the third will play after the second so these will be played without any interruption because all these three songs are linked with each other using linkless type of data structure so followed by linked list the next example we have is the data structures the stack of books analogy is a perfect example of the real-time working of the stacked data structure subsequent to that assume there is a line of people at a ticket window and the person who comes first gets the ticket this particular movie window queue is an example for the real time implementation of queue data structure last but not the least google maps google map is the graph data structure in which all the cities and states are connected if we want to go from one place to another there may be many ways to do so so we can use some algorithms to find the shortest path as a result the google map is a perfect example for the graph data structure working analogy following that we will look at some different types of data structures in this tutorial so the first type is the linear data structure the elements in the linear data structure are arranged subsequently one after the other they are simple to implement because the elements are arranged in specific order followed by the first type the second type is the non-linear data structure which we will be discussing a bit later so in linear data structures we have four different types the first one is the array data structure memory elements are arranged in a continuous order in arrays and arrays elements are of same type the software program also determines the type of elements that can be stored in arrays so followed by arrays we have linked list link lists are completely similar to data structures data elements in linked list data structure are linked together by a series of nodes furthermore each node contains the data items as well as the address to the next node the third data structure is the stack data structure elements in a stack data structure are stored using lifo principle in other words the last element stored in the stack is remote first in stack operations can only be performed in one end namely the top and the last data structure is the queue data structure unlike stack queue data structure operates in the fifo principle which states that the first element stored in the queue is remote first in a queue insertion and deletion are carried out from opposite ends now we will discuss the second type of data structures which are the non-linear data structures the non-linear data structure is the second type of data structure non-linear data structures do not have elements in any order as opposed to the linear data structures instead they are arranged in hierarchical order with one element connected to one or more others so the first one in the non-linear data structures is the tree data structure a tree data structure is built using nodes and edges each element in the tree data structure is called as node or vertex each vertex or node is connected to the other nodes or other vertices using edges and the second one in the list is the graph data structure a graph data structure is completely like a tree data structure it also has the vertices and edges each vertex in a graph data structure is connected using edges the only difference between a tree and graph is that in tree you can have n number of vertices but in graph you will have only two vertices after discussing the graph data structure we will move ahead into the last segment of this tutorial that is importance of data structures so the first one data structures are widely used in almost every aspect of computer science both for simple and complex computations next data structures are used in all areas of computer science including artificial intelligence graphics big data operating systems and much more after that the data structures are an essential component of many computer algorithms because they allow programmers to manage data efficiently lastly a proper data structure of selection can improve the efficiency of a computer program or algorithm introduction to time complexity the time complexity of an algorithm is the amount of time it takes to run as a function of the length of that input the length of the input determines how many operation the algorithm will do it will provide the information about the variance increase or decrease in execution time as the number of operations in an algorithm increases or decreases next up types of time complexity we will start with the constant time complexity then we will discuss linear logarithmic quadratic time complexity now let's have a look at them in the detail first constant time complexity when an algorithm is not reliant on the input size n it is set to have constant time of order bigger of 1. the runtime will always be the same regardless of the input as you can see in the code every line has the runtime of 1 and they are all independent of any input size so the runtime is always constant next up linear time complexity when an algorithm's running time increases linearly with the length of in the input it is said to have linear time complexity when a function checks all the values in an input data set it is said to have the time complexity of order of big o of n as you can see in the code the loop depends on the size n so the time complexity rose up to n next up logarithmic time complexity when an algorithm lowers the input data in each step then it is said to have the logarithmic time complexity binary trees or binary search functions are some of the algorithms with logarithmic time complexity as you can see in this code by finding out the mid in every iteration the runtime will decrease every step making it approximately logarithmic runtime next up quadratic time complexity when the execution time of algorithm rises non-linearly up to n square with the length of the input it is said to have quadratic time complexity in general net nested loops falls into the quadratic time complexity order where one loop takes big o of n and if the function contains the loop inside the loop then it multiplies as you can see in this code because of the nested loops the time complexity rose to n square now that you have the firm grasp of time complexity and its type we will discuss essential steps to evaluate the time complexity to understand this we will take an example of fibonacci number this code prints the fibonacci numbers till n we will divide this code into three parts isolating all the loops that play a significant role in altering the time complexity let's look at the first part it consists of some independent statement which gave constraint time for each statement next let's move on to our next part that is for loop since this loop runs n times this will give linear time complexity on n next up the third part which also has the constant time complexity now let's take a total of runtime which comes out to be n plus 5 we will then discard the constant part to find the time complexity which does not affect the overall time complexity now we will have the final time complexity of bigger of n we have now discussed time complexity and how to evaluate it now let's have a look at the time complexity of various algorithm we will look at the time complexity of insertion sort merge sort quick sort bubble sort and some searching algorithms like linear search and binary search let's look at them in the detail first up insertion sort as you can see in this code we are using nested loops so in worst case its complexity comes out to be n square now in the best case scenario the complexity will be linear time complexity next up merge sort in this case whether it is the worst case or the best case it will always remain and login as every statement in this code will run the same amount so no matter what its time complexity will remain the same next up quick sort the time complexity of quick sort in the best case is n login n and in the worst case it is answer next up bubble sort as you can see in this code we are using nested loops so in the worst case its complexity comes out to be n square now in the best case scenario the time complexity will become the linear time complexity that is n and after that we will discuss some of the searching algorithms first up linear search in the best case scenario if the statement to be searched is at the first position then the time complexity will come out to be constant whereas in the worst case the time complexity will come out to be n finally binary search in the best case scenario if the element is to be searched is at the mid then the time complexity will come out to be the constant whereas in the worst case scenario the time complexity will come out to be big of log n we have now discussed the time complexity and how to evaluate and the time complexity of various algorithm now let's sum up what we have learned from this session first up the execution time increases with the types of operations we make using the inputs next up the lesser the time complexity the faster is the execution finally if a code is of hundreds of lines then it takes a toll on the pc's processor so it is essential to check and reduce the time complexity as much as we can let's get started with what are pointers a pointer is a variable that points to an address of another variable it is declared using a star symbol also called asterisk and then we allocate a memory of a variable to it we can access a variable's address using the ampersand symbol in the same manner as the pointer declaration let's write a code we will declare a variable a is equals to 5 and a pointer ptr then we will assign this variable a's value to pointer ptr now let's write a print statement to directly access the variable's value using variable name let's write another print statement to print the value of a using pointer let's try and execute this program as you can see we have successfully accessed variables value using both variable name and pointers let's get back to our slides now let's discuss different types of pointers first up null pointer void pointer while pointer and dangling pointer let's discuss these in details first up null pointer it is a kind of pointer that points to a null memory as you can see in the figure here is a pointer which is pointing to a null memory to get a better understanding let's try a simple program in the code editor let's write a code first we will declare a pointer where then we will assign its value to null now let's try to print the statement let's execute this as you can see since this pointer points to a null or nothing that's why it doesn't print anything let's get back to our slides next void pointer when a pointer is created with data type void then this pointer is called void pointer if we want to print the variable's value then we have to typecast this pointer to avoid any error for better understanding let's get back to the code editor and try it with a simple code first we will declare an integer variable a is equals to 5 and avoid pointer ptr now we will assign address of a to pointer ptr let's write a print statement to print this pointer let's run this program as you can see we are getting an error that's because we can't print a void variable in this we have to typecast this variable to integer let's do this we can typecast a variable like this now let's print this as you can see we can print it now let's get back to our slides next while pointer when we create a pointer but don't initialize it by assigning any memory to it then this kind of pointer is called while pointer these pointers can be very tricky they can even cause a program failure or a segmentation fault let's get back to the correlator and try it with a simple code first let's declare a pointer ptr but they will not assign it with any address let's write a print statement to print it this time we will directly print it let's execute this as you can see we are not getting any results because there is no value assigned to it sometimes it may even show segmentation error let's get back to our slides next dangling pointer let's suppose there is a pointer p which is pointing at a variable now if we deal locate this memory using a free function then this pointer will point at a free space or a non-existing memory then this pointer will become a dangling pointer to get a better understanding of this pointer let's try it with a simple code let's declare a pointer ptr here we will dynamically allocate memory using a mail of function to do this we will put int star in a bracket then dialog function and in another bracket we will put memory size to be allocated now let's declare a variable a and assign its address to the pointer now to make it a dangling pointer we have to de-allocate the memory of this pointer we will use free function for that now let's write a print statement to print this pointer let's execute it as you can see since we have diallocated its memory that's why it is pointing to nothing hence it doesn't print anything let's get back to our slides till now we have discussed pointers ways to access variables and types of pointers now let's talk about use cases of pointers we will talk about point to arithmetics pointer to pointer array of pointers call by value and call by reference now let's dive right into it let's talk about point to arithmetics we can use four arithmetic operations on pointers increment decrement addition or subtraction of an integer from a pointer since pointer operates on addresses it only makes sense if we apply pointer arithmetics on sequential data structures like arrays or strings let's discuss them in detail first up increment if we apply this operator on a pointer then it will shift this pointer's address to its sequential successor as you can see in the figure as we increment the pointer's value we shift to the next index of the array let's get back to the code editor and try it with a simple program let's declare an array of size 3. let's give them some value we will then declare a pointer and assign it to the arrays first element now let's write a for loop to traverse this array in this for loop we will increment a pointer's value and print this pointer's value to traverse this array let's try and execute this program as you can see we have traversed this complete error let's get back to our slides next decrement if this operator is applied on a pointer it will shift this pointer's address to its sequential predecessor as you can see in the figure as we decrement this pointer we also shift to arrays previous index let's get back to the code editor and try to implement it let's declare an array of size 3 and assign it some values now let's declare a pointer and assign arrays last elements address to it now let's write a for loop to traverse this array in this for loop we will decrement the pointers value also we will keep printing this pointer's value to travel this array let's try and execute this program as you can see we have traversed this complete array from the back let's get back to our slides next the addition of an integer to a pointer if this operator is applied on a pointer it will leak forward accordingly if the integer is 2 and our pointer points at the first element then the pointer will sequentially skip one element and shift to the next element let's implement it in the code editor let's declare an array of size 7. and assign them some value then declare a pointer and assign it to the array's first element now let's take an integer n to add in the pointer now let's write a for loop to traverse this array in this folder we will increment the pointer's value with integer n and we will keep printing the pointer ptr value let's execute this code as you can see we have traversed this complete array skipping one element at a time since we have skipped three elements that's why we are getting last three values as garbage values let's get back to our slides next subtraction of an integer from a pointer if this operator is applied on a pointer then accordingly it will leap backward if the integer is 2 and our pointer points at the last element then the pointer will skip one element and shift to the previous element let's try and implement it in the code editor first let's declare an array of size 7. and assign it some values then declare a pointer ptr and assign it to the array's last element now let's take an integer n to subtract from the pointer now let's write a for loop to traverse this array [Music] in this for loop we will decrement the pointer's value with integer n also we will write and print statement to print this ptr's value now let's try and execute this program as you can see we have traversed this complete array from back skipping one element at a time since we have skipped three elements that's why we are getting last three values as garbage values let's get back to our slides let's talk about precedence of these operators operator asterisk and ampersand have the same priority as the unary operator increment and decrement these operators are evaluated from right to left let's understand this concept with an example suppose if a pointer p points to a variable x then we can swap x with pointer p in that expression in the first row we have y is equal to x plus 1 which means we are storing an incremented value of x in y similarly if we replace x with a pointer p we can store incremented value of pointer in y in row 2 and row 3 we are incrementing x and storing incremented value in x itself we can do this with pointers as well in row 4 we are attempting to execute pre-increment with a pointer p in row 5 we are attempting to execute post increment with pointer p here we have to put star p in braces because these operators are evaluated from right to left so to give more priority to pointer p we have to use braces as they have highest priority let's talk about another use case pointer to pointer basically in this situation a pointer will point at a variable via another pointer we declare it with two statistic symbol let's discuss it with an example suppose a pointer 1 points to a variable and another pointer 2 points to that pointer 1 this way pointer 2 will indirectly be pointing to the variable let's go to the code editor and try implementing it first we will declare a variable where a pointer ptr1 and a pointer to this pointer ptr2 then we will assign this variable vars address to ptr1 and ptr1s address to ptr2 now we will write a print statement to print variable var ptr1 and ptr2 now let's try and execute this program as you can see ptr1 and ptr2 shows variable vars value as ptr2 is pointing to ptr1 and ptr1 is pointing to that variable so indirectly ptr2 points to the variable var thus it prints the variable's value let's get back to our slides let's discuss the array of pointers as the name suggests it is an array that has all its elements as pointers these pointers can be pointing at another array it is declared as an array with asterisk symbol let's discuss it with the program first we will declare an array a of size 3. then we will declare a pointer array ptr of size 3. now we will write a for loop to assign a's elements address to ptr's element then we will write another for loop to traverse ptr and print its element foreign let's try and execute this program as you can see it prints the value of arraya's elements because error ptrs elements are pointing to arrays elements let's get back to our slides next call by value we don't use pointers in this concept but it is very important to understand this concept to get better understanding of the next topic call by reference in call by value we call a function and directly pass the variable's value as parameters in this situation a copy of those variable is created and get passed into a function as parameters if we modify these parameters it will not affect actual variables rather these copies will get deleted as soon as the function body ends let's try implementing it in the code editor let's write a code first we will declare a variable x equals to hundred then we will write a function called to function func with argument x next we will write a print statement to check if any changes happen due to the function now let's write definition for this function we will take a void function with argument as x in this first we will set x equals to 200 and then we will write a print statement to print this value let's try and execute this program as you can see here when we get back to the main block from function its value again reverted back to 10 because in call by value program we only pass variables copy into the function not the actual variables let's get back to our slides next call by reference in this if we call a function but this time we pass the variables address as parameters then in this situation actual variables will get passed into the function as parameters if we modify these parameters it will modify the actual variables even outside the function scope let's try implementing it in the code editor first we will declare a variable int x equals to 100 next we will write a function call for function func with argument as address of x then we will write a print statement to check if any changes happen due to the function now let's write definition for this function it will be a void function with argument as pointer x in this we will first set x equals to 200 then we will write a print statement to print this value of x now let's try and execute this program as you can see this time variable access value didn't revert to hundred that's because in call by reference we pass actual variables address two functions so it will modify them as well let's get back to our slides during the course of this video we have learnt a lot about pointers let's discuss some advantages of the pointers first up pointers are useful to access a memory location pointers are also an effective way to access the array elements pointers are used for the dynamic memory allocation and its distribution pointers are also used to build complex data structures like linked list graph tree stack queue etc now let's talk about some disadvantages as well first up pointers are difficult to understand so a programmer needs to be careful while handling them they might raise some errors like segmentation error or access some unrequired memory and cause program failure if a pointer is pointing to an incorrect value then it might corrupt memory pointers may also cause memory leakage also pointers are slower than variables at last let's sum up what we have learned in this session with key takeaways first up a pointer is simply a storage location for a data in a memory we can use pointers to traverse array more efficiently we can also use function pointers to call a function dynamically we can perform arithmetic operations on pointers as well when we define an array of pointers its elements can also points to function making it easier to call different function at once why did we actually need an array so to understand this let's go through a simple concept let us imagine that we have some data and the data is related to students right so if we wanted to store the marks of individual students then we had to declare a variable for each of the student so you can see we have student 1 student 2 student 3 4 and 5 and their individual scores so the score 1 is assigned to student 1 and so on with student 5 being assigned to score 5. so in the real time this might be a little clumsy we have here just five students so that is okay but what if we had 500 students or 5 000 students right that might be an issue there we have to create some 500 or 5 000 variables and it would be a little tough to handle that right even if we wanted to apply some operations collectively on all the variables that might be a little tedious so what if we had one variable which could store all the 5 students or 500 students or 5 000 students all together and make it really easy for us to apply some operations collectively on all the students right this sounds a little bit logical so similarly we do have a data structure which can do that which can collectively store all the data elements in it as a single variable and it will also help us to apply the operations which are logical or mathematical on all the variables and their values together as a whole so that is the purpose why we had created arrays that is the purpose why we needed arrays so far we have understood what was the necessity for aries now we will understand what exactly are arrays so basically an array is a linear data structure that stores the elements in a sequential manner one after the other and when you declare an array the variables will be stored one besides the other that is adjacent to each other in a sequential order now let us understand how the array is represented by the compiler now the next part that is the memory representation of aries now let us imagine that we have declared an array which stores character type data and another important point to remember about r is when you declare an array it stores only a single data type typed elements only for example here we have declared a character type array right so we cannot store integer type data or flow type data in it we only have to save character type array or character type elements in this particular array so now let us imagine that we have created an array which is of character data type and these are the elements which are a r r a y now how does the compiler represent it in the form of memory so when you create an array these are formed that is the index values and the address so basically compiler will select a block of memory and it has addresses to that block and it can be anything right here we have 11 12 13 14 and 15 and in real time it might be a thousand one thousand two thousand three thousand four thousand five the main motto is assign a sequential block of memory and this is the array and the elements are a r r a y and this particular one which is the last one is the index of the array that is the position of the array for user so using this index you can access the elements in the array more on that in the accessing part so let us imagine that we wanted to access the element r so how to access it we might not know the address right in that instance we will use the index this is for our reference so we will tell i want the element from array index number 2 and then we'll have the ar r element so in the practical form this is how we use the index now let's continue with the lower bound and the upper bound so the first initial location is called as the lower bound and at the last or the max value of the array is called as the upper bound now let us jump into the next topic where we will understand the different types of arrays so these are the different types of arrays one dimensional arrays and multi-dimensional arrays in multi-dimensional arrays we have two more types that is two dimensional arrays and three dimensional arrays so how are arrays different from each other right so the first one will deal with the first one that is the one dimensional array now how is an array declared as one dimensional for that we need subscript so one dimensional array requires only one subscript to specify the number of elements in an array so how is it actually represented so here you can see an example right on my screen so here is how a one dimensional array looks like so here we have the data type that is integer data type and marks is the name of the array and this is the size of the array and here the elements will be stored and here it is the index value of the array and remember the index value of array always starts from zero in the previous example that was only for basic understanding so i just started that with one in the practical way the array index always starts from zero so followed by the one dimensional array we will deal with the multi-dimensional arrays in that we have the following the first one is the two-dimensional array and the second one is the three-dimensional array in the multi-dimensional arrays we require more than one subscript in the previous example we had one dimensional array so the subscript is just one that is ten columns right so we just had one single row and ten different columns but in the multi-dimensional arrays we need multiple rows and multiple columns right so we need two subscripts for two dimensional array and more than two subscripts for three dimensional arrays so first we have the two dimensional arrays the 2d array is organized in the form of a matrix which can be represented as a collection of rows and columns so here is the example as you can see on my screen we have three columns and three rows and we have two subscripts that define the number of rows and the number of columns and the elements in each and every row so the one two three confines the first row four five six confines the second row and 7 8 9 will be the third row now similarly we have three dimensional arrays a 3d array is a collection of 2d arrays which consists of three subscripts block size row size and column size so here we have an example for that so we have three subscripts that is the first one is block size the second one is the row number and the third one is column number so this happens to be the first block this happens to be the second block and this is how a three-dimensional array can be represented now we have the next stage where we will understand how to declare the arrays and the syntax is right on my screen you need to specify the data type of the array which is integer float or character any selection which you make followed by that you need to select an array name for your array and inside that you need to declare the array size and sometimes you can also eliminate the array size if you wanted to you know have a dynamic array and here is an example for that you have integer data type name of the array is example and the array size is 6. so the compiler will allocate continuous memory block of 6 integer type blocks so these are the few more methods to initialize the array so here you can see integer data type array name is a element size is five and we have five elements the method two is remember i have said you can eliminate the size of the array right so here you can use this way as well integer data type array name a and no size here and you can directly declare the elements and the method third so here you have the name of the array size of the array and you are allocating the elements to the individual memory locations there is also another method to initialize array and method for is using a forum you can just initialize a for loop and the i value will be stored in the array locations starting from 0. now let us understand how to access the elements in an array so to access the elements in an array you need to specify the name of the array and memory block where you have that element that you want to access so here we have an example which is integer data type name of the array is x y z and the element we wanted to access is 5 so here we have an example that is integer type array array name is xyz and it has the size 5. and now we wanted to access the first element in an array that can be done using the first index that is x y z of zero index that is the first element and accessing the second element and so on x y z top one will be the second element x y set of two three four will be the third and fourth and fifth elements now let us understand some basic operations that can be performed on the array elements so the following are the operations that can be performed on the array elements that is the traversal insertion deletion searching and sorting now let us get into practical mode and try to execute some examples based on traversal of the array insertion of an element into the array deletion of an element from an array searching for an element in an array and sorting the complete array so at first we'll carry out the traversal operation so here we have an array that is a of 5 and the elements are 1 2 3 4 and 5. now we're going to use a for loop to traverse through this array and print all the elements sequentially now let us execute this code and see the output so as you can see the code got successfully executed and the elements that is 1 2 3 4 and 5 from the array a are printed sequentially now moving ahead we'll try to execute some examples based on insertion of element into the array so on my screen you can see an example for inserting an element into the array at the starting position of the array now let us try to execute this code and see the output don't worry about the codes these code documents will be attached in the description box below and you will be able to have an access to it and run these codes in your personal laptop and get a better learning experience now you can see the code got successfully executed and now it is asking for the size of the array let's declare it as 5 and now let's enter the elements into the array now it is asking for the element to be added at the beginning of the array now we have 2 3 4 5 and 6 existing in the array let's add the first element 1 and there you go the resultant array is 1 2 3 4 5 and 6. the element which we added at the ending which is one is supposed to be in the first or the beginning part of the array which is here at at the first index location as planned now let's get started with another example on the insertion now let's try to insert an element at any given location as per the user's choice so as you can see we have a program on my screen and running this program must help us to insert an element into any given location of the array now let's try to quickly run this program and see the output so there you go enter the elements into the array let's enter 1 3 let's try to run this program and see the output so there you go the program got successfully executed and now the output is asking for us to tell it the number of elements in an array now let's say four elements so now let's enter the four elements one three four five and six okay so the four elements which is one three four five are been inserted now it is asking for the location where you want to insert the element now let us insert it in this second location now let us set the value as two and there you go the resultant array is one two three four and 5 and the element which is 2 was supposed to be added in the second location and it has been successfully added now let's try to execute another example based on insertion where you will try to insert the element in the last position now this program on my screen will help us to add an element at the end of the array let's quickly run this program now it is asking for us to enter the five elements of the array let's enter that now it is asking to enter the element to be inserted now let us enter the element and this element should be added at the end location as discussed the resultant array is one three five seven nine and eleven now let's continue with the deletion operation now the program on my screen is an example for deleting an element from the beginning position of an array now the program got successfully executed and it's asking for us to enter the size of the array let's enter the size as 5 and now let's enter the elements of the array that is 1 2 3 4 and 5. now the element from the first location that is 1 has been deleted and the resultant array is 2 3 4 and 5. now the code on my screen will help you to eliminate the element from the ending location of an array now let's try to quickly run this program and say the object so you can see that the program is successfully run and it is asking for us to enter the size of the array let's enter 4. now let's enter the elements of the array that is 1 2 3 and 4. now after eliminating the last element from the array that is 4 we have the resultant array that is 1 2 and 3. now a little hover for you guys let's try to execute an example for deleting an element from any location of an array this will be a homework now don't worry try on your own and if you don't get that you can refer to the comment sections below where you have the code document attached in the description box and you can refer to it now let's continue with the next operation where we will search for a given element in the array so you can see that on my screen we have an example which will help us to sort the elements in an array let's quickly run this so there you go the program got successfully executed and now it's asking for the array size let's enter five and now let's enter the elements in a random order [Music] now the resultant array should be sorted so there you go the array after being sort is it's 2 3 5 14 and 21 so there you go the array got sorted so now we have finished our practical session let's have a quick overview again so traversal in an array is a process of visiting each element once traversal can be done by various means that is by counting the array elements printing the values sorted in the arrays and sum of all elements present in the array and many more so this is how we traverse our array from the first location to the last location again the insertion operation insertion in an array is the process of including one or more elements in an array and it can be done at the beginning at the end and at any given index of an array which we executed for all the three types of examples now next we have the deletion operation so deletion operation or deletion of an element is a process of removing a desired element and reorganizing the array and it can be done at the beginning at the end and at any given index so we have executed the example for at the beginning and at the end and the homework was at the given index don't worry if you don't figure it out you can always refer to the example document which is mentioned in the description box below now the search operation searching is a process of finding a given value in the list of values and it decides whether the search key is present in the array or not and we have executed an example on that and again the sort operation where we will sort the given array if the given array is not in the default order or in a given order that is ascending or descending then we can sort the order of the array by the user's choice given it is ascending order or descending order now in the next section of the tutorial we will discuss the advantages of using arrays so the first one is array stores multiple elements of same data type with same name next one elements in an array can be accessed randomly using just the index number array memory is predefined so there is no extra memory loss array avoids memory overflow and finally 2d arrays can represent the tabular form of data in a very efficient way now let us also have a look on some of the disadvantages of using arrays the first one the number of elements in an array should be always predefined so there is no chance that you can add some extra element in the last moment array is static in nature so its size cannot be varied after declaration what if consider that you wanted to store 10 student data in one array and you end up having just seven students so the remaining three is a waste right so you are wasting memory there that's the problem and insertion and deletion operations in an array is quite difficult as the array stores elements in a continuous form and finally allocating excess memory then required mainly to memory wastage now we have the final key takeaways of the arrays so we discussed why do we need arrays then we discussed what are arrays followed by that we discussed types of arrays next we had a declaration of arrays accessing elements from an array initializing the arrays and basic operations on array that is the practical demo part and finally we have discussed the advantages and disadvantages of using an array what are arrays so we will see a brief definition of arrays the array is a data structure that stores elements of the same data type in a sequential order two dimensional arrays are considered as an array of arrays two-dimensional arrays represent the information in the form of rows and columns which is completely similar to a tabular form of data following by the definition and briefing of the two dimensional arrays we will understand the need for two dimensional arrays so the main advantage of using a two dimensional array is the elements can be represented in the form of a matrix that is rows and columns using two-dimensional arrays we can initialize access and print multiple elements in the matrix form by just running one single quote segment you can see an example right on my screen here this is an example of marks list suppose a class has three subjects namely english science and maths we have four students and we wanted to represent the data in the form of a database so here the marks of the four students can be represented using two dimensional arrays now we will see the syntax of a two-dimensional array so here the syntax at first we need the data type the data type can be integer character float string etc then we have the name for the two-dimensional array and later we can have two subscripts which represent two dimensions that is the rows and columns the first subscript defines the number of rows and the second subscript defines the number of columns and note that the column number can never be null at the end we have a semicolon to terminate the syntax and here we have some examples of two dimensional arrays so in the first example we have the name of the two dimensional array and we have three rows and four columns and followed by that we have another example which is of character data type and the name of the array is names and we have 7 rows and 15 columns next we will see how to visualize two dimensional arrays we read earlier that two-dimensional arrays are a collection of rows and columns let's see an example of two dimensional array we will consider an array with six rows and four columns as you can see on my screen we have integer type array and the name of the array is array and we have six rows and four columns the product of rows and columns will give us the total number of elements present in a two dimensional array in the current example we have 6 rows and 4 columns and the product is 24 so we must have 24 elements in this array next we will see how to initialize two dimensional arrays so there are two ways to initialize a two-dimensional array so in the first method we declare the elements in the set of curly brackets this array consists of three rows and three columns note that the index always starts from zero here we have three rows it means the row starts with zero and ends with two the same goes for the column but sometimes this method might be a little confusing so we have a better method the advantage of this method is clarity we can visualize all the elements with better clarity compared to the previous method so the first three elements are 9 six and one they are present in the first row and in the second row we have 144 70 and 50. they comprise the second row and finally the third row in which the elements are 10 12 and 78 so far we have learned how to visualize and initialize a two dimensional array so we have done it by using the index values that is the row index and the column index so the row index value was three and the column index value was three for accessing an element in the two-dimensional array we need to pass the name of the two-dimensional array followed by the row index value and the column index value for example let us assume that we wanted to access the element 9 for doing so we will pass the name of the array followed by the row index value and the column index value as shown below that is end first zero comma zero and an important point here is indexing always starts with zero we will now start printing the two dimensional arrays so to print a two-dimensional array we will be using two nested for loops so to understand the process of printing the two-dimensional array let's get back to the practical mode and we will work on a code so on my screen you can see an example for two-dimensional adding so here we have declared an array with the name first and we have three rows and three columns and inside that the first row of elements is 961 and the second row of elements is 144 70 and 50 and the third row of elements is 10 12 and 78 followed by that we have two counter variables which are i and j so we are using the first counter variable i in the order for loop and the second counter variable j in the second in the form and inside the inner follow we have a print statement which is used to print the elements in the array now let us try to execute this code and see the output so you can see the code got successfully compiled and we have our elements here which is 961 144 70 50 10 12 and 78 now let us understand the logic so here we have declared the counter variable as 0 and the condition is i should be less than 3 which is true so the control will enter into the second inner for loop here we have j is equals to 0 and j should be less than 3 which is true so here the condition or the statement is valid and it will print the first element 9. followed by that j will be incremented again j is now equals to 1 and j is less than 3 so again we'll print the second element 6. again j value will be incremented to 2 so 2 is less than 3 then we will print the third element that is 1. now when you increment the value of j from 2 to 3 the condition will fail because 3 cannot be less than 3 so the control will enter into the outer for loop here we have i value is equals to 0 which will be incremented to 1. so 1 is less than 3 again the control will enter the inner follow here again we will check for j is equals to 0 which is true so we will print the second row of elements that is 144 70 50 in the same way how we printed the first row right so j will be equals to 0 so then we'll print the first element so j will be incremented to 1 and 1 is less than 3 then we will print the second element that is 17 and again j will be incremented to 2 and 2 is less than 3 so we will print the third element that is 50 in the second row and again j will be incremented to three now the compilation of the condition will result in false so it will exit the second follow-up and but it will come back to the first outer for loop now the value of i will be incremented to 2 so 2 is less than 3 the control will enter into the inner for loop again then we will print the third row of elements that is 10 12 and 78 in the same way how we printed the first row and the second row after printing the third row the condition will fail when j value is incremented to 3 and it will enter the order for loop here the i value will be incremented again from 2 to 3 and the condition fails now the overall control will come out of both the for loops and it will terminate here so that's how we got 9 6 1 44 70 50 10 12 and 78 so with that we have come to the conclusion and so far we have learned the following things what are two dimensional arrays why we need two dimensional arrays syntax of 2d arrays visualizing 2d arrays initializing 2d arrays accessing 2d elements and finally print the elements of two dimensional arrays let's get started with what is linked list a linked list is a linear data structure made up of nodes these nodes consist of two parts data and reference to another pointer typically a linked list starts with a head node which goes all the way up to the last node which is called tail next let's discuss why do we need linked list a linked list is a linear data structure like arrays but an array can only offer a fixed size whereas a linked list can dynamically increase its size also operations like insertion and deletion are much easier in a linked list than in an array now let's try to implement the linked list in the code editor let's start by creating a node to create a node we need a class let's declare a class node we will declare its member as public the first member is end data and the second member is node pointer next now we will go into the main block and initialize our first node to initialize a node we need to use node star the node name had equals to similarly we will create more nodes and our last node now we will allocate these four nodes in the heap to do that we will use a node name equals to new node star new node braces now we will allocate all the nodes in the same manner now we will assign data to our first node to access the member of the node class we will use error formation then we will use data equals to let's give it a value as 2. now we will link this first node with our second node to do that we will use head same error formation and next which will be equals to our n1 node and now we have created our first complete node now let's create other nodes as well n1 arrow data is equals to let's give it three and one arrow next is equals to n2 and two arrow data is equals to five and to arrow next to arrow next is equals to tail now tail is equal still arrow data equals to seven and tail arrow next is given null now let's call up function to print this list we will give hat as the argument as we can only traverse a linked list from its head let's write a definition for this print list function this function will be a void function argument is node star a we will use while loop to traverse this linked list we will give it condition if a is not equals to null then see out yes a data and l now we will change our cursor from the current node to the next node to do that we will use a is goes to a arrow next now let's try to execute this code as you can see we have traversed our complete linked list now let's get back to our slides now let's discuss different types of linked list the first of single linked list next is the doubly linked list the circular linked list and finally we have the circular doubly linked list let's discuss each one of these in details first up single linked list it is a unidirectional linked list while using the sinclair link list we can only traverse it in one direction that is from head node to the tail node next up doubly linked list it is a bi-directional linked list we can traverse it in both the directions in this linked list the node has an additional pointer that points to the previous node next up circular linked list it is a regular linked list except for its last node points to the head node programmer needs to be careful while traversing it or they might get stuck in an infinite loop next up the circular doubly linked list it is a combination of doubly linked list and a circular linked list its last node points at the head node and the previous pointer of the head node points to the last node it is also bidirectional linked list so that we can traverse it in both directions we have now discussed the linked list why do we need linked lists and types of linked list now let's learn about some operation we can apply on linked list we can use majorly two operations on linked list first up insertion and deletion we can perform these operations in three different situations first at the beginning at the last or at a specific position after a node next we will discuss these operations in detail first up insertion we will discuss first session at the beginning we have to give the first notes address to the new nodes next pointer to execute this next up insertion at the end we have to give the new node's address to the last node's reference pointer next up in session at a specific position to do this we will have to change the reference address of the previous node to the new node's address and the new node's reference pointer to the next node's address now let's discuss deletion first up deletion at the beginning we have to change the first node's address to the null to execute this next up deletion at the end we have to change the second last node's address to the null next up deletion at a specific position we will change the reference address of the previous node to the next node's address we have learnt a lot about linked list during this session now let's discuss some benefits of linked list first up a linked list is a dynamic data structure that is we can dynamically increase its size next it offers easy insertion and deletion than other linear data structures like arrays and string since it can dynamically increase its size resulting in no memory base stage next it is pretty handy in implementing complex data structures like stacks and queues etc now let's talk about some disadvantages as well first up since the linked list is made up of nodes it takes extra storage for storing data and reference pointer next the traversal in the linked list is a bit harder than other data structure reverse traversing is easy in doubly and circular doubly linked list but since it uses one extra pointer it takes extra storage making it another limitation at last let's sum up what we have learned in this session with key takeaways first up we have recognized linked list as a dynamic data structure next a linked list offers faster insertion and deletion operation next linked list traversal is hard because we have to start from the head node every time finally a linked list is an asset in implementing other data structures like stacks and queues let's get started with introduction to single linked list a single linked list is a linear data structure made up of nodes these nodes consist of two parts data and reference to the another pointer these nodes can be traversed using pointers it starts from the head node all the way up to tail node now let's try to implement the singly linked list in the code editor start by creating a node to create a node we need a class let's declare a class node we will declare its member as public the first member is end data and the second member is node pointer next now we will go into the main block and initialize our first node to initialize a node we need to use node star the node name had equals to similarly we will create more nodes and at last repeat and our last node tail now we will allocate these four nodes in the heap to do that we will use a node name equals to new node star new node braces now we will allocate all the nodes in the same manner now we will assign data to our first node to access the member of the node class we will use error formation then we will use data equals to let's give it a value as 2. now we will link this first node with our second node to do that we will use head same error formation and next which will be equals to our n1 node and now we have created our first complete node now let's create other nodes as well n1 arrow data is equals to let's give it three and one arrow next is equals to n2 and two arrow data is equals to five and two arrow next to arrow next is equals to tail now tail is equal still arrow data equals to 7 and tail arrow next is given null now let's call up function to print this list we will give head as the argument as we can only traverse a linked list from its head let's write a definition for this print list function this function will be a void function argument is node star a we will use while loop to traverse this linked list we will give it it condition if a is not equals to null then c out is a data and l now we will change now we will change our cursor from the current node to the next node to do that we will use a is equals to a arrow next now let's try to execute this code as you can see we have traversed our complete linked list now let's get back to our slides we have now introduced the singly linked list now let's discuss some of the operations we can apply on a linked list first up insertion we can perform insertion at three different situations like at the beginning at the last or at a specific position after a node next up deletion similar to the insertion we can perform it in three different situation as well at the beginning at the last or at a specific position after a node let's talk about them in detail first up insertion at the beginning to execute this we have to give first node's address to the new node's next pointer next up insertion at the end to execute this we have to give new nodes address to the last node's next address next up insertion at a specific position to execute this we will change the previous node's reference address to the new node's address and the new nodes reference pointer to the next node address now let's try these operations in a code editor as you know a linked list is made up of node so we should start by creating a node to create a node we need a class node and we will define its members as public print data and node pointer next now we will create a function to insert a new node in front of the list for this function as an argument we will give the reference to the head of the list and integer dot new data in the definition we will allocate a node newnode equals to now we will put in the data in the new node we will use arrows to put to access the data equals to new now we will make the next of this new node as head now we will move the head to point to the new node now we will create another function to insert a node after a specific position as arguments we will give it the address to the previous node and the integer new data we will first check if the given previous node is null it is we will print given note and not and then we will return the function otherwise otherwise we will allocate a new node and then we will enter the new data now we will make the next of the new node as a next of the previous node and then we will move the next of the previous nodes as new node now we will write a function to insert a node at the end of the list as an argument we will give it a node pointer to pointer and integer new data we will first allocate a new node we will also create a last node and give it now we will put in the data in the new node since this new node is going to be the last node so we will make its next as null now if the linked list is empty then we'll make the new node as head to check that we will use if starhead is equals to equals to null if it is then we will do star head equals to new node else we will traverse it to the last node while last next not null last is equals to fast next now we will change the next of the last node as new node now we will write a function to print this list bye node is not null load arrow data and then and node equals to node now we will write the code for the main block first we will define a head node and mark it as null now we will start using those functions to make a linked list first we will use append function to add six in it next let's let's use another function push and add 7 in it now we will try to insert one at the beginning so we will use push again comma one now let's try to insert four at the end so far the list looks like one seven six four null now let's let's try to insert eight after seven to do that we will use insert after as argument we will use head next as 7 is present next to the head comma eight now let's try to print this linked list see out created then yes list add return let's execute this as you can see we have created the linked list in the correct order let's get back to our slides now let's talk about deletion first up deletion at the beginning to execute this we have to change first node's next address to null next up deletion at the end to execute this we have to change the second last node's address to the null next up deletion at the specific position we will change the previous node's reference address to the next node's address now let's try these operations in a code editor we will start by creating a class node in this class we will declare the members as public print data and the node pointer next now to insert the data in the node we will use a function push as argument we will give pointer to pointer node header and integer new data we will allocate a new node we will give this new node the data as new data and and new notes next as head now we will write a function to delete the node as argument we will give a node pointer to pointer head and end key now we will store head in a temp node and we will create a node as null if head node itself holds the key to be deleted we will use if amp is not equals to null and temp data is equal to equals to key then head equals to next now we will free the old node else we will search for the key to be deleted while amp is not equals to and temp data is not key so prev equals to temp and temp will be hydrated to its next if the key is not present in the linked list then we will just return the function else we will unlink the node from the linked list and delete now we will write a print list function to print the list its argument will be a node pointer node while a node is not null layout less than node data and we will iterate this node using node equals to node next now we will move on to the main block we will start with the empty list node star head equals to null now we will add the element to this list so push ampersand head comma 7 next push head comma 2 push next push ampersand add comma 9 now see out created test and list add now we will use delete node function delete two we will use argument as ampersand head comma 2 now we will check the linked list of two print tests let's try and execute this as you can see we have deleted the two from the linked list let's get back to our slides at last let's sum up what we have learnt in this session first up we have recognized singly linked list as dynamic data structure next up the single link lists offer faster insertion and deletion operation next single linked lists are unidirectional linked list that is you can only traverse it in one direction finally a single linked list is an asset in implementing other data structures like stacks and queues let's get started with an introduction to double a link list a w link list is a linear data structure made up of nodes this linked list is a bi-directional linked list that is we can traverse it in both direction these nodes consist of three parts first up data reference to the next node and reference to the previous node now let's try to implement the doubly linked list in the code editor as you know a linked list is made up of nodes so we will start by creating a node to create a node we need a class node its members should be defined as public hint data node pointer next and node pointer now we will write a function to insert a node at the beginning of the doubly linked list void push argument will be a node pointer to pointer add and end new data now let's allocate a node node star new node equals new node now let's put in the data into the new node since we are adding at the beginning its previous is always null now we will link the old list of the new now we will change the previous of the head node to the new node we will check if head is not null then heads previous is equals to new node now let's move the head to the point to the new node now let's write a function to print the given double linked list its argument will be a node we will iterate it until the node is not null layout node data and and node equals to node next now let's write a code for the main block we will start with the empty list now we will use a push function to push values in the function another push function add comma 3 push function ampersand had comma 5 push function add comma seven now p out doubling and list then we will call the print list function in the double linked list let's execute this program as you can see we have successfully created our first doubly linked list let's get back to our slides we have now introduced doubly linked list now let's discuss some of the operations we can perform on a doubly linked list we can perform three operations on a doubly linked list first traversal insertion and deletion we can perform a traversal in two ways a normal traversal and reverse traversal and we can perform insertion and deletion in three different situations at the beginning at the last and at a specific position after a node let's discuss these in detail first up normal traversal we can traverse the doubly linked list using a next pointer starting from head to all the way up to tail node reverse traversal similar to the normal traversal we will use previous pointer we will start from the tail node to go all the way up to head node now let's try to traverse the doubly linked list in the code editor let's start by creating a class node will define its members as public print data node pointer next and node pointer pref now we will write a function to insert a node at the beginning of the way link list right push its argument will be a node pointer to pointer head and integer new data now we will allocate a node new node new node parenthesis now we will put in the data since we are adding at the beginning so its prep is always null now we will link the old node to the new node now we will change the previous of the head node to the new node now we will move the head to the point to the new node now we will write a function to traverse the linked list normally voip traverse node pointer while loop node is not null therefore data node equals to node next now we will write a function to reverse traverse it its argument will be a note pointer to pointer add we will create a note tail equals to head while next is not null this loop is enabling us to reach to the tail node so that we can traverse it from backside now while loop until tail is not equals to head layout data then goes to tail prep here data handle this last c out statement is only because we are not traversing till the head pointer now let's go to the main block let's start with an empty list node star head equals to null now let us create a linked list to test the function so we will use push function another push function ampersand head comma three since we are inserting at the beginning so the actual linked list looks like 7 5 3 now we will print the order linked list first see how original traverse and seals reverse traversal first traversed linked list and then now let's try and execute this program as you can see we have traversed it in the normal way as well as the reversed way let's get back to our slides next up insertion at the beginning we will create a node with the previous pointer pointing to a null and the next pointer pointing to the head node then we will change the head node's previous pointer to the new node and we will change the new node to the head node next up insertion at the end we have to give the new node's address to the last node's next pointer and change the new node's previous pointer to the last node next up insertion at a specific position we will change the previous node's next pointer to the new node and the new node's previous pointer to the previous node and the next pointer to the next node and vice versa now let's try these operations in a code editor we will start by creating a class node public pointer now we will write a function push insert a note at the beginning of the list its argument is note pointer to pointer head into new data we will first allocate a new node note star new node equals new node parenthesis now we will put in the data node arrow data is equals to new data now we will make the next of the new node as head and previous as null and new node previous is equals to null now we will change the previous of the head node to the new node first we will check if the head node is null then star head previous is equals to new node now i will move the head to the point to the new node now let's write another function to insert a node after a specific position void insert after its argument will be node data if we first check if the given previous node is null yes then we will give it c out given node we will return to the function or else we will allocate a new node let's do new now we will put in the data now we will make the next of the new node as the next of the previous node equals to ref node now i will make the next of the prep node as new node and make the prev node as the previous of the new node now i will change the previous of the new node's next node if new node next is not null then new node next rev is equals to new node now let's write another function insert a node at the end of the list void append its argument will be a node pointer to pointer head new data first we will allocate a new node equals to new parenthesis now we will create another node last equals to head now we will put in the data node data equals to new data now since this new node will be the last node so its next will be null and is equal to equation null and star head equals to new node return or else we will traverse till the last node file last next is not null last equals to last next now we will make the last node as the previous of the new node return now we will write a print list function to print this list the argument is a node pointer node while node is not null data or is equals to node next now let's write the main block we will start with an empty list we will start by inserting six so the link list becomes 6 null and ampersand head how much six now we will insert seven at the beginning push percent head comma seven now we will insert one at the beginning also now we will insert four at the end till now the link list looks like one seven six four now we will insert 8 after 7 so insert after head next comma eight now let's print this linked list let's try and execute this as you can see we have created our linked list in the correct order let's get back to our slide next up deletion first up deletion at the beginning we have to change the first nodes next to null and second nodes previous to null next up deletion at the end we have to change the second last node next pointer to null and delete the previous node to free up the space next up deletion at a specific position we will change the previous node's next pointer to the next node and next node's previous pointer to the previous node now let's try these operations in a code editor we will start by creating a class node click data node pointer next load pointer now we will write a function to delete a node in a doubly linked list void delete node its argument as pointer to the head repeat its argument as pointer to the head node pointer and pointer the node to be deleted now we will check the base case condition that is if add is or not to be deleted is null and return now if the node to be deleted is a head node then added is equals to now if next node of the dell partner that is if the node to be dedicated is not the last node then else next previous equals to else previous now we will change prev only if not to be related is not the first node so if not equals to null then next equals to del's next finally we will free the memory occupied by the dell free and now let's write a function to insert a node at the beginning of the wlink list void contour to the head node pointer and enter new data we will allocate the node now we will put in the data since we are adding at the beginning so prev is always null now we will link the old list of the new node now we will change the preview of the head node to the new node now we will move the head to the point to the new node now let's write print list function note pointer node while node is not equals to null c out data load goes to node next now let's get started with the main block we will start with the empty list now we will create new nodes push percent head comma 2 push ampersand add comma 4 push ampersand head comma 6 push 10 percent head comma 8 now let's print this list see out original list original list we will call the printlist function now we will delete the node from the doubly linked list here we are deleting the first node next let's delete the last node now the modified list should look like 4 8. let's try and print this c out defined list let's try and execute this as you can see we have deleted all the nodes except for 6 and 4. let's get back to our slides at last let's sum up what we have learned in this session first up we have recognized doubly linked list as dynamic data structures next the w link list offers faster insertion and deletion operation next up doubly linked lists are bi-directional linked list that is we can traverse it in both direction finally a doubly linked list is faster at reverse traversal let's get started with introduction to circular linked list a circular linked list is a linear data structure made up of nodes it is like a single linked list except its last node points at the head node these nodes consist of two parts data and reference to next pointer these nodes can be traversed using the next pointer now let's try to implement it in the code editor we will start by creating nodes to create a node we need a class node we will define its members as public link to data and node pointer next now let's write a function to insert a node at the beginning void push we will use arguments as a pointer to node pointer head and enter data we will define a node new node equals to new note parenthesis star head now we will put in the data into a new node since we are inserting at the beginning of the linked list that's why this new nodes next should be the head pointer if linked list is not null then set the next of the last node as head while next is not equals to head the temp is equals to temp arrow next now then next is equals to new node else new node is next to new node star head equals to newnode now let's write a function to print this linked list void list node star head node star temp is equals to head if add is not equals to null then do see out temp data now while amp is not equals to head this condition is important to stop this loop so that it doesn't go infinitely now let's go to the main block let's initialize this list as empty node star head equals to null now let's insert some nodes in this linked list push amp percent head comma to push ampersand push ampersand head comma 11 head now this linked list looks like 5 11. nine two then it will again go back to five now let's try to print this see out circular listed now let's try and execute this as you can see we have successfully created our first circular linked list let's get back to our slide we have now introduced the circular linked list now let's discuss some of the operations we can apply on a circular linked list we can perform two operations on a circular linked list first up insertion we can perform insertion at three different situation at the beginning at the last and at a specific position after a node next up deletion we can perform deletion at the three different situations first up at the beginning at the last and at a specific position after a node let's discuss these in detail first up insertion at the beginning we have to give the first notes address to the new node's next pointer to execute this next up insertion at the end we have to give new nodes address to the last node's reference pointer next up insertion at a specific position we will change the previous node's reference address to the new node's address and the new nodes reference pointer to the next node's address now let's try these operations in a code editor so far we have implemented a linked list using classes now let's try to implement it using structures we will start by creating a struct node with its element as int data and struct node next now we will write a function which can only insert a node to empty list struct node star add empty star last comma end new data now since this function is only for the empty list so we will have to check if the link list is empty or not if last is not equals to null then we will return last now let's create a node dynamically struct node start temp equals to struct node star malloc size of we will copy this statement because we will need it in the future functions we will assign the data to this new node temp data is equals to neutral data last is equals to temp now we will create the link to that we will use last next is equals to last since we are in an empty list so the first node will always point to itself return start node star we are creating a function to insert at the beginning of the linked list struct node star add again this argument we will use struct node last comma and data if last is equals to null then we will return empty last comma data now we will create a node dynamically i have already copied this statement for the ease now we will put in the data data is equal to data temp next is equals to last next last next is equals to return last now we will write a function to insert a node at the end start node star last data if last equals to equals to null and return add empty last comma data now we will dynamically create a node and put in the data temp data equals to next is equals to last next now last next equals to temp and last equals to return now we will write a function to insert a node after a specific node so struct node star add after start node star this item is a node after which we have to insert the node if last equals to equational then return structure p e is equals to last next now do [Music] if equals to we will dynamically create a node here temp is equals to structure load star lock size of now we will put in the data so temp data is equals to data temp next is equals to next a p next is equals to temp if e is equals to last last is equals to temp return equals to next while e is not equal to last text see out item not present in the list return last now we will write a function to print this list void print list struct node start lost now if last is equals to null then c out list is empty and return else we will point to the first node of the list so p is equals to last next to traverse the list we will use do while loop so do c out next while e is not equals to last text now let's write a code for the main block we will start with an empty list struct node star last supposed to none now last is equals to add empty last comma six last equals to add begin comma 4 last equals to add begin last comma two last equals to add and last comma 12. last equals to add after last comma 10 comma 4. list let's execute this as you can see we have created the linked list in the correct order let's get back to our slides now let's talk about deletion first up deletion at the beginning we have to change the first node's address to the null to execute this next up deletion at the end we have to change the second last node's address to null to execute this next up deletion at a specific position we will change the previous node's reference address to the next node's address now let's try these operations in the code editor let's get started with creating a node to create a node we need a class node we will declare its members as public and data node pointer next now we will write a function to insert a node at the beginning of the list void push a pointer to the node pointer header and new data now let's create a node and make head as next of it load star node equals to new node parenthesis let's put in the data new node data is equals to new data and new node next is equals to head if linked list is not null then set the next of the last node as the first node if star head is not null then they will find the node before head and update next to it so node star temp is equals to star head while and next is not equals to head is equals to tamp next now temp next equals to new node else new node next is equals to new node and star head is equals to new node now let's write a function to delete a given node from the list so void delete node its argument is a pointer to the node pointer add and end key now if linked list is empty then we will simply return it if star head is equal to null then return otherwise if and add next is equals to head then free add is equal to null return now node last is equals to star head comma star d now if head is to be deleted then star head data is equals to key then while next not equals to star head then last is equals to last next now we will point the last node to the second node of the list now we will free this head our head equals to last next now if either the node to be deleted is not found or the end of the list is not reached then while last next is not equals to head and last next data is not equal to key then last equals to last if note to be deleted was found then if last next data is equals to key then d is equals to last next and last next is equals to d is next now we will free d or else see out no such key found you now let's write a function to print this list void print list node star head node star temp is equals to head if head is not null do c out temp data amp is equals to next while temp is not equals to head see out now let's write a code for the main block we will start by empty list so note star head equals to null now we will push ampersand head push ampersand head comma 5 push ampersand head comma seven push ampersand head comma 8 and push ampersand head comma 10 now we will print the list before any deletion operation c out list before deletion list head now let's delete ampersand add let's delete seven see out list after deletion print list let's execute this as you can see our deletion function is working perfectly let's get back to our slides at last let's sum up what we have learnt in this session first up we have recognized circular linked list as dynamic data structures next the circular linked lists offer faster insertion and deletion operation next a circular linked list are unidirectional in nature that is we can only traverse it in one direction finally a circular linked list traversal is quite tricky as we have to stop the loop as soon as we revisit the first node otherwise it will traverse it indefinitely so at first what exactly is an array so an array is a linear data structure that stores homogeneous data elements in a continuous form so homogeneous in the sense you will be able to store only one single data type of elements in an array for example consider that you have declared an array and you wanted to store some elements in the array so you can declare a data type first after that the name of the array and if you declared that the array should store in teacher data type then you can only store integer elements in that particular data type you cannot store any other data type like float or character that is the meaning of this particular definition and it stores the elements in a continuous order that is in the adjacent format as you can see in the example here 10 20 30 40 and which are located in the adjacent locations that is 0 1 2 and 3. now let us understand what exactly is a linked list so similar to array even a linked list is a linear data structure but the only difference is it is a dynamic data structure here you can increase or decrease the size of the linked list in run time the only difference is here the memory locations are not adjacent to each other but they are taken from the memory heap so there is a huge memory chunk out of that the linked list will borrow some of the memory locations and one after the other the memory nodes will be interconnected using pointers so that was the difference between array and linked list and similar to arrays even the linked list store homogeneous type of elements that is if you declare a linked list of float data type then you can only store float data type in it you cannot store any other different data type like character or string now followed by that let us understand the types of arrays so basically we have three different types of arrays those are the one-dimensional arrays and inside multi-dimensional arrays we find two more types those are the two dimensional arrays and three dimensional arrays now one dimensional arrays will be having only one subscript that is where they'll be having only one single row whereas in the two dimensional arrays we will be having two subscripts that is it will be having rows and columns and in the three dimensional arrays it will be having three subscripts that is the row column and the block address now followed by the types of arrays we will understand the types of linked lists so similar to arrays even linked lists are divided into three types they are singly linked list doubly linked list and circular linked list the difference between them is a singly linked list will have two parts that is the node address and node element in this particular segment the element will be stored and in this particular second segment the address that points to the next node will be saved and similarly in the circular linked list the only difference between the singly linked list and the circular linked list is at the end of the single learning list we can see a null pointer which indicates the end of the linked list but in circular linked list the address will not be null instead it will point back to the head node that is what which makes it as a circular type dissingly linked list or a circular linked list when it comes to the third type that is the doubly linked list we can see there are two address locations the first starting node will have null as its first address location then we'll store the element and the second address location will point to the next node and you can see in the second node will have element and the first address location will point to the previous node and the second address location will point to the next node and at the end the second address location will be pointed as null which indicates as the end of the linked list now that we know the types of linked lists and arrays we will look into the fundamental differences between arrays and linked lists so the first fundamental differences between the arrays and linked list is the array element can be accessed randomly using just the index values but whereas random access is not possible in linked list if you want to access any element in linked list you need to perform the traverse operation sequentially the second difference between the both is array is static which means memory size is fixed which cannot be changed in runtime but whereas in the linked list the memory is dynamic which means you can either shrink or expand the memory in runtime according to your requirements followed by that the next difference is each element in array is independent in nature that is you can access any element just by giving the index location whereas in linked list the elements are interdependent on each other whenever you want to access a specific element you need to go through the other elements or traverse through the other elements next one is the array takes more time in operations like insertion and deletion whereas linked list takes less time to perform the operations of insertion and deletion followed by that the next difference is accessing any element is faster in array as random access as possible and the array data structure just by using its index values but whereas accessing an element in linked list is slow because we know that we need to traverse through all the node elements to access a particular element now the next difference is in case of an array memory allocation is done in compile time whereas in linked list the memory allocation is done during the run time memory utilization is inefficient in an array as it is allocated as in static and it is allocated during the compile time in case of linked list the memory utilization is very efficient as the memory is allocated during the runtime what is a stack so basically stack is a linear data structure just like arrays and linked lists the only difference is that it follows a specific order when an operation is implemented on it so what is the specific order that it follows that is lifo last in first out or failo first in last out in the next part we will understand this order in a much better way all operations can be done only at the one end of the stack that is on the top now we will discuss much about that in the operations part of the stack now let us understand the first fundamental that is the representation of stack that is how do you represent a stack normally so a stack can be represented using two different methods that is using an array or using a linked list so in an array we will be using the continuous memory and in stack we will be using a non-continuous memory and the stack will behave like a dynamic stack or a dynamic data structure now the first method that is the array method so in this method an array is used to represent the stack as you can see in the image below we have a stack so the name of the stack is stack itself and you can see two more things here that is top is equals to 2 and max is 4. so the max is the value of the array or the length of the array the maximum length of the array and top is the position where the last element of the stack is present here in this case 56 is the last element in the stack and top is inclined or it is addressing to that particular address that is two and now let us discuss about the linked list representation of stack so in this method a dynamic data structure that is a linked list is used to represent the stack this representation leads to a dynamic stack it does not need to define the maximum number of elements present in the stack remember in arrays we had to define the max value in the previous example we had the max value as 5 but in here you need not to assign the max value as the stack itself is dynamic the pointers links are used to store the address of the upcoming nodes and the variable used in this method is top so the top is holding the address of the topmost element in the linked list representing the stack now moving ahead we shall understand the basic operations on stack now here we will understand the previously discussed definition that is push pull etc in a much better way so the basic operations on a stack are push pop or pull and peek now let us discuss each one of them in a detailed way the first one is push operation so the push operation is the mechanism of inserting a new element into the stack as you can see we are trying to insert the elements from the top so the push operation basically involves the following steps check if the stack is either full or not so basically whenever you are trying to insert an element into the stack you need to make sure that the stack is empty or it has some space if it is full you cannot insert an element into the stack step two if the stack is full produce an error and exit that's what i was talking about now the step three if the stack is not full increment the top by one that is when you're inserting an element then you need to update the top value for example in the previous slide when we had the array representation of a stack we had the top value as 2. so if you try to include an element into the stack then you need to update the top value from 2 to 3 that is incremented by 1. now the fourth step add data elements to the stack where the top is pointing and finally success the push operation has been successful so this is how you insert or push an element into the stack now followed by push operation we have pop or pull so the pop operation is a mechanism of eliminating or deleting or removing one data element from the existing stack so we shall understand the pop operation in a much more detailed way the operation involves checking the stack is empty or not if in case the stack is not empty then you can carry forward the pop operation but in case if the stack is empty then you have to provide an exit status and exit the control and leave the stack so if the stack is not empty approach the data element at the top that is at the top position for example in the previous array example remember right we had the top position pointing towards two so you need to take the control to the top position and pick out the element and pop it and finally decrease the top by one so when you eliminate the top element then the top value from 2 will be decremented to 1. so this is how the pop operation is carried over on a stack next one is the peak operation the peak operation involves returning the topmost data element from the stack without moving it so here you can see the top is pointing to the element number four and you're picking the element number four and you're not removing it from the stack you're just returning the top most data element you're passing the value of the top element so to understand the push pop and peak operations on stack in a much more better way let's carry out a practical example now we are on the practical mode and here you can see on my screen we have the code example for the stack now first we'll be checking if the stack is empty as per the steps mentioned in the previous discussion we will check if the stack is empty or not if it is empty then we will return else we will continue and again another step we also check if the stack is full if the stack is full we will exit else we will continue with the operation whatever it is peak pop or push and here we have an example for the peak operation that we discussed previously and followed by that we have a pop operation we are trying to exclude an element from the stack and another one we have the push operation where we'll be trying to push the elements into the stack so these are the three functions for push pop and peak now we'll try to push in the elements and also pop and try to involve some functions on it or run some operations on the stack now let's run this code and see the output so you can see that the code has successfully executed and we have the statements here the first one says the stack is not full that is false and stack is empty that is true right and after that you can see that the elements which we try to push into the stack that is 11 76 71 15 and 66 are been pushed into the stack and if you clearly observe it we have the element 11 in the bottom 76 upon that 71 upon that and 15 and last 66 so the order is first in last out that is the first element was pushed first and when you are trying to eliminate the elements from the stack then you will first pick out 66 followed by that you will pick out 15 followed by that you will pick out 71 and so on so this is the rule what stack follows now i hope i made myself clear with the example now we shall continue with the applications of stack so these are the few applications of stack the first one is expression conversion so you can see we have the in fixed notation prefix notation and postfix notation so the infix notation is no rocket science there is only one thing here to learn that is we have two operands a and b and we have one operator that is the addition operator in between those two operands and when you use the prefix notation you will have the operator located at the first place then you will have the operands followed by it and in the postfix one you will have the operands first and followed by the operands you will have the operator so basically all the infects prefix and postfix notations give out the same results but the only difference is the representation of those operands and operators now let us understand this in a much more detailed way so conversion of expression from one form to another form is the main application of stack so we have the first one that is in fix to prefix and infix to postfix now let us see an example here you have 1 plus 2 star 3 plus 4 so this is the normal infix notation and when you try to present the same expression in the form of prefix notation so this will be the result and this is the result for postfix the next one prefix to postfix and prefix to infix and this is the way you write the prefix notation and if you want to convert that to infix this is how you can write it and this happens to be the result of postfix notation and finally postfix to prefix postfix to infix and these are the results now followed by expression evaluation the next important application of stack is checking parenthesis and you can see if the parenthesis is set properly the expression gets evaluated if not it will not be evaluated now the last one memory management and function call the very useful thing of using a stack is the memory will not be allocated to your stack elements unless the function is called here you can see it is the main function and these are the elements that you wanted to declare into your stack and unless you make a function call the elements will not be declared their memory or the elements will not get the memory allocated for them now another good application of stack as the backtracking problem or the end queen problem the end queen problem is an example of backtracking problem the end queen's solution to this problem is to position the queen in such a way that the opponent queen cannot attack your queen now another example is string reversal you can see on my screen we have a string that is a b c d and e now using stacks you can reverse this right so you're basically eliminating an element and relocating it to the first place and finally after reversing your string this will be your result a b c d and e followed by that we have conversion evaluation so stack is used to evaluating the expression as shown in the example since parenthesis has the highest precedence 5 plus 4 gets evaluated first and it will result in 9 then multiplication and division have the same precedence now the associativity comes into picture so the associativity is always from left to right so first 4 into 9 will be executed which will result in 36 and then 32 divided by 4 which will give us 8. now we have 36 minus 8 which will give us an answer that is 26. now the last application is the tower of hanoi so the tower of hanoi is a mathematical puzzle consisting of three rods and n discs this puzzle consists of some rules the first rule states that one disk can move only at a time the second rule is that the disk can only be moved when it is at the uppermost position on the stack the third one no dusk is allowed to place on the top of the smaller disk so this is how the tower of hanoi works so first up what exactly is a linked list so linked list is a dynamic data structure it allocates memory dynamically the nodes are maintained in a non-continuous memory that is in linked list we have nodes so each and every node is connected via a pointer which points to the address of the next node each node contains next pointer that is the next pointers address which keeps the reference to the next node and it also has another section which stores the data the top most note always contains null in its address and this is how a linked list looks like so this is the top which is the beginning position of the linked list and this is the address of the first location and this is the next node this is the following node then this is the last node and this points back to the head node so this is how you can implement a stack like data structure using linked list you can see that we can perform stack like operation that is the elements are located one above the other and the top is pointing to the head node now let us go through the implementation of stack using linked list first we will go through traversing of stack using linked list so displaying each node of the linked list representing stack is termed as traversing copy the head pointer to the temporary pointer and then move temporary node through all the nodes and display values of each node so you can see the animation here will explain you how the traversal goes through the linked list in real time now another linked list implementation of stack is the push operation so adding a new node to the top of the stack is termed as push operation generally in stack we have three operations that is push pop and peak so one of the operation is push where you add an element into the stack in the same way using linked list you can add a new node to the stack and point it as the top of the stack or the first element which represents the top in terms of stack now create a node first and allocate a new memory to it if the list is empty and node consists of data and null is the address it will be inserted as the first node if there is some node already existing then add a new node at the beginning to avoid violations so the following animation will help you understand how we add a new element or the top element to the stack using linked lists now followed by the push operation we have the pop operation so now let us go through the pop operation removing a node from the top of the stack is termed as pop operation in the same way we will be eliminating the first node from the linked list which is termed as top underflow condition may occur when you try to remove the node if the stack is already empty in stack node can be removed from one end only therefore the value stored in the head pointer must be deleted and the node must be freed followed by the pop operation we have the peak operation retrieving the topmost node of the linked list representing stack without removing the linked list node from the top of the stack is termed as peak operation generally when you're using a stack data structure just retrieving the value of the top node is called as peak operation you're not going to eliminate or you're not going to add a new element to the top you're just going to copy the element or you're just going to retrieve the element which is pointed as top this operation is called as peak now in the linked list you can also perform this operation of peak now with the theory discussed let us execute a practical program based on stack implementation using linked list now on my screen you can see a code example using which we will implement stack using a linked list now here we have the pop operation push operation and top and then the main function don't worry about the code this particular code snippet will be attached in the description box below or you can also request us and we will have it sent to your mail id and you can understand the code and try executing in your local system now without further ado let's directly run the code so there you go the code got successfully compiled and we have tried to add some elements into the stack that is a b c and c is being the top most element of the stack and that element has got popped and followed by that the element on the top currently after c being popped out is b and the node element b got popped again and the only element which was present in the stack is a and that element is also popped out after performing the pop operation and now currently the stack is empty you can see that we have tried to push the elements a b c and also we try to pop the elements a b c let's get started with introduction to q you know that all of us depend on messaging applications like whatsapp facebook messenger instagram chats to communicate with our friends and family members and while using them you must have observed that the person you are trying to communicate with receives messages in the same order as you have sent them now the question that arises here is how is this happening how are these applications maintaining the order of these text messages and the solution to these questions bring us to queue basically in these applications a queue is maintained for each user containing the messages to be delivered to the user when the user connects to the network all the text messages in the queue gets delivered and once the messages are delivered empty queues get deleted this example clearly illustrates the importance of data structures so let's dive further and understand the structure of the queue in depth but before doing that let's look at a real-life example of cues to understand it more clearly the most common and relevant example of a queue is a movie ticket counter in the movie ticket counter you must have observed that both of its ends remain open also these ends are fixed with the help of barricades and that is why no one can enter in between these ticket lines additionally the person who enters first receives a ticket first and the person who enters last will obviously get served at last cues and data structure resembles all these properties of a movie ticket counter which makes them better at creating virtual first-come first-served systems basically they are defined as a linear collection of different data types that allow insertion at one end and deletion at another unlike any other data structure the q ends remain open allowing it to have different functionalities at both ends the end at which insertion takes place is called rare and the end at which deletion takes place is known as front furthermore there are two approaches to consider the structure of the queue and both of them depend on the approach of the programmer that means being a programmer if you consider the left hand as front then your rear node will be at right end otherwise if you consider the left hand as rare then the right end will be your q's front node unlike arrays and linked lists elements in the queue cannot be operated from their respective locations here they can only be operated from the front or rare position moving on let's discuss the operations in queue data structures one by one the first operation is enqueue it is used to store the elements in the queue next up is dq this operation is used for removing them further we have isful and is null operations is full function scrutinizes if the queue is full or not and the is null operation evaluates if the queue is empty we also have a peak operation that helps you get the element from the front of the queue without removing it let's now understand how these operations work with the help of the following examples here we will look at nq5 and q1 and q minus 2 then is full then dq peak and is null but before explaining these operations it's essential that we initialize the queue data structure by assigning some random size to it for example end queue of three by this declaration we are assigning only three spaces for insertion and queue also at this phase there is no element in the queue as its empty so both the front node and rear node will point to the same location with null memory space in the storage system let's consider that null index to be -1 for ease of our convention now the first operation on our list is nq of 5. as we discussed previously enqueue operation is nothing but the insertion of data into a queue data structure it begins with checking if the queue is full or not if the queue is full then the previously assigned memory is completely filled with data elements so insertion would not be possible this is also known as overflow error in terms of programming but as our queue is empty so the insertion can be performed here for that we have to increment the rare pointer to index 0 from index -1 and once we do that the data element phi will be added to the queue also for front insertion both front and rear will point to the same location as there is only one element present in this queue let's insert two more elements into this queue with the operations nq1 and q minus 2. for that we have to increment the rare pointer to the next index which will be 1. now as the point is incremented so the data will be entered into this position next up is nq minus 2. again we have to follow the same process of incrementing the rare pointer we will increment the rare pointer to point towards the next index that is index 2 and hence the data element with value -2 will be entered here the next operation on our list is is full in this operation if the rare pointer points to the max size then the queue is considered to be full as there is no space left for insertion in our case the max size of rq is 12 bytes additionally we are considering to enter only three integer elements and one integer data element takes four bytes of the memory space that means three integer elements will take 12 bytes hence this function will prompt q is full on the screen now we will discuss the dq operation if we want to access data from a queue we have to perform two sub tasks the first one is access the data where the front is pointing and another is to remove the data after access and this complete process is called as dq operation the first step of this operation is to check if the queue is empty if the queue is empty then there is no element available for deletion this is a case of underflow error but as our queue is not empty we can proceed with the next steps we will be accessing data from the front node and later we will be incrementing the front pointer in order to remove the link to the previous node so that the data gets removed now front will point to the index 1. thus the data value 5 will be removed from the queue and will also be prompted on the screen therefore this function comes with an integer return type next up is peak operation in this operation element at the front node will be accessed without deleting it the algorithm for this operation begins with checking if the queue is empty or not if the queue is not empty then data at the front node will be accessed with temporary variable and printed on the screen advancing further let's perform two more dequeue operations here first is dq of one and another one is dq of minus two the data at a front node will be accessed primarily and the front pointer will be incremented to point to the next data element when we do the point incrementation the link to the previous node gets removed which results in data deletion similarly we will perform a dq of -2 operation here now the front will be pointed to null memory space as there is no element left in rq and the data -2 will be removed the last operation on our list is is empty this function checks if the queue is empty or not in the previous procedure we mentioned that if the front points to the null memory space then the queue is empty and in our case the front is already pointing to -1 so the output of this function will be q is empty this is all about operations in the queue i hope that you all are clear with these operations next we will discuss different types of queues and their structures at a glance basically there are four types of queues linear queue circular queue priority queue and double ended queue the structure which we have discussed till this time is that of a linear queue so now we will move on to circular queue the circular queue is almost similar to the linear queue except that the last node of this queue is connected to the first it is also known as ring buffer as all the ends are connected to another end additionally this circular queue is a better version of the linear queue as it removes the drawback of insertion in the linear queue the empty space available in a circular queue can be filled with the new element by simply incrementing the value of the rare position we will learn about this in detail in our further sessions a priority queue is another special type of queue data structure in which each element has some priority assigned with it based on the priority of each element the elements are arranged in a priority queue if the elements occur with the same priority then they are served according to the first in first out principle in the priority queue the insertion occurs based on the arrival while the deletion occurs based on the priority the above figure shows that the highest priority element comes first and the elements of the same priority are arranged based on the first in first out structure the last type of queue is dq dq is a linear data structure in which the insertion and deletion operations are performed from both the ends we can say that dq is a generalized version of the queue dq can be used as stack as well as q as it allows the insertion and deletion operations on both the ends if the insertion takes place at one end and deletion at another then that eq is known as a linear queue and if both addition and deletion are performed at a single end then that eq is called stack advancing further let's discuss some applications of queues to gauge an insight into the importance of queues the queue data structure is used in computers printers and applications to utilize the benefits of the first come first serve technique in computers whenever you work on documents or ppt you must have observed that whichever key you press on the keyboard appears in the exact same order on the screen but when your processor is too busy with other tasks you might notice that the keys you press appear on the screen with some delay after you press them basically those keys are stored in queue and when the processor becomes free it processes in the order the keys are pressed that means the key pressed first will be written in a word document first so this is how computers use a queue to eliminate deadlocks when multiple processes are in a ready state next up is printers a queue data structure is used in printers to maintain the order of pages while printing that means the pages are stored in a queue in the order that you want to print them and once the page is removed from an ordered queue it gets printed another most common application of queue data structure is their usage in web or mobile apps applications like domino swigi uses a queue for maintaining food order status if you place an order from an online portal your order id enters the queue and once the previous orders before your order id gets scattered then your order will be catered as well from these examples we can clearly say that queues are used whenever there is a need for an fcfs strategy in software development so whenever you work on projects that need a first come first approach then remember that you have to implement a queue data structure to complete it successfully finally let's have a look at some key takeaways that we discussed in this session we started this session by examining the structure of the queue we learned that the queue is a linear data structure after that we talked about different operations of queues in which we learnt nq and dq are responsible for data manipulation in a queue later we discussed different types of queues as well finally we discovered some applications of queues and how they fulfill the need of fcfs systems we have also made it clear that queues can handle multiple data types as well a queue is a linear collection of different data types that allow insertion at one end and deletion at another unlike any other data structure the queue ends remain open allowing it to have different functionalities at both ends additionally the queue works with the restriction that insertion should be performed at the rear node and deletion at a front node those processes of insertion and deletion are called nq and dq respectively we discovered both of these operations along with three more supportive procedures named as peak is full and is null now that we are considering to implement a queue data structure so all these operations will become different functional blocks additionally all these operations must take constant time and it must not depend upon a variable like the number of elements in q or the size of the queue by that what i mean is the complexity of all these operations must be o of one having said that let's dive deep into the strategy to implement q data structure until now we have understood that q is a special kind of list with some restrictions on insertion and deletion and there are two approaches to deal with queue implementation the first one is array based and another one is linked list based in this session we are going to focus on array based implementation initially let's say we want to create a queue of integer elements for that purpose firstly it is essential to declare an array of random spaces let's take hundred as the size of our rra that means our array can have a maximum of hundred integer elements the declaration of an array is made with this line of code intq hundred where int represents integer data type and q is the name of our array and hundred is its size the array that we just initialized is going to store our queue by that what i mean is that any random index of an array queue is going to start with two marked ends front and rear in this array i am showing front of the cue towards the left and rear towards the right for making those end nodes we need to initialize two pointers front and rear at this moment as our queue is empty so both of those pointers should point towards -1 so initialization of these pointers should be done as inch front is equal to -1 and inter is equal to -1 when the insertion or deletion happens in queues these pointers will be either incremented or decremented so they are an essential part of this queue implementation process now you must be clear with the array and pointers declaration part so let's dive further and formulate code for queue implementation using a one dimensional array in c plus plus it is essential to include header files into our source file as we cannot access standard c plus functionalities without them that is why here we are going to load io stream and standard input output files along with using namespace sdd once this is done we will initialize our array along with front and rear pointers remember we always have to declare the size of an array before compilation that means we cannot update the size of an array at runtime this scenario is the biggest limitation of queue implementation using arrays having said that let's proceed with pointers declaration now we are done with the initialization process we will now work on implementation of queue functionalities let's first work out supportive queue functions like is null is full and peak isn't function validates if the queue is empty and as per our previous discussion when both front and rear points to -1 then the queue is considered to be empty so the condition to determine if q is empty will be if rare is equal to is equal to minus 1 and front is equal to is equal to minus 1 it will return q is empty if the queue does not satisfy the previous condition then it is not empty so by using the else condition we can display the queue is not empty next up is is full function this function validates if the queue is full and we can clearly say that if the rare pointer is equal to the max size of the queue then our queue is going to be completely full next is peak the peak function extracts the element where the front pointer is pointing without removing it from the queue for this functionality to work our queue must contain data elements in it what i mean is our queue should not be empty if our queue is not empty then data at the front node can be accessed this is how we implement supportive queue functions let's immediately dive into the development of main queue operations nq and dq for enqueue operation if the queue is full then our function should prompt an overflow error for that to happen we have to put this condition if the front pointer is pointing to -1 then we have to increment the front pointer to 0 manually otherwise it can be incremented by rare plus plus after pointer incrementation we have to ask for a data element to enter into the queue once the data is given it should be inserted at the position where the rare is pointing now finally let's quote the final main queue operation called as dq if the queue is empty then there is no element for deletion so it should prompt an underflow error on screen also if there is only one element left inside q then both pointers should again be pointed towards minus -1 for that let's write another condition here if both the previously mentioned conditions are false then deletion of an element can be achieved by just pointer incrementation foreign we have implemented all the queue functionalities here but we haven't implemented a function that can show us how our queue looks so for that let's implement one more function with the name display this function should prompt the elements of the queue on the screen elements will only be printed if the queue is not empty hence we have to check for the emptiness of the cube first finally we are done with the hard part so let's arrive at the main function to contemplate these operations in order to visualize outputs we are going to use a switch case to take a user command thus not to waste your time on this let me just get done with this block asap that's all we are done with the queue implementation using arrays let's just examine if our code works fine or not by compiling it this program should return a console that asks the user to give commands for performing different operations so as you can see on your screens if i input 1 i can perform insertion in a queue let's perform some insertions now we will insert 4 elements first 3 then 21 next 78 and finally 12. after inserting these elements we will print the state of the queue using case 3. now let's also check the dq function if we perform a dq operation then 3 should be remote from the queue let's check if it is remote using the display function and yes our code works just fine now if you're concerned about this code then don't be as we can send it over to you if you drop your email ids in the comment section below additionally you can also try to run it on your local system to have a better understanding of the concept introduction to priority queue primarily we will have a look at the real life example of priority queue to understand it better a hospital emergency queue is almost an ideal example of priority queue when you go to the hospital you must have observed that the person who needs immediate medical attention will be treated first irrespective of his arrival at the reception that means treating a person who is in agonizing pain or in emergency medical condition is the priority of the queue of patients priority queue in computer science also works with same approach so what exactly is this priority queue well a priority queue is an abstract data type that operates similar to the normal queue except for the fact every element has certain priority assigned to it this definition of priority queue suggests that this particular type of queue also follows the same restrictions for insertion and deletion of data elements the insertion in the priority queue will only be achieved at one end and deletion at another or opposite time additionally the priority of data elements will determine the order of removal the elements which have higher priority will leave the queue at first and the elements which has lower priority will definitely leave the queue at last as a side note i would like to tell you guys that the priority queue only supports the elements that are comparable meaning the data that we are going to insert into priority queue must be orderable the compiler should not be facing any difficulty while comparing these data elements otherwise the execution of a priority queue will definitely fail moving ahead let's have a look at an example of priority queue in this priority queue we'll insert 7 to 45 23 and 12 respectively these elements are not ordered so how the priority queue is going to store them in order well at the time of insertion the priority queue conducts a comparison of each element with every other element present inside a queue to store them in order but as there is no element inside a queue so the first insertion that is an element with value 7 will be attained followed by that the next element will be inserted in a queue since the newly inserted element is smaller than that of previously inserted element will swap their positions in order to maintain order remember the element with least value will have a higher order and the element with greatest value will have a least priority or order now we will insert the next element in a queue that is 45. as fortifier is a larger element than the elements inside the queue there is no need to shuffle elements when we make the next insertion the element 32 will get inserted at index 3. now this element is smaller than that of 45 so the algorithm will have to swap the locations of these 11. now we will perform the final insertion into our queue we will insert 12 at index 4 now but as you can see this element is smaller than both the previous elements thus the algorithm will have to swap their positions now 45 will reach the end of q as it is the element with highest value and 2 will remain at the front of q as it is the least valued element as a humans we could see the numbers visually inside the priority queue and further we can easily arrange them but how does the machine know this does it restore all the elements inside the priority queue before each insertion no obviously that would be highly ineffective as there will be n comparisons for insertion of n elements leading to time complexity big o of n square this is an enormous time complexity which we cannot allow in any software application we will understand how the priority queue manages to reduce this time complexity in upcoming topics but right now we will contemplate different properties of a priority queue that we have learned from previous example the first property of priority queue suggests that each element has a certain priority assigned to it that priority might depend on value of data element it can be either larger or smaller the next property states that element with higher priority will leave the queue at first where the element with least priority will leave the priority queue at last further if two elements have the same priority then the element will be removed from the priority queue based on their arrival that means the element which arrived at first out of the elements having same priority will be removed first now moving ahead we'll deal with the representation of priority queue using a linked list as usage of arrays is not an ideal way to implement priority queue if we consider array implementation of priority queue then inserting items into the sorted array will cost us big o of n and in general processing each element will further cost us big o of n square as discussed previously so in this tutorial we'll just look into the linked list representation of priority queue we will understand the representation of priority queue with the help of an example initially let's say there are three elements inside a link priority queue and all of them are in order 3 being the least element has highest priority where 43 has the least priority the purpose of keeping three at the head node is that we want our priority queue to delete elements according to their priority now we want to insert a new node consisting of data element 2 and as the data element is smaller than the element at head node that is 3 so this new node should be inserted prior to it this particular scenario of insertion seems pretty perfect but it does not cost us more time but what if the element is significantly larger than all the nodes in queue for instance let's say we want to insert 45 as a new element in that case primarily it will be compared with element 2 and as 45 is larger than 2 our temporary pointer will move to the next node for comparison now 45 will be compared with element 3 and again the temporary pointer will be moved to the next node for comparison after two comparisons the temporary pointer has reached element 17 for performing the next comparison and here also 45 is larger than 17 so the temporary pointer will again move towards the next node now finally our temporary pointer has arrived at the tail node consisting of element 43 again in this case the element 45 is larger than 43 thus the new node will be inserted after node containing data element 43. from this specific example of insertion into a priority queue we can clearly see that there are n comparisons leading to the time complexity big of n where the complexity of deletion remains constant that is bigger of 1. while understanding the representation of priority queue we came across some packs that make priority queue implementation using linked list quite vulnerable so here we will again try to recall them the first drawback of priority queue implementation using linked list is that it cost us big o of n for inserting a new element further it also cost us big of n for peak operation and as memory and time management is the purpose of data structure hence we must try to analyze other implementation strategies that is why in upcoming slides we'll look into different approaches to implement the priority queue there are three approaches that implement a priority queue with complexity less than big of n square we have already discussed the linked list so let's also look into other two approaches binary heap and binary tree provides almost similar complexities these approaches cost us big of log n for insertion and deletion and big of 1 for peak operation but which one of these operation is most optimal approach to implement priority queue well to answer this question we again need to discuss about memory management in the case of both this data structure you guys know that binary heap data structure is implemented using arrays and since it utilizes arrays there is always a better locality of reference as well as operations become more cache apprentices the binary search tree uses pointer to implement front and rear node which definitely takes up more space in memory due to that building a cell balancing bst cost us big o of n log n where binary heap just cost us big o of n these facts clarify that the binary heap is the best data structure to implement a priority queue now you must be thinking about what exactly the heap is and how does it work so moving forward we'll look into the definition of heap and its properties basically a heap is a tree based data structure that satisfies the heap in variant or in simpler words heap property the heap invariant states that if a is a parent node of b then a is ordered with respect to b for all nodes a and b in heat what that means is the value of parent node is always greater than or equal to the value of child node in the heap or other way around the value of parent node is less than or equal to the value of child node for all nodes in a heap further there are two types of heap named as max heap and minimum heat first we will look into maxi the max heap is heap in which value of parent node is greater than the value of child node for this particular example of max heap you can see that the root node is the biggest element in tree and each child node is smaller than its parent node the next type of heap is minimum heat the mean heap is heap in which the value of parent node is less than the value of child node in this specific example you can observe that each child node is larger than its parent node and the element at the root node is smallest element of the heat both the structures that we have discussed are binary heats as every node has only two children in upcoming slides we'll discuss some complex structures of heap data structure to better understand how we can judge if a tree like structure is heap or not okay so you can see a tree like structure on your screen and we are supposed to check whether if it is a valid heap data structure or not but actually here i would like you all to give it a try by yourself you can also pause this video if you want but here i will provide you with a short moment to inspect this structure all right i can clearly say that this is not a valid heap data structure as you can observe the highlighted part is violating the heap invariant moving forward let's analyze another tree-like data structure to consider if it is a valid heap or not well yes this is a valid heap because even though this one is strangely structured we are free to move around the visual representation of nodes to make it organize now you all must be thinking how we can do that well we'll understand that scenario in upcoming slides now how about this one is this a valid heap no right this is not a valid heap this structure is not even a tree as it forms a closed cycle and every heap must be a tree so it's pretty clear that this is not a valid heap now what about this one is this a valid heap yes this is a valid heap as it satisfies the heap invariant that all the child nodes must be greater than or equal to or smaller than or equal to its parent node now this is the last structure that we are going to check if it is a valid heap or not what you guys think is this a valid heap well i think it's pretty clear that this is not a valid heap but it can be converted into a heap by making a one small change now if we make six as our root node then this structure will get converted into a maxie which is absolutely a valid heap i hope you all are clear with the heap invariant and how to judge if a given tree is a valid heap or not now moving ahead we'll discuss the different types of priority queue basically there are two types of priority queue based on the priority of elements if the element with smallest value has highest priority then that priority queue is called as min priority queue and if element with higher value has the highest priority then that priority q is known as max priority queue furthermore it's vividly clear that the mean priority queue can be implemented with a minimum heap where the max priority queue can be implemented using maximum heap moving ahead we'll deal with the operations in priority queue considering the heap as implementation strategy the common operations that we can perform on priority queue are insertion deletion and peak but there is one more hidden additional operation that gets performed during these operations that operation is called as hippie fire heavify manages the priority of data elements in a heap by shuffling the data elements after new insertion or deletion first of all we will understand how insertion in priority queue happens with the help of an example in this example we are inserting a new data element that is 43 but due to this insertion the structure disobeys the priority queue invariant that the parent node of the max priority queue must be greater than its child node now the hippie pi operation solves this problem by rearranging data elements by carrying out the comparison in this particular case 43 becomes the parent node where 40 becomes the child node the next step is deletion as we know the highest priority element will be the first to leave the priority queue and further it is stored at the root node of a max heap so definitely the element present at the root node will get removed but due to this operation the order of priority q gets affected however the hippify operation comes to the rescue it reshuffles the elements of the priority queue to rearrange them in order the next operation that we are going to discover is peak the peak operation simply returns the element present at root node without removing it and it is easily accessible thus the time complexity of this operation is big of 1. i hope you all are clear with the operations that can be performed on priority queue moving forward we'll try to implement them with the help of minimum heap as discussed earlier while implementing a heap data structure we know that all the elements will get stored in an array and we don't have any pointers pointing to either child or parent nodes so how exactly does the heap data structure remember nodes like parent nodes and its left or right nodes well if you have learnt binary trees then you must know the formulas present on your screen these formulas determine the left child right child or even the parent node of any binary tree let's understand how this phenomenon works with the help of an example we'll begin with index 0. if we enter 0 in this arithmetic expression then we will get 1 and 2 as output that means the element at index 1 will be the left child and element at index 2 will be the right child and tree structure will look like this now moving ahead let's take an example of index 1. for index 1 the left child will be at index 3 and the right child will be at index 4. similarly for index 2 the left child will be at index 5 where the right child will be at index 6. using these formulas we'll be implementing heavify and primary queue operations so note them down for further reference now moving further we will visit code editor to implement priority queue data structure using c programming language previously i mentioned that heap is implemented using arrays so to begin with heap implementation primarily we will create a structure consisting of different variables or objects needed to implement heap data structure so let's create a structure struct heap consist in size and count variable and end star heap array which is a dynamic array that we are creating here and next we'll also declare a pointer to heap structure along with size and count variable in a global scope so let's do that end star heap comma size comma count we'll create one more variable end initial underscore size to represent the initial size of our priority queue and let's assign it value 4 for now okay now it's time to allocate memory to our heap array for this purpose we'll create a new function called heap underscore init so let's create this function void heap underscore init and inside it will pass an argument struct heap star h which is a reference of this structure that we created previously okay in this function let's initialize the variables that we have created inside this heap structure so for that we'll initialize h arrow operator count is equal to zero similarly h arrow operator size size is equal to initial underscore size and h array is equal to end star malloc size of end star 4 this statement is just allocating four integer variables to our heap array basically our heap array is dynamic data structure that's why we have to provide it with dynamic memory using malloc if you are using c plus programming language to implement this data structure then you can use new instead of malloc moving forward now we'll work on our condition f not h arrow operator allocates memory to heap array then printf error while allocating the memory and that slash one next we will write exit command okay okay with this we have successfully implemented our heap init function now moving ahead let's implement heavify function to move the nodes for that we'll create a heavy five function void max underscore hippify int star data end log and count so all these are required variables to implement this hepify function that we have passed in argument for this maximize function now let's create few more variables that we need and left comma right comma largest comma temp now as discussed earlier left will be equal to two star location in array plus 1 and right will be equal to left plus one now let's say largest is equal to loc and we'll work on conditions now f left it's greater than or equal to count and data left is greater than data largest that it's the location we have stored in largest variable then largest is equal to left with this block what we are doing is we are checking if the element at location left is greater than the element at recent position and the value at left is also greater than the value of recent location if these conditions are true then we will set the recent location as left and here we are getting signal that there is semicolon missing over here so we'll add it okay now let's work on next condition now we will check the value at right position if the recent location is greater than the right and the value at right is greater than the largest value then element at largest will be set to right so for that we'll write condition f write its data count and and data right it's greater than data largest then largest is equal to right otherwise if largest it's not equal to location then we will store the data present at location in temporary variable and data loc is equal to data largest this is a swapping operation that we are carrying out here and next data largest is equal to 10 and now we'll make recursive call to our hipfire function max underscore if i data comma largest comma count with this we have successfully completed our hippify function now we will work on insertion operation on priority queue let's call this function heap underscore push because we are treating this structure as heap right so in heap insertion is called as push operation so we'll call it void heap underscore push and we'll pass arguments struct heap star h and value and inside this function will create few more variables and index and parent if you guys remember the initial size that we have allocated to our array is 16 bytes you can verify with this statement here that we are providing 16 byte size to our heap array but what if you want to insert elements more than 4 then what we'll do well for that we'll need to increase the size of our heap array so we'll do that here for this resize we'll create if condition f h dot count is equal to equal to h dot size then h dot size plus equal to 1 and h dot heap array is equal to real lock h dot heap array size of end star h dot sides basically we are using reallock function in c to extend the dynamic memory space for our heap array and in order to increase the size we have to increment the size variable first so that's what we have done in this statement here and now once done with this we'll check if our dynamic memory is getting allocated or not so for that we'll add one more if condition inside this if block so it can be called as nested if you guys want dot keep array then exit -1 now we will move out of this if block and we will set index variable to h dot count plus plus basically we are iterating with help of index variable here so next we'll add for condition for loop index to index is equal to parent and then set this condition will make parent node is equal to index minus 1 by 2. this is nothing but the formula that we have discussed in previous part now we'll add one more condition inside this for loop f h dot heap array parent it's greater than or equal to value then we will break this for you otherwise h dot heap array index will be equal to h dot keep array parent now we'll move outside this for loop and we'll add one more condition of insertion that is h dot heap array and at position index we will add the value provided by user using argument to heap push function okay with this we have successfully created our heap push function now we will move towards the next function that is heap underscore delete for that we will create new function heap underscore delete and let's make this function integer and we'll pass struct heap star h as an argument we will create one more variable temp is equal to etch arrow operator heap array and inside this will pass a negating index that means we are using this temporary variable to traverse through all list of elements so for that we'll write dot dot minus minus h arrow operator count which will decrease count one by one now next we'll add condition f h arrow operator count it's greater than or equal to edge arrow operator sides plus 2 and and h arrow operator size it's also greater than the initial underscore size okay then what we will do is we will set size to negate itself by 1 for each action and then we will add h arrow operator heap array is equal to real lock h dot heap array comma size of end star h arrow operator and size sorry size and semicolon so basically what we are doing here is we are checking if count is smaller than the size of heap plus 2 and and the dynamic size of q is also larger than initialized size that is 4 then what we are doing is we are reducing the size for deleting an element using this statement and in next statement we are reallocating that deleted space so this is how this ip block works now moving forward we'll add a condition to check if memory is getting allocated or not for that we'll write condition f not h arrow operator heap array then what we'll do is exit with -1 okay now let's move out of this block and now we will set this removed variable to h arrow operator heap array and index zero so if you guys remember zero is the index of the highest element in our maximum heap what i mean here is the element with highest value is stored at index 0 for maxi now moving forward to delete this element what we'll do is we will set h dot heap array and index 0 is equal to temporary variable or pointer that we have created previously and next what we'll do is we'll call max underscore hippie five function to rearrange the structure of our priority queue which has been shuffled due to this delete operation now for that we'll pass arguments our heap structure that is heap array and next the index which was removed and the count variable and will return the remove element okay with this we have successfully implemented our delete function now to understand the order of deletion in priority queue we will implement one more function called as mtpq so let's create this function and in this function will pass the reference of heap structure in order to operate on it so let's pass the structure here star h and insert this function we will create a while loop h dot count is not equal to zero then printf modulus d and recursive call to keep delete function in which will pass h now we are done with this empty pq function further we will create one more function to visualize our priority queue let's call this function void heap underscore display and inside this will pass structure heap star h and now we will create one iterator element and using that iterator element will create for loop i is equal to 0 to i it's greater than arrow operator count plus plus i and inside this for loop we will print the elements present in our queue using this format modulus d and we'll call heap array but for that we'll need to call structure as well if array and will pass this item variable into it okay and then next we'll get outside this for loop and we'll print f this to the next line using slash n okay now we have implemented all the required function for our priority queue moving forward we'll work on our driver function that is main method to contemplate the result of our program so for that we'll first call struct heap edge then we'll call init function to create heap structure so heap init and we'll pass the address of h next we will call heap underscore push function to insert element and h comma one next i'll copy this part with paste it to insert another element now we'll insert five here next paste and we'll pause three next we'll insert element 7 next we'll insert element 9 and after this we'll insert element 8. okay so now let's display the elements inside our key using heap underscore display function and let's pause and h object to print it and again we'll call mtpq function empty pq and after deleting all elements it will return the state of our heap array again or our priority q so finally we'll add return zero statement and now our code is ready so let's compile it and check it if it works fine or not so we are getting four errors here guys so we'll need to resolve them first we'll need to check line number 82 so for 82 okay here we haven't added semicolon so i think this should be fine now still we have two errors before i it's there so let's recompile it and check it if it is working fine now so we have received our output now now if you look at our output our output is printing elements 9 7 8 1 5 and 3 and deletion of elements is also happening according to their order so 9 is getting deleted first after 8 7 5 3 and 1. so that means our elements are getting removed in proper order further we can say that our program for priority queue implementation works fine now if you guys are worried about this program then not to worry we have you covered you can mention your email ids in comment box below and we will send it over to you remember guys we can make comments private to protect all your data so you can fearlessly put all your email ids in comment box below now we will discuss applications of priority queue to understand its importance the first application that we are going to discuss is use of priority queue in google maps you must have used google maps several times to navigate from one city to another or from your location to nearest desired location have you ever wondered how google maps managed to do that how does it provide an optimal path to reach your location well dijkstra's shortage path algorithm implemented in google maps actually manages to do that by gaining access to all possible paths this algorithm uses the priority queue to maintain all the paths in order let's understand how it works in detail now when you provide the location of place you want to reach via your mobile device google maps feeds the data of all possible path to digikestra's algorithm those paths or road are stored in minimum priority queue considering the distance as parameter for priority assignment and we have learned that the minimum priority queue maintains the lowest value at the print or root node this is how the priority queue helps google map to search for an ideal path for reaching destination location the next application that we are going to discuss is data compression in winzip or gzip these applications use hubman encoding algorithm to reduce the size of files hupman coding is a lossless data compression algorithm and in this algorithm a variable link code is assigned to input different characters the code length is related to how frequent characters are used most recurring characters have the smallest codes and longer codes are for the least frequent characters this is how the generated codes will maintain the complete data while utilizing less memory space let's understand how this process works with the help of an example let's say our text file contains these random characters the hubman encoding algorithm creates codes for each character based on its number of occurrences for instance the frequency of character a is more prominent than b and character c has less frequency so the length of code a is smaller than b and length of code b will be smaller than c now according to the amount of generated code the priority queue will determine the priority of characters and will store them these codes takes less size than the actual characters in memory space and due to the mapping of occurrences data does not get lost i hope now you guys understand why the priority queue is treated as an abstract data structure itself and why it is the better version of queue data structure we'll start this discussion by understanding what is double ended queue in data structure followed by that we'll understand the properties of dq in detail advancing ahead will deal with the different types of dequeue after that we'll understand the representation of dq using circular queue and further we'll discuss different operations that can be performed on dq once finish with that we'll implement a dq using circular queue and finally we'll cover applications of dq to understand its importance i hope i made myself clear with the agenda now let's get started with our first topic what is dq dq is an abbreviation for double ended queue and as the term double ended queue suggests it is a type of queue with some advanced features at both of its ends but previously we have learned that the basic queue data structure must perform insertion from one of its end and deletion from another or opposite end so what new limitation of feature does this particular type of queue brings well the dq extends the concept of a linear queue by implementing insertion and deletion at both of its nodes by that what i mean is the dq data structure is acquainted with the possibility to insert and delete new elements at any node that is why dq is concerned as more generalized version of queue data structure now moving ahead we shall understand the key properties of dq the first property of dq states that the dq can use the lipo principle for inserting or removing elements the last in first dot principle is used while implementing stacked data structure and according to this principle the queue elements must be inserted from one end and should also be removed from the same end for instance we are storing some elements inside this queue structure which is performing both insertion and deletion from one end however when deletion begins the element inserted at last will be removed first whereas the element stored at first will get removed at the end this property clears that the dq can inherit all the properties of stack data structure the next property of dq states that the dq can use the fifo principle for performing both insertion and deletion operations that means the element which enters inside the queue at beginning will also leave the queue at first further the element which entered at last can leave the queue at last both of these properties displays the uniqueness of this particular type of queue data structure now in upcoming slides we will understand different types of the dq the first type of dq we have is termed as input restricted queue this terminology itself suggests that this particular type of dq will have some restrictions while performing nq or insertion operation in this type of dq the insertion can only be performed from one end where deletion can be performed at both of its ends the representation of dq shown below explains how the operations in this type of dq will get accomplished the next type of dq is output restricted dq this term makes clear that this type of queue will have some restrictions while performing deletion operations in this specific type of queue the removal of elements can only be performed from one eight where the insertion can be performed at both of its eights this particular structure of a queue explains how the different operations will take place in this type of dq now here is the interesting question that we want you all to answer based on the properties of dq that we have discussed till now which of the following data structure will be more ideal for implementing dq in data structure what i mean by ideal is the time and space complexity for implementation strategy that you decide should be minimum the options that we have are circular array singly linked list and doubly linked list it will be interesting to see how many of you guys will get this right so guys do leave your answers to this question in comment section below in a week's time we'll be announcing the right answer and you all can check it out on that note let's dive further and understand the representation of dq using circular queue and yes circular queue is one of the answers for previous questions we'll understand why it is best in upcoming slides but please check the complexity analysis of other two strategies to decide your answer for the previous question as multiple answers can be accurate for that question now let's understand what a circular queue is well a circular queue is nothing but the extended notion of linear q as it follows the first in first out principle with the exception that the last position of this particular queue is connected to its first position making a circular link the circular link is responsible for naming of this queue as circular queue or ring buffer let's understand how a circular queue operates with the help of simulation this is the illustration of a circular queue having size 5. as the position of rear pointer keeps increasing a new element will be inserted in this queue until the rear pointer reaches the end of q but what if we perform dq operation now if we perform the deletion then the empty space will get created at front of q however this space can further be utilized in this particular type of queue by making circular incrementation of rear pointer or circular link so if we increment the rear pointer from its index 5 to index 0 we can utilize empty space by making new insertions using this feature of circular queue we can implement both insertion and deletion at both the ends of q let's understand how we can do that in upcoming slides the first type of insertion is a pretty ordinary one and this insertion will increment the position of rear pointer to insert a new element the arrow shown in blue is rear pointer and the arrow shown in orange is the front pointer so as you can see once we increment the rear pointer new elements get inserted this is how the insertion using rear node happens now what if we want to perform insertion using front end in order to perform the insertion using front node we'll have to make front pointer reach to the end of queue the only possible way to achieve that is to set front pointer equal to max size minus 1 manually this command will allow a front pointer to reach the end of queue for performing insertion and for further insertions we'll just have to decrement the front pointer location for inserting new elements this is all about insertion now that we have implemented insertion from both ends let's move on to the deletion operation primarily we'll look into the deletion using front node in order to delete elements using front node we'll have to increment the front pointer until it reaches the end of q and once it reaches the max size we'll use circular incrementation to bring the front pointer to the beginning of queue while performing these incrementation meanwhile the elements will be removed from the queue next up is deletion using rear end for performing deletion using a rear pointer we'll have to decrement its location once we decrement the rear pointer location the element will get removed from the queue now moving ahead we'll look into the different operations that can be performed on a double ended queue basically there are four primary operations in the dq which we have already understood in the representation of dq using circular queue these operations are insertion and deletion at the front and insertion and deletion at the rear additionally the circular queue implementation of dq cost us big of 1 which is the most optimal complexity that we can hope for having said that let's dive into the implementation of these operations using a circular queue we'll implement a double ended queue using circular queue in order to do that we'll use c programming language and one dimensional arrays so without wasting any time further let's move to the code editor now in order to get started with implementation of dq we'll have to create array and pointer variables so let's do that and we'll name this array as dq and we'll provide 100 as initial size next we'll create pointers and rear is equal to minus 1. now we'll also define the maximum size for our queue using define call as 5. after done with this initialization process we'll start working on insertion from front node will declare a function named as voidfront insert so let's do that void front underscore insert and instead this function will pass an argument into z to insert an element now while performing insertion we should always check if the queue is full or not because if it is full then the insertion won't be possible so for that we'll write condition if front is equal to equal to zero and and rear it's equal to equal to size minus one inside and braces or front is equal to equal to rhea plus one printf dq as full insertion it's not possible okay otherwise if both the front and rear node are pointing to null memory index or -1 will manually set our front pointer to index 0 to make the first insertion into the queue and we will insert the element at new location or index 0 where the front pointer is pointing so for that what we'll do is we'll write another condition with lc block else if front is equal to equal to -1 and and zea is equal to equal to minus one then make front is equal to rhea is equal to 0 and dq front is equal to z now if we want to insert the element at the last node of q then we need to set front pointer to the max size -1 location to do that we'll write this condition else if front is equal to equal to zero then front is equal to size minus 1 and dq front is equal to z if all these above mentioned conditions fail then the front pointer is already at the last part of q and it just need to decrement its location for inserting element in empty spaces as discussed previously so to do that we'll write one more condition using else block so let's do that else front is equal to front minus 1 and dq front is equal to z now we have successfully implemented a front insert function so let's move forward and work on another function that is called as void rear underscore insert and will pass g as an argument to insert an element now as done previously we will first check if our queue is full or not so let's do that using if condition if front is equal to equal to zero and at ria is equal to equal to size minus 1 inside braces or front is equal to equal equal to equal to rear plus 1 then printf dq is full next if there is no element in an array we'll manually set the rear pointer to index 0 for new insertion so for that we'll write condition else f front it's equal to equal to minus 1 and and rear it's equal to equal to minus 1 then set rear is equal to 0 and insert dq ria is equal to z otherwise if rear pointer is already at the end of q then we will bring it to the beginning of q so for that we'll write condition else f rear is equal to equal to size minus 1 then being rear to index zero and dq rear it's equal to z if all these mentioned conditions fail then what we'll do is we'll write else condition and we'll simply increment our rear pointer to make an insertion so for that what we'll do is we'll create else block and we're inside it we will do rear plus plus and we will set dq rear is equal to c with this we have successfully implemented void rear insert function so now let's move into deletion functions first we'll create void front dq function void front underscore dq and there is no need for any argument for this function to begin with this function first we'll have to check if dq is empty because we cannot delete elements if there is no element to delete so for that we'll write f condition if front it's equal to equal to minus 1 and and rear is equal to equal to minus 1 then printf there is no element to delete inside this dq in the next condition we'll check if there is only one element inside the dq if there is only one element then we will set both front and rear to minus 1 manually for that what we'll do is we'll create else if condition else if front is equal to equal to zero then printf let's slash in to take this to the next line the deleted element from the front is modulus d comma dq front and we will set front is equal to minus 1 similarly real is equal to minus 1. now if both these above mentioned conditions fail then we will delete the element from our front node the first removal will be in a case when the front pointer is at the end of queue so for that we'll write condition else if front it's at end of queue that its size -1 and what we'll do is we will printf slash and the deleted element from the front is modulus d comma dq front comma and another condition will be when the front pointer is at the beginning section of a cube for that we'll write else condition printf slash n the deleted element from the front is modulus d comma d2 front with this we have successfully implemented our front dq function now let's move towards next function that is deletion from the rear end for that we'll create new function name void dq underscore rear and this function also does not need any argument so next what we'll do is we'll create condition to check if the queue is empty or not so if front is equal to equal to minus 1 and and rear is equal to equal to -1 then printf printf slash n there is no element to delete inside the queue now let's move to the next condition in next condition we'll write else f front is equal to equal to rhea then printf some statement and set run is equal to minus 1 along with rear is equal to -1 and that statement will be the deleted element from the dq using rear node as modulus d comma dq rhea now if both these above mentioned conditions fail then we'll have to delete the element from our real node the first removal will be in a case when rear is at the beginning portion of a queue for that let's write a condition else if rear is equal to equal to 0 that is at the beginning part of q then printf some statement and rear is equal to size minus 1 that is setting it to the max size of cube and the statement that we will return is backslash n the deleted element from the rear node adds modulus d comma dq rear in other cases we'll just have to decrement the size of rear pointer and delete the element so for that we'll write else condition printf some statement and set rear is equal to rear minus 1 that is decrementing the size of rear pointer and the statement that we'll write as backslash n the deleted element from the rear node as modulus d and comma dq rear well here is one spelling mistake so let's remove it okay so with this we have successfully implemented our void dq rear function now we will implement one more function to display the state of our dq the name of that function will be void display and this function also does not need any argument so we'll begin with implementation of this function for this we'll create an iterator element and we'll set it to the front pointer and we will printf backslash n elements inside the dub double ended queue r next line will enter into while loop to print those element i not equal to rear printf modulus d comma dq i and will increase the value of i by i plus one modulus size and outside this while loop we will printf modulus d dq ria okay with this we have implemented all the required functionalities for our dq so let's work on driver method that is main function in order to check the output of our program so let's work on this main function first we will insert few elements into our queue so i will insert first element using front insert next let's insert one more element from front node using function front insert and this element will be 23 next we will insert elements using rear node underscore insert and we'll pass 17 now next we'll insert 12 and we'll insert one more element using this rear node only insert 47 now we will display the state of our queue after performing all these operations and next we will dq few elements so for that we'll use front dq function and next we will dequeue from real node so dq here and after performing deletion operations will also display the state of our queue so let's call display once again and let's add one more command return zero so with this we have successfully implemented our program for dq implementation so let's run it and check if it is working fine or not okay so we are getting output here but uh display function is printing output in weird manner so let's work it out so all we have to do is we'll have to add space before modulus t here and here as well so once done with this let's recompile our code okay so now our output is clear so let's check if it is perfect or not so the first insertion that we made was -5 second was 23 from the front end so 5 should be getting inserted before 23 so minus 5 is getting inserted before 23 but as we are inserting it using front pointer so 23 is remaining at the front now after these two insertions we are performing insertions using rear pointer the first rear insertion was 17 then 12 then 47 and these elements are getting inserted so let me show you how they are getting inserted in exact same order so look here so elements inside the double ended q are 23 minus 5 17 12 and 47 that means the insertion is in right order after that we deleted the element from front node so the front node is at 23 so 23 is getting deleted after that we deleted the element using rear node so 47 is getting deleted from the rear node we are still getting 23 here that means the tq function is incomplete so we'll have to change it so let's go to the dq function and i guess it was from front end so we'll need to change code for our front dq so okay so in this case we haven't brought our trend pointer to index 0 so let's do that here and once we do this let's recompile our code again okay so now you can see that the 23 is getting deleted with this we have successfully implemented our dq function now let's move back to the powerpoint and understand few applications of dq the first application that we are going to discuss in detail is palindrome checker you all must have heard about the term palindrome the palindrome is a specific word or number which reads the same backward as forward for example the word radar it reads the same from both ends so using the dq we can implement the palindrome checker program with complexity big of 1. the string which you need to check will be inserted into a dq and after that it will read from both sides if the reading is the same then that string will be considered as palindrome the next application of dq is its use in multiprocessor scheduling but what precisely is multiprocessor scheduling and why do we need it well the system implemented in the old days use single processor scheduling to manage the computing processes when multiple processes need to be executed by a single core or cpu then the process take more time to implement and thus the system lacks computing power but the multi-processor scheduling implemented in modern computers resolves that problem using a double ended queue suppose we have three processors in our system and each processor has some processors to execute each processor maintains a dq that contains threads that are ready to execute the processor executes a process and if a process creates a child process then that process will be inserted at the front of the dq of parent process suppose the processor p2 has completed the execution of all its threads then it steals the thread from the rear end of processor p1 and adds it to the front end of the processor p2 the processor p2 will take the thread from front end therefore the deletion takes from both the ends this is also known as a still algorithm in process scheduling what is a stack so to define stack in a more generalized way we can consider stack as a linear data structure that follows lifo order or lost in first out order or another way of putting it down as first come last out order so some of the basic operations that can be performed on stack are insertion and deletion and that can be done only at the end which is called as the top of the stack now let us understand the basic operations on stack so the three fundamental operations that can be applied onto a data structure like stack are push pop and peak so the push operation involves inserting a new element from the top of the stack the pop operation involves removing the element from the top of the stack and finally the peak operation which returns the topmost element from the stack without removing the element from the stack now we shall go through some generalized examples of stack so some of the generalized examples of stack are you can see a stack of books here and a stack of utensils stack of coins and stack of dollars of bills now let us go through a practical example based on stack and data structures we shall be using c programming language for this particular example so you can see that on my screen i have an example for stack data structure don't worry about the code this code will be attached in the description box below and you can always have access to it and you can run the same code in your personal system so that you have a deeper and better understanding of the program now let's quickly run this program so there you go you can see the program is getting executed now so you can see that the program got successfully executed and the elements are being inserted into the stack now the elements are a b and finally the elements are popped back again that is b a and the last element that is popped away from the stack is a and you can see that the stack is currently empty so top is pointing to -1 now with that let's get back to the presentation again now let us understand some of the applications of stack so one of the applications of stack is function call or recursion the recursive function call is also known as the called stack whenever a function is called then the function goes to the top of the stack now another important application of stack is expression conversion there are three types of notations that is prefix notation inflectionation and postfix notation so these particular notations can be taken care by using stacks in real time now the next one is checking parenthesis stack is used to check if the given parenthesis are balanced or not sometimes if you forget to add a parenthesis then the compiler will throw an error so using stack this can be found if there are balanced parenthesis used in your program or not balanced parenthesis means opening and closing brackets are of the same type that means if you have two open flower brackets then you need to have two closed flower brackets it should not be an equal it should be completely equal to complete the code segment now another application of stack is expression evaluation stack can be used to evaluate the expressions as you can see here we have an expression that is 6 plus 2 star 3 minus 12 divided by 4. now this particular expression will be evaluated based on the presidency table so the stack is used to check the precedence and then the expression gets evaluated into the result which is 21 right over here now another application is the tower of hanoi tower of hanoi is a mathematical puzzle which consists of three rods and n number of discs of different diameters all the discs are placed on one rod one over the other and in ascending order of size similarly into a cone-shaped tower now we will enter into the next segment where we will discuss about queues so what exactly is a queue a queue is a linear data structure that follows the fifo order that is the first and first out whereas stack followed first in last out so this is one of the fundamental difference between stacks and queues so we'll be discussing those in the next section for now let's continue with the operations on queue the queue is an ordered list in which insertion is done at one end that is called here and deletion is done at another end which is called front the operations on queue are enqueue operation that adds a new item to the queue if the queue is complete then there is an overflow condition dq operation is the operation which deletes an item from the queue and if the queue is empty then there is an underflow condition through it as an exception now let us understand some of the basic examples of q you can consider the patients at hospital registration and you can also consider an example of customers making use of atm now let us understand the types of queue so there are basically three types of queues those are circular queues doubly ended queues and priority queues now let us understand the circular queue in a circular queue the last element points to the first element to form a circular link circular queue is also known as ring buffer insertion is done at the rear and deletion is done at the front as discussed before now we will go through the doubly ended queue in doubly ended queue both insertion and deletion can be done at both rear and front of the queue now the last one the priority queue in the priority queue the notes have same predefined priority insertion can be done as the arrival of the nodes node having the least priority will be the first node removed from the queue now we will go through a general practical example of queues and then we will go through the applications of queues now on my screen you can see an example for queues don't worry about the code this code will be attached in the description box below and you can always have access to it and learn executing this on your own system so without further ado let's start to execute this code so you can see that the code got successfully executed and the terminal is asking for us to give an operation so the first one is to insert an element into the queue second one is to delete an element and the third one is to display the elements in the queue and the fourth one is to quote let's insert so now let us insert an element into the queue that is 10. now let's try to display the elements in the queue for that i need to select the option number three and there you go the queue has element number 10. now let's try to delete that element for that we might have to choose the second option so you can see that the element got deleted from the queue and the element deleted from the queue is 10 and you have another choice now so let's try to quit it now so that i need to select the option for because we have seen how to insert view and delete the element let's not make further delay and let's quickly enter into the next part of our session that is the application of cues so the first application of queue is breadth first search breadth first search or bfs traverses a graph in a breadthward direction and uses a queue to remember the next node to start a search the second application is level order traversal entry level order traversal processes all the nodes of a tree by depth first the root then the children of the source next one is first come first serve cpu scheduling first come first serve fcfs is an operating system algorithm that works on cued requests and implements them according to their arrival now the fibonacci fibonacci heap is a data structure that implements priority queue operations consisting of the collection of heap order trees now our last segment that is the comparison between stack and queue so at first both stack and queue are linear data structures and stack follows last in first out whereas q follows first in and first out and when you are considering stack the insertion takes place at the top and deletion takes place from the top as well whereas when it comes to stack the insertion starts from rear but deletion or elimination of the element from the queue starts from the front in stacks the insert operation is called as push and deletion process is called as pop in queues the insertion is called as enqueue and deletion is called as dq in stacks you mainly maintain one pointer to access the list that is called top which always points to the last element present in the list in queues we maintain two different pointers the first one is the front pointer which always points to the front element or the first element inserted in the list and the next one is the rare pointer which always points to the rare or the last element inserted into the list stack is used in solving problems that work on recursion whereas q is used in solving problems having sequential processing so these are the fundamental differences between stacks and queues what is a tree data structure so what exactly is a tree data structure the tree is a non-linear data structure that consists of nodes and is connected by edges i know it's a little difficult to understand just by the definition so let me show you the pictorial representation as you can see we have the elements that is 10 20 30 40 50 60 and 70 and all these are stored in the tree data structure they are stored in a non-linear structure if we had used arrays it would have been in a linear consecutive way where 10 starts first and 70 ends at the last position now in the next section we will discuss why we had made to a switch to the tree data structure when we already had a linear data structure that is airy now the next topic that is why we need tree data structure so there are many reasons why we have switched into tree data structure and one of the reason is a linear data structure always stores the elements in a sequential form that is one after the other and in operations to be performed in linear data structure the time complexity increases as the data size increases you can see here that as discussed before the elements are stored in a linear form that is 10 at the first place and 70 at the last place imagine you wanted to access the element 70 then using the traversal you had to start from the first position that is 10 20 30 40 and slowly at the end is 70. so accessing that particular element is really time consuming we are facing this just for 70 elements imagine if we had 700 elements right so that is exactly why we had made a switch to tree data structure and using tree data structure we have many advantages as the tree data structure is completely non-linear and it allows easier access and quicker access of the data elements how is that possible we will look into it into the next segment where we will discuss about the traversal of trees now before we understand the traversal of trees we should understand another important topic that has the terminologies of tree so the first one is the node node is the entity that contains the keys and pointer to its child nodes so here you can see that the elements a b c d e f and g are the elements so each and every element or the blue dot is called as a node and the blue dots here are one two three four five six and seven so we have seven blue dots so we have seven elements here so you can see the line between each elements right so this particular line is called edge now we'll discuss about the edge in the next part so the connecting links between any two nodes are called as edges so we discussed about the nodes right where the element is stored the blue dots are the nodes and the lines connecting between the elements or nodes is called as the edge so out of all the nodes this first node that is the element a is called as the root node in a tree data structure so indirectly root node is also called as the parent node of all the nodes now we will understand what are parent nodes and children nodes so in a tree data structure the node that is the node's predecessor is called as parent node so here we have discussed that a or the root node is the parent of all nodes so for a b and c nodes are children nodes and for b and c nodes a happens to be the parent node similarly d and e are the children nodes of b and f and j are children nodes of c and the nodes d and e have b as the parent node and the nodes f and g have c as the parent node now followed by that we will understand the descendant node so as discussed before the descendant node is the node that comes after the parent node here the b and c are the descendants of a and d and e are descendants of b and similarly f and g are the descendants or children of the node c so in a tree data structure the node which does not have any child is called as the leaf node now at the end we have d e f and g so these particular nodes do not have any children nodes like b and c so these particular four nodes which do not have any children are called as the leaf nodes in a tree data structure the node with at least one child node is called as the internal node so here the internal nodes are p and c which have at least one child in a tree the total number of children of a node are called as the degree of that node so in this particular diagram the degree of root node is 2 because it has 2 child nodes and the degree of b is 2 as it has 2 child nodes similarly the degree of c is 2 because it has 2 child nodes but when it comes to d e f and g the degree is 0 because they do not have any child nodes in a tree data structure the root node is said to be at level 0 and the children of the root node are said to be at level 1 and the children nodes of the level 1 are at level 2. so to understand this let's go through the diagram as you can see this particular root node is called as level 0 and followed by that we have the children nodes of a that is b and c and that level is called as level 1 and followed by that we have level 2 and if this tree goes forward the levels also increase accordingly in a tree data structure the total number of edges from a leaf node to the particular node is the longest path and this particular path is called as the height of that node now here we have our general tree data structure and here you can see the height of node a s2 and the height of node b and c together is at 1 and the height of the last leaf nodes happens to be 0. next in the tree data structure the total number of edges from the root node to a particular node is called as the depth of that node now in this particular tree data structure the depth of the root node is 0 and the depth of b and c together is 1 because the number of edges connecting to the node a from b is just 1 and similarly the number of edges connecting the node c from a is just one so the depth of both b and c is one now if we consider the last leaf nodes then the depth is two because if you see g is connected to a using two different edges similarly f is connected to a using two different edges and e and d also have two nodes to connect to a so the depth is 2 now in the next segment we will understand the tree node so the tree data structure has data part and references to its left and right child node in the tree data structure so here you can see this is the node and the node has three segments that is data element and the references towards left child and the references to its right child now there are four different types of trees the first one is the binary tree followed by that we have the binary search tree then we have avl tree and finally we have the b3 let us discuss each one of them the first one is the binary tree a binary tree is a tree data structure in which each parent node at most has two children so in this particular tree we'll have at most two children that means it might have one or more than one but not more than two children per node moving ahead we have the binary search tree so a binary search tree or a bsd is a tree data structure in which each node has a maximum of two children all nodes of the left subtree are less than the right node all nodes on the right subtree are more than the root node so here you can see the image or the gif which represents the image of a binary search tree so here all the nodes of the left subtree are less than the root node and all the nodes of the right subtree are more than the root node the next type of the tree is the avl tree the avl tree got its name after inventory georgie adelson welsky and landis avl tree is the self-balancing tree in which each node maintains a balanced factor most value is either one zero or minus one balance factor is equals to height of the left sub tree minus height of the right subtree or height of the right subtree minus height of the left subtree so in this particular image you can identify it is an avl tree and now the last type of tree that is the b3 b3 is a special kind of self-balancing search tree in which each node can contain more than one key and can have more than two children b3 is also known as the height balanced m way tree now in this particular gif we can see how a b tree looks like now followed by this we will discuss the tree traversal so traversing a tree helps to visit required node in the tree to perform specific operations tree traversal can be performed in three different ways the first one is the pre-order traversal where we visit the node and visit all the node from the left side then visit all the nodes from the right side so this particular gif is an example for pre-order traversal where we visit all the left side nodes first then we visit the right side nodes now we will move ahead into the next type of traversal that is the in order traversal first we visit all the nodes from the left side then we visit the root node and then represent all the nodes from the right side so this particular gif will be an example for the in order traversal where we visit all the left side nodes and then we visit the root node and followed by that we will visit the right side nodes and the last type of traversal is the post order traversal where we visit all the nodes from the left side first then revisit all the nodes from the right side and finally visit the root node so this particular image on the right side is an example for post order traversal now before we get into learning the applications of trees we will try to execute one example based on the post order pre-order and in order traversals and tree data structure so you can see that we have an example on my screen right now so here we have the node structure then we have the in order traversal function followed by that we have the pre-order traversal function and finally we have the post order traversal function now let's quickly run this program and see the output and don't worry about the code this particular code document will be attached in the description box below and you can have access to it now we have the run option over here and the program got successfully executed you can ignore this warning and here we have the in order traversal of the tree and the first output then we have the pre-order traversal of the tree and finally we have the post-order traversal of the tree now let's discuss the last part where we will learn the application of trees so the application of trees are as follows binary search trees are used to quickly check whether an element is present in the set or not then we have the most popular database usage of b3 which is a variant of tree data structure then we have the modified version of trees called as trice which is used in the router to store routing information and finally the compiler uses a syntax tree to validate the syntax of every program you're right what is tree traversal in data structure tree traversal is a process of visiting each and every node in a tree data structure so right here on my screen we have a tree with different nodes that is a b c d and e so here we will be visiting all the nodes one after the other using the tree traversal methods now that we have a brief understanding of what exactly is a tree traversal process let's get into the next topic of our discussion for today that is the data structure used for tree traversal in a tree data structure there are primarily two data structures utilized for tree traversal the first one is the start data structure and the second one is the queue data structure a stack is a linear data structure that operates on the last in first out lifo principle there is only one pointer in the stack that is the top pointer which points to the stack's topmost element only the top of the stack is used for insertion and deletion now the next one is the queue a queue unlike stacks is open on both the ends the one end is always open and used only for input and the other is only used for deletion or elimination the principle followed in queue is first in first out or fifo approach followed by that we will look into the different types of tree traversals in data structure tree traversal can be done in the following ways the first one is breadth first search and the second one is the depth first search first let us have a look at the breadth first search algorithm or breadth first search traversal we follow level order traversal in breadth first search breadth first search traverses notes by level instead of subtrees first we visit the root node followed by the root node we visit the left sub tree of the tree then followed by the left sub tree we finish the right subtree of the entire tree after that we go until the leaf nodes of the entire tree is found the second one is the depth first search in depth first search we traverse three data structure in three ways that is pre-order traversal in-order traversal and post-order traversal let us take a look at how these traversals are carried out first let us discuss the pre-order traversal we traverse the root node first in the pre-order traversal then we traverse through the left subtree and finally we traverse through the right subtree then there is in order traversal in order traversal involves traversing of the left subtree first followed by that we enter the root node then we visit the right sub tree lastly we have the post order traversal so post order traversal involves traversing of left subtree first then the right sub tree and finally we visit the root node now next we will have a look at some of the important applications of tree traversal in data structure so we use tree traversal in data structures to build a prefix expression or polish notation from expression trees then utilize the pre-order traversal and then traverse the expression tree in a pre-orderly manner a binary tree's postfix representation or reverse polish notation can be generated using post order traversal because it returns values from the underlying set in order according to the comparator setting up the binary search tree in order traversal is often employed on binary search a complete binary tree can be deleted or released when deleting or freezing nodes and values in the post order traversal now next we will see an example based on tree traversal in data structures so on my screen we have an example for tree traversal in data structure to begin we have included the enum or user specified data type traversal it mostly used to give integral constant names which make a programmer easier to comprehend and maintain we defined three variables in the enum data type that is pre-order in order and post order traversal we can define the type that can take one of the two values by using the typedef and enum keywords we have a traversal data type with trap variable and a node data type with node variable then we define the node using the data structure type as struct node we declare one variable x and two nodes as a left and right nodes respectively in this node section we then attempted to create node using the create node function passing the root node as an argument in this code we use a malloc function to create a node assign data to x and null to both the right and left nodes before returning to the root node if node t is not equal to null we simply return it otherwise we will use the released tree function to release the left and right nodes and if neither is a root node then we will use the free function to release the node t which will behave as the root node then we define the display tree function which takes the trap variable and the root node as parameters there is a condition in this function that is if the root node is not null we will return the root node then using the switch case scenario we attempted to traverse the tree using all three types of traversals we utilize a trav variable in the switch function so if any of the inorder pre-order or post order variables match the trap variable the traversal will be executed then we created a tree using the create tree function which takes a data variable as input in the create tree function we used a malloc function to create the root node and we first assigned a null to the left and right nodes as well as the data to the variable x before returning to the root node we first traverse the root node then the left subtree and finally the right subtree in the preorder traversal case in order traversal case we first traverse the left subtree then the root node and finally the right subtree and in the post order traversal case v traverse the left subtree then the right sub tree and finally traverse through the root node and finally we exit the display tree function and move on to the main function we assign the values 5 as the root node then 10 20 and 30 as the left nodes and similarly 15 25 and 35 as the right notes and then we call the three tree traverses that is pre-order in order and post order to traverse the tree and finally we release the root note now let us try to execute this program and see the output so there you go the program got successfully executed and you can see that the output has been displayed on my screen so the pre-order traversal is 5 10 20 25 15 30 and 35 followed by the pre-order traversal we have the in-order traversal that is 20 10 25 5 30 15 and 35 and finally we have the post order traversal that is 20 25 10 30 35 15 and 5. and with that let me give you a simple question so what is the pre-order and post-order traversal of this binary search tree so the elements are 1 2 3 4 5 six and seven you need to find out the pre-order and post-order traversal of this binary tree and you can let us know the answer in the comment sections below what exactly is a binary tree so it is a treated structure in which each node can have at most two child nodes these nodes are referred to as left child node and right child node next let's discuss about some terms related to binary tree first up a node a node consists of data and a link towards both child nodes next the root node root node is the first node of the tree next leaf nodes these are the nodes which has no child next parent node apart from the root node any node which has at least one child is called as parent to that child node next up a child node any node with a parent is called as a child node next up is the internal node any node with a child and a parent is called as an internal node next up is the height of the binary tree the longest path from the root to any leaf node is called as the height of the binary tree next up is the depth of the binary tree the depth of the node is the total number of edges from the root node to the target node or the last child node now let's try to implement the binary tree in the code editor as you can see now we are on the code editor and the code on my screen is an example for binary tree now here you can see that we have created a structure for node followed by that we have a function where we will print the tree and this is our main function now don't worry about the code this particular code segment will be available in our description box below and you can always have access to it and try to edit and run this code on your own local system to have a better learning experience now without further ado let's try to run this program quickly and see the output so there you go the code got successfully executed and here you can see the output of this particular binary tree now let's get back to the theory part so as discussed before followed by the implementation part we will learn about the properties of a binary tree now let's discuss the properties of the binary trees first up maximum number of nodes at a level l is 2 to the power l next up maximum number of nodes in a binary tree of height h is equals to 2 to the power of h minus 1. next up minimum possible height in a binary tree with two nodes is equals to log of l plus 1 base 2. next up the minimum possible level in a binary tree with n nodes is equals to log of l plus 1 base 2. finally a binary tree with l leaves has at least log l base 2 plus 1 levels now let's discuss about the different types of binary trees first up we have the full binary tree followed by that we have the complete binary tree then we have the perfect binary tree followed by that we have the balanced binary tree and lastly the degenerate binary tree let's discuss about these in detail first up full binary tree a full binary tree is a unique tree data structure in which a node can have either two children or no child next a complete binary tree so a complete binary tree is another specific binary tree where each node on all levels except the last level must have two children and at the lowest level all leaves should reside possibly on the left side the next one is the perfect binary tree a binary tree is perfect if every node must have two children and every leaf is on the same level the next one is called as the balanced binary tree a binary tree is balanced if for each node the height of the left sub tree and the height of the right subtree varies at most by just one at last we have the degenerate binary tree a binary tree is said to be degenerate if every internal node has only one child we have now discussed the binary tree some terms and properties related to binary trees and types of binary trees now we will look into the operations that needs to be performed on the binary tree so there are basically three types of operations that can be performed on binary tree which are traversal insertion and deletion so first we'll look into the traversal operations there are three different types of traversal operations possible on binary tree which are pre-order traversal in order traversal and finally the post order traversal now let's get back into the text editor mode and try to execute our example so right now we are on the text editor and this particular code is for the traversal operations on our binary tree and here you can see we have the structure for node and we have also the in order function pre-order function and post order function don't worry about the code this particular code will be available in the description box below and after you have written the code we have some standard input over here you can see that we are giving the number of edges as four and the left subtree elements are two and one and the right subtree elements are two and three and another left subtree elements are three and five and lastly we have five and 6 for another left subtree now let's try to execute this code now we have already executed the code and we also have the output over here and here you can see we have entered the number of edges as four and the traversal is inorder traversal which is one two six five and three and the pre-order traversal output is two one three five six and the post order traversal is one six five three and two now let's get back to the ppt now we have the insertion operation and now let's get back to our text editor and try to see an example for insertion operation as well so on my screen you can see an example for insertion operation so here we have the insert function as i said this particular code will be available in the description box below now let's provide the standard input so the standard input will be four edges and we have two and one as the left subtree and two and three as right subtree three and five as left subtree again and five and six as the left subtree now let's quickly run this code and there you go the program got successfully executed and here we have the output the nodes got inserted and it has provided an in order traversal that is one two six five and three now let's get back to the presentation and the last type of operation is the deletion operation let's quickly execute an example based on deletion operation as well now as you can see we are on the text editor again now here the example is for deletion operation we have the delete function over here now for this particular program we don't need any standard inputs so just let's run the program so there you go the program got successfully executed and we have the output over here and in order traversal before deletion and in order traversal after the deletion of an element so the deleted element is element 11. now with that let's get back to the presentation mode again so that's how the element got deleted now we have reached to the last part of this session that happens to be the final key takeaways so what are the final takeaways so binary tree is faster at search operations than other type of tree and it is easier to find maximum and minimum elements in the binary tree binary tree does not allow duplicate values and graph traversal is done using binary tree it is used to convert the post fixed expressions into the prefix expressions let's get started with introduction to binary search tree binary history is a set of nodes organized in such a manner that they all have the same binary search tree characteristics a key and a value is assigned to each node the requested key is compared to the keys in binary search tree so during search if the key is found then the corresponding value will be retrieved next up properties of binary search tree first up the left sub tree of a node contains only nodes with keys lesser than the parent node next up the right subtree of a node contains only nodes that are greater than the parent node the left and the right subtree each must also be a binary search tree next let's discuss what are the operations we can perform on a binary search tree first up insertion last deletion let's discuss them in detail first up insertion we can insert a node in such a way so that we obey binary search tree rules that is the new node should be either less than the parent node if it's a it's on the left sub tree or if it's on the right subtree it should be greater than the parent node let's execute this in the code editor we will start by creating a class for the binary search tree so class pst print data and bst pointers left comma right next we will define some functions publicly public first default constructor and a parameterized constructor a function to insert the value and a function to traverse the node now let's write default constructors definition so bst psd now let's write the parameterized constructor's definition bst and value data is equals to value and left is equals to null and right equals to null now let's write the definition for the insert function so bst star root comma and value now we will check if the tree is empty or not so if root then we will insert the first node we will return new psd value otherwise we will insert the data so if the value is greater than root tata and then we have to insert it in the right subtree so root right is equals to insert root right comma value else else the value should be inserted in the left side so root left is equal to insert root left comma value and then we will return root now let's write the traverse function so void est if root and we will return otherwise we will first traverse left side then we will print the root data then we will traverse the right side root right now let's write the main block so we will start with an empty tree so bst b comma star root is equals to null the root is equals to b dot insert root comma 50 e dot insert equals to root comma 10 b dot insert 50 sorry we already use 50 so we will use 60 a dot insert root comma let's use 20 let's try to traverse this so b dot traverse root let's execute this as you can see we have successfully created and traversed our first binary search tree let's get back to slides at last deletion we will delete a node following the binary search tree rules that is the value of the left subtree should be less than the parent node and the value of the right sub tree should be greater than the parent node let's try these in the code editor let's start by creating a node this time we will use structure so struct node node star left comma right now we will create a utility function to create a new binary search tree node substruct node star new node and item or star amp equals to product size of next amp will be assigned the key is equals to item amp left equals to null and damp right is equals to null now let's write a function to traverse the tree traverse product node star route so if root is equal to null traverse root left see out root e covers right now let's write a utility function to insert the new node with the given key in the binary search tree substruct node star node comma and key so if node is equals to null then we will return new node key otherwise we will recur down the tree so if e is less than the node key then we will insert in the left subtree so node left is equals to insert mode left comma key else node right would be inserting e now let's return the note now we have given a non-empty binary search tree so we have to return the node with the minimum key value found in that tray so we will start extract star men value node star mode node start current is equal to node so we will loop down to find the left most leaf so while current and parents left is not equals to null so current should be equals to current return current node star delete node note star loop comma and key f root equals to null return root now if the key to be related is smaller than the roots key then it lies in the left subtree so we will check if e less than root key then root left it will be equals to delete node root left key comma key now if the key is deleted is greater than the roots key then it lies in the right subtree so else if e is greater than root root right is equals to delete node root right comma key else if roots dot left equals to null and root dot right is equals to null and return else if root that equals to null then struct node start is equals to root right and free root return temp else if roots right is equals null then stripped outstar temp is equal to root three root return temp now note with the two children get the in order successor smallest in the right subtree so struct node star temp is equals to min value node right now we will copy the inorder successors content to this node so root is equals to temp now we will delete the inorder successor so root right equals to delete code root right comma template now we will return root now let's write the main block we will start with an empty tree product node star route is equal to null now root is equals to insert root comma two route is equals to insert root comma 5 root is equals to insert root comma 3 root is equals to insert root comma 4 root is equals to insert root comma seven and root equals to insert root comma six let's try to traverse this so c out traversal of the given i was root now first we will delete a value c out delete two our root is equals to delete node comma two see out traversal after deleting traverse root let's execute this as you can see we have successfully deleted to and traverse the tree again let's get back to our slides at last let's sum up what we have learned from this session first up left side nodes are always lesser than the parents node and the right side node are always more than the parent node next it is easier to search and sort elements in a binary search tree finally a binary search tree offers faster insertion and deletion operations what is a b plus tree a b plus tree is a special m by tree data structure a b plus tree of order m can have at most m minus one keys and m children a b plus tree can be used as b tree with only keys to each node and with linked leaves to which an additional level is added at the bottom now let's discuss some properties of b plus trees first up every node in b 3 can have at most m elements next every node except the root and the leaf node must have m by 2 children next maximum keys for any node is m minus 1 and at the last minimum keys for any node is ceiling of m by two minus one now let's discuss what are the various operations we can perform on b plus three we can perform two operations on a b plus tree first up insertion second deletion now let's discuss these in detail first up insertion we have to insert an element is in such a way so that we won't disobey any properties of b plus trees now let's try this operation in a code editor we will start by creating a node to create a node we need a struct b plus tree node and star data b plus tree node space star child btr boolean leaf and end and for the object star root will be equals to null star and p pointer will be equals to null comma star x will be equals to null now we will write a constructor for it so b node star highlight and i and p equals to mu b plus tree node np arrow data is equals to new space and bracket 5. nnp child ptr is equals to new b plus 3 node star bracket sex and belief is equals to true and then p at the is equals to zero now we will write a for loop i is equals to zero i less than six i plus plus np child is equals to return traverse b plus 3 node star b out and i again upon do from i equals 0 to i less than p at n i plus plus f p doesn't have leave then we will traverse that child traverse child patient bracket high see out p data at i now we will check these conditions again for i at t at n we will traverse it again from p child at i see out and now next function will be used to sort this so void sort and for loop a equals to pi j less than equals to n j plus plus f p bracket i greater than p bracket j then we will swap these two so temp will store p at i and then p will replace its value with p at j now we will store the temp value in the pfj now let's write a function to split this child and set child e plus 3 node star x comma and i and j made b plus 3 node star np1 comma star np3 comma star y and b3 is equals to init and p3 equals to true f i is equals to minus one mid is equals to x data bracket 2. x data bracket 2 will be equals to 0 then x will store n minus minus p1 is equals to finite now when p1 leave will be equals to false and x leaf is equal to true for loop j is equals to three j less than 5 j plus a minus three will be equals to x data j 23 child peter at j minus 3 is equals to x at child ptr record j np3 and plus plus x data bracket j is equals to zero now x greater than n minus minus another for loop from j is equals to zero with j less than six at j plus plus rate x child ptr a j will be stored at null now np1 data at zero position will be equals to mid np1 child ptr at np1 on will be equals to x and p1 child at np1 on n plus 1 will be equals to np3 even call n plus plus root is equals to np1 now else y is equals to x child ptr at i at 2 and y on data at 2 is equals to zero i will store n minus minus now for loop j is equals to three j lesson 5 j plus plus np3 data j minus 3 is equal to y data a and p3 and plus plus y data bracket j is equal to zero why and minus minus x child ptr at i plus 1 is equals to y x at child ptr i plus 1 is equals to np3 return now we will write a function to insert into the tree void insert argument as end a so end i comma temp x is equal to root if x equals to null then root is equals to finite and x will be equals to root otherwise if x is a leaf and x at nine feet and exit n is equals to five and temp is equals to split child x comma minus 1 x is equal to root f a is greater than x and a is less than x at data i plus one i plus plus and break else if a is less than x data zero then break else continue x is equals to x at child at i else hex leaf is false for loop i is equals to zero when i is less than x at n i plus plus if a is greater than x at tata i and a is less than x and data i plus one a plus plus break else if a is less than x data break else continue if x child at n is equals to five that temp is equals to split child at x comma i x data at x and on n is equals to temp x at n plus plus continue else x is equals to x child right here i x on data at x at n is equals to a sort hex at data exit n x at n plus plus now let's write the code for the main block first we will declare some variables as and i n and d now we will request enter number of element to be inserted in pattern now c out now we will enter the element so enter the element now we will write a for loop so i is equals to 0 to i less than n at i plus plus so c n d and insert d now we will traverse this tree we'll see out traverse cell of b plus 3 traverse route let's execute this we will enter five elements two comma three comma five comma seven comma nine as you can see we have successfully traversed our first b plus tree let's get back to our slides next deletion while deleting any element from b plus 3 we have to be careful not to break any properties of b plus 3. like all the leaves must be present at the same level or elements must be in ascending order now let's try these operations in a code editor let's start by creating a b tree first we will declare a global variable and max equals to 3 then we will create a class pp tree and a class node boolean is leaf and start key comma size load star star ptr and a friend class now public load variable now we will write class pp void insert kernel and node star comma node star void remove internal paint comma node star comma node star and a node function find parent now public pptree the constructor a search function insert function void remove void display get root is equals to new and bracket max is equal to new node star record max plus one a bp tree this tool now void with bp tray insert and x if rule is equals to null then root is equal to new node root calls key at 0 0 root checks its leaf ice is equals to one else node cursor is equals to root node star parent wife cursor is leave is equals to false parent equals to cursor now for loop and i is equals to 0 to i less than cursor size i plus plus f x is less than cursor key at i cursor is equals to cursor at ptr at i if i is equals to cursor -1 cursor break now if person size is less than max then end i is equals to 0 while x is greater than cursor e set i and i is less than cursor size i plus class for loop and is equals to cursor at size and j is greater than i a minus minus so cursor calls key at j is equals to cursor pulse key at j minus 1. cursor calls key at i is equals to x cursor calls size plus plus pressure calls ptr add cursor size is equal to cursor ptr at cursor size -1 now cursor at ptr cursor size minus one cursor ptr equals else node equals to new and virtual node max plus one for and i is equals to 0 to i less than max at the rate i plus plus so virtual node at i is equals to cursor hair dye while x is greater than virtual node mercury i is less than max i plus plus for int j is equals to max plus one comma j is greater than i say minus minus virtual node let's see is equals to virtual node at j minus one so virtual node i is equals to x so new leaf s leave is equals to true cursor size is equals to max plus one by two new leaf size is equals to max plus one minus max plus one divided by two pressure nice is equals to new leaf new leaf new leaf size is equals to cursor ptr max now void bp tree insert internal x comma node star cursor comma node star child f cursor size is less than max then end is equals to zero while x is greater than cursor at key at i and i is less than cursor of size i plus plus for loop and j is equals to cursor size a is greater than i j minus minus cursor at key at j is equals to cursor a minus one cursor key cricket eye is equals to x cursor size plus plus cursor at ptr bracket i plus one is equals to child else node star internal is equals to new node and virtual key is max plus one node star virtual key at max plus one virtual ptr at is equal to zero i less than max i plus plus virtual key i is equals to cursor key foreign and i is equals to zero i less than max plus one i plus plus virtual dtr i request to cursor ptr at eye node star pp tree find parent node star cursor comma node star child star parent if cursor is leaf or cursor at atr zero yes then return none for loop i less than cursor size plus one i plus plus f child return parent else parent is equals to find parent cursor here if parent not equals to null return return now void repeat remove and x if root null then see out empty else node star cursor refers to root star parent and left sibling comma right sibling so while cursor is leaf equals to false so for i is equals to zero i less than cursor size and i plus plus current is equals to cursor left sibling is equals to i minus one right sibling is equals to i plus 1 if x is less than cursor is at i then cursor will be equals to cursor ptr now if i is equal to cursor size minus one equals to i plus 2 cursor is equals to cursor bracket i plus one click is equals to false zero force is less than cursor size force plus plus f cursor key at force is equals to x then found equals to true and then break if not found not done now if cursor size equals to zero then see out right delete cursor late cursor pdf delete cursor root is equals to return for loop and i is equals to cursor j less than right node size i plus plus comma j plus plus cursor key at i is equals to right node pressure and cursor size first tuner now see out merging remove internal at right sibling minus one comma parent comma right node delete write node key write node right now avoid e3 display if cursor is not equals to null for y equals to one i less than cursor size i plus c out handle if cursor is leave not equals to true and for and i equals to zero i less than cursor size plus one ptr now node star bp3 get root return root now we will write the main block we will start with an empty tree pp tree node now node dot insert five node dot insert 15 node dot insert 25 node dot insert 35 dot insert dot display dot get true node dot remove 15 dot display dot root let's execute this as you can see this program is working flawlessly we have successfully deleted the key 15. let's get back to our slides at last let's sum up what we have learned in this session first of b plus trees are fast at performing all its operations next all the leaves must be present on the same level and data is only stored in leaf node next elements of the b plus tree are sorted in ascending order from the left to the right finally every node contains one more pointer than the number of elements of the node a brief introduction to graphs so what exactly is a graph so a graph is a data structure like any other data structure example linked list arrays etc so graph is a little different from the other types of data structures such as linked lists and arrays they are linear data structures whereas graph is a non-linear data structure that consists of finite sets of vertices and a bunch of edges connecting with them so what are these vertices and edges so let us understand that a graph is usually represented by a set of vertices and edges so a vertice is the node present in a graph imagine that you are a group of five friends so each one of you is considered as a vertex and the network connecting you guys is known as an edge so the overall graph of your people can be considered as g and it is represented by vertices and edges set where vertices is you and the network connecting you guys is called as an edge so here you can see it clearly each one of the friend is called as a vertex and the network connecting them is called as an edge and the entire graph is represented using a set of vertices and edges now moving ahead we will understand the graph terminologies now at first we have the adjacency vertices and adjacency edges so what are adjacent vertices if there is an edge between two vertices that is one vertex or one node is connected to another node directly using just one single edge then those vertices are called as adjacent vertices now what are adjacent edges if there is one common vertex between two edges then those two edges are called as adjacent edges let's imagine this way let us imagine that we have three vertexes and these three vertexes are connected using two edges so here we have one vertex which is common between these two edges so such type of edges are called as adjacent edges next we have the degree in an undirected graph number of vertices adjacent to the vertex is called as a degree next is the path the path is considered as a sequence of distinct vertices such that two consecutive vertices are adjacent to each other up next we have the cycle a path that has only one repeated vertices are called as first and last vertices followed by that we have the work the term block is self-explanatory a work is the sequence of vertices and edges in the graph which is used to traverse through one vertex to another vertex now we have entered the next segment of this particular tutorial where we will be discussing the different types of graphs available so at first we have the finite graph so what exactly is a finite graph a graph is said to be finite when the number of vertices and the number of edges are in a finite number or in a countable number now the next type of graph is the infinite graph so what exactly is the infinite graph so the infinite graph is a typical opposite of the finite graph so this particular graph will not have countable number of edges and countable number of vertices the image here is an example for a typical infinite graph now followed by the infinite graph we have the trivial graph so what is a travail graph a graph is said to be trivial if there is only one single vertex without any edges so this particular type of graph will only have vertex that is only one single vertex not more than one and there will be no edge if you have just one vertex then there is no possibility of having an edge unless if you have one single loop type of edge which is connecting to itself but in a trivial graph we don't even have that we just have one single vertex so followed by trivial graph we have a simple graph so what exactly is a simple graph a graph is said to be simple if there is only one and one edge between each vertex so this particular example can be considered as a simple graph so here each and every set of vertices have one single edge between them now followed by the simple graph we have the multi graph so if there are multiple edges between the pair of vertices then this particular type of graph is known as a multi graph so here you can see that we have two vertices a and b and we have two edges connecting them not one but two but in a simple graph we were supposed to have just one edge connecting the vertices so this is the difference between simple graph and a multi graph so followed by multi graph we have a null graph so what is a null graph a graph is said to be null if there are only vertices and no edges between them so remember the trivial graph right we just had one single vertex but no edges but here we do have multiple vertices but no edges connecting them so this type of a graph is considered as null graph so followed by null graph we have the complete graph so what is a complete graph a graph is called as a complete graph where each vertex must be connected with the other vertices using the edges so the meaning of this particular type of graph is all the edges are connected to all the other edges using at least one single edge so here you can see a is connected to b d and c all together with at least one edge and similarly all other vertices are connected to each other with at least one single edge now followed by the complete graph we have the pseudograph so what is a pseudograph a pseudograph is a graph where at least one vertex will have self looping type of edge so remember the self loop or self edge we have discussed in the trivial graph type so this particular type of an edge where it connects to itself is called as a loop or kind of self connecting edge so any graph that has this kind of a edge is called as a pseudograph so followed by the pseudograph we have the directed graph so what is a directed graph any graph is called as a directed graph where each edge has a direction associated with it so so far we have just discussed the edges which are connecting to one or the other vertex but there was no direction but here you can see that this particular edge has a direction that is from b to a not from a to b it is from b to a this type of edges which are directing the traversal of the graph are known as the directed graphs now followed by the directed graphs we have the regular graph so a graph is a regular graph where each vertex of the graph has the same degree now here you can see all the vertices have the same amount of degree that is the connection between all the other vertices so the degree of a is 3 so the degree of b is also 3 and the degree of d is c and similarly the degree of c is also 3 so what i'm going to say is all of these vertices have the same degree that is 3. now we have the weighted graph so what is a weighted graph a weighted graph is where each edge holds some weight that denotes the traversal cost through those edges now here you can see that all the edges have a different weight the edge from a to b has the weight 5 and the edge from a to c has the weight 9 and the h from c to b has 2 and the edge a to d as eight and finally c to d as seven so all these values are the weight or the cost to traverse from a to another vertex flow so from a to b we have the cost five and a to see we have the cost nine and similarly c to d we have seven and so on now followed by the weighted graph we have the connected graph so what exactly is a connected graph a graph is said to be connected where each pair in the graph is connected followed by a connected graph we have the disconnected graph so it is a typical opposite of the connected graph a graph is said to be disconnected where each pair in the graph is not connected to each other now next we have the cyclic graph so a graph is said to be cyclic if it contains at least one cycle in a graph that is one complete traversal connection so a can be traversed again from traveling a to c c to d d to b and b to a again so this type of a graph is called as a cyclic graph now next we have the acyclic graph so it is the typical opposite of the cyclograph so here you cannot traverse to a again by traversing from a to c c to d and there is no connection between d to b so the complete cycle is not available here this type of graphs are called as acyclic graphs so moving ahead we have the graph representation so generally there are two different ways to represent the graph data structure they are using adjacency matrix and adjacency list so what is adjacency matrix so adjacency matrix is a sequential representation adjacency matrix is used to represent which nodes are connected to which node if there is an edge between two vertices then the value of the corresponding element of the graph is one otherwise zero if there is any weighted graph besides then zeros and ones we can store the weight of the edge as that particular number suppose that there is a connection between a and b and it is represented as a weight of five then there is a connection so we will use the connection as true but we will not represent it as one instead we will use the weight that is 5 to represent it as 5 not as 1. if there is no weight then we will represent it as 1 and if there is no connection then we will represent it as 0. now undirected graph representation so here you can see how we have represented a graph so there is no connection between a to a that is there is no loop so the value will be zero if there was a loop and if it was represented with a bit then we could have written a weight here since we do not have weight then the no connection is represented as 0 and a connection is represented as 1. we have a connection from a to b so we have represented as 1 and similarly to a to c so and so on now directed graph representation so the simple difference between the directed and undirected graph representation is we did not have a direction in the previous segment but here we do have directions so b is connected to a but a is not connected to b so we will write it as 0 because the control is traversing from b to a but not from a to b so we need to take care of the traversal of control so we are representing 0 and you can see from d to b we have one connection and the traversal is in the direction of d 2 b so we will have 1 there so here we have d and b so we have one so in that way we represent the directed graphs next undirected weight graphs so this was what we discussed before instead of zeros and ones we will represent the weight here so we do not have a connection between a to a so that is zero as usual but we do have a connection from a to b so we have represented it with a number that happens to be the weight of the edge and remember we do not have the direction here this is undirected weighted graph now if it were the directed weighted graph then we could have seen the direction and represented the number with the weight now after this let us look into the adjacency list so what is adjacency list adjacency list is a linked representation in this representation we maintain the list of its neighbors for each vertex in the graph every vertex of the graph contains the list of adjacency vertices area of vertices which have vertices indexed by each vertex number for every vertex the array element points to the linked list of the neighbors of the vertex so this might be a little complicated to understand so let us understand this using an example so directed graph representation implemented using linked lists so this is the directed graph we are using so you can see that a is not connected to anything so we have ended the address of next location as x but b is connected to a and c is connected to a similarly d is also connected to a so that is how we represent the directed graphs using linked lists next we have directed graph representation using array so a is not connected to anything so we have represented as 0 and b is connected to b as well as a so we have 1 there and c is connected to b so c is also connected to a so we have 2 there d is connected to a c and b so we have 3 there now we have the graph traversal so graph traversal refers to the process of examining each edge and vertex in a graph graph traversing can be performed in two ways the first one is breadth first search or bfs algorithm bfs starts traversing the graph from root node and exports all the neighboring nodes then it selects the nearest node and explores all the new nodes queue data structure can be used in bfs algorithm so the following image depicts the epfs algorithm working it shows us the nearest node first then it traverses to all the other nodes so followed by bfs algorithm we have the dfs algorithm that is the depth first search algorithm dfa starts traversing a graph from the initial node of the graph and then it goes deeper and deeper until it finds the node has no child then backtrack from the dead end towards the recently explored nodes stack is used for bfs algorithms so this particular gif image can be considered as the graph traversal which is performed using dfs algorithms so if you don't know much about dfs and vfs algorithms don't worry about that those particular tutorial videos are added in the description box below you can go through it and understand bfs and dfs algorithms in a much better way now we will go through some of the applications of graphs so some of the major applications of graphs are used in the websites google maps and social media websites like facebook and some security systems and also software programming understanding the importance of a spanning tree we will have a look at an application of the spanning tree to understand it better meet patrick patrick works as a head of the network administration department in an it solution company named as grey solutions being the head of network administration department patrick is responsible for managing his team to keep the organization's computer network up to date and operate it as intended network administration department coordinates and connects multiple systems in the company to a single network using multiple routers this network is called as local area network or lan which is created for the sole use of an i.t company but in the last few days something went wrong in the network management system which came to patrick's notice he observed that the network loop is formed in a routing system a network loop occurs when multiple routes carry information from the same source to various computing devices and due to this formation of a network loop the network connectivity started slowing down initially after a few hours the network connectivity completely went down and all the operations of the company stopped abruptly now patrick and his team needed to do something in order to resolve this problem permanently so patrick started brainstorming to find out an optimal solution to fix this problem one of patrick's teammate was good at data structures and he came forward with an idea to implement a spanning tree data structure for managing the routing connections he suggested replacing the old knives routing strategy with a minimal spanning tree routing after listening to this idea the whole network administration team started working on implementing a spanning tree while doing that they treated the network connection as a graph the routers and end devices like computers fax machines were treated as the nodes of the graph where the connecting wires carrying network signals were treated as the edges of a graph but before understanding how patrick's team was able to solve this problem using a minimum spanning tree let's first understand the basics of this data structure this will allow us to get a clear insight into how spanning tree solves network routing problems so let's start with graph and its different types basically a graph is a structure made of nodes and edges connecting them and there are three types of these graphs based on the types of edges the first is the undirected graph the second is the directed graph and the last is the connected graph let's understand these types completely in the upcoming slides the first type of graph that we are going to discuss is the undirected graph it is termed as a graph in which all the edges does not point to any specific direction in simpler words all the edges of this graph will be bidirectional as you can see in this particular graph you can move from any node to any other node and retrieve back as well next up is the directed graph it is a graph in which the edges point to a specific direction by this i mean in this type of graph you can only move towards a single direction for example you can traverse this given graph starting from a then b then c then d and finally e but here you cannot traverse back from e to a as this graph is unidirectional the last type of graph depending on its edge is a connected graph it is defined as a graph with a path from any vertex to any other vertex in the graph in this particular type of graph you can reach any vertex from any other vertex in a graph for example you can go to node b or d from node a and arrive back at a from either vertex b or d now moving ahead we will understand what a spanning tree is and how we can create it mathematically the spanning tree for any graph g having vertices v and edges e can be represented using superscript notation g dash having vertices v dash and edges e dash suppose we intend to create a spanning tree for graph g then our spanning tree g dash must follow a few constraints the first constraint suggests that the number of vertices for created spanning tree must be equal to the number of vertices of a given graph g further the edges of g dash should also be similar to the number of vertices in graph g minus 1. to understand this mathematical formulation clearly let's have a look at an example now for this given graph g we have to formulate all possible spanning trees remember a single connected graph can have multiple spanning trees until we fulfill the constraints mentioned earlier so for this particular graph g we have 5 vertices and 5 edges additionally each edge has been assigned with some cost or weight let's say this weight represents the distance between the connected two nodes to create the spanning tree g dash we need to ensure that g dash contains five vertices and phi minus one that is four edges hence for this graph we can create a spanning tree like this you can observe that we have eliminated one node in the spanning tree to remove the loop or cycle in a graph for this spanning tree one we have a cost or value equal to 10 and this cost is nothing but the summation of all edge weights now that we have created the first spanning tree for our graph g i would like to ask all of you to give this a try for that i am going to provide you with a short moment to generate all possible spanning trees for the structure that we are discussing right now you can also pause this video if you need more time in order to do that so now let's have a look at all possible spanning trees at a glance we have seen that the value for the first spanning tree was 10 and for this new spanning tree 2 it is 13. in this spanning tree the edge between vertices b and c is removed the next spanning tree looks something like this with cost 14. further we have spanning tree number 4 with a value 12. and finally we have the last possible spanning tree 5 with a value 11. out of all these spanning trees the value or cost for spanning tree number 1 is the least which is 10. thus this spanning tree will be called as minimum spanning tree i hope you are clear with the creation of spanning trees but how can we judge the number of all the possible spanning trees well for that you need to check the structure of your graph if the graph you have been given with is cyclic then the number of possible spanning trees will be equal to the number of vertices the cyclic graph is a graph in which you will have the same number of vertices and edges with a cyclic structure if the given graph is a complete graph then the number of possible spanning trees will be equal to v raised to v minus 2 where v is the number of vertices in a given graph you can say that the given graph is a complete graph if each pair of vertices is connected by the unique edge for this particular graph the number of possible spanning trees will be equal to the number of vertices that is 4 to the power of 4 minus 2 which is further equivalent to the square of 4. hence the number of possible spanning trees for this structure will be 16. moving forward let's understand some important properties of spanning tree we have already gone through some crucial properties while creating spanning trees in the previous section so primarily we will list all of them here the first property of a spanning tree conveys that a connected graph can have more than one spanning tree the next property states that the number of vertices in spanning trees must be equal to the number of vertices in the given graph whereas the number of edges is equivalent to the mod of v minus 1. the third property of a spanning tree says that the spanning tree must not contain any cycle if the structure that you have created as a spanning tree includes a loop or recycle then it's clear that you have made a mistake because no tree can contain a cycle and finally the fourth property is all about kayley's formula if the given graph is a complete graph then you can calculate the number of possible spanning trees using the formula v raised to b minus 2. the next property of a spanning tree conveys that a spanning tree can never be disconnected for example if you create a spanning tree for this given graph which is accurate and you erase one edge when you do that the structure will no longer be a spanning tree it can only be referred to as a disconnected graph the next property states that if the graph contains more than one similar weight there is a possibility of having more than one minimum spanning tree for example in this particular graph there are more than one edge having the same weights thus there will be two possible minimum spanning trees with the same cost that is seven this is all about the properties of spanning trees now that you understood what spanning tree is you would have also understood how it proves is an effective solution and that is exactly how patrick from our story solved his network issue in a few days patrick and his team changed the naive routing into the minimum spanning tree routing now the routing parts are managed by a minimum spanning tree to maintain cost effectiveness and to avoid any looping activity as we have already understood misty removes all the loops from a given graph and we also know that the whole network becomes the graph for which msc will maintain a minimal routing path hence the network system will never experience a network loop again due to this amazing initiative patrick and his team were appreciated by the whole organization this example clearly illustrates the importance of a spanning tree and why it is one of the most important algorithms in data structures now we will look into the different applications of spanning trees the first application that we are going to talk about is telecommunication network building if we want to build a telecommunication network for the whole city and we are putting different connection lines for each customer then we will have to deal with a huge cost this knife ordinary approach is not the best solution to build a connection line but no worries this problem can be resolved using the minimum spanning tree data structure in this case each customer will be treated as a vertex whereas the connection line will be treated as an edge [Music] the minimum spanning tree will give us the possible output for generating the telecommunication network no matter what type of algorithm you are building using machine learning techniques somewhere down the line you will be using clustering techniques quite liberally clustering and data preparation go hand in hand as many times you will be working at least initially with data sets that are largely unstructured and unclassified those data sets can not be classified using single neuron or classification methods so you use a clustering algorithm which utilizes a minimum spanning tree to create clusters or groups by mapping distances between data points the next application of a minimum spanning tree is image segmentation you must have observed that your face gets detected with the square shape while clicking images in selfie mode this scenario is happening due to the image detection algorithm developed on the camera system at the back end the picture gets fragmented into tiles of similar pixels with the help of a minimum spanning tree the last application of the spanning tree is its use in calculating the finance factors a correlation matrix can be created by calculating a coefficient of correlation between any two stocks this matrix can be represented topologically as a complex network and a minimum spanning tree can be constructed to visualize the relationships now with that we have come to an end of this session on data structures full course if you have any queries regarding any of the topics covered in this session or if you need the resources that we used in this particular session then feel free to let us know in the comment section below and our team of experts will be more than happy to resolve all your queries at the earliest until next time thank you stay safe and keep learning hi there if you like this video subscribe to the simply learn youtube channel and click here to watch similar videos to nerd up and get certified click here you