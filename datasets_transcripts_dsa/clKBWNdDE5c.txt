hi my name is pratik Naran and in this tutorial we'll be quickly revisiting many fundamental concepts associated with data structures like arrays Dynamic arrays link list stack Q hashmap priority q and much more not just that we will be also exploring Java's collection framework to use these data structures in solving problems and building real software we will do many Hands-On examples that will solidify your understanding of these Concepts but before we get started make sure to check out free master classes on scalers event page to learn from the best industry leading experts the link is in the description below also make sure you hit the Subscribe button if you haven't already all right so let's begin with the tutorial let us start by revisiting the concept of a data seure a data structure is a meaningful way of arranging and storing data inside the memory of the computer that is your RAM okay we are not talking about your physical memory we are talking about your volatile memory in which your algorithm will execute and it will do some certain operations like insertion deletion searching and removal of data we have different data structures and they are optimized for different kind of operations that we can do and different kind of orderings we can do on that data right so some of the data structures you might have heard about arrays Stacks cues hash tabls trees and graphs every data structure has its own uh properties own way of ordering data own way of implementing these operations we'll try to understand how these data structures are different and how we can use them in Java as well broadly speaking they are divided into two categories we have linear data structures we have nonlinear data structur there is one more category I would say we have associative data structures in which we store data in the form of key value pairs for example your hash Maps we will talk about hash Maps later in this course so linear data structures they can be of fixed size like a fixed size array or they can be dynamic that means they can grow and shrink in size for example your ER list your link list your stack your Q in nonlinear data structures we might have data structures which have a hierarchical structure for example your trees also have data structures which have Network like data struct for example this is a very high level overview of how data structures are classified but let us start by revisiting the importance of data structures in our real life so suppose you go to a grocery store and you find everything is disorganized then it would become very difficult for you to search for a given item but if your items are organized across racks and categories you will easily find a particular item that you're looking for right so keeping data organized makes certain certain operations like you're searching faster right similarly if you go to tickets and if there is no que then it would be very unfair for the people to wait randomly right but if people are organized on the basis of their priority the person who is coming first and he getting the T Q ticket first then it is called as fif ordering right similarly in data we might require fif ordering so Q is a data structure that provides us with this kind of a ordering right and let us look at one more example sometimes I go to a restaurant I say okay I want to order a burger then I quickly get an answer that the burger cost is rupees 100 what is happening for every item there is a value attached to it right so for every key there is a value right so the data can might be stored in the form of key value Pairs and this is where some other data seares like hashmaps come into the picture right another example could be that if I'm on my system and I'm locating certain files right I know that okay in this folder I have kept this kind of a data in this folder I have kept my PDFs in this folder in this drive I've have kept my pictures right what is your file system the file system is a tree like structure you start with your my computer you go to your drive then you go to certain folders and you find the files that you're looking for right you do not organize this data in the form of hierarchy and you so I'll search the whole computer it would be very inefficient for you and you will spend a lot of time searching for a given file right the file system is also an example of a three like data structure so that means we use data structures a lot in our daily life in building software application so in real world also the meaningful structuring of items helps businesses operate efficiently we saw the example of grocery store so similarly data structures allow us to execute certain operations like insertion deletion searching updates on the data very efficiently and that this data is stored inside the memory of the computer depending on the problem that we are trying to solve we select a suitable data structure that fulfills our requirements this is the goal of this video in this lecture we are going to understand how according to different requirements what data structure we will use and we will look at its implementation using Java Collections framework right now you might ask okay that's data structure what is an algorithm then algorithm is the main logic it is the step by step unambiguous set of instructions for solving a problem right we can Define algorithms for real life scenarios like making a pack of noodles you might say okay take a pan put two cups of water inside it boil something something that list of instructions is an algorithm to make a pack of noodles or maybe something complex like if we want to play a Ludo game or if I want to make an algorithm that suggests the best photo out of a set of photos we can devise an algorithm for that as so in real world from every U every deterministic action for example your washing machine a self-driving car all the actions your machines are taking that can also be expressed using an algorithm right in the software world all the apps that you're using photo editing app scrolling Instagram browsing Netflix uh in a cargo Hub sorting of shipments detecting collisions in games transferring money through UI ordering food there is an algorithm behind every action that we perform so that is why it is very important for us to learn data structures and algorithm right and when we combine data structures along with the algorithms we build products that can solve real life problems that is an importance of data structures and algorithms we'll start with arrays let us start with the array which is the simplest and the most widely used data structure I'm hoping most of you have must have worked with an array what is an array array is a linear collection of elements of the same type so this is true for Java other languages like python they also support heterogeneous array that means you can put different number different types of of data for example integer string float inside one array arrays are used to store multiple values in a single variable so let's say this is a container which is linear that means it will occupy linear block of memory for example if this address is 104 and this bucket takes four four bytes and the next address will be 108 next address will be 112 right so it is a linear block of memory right and this whole block of memory has a single name right and each each element if I want to access it can be accessed using an index the indexing starts with zero so I can say Okay I want to put something at array of Zer then I will say array of Z it is four if I want to overwrite it I will say Okay array of three it's going to be 20 so I can just overwrite this data and it will keep 20 here right each array location is accessed using an index the indexing starts from zero that is what we have just seen so we have the array name followed by the index this is how you access the ith location inside an array right now uh let us look at some examples of an arrays for example if I want to create an array of strings in which I'm calling the variable as bill payments I have uh defined three strings electricity mobile and credit card right and I have an AR of numbers I have defined four numbers here I have int followed by square brackets followed by name of the array this is a very simple way of creating an array but you can also create an array of fixed size where you have not given your data right in the previous scenario we have not defined the size size will depend upon how many um items we have initialized in this list right so you can directly initialize or you can first create a fixed size block you can okay I want an array that is able to hold five integers we'll use the new keyword followed by the data type and followed by the size so what happens it creates an array so if I talk about Java the variable ARR it most likely it goes into your back memory and the actual array that we have this this is created in the de memory right AR we call as a object reference ARR is holding the address of this array AR is going to hold 104 error is in the stock whereas this actual object it is in the Deep memory now we are updating the data at the I index we are actually storing 10 20 30 40 and 50 here this is how you create an array and all the array objects they have a length property added to it so if you say okay this is a cars area and I want to say cars do length this will give me okay how many objects are stored in this array or what is the size of this array this will give me four right the size of this array and using the length property I can also iterate over the aray right so I can okay let me go over every index from Zer till cars. length that means I'm iterating from 0 1 2 3 the length is four so I'm iterating over these indexes and I'll okay let me print every car I will print the ith object right that is one way of itating using the length property you can get the size other ways you can use a for each Loop or also called enhanced for Loop you can okay for every string value that is there inside my um cars array I want to go over that value and I want to print it that is another way of iterating over the complete array object then let's talk about the advantages of arrays they are very simple and they are very easy to use the insertion is really fast at the end of the because if you keep a variable that okay these positions are filled I want want to put something here you can simply say array of I equal to Value so that value will get stored here you can insert at the end of the array very fast and array element can be accessed in a constant time so if you want to get this element you can simply say okay give me the jth element so you can access any random element any random index in just order one time that is an advantage of an array but they also have certain disadvantages the thing is arrays have fixed size so once you cre an array okay new int of some size 10 cannot say I will make it 15 or I will make it 20 they have a fixed size they cannot grow in memory once they are allocated insertion in the middle requires shifting of the elements if you have inserted something let's say 1 2 4 6 8 and you okay I want to insert three what you will have to do you will have to shift these elements to the right then you can insert three in the middle it's going to take order of end time for doing the insertion right and second thing is since error requires a linear memory block such blocks might not be available if the error size is Big this is your HEAP memory and suppose certain portions of the Heap memory they are already used up right and suppose you want to create a very big array which might go like this now it is possible that such a linear block of memory is not available but this amount of memory is available in the Heap in chunks right so you might say okay some memory is available here some memory is available here some memory is available here that is where link list might perform better because link list does not need big linear chunk of the memory whereas error requires a big linear chunk of the memory right so for big errors it could be a disadvantage that such a linear block could not be present in the memory now array are used a lot in the real world for example this is a UI from a shopping website where I have to display these components right the type of bill payments I can okay each bill payment is a string so I have a fixed size array of bill payments in which I have defined all the categories right now you might say okay uh this looks very simple in actual World it might be a bit more complicated yes it can be what may happen is that each item is not just a string but it is a um something more complex let me call this as a payment category what I can do I can define a class called as payment category which hold three things maybe the category ID which is not displayed the category name and the image of the category right the URL of the image of the category so I can hold all these things inside a class and then I can create an array of uh the following class I can say okay I'm creating an array where each item is of the type payment category right so I'm creating an array of objects of the type payment category I have initialized this array that is going to contain 14 items and I I need to create these these objects as well I need to say okay the bill payments of zero it is going to hold new payment category and using the Constructor I initialized these values okay the payment category is one the name is electricity and some Ural instead of creating an array of primitive data types such as integer or float we can also create an array of complex data types such as payment categories in this example right secondly there are two dimensional array as well which are also used a lot especially esally in games and puzzles right here is an example of tic tac to where we might need a board or here is an example of uko game where might we might need a two dimensional array to represent the state of the game right so it's a 9 cross 9 array so I've created this array right and I can also create a list of players it's going to be a 1D array but the data type is now a player right each player might have a name it might have a score might have certain methods associated with it right it's an array of layers right that is also how arrays can be used another use case could be that AR can also be part of a data member of a class for example you have a enemy object the enemy has certain bullets inside it like certain number of bullets the enemy can fire I can create an array of bullets where each bullet is of the type bullet and I have created it when the enemy is created for example I want this enemy to have exactly Six Bullets when this enemy is created I can do something like this okay and when you're firing the bullet maybe a particular bullet might get deactivated something like this can also be possible where your array is a data member of a particular class this can also happen right another example could be the your images right so when you deal with images you you know each image is made up of a matrix of pixels okay of the size rows into columns so you might have heard about an HD image so that is 1920 by 1080 that simply means that we have these many pixels in this image and each pixel is actually made up of three numbers a component of red component of green and a component of blue so that means each pixel itself is a array of three numbers right if I look at an image image the image is actually a three-dimensional array of rows comma columns into three right where each pixel is actually going to store three numbers when we do with work with images in Python you often see the arrays are threedimensional okay another example that when you're building um software components for example a tool like Photoshop right you will say okay there is this grid where every item is a tool I can say okay tool tool box this is new tool and in every index I'm creating a new tool right Marky tool is a type of a tool move tool is a type of a tool right I can also do something like this they are used a lot in building real life software and that is the importance of arrays right now we'll look at some code demo to work with arrays now we are going to look at some code of an arrays especially how do we perform an operation like sorting on arrays which comes very handy solving lot of problems okay so I have an array of numbers and I want to use a method called as sort right in java.util package there is a class called arrays right this class contains methods that will work on a array that we have created right arrays do sort is one such method we want to use this method to sort our numbers array let's see if I uh go and run this code so I just need to call this function F1 so my array is created the array will get sorted and we are going to Output this array right another such method is arrays. two string I can convert this array into a string like representation that I can print directly so let us just go and run this main method so now you see the data that you're getting is in a sorted order let us look at one more example let's say I have an array of strings and I want to sort these strings again what I can do I can use arrays. sort method which is again inbuilt method inside java. util and I just need to pass the array object to this method it's going to sort these objects and let us call our function F2 and let us run this code now what do I see I see output apple banana grape lemon and orange right now how two strings are compared let us talk a little bit about comparisons as well now comparing numbers is easy I can compare as 5 less than 13 the answer is yes but if I have a string called as let's say S1 that is ABC and I have string S2 let's say I call it as a b e right now are they equal or are they not equal how do we compare by default inside the string class there is a method called as compare to if I say s 1 do compare to you see there is a suggestion coming out and I say okay let me compare it with the string S2 and let me uh show you the output of what this comparison function is going to return now why I'm teaching you is this is very important because we also want to write custom comparisons for our objects I'm getting an output that is minor basically how sorting function works is internally calls the compare to Method when you use arrays do sort and you give um some array of objects to sort right so what it does it calls the compareed to method of that object so string basically it is calling the compar to method of this object so I'm saying S1 which is ABC I want to compare it with another string a e this compared to Method it's going to produce three types of outputs one is a negative output one is zero and another is positive the negative output simply means that my first number is smaller first object is smaller that means it will come first in the list positive number means my second object is smaller that means it will come first in the list and zero means the two objects they are actually equal if if I get a negative output which I'm getting in this case that means ABC is smaller than AB let us also see how this minus two is actually coming right so when you compare uh a b c with a b e right so you compare a with a they are equal so you move to the next position you go with B B and B they are equal you move to the next position now you compare c and d right now suppose C has some M value right so maybe this is uh this was 97 98 99 right and this is 97 98 99 100 101 right the ask value of e would be 101 so when you take this difference I think a a is actually 90 not 97 whatever the ask value is right you will take the difference if you subtract C from E you will get a difference of Min that basically tells the Sorting function that I will place ABC first and then I will place a the sorted so compared to function is responsible for defining the Sorting order when I'm sorting these fruits you see apple banana grape lemon and orange they're coming in their dictionary order right because a string knows a compared to function is present inide it right then I say okay I want to I want to reverse this order right what you can do is one simple way of doing it is that you supply a custom comparator called as collections or reverse order that is exactly going to reverse the default output okay by default you're getting this output if you specify this it's going to reverse the default output if I run this code now you will see I will get orange first followed by Lemon grape banana and apple that is one thing that you can use to convert your ascending array into a descending that is one way of doing it so now you might ask then why we are studying this compared to method of or where do we need it let us try to understand that as well this was very simple this was an array of integers or an array of strings right you might say that I have a custom object I I have let's say class called as employee where my employee has a name age and salary right and I want to create an array of U employees I have a array of employees array of custom objects and I want to sort them if you uh sort them right and if you do not tell Java that okay I do not know how do how do I compare two employees most likely you're going to get an error right now errors. sort can also accept employees but given that you define a method called as compare to inside the employee class okay in the string class it is a inbuilt method but in the employee class which we have written we have to Define how do I compare two employees for for example I have an employee E1 I want to call the compared to method and Supply it some another employee E2 right so when you say okay I'm sorting a list of employees right this is an array of employees it will say okay I'm going to compare this employee with some other employee so I will say employe I do compare to some other employee that is employee J right so the sort function is internally going to call this method called compare to right this method is not there what we have to do we have to Define this method inside our employee I have my employee class and here I'm going to Define my compare to Method how it will get called it will get called internally employ I getting compared to with some other employe J right now it is up to you how do you compare two employees right some other employee here WR EMP now look at this how do I write this method so basically what I'm doing I'm saying if the two employees have the same age I will compare them according to their salary I'm saying salary 1 minus salary 2 so if the first employee salary is 100 and second employee salary is let's say 60 100 minus 60 it's going to produce a positive number that means the second employee will come first the person with the Lesser salary will come first or if the age is not equal I'm saying age minus employee. age so this is the age of the first employee and this is the age of the second employee for example if the first employee is 50 years old the second employee is 40 years old 50 minus 40 it's also going to produce a positive number that means the second employee it is smaller in age right so what this sort function is going to do what this compare function is going to do it's simply going to compare the two employees based upon their age if their ages are equal it's going to compare according to their salary people with the less age and less salary they are given priority they will come first in the output so let us run this code and see what do we uh really get right okay one more thing is that uh we have to so whenever you're creating this class you have to tell that it implements the comparable interface right why because the sort function ex expects that you will Implement a compared to Method this compareed to method is coming from the comparable interface right we'll discuss the concept of interface very shortly but you should know that uh you have to say this class implements the comparable interface for the employee in which we have a abstract method compared to and we have defined this method in the current employee class right the body must be given here so what what is happening now uh let me show you the output let's run this one we are sorting an array of object right so I'm saying let me print employees so now I'm getting 6,025 this is salary and age uh I'm getting 12,25 that means higher salary same age then I'm getting uh 8,045 according to my Logic the first preference is on age employees are sorted first on their age 25 25 45 and 56 then they are sorted on their salary if the age is same Jam Jamin and Aran they have the same age so the person with less salary it's going to come first so you can do you can make any logic like depending upon the situation and this compared to Method will tell the sort function how do I actually sort so I'm hoping that this is clear so one way is use the default s function but it does not work for the custom object right then what you can do you can write the compare to method and now there is one more scenario in which might not want to go this way you might want to go go with the comparator way right let me discuss that as well so let us discuss one one more way of sorting using comparator now I'm going to tell you why it could be important suppose you have maybe a list of strings if let's say ABC or let's say some fruits apple mango guava and orange and you want to say Okay I want to sort my fruits I want to say okay um array do sort I want to sort fruits but I want to sort fruits maybe according to the dictionary order I want to use the default comparison or maybe I want to sort fruits uh according to their length I'm not wrting writing the proper code but what I'm trying to tell you is that if I want to sort fruits according to their length I will have to go inside the string class and inside the string class I will have to change the compareed to method do you think changing the compar to Method inside the string class which is implemented in the Java Library will be a good thing answer is no we cannot go and make changes in the library right that is one reason we will not use the default compared to method or we need some other way to do the Sorting so that we have the flexibility right another option could another reason could be that uh I I might have a if else like this if the condition is this I want to sort According to some criteria if there is some other condition then I have to use some other criteria for sorting right I might have something like this then also I will have to say that okay go with the first way if your if condition is true go with the second way if your second condition is something of the sort what I'm going to tell you is that in such scenarios where either either you have conditional sorting or you will have to uh use your you cannot go and change the library compared to method for for that particular class there is third way of doing the Sorting so that way is called as comparator I'll show you an example of using a comparator right in this case I'm creating an array list of integers array list we will study very shortly it's just like a array but it's dynamic in size it can grow and Shrink so it is part of collections framework we will study so the teach the the demo that I'm going to do here is also applicable for arrays. sort method what we have done is we have created a dynamic array in which I have added few numbers what I want to do is instead of sorting these numbers directly right I know 10 is less than 22 that's okay but what I want to do I want to sort these numbers based on the sum of their digits you might say okay how do I override such a comparison in such scenario there is this third way that I'm going to teach you it is called as sorting using comparator right what we can do we can we still need to call the sort method if it is an array object you will use arrays. sort but if it is an array list which is part of your collections framework you will use collections. sort and this sort method you need to give your ARR list object that is a that that we have given right and now you have to say that okay I'm creating a new comparator object it's Anonymous object we are not giving it any and in this object we have to override the compare method right so I'll just uh write this part again once you will see U if you're using intellig it will come using the autocomplete feature I create a new comparator object and in this it automatically creates a method called as public int compare note that it is not compared to this method it's going to accept two objects that you want to compare and you want to tell how do I compare these two objects okay so if there are simple strings so integer o1 integer O2 let's say first object a is 10 B is 20 if you simply return a minus B that will simply compare these strings based upon their values that means okay 10 - 20 sorry o1 - O2 first object minus second object I can do that that will say okay 10 - 20 it's a negative number that means 10 will come first but if I do it other way if I say I will negate this entire comparison that means I'm doing O2 minus1 that means this list will be sorted in the descending order but suppose if I want to do based upon the sum of their digits okay for example this is 10 so is 1 + 0 that is 1 2 + 2 that is 4 4 + 1 5 4 + 0 that is 4 35 3 + 5 8 5 + 1 that is 6 I want to sort according to this what I can do I can convert an integer into its sum right what I've done I've written a function called as get sum given an integer X I want to get the sum right so this is very easy you know how to find the sum of an integer when I'm making a comparison what I will do I'll okay I'll get the sum of first integer object I'll say get sum of a and I will subtract get sum of a is my object o1 and B is my object O2 if I do this what's going to happen the numbers whose sum is lesser right so I'll just commment this code out I'll show you the output I'll show you the output let us run this code once right this comparator is telling the sort function that now you have to compare the objects using the following criteria okay so I've printed it it twice now if you look carefully 1 + 0 is 1 this is 4 this is 4 this five this is six and this is 8 now you look carefully that these numbers they're sorted according to their sum that is something that that you can do right you can do the same thing with strings as well you can do the same thing with employee as well you do not want to uh implement the compar to Method inside the employee class you can use a comparative or you want that on the top of it I need another comparison based upon certain condition right if employees are uh near their performance period I want to compare according to their salaries not according to their age right so you can have that comparator gives you another option to do the Sorting right you might say okay this looks little tricky is there a shorter easy easier way to do it the answer is yes so what we can do we can use something called as a Lambda function as well I'll just tell you in a very short way what is a Lambda function it's a s oneline function it's Anonymous function so in Java what you have to do you have to write the inputs that you need to compare in these round brackets for example if I'm comparing two objects A and B right and with an arrow you have to write the output of the comparison now if you want to compare A and B in this case what is the output I'm saying okay get sum of a minus get sum of that is what we are doing in the compare function as well that thing you put it here and this becomes a Lambda function and it will do the trick for you right so you can just say that okay I don't want to write the compare method I just want to use this value that is the output and use these numbers that are my inputs given these two inputs I want to return this output from the comparison this will also work and if I show you if I commend this code out this Lambda function will also do the same sorting thing that we want to do let us sort them and let's see what do we get we are still getting the same out that is another way of doing the sort so hopefully now you have understood the three different ways of doing sort and that's all for sorting and we'll start with the collections framework next let's talk about Java Collections framework now the Java collection framework is a framework in Java that provides us with set of classes interfaces to manipulate organize and perform operations on data without writing your own data structures from scram it provides you with Library implementation of data structures and their Associated methods that can do anything that you will ever need to do right that means you will be using inbuilt data structures because they come very handed when you're solving problems or you're building real life software these data structures are also highly optimized and they will of course save a lot of development time so you don't need to write your own hash table you don't need to write your own link list right so this is what is a standard practice we will most of the times we would be using the library Implement just to summarize once again what do we have we have set of interfaces we'll see we have implementation classes the classes that actually Implement those interface and we have also algorithms okay so I showed you the examples of array. sort method collection. sort method similarly we have methods for searching like binary search available in the Java Collections so you can just go and look at what all those methods are there but for now what I will be doing I will be doing a quick demo of interface versus a class so that you can really understand how these interfaces and classes are being organized inside the Java collection right let us jump into a small code demo to understand the concept of interface versus a class in this uh example what I have done I have defined a interface called as a payment method okay so what is an interface an interface specifies what a class must do and not how that means we do not have the implementation of the pay method we do not know how to make the payment but we are saying there must be something called as a pay if it is a payment method any payment method that we have must Implement a pay method inside it it is a blueprint for for the class interface methods are abstract by default so they they don't have any code inside now suppose I have I'm going to create payment method called as debit card so debit card is a class which implements payment method that means now debit card must Define the pay method so for now I'm just saying that debit card pay method prints paying via debit card similarly I have one more class called credit card which also implements the payment method in I have one more um class called UPI which also implement the payment all these classes they have the pay method and they're implementing the payment method there are different ways of creating the payment method execution of each payment method would be different okay a credit card might have a different mechanism UPI might have a different mechanism of making the payment debit card will have a different mechanism of making the payment why we are doing this let us try to understand now suppose we have method called as make payment and this method can accept any payment method right I'm not hardcoding here I'm not saying that I will only accept debit card DC I will not accept debit card I can accept any payment method one thing is we need a uh General structure we need a general data type that can hold all payment method okay and here I'm going to call pm. pay so now why this method will work so let me show you how do you create objects of it I can say Okay debit card DC this is equal to new debit card and I say okay uh I'm creating a debit card then I can call dc. pay so this will work I'm creating a debit card object dc. pay will actually work right so I'm not calling this method as of now but what I can do is I can call the make payment method and I can pass it the debit card object why because debit card object imps the payment method interface a better way to do it is suppose you have like some code here you say dc. pay suppose uh your debit card is not working or the debit card servic is down or there is some issue and you want to make it change it to the credit card okay you want to say no I want to try credit card now if you do this this is going to give you a problem because a debit card data type cannot hold a credit card right but what we can do is we can use a more General data type that is payment method payment method is PM I can see okay on the left side I'll have a payment method which is implemented by a credit card right so payment method is a more General data type so this is a good design practice as well so this data type we will keep it more generic and this is a specific class that provides implementation of methods defined in this class this is a specific class now this could be credit card this could be debit card this could be UPI right and I can pass the this object BM to any method make payment right now it does not care whether it I'm going to call the pay method of debit card credit card UPI whatever ever is the object passed it will call uh the pay method of that object so that means with minimum change in code we can achieve this General General Behavior right so any payment method object will work inside the make payment method if I go and run this code I will show you what's going to happen it will say okay I'm going to make a payment using a credit card paying via credit card but if I say okay no I will make it UPI without changing your make payment method you have just changed this object it will pay via UPI right going to run this code now paying via that means this uh object reference can hold any object like any object which implements the payment method interface that is a quick revision about interfaces and classes in Java and collections framework heavily uses this concept of interfaces and classes a lot so let us look at how this is implemented in the collection framework as well there are so many components inside collection framework there are interfaces there are classes there are child interfaces there are child classes and the hierarchy is bit complex so what I've done is I've drawn a simplified diagram so that you can understand how these components are related on the top we have something called as a collection interface okay okay so collection is a interface inside collections framework there are three more interfaces which are child interfaces of the collection interface so they are list set and Q they all extend the collection interface okay Q extends collection set extends collection and list also extends collection that means some methods are there in collection and list adds some additional methods which are specific to the list set adds more methods which are specific to the set Q adds more methods which are specific for the Q like behavior and then there are implementation classes which actually Implement a list so error list implements a list the other way the array list is going to implement the list a link list is also going to implement a list T is also going to implement a list Vector is also going to implement a list so a vector is a congruent data structure that means um if there if you need to work if you need to share this data structure across multiple threads then Vector is the synchronized data structure okay so we are not going to do congruent data structures in this tutorial so I will leave Vector at the moment similarly hash set implements the methods of the set link list implements linked has set implements methods of the set and reset also implements methods of the set right now what is the difference the way these methods internally work that is different okay a tree set might use something like a self balancing binary search tree whereas hash set might use the concept of a hash table to store the data right so the implementation of methods is different and their time complexities they are also different right so for Q we have three implementations we have err deck which is a wended que we have a link list which is like your which serves as your fifo link list and there is a priority que which again internally uses a heap like data structure to give priority to the elements which should come first right so we have interfaces and we have classes that Implement those interfaces the ones that are in the orange they are the classes the ones which are in yellow they are the interfaces right I hope you understood this simple hierarchy now you might be wondering where is hashmap hashmap is not a part of collection interface it is not a subtype of a collection interface it has been kept separately and it behaves differently from rest of the collection types so that means uh the map will be treated differently so map is a interface that we will look and hashmap tree map and linked hashmap they are the implementations for the map interface right we will use one of these implementations if you want to build a something like a map which can store key value pairs so we'll understand the differences between these implementations as we go through this tutorial right so let me uh tell you little more about collection interface The Collection interface it it's a general interface it represents a group of objects which are known as elements right so it's it's simply grouping different objects and it is used to pass around collections of objects where maximum generality is required okay you just want a group of objects you don't want to use specific priority Q method or specific Q method or you don't want to use specific hashmap method right so you just want some general methods that I should be able to add into the collection I should be able to remove from The Collection I should be able to delete from The Collection right for example you have a collection of string now this collection again it might be implemented using a link list it might be implemented using a set it might be implemented using error list we don't know right we have to provide one way implement or represent this group of strings right so let me show you a code demo here so I have collection of string S1 this interface collection is an interface so I need a class to implement it I say okay this collection will be stored using a error list so I'm adding something into the error list right I'm saying S1 do add hello S1 do add world right now you might ask where is this add method defined so I will tell you the collection interface contains method that performs basic operation okay so such as size every data structure you need to get it size every data structure should know whether it is empty or not every data structure should know whether a particular object is present inside it or not every data structure should support that I want to add some element I want to remove some element I need a iterator right it also contains methods that operate on ENT ire collections such as add all given another collection can I add all the elements of this collection into the current collection yes I can right remove all retain all clear right these are General methods that are defined in the collection interface that means all the implementation classes will have to Define these methods let me show you uh something here so let us say I create one more collection and this collection is implemented using a haset now in this haset I'm adding few strings a b c and d right now this add function is going to behave differently from this ad function because this ad function is implemented by the array list but this ad function is implemented by the hash so if I print S1 and S2 I would be able to see okay there are two group of elements okay if I just run this code I'll say okay I have uh collection S1 and I have a collection S2 now suppose I want to add all elements of S1 into S2 can we do that of course I can do that because the collection interface gives me methods like add all so S1 do add I can give any collection here I can give list I can give error list I can give Q right I can say Okay u in my hash set I want to add all elements of error list that is S1 so I can pass another collection into my add all method the method is add all right it's a general method any collection can be passed to right this is what it means right method is add all that's correct so let's go and run this code now if I see ABCD it's here I will also see hello world is also there so you can see all elements of S1 they got added into S2 right all these General methods they are defined in the collection inter okay I hope you're understanding it so that is at the top right now why we are learning this because we want to use these data structures to solve problems efficiently it is so powerful that we can do lot of things for example we can create a list in which we can keep adding two we just saw an example of a list we can search items very quickly inside a hashmap you can sort a list of students by using a comparator right we have just seen comparators we can also find topmost ordered items using a priority queue we can f filter out duplicate elements using a haset we can build a rate limiting algorithm using a q we can do lot of stuff using the collection framework and that is why we are learning it now next we will dive into specific classes and the first class that we will start is array list so let us talk about array list so array list is like a dynamic array for storing elements it's an array but with no size limit that means if an array gets full it will grow in size and it can accommodate more elements till you have memory available inside your HEAP right ARR list class uh it's a dynamic array it maintains the relative insertion order so if you add element it will always get added at the end so that means you will get the same order as insertion we can add or remove elements even we can search for elements and it implements linear search that means it will take linear time to search it in Java it implements the list interface so we saw that list is a interface and ER list is a implementation of list interface all the methods that are available in the list interface are implemented by ER list now how it is going to work internally so I'll give you a quick idea so internally it uses a fix size array only right so it starts with some fixed size array so in Java the default size is 10 so by default it will create a new array of size 10 and as soon as the array gets full it will double the size of the original now that doubling cannot happen in the same Place suppose this array was full right what it will do it will create a new linear array suppose this size was 10 it will create a new array of size 20 and it will copy all these elements into the new array and then you will have some extra buckets for new elements once this gets full it will again delete the previous array it will create an new array of double the size copy elements here and delete this array as well this is how it happens copy the elements from the old array in the new array and delete the old this is how this array actually works that means the doubling of the ARR list is a expensive operation and we should reduce the frequency of this doubling how do we do that if you know you're going to store 1,000 elements create an array list of initial size 1,000 if if you by chance exceed 1,000 the doubling will happen the aray size will become 2,000 right so it's good idea to start with the sum initial size that is equal to your requirement in Java this doubling procedure is little different it says okay I'll maintain something called as a load Factor this load factor is I think around 7 that means if 70% of your array is full the doubling will get triggered so we will not wait till uh filling of 100% of the array if 70% of the array gets full the doubling gets the doubling function it's it's triggered okay after adding the seventh element if the initial size was 10 a new ARR is created with a capacity of 20 so there are two things when you talk about size of the ARR list it tells you how many elements are currently stored in the ARR list if you use the size method it's not the capacity capacity is generally more than the size right the capacity is how how much space has been allocated internally whereas size is the number of elements that we have stored in the parist right so what are the features it is dynamic in size it can grow and shrink in size secondly it is ordered it preserves the order of elements third it is index space just like an array you have indexes array list also have indexes if you want to access a particular element okay I want to get this ath element you do not write array of i instead you write ARR list do get I give me the I element so get is a method that you will use to to access any ith element so this also works in order one time right indexing is Zer based so another property you need to know is it is object based error list can only store object data types that means it cannot be used with primitive data types you cannot create an array list of int float Etc then you might be wondering how do we uh create an array list of integers for that you have to use rapper classes in Java the rapper class for INT is called as integer so you will always create an ARR list of the data type integer not as int and secondly it is not synchronized that means it's not a congruent data structure if you need if concerence is important for your application you have to use Vector which is the synchronized version of list right so error list operations are not thread save and multiple threads should not operate on the same error list so this is a basic data success tutorial you want to learn about advanced concepts we will cover it in some other video right so what what are the operations we can get any element using the get function we can add any element using the add function we can also add more elements using the add all function so I give you a list I want to add it I can use add all right I can give some element X that can be added insertion and deletion in the middle it's going to take order of end time so if you insert something in the middle right want to okay I want to add something in between it will require shifting of remaining elements that means that will take order of and time searching takes order and time so by default if you use the contains method it's going to do linear search right but if you know the arror list is sorted then you can use your own binary search method or the binary search provided by the library function you can use that as well that searching will take login time if your err list is already sorted right now let us look at basic syntax how we can create an array list array list uh this is you have to Define what kind of objects you want to store here right and then you say okay I want to create a new ARR list object right so This Is How We Do It For example you can create an array list of strings and you say it's a new array list you can create an array list of integer right I told you it does not work with primitive data type you have to use other the raer classes okay in general I would uh make this left data type to be of the list type because error list is a type of a list right and as a good design principle it is preferred that we make this data type more General as possible so we can see okay the list uh we are creating an object of the type list implementation is given by new err list this is a more recommended thing to do right than doing ARR list right this you will learn in the design principles right so we'll create an object of the typ type list which which is implemented using the ER list class right so this is what we will do right uh so we can also use the Constructor to give an initial capacity right so you can pass a number here that will tell me okay I want an error list who initial size is 50 it is not going to be 10 so by default the initial capacity of the ER list would be 50 that means until this error list is not full or it's not 70% full the doubling will not execute if you know that you're going to work with with 10,000 elements create an ARR list of size 10,000 or 11,000 so that your doubling does not happen again and again because it's a expensive operation we can also initialize a list using an another list okay so you can give another list for example here we have a list of strings which is storing F and bar and I'm going to initialize an error list with another list that is also possible so we have seen three ways the default Constructor a Constructor with the initial capacity and a Constructor that accepts another list collection to initialize this err list right now one more cool thing about error list is we can also store objects of various types in this array list why so if you want to create an array list which can store objects of multiple different data types then don't parameterize the instance so you if you see here I've not specified any specific data type here that means this ER list can store different object data types so I can add an integer right so I'm saying error list. add in integer do value of one now you might ask why I cannot do this err list. add one because it is of the type int right so I need to typ cast this into integer data type integer. value of is a method that creates a integer object out of this one right string do value of scalar so this is optional we can simply say ARR list. add scalar so it's it's going to add a string object inside my ARR list right if I show you in the demo I have created an err list here I say okay err list do add integer do value of one this is going to add an integer and then error list. add scaler so I'm storing an integer object and a string object inside the same error list right so this is also possible right so you see the output here right let us talk about some more methods of array list so predefined method include lot of methods so there are methods for adding objects if I simply call the add method it will add at the end of the list there is a add method which also accepts an index and an object it will insert into a specific index of the list right there is a add all method it will U add another list in another collection into this list right so we can also add another collection at a particular index in this list so let us look at uh the add methods first I can say I want to create an array list so list of it's say integers I call it as list and this is equal to new er list you can see we have imported the list interface and we have imported the err list class inside this list I need to add some numbers I can say add one add two add four so let me show you and if I print this list I see I get 1 12 4 I have added these numbers okay now what I can do I can add at a particular index as well I can okay I want to add at a certain index so either I give a integer or I give a int followed by a integer I can Okay add at index 2 the element is 15 if I do it it will do insert version in the middle of the list that is also possible so you can see I get 15 which is now present at index 2 so by default it is uh like the first parameter is is the index the second parameter is the value that I'm going to insert right that is the add function I can create another list as well I can say Okay um I need another list list two and I can say list two. add 15 and I can or let's say this is 25 I can also add all elements of list one in list two I can say list two do add uh list so I can pass another collection here so add all so I need to call the add all method and this will also work and I can print list two as well you can see I'm having 25 here followed by all elements of list one that is how do we use the add method next we will look at look at the remove method so now remove method is it's actually a overloaded method if you look at uh we have we can pass a object we can also pass an index now this becomes tricky especially if you're working with integers right if I say okay I want to remove something I want to say uh list two do remove one what does it mean am I removing the index or am I removing the value one right so or let me just say list. remove one if I talk about first list and I want to remove one from it so let me show you it will actually remove the index because when you're passing one simply like this it's going to assume it is of the data type int right so if you look here so when I pass int data type it removes the index at the at the following index it will remove so that means it will remove the element two from list one but if I want to remove the value that is one what will have I have to do I have to convert that into a integer object right so I have to say list do remove integer do value of one that means remove one as a uh object so if I remove both let's say so that means one and two both will get removed let me show you the output file print system s out uh list show me what you're going to remove right so now you can see the output that both one and two they got removed and we got 15 and 4 similarly you have a remove all method which will accept another collection it will remove all elements from that collection from the given collection clear will remove all elements from the list contains will tell me whether a particular element is present or not so I can check that okay if list contains 15 do something right contains is is is your linear search so s out uh yes 15 is present something like this so you can use the contains method with almost every collection let me run this and you can see that we are getting 15 is present okay so there are more methods U so there is a get method so if you want to read a particular index you want to say okay show me what is present at uh the zero index you can say s out or you can maybe you want to iterate over the entire ARR list you can say for in I equal to 0 I less than list do size or List 2 do size i++ I want to get the elements at each index can say s out list 2. get I this will give you the elements at given is index so get function is used to access the ith element so let me run this and you can see we are able to iterate over all the elements in this list so just like get there is another method that is called set so if you want to update a particular index you want to say Okay I want to make this zero element as 50 so you can say Okay list to do set zeroth Element Make it 50 this will work and now your zeroth element will be 50 you need to give the index and the object that is get that you need to store here this is is the set function there are more methods I won't be able to cover all the methods but we have covered like most of the important methods there is a method called two array if you want to get an array from an array list you can use this and there is a method called as size which we have just seen there is also method called trim to size that means if we have if we want to reduce the current size right like if we want to reduce the capacity to the current size we can use this method Tri to size right these are some of of the important methods associated with error list there is also index of returns the index of the first occurrence of the specified element in the error list or minus one if it does not contain the element so contains is going to give you Boolean present or not index of is going to give you at what index it is present or not right we'll look at some more ways to iterate on the error list let's do a quick demo so we have seen a for Loop we can also use a forre Loop so I can say for every uh integer X in my list two I want to access it and I want to print it so I can say Okay s out this 2. Getti that is my another way of iterating and printing so sorry I will not do this I okay let me print this number X let me run this code there is one more way that I can also iterate on the list using an iterator right so you can see we are getting all the elements that is one 2 15 4 and 50 is also there right so we are starting from 50 here and we are getting all these element okay so iterator is one more way to Traverse on on on a Java collection all Java Collections they they support iterators so what you can do you can create a iterator object by calling list. iterator this iterator has a method called as has next which tells me whether I can access the next element in the collection not or not if your collection has finished your has next will give you okay there is no other element right so I can say while it. has next if there is a element present I can access it so I can say Okay s out it. next this will give me the next element in the collections this is another way using which I can iterate on given collection right so so iterator is coming from the java.util uh package only right so this will also print all the elements present in this head list let us quickly run the code and see we are getting the same output uh using iterator as well so we I iterated on list one so which is 15 and 4 again I iterated using iterator which is 15 comma 4 that is what I am getting by iterating on my list that's all for ER list I hope you understood the methods of error list and how it works now let us jump into link list so link list is also a linear data structure in which elements are represented as objects and stored in non-continuous memory for example if this is your HEAP memory and you have some data Maybe one is stored here two is stored here three is stored here four is stored here they might form a chain like structure and where each object is refering to the is holding the address of the next object in the chain this is called as a single link list where each object knows the address of the next node but it does not know anything about the previous node so if you arrive at three you can only go to four if you arrive at four you can only go in the forward Direction let us talk about link list little more so we don't have to specify the size of the link list it's a dynamic data structure as you add more data more objects get created in the memory and they become part of the chain and size is changing automatically as the data is added or removed so you don't need any fixed size array to initialize it right now let's talk about the implementation as I just talked about each node in a link list it's it's going to hold data it is also going to hold the address of the next node and if it is a w link list it is also going to hold the address of the previous node the nodes are not stored in a continuous memory location they are linked to each other with the help of next and previous pointers okay so this is something we'll go into the detail when we talk about uh when we do a tutorial on link list but for now we just want to see how to use the inbuilt link list class and understand its advantages and when to use it right so in Java the default implementation provides us with a W link list so a w link list each node stores three things the object or the data the next nodes address and the previous nodes address so at two you know where is the next note located and where is the previous note located at three you know where is the next note located and where is the previous node located so you knew all the three things at each node inside the link list that is what a link list is right and creating a w link list is fairly simple so you just need to use the link list class provided by the java.il package and the data type what kind of data you want to store in this link list and it will create a link list for you right now let's talk about the features of the link list the biggest feature is we can use the non- continuous memory so if you don't don't have a linear block available we can still create a big Chain by utilizing the non-continuous blocks of the memory it is a dynamic data structure there is no need to pre-allocate the memory and hence it results in efficient utilization of the uh memory as well right and insertion and deletion at the ends of the link list are performed in constant time now this is a very big Advantage so if you have a array and you want to insert something at the beginning you would see that I will have to shift the entire array then I can insert a zero here right but in case of a link list this time which is order and in an array inserting at the beginning it's going to be very fast suppose you have 1 2 3 4 5 you already know this node okay and you say I want to insert a zero here so you create a new node and you say okay head should Point here and zero should Point here this can be done in order one time similarly the last node is uh referred by a tail pointer if if you want to create something at tail you can simply add six here and your tail will move here right so if it is a w link list insertion and deletion both at the both ends can be just done in order one time this is a very very big advantage of Link list and concatenation of two link list is much more efficient in terms of space and time so if you want to merge two array lists you will have to copy all the data right but if you want to merge two lists let's I have another list 7 8 and n in that case merging is also very easy you just need to connect this node with this one which is again going to take order one time concatenation is also very fast in case of a link list right so let's talk about uh the differences between the operations right so random exis that means if I want to get any ath element this is very fast in Array right so I know I can get uh I can do array. get I this works in order one but if you want to get some ith element inside a link list there is no direct way you have to iterate it so in the worst case it will be order of n insertion and deletion at the beginning in case of Link list as I told you it's order one in an array it's going to be order n because you have to do the shifting insertion and deletion at the end so if it is a dou link list uh and we are maintaining the tail pointer you can do it in order one time as well and uh in Array it is also order one so this this can be made order one right depends upon the Implement insertion and deletion from the random location so of course this inserting deleting something from the middle both in Array and a link list will take order of end time so I hope you understood the basics of a link list now let's look at the implementation so I have this code in which we said okay we are creating a list which is using a new erray list object so instead of Now using erray list I can simply replace listed with with link list and since both AR list and Link list implement the list interface all the methods that we saw uh with this list they will also work with link list as well right I need to import this class let me just type link list and this will get imported import java. u. link so this is also there if I run this code as it is the same arist code it will work all the methods that we used on error list will also work on link list as well right now apart from it there are some additional methods as well which are provided by link list for example adding something at the beginning of the list so that method is not there in N list we can use that method for example I can say uh list do add first I can say okay in the beginning you add an element that is zero you might be saying okay we are get getting an error here add first there is nothing like this now why we why we are uh getting this error because add first is not a method inside the list inter okay so what happens is your list says that okay you must Implement an add method whereas your link list class which implements your list interface right it says okay I will implement the art method I will also implement the art first method that means you cannot call add first method on on a list kind of a variable right it is of the type list what I need to do I need to okay the object that I'm now creating is exactly a link list okay if I make it link list you can see add first will work CU you can easily add in the beginning of a link list I can okay maybe add uh minus 20 here and show me this list I'm running the code and you can see minus 20 is there it's added in in the beginning of the list so we have more methods let's look at some more meth all right so just to save time I'll quickly go through all of these methods so there is a add method which we saw in the list this is also there add all is also there add all we have seen right now add first I just show you showed you the demo it adds uh the desired element in the beginning of the list similarly there is a add last method it will add at the end of the list so it will work same as your uh add method there is a clear method which is fine there is a clone method creates a shallow copy there's a contains method element present or not right uh then popular methods are get I want to get particular element Works in a linear time get first get the first element get last get the last element index of you can use right now there is also a method called as offer right this method is used to add at a speci specified element at the tail of the list now you might be asking what is the difference between ADD versus offer so let us discuss this as well for that you need to go to the Java link list class right so I'm look Java link list the Oracle dogs right if I look look here what is happening uh the link list class it it actually implements uh not just your uh list interface it also implements your deck interface it also implements your Q interface that means all the methods of the queue all the methods of deck they should be available as a part of Link list so what is deck a deck is a doubly ended L uh it's a doubly ended uh Cube that means you can do push and pop that means you can add from the rear end add remove from the rear end and you can also do push and pop that means you can add from the front side and also remove from the front side of the que that means insertion and deletion can happen at the both ends of the queue now in order to uh implement this deck interface or the queue interface let us look at what all methods are there in the deck interface inside the deck interface you see there are methods you want to insert something at the beginning there is a add first method that should be implemented by that class you want to remove something the remove first should be there you want to get something get first should be there right similar L uh for the last element add last remove last and get last should be there now there are two versions of the same method one is ADD first one is offer first right what is the difference between ADD first and offer first so the difference is written here so what they're saying is that Mo methods are provided to insert remove and examine the element each of these methods exist in two forms one throws an exception if the operation fails the other returns a special value basically your offer method it returns like true or false or null if your operation fails right whereas add first will throw an exception so it again depends upon your use case how you want to use this method if you're working in an environment where your capacity of the data structure is restricted and you are trying to insert something and your data structure is already full what do you want should I should it return false that I cannot execute this operation or should it throw an exception if you want to throw an exception go with the add first method if you want to handle it using a value like true false or null you will have to go with the offer first method so because linklist implements the Q and the deck interface which needs these methods hence you will see there are many methods which are doing the almost same work right between ADD and offer there is a difference of the return type should you not the return type but how do you handle the failure case right so you going to to return something like true false or should I throw an exception right so that is offer and we have offer first we have offer last right then there is a method Peak so Peak means to look I want to look at the element so if you simply call Peak it will show you the first element of the link list the head of the link list Peak first fetches the head of the link list so Peak and Peak first they are same Peak last show me the last element right then there is a method pole pole means I want to fetch the first element of the link list it it will return the first element and remove it right pole first is also same removes the first element or it's going to return null if the list is empty then there is pole last it will remove and give you the last element of the link list or it will give you null if the link list is empty right there is a method called pop as well link list can also be used as a stack so in stack we generally call removing the last element as Pop right and push is also there if you want to some push something in the stock I can say okay I'm pushing something so it will push something into the link list if I a pop it will remove the last inserted element from the link list similarly the the remove method is there right remove first is there remove last is there set is there you want to update a particular element and two string is there that means if I want to print a link list it will call the two string method and each element is separated by comma and it is enclosed in square bracket when whenever we are printing this and whenever we we are using system.out.print list what is happening internally it is using the two string method of the list object to give us list which looks like this okay this is coming from the uh two string method so I hope you really got an idea on what all methods you can use on a link list so many methods are there so mainly you need to remember that you can work on both ends you can work on the front side you can work on the rear end and you can also insert in the middle search in the middle but insertion and deletion at the ends it is fast in the middle it's difficult Random Access it's difficult it's going to take order of end time compared to an ARR so that's all I'll see you in the next data structure let's talk about stack stack is a very simple and easy to use data structure so just like Aras and Link list it is also a linear data structure that is used for storing data and it looks very much like a real life stack such as a stack of books a stack of plates and uh let's see so it's kind of an ordered list in which insertion and deletion are done only at one end for example if you have items coming in 1 2 3 and you push them items into a stock so one will go then on the top of it two two will go and three will go and if you start popping items three will come first then two will come and then one will come so it's also called as last in first out data set the element which is inserted at the last is the first one to get removed for example if you keep a stack of books you put a C++ book then you put a Java book and then you P put a python book python book is the one that you can pick first followed by Java book followed by C++ book last in first out property stack has so internally if you want to see how it is implemented you can use a fix size array you can also use a dynamic array you can also use a link list to implement a stock and how it is different from arrays arrays allows Random Access you can get any e element but in case of stack of books you can only access the topmost element so in a way there is a limited access possible and only topmost element is directly available in case of a tack facts are generally dynamic in nature that means you don't have a fixed size and size can be increased or decreased depending upon the push and the pop operations that we are doing right so the container that you are using can can be a fix size array as well but in general it would be dynamic such as a dynamic array or a link list so the operations on stack they are very simple you can push an element into the stock you can pop something from the stock and you can Peak Peak means you can look at the topmost let us look at a code demo to understand these operations well so in Java we have a stack class which is uh which also implements your uh list interface but on the top of it stack has its own methods as well so let's look at a demo right so like I have created a stack object stack of string called books and in this I can push something so I can say books do push right now you see there is a add method as well the add method is coming from the list interface or I can simply call Push method which is specifically implemented by the stock class so I can okay let me push C++ let me push Java and let me push python let me just create three books and push it let okay python now if I print the stack I can okay show me what elements do we have I call it as books let's run the code and suppose if I want to see the topmost element the topmost element will be what it should be uh python knite I want to look at the topmost element so I can simp we call Peak right so I can say okay uh s out books. Peak that will give me Python and if I want to remove it I can call the pop method I can say books. popop that is going to remove the topmost element and now if I do Peak I will see Java next s out books Dot and apart from these methods we also we we can run a loop like we can say okay uh while the stack is not empty I want to uh tack dot sorry books dot is empty while this is not empty I want to keep on popping elements I want to remove them so I can say s out U books. Peak and I want to pop everything books do this is one way to iter On The Stack you have to remove all the elements and uh yeah so I hope you are able to understand this example so we are able to remove all elements we first removed python then we removed Java and then we removed C++ as well that's all about stack a very simple data structure right and hopefully you will be able to use it let us talk about q q again is a very simple data structure it's just like a real life que it's a sequence of object waiting to be served in the sequential order starting from the beginning of the que so in general Q maintains a fif kind of ordering but we also have something called as a priority Q which is little different for example a f would mean a queue of cars at a doll Booth cars are coming in to get their ticket or people are standing in a line to buy their tickets what happens in general people enter from the rear end of the queue and they leave from the front side of the queue once they get the ticket so adding something in into the queue it's called as NQ removing something from the Q is called as DQ someone has been removed from the Q so insertion as I discussed it happens at the rear end of the queue whereas deletion happens at the front end of the queue last in uh last out the person who is entering in the last is the last one to come out or you can say it's a fif first in first out the person who is coming first is the first one to come out right the front of the Q is returned using a PE operation so if you want to say Okay I want to see who is at the front the most libraries they have a peak method like in Java we have a peak method to see what element is at the front of the que right and similarly there are methods like offer to add something at the end of the queue and if you want to remove something from the front side it's called as Pole right we'll look at three methods offer adding something at the rear end ping removing something from the front side and peaking means looking what is at the front Okay so Peak only gives you the element whereas pole removes an element from the cube right so these are three methods that we will discuss if you want to implement a cube at your own end you can use a fixed size array um also known as a circular array to implement the queue you can also use a dynamic are or also you can use a link list so there are limitations of Q data structures a q is not ready be searchable you cannot go inside the queue and search so you might have to maintain another queue to store the dced elements okay so you have to empty the entire queue if you want to search for something and uh traversal of course we cannot Traverse that is the same thing you have to again remove all the elements to do the traversal and in this process Q becomes empty so these are limitations of the Q so operations you want to add something so the equivalent Java method it is called as offer I want to add something into the Q want to remove something the Java method it is called as pole and if you want to look who is standing at the front the method is called as P let us look at the Q methods in our code demo and if I talk about uh what are the methods there in Java right so if I told you that Q is a interface in Java right so this interface is implemented by three different classes one is called AR deck which stand for wended Q we can use Link list which we will be using to implement our P4 q and there is also something called as priority Q which we will also study very soon right we'll go with the link list while implementation right the methods that I told you they are insert remove and examine examine is like Peak right now again I told you there are two two versions that Java provides one set of methods that throws exception so if you use okay I want to add something into the que there is a add method or if you want to do the same functionality you can also use the offer method offer method returns a special value whether your operation was successful or not add method might throw an exception if your add operation fails because of some reason okay similarly remove throws an exception if your operation fails po will not throw an exception element you you're looking for an element maybe at the mtq right it can throw an exception Peak will not throw an this is how these methods are designed so I will be going with these methods okay in the implementation let me jump into the code and let's quickly create a queue right well okay I want to create a q of integers I call it as q and I say okay the Q implementation so Q is an interface the implementation is provided by the link list so we'll be using link list for this Q right so we also need to uh import it now how do I do it I can say q. add some numbers let's say one two three and four let me just copy this now if I say okay I want to see who is at the front of the que or let's just print the entire queue Let's uh run this code and simultaneously let's see who is at the front of the que so I can say s out Q dot PE show me who is standing at the front I will see one is standing at the front so one came first right if I remove this I okay I want to remove one I can say Q do um pole and then I can say show me the entire q and also show me the front element I can say Q dot just like stack you can also use a while loop to empty all the elements of the q que so after removing one the Q is 2 3 4 and if I look at the front element the front element is now so you can put a loop like this while your Q is not empty can keep on removing the elements from the Q that is all about Q I hope you really understood how to use Q in Java so next in line is the deck data structure so it stands for w ended q and it's pronouned T deck it is again a linear data structure that allows insertion and deletion at the both ends okay so you you can do insert here you can say okay I can expand in this side or I can also expand in this side maybe I insert five maybe I insert 12 or I can remove from both ends of the queue it's a queue that supports insertion and deletion at both ends so basically internally we can use a link list to implement it and Java also provides a special class called as array deck which implements the deck right so if I look at the hierarchy so we start with the collection interface we have seen the Q interface extends The Collection interface it adds some more methods into the collection and there is also a deck interface which I've not shown earlier in the diagram and the array deck is a implementation of the deck interface right a de is implementing a class that imp implements the deck interface which is extending the Q interface okay so this is what you it's a good to know thing not mandatory right a de and Link list are commonly used deck implementation if it is a dou link list you can see it is very easy to expand something on both the ends right so you can simply add something here as well and your tail will move right you can add something here as well your head will move right so it's pretty easy to use Link list but aridic internal implementation is little more complicated I'll discuss few more points about aridic it is a implementation of the deck interface that uses a resizable array to store its element and deck is a subtype of Q interface that we have just discussed best thing about ERC class is it provides constant Time Performance for inserting and removing elements from both the ends of the queue now this is very tricky right in an array we cannot do constant time insertion and deletion at both both the ends we can do only at one end right but in deck in Array deck it uses a internally some complicated mechanism so that we can remove and insert from both the ends of the queue and these operations can be done in order one time from both the ends right this is a very powerful feature of erod DEC that we must know talking about the operations right if you want to add something at the beginning you can say add first okay or you can use a method called as offer first these are two methods which are doing the same work there is a minute difference if due to let's say capacity limitation you don't have me memory or you're restricting the size of the queue and you're trying to add some element then add first you'll throw an exception we'll throw an exception just like other add methods we have discussed the offer method will return false that okay I could not return this element I could not not add this element similarly we have remove first and pole first methods the remove will throw an exception poll will return true or false get first we'll throw an exception Peak will tell me whether the element like if I could not get that element it will throw an exception Peak will tell me null I could not remove that element that might happen right there is ADD first there is ADD last offer last remove last P last get last Peak last now if you ask me what methods I would be using I would be using offer first poll first Peak first so if you want to do operations at this end you want to add something use offer first if you want to remove something from the front use pole first and if you want to look at what is this element can use Peak first right same operations if you want to do at this end what what you will do you will say offer last I want to add something here I want to remove something from here I will say poll last and I want to see something what is this last element so I can say P show me the last element this T so that is about the operations of deck now let us look at a code demo for deck so let us create a array deck object and say array deck of let's say integer deals to De and in this deck I can add elements I can say uh offer so there is a offer method as well offer first is there offer last is there I can okay let me show you offer first let's say 12 Tech do offer first let's say 15 tech. offer offer last it's a 20 Tech do offer let's say 30 let me show you what in what order the elements have been inserted s out I will say deck and let's run this code I'm getting 15 12 20 and 30 so first I had 12 offer first I said in the beginning I want to add something 15 gets added here then I say offer last 20 so 20 gets added here then I said offer 30 offer is actually behaving like offer last offer and offer last they are doing the same work this is how your deck is getting created similarly if you want to remove something and call the poll method you can say s out de dot poll last give me the last element s out de. pole first give me the first element and uh if you want to see now what is the new first element you can just call P so can say s out do Peak first show me the new first element and S out show me the new last element Peak last let us run the code and see so this is our deck now I say uh give me the last element so it removes 30 it's gone give me the first element it removes 15 it is gone show me the first element the first element is 12 show me the last element the last element that is how easy it is to work with deck and I hope you understood the concept let us talk about priority Q priority Q is a special type of Q in which each element is associated with a priority value for example if uh people are standing in a que and you might want to give priority to to the senior citizens maybe age is a criteria in which people will get their tickets okay senior people will get their ticket first young people will get their tickets later so basically elements that we are going to serve in the queue they will be served according to a certain priority higher priority elements are going to be removed and it is up to you how do you define the priority okay maybe a big number has a more priority or maybe a lower number has a more priority we can have a Max priority Q we have a Min priority Q we can insert like people and join the queue right but maybe this is 16 years this is 20 years and this is maybe uh four years right now if I say okay I want to remove someone I'll remove the person with the maximum I'll remove person 20 right so this will get removed so people can join the queue but when I'm going to remove people the people with the higher priority will get SED first right so the underlying data structure for a priority Q it's a heap we can have a main he or a Max he I will not be able to dive into the details of Heap at this point we'll be looking at how do we use the Java priority so the operations that are supported we can insert something inserting in a queue it's called as uh offer I can offer some data inside the queue I can look at if I want to see who is standing at the front of the queue that is called as Peak and if I want to perform deletion I want to remove someone right from the that that is called as poll we'll be looking at these methods and insertion and deletion there are login methods looking who is at the front the order one method right so let us do a quick code code demo as well so we have seen how to work with the que this is the code for a que a priority Q Al is a class that implements the queue interface okay so right now it was a fif now I'm going to change it to a priq right so rest Everything Will Change so if you want to add add method will also work but if you want to use the offer method I can use offer method as I can say do offer some numbers uh 10 we change the data I have 10 0 8 maybe 7 and let's say uh n right now if I say okay I want to print the entire Q let's see what output do we really get okay so I'm getting this output 0 7 8 10 and 9 I want to look at what is the first element I'm in this case the lowest element it's getting priority right so you see Zero is coming at the front of the que rest of the Q is not actually sorted only the uh priority element it comes to the front of the que right so zero is there if I say okay I want to look at this element so this element is zero and I want to remove this element so it removes zero and now what is the next lowest element in the cube that is seven so seven comes to the front of Cube if I make it 17 then the next lowest would be8 right so let's let me run it once again now I have 0 9 8 17 and 10 the lowest element it is at the front like then if I remove zero the next lowest is actually eight so that comes to the front so if I remove that element or if I look at what is that element I get that element using the peak operation you can see the element using the pole operation you can remove the priority element now you might ask if I want to reverse the order okay um so in that case can pass one more comparator so I can say okay comparator do reverse order this is exactly going to reverse the comparison aain priority Q becomes a Max priority u in this case the highest element it's going to get a priority right so now you look at 17 is standing at the front if we remove 17 10 is standing at the front and there is no specific order for rest of the elements that is unpredictable we are only worried about the element at the front should be either the main element or the max element this is about priority Q in Java let us talk about set interface now so so what is a set mathematically it is a collection of elements that cannot contain duplicate elements okay so set in Java it models the mathematical set abstraction now the set interface that we have seen it contains only the methods inherited from The Collection that means there are no additional methods inside the set interface all the methods are inherited from the collection but it adds the Restriction that the duplicate elements are prohibited everything all the method methods which are there in collection right the same methods are there in set except the condition that duplicate elements cannot be present there are three classes in Java that provide the implementation of set there is Hash set there is link set linked hash set and there is reset so let us try to understand the differences between the three Implement so as I discussed there is Hash set Treet and led hash set so hash set stores the elements in inside a hash table it is the best performing implementation however it makes no guarantees regarding the order of iteration you say okay I inserted 10 20 15 18 inside the set and if you start iterating over the elements you are not guaranted to get any order you might get 20 18 10 and 15 so the elements will come out in any random order right so it does not ensure any kind of ordering on the hash the internal data structure is a hash Table and there is a link High set so it is implemented again as a har table and along with the has table we maintain a link list so that means these elements are going inside the hash table but also we uh like chain them together so that we are able to maintain the order of insertion so it has implemented a hash table with a link list running through it so it combines the features of hash table and a link list and orders its elements based upon the order in which they were inserted so basically it maintains the insertion order okay so it's going to give you the features of the haset along with the ordering that is maintain there is one more thing that is called tree set it stores the elements in a red black tree so red black tree is a self balancing binary search tree which is a height balanced tree and it orders its elements based upon their values and it is subsequently slower than the highet basically whenever we talk about BST right and it is height balance BST so if you have to do an insertion searching inside in such a tree where the tree height is login it's going to take all the methods like inserting data finding data they are going to take order of login time inside a preset whereas on haset and linked haset the time complexity is going to be order one on average right basically the advantage of Treet is it keeps your data sorted linked haset keeps the same order as input haset it is the fastest and it is the but it does not give us any gures on the order so these are three different implementations of set in Java let us look at the code demo for uh hash set okay I want to create a set it's a set of integers s this is equal to new hash right I want to do something on this let us import as well right java. u. set import has been done let us add few numbers into it it's a set. add uh sorry s. add some numbers it's a 10 s do add 20 s. add 18 and S do add let's say 15 right and S do add I've added few numbers so let me display s s out the set let us run this code and see what do we get I'm getting 18 20 40 10 and 15 you see the order is random there is no fixed order 18 20 40 10 15 it's it's kind of a random order right if I want to add like if I add a duplicate element once again so if I say Okay add 10 once again and if I run this code you will see this it will not store the duplicate elements only one 10 is stored even if I add it once again the duplicates get filtered out so no duplicates are allowed in the set right suppose I want to remove an element so I can say s do remove 40 right this will remove 40 from the set and uh what is not there and suppose if I want to check if a particular element is present or not so if I can say s do contains uh Thum number 20 so you can say yes it is present or I can simply say uh just do s out whether 20 is present or not s out s do contains so it will give me true or false whether this element is present or not so I will get a true here right so 20 is present these are the three fundamental methods add remove and contains and if you remember these are the methods they were part of collection interface as well we can use these methods on any uh any data structure that we have seen so far right and all of them they inherit from the uh collection interface uh there are few more methods we which we have with the collection interface is empty we can check size how many elements are there in the set clear remove all elements from the set and uh we'll also see how do we use set with custom objects so let me first show you the size method how many elements are there in this set So currently we have four elements so this method will uh tell me okay there are four methods but there are four elements inside it now we have worked with a set of integers sometimes we might have to work with a set of a complex class maybe a set of books set of students a set of uh payment IDs or set of debit cards right anything anything can come here so data type can be anything so let us see how do we Implement set with a custom data type and what will change okay before we uh discuss the custom set there is one more thing so we just discussed that okay we can use a hashset class in Java but we can also use linked hashset and we can also use Treet so I'll commment this out and I'll show you two more examples instead of creating a haset I can create linked hash set in Java and if I use this you will see I will be able to maintain the same order as insertion in this set if I remove 40 I will get 10 20 18 and 15 so this follow this follows the order of insertion right and if I use something like a Treet that is slower because it uses uh self balancing binary search trees doing add and remove it's going to take login time on a tree set but it's going to maintain elements in a sorted order so let's see that as well now the elements are sorted in the set because we are using a Treet so I hope you are able to understand the differences between haset link set and Treet now we will move into uh set with a custom class set of custom objects let's see that now let us just discuss how do we use set with a custom class suppose you want to create a set of books what I've done I have defined a book class in which book has three properties ISBN name and price as the attributes of a book what I'm doing I want to create a set in which every item is of the type book now let us uh insert few books in into this hash set I can say books. add let's say I want to create a new book each book should have a name ISBN which is a unique code and let's say the price of the book and let me say okay I'm going to add few more books and here I make the name as let's say Java ISB is 2 and let's I change the price right now if I let's say go and run this code let us see how many um books we will have so s out um books. size and let's s out books I also want to see what are the books that the set is storing so I'm storing three books and you can see C++ book is getting stored twice and Java book is coming once now why why is this happening why it is not able to filter out that these two books are really same the reason is we are creating this object using new right so for the set to know whether these two objects are same or no there is no way right so we creating a new object set will treat that these these are two different objects created at two different memory locations maybe this is 1056 this is 2080 so for set these two books are different because they are two different objects in the memory right we need a way to tell this set that okay you should consider these two objects as same in order to do that one thing we need to do is we need to Define internally it is using uh the concept of hashing right so it's going to compute the hash code for an object you have to tell me how do I compute the hash code so for that I need to overwrite a method which is called as hash code what I'm going to do I'm going to overwrite a method called as hash code in this case if I want to compute the hash code of a book maybe I want to say okay compute it only on the basis of ISB ISB is a unique number so let me do it once again now let's see if something changes or not again it is not changing so when I'm hashing the books although the books are getting on the basis of ISBN still the set does not know whether the two books are equal or not so what happened we uh computed the hash code for this book inserted it into the set this book went into the set we again computed a hash code for this book it also went into the set two objects they can have the same hash code that is okay and uh the thing is I need a way to tell the set consider these two objects are equal so maybe I want to say that uh so I need to uh provide a method that is called as equals method okay so let's see how do we write this method so there is a pretty standard template to do it so whether two objects are equal or not so whenever you are inserting a new object let's say you're inserting this object into your headset it's going to compare that whether such a object is present or not so why at what location it's going to compare it's going to compute the har code and it's going to check whether we have uh something at that location or not so suppose C++ was there some other book python was there suppose they two two had the same hash code so it's going to compare whether these two are equal or not whether these two are equal or not so this concept will be a little more clear if you understand the technique of separate chaining right different objects they can have a same hash code if they have the same ISB or the hash function is producing the same value for two different numbers as well it can happen right but what we need to do is we need to tell that okay the two objects are equal if their ISBN is same so what I will do is what I have done here is I'm saying that okay um you're I'm giving you an object I say okay book B1 compare this object equal to B2 they two these two objects are equal in like two three scenarios I'll discuss what are those scenarios suppose I create a book B1 which is equal to new book and I say okay B2 is a book which is equal to B1 so in this case what is happening I have just one book object and both B1 and B2 they are pointing to same right if B I if I make any change in B1 it will also affect in B2 so what I'm doing that if this is equal to O that means if the current object and the other objects they're referring to the same memory that means they are equal right if o is null if one of the object is null they cannot not be equal or if the two objects they belong to the different class so suppose if I compare a book with a student they can never be an equal I am returning false otherwise any given object I typ cast this into book Closs and then I compare that is the isbin of my book is equal to the isbin of other book if this is the case consider the two book objects to be equal if I add this equals method my hash set will come to know that okay these two books they have the same SBN I will not insert them again even if I now now look I have only two books okay and C++ is stored only once now even if I change the name of this book I say okay this is C++ version 2 and the price has been increased to 120 will hash set store this book the answer is no because it is only going to compare on the basis of ISBN if ISBN is same I will not again store this book right but if you want okay the two books are equal if their name is same if their price is same if their ibin is same then in the equals method you can have two more conditions along with the ibin that I should match all the three parameters for the comparison the equals method is important so you need to override this method to tell the set in What scenario you should consider two objects as equal so I hope you're getting it and uh that's all for this Implement let us talk about the final data structure that is a map a map contains values on the basis of key that means it contains information in the form of key value pairs just like a restaurant menu whenever you go to a restaurant you say Okay I want to have a burger and you immediately get to know the burger is 50 I want to have a pizza the pizza is 200 I want to have a Coke the Coke is let's say 70 there is a key there is a value Associated a map contains unique keys that means I cannot have uh Burger twice in my menu okay a map is useful if you have to search update or delete elements on the basis of key so we do not ask okay what item is after burger or what item is coming before Pizza the ordering is not that important to us what is important that given a key what is the value associated with that item and I want to okay Coke is out of stock so I want to delete this key value pair or something new has come up I want to insert that key value pair for operations like these map is a very good useful powerful data structure and most of these operations they run in order one on average so search is order one on average update is order one on average delete is order one on average so very powerful data structure now uh let us uh talk a bit more about map Java platform contains three general purpose implementations one is your hashmap another is your tree map and another is your linked hashmap so the behavior and the performance is same as the way hash set Treet and Link set work right so hashmap internally uses a hash hash table it's the technique called separate chaining that is used to implement a hashmap so to understand hashmap we'll do a separate video where we will dive into the internals of a hashmap three map is like a self balancing binary search tree and linked hashmap is your hash table and it also maintains a link list of the elements in which like it chains the elements through the link list as well um in the order in which they were inserted it's more complex than a hash map map does not allow duplicate Keys just like a hash set we cannot have duplicate elements but we can have duplicate values for example Burger can cost 50 noodles can also cost 50 the value can be duplicated but the key must be different right hashmap and linked hashmap they allow null keys and values but tree map does not allow null key or a value right tree map you cannot store a null key a map cannot be traversed so you cannot directly iterate on the map so you need to convert it into set using key set or entry this we will look into the code demo talking bit more about uh the hierarchy in Java there is a map interface okay and hashmap is a implementation for the map interface there is a linked hashmap which Builds on the top of your hashmap class right hashmap is a class L hashmap is also a class remap is a class that implements your sorted map interface SED map interface is again an A Child interface of map right it it kind of extends that here ordering is important right you get thee keys in a sorted order here you get keys in the order in which they were inserted and hashmap it is the fastest here you don't get any ordering on the key this is the difference between the implementation also the operations are order one here on average operations on tree map they are order of login on average why because it is using a self balancing binary sear tree okay so here I have have implemented a map object by using the hashmap class right so I've created a map called as menu and I'm going to add certain items in I can say menu. add it say uh the item is Dosa and the price is menu. ADD let's say the item is Burger the price is 50 we getting a error here so the method is called as put hashmap we don't have the add method because it does not inherit the colle interface okay I told you map is separate from um map interface is not U it's not a child interface for of collections interface so it has method called put it does not have a method called add I can put key value pairs like this I can say menu dop put noodles and maybe some price and here I can say s out show me the menu let's see if we get something here so let's see what do we get if I run this code in the meanwhile I will write down some more methods I can see there are I can see the U list of key value pairs that are stored inside this map I can also remove something I can say menu. remove I give Burger I just need to give the key the burger will get removed from the map I can also search that if my menu contains some item like Dosa I can say contains key this this is the method and I can check whether it is present so you can say yes out s out Dosa found so you can do this as well after removing Burger we have two items noodles and Dosa in our map right so Dosa is there so Dosa found it's get it gets printed now let us also talk about how we can iterate on the map there are multiple ways right so what we can do is okay I just return the three ways to itate so that we can save some time so the way is I can do I can create an object of the type map. entry and this object is iterating over uh all so M menu. entry set is a method that gives me the list of key value pairs where each key value pair is considered as a entry right I'm saying okay give me all the entries and given any entry I want to get the key and I want to get the value so that is one way so you are printing the first entry the second entry and then the third entry that is one way another way is if you want to just get the keys of the map can okay menu. key side so it will give me all the keys like Dosa Burger noodles and you are iterating over these Keys those keys are strings then you can okay I want to iterate over the values that are 250 70 I just want to iterate over these values so you can call the method called menu. values and it will give you a set of values and you can iterate over this set using a for each Loop and for every value you can print it I'll just run this code and show you the output you can see I'm able to iterate over the uh keys I'm able to iterate over the values and I'm also able to iterate over key value pairs right so this is coming from this Loop right and apart from it there are some more functions which can come handy so you can I would suggest and try those methods is empty whether the map is empty or not size how many elements we have clear clear out everything in the map right this is clear method is helpful if you are working with multiple test cases every time you have to load new items and discard the previous items from the hashmaps instead of destroying the object and creating a new object it's better to clear out everything from the previous map so then there is get or default if the key is found you want to return some value uh you want to return the value or if the key is not present you want to return some default value this is something you can use so for example I can say menu do get uh let's say uh pza so Pisa have not inserted if the Pisa is not there I can say the default value is let's say zero that means um in this case I will get an answer that is zero s out this value right what I'm getting I'm getting zero that means Visa is not present the default value if the item is not present I'm think the default value for that item is zero I can also say uh I want to put pza if it is not there so menu. put if absent I can say okay it will first check if the item is not there if pza is not there put pza inside the map and put the value of pza as 200 if I go and run this now it will first insert pizza because it's not there so it's basically using the put method with a condition and now if if I inquire about give me the price of pizza now the pizza is present because we have added it and I'm getting the P of price as that's all for map right and now what you can do is you can also have a custom class here you can also have something more complex here for example list of integers list of books key can be of any type value can be of any type but if you're using a custom key again you will have to overwrite your hash code method and the equals method just we did in the case of hash set as well one more thing we can do is if you um want to replace this with a linked hashmap you can do that everything will remain same and your ordering will also be maintained and you can also replace it with a tree map if you want everything will remain same except the internal structure will be now uh it will be using a self balancing um BST right so you can also do a tree map kind of a stuff here we need to import it uh tree map map is the the code will work fine except now the elements will be sorted according to their um keys right let us Begin by revisiting the concept of an array array is a very simple data structure that represents a linear collection of elements of the same type right so the concept of array is there in across all languages in Python it is called as list in C++ and Java it is called as an array right and most of the times it is of the same type but in Python the arrays can also store elements of the different type so arrays are used to store multiple values inside a single variable I say okay this is a container the name of the container is just one variable but it is going to hold multiple values right instead of declaring separate variables for each value we just create one variable now this helps us because suppose you want to store 100 integers will not create 100 variables instead you will create one array and in this array you will have multiple buckets each bucket is referenced by an index okay if you want to store something at this position indexing always starts from zero right you will say Okay array of zero I want to store the number four at this position if I want to store something or I want to update something I will okay array of one should store five or it should be 15 so I can update the value anytime I want right so this is the syntax right so the variable name is AR and how do I create it so if I want to create an array of integer I will say int followed by square brackets followed by AR followed by here we will see there are few different ways one is we can use new keyword to allocate some memory or we can directly give the values which which we want to initialize the with right so let us jump directly into the code and see uh various ways to create an array and work with them so first of all I'll okay I want to create an array so this time I'm just initializing it with some random numbers I'm not using the new syntax we will do that as well this creates an array if you do s out ARR let us understand what happens behind the scenes in the memory if you do this right so let me go and run this code I will see some some kind of address in Java it is called as object reference so I see this number now what is happening if you dive little bit into uh what is happening in the memory right when your program is executing your RAM memory is divided into two parts one is your stack memory and one is your HEAP memory both of these memories have their different properties any function that you're calling it goes into stack and it creates a stack frame out of it right and when you're creating this something like this you say okay uh I'm doing inex this that is equal to 20 when you create a primitive variable like this x is a bucket it is created here and it is storing 20 but when you create a object Java Aras a object the actual object it is created in the Heap so your 4 6 8 9 it is created in the Heap and the address of this object whatever is this address 264 right so 264 is stored in a variable which is there in the stock and this is storing 264 that means the variable in the stack frame is pointing to the array object so we call this ARR as a this is a object reference this ARR is not the itself it is ref string to the array right this is how it is created uh behind the memory right now when you're going to print ARR it's not going to uh print the contents of the array instead it is going to print um what is stored in a right if you want okay I want to print the contents of this array right what I will do I will say okay I need a way to iterate on this array and convert everything uh and print everything right there is an inbuilt function that we can use so there is a different class okay it's there is a class called as arrays and it is part of java.util so arrays class has certain helper methods to work with these kinds of arrays in this these methods we have to pass the array object and get get our work done so one such method is two string right I will give you some kind of array and you want I want you to convert this into a string like representation that can be printed using system.out do print so let me give this array and now if I show you what is the output let's see now I'm getting this array so I'm hoping that you able to understand why this is working right what could be the logic behind this two string it is doing nothing but it is doing a traversal on the array using a for Loop and it is adding everything into a string so it says okay I'll start the string with the square brackets then I will add the zeroth element then I will append the first element and so on so something like this it is doing but what is happening it is simply iterating over there so if I talk about how much time it will take it will of course take order of end time to iterate over all the elements of the array okay so let us look at one more method uh in this array so let me create one more array let me call it call it as U some array let me call it as array 2 this is equal to new in I'm saying okay let me create an array this time I'm not going to Define you the give you the data but I'm simply giving you size of the array that okay I want an array that should be able to hold 10 numbers one thing you can do is you can manually initialize every index you can say array of zero should be eight or let's say I want to fill five in every position right one way is you put a loop and update every Index right or you read input that we will see very soon but there is one more method if you want to initialize an array with a a particular number so that method is called as arrays dot fill look at this there is a fill method and you can say Okay I want to fill this array with number that is 12 you need to pass the array object that is array 2 and maybe the value that you want to fill maybe I want to fill with the number 13 now if I show you the output I can say s out uh array 2 but I have to first convert it into a string so that I can print it arrays dot two string that is array two let me print the second array can you guess what the output would be the first element would be eight which I have overwritten so this is updating the zeroth element and rest all the elements will be 13 this is what we are getting right the fill method is going to fill this array with 13 at each position and so on and first zero index I'm updating as eight so I get eight followed by all 13s that is another method present in arrays class okay arrays. two string arrays. fill one more method that is coming into my mind it is very popular we need it often this method is called as ar. sort that is also present in this arrays class I can say okay let me sort this array I want to put all these numbers into ascending order so I say 114 um 81 I just randomize the numbers so that after sorting I can see they actually in the sorted order right if I run this code now you will see this array it's going to be in the sorted order you see the AR is got getting sorted so internally it uses something like a quick sort kind of an algorithm and the running time complexity of the sort method it is order of and log okay this is something that you should okay so let us look at one more fundamental thing in arrays that is reversal there are three ways to two ways to Traverse the array one is that I can find out the length of the array and then I can go over every index if I talk about this array I know there are five elements so the indices are 0 1 2 3 4 so uh array object has a property called as length so if I okay I want to see the length of the array s out uh array length I can say this is given by length attribute of the array object I can say array dot length this will give me okay this particular array has five elements so and if I have to iterate I can say okay for I equal to Z the index starting from zero I less than array do length i++ and what I will do I will say s out array of I this is going to print the I element of the array and we are doing it for all indexes less than five we do not go till five but we go till less than five because the indexes start from zero and they go till n minus one this is n the last index will be n minus the other way is you can also use uh enhanced for Loop also known as for each Loop right so you can okay for every integer X that is present in this array I want to print that X in this case X is not your um index but X is the value that that is contained in this array if it is like 1 6 9 14 and 81 in the first iteration X will take the value one the next iteration it will take the value six then it will take the value 9 then it will take 14 and then it will take 81 if I simply F print the value of x it will again give me uh the contents of these are two ways to iterate on the array if you want to iterate on some part of the array better go with the for Loop if you know that okay I want to iterate over all the values then the for each Loop is a more simpler syntax okay but the first Loop is more powerful because you can start at any point start at any index and you can stop at any index so let's run this code and see that we able to iterate on this okay so we can see uh we are able to iterate 1 694 and 81 this is coming from the for Loop and 169 14 and 81 this is coming from the for each Loop that we have written let us look at another way of building an array many problems will require you to reading n numbers and storing them and working with them so for example a very simple use cases we have to read n numbers and we want to print them in revers without storing them we cannot print them in reverse that means we will need an array to do it how do we read n numbers so it's very simple first of all we need a scanner Java so scanner is used to uh scanner object is used to read something from the command okay I can okay first tell me how many numbers are there the method is called as next Once you know n you can okay I'm going to create an array how do we create an array let's say I want a integer array and I can say this is new here I Define uh what is the size of this this will create an array of size and now I want to read this array again it is pretty simple I will read the zeroth index first index second index up to n minus one IND it's okay I less than n i + and in every iteration I can array of I is going to hold an value will read from the user I can say scanner. next scanner. next in will pick one number from the command put it in the I bu in once I'm done I want to print them in R printing is easy so how do be print it I can say okay I can start from the last index that is n minus I can go till the first index that is zero IUS so I just need to reverse the loop that I'm uh using to iterate over the array and I can simply uh iterate in the reverse Direction so system. out. print Ln array of I let us go and run this codee and see suppose I want to uh read five numbers and print them so let's say the numbers are 10 20 30 40 so you can see I'm able to print 50 40 30 20 10 so what happened I created an array of size n then I stored numbers I said okay go over index zero and read one number from the command line so it it read 10 it scored it here then I becomes one it is reading one number again scanner. next in the next integer in the line it is reading it is storing here and so on so 30 40 50 then what I did I iterated from the last index which is n minus one till zero in this direction I iterated and I printed aray of I this will print my array in the reverse order the next thing I want to talk about arrays is array of objects okay we have seen how do we create an array of primitive data types like integer similarly you can make a array of float array of Boolean right primitive data types you can work with but what is an object the complex data types like strings string is an object okay you can also have a user defined class and you want to store objects of that class in your array so let us see how that actually happens at the memory level and also at the syntax level right so suppose I have I have a book class I'll just delete this method in this book class I have defined three attributes of the book one is ISBN which is your unique book code a name and a price and I also have a Constructor to create a book object right if I want to Simply create one book object how I will do it I will say Okay I want a book b this is equal to new book in this new book I want to pass the name of the book and ISBN and a price I okay these are the three attribute or three values that I'm going to initialize this book with this just creates one book object but what we really want we want to create an array of book how do we do it we okay book followed by square brackets that is the data type of the array then you have to give a variable name I okay the name of the array is called as books let's keep it intuitive and followed by new book suppose I want to store three books in an array right this is going to be three now what it's going to do right as I discussed in an integer your memory is going to get divided into two parts one is your stack memory which your main is getting called and we have a variable called as books which is going to refer to an array that is capable of holding three now this is this position is books of zero this is books of one and this is books of now how do I put a book here one option is that okay I have created a book object B already so B is a book so B is also created here B is pointing to a book that is a C++ book C++ book has some address let's say 104 B is storing this value 104 now I want to put this book inside this array I cannot like physically I I cannot say okay this object will go inside this box in the he no this is now not how it happens the way to do it is you will have to say that that books of zero it is going to hold B books of zero is going to hold B that simply means that whatever is the value in stored in B it is also stored in here so this value is one that what does it mean so it simply means that books of zero is referring to the C++ object C++ book object that is present in the this is how it is getting stored in case of array of integers it is different case of array of integers you say okay uh array of zero this is equal to five the number is directly stored here but when you say books of Zer this is equal to B books of zero is holding the address of this book op you might say okay this this might be the reason um because we have created a b reference variable and then we are copying that value even if you do something like this you say okay uh books of one should be equal to new book and let's say this is a Java book uh with code two and price is let's say uh 200 and let's say books of two is a new book which is let's say a python book and uh code is let's say three price is let's say 150 something like this let's say we have now books of zero books of one books of two what is happening when you're doing this statement this is even doing the same work just that this new book object is getting directly stored inside books of one so that simply means whenever you use new book it creates a book object in the Heap memory right it's not going to create inside the array Java book is created somewhere in the Heap maybe this location is 216 and this address is getting copied here so this is going to be 216 that means books of one is going to refer to this Java object and when I say books of two this is equal to new book so again a new book object will be created in the Heap let's say this is Python and uh it has some address let's say 780 780 will get copied here now you want to say Okay I want to really verify this is how it is stored let me show you um by doing an S out right if i a s out uh books what I'm going to get I'm going to get the address of the whole array maybe this uh books array is created at a location that is 200 I'm going to get this 200 but now you might okay no I don't want to print this I want to print this entire array if I say s out uh arrays dot to string basically I want to I Traverse on this books array and I want to print it let me show you this output what output and do we really get let me run this one now you see what we getting here is the address is the value that is stored in this books variable and what we are getting here these are the three addresses stored in this array which are refering to the three books that we have this this is C++ Java and python three objects their addresses are stored in the books array and this is what we are getting right you might say I want to print the content I actually want to print the object I don't want to print the print an address how do I do that right the reason is Java does not know how do we print this book okay how do we actually go to a location and print that object so in order to do this there is a u method called as two string that is present in um inbuilt classes okay for example when you print strings string has a two string or if you print like some object right so many objects have their own two string method what we have to do uh we have to go inside the book class which is this and we have to say Okay I want a two string method public string to string so this method should return a string it is automatically giving me a recommendation that there is a default template in which I will concatenate these three properties of the book which looks good to me so I will just click okay and it will create a method for me right so when I want to say Okay I want to convert this book into a string internally it is going to call uh the two string method of book right which method I will tell you right let us go to array of objects when are you saying ar. two string it is going to iterate on each book and it is going to convert that book object into the string like representation if the two string method is overwritten right we have overwritten that method so what we will get we will get the contents of the book let's run this code now once again and see what do we get now now you can see I'm getting U book that is the C++ book then the Java book and then the python book you might ask okay can we do something more on this object the answer is yes maybe you want to uh sort this array of books right so do you think arrays. sort will work want to sort this array of books will it work I might get an error okay I'm really uh getting an error here why because the S function does not know how do I compare two book objects okay so how do I do it U there are three ways that I have discussed in my previous video in which I have discussed Java Collections One is using compare to Method One is using uh comparator and one is using Lambda function I'll give you a quick uh way to do it which is is using the Lambda function in this video I what I need to do I need to Define one line function in which I will say okay how do I compare two book objects the two inputs let's say book B1 and B2 so there can be any two books the Sorting algorithm is going to pass book objects to this function followed by an arrow followed by I should return a number which is negative zero or positive so if I return a number that is negative it simply means that my first book is smaller right okay and if I return a number that is positive that means my um first book is bigger right I I need some way to convert these two books into the numeric values for example I want to sort these books according to their price let's say I'm comparing C++ and Java if I return 100 minus 15 what what does it return it returns a negative number that means the C++ book is smaller than the python book something like that let me show you if I say uh I want to compare two book objects B1 and B2 and in return I will say that compare on basis on the basis of their price so I will return a number b1. Price minus b2. price this is a shortcut way of writing a comparator right using a Lambda function so I'm comparing two books if the first Book price is let's say 50 and second book price is 100 this expression will return a negative number that means the first book is smaller and hence it will be placed first in the list right let me go and run this and we will see what happens so I'm getting now the C++ book followed by okay I I forgot to print this after sorting right before sorting it is C++ Java and python let us see what happens after doing the Sorting right I'm getting C++ the least price then I'm getting the python book which is 150 price and then I'm getting the Java book which is having a price of 200 okay so I hope you're really understanding how we are uh doing the comparison and we can uh tell the sord function this is the parameter on which I want to do the Sorting right if you want to write more complex comparisons like multiple ifls conditions then you have to go with the comparator way of uh comparing the two book okay so that is how you work with array of objects and uh I hope these concepts are clear let us move on to the next concept that is how do we pass arrays to functions and what happens internally in the memory so let us discuss these concept for example uh let's say I have a variable called as uh money which is let's say I have 100 rupees and let's say I have a function called as uh double money right so I okay I will get some money and I want to double it so I can say Okay money equals to Y of money and uh that's it now I call this method I call the method called as double money and I give it money right and now I can say okay let me so let me call it as public void I'm not going to return anything public static void double money I I've just I have I have a single variable right so basically what I'm trying to tell you is I have this money variable I pass it to a method called as double money which should which people might think that it's going to double it but let's see what do we really get if I print money here what do you think what output you can expect here let me go and run this code the output will be still 100 the money is not going to change I'm still getting 100 so let us understand what is happening behind the scenes this main function created in your stock memory is your stock memory and there is a variable called as money and when you make a function call another function is called that is your double money and in this function you have another variable called as money it exists in a different scope in a different part of the memory and this money was 100 so when you call this function this money is getting copied here right copy right pass by value the value that is here it is getting passed here you're passing this value 100 and here you say money equal to twice of money you say okay I'll make it double I will uh make it 200 now this function call is over it does not return anything this stag frame is destroyed and you are back here when you print this money what you going to get you're going to get just 100 now let us repeat this experiment in in in a case instead of having one variable let's have a array object I say okay I have multiple friends and they have some money so I say friends money it's a integer array and let's say a friend has 100 200 and 300 and I create one more function called double money which is going to accept a money array or friends money right whatever you want to call it as in this case I iate over this array for in I equal to z i less than money. length I ++ and I say money of I should be twice of uh money of and again I do not do anything I do not return anything now I again call this function I call Double Money and I give friends money which is an array what do you think will my array get doubled will my money in this are will it get doubled the answer is yes it will so let us see how and why it's going to happen so if I print prints money and if I show you the output now okay I I have to use the method arrays. two string so that I can actually print the contents of the array [Music] for java. now this money is actually getting 200 400 you might think it is not doubling for the P primitive data type but it is doubling for the array primitive behind the scenes what is happening we have already seen now let us see what is happening when you're are passing an array so you have your stock memory I told you the array is created in the heat memory your 100 200 and 300 they are created here and they have some address let's say the address is uh 556 this is the location at which the array is created when you called your main function it got created in the stock your variable friends money it is also created here what is this variable holding it is holding the address of the array so it is holding 556 now when you call this function double money you're passing the variable the object reference friends money to it okay so we are calling this function double money and it has a variable called as money in which what is the value that is getting copied it is not the array that is getting copied it is the value inside this uh fun variable friends money it is getting copied right in Java everything is passed by value okay but in case of of array what is the value that is getting passed it is not the array object it is the address that is getting passed you have 5.56 getting copied here when you okay money I equal to twice of money so this money is also referring to the same array when you access the ith location using this address you eventually end up here you say Okay money of I should be twice of money you make it double make it 400 you make it 600 now this function is over this is uh this call it is gone this link is also gone and when you come back again here and you try to access the friends money array the actual array has been change right okay although it appears like pass by reference but the concept is still called as pass by value in Java okay but for the objects that are stored in the Heap okay objects in the Heap when you pass them to a function their address is being passed okay that is something that you should know and now I hope you're able to to understand what happens when you pass an array to a function you change the array the actual array will get changed okay if you want to create a copy of the array you have to use some methods like clone or what right so that is how arrays are passed to a function now let us move on to two dimensional arrays okay so many real life problems for example games puzzles like Tic Tac do they might require you to store data in the form form of a 2d Matrix now if you want to store data in the form of a 2d metrix you need a two dimensional array right you can also have a threedimensional four dimensional and dimensional array right how do we create such an array I'll show you few ways to create these kind of arrays so first I need to define the data type and in this case it's a 2d array so I will have to use these square brackets two times I'll tell you the reason why and then one ways I can directly give the data right now if you look at this array it has three rows and four columns it is like 1 2 3 and 400 this is like one object and I have 4 5 6 and 100 this is like another object and then I have 7 8 9 and 100 7 8 9 and this is like another object now how they are stored internally in the memory let us discuss for Java 2D array is nothing but it's a 1D array in which each each row or each uh each row is like one object right so can I say it's a 1D array of objects where each object itself is a onedimensional in the memory there is no 2D array created internally it's going to use a 1D array where I can say the zero throw this this element is my array of zero array of zero itself is an array that is what I'm trying to tell here array of zero is of the type int square brackets that means array of Z represents 1D array array of zero is going to hold the address of another 1D array let's say this address is some something that address will be present here array of one that is also going to hold the address of another array and array of two it's also going to hold the address of another this is array of one and this is exactly how it is stored right and where is your ARR AR is here this variable it is in the stack memory and these arrays these four arrays they are in the okay so this I'm saying this is a object a 2d array is nothing but it's a 1D array of objects 1D array of objects where each object is also an array this treat it like this way right so treat it like this is one book this is another book this is another book right each row is one object now you might say Okay prove me this is how it is St so let us uh go and do s out let me show you um I can say arrays do two string I want to print this array I give ARR and again I will import Java do util dot if I make this import and I call this method array. two string now what I'm hoping to get will I get the contents of the array or will I get the these addresses let us see what do we really get I need to run this look at this I'm getting three addresses what are these three addresses these are the three addresses of these three row objects that we have created this is 264 this is stored here this is 30C this is this is the address 30C and this is 1 1970 11 970 this is the address of another and you might ask okay if I want to print a 2d array using a two two string method can I do that or should I iterate over this array I will tell you you can do both okay so you can use a inbuilt method to print this entire array you can also iterate over this array let us first look at a inbuilt method if if you have a structure like this right so you have to you just don't need to iterate over these values but instead you need to say okay uh I also need to iterate the objects they are referring to right so basically it's kind of a recursive structure right so this is refering to some object this might also be referring to some some other object right so I want to go deep inside this structure and iterate over all the values right in order to do an iteration like this what I have to do I have to use a method called as Aras dot deep to string I iterate deeply inside these structures and then print this array if I call this method right arrays do deep2 string what will happen it will go inside those arrays those rows as well and it will print them right if I go and run this code you can see this is the output that I'm getting right I hope you're able to understand the difference okay now how this 2D AR is stor just a quick recap this array this ARR is a 1D array which is holding three rows in it so three rows each row is a 1D array object containing four numbers so now let us do one more thing Let Us write a method called as print that is going to iterate on this 2D array right so sometimes we have to manually use a for Loop to iterate over a 2d array let's see how we can do it so public void uh public static void it's a reverse input is a 2d array so I will create a reference varable AR how do I iterate if I simply say s out ar. length can you guess what is this length going to be what is the length of this array this array is holding three items this length is giving me the number of rows I have if you want to figure out how many rows I have in this array these are the number of rows how many columns I have in this that is nothing but the number of elements in each array is the number of columns so I can say if it is a fix size array rows cross columns rows will be nothing but uh number of rows will be nothing but array dot length how many columns I will have that is nothing but array of 0 do length the number of elements in the first array if this is same across like all the arrays the number of columns I know right how do I iterate iteration is pretty easy I can say I equal to z i less than then the number of rows I ++ and then I can say okay for J equal to Z J less than the number of columns j++ s out array of i j so let's see uh what does it really mean so if I have an array like this let's say 1 2 3 4 5 6 7 8 9 this is one object another object this is object array of zero I iterate over rows I is zero so array of Zer is fixed I go over 0 1 2 these are the row numbers for each row number I see okay iter over the columns array of I gives me this then using this J gives me the column so AR of 0 0 gives me 1 AR of 0 1 gives me two AR of 02 gives me this number so J is going along this direction I is changing across R right so what I'm going I'm going over each aat object and then I'm using a j to Traverse the elements of that particular row this is how we generally do the traversal right you can also do it other way around so I'm iterating across the rows you can also iterate across the columns by changing the order of these okay if I show you the output I okay I'm going to print them in the same line and after my row is finished I'm going to give a new line so I can say s out print Ln so now if I call this method that is going to be Traverse and I give this array I will see an output which looks like a 2d array right let us go and run this code and you can see it's I'm able to iterate over all the rows and for each row I'm able to iterate over All The Columns of that particular row or all the numbers in that particular I hope traversal is clear to you now some of you might ask that okay can we do uh some kind of sorting on this 2D array maybe I want to compare each row with some other row okay so I want to do sorting across the rows I want to sort rows and you might have a different criteria you might say Okay I want to sort on the basis of first element or I might want to consider the sum of all elements right so how do I do that so it's very easy so consider each row as one object and I want to compare this with other objects right what I can do I can use arrs do sort method it will assume that I'm going to give you a 1D array that's okay so it's going to and this this is actually a 1D array okay although the syntax is 2D array but Java consided this has one element of the array this has another element of the array and this has another element of suppose if I want to sort according to their sum right what I have to do I say okay fine I will give you two objects what are the data types of these two objects these two objects are arrays I have int square brackets object one int square brackets object two and in return I want to uh get their sum so I can okay I can create some method called as get sum in public static int get some given a 1D array I want to find the sum of that array I give some array I want to find the sum of that I want to sort these rows according to their sum so basically the row which has a higher sum should come at the end of this array how do I do it first let's write a helper function to get the sum so for now I can say uh int sum equals to0 for INT value inside this array I can some equal to sum plus Val and I can return this finding the sum is pretty easy now here in my Lambda expression I can see okay I'm going to compare on the basis of some of these arrays so array one which is my object one minus get sum of array to which is object two that's it and if I do this and now I want to show you the output I can again print this array after doing the sorting and let us see what do we really get now if you look carefully I'm getting this array first which has the least sum this array has a higher sum and this array has even the highest sum why because I'm I have a very big element 400 you can verify so what I have done I have written a Lambda function that is comparing two rows any like internally it will call some logic to compare two rows okay so it is comparing two rows according to their sum if you want to compare on the basis of first element or the last element that that that can also be done so if I do this once again here I can okay uh o1 dot get last element how do I get it can okay o1 dot 10th minus one that is giving me the last element and O2 of o2 do length I'm saying okay let us compare on the basis of last element in that case this array will come first then this array will come and then this array will come if I go and run the code once again let's see what do we really get okay so I'm getting 10 100 and 400 that is how powerful these Lambda functions are they can also work with 2D arrays but now you're not going to compare uh you're going to you are going to treat each row as one object okay that is something that you must learn so we have seen how do we work with a 2d array but we have not seen how do we take input a 2d array of size n cross M and read it from the user okay let us do that as well first of all I'll create a scanner so that we can read numbers from the user so scanner SC this is equal to new scanner and uh let's read how many rows we want to create number of rows is scanner. nextend and number of columns is also going to be scanner do so I'm going to create a 2d array of size n cross M so how do I do it pretty simple I Define variable ARR is of the type in square bracket square bracket this is equal to new in and here I Define the number of rows is n and the number of columns which is M once I do this Java will create an array in which I have let's say n equal to 3 and M is four it's going to link these like that internally This Is How They will get created now what I want to do I want to read numbers and put them here I want to say okay 1 2 3 is the first Row 5 6 7 8 is the another row how do I do it I have to go to the zero index then I have to iterate over uh from J equal to 0 till Jal to 3 0 1 2 3 then I have to go to this index read this array I have to go to this index read this array let's see how we can do it I can say for in I equal to 0 i l than n i ++ then for each row I need to read the elements J equal to Z J less than M j++ and array of I comma J in the I Row the jth cell I want to read a number scner dot extent fine this is it it's once this is done I have read all the elements now what I need to do I need to print so I can say Okay s out RS do uh deep to string and I will give it I need to import java. so let us run this code and see are we able to read an array from the user or not let's say I I want to have three rows and four columns I need to give data let's say I'll give 12 elements 1 2 3 4 5 6 7 8 9 10 11 and so yes I'm able to create an array with three rows and four columns and you can see first row second row and the third row so this is how exactly we cre a twood dimensional array and this is how the memory representation of 2D array looks like this is my variable AR okay so let's move on to Jag D next so we have seen how do we work with a 2d array but we have not seen how do we take input a 2d array of size n cross m and read it from the user okay let us do that as well first of all I'll create a scanner so that we can read numbers from the user so scanner SC this is equal to new scanner and uh let's read how many rows we want to create number of rows is scanner. nextt and number of columns is also going to be scanner. so I'm going to create a 2d array of size n cross M so how do I do it pretty simple I Define variable ARR is of the type in square bracket square bracket this is equal to new in and here I Define the number of rows is n and the number of columns which is M once I do this Java will create an array in which I have let's say n equal to 3 and M is four it's going to link these like that internally This Is How They will get created now what I want to do I want to read numbers and put them here I want to say okay 1 2 3 is the first Row 5 678 is the another row how do I do it I have to go to the zero index then I have to iterate over uh from J equal to 0 till J equal to 3 0 1 2 3 then I have to go to this index read this array I have to go to this index read this array let's see how we can do it I can say for in I equal to Z and I less than n i ++ then for each row I need to read the elements a equal to 0 J less than M j++ and array of I comma J in the I Row the jth cell I want to read a number scanner dot extent fine this is it it's once this is done I have read all the elements now what I need to do I need to print so I can say Okay s out RS do uh deep to string and I will give it I need to import java. so let us run this code and see are we able to read an array from the user or not let's say I I I want to have three rows and four columns I need to give data let's say I'll give 12 elements 1 2 3 4 1 2 3 4 5 6 7 8 9 10 11 and 12 so yes I'm able to create an array with three rows and four columns and you can see first row second row and the third R so this is how exactly we read a two dimension array and this is how the memory representation of 2D array looks like this is my variable AR okay so let's move on to Jag D next let us discuss what is a Jag d right a jagged array is a array with variable number of columns variable number of columns in now how this is possible let's see let's see an example let's say I have three columns in one row in another row I have let's say four columns and in another row I have just two columns can we create such an array the answer is yes why because when you create a 2d array in Java each bucket is referring to a array object now each array object is independent of the previous object that we have created what I'm saying is we we are creating three different objects for three different rows and each object can have its different length for example this length is two this length is four and this length is let's see how we can create an array like this Java it's again a 2d array which looks like this 1 2 3 4 5 6 7 8 and 9 in this case we don't have fixed number of columns in each row number of columns are variable in each row how do I do it so let's see I'll start by creating a scanner equal to new scanners in now I'm just going to read the number of rows from the user is scanner. next Once I know the number of rows I can initialize my array I can say in square bracket square bracket ARR this is equal to new end and here I just Define the number of rows is okay I need R number of rows how many columns are there I will tell you later what does this code do it creates an ARR that points to an array that is going that will hold that will hold these array objects but they will be created later it's only going to create an array with r number of buckets inside okay these these will be created later this part we will do next right now what I need to do I need to iterate over each bucket I = to 0 I less than r i ++ now I'm going to ask okay tell me how many columns you are going to uh have in this row I will ask the user I can accept a columns in current row how many columns I'll ask the user to tell me number of columns in the current row you can also output here s out columns in current row it tell me how many columns will have in the current row and then you can say s out data in the current row maybe if I I have two three columns then I will run a loop three times to read those numbers so I'll say okay for in I equal or in J equal to Z a less than um columns in the current row j++ now the thing is where should I store this data this array object is not yet created first I have to create an array object here in which I should be able to store data how do I do it I said fine this array of I array of I is this bucket it should uh point to a new 1D array in which I can hold these many these many numbers that is equal to columns in the current this line of code you'll actually create this array and suppose this address is now 72 this is stored there 7 and this link is established now I can read data and I can store it and this thing we will repeat for every row I'm iterating over these buckets now and I'm going to say okay read the next number and store it here so I can say uh array of I comma J this is equal to scanner dot that's it and in the next iteration we move on to the next row and we do the same work in we ask how many columns you have in the next row it says okay I have four columns I create an array of size four and I link it here using this line and then I again read it I read these let me show you uh by running this code that we can actually create a jagged array s out arrays dot uh D to string and I can give ARR here and again I have to import java. so let's go and run this I want to create an array with three rows now I have to tell me how many columns in the current row I say okay four columns and then I have to tell me what are the four numbers in that so let's say 1 2 3 4 then in the next row how many columns maybe just the columns and the numbers are 78 9 then in the next row let's say to two columns the numbers are let's say 10 and 20 what do I see I see a jaged array four columns three columns and two column this is how we can create a array in which every row has variable number of elements and this is called as a jaged aray now we are going to look at Dynamic arrays so far the arrays we have created they had a fixed size once you create an array of size n you cannot add more than n elements into it that is where Dynamic arrays come into picture for example you're building a to-do list where you can keep on adding tasks every day and you might be removing some old task as well so you do not know how many elements you would be storing in your list so you need something like a dynamic are in that case right in Java Dynamic array is provided by the library U as a part of Java Collections framework the class is called as AR list we will also see how this class internally works but before that we will look at a demo of using AR list okay an array list is a dynamic array for storing elements it's like an array but with no size limit it also maintains the insertion order that means keep on adding elements and they will get added at the end of this array right so if I say okay I want to add six I want to add seven I want to add 12 they will keep on adding in this at the end of the array we can add elements we can also remove elements and it implements the list interface in Java so we can use all the methods of the L list interface here so list interface is part of collections framework and I've done a detailed video on collections framework link you can find in the description also you can uh watch that video if you want to learn about more about the collections framework and various data structures present inside the Java Collections framework now how this array list is implemented let us talk about how this array is actually Dynamic how does it grow and shink one way of implementing the ER list is start with a some fixed size array so I guess in Java this fixed size array is having a default size of 10 so whenever you okay I want to uh create an ARR list it will give you sp for 10 elements but as soon as this gets full right you see okay I have used all the elements right what it will do it will double itself now you cannot double in the same memory because this memory might be occupied by some other data structure or some other part of the program what it does it looks for new memory in the Heap where it creates a array of the double size and it's going to copy the old data into the new array let's say this data was 1 2 3 4 up to 10 it's going to copy all this data in the new array and then the remaining elements the remaining 10 boxes are available for putting some new data right once this gets full again you have to do the same thing again double the old array by creating a new array copy the data from the old array and you have to delete the old old array so in Java the deletion is done by the garbage collector for example if this is my old array and I say old ARR equal to null what does it mean no one is referring to this array this object becomes eligible for garbage collection okay so in other languages like C++ you have to use the delete keyword but but in Java the garbage collector takes care of objects that no one is referring to so first let us first look at the demo right so to be precise in Java uh so Java maintains something called as a load Factor load factor is what percentage of your array is currently filled right so if I say okay if my load Factor goes more than 7 that means if I have space for 10 elements and I put eight elements in this array right that means it is the time to double the right so right now I was doing it full capacity but you can also do it early if your 70% of the are is full right so that is your current size Upon Your Capacity if this percentage exceeds 7 so Java triggers this function that doubles this array so it creates a new array copies the data here and you have more space available for storing um new elements okay ideally if you know that okay I'm building a application in which I will require space for around 1,000 elements it is better to initialize your error list with the initial capacity of th000 so that your doubling does not happen again and again and if you okay I need maybe 1100 elements so take a safer limit okay and you took okay I created an array with thousand elements that is fine it will double one time so from 1,000 it will become 2,000 right in 2,000 you can easily store 1100 elements basically you should have a rough idea of the range how many elements you would be needed and accordingly you can initialize a error list so that your repeated doubling operation can be minimized and doubling is a expensive operation why because it copies all your data into the new array which is going to take linear time right that is how the internals of the err list work right so let us also talk about features err list is a dynamic data structure and uh it can grow dynamically it can also shrink as we remove elements from the list so again there is certain criteria okay when 20% of the list is occupied I I might shrink it to the half something like this we can have a conditional condition on shrinking as well just like we have a condition on growing second thing is it it is ordered it preserves the order in which the elements were added to the list it is index base just it's it's an array internally right so it it also has indexing so if you want to get this element you will say Okay array dot get zero it provides us with a get method and I need to tell okay this is the index I need to um access right and okay and err list can also store uh it can only store object data types that means it cannot store primitive data types like int if you want to create an array list of inss you will have to use the corresponding rapper classes okay so you have need to have some idea about rapper classes I can create an array list of integer where integer is a rapper class for INT data type right it cannot be used for primitive data types we require a rapper class in that and another thing is it is not synchronized so if you need a congruent data structure then there is a something called as Vector which is a synchronized implementation of error list okay so this concept is pretty Advanced if you're working with multiple threads and stuff then you might be using vector so let us look at a demo of using Eris before we jump into the code let us talk a little bit about the kind of operations we can do on an aist so one common operation that we do is we want to access any element so it is called as random access that is done using the get function I can get any random element in order of one time which is pretty obvious because internally it is accessing the array okay then I can add elements I can add elements at the end of the AR list which will take order of one time but you can also add elements in the middle of ARR list which will require shifting of elements okay inserting elements in the middle it's going to take order of end time similarly deleting something from the middle is also going to take order of hand time because remaining elements will have to get shift searching in general it takes order of hand time because it's going to use a linear search right but if you have a sorted arror list you can use your own binary search method or you can use collections. binary search method to search in order of login in order of login time if your error list is SED okay so how do we create an Nal list it's a predefined class in Java Collections I can okay error list of a following type followed by name of the variable followed by new eror list and this will create an error list with a default size default size in java it is 10 right for example an array list of strings can be created like this and it does not work with primitive data types okay so I told you that you have to use rapper classes you will have to say array list of integer if you say array list of int it will not work so you will have to say array list of integer right this is equal to new ARR list that is how you will create a ARR list object in Java next thing is uh you can also give some default size so basically the ARR list class has three Constructors in in one Constructor you can you don't give anything so it it uses a default size of 10 in another Constructor it accepts you give me the default size and I will create an error list of that capacity so I'm saying 50 that means it is able to hold 50 objects in this AR list and once you reach 50 capacity it will double itself right and there is a third Constructor as well in which you can initialize an ARR list from some other list or from from some other collection as well that can also be done for example in this case we have a list of strings and we are initializing the error list using this list that is the third Constructor call that is being done right so one more point to note about error list is it allows us to store hetrogeneous elements as well for example I can add an integer into it I can also add a string object into it right we can store objects with various uh types in an ARR list instance also in this case when you're creating this ARR list object you don't need to parameterize the instance you didn't don't need to Define what kind of data it is going to hold it will hold all types of objects in it right you can put a string you can put a book you can put a dog anything will work in the same AR so that is about uh how do we create an ER list now I will show you a quick demo as well so I did this demo in Java Collections video that I have already done so I've shown you that you can create an array list so the first four lines I show you we are creating an array list in which we have not defined the data type then we are pushing an integer then we are adding a string and then we are going to print it let me just run this code and let me show you the output I need to run this yeah so if you see here I'm getting an ARR list in which one item is a integer object the other item is a string object so we can definitely do this I'll comment it out then I can say okay uh create an ER list because error list implements an interface so I can say this left hand side data type can be more generic it it can be it can have list as the data type that is perfectly fine because an error list is an implement of a list so I can call the add method to some add something at the end I'm saying add one add two add four then I can also use this add method by specifying the index so the add method is overloaded there are two add methods one which adds at the end and one which adds at a particular index I'm saying okay at the second index you should add 15 so it becomes like this 1 2 4 then at the second index which is 0 1 2 I want to add 15 here it will become 1 2 15 and 4 this is the output that we get then I have created another list in which I have added 25 and then I'm using a method called as add all add all is used if you want to add all items present in one list into another list add all will iterate over all items in list one and it will add them into list two so you will see 25 followed by all items that are present in list one are now present in this tool so just like that we have a remove method remove method is also um there are two remove methods the one remove method which accepts an integer so if I show you something like this list. remove so you can see one remove method accepts the index and second remove method accepts the object if you have to give the object of the type integer you have to typ cast into the integer data type so I can say Okay integer do value of one it will mean that I'm I want to remove one from this list but if I simply pass one it would mean that I want to remove the element at index one right that is how the remove method works right and if you want to search something then there is a contains method will tell you okay whether the following integer or following object is present inside this list or not that is your searching method now there is one more method that is called as set set means I want to update something so if I want to say Okay I want to update the zero index and this is the object that I want to store at the zero index if I do this you will see at the zero index instead of 25 now the new element that I have stored it's going to be 50 and apart from it we can iterate over the list so list do size gives me how many elements are there right not the capacity but how many elements are currently present that will give me and I can use the get function to get the ith element from this list that is one way of iterating over an error list you can also use a for each Loop if you want to um iterate over the entire list and Third Way is you can also create an iterator object and while iterator do has next so has next tells me whether the next element is present in the list or not while it has elements keep on iterating and you access the next element using the next method so that is another way of iterating over the err list so you can use this methods and you can work with err list while solving a lot of problems okay so that is about error list and if needed you can also refer the Java Oracle docs to go in more details of these let us come to the final part of this tutorial so so far you have worked with arrays you have worked with array list and now I want to show you if you want to build your own Dynamic array class okay just just for your better understanding of ARR list suppose you are asked to implement an array list at your own how you would do it what we want to do we want to implement a class called as Dynamic array what what thing we learned first thing is it internally uses an array that means one data member of this class would be an array and this array would have some size also we will say okay it has some default capacity right this capacity can be provided by the user or we it can have some default value as well we will look at that and then if you start putting elements start adding elements in this aray you also need to maintain how much array is full so maybe current size maybe the current size is three right 0 1 two if if the next element comes can I insert it at the current size index can I insert it at the third index yes I will insert it at the third index let say the element is four and I will increment the current size right so it is clear that I need one data member that is array one data member that is current size one data member that is capacity and maybe one constant where in which is going to store how much should be my uh default capacity so that I can call it as default so by default the capacity of this array should be so let us create these data members I've created an array right I've created a capacity I've created current size and I've created a default for which the value is 10 now user says Okay I want to create a new Dynamic array object how you're going to initialize uh these variables okay so suppose I do not give you any default capacity I will need a Constructor right and in the Constructor what I will do I will initialize my array equal to the default size a default of size 10 I will say okay the cap capacity variable is also equal to default right why I need this capacity because capacity can keep on changing if 10 size 10 gets full I will make it 20 if 20 gets full I will make it 40 the capacity will keep on doubling and current size that is going to be zero right because I've have not added anything but suppose if the user says okay no I'm going to give you uh the default size of the array then how do I do it in the Constructor will accept okay you tell me the capacity I will uh initialize my capacity equal to that capacity and I will create an array of that capacity right and current size is still zero okay so that is how the Constructor is getting created the third Constructor in which I get another list and then I create this I'm not creating that I'm writing a simplified version of an array list right now suppose I want to add something into my ARR list how should I do it very simple I will Define a method called as ADD and I uh will I'm just printing the capacity as of now but I will remove this statement so that we can see while running the code I can say array of current size this is equal to data basically in the beginning my current size it is zero and I get some data let's say data is five I said fine array of zero this should be equal to five and I say current size Plus+ so my current size becomes one so that means next time I will do an insertion here again I get a data that is six what I do I put it here and I increment the current size to two next time my insertion will go here now suppose I keep on adding elements and after some time my current size becomes equal to the capacity okay so my capacity was 10 and my current size is also 10 that means I have already inserted 10 elements if something like this happens that okay my current size it's going to be equal to the capacity what should I do I need to double my array how how I am doing it let us try to understand that so let's say I have an array of size of capacity 4 okay I insert one element current size becomes one I insert one more element current size becomes two I insert one more element current size becomes three I insert one more element my current size becomes four current size is equal to capacity if this happens and this is my ARR what do I do I create a variable called as old array I say okay old array pointing to this ARR the old array then I say ARR which is the data member of the class it should refer to a new array which has a double capacity it should have double capacity so that is what I do here then I iterate over the old array I iterate over these elements and I say array of this is equal to Old array of I I copy all these elements here okay fine I do it what should I do I say old array this is equal to null so I break this connection that means no one is pointing to this array now the garbage collector will delete it here the garbage collector will get invoked and of course for the new array we have updated the array property but we have not updated the capacity property the capacity was still four but now the capacity should be I'm saying capacity equal to tce of capaity what what do I do I first check if my array is full I double it and then I can insert data into I say array of current size array of current size is still four so 0 1 2 3 four at the fourth index I can put the new data Maybe the data is 50 I put it that is how I implement the doubling operation inside my array suppose I want to to remove something so removing is easy right I'm not uh removing from an empty array so that check you have to uh either you do not either you put some conditions here or you throw an exception right I'm simply saying okay I want to remove an element I'm simply removing the last last element so this is my current size I said okay I'll reduce the current size and it means okay I am going one step back current size minus minus I'm removing one element from the array right the element will stay here but next time you add something it will get overwritten okay and if you have to iterate you will only iterate on uh on this range doing current size minus minus will remove the last element as well now there are some more methods we can Implement for example if I want to um get the I element that is pretty easy you simply return array of I if I want to get the capacity how many elements my array list can hold I can say return the current capacity I cannot use accesses directly because it is a private variable so I have created a getter to return it then if I want to get how many elements I currently have I say okay there is a function called size that I've implemented it is going to return the current size now you can um create more methods you can create a method called contains in which you will Implement linear search and you will tell whether that element is present or not okay you can Implement a method called as index of in which you will return the index of the element where it is present so instead of returning a Boolean you can return an integer index as well right you can also overload the remove method where you will get a integer value so either you remove the element at that index or you remove that value right so you can do something like that as well right so the internal implementation is bit more uh I would say it's more robust it is more power ful but this implementation we did so that you get an idea how the doubling operation in an array list is actually working okay how things are happening behind the scenes Let Us test our class by uh creating a dynamic array object okay my class that I have defined it is called as Dynamic array I can say Dynamic array da this is equal to Dynamic array and I want to use some methods inside it now let me say default sizes is five instead of 10 so default capacity is five a do add 1 let me just add five elements let me say one uh 2 3 4 5 now at this point I want to see what is the size of the array and what is the capacity of the array let us see s out uh d a a do size and S out da do capacity both should be five at this moment but as soon as I insert the Sixth Element the size should be six and the capacity should be uh okay so both are five at this moment let me insert one more element let me da do add six and now if I add this element you will see the doubling operation will get triggered right that means the capacity should be now 10 the size should be six yes that is happening right so your array of size five it got full and as soon you at Sixth Element it it doubled itself that doubling thing is happening right you can see here now I can uh also say Okay I want to add seven I want to remove the last element and then I want to add eight that means I added seven I removed one element I added it so seven will get overwritten by8 and if I want to iterate on this array and see right what all elements are there so I can for in I equal to z i less than n what is n the number of basically da do size the number of elements present I ++ and I can say s out I want to get the ith element I can say da dot get I element I want to show them in a straight line I'll do s out here and like this [Music] so you can see like 1 2 3 4 5 6 7 8 now you can also Implement a method called as two string which will simply iterate over the array and join all these numbers inside a string so you can use the two string method also to print your Dynamic array right so instead of after reversing you can give this as a method inside the dynamic area class as well so let us begin with link list what is a link list a link list is a linear data structure in which the elements are represented as objects and they are stored in non-continuous memory locations okay so one thing that you need to note about link list is it's a dynamic data structure right so unlike an array where you need to tell okay I want an array of size n you don't need to specify the size of the link list every time you get a data you create an object you put the data inside it and you put it in the form of a chain or in in the form of a linked list right so why the name linked list because we have lot of nodes okay each node is a object in a heap and these nodes are connected with each other right how they are connected so each node is created at some memory let's say this address is 205 so the previous node knows that the next node is present at this address right two will know the next node is present at some address so that is also going to store there right so each node is going to store two things one is your data and one is the address of next node right so if you know the address of next node you can easily Traverse the data structure and you can also put things in a ordered way right so every time you get a new data we can insert at the beginning we can insert at the end we can also insert in the middle right so it's up to you how you want to maintain the ordering inside the link list right one thing to note is it's a dynamic data structure and the nodes in which the data is getting stored they are stored in noncontiguous memory locations unlike an ARR right so that is what link list looks like right now in link list we do not specify the size as I have already discussed with you and it is a dynamic data structure it automatically changes size when an element is added or removed so we'll go into the internals of how addition and deletions are performed on a link list in this tutorial so while doing the implementation I will show you that okay if there is a node how do I connect the next node how do I add something in the beginning how do I add something in the middle how do I delete something right so the fundamental operations that we will be learning would be addition okay removal right and getting a node right so I want to get a particular node I can how do I get that not right so given an index I can iterate to that Index right one thing that is bad about link list is if you suppose want to get the middle node right in arror you can say okay give me the I element so this this property is called as random access so link list is a bad data structure if you need to access I element why because you cannot directly get this element you have to Traverse the LI positions to get this element right so it's it's bad at getting nodes it's bad at random exess but it is good at certain things that we will see all right so that being said let us jump into the implement mentation of Link list so now let us dive into the implementation of Link list so far what we have learned is that link list is a chain of nodes in which every node is connected to the next node okay if there is a node one it must be connected to the second node let's say node two right the way to do it is that in every node we also store the reference of the next node okay for example if this node is created at some memory location let's say 206 then this node must store what is the reference of this node where it is created right and for the first node what we need to do for example if this node is created at some some location 115 then we need to store this location 115 in a special variable okay we generally call this special variable as head right okay and second node will store the reference to the third node and so on right so third node maybe it might be at 480 so I might be storing 480 here right now the first step in the implementation is that how do we implement this structure okay this uh object that we see here so we are calling this object as a node object right what I will do I will say okay I will Define a node class and this is capable of holding two things one is my data and one is my reference right so each of these boxes is a node right so each uh node is going to hold a data now a data can be of a different type as as well so just for the sake of Simplicity I'm treating it to be a integer but it can be a image it could be a book it could be any object right and second thing I have is a reference to the next node right so how do we uh store a reference to the next node right I say okay uh this will be of the type node and let's call this variable as next right so we have data and we have next so if you're confused I will explain you uh what is this concept so let us first start with the code let us create this structure and let us try to understand that okay inside the node class you can have an object reference which is holding the address of the next node right so let us go into intellig and I have created a package called link list data structure and here I'm going to create a Java class called as let's say node. Java right now it automatically creates a class for me but it does not have data members so how do I add data members I can say Okay I want data and I also want something called as next so that will be of the type node now this does not mean that there is there will be an object inside an object no this is only a way uh this node right it's only a way to hold the address of the next note right so this is of the type object reference I will tell you right and let me do one more thing let me add a Constructor here as well so you will see why we need a Constructor let's do one thing let's create main right let's create uh link list demo another class in which I'm going to test my functionality in this class I will create my main method where I'm going to test my functionality right let us create a node object guys okay node a this is equal to new node right now this no this does not hold any data right so a a is not going to contain any data so by default the value of integer is zero right and next would be null right so what I can do I can say Okay a do data equal to 5 a do next equals to null and if I say okay s out a do data what what I'm going to get let us see right so I'm getting this uh value is five which is absolutely correct right now why this is happening let's see so what it did writing this code it created a node right and what is a a is ref referring to this note so a is a address right a is a object reference so a is another bucket which is holding the address of this node so this node has two things one is my data and one is my null so this is your data and this is your next and this node has been created at some memory location in the Heap right this is my Heap memory so a this address might be let's say 508 right what is a holding a is holding holding 508 this is what is exactly happening behind the scenes so in this case this a is also an object reference right and it is referring to an object inside that object I have one more reference okay how do I access this value I access this value by a. nextt this is what is happening when you are creating this note right it is giving you it's wrapping up two data members inside one bucket inside node you have an integer value and a reference to the next node right if I say okay there is one more node right let's say node b equals to new node and I say Okay a do next should refer to be so if I print out what is a. nextt so a. next is nothing but it is the address of the B node that we have created or the value that is getting stored inside B right now if you see this is the reference of the next node right so let me show you through a memory diagram so a is refering to a node okay a is five b is some other node so let me do it like this so a is a variable that is holding this address let's say 108 this value is five and B is 30 C right so B is some other node b is another variable that is is holding this value 30C right and this is the address of next node I don't have any data and null value here so it will be the default value of integer and uh next right so that will be zero and null right so I have zero and I have null now B is referring to this so when I say A next equal to B so inside a do next which is this field I'm copying whatever is present in B so I'm copying 1C it means in a way this B got connected with a right now even if I lose this variable B this chain is still connected right so this is how we are going to work with nodes and we will write one more class that does all this manipulation of nodes okay we'll call that as a link list class right so I hope this node concept is clear what is a what is new node the new node is getting created in Heap in this case this is a reference variable here and this variable is created inside stock at this point right so what I will do I'll remove move all this code and I will do one more thing instead of like every time doing a do data equal to something ax equal to something I will Define a Constructor inside this class I call it as node it will accept some integer let's say data it will accept some value of next but in general we will not know that value of next okay so whenever you creating a new node you know the data you say Okay I want to create a new node with data 7 what will be connected in the next node we do not know at the moment right so what we can do we can leave this variable initialized with the default value right so I can say this do data equals to data I'm initializing this variable with the data that I'm getting right so since the two variable names are same writing this here is important so that compiler knows that we are talking about this data member as attribute right and uh next what about next so you can say next is null or you can do this do next is null both are fine both will work right this is the Constructor for the node class right now if you want to create a node a now you will say Okay node a equals to new node you just give the data as five and you say node b equal to new node you say data is six and a do next equal to B this creates a very simple link list in which we have two nodes okay so if I say s out a do data and show me what is the data in the next of a so how do I do it a do next gives me the uh address of B do data so I say five followed by six right so I will see this I see five followed by six so what we did we simply created a link list in which we have just two nodes this is a this is B right okay and a do next is storing b a NEX is storing right now you might say okay this is this looks very easy but if I have to add 10 nodes 20 nodes 100 nodes thousand nodes will we create so many variables and attach them manually the answer is of course no we will write an algorithm that does insertion in the link list deletion in the link list and it helps me to get the nodes in the middle of the link list or at the end of the link list or at the beginning of the link list right to do all these operations what we will be doing we will be writing our own link list class so what I will do I'll create a new Java class and I will call it as link list. Java in which all these operations involving these nodes will be done right let's see the implementation of Link list so let us see the implementation of Link list now suppose you are U you want a data structure that is like in the form of a chain right and you want to build certain methods you want to say Okay I want to do addition in this link list that means I should be able to add more nodes inside it I should be able to remove nodes from this link list and I should be able to uh get the noes from this link list that means I want to read nodes from the link list right now the add operation it can happen at three places right maybe if there is a link list like this you can okay I want to add something in the beginning of the link list like can Okay add at the first position or you might say Okay I want to add something after the last node right so you might say Okay I want to add at the last node or I might want to say that that I want to insert something in the middle so I might be doing something in the middle or at a given location okay at a at a given position inside this uh link list right similarly remove can happen at the beginning so I will say remove first would be an operation remove last would be an operation and remove at a particular position can be an operation similarly get means okay I want to read something I want to get the first element I want to get the last element or I want to get the middle element right so I will say I want to get first element last element and element at a given position right so what we will be doing we will be implementing these operations right now in order to implement these operations right what is important let us start by understanding how my ADD ation will work right so whenever you want to add something so one thing you need to know is what is the starting point of the link list right so suppose you want to add something in the beginning you must know the starting point or you want to add something at the end right the one way is if you're adding something at the end right that means if you're creating a node here you must access this node and update the next variable of this node right you would say Okay um in the ending of this node I will attach this Noe one way you all always iterate till this point starting from the head and this will actually take order of end time if you iterate from here to here it will take order of end time so I don't want to do that what I will do I will say okay every link list will at least know what is my head and what is my tail I will keep another reference that always point to the last node of the link list whenever you will add a new node at the ending of the link list I'll say okay I'll modify the tail node I will attach the node and I will update my tail variable to go here right so let us see how these operations are implemented so what I'm trying to tell you is that if you're implementing a class called link list this link list will have data members okay something that the link list should know okay and some operations that the link list will does right so here are the operations they will be part of the methods right and we will have some data members or attributes what are the data members what are the things that the link list must know one is head what is my starting address one is the tail what is my ending address so again keeping this is optional but I want to optimize certain operations for example add at last should not be in order n operation it should be in order one operation I need to keep the tail variable as well right and maybe some optional information like size how many notes I have in the link list okay so maybe I want to implement a method like get size how many items are already inserted in this link list this is a useful operation we want to check okay if the size is zero that means link list is empty right other ways you can check if the head is null that also means link list is empty right so we will also implement this operation like uh get size and maybe we'll Implement operation like display I want to show the entire link list okay or or you can Implement a method like two string iterate on this link list and convert it into a string so that is just like a display method I want to show the entire link list to the user right so let us start by implementing these operations one by one so this is my link list class so first of all what I will do I will add some data members and I will add a Constructor to it it's okay I want to create a head so node head again head is a object reference hence it has the data type called as node right then I will have node tail and one thing I can do is I can make them private so private node head and private node tail I don't want people outside the linklist class to know where is the head node where is The Tail node so I will not expose this data outside the link list class right and I can also say private and size I'm not making it public because I don't want this size to be changed by someone outside the size should change automatically when something is is inserted or something is removed from the link list so it should be a private variable only Changed by the link list class right next thing I want to do is I need to initialize a Constructor okay when whenever user says okay give me a new link list what should I do that link list will have zero nodes inside it so I need to initialize these three data members as well okay link list there is a Constructor here and what I want to do I want to say head and tail they will be null and the size will be zero okay so this is my Constructor now what is the first thing I will do I will say Okay I want to do an insertion so I will add I'll write three methods one to add something at the beginning something at the end and something at a given position in the link list that's okay public method and the method is of the type void add and let me call it as ADD first and public public void at last and public void add at a particular position so add add in all the three uh methods I should know what is the data that I need to add and in the third method I should also know at what index I need to add right now take a pause and think how you will Implement these methods okay if you given a link list and you want to add something at the beginning of the link list how you would add in okay so what will be the code behind this method take a pause and think about it okay so let us discuss the first method add first now suppose you have a link list right let's say this is a this is B this is C this is already there and head is referring to this node I want to okay I want to add another node D which is at the beginning of the link list right so how I will do it so first thing is I need to create this node so how do I create a node object very easy I simply say let me create a node called as n this is equal to new node and the data of this node is same as this data that I've given so this creates a new node and N is refering to this node right N is a object reference a local reference created inside this function which is refering to this particular node what should I do how do I connect this I would say Okay n do next should refer to the head so if head is already there n. next should connect to head so it it makes this connection right one thing I need to do is I need to say okay this head it should move here right this head should not refer to a Instead This head should refer to now D I can say head is equal to n this will work really well and one more thing I will do is size Plus+ every insertion will increment the size of the link list right so this will work really well if if the link list is already there right but suppose you're creating the link list for the first time and you call the add first method so head and tail both both were null right and you said Okay I want to create a new node so you created a new node called d and n do next is equal to head so head was null so D is next is also null which is fine right and then you say head is equal to n this head Point refers to this node which is also fine right but the thing is the tail is not getting updated right whenever the first node is inserted right let's say the first node is a both head and tail should refer to this note right what I can do I need to I need to add a separate condition that if what if the size was Zero before adding this node in that case my tail will also get update so tail should also point to head or tail should also refer to and right this is a special case case when you have zero nodes in that case you also need to update the tail right so this is my ADD first method let us test the functionality of art first method so what I will do I will go in link list demo it's okay I want to create a link list L this is equal to New Link list and now in this I can say Okay l dot at first and uh I will give some data let's say 10 and say l do add first I will add 20 and then l l do add first I will add 30 right so I want to see this link list so I will call the display method which I have not implemented so I will we will implement the display method as well right so let us go back into the link list class and let us add one more method public void display right so how do I display the link list now it's going to be pretty easy easy suppose the link list is 30 followed by 20 followed by 10 right and head is refering to this node okay tail is refering to this node so this is 10 so tail is referring to this so what I need to do I need to start iterating from head till the end so I say okay I'll take a temp variable I will print it and I will take temp here I'll print it I will take temp here I'll print it I will take temp here right so what is happening so once my temp reaches null I will stop what I can do I can say node temp this is equal to null so temp is again a reference it's not a node right so sorry it's it's equal to head it starts from head and while this temp is not equal to null what do I do I print the node I say s out temp. data and take this temp to the next note temp equals to Temp temp dot temp goes to the next not this V Loop will help me to iterate on the entire link list right so temp starts from head temp is referring to this node I print out 30 temp equal to temp. next so temp. next means this value so this value means this node so temp goes Here Again temp dox means this value which is this note temp goes here again this is not null this node is not null so I say temp. next which is this value which is null so temp actually becomes null and my Loop stops right now the display method is there and we can run this code okay so I see 30 20 and 10 which is okay that means my link list is getting created but to show you in a linear fashion what I can do I can put a arrow here and I can put a new line here right this will make the representation look little better right I'm getting 30 20 10 if you look carefully I added 10 in the beginning so 10 got added that means my head and tail both were here right then I added 20 in which 20 got added here and my head moved here right then 30 got added a new node was created it got connected here and then my head moved here right this is how the link list is going to look like 30 20 and and I hope you're able to understand the add first method right now on the similar lines what we will do we will implement the method called as ADD last or take a pause and think how you will implement the add last method all right let us see right now suppose you already have a link list a b c and I want to add a new node D which is at the end of the list so this is my head and this is my tail right so how do I add a new node here first of all I need to create this new node so how do I do it I can okay fine node n this is equal to new node and I give the data to this node that I'm getting right now how do I connect this tail node with the new node so that connection is pretty easy what I need to do I need to update this value and give it the reference of this node which is stored in it right I need to say that fine al. next this is equal Al to the new node that we have created right so this makes the connection and I also need to say okay this tail should be here because this this node is now the new tail right so I can say tail equal to tail do next or you can say tail equal to n both are fine right now this tail has also moved and one more thing we will do is we will say size Plus+ now this will work fine when the link list is already there right but but think of a case when your link list is not created that means both head and tail they were null and you inserted the first node by calling the add last function you say okay I don't have a link list that means if the size is zero and you adding the first node in the link list and how should the update should happen right so you still created this new node n right uh with with the data d n is refering to this node so in this case both head and and tail should get updated they should point to this node right what I can do I can say okay head and tail they will refer to n right they will also store the address that is stored in N right now you might ask okay uh what happens to This n so N is a local variable it will get destroyed after this function call is over but head and tail they are the data members of the class they will exist till you have the link list object in your memory right so they are not going to get destroyed right so N is a local variable it will be over right and anything that is allocated using new will not get destroyed why because if someone is refering to this memory that memory will not be garbage collected right so head and tail they're refering to this node N is a local variable it will get destroyed right so this way add last will work so now let us test our functionality right is okay L do add last Maybe This is 40 this time and again I say okay L do add last This Is 50 right now if you look carefully I'm adding the first note by calling add last function first 40 was added add first 10 so 10 was added then 20 was added then 30 was added now again I'm calling the add first method on a link list which is already built so 50 should get added right so if I say l do display right it it will give me this link list let us see the output we are getting this link list 30 20 10 40 50 that means this is working really fine okay let us go back here and let us Implement one more method that is okay give me the size right how many nodes we have so that's going to be easy public int get size and what we are going to do we're going to return the size of the link list right now we are doing it this way because if you make this size public anyone can change it right so I'm only giving the getter to access the size I'm not giving any method to set the size of the link list okay so that size should be updated only through the ADD and the remove methods so this is also fine so I can say l dot get size and I want to display how many nodes I have in this link list this is again a order one operation right so I can see okay there are five nodes now let us talk a little bit about the complexity so your Constructor is doing order one work add first it is also doing order one work no Loops involved here also we are doing order one work get size we are doing order one work display we are iterating over all the N noes we are doing order of n work right now the next method is ADD art right so take a pause and think how you will Implement add art method and if you want to insert something in the middle of a link list at a particular index okay so let us see it next so we are discussing how do we implement the add at method okay so we we are given okay this is the data that you need to add and you have a particular index at which you want to do this insertion right suppose my data is 4 and my index is three that means okay zeroth index first index second index here I want to add like at the third index the new node should come right or you can say okay after three nodes I want to insert the fourth node this is my fourth node that I want to insert somewhere here right so how I will do it right so one ways okay I will create a new node n n is referring to this node four right but how do I connect three with four and four with five right so this is going to be easy how you can okay let me create this new node n so node n this is equal to new node with my data 4 right now one way is okay I can say I need to reach this node right how do I reach this node right that means I if I start from this node right and I want to reach the third node right after after three nodes I have to insert that means I have to reach the third node if I take one jump here I reach two if I take one more jump here I will reach this node right that means in order to reach three I need to take two jumps right okay so if my index is some P right I need to take P minus one jumps right for a particular position P I need to take P minus one jumps this we will do it using a loop right let's say I've reached this node and I'm holding this address in a variable called temp right now how I will do it right I can okay temps next should 24 if I do this temp. next should refer to n what loss I will have I will lose the address of five I don't want to do that right how should I do it I will say that before doing this operation let me say that four should store the address of five can I do that of course yes so how do I do that I can say n. next that is the next of four should refer to five so what is the address of five it is nothing but it is the next of temp so it is temp. next right once it is done can I update the address the next of three of course yes I can okay three is next now should point to four and this link will automatically get broken so I can say three is my temp temp do next should be equal to n right in just these three steps I will be able to insert a node in the middle right now we might have a special case where we might need to insert a node in the beginning or at the end or we are getting an index which is out of bonds so let us see how we will handle those cases so first of all I'm going to check if this index is out of bounds right so if my index is less than zero or my index is greater than the size of the link list that means I cannot insert this node right so in this case what we can do is either we uh simply return right but that's not a good idea we should tell the user that you are doing something wrong right one way to do it is we can throw a new exception and we can okay uh index out of bounds that you're using the incorrect index and here I have to say Okay this method towards throws a exception right I can throw an exception in this case and an error will come in the main when this program is executed right and um now if my index is zero that becomes a special case that means okay I'm I'm trying to add something at the beginning so that I have already handled we can just call the add first method with data right so I can say uh you call the add first and you give the data that's it else if your index is equal to size that means if the link list has three nodes and you want to insert something at index 3 that means you're inserting something here right which is again at the ending of the link list in that case you can call the method at last and you can give the data right in the else block we have to write the exact logic that we are talking about right so let's see how we will do it suppose you're l Nu is like this 1 2 3 right and I have 5 6 7 right I'm telling you that okay after three nodes you have to insert a data that is four right so how do I do it first I need to reach the third node right so I need to take a temp and reach this node so temp will start from head so I can say node temp this is equal to head how many jumps I have to take I have to take index minus one jumps so I can okay for INT jump equal to one jump less than uh equal to Index right jump Plus+ right or if it is sounding confusing to you you can say less than equal to index minus one right these many jumps as I told you we have to take right in each jump what we should do temp will take a step so temp will go to the next node temp equal to temp. next now I'm going a position to do some insertion here right what I will do I'll say okay let me create a new node n whose data is four I can say node n this is equal to new node with the given data and n. nextt should refer to temp. nextt as we have just discussed here as well right so four should get connected with five that is the first step then I need to connect three with four right so how do I do it so three is my temp do next should point to four so four is n that's it and size Plus+ size we will update here so here we are not doing size Plus+ because at first and at last will automatically increment the size right that's it so that is my insertion in the middle now let us run this code in Main and see if it works really well or not right now I can okay this was my original link list L do add at index let's say I want to add at some index uh zero let's say the data is zero right L do add at index I want to add something at the last index so l dot get size okay now I'm getting a getting not add last but I can say add add index will be let's say the last index so data is let's say 100 L do get size now again here I'm getting this because I not written throws exception so main can also throw an exception because it is calling a method that throws exception so main can also throw exception right so we have to write this here right and let's add something in the middle as well so L do display and I will okay L do r index 4 sorry data is four add some index let's say three something like this and again let me say l do display so this will test our all the three cases and we should be seeing that they should work fine right so in the first case I added zero in the beginning fine I added 100 at the end fine working fine then in this link list I said okay at index 3 I should insert four so 0 30 20 this is the third index before 10 I will insert a four so 0 30 20 I'm getting a four here then 10 40 50 and 100 that means in the middle it is also working fine and I display this list right and finally I have 8 elements 1 2 3 4 5 6 7 8 that means that size update is also working fine in all the three cases right so that completes part one that means we are able to add nodes in the link list in all the three cases we have seen add first we have seen add last and we have seen add in the middle right next we will move on to get and after that we will move on to remove right so take a pause and think how you can Implement these methods get first get last and get an element at a particular position it's your time to code and I'll just show you the add art method right so pause this video here and try to implement these three methods let us implement the get method right so I need to write a method called public int get first that means I want to get the first element of the link list but what if the size of the link list is zero I do not have any such element so I will have a special case if size is zero I can throw a new exception that the link list is empty right so link list is empty that is the error that I'm trying to show to the user right and here I have to tell that okay this method also can also throw exception right so throws exception but if the size is not zero the link list is there then it is pretty easy we just need to return the data present in the head node so head is referring to this node access the data and return it return head do data that's it size will not change and this is what you will do so similar to this you you can also write get last so again if the link list is having size zero then there is no last element you will throw an exception and in that case the last data will be at the tail node right you can say return tail do data that's it if you want to get something in in the middle that is going to take one more step because you will have to Loop through it right okay so add it we did not discuss it's going to take order and time because your the worst case you might have to Loop till the second last or the last note right so get last we have done now this this will be get at a particular index if I give you an index and I want to get an element at that index how it will work out to take a pause and think how you will do it this is also easy right now user is giving you an index now it is possible possible that this index is also out of bounds like we saw here right like in the case of addition it is also possible that this index is out of bounds so if index is less than zero or it is greater than size I can throw an exception index out of bounds then if this is not the case right so if this is not the case if the user is uh really giving you a valid Index right as if it is possible you're talking about index zero if that is the case you can say return get first this can happen else if index is equal to size you can say return size or size minus one it will be size minus one because the last element will have an index size minus one you can say return get last otherwise what you need to do you need to iterate on the link list right so so that iteration part is easy what we will do we'll have let's say A B C D and so on right this is index 0 1 2 3 4 right I want to get something at the second index what I need to do I need to take one jump one more jump two jumps to reach this particular Index right so that means take the number of jumps equal to that index so I can say okay fine node temp that is equal to head and uh for INT jump equal to 1 Jump less than equal to index jump Plus+ what do I do I take my temp to the next note temp equal to Temp dot next Once I reach this node I need to return the data of that node so return temp. data that's it so I take my temp here and I return this data right this will give me the data at a give given position so that is my G at a particular index now let us uh test this code I want to say okay fine in this link list that we have I want to get the zeroth element s out L do get first s out l. get last and S out l. get at index 4 let's go and run this code the first element is zero last element is 100 the fourth element is 10 let us verify the zero index first index second index third index fourth index so fourth index is really 10 that means my output is correct that is how we build the get art methods in the link list so far we have seen uh the art method and the get methods okay all the three versions so getting first adding first they all take order one time but doing some work work at a particular position they take order of end time right so other methods are all one now we have the remove method we want to remove first remove last and remove at a particular position so let us see how we will write these methods okay so what I will do I'll create remove methods public int so remove I will also get the data that has been removed from that particular index so return type would be int so remove first you might think it should be very simple whatever is at the head I will uh return that right so I want to remove this let's say 10 is there 20 and 30 and this is my head how do I remove this node so one way is okay you can store the output that is going to be head. data and then you can say okay this head will move to the next node so head will go here so head is going to be at head head do next right so doing this will it remove this node the answer is yes so in Heap uh this node is a note that no one is referring to what will happen it becomes eligible for garbage collection so garbage collector will come and it will going to it's going to sweep away this memory so that means now your link list will be only this right but there are few special cases right so I can say output will be returned that's okay you also need to reduce the size this do size minus minus this is something we need to do right but what is a special case if the link list is empty can you remove the first element the answer is no so we have to check if the size is zero what we will do we'll throw an exception right we'll throw new exception that link list is empty fine and we need to tell that this method throws exception what about if the size is one right so head will get updated fine but if you have just one node and both head and tail they were pointing to this node will it form a special case of course yes right if this node is getting removed what will happen to head and tail they will be reset to null right if your original size was one how do you remove it you will set your head and ta equal to null size will become zero right okay and uh else sorry yeah so one thing we can do is this code we can move here output is equal to head. data okay and we'll of course return output this code we can move in lse case right that means if there are like at least two nodes in that case tail will not be affected right so what about this case L's case if there is 10 there is 20 and there is 30 so this is my head this is my tail even if my move remove this node head comes here right the head goes to the next place size gets reduced tail is not affected right but if I have just one node and I remove that node in that case head and tail both will be affected so they are reset to null and the size becomes zero so that is how the remove first method should work now let us uh test this method let me create a new link list let's say I add at the first position let's say 10 then I add 20 30 40 20 30 40 and I can say l do display then I can say l do remove first and l dot display right so I'm getting 40 30 20 10 fine and if I remove the first element 40 my link list is 30 20 10 which is fine okay if I have just one element in the link list and let me see if it works well so I have one element I removed that one element so my link list is empty fine that also works well right and I can say s out L do size I want to see if my size is getting updated properly yes the size is zero and I don't see any output here that is how I will Implement remove first method now on the similar lines can you implement the remove last method okay just need to think what will change what will happen to head and tail how much time it will take this method it's going to take uh order one time right remove first but you have to think how much time remove last will take Okay so let's see uh remove last okay so first case is okay if your linklist is empty you cannot throw anything uh you cannot uh remove anything so if your size is zero you will throw a new exception okay then similar to this one your output in this case will be what your output will be now tail do data you know the last node is tail and that data is your output right if you're size is one what you will do you will reset your head and tail to null and you will just size is zero if this is only one node both head and tail are referring to this node you want to get this data you store this data in a variable called output that is tail do data original size was one if this is removed head and tail they reset to null and size become zero which is correct right otherwise if you really want to remove something right so you will have to check that if your index is in the the bounce or is it zero or is it the last index sorry you don't need to check here because we are talking about remove last right so you just need to remove the last node right so what I will do I okay else we have the other case we know what node to remove if there are more nodes right now there is one tricky thing here that if it is a singly link list right and this is your tail node you're saying I want to remove this node right that means tail should be updated tail should come here the new tail should come here right after removing this node I've stored this D in in a variable called output so output is tail do data so output is d right how do I bring it back there is no way to do it right even if you maintain okay I'll maintain previous of tail for every node suppose this was the previous but when you remove C how you will get the previous so the answer is we don't have an any order one way of coming to the previous node we have to iterate from the beginning to reach this node right so that I can update my tail variable right so this is going to take time right or the other option is you maintain a dou link list in which every node is also connected back right if you do that your remove last will work in order one time but for now we have a singly link list that means we have only the next address right singly link list in that case we have only one option start from the head node and try to reach the second last node so how do I do it so I take a variable called temp which starts from head I can say while temp. next is not equal to tail right so what is the stopping condition when I reach this node temp do next this is equal to tail right so this is the tail node right suppose this is my C this is my temp and this is my tail node this is my d right I'm saying while temp do next is not equal to tail until this condition is not met I will take my temp to the next and next note so temp starts from here it goes here it stops here right because c's next is equal to tail so temp will stop at C I can say temp equals to Temp do next my temp stops at the second last node right now why this is important because I want to update the tail thing right now at this point I want to disconnect D this D I don't want so what should I do I would say temp do next is equal to null so if I reset this variable to null what will happen this object becomes eligible for garbage collection because no one is referring to this object right the garbage collector will come and sweep away the memory of D because there are no object references which are holding the address of this node so this D will get deleted from the memory and c's next is updated correctly right but what about the data that we wanted to return that is still copied in in a variable called as output right so once this is done what should I do so temps next is now null this tail should be updated so this tail should come here this tail will become equal to Temp and the size will also get reduced right so here we have reset the size so here it will be one lesser size minus minus that's it and I will return the output in both the scenarios right so return output in this case also I'll return the output in this case I will also return the output that is how remove last will work and if I now show you L do remove last and uh maybe if you want to Output that's okay we just want to see the link list so I can say l do dis play what do I get let me add some numbers only then we can see 20 30 40 so right now I'm getting an exception because you know it's an empty link list so 10 20 30 40 L do display and then I called the remove last method this was the link list I removed the last element this is what I am getting and the size is three right which is fine that means the remove last is working as expected right now the next thing we would like to do is any guesses of course it's going to be remove at a particular index so we want to write one more method public int remove at given index again before I write the code take a pause and think how you will implement this method given a particular index I want to remove remove something from that index so let us start implementing a remove that right so first thing is if the size is zero that means you cannot remove anything so you will throw a new exception so throw exception throw new exception and you'll say Okay link list is empty you cannot remove it or you can check that if the index that you're getting is out of bounts so if index is less than zero or your index is uh greater than size you cannot remove or equal to size even at size we don't have anything the last index is size minus one so if this is the case I I have to throw new exception right I'll throw a new exception and we'll tell that this method can throw an exception all right so the error is fixed now what to do I still want to remove it so if my index is zero that means I want to remove something from the head that we have already implemented so whatever is returned by the remove first we will return that else if index is equal to the last which is size minus one we'll return whatever is removed by remove last method and now is the time we will see the actual working of this method right how do I remove something from the middle of the link list so let's say I have a link list like this a a b c d e f right and as okay I want to remove something from index 2 right 0 1 2 I want to remove this element if I want to remove this element that means B should get connected with d right and this link from B to C it should get broken and uh C should be garbage collected right if this happens c will be deleted from the m right so how we are going to achieve this right so first of all we need to reach this node that is B right so if my index is two I need to reach one node behind that index so how do we reach that node again fairly easy I can say I will start with temp that is equal to head and if index is two that means I need to iterate one less than that index for INT jump equal to one jump less than index jump Plus+ so if it is two I'll okay I'll just take less than two jumps that is I'll take one jump I will come here and at this node I will start doing certain operations right so first of all let me take temp to that particular node now I'm standing at this node so what I want to do I want to return this node right I want to return the data of this node I will copy it in a variable called output output is nothing but uh temp. next. data that is what my output is right and I want to return that output or let's say this is my node which is okay either way we can do it node called output so this node is my output node and what I want I want temp to connect with next of this node so I want B to connect with d so how we can do it so temp. nextt either you write it should be equal to temp. nextt which is my output do next so that is my D or you can say output. next again I'm connecting B with d right now no one is pointing to C it will become it will get garbage collected right okay and if this node is garbage collected this link is automatically broken so what I need to do I need to say size minus minus and I need to return output dot data output. data this output is a local variable right it is there only in this function once I return output. data there is U this function call is over output will will be out of scope it will get destroyed and hence no one is referring to C this memory will also be cleared off that's it that's what you need to do right so that is going to remove something from the middle of the link list right now I can test my code so I can say l do remove at index let's say one given this link list let's say remove at index 2 which is okay show me what will happen if you remove something from index 2 so this is my link list and if I say okay remove index 2 01 2 20 is gone I get 4030 and 10 that means the code is working absolutely fine so this is how we can remove something from the middle of Link list so far we have seen the implementation of single link list right so in which we said every node is going to store the address of the next node right but what happens in real scenarios you might need some times a dou link list so what is a dou link list just like you were storing the next you will also store the address of the previous note that means each node is now holding three things a data a next reference and a previous reference the two will hold the address of three two will also hold the address of one right now the advantage of D linkless is that you can Traverse in both directions right for example we were doing removal at tail in which I said Okay I want to remove this node and I want this tail to come back I if it is a singly link list I have to iterate from the front to reach this node which is going to take order of end time right but if I do it the same operation deletion at end for a w link list I can just come back back to the previous note okay because four knows the address of three so I can update my tail pointer very easily right so it comes at the cost of extra memory but it can save some time for example if you want to delete something at the end it can then be done in order one time insert at end can be done in order one time insert at head can be done it can be done in order one time remove at head can also be done in order one time so at both ends you can do insertion and deletion in order one time right so each object stores data and memory location of next as well as the previous object right so this is something you can Implement right now there won't be a lot of change for example if you're making a method to insert something in the middle let's say I want to insert five here what are the variables that you will have to update right so so you will have to update that two's next should point to five okay but if if you do this first what will happen you will lose the address of three so what I will do is I'll okay let me create this new node 5 and let's say this is my temp here I want to insert it so five's next will point to two's next five gets connected with three right I can also say five's previous can point to time so five also connects connected with two right now I just need to change these variables I can say t is next will point to n two is 2. 23 right and I also need to say three is previous right or we can do it other way right we can first say that this node which is the next of two so T do next do previous three is previous should point to n so this link will get like this this link is gone now what you can do you can remove to uh next and make it point to end so you can say this will get connected here so you can say t do next this is equal to and right so again you just need to think logically and you you need to execute these instructions in a particular order so that your updates are correct you're not making any changes which are inconsistent right so again all the operations get remove uh add you can try creating those operations on a w link list as a exercise right so let's talk about what happens in Java right so if you want to use this class inside your collection framework then this class is already implemented so there is a class called as link lists so it's it's part of java.util uh package as a part of collections framework by default this class internally uses a dou link list right so if you're using this class directly in solving problems you're getting a w link list by default right so if you want to learn more about this I have covered collections in my DSA tutorial on the channel you can watch that and learn how do we use the inbuilt dou link list or inbuilt link list class you can definitely learn about the methods of that as well right so let us quickly revisit the features of Link list right so it provides us an ability to use the non-continuous memory locations right so if you have like different chunks of memory available in different parts of the Heap and you cannot create a big array but what you can do is you can use some memory here some memory here some memory here and you can just connect those chunks right non-continuous memory Parts can be utilized efficiently using a link list second Advantage is it's a dynamic data structure there is no need to allocate Prem memory and again this results in efficient utilization of memory for example if an array you say okay I need th elements but only suppose 100 get used up then what is happening all this memories uh it's a waste of memory it's not efficient utilization of memory so link list you you create memory on demand and hence you only only use that much memory that is required right okay and if you are using a w link list insertion and deletion at the ends of the link list they perform in constant time so if you compare it with an array and if you have to do some insertion or deletion in the beginning right you will know that it's going to take order of end time because I have to do shifting if I insert something or if I delete something again I have to shift all the elements right and joining two link lists is much more efficient in terms of SP time so if there is one link list and there is another link list right so think if you have to join two arrays you have to copy all the elements from one array into another array but if you have to join two link list you just need to connect the LA tail of one with the head of other link list and that is going to be again an order one operation so it saves both your space and time right so that is all about link list so a quick revision on the operations Random Access if it is a link list it's it's a bad thing right because it's going to take order of end time in an array getting the element will take order one time insertion at deletion at the beginning order one time in an array it's going to take order and time as I just discussed insertion and deletion at the end right so this if it is a dou link list it be it can be done in order one time right in an arrow also it can be done in order one time insertion and deletion from a random location so if you're doing somewhere in the middle both are going to take order and time right so in an array this part is bad insertion and deletion at the beginning Random Access is good in a link list this insertion deletion part is good but Random Access is bad so you can see each data structure has its own pros and cons so depending on upon the problem you have to decide whether you will go with a link list or an array let us talk about stocks today just like AR and Link List stock is a Le linear data structure that is used for storing data right and it looks very much like a real life stack such as stack of books stack of plates and so on right so you might have guessed the kind of behavior this stack will show so what happens is you can insert something if you want to put a book that book must be inserted from the top right you cannot insert books directly in the middle right you cannot insert a book at the bottom of the stack right basically any book let's say C++ book it goes on the top then a python book it goes on the top of the stock right so this is how it it's it's going to be and if you want to remove some book you will have to remove the topmost book first then you can remove the next topmost book then you can remove the next topmost book right basically it's a data structure in which insertion and deletion they are done only at the one end where end is called as the top of the stack right so if you're are pushing something this blue goes then this blue goes and then this y yellow goes okay the item which is inserted at the last right last item it is at the top of the stack right if you want to remove something this three will come out then this two will come out then this one will come out so the last item is the first one to come out so hence this behavior is also called as last and first out right so when you do execute this operations on your computer uh undo undo redo you do right so you when you do control Zed so the last operation has been reversed when you do again undo the previous operation gets reversed right so stack is a useful data structure if you want to implement recursion if you build if you want to build something like an undo redo stack you can do that right and problems where this last in first out behavior is important stack can be used there right talking about implementations of stock we will discuss uh three implementations we will discussed uh one using using fix size array we will see Dynamic array right or an array list and we will also see using link list right so we'll go into the implementation details uh very soon but before that let us also talk about features of the stack right the stacks are different from arrays in a way that in arrays Random Access is possible that means you can pick any I element but in this case stack only limited access is possible that means only the element which which is at the top is directly available to us right and stacks are generally dynamic in nature in general we can have a fix size stock as well but generally we can push and pop elements so the size of the stock can keep on changing right so generally we do not say it's it's going to have any fixed size right if you use an AR list or a link list you will be able to implement a dynamic stack right so three fundamental operations that we will have with every stock we okay we want to push something uh push something at the top of the stock we want to remove something again that happens at the top of the stock and we want to Peak that means we want to get the element at the top we looking for the element so we call it as Peak sometimes also called as a top right we want to seek the topmost element that is about stack and now let us jump into the implementation of Stack let us talk about implementation of stock so we will be discussing two implementations one is stock that uses a fixed size array and the second implementation would be a dynamic stack right which can use a array list or a link list okay so we'll discuss a fixed size array implementation and another implementation using Dynamic array which is called as AR list or we can also use Link list right so one of those data structures we can use to give the behavior of a stack right if you're using a fixed size array right so you have to think of a container which is getting filled and getting empty only from one end right that means if I okay every insertion will go from here right so 1 2 3 4 5 if I want to insert six I will insert something from this end if I want to remove something I will also remove something from this end right so I can say okay I'll push something into the stock so that means I'll push six and if I pop something that pop will also remove six right and there is one more method that we would like to implement that okay I want to see what element is at the top of the stock so if you remove six and we call this method as Peak right so if I want to see what element is at the top of the stack so that element would be your five right these are the three most important operations that we need to implement on a stack right now clearly we can use a fixed size array to do it right so internally we'll say okay there is an array which is having fixed size and we can add elements from this end into the array and we can also remove elements from this end of the array so let us see how we can Implement a star class in our code so let us start implementing the star using a fixed size array right now if you look at this fixed size array what are the three things you will need in this class one is the name of the array or the container in which you are going to hold data another is the top variable that is going to move as you insert and delete elements and another thing we need to know is what is the maximum capacity of the stack right what I will do I will Define these three attributes as data members of the class so first thing I will have is a private array which which we call it as data next thing I will have as stop and another thing I will have as a constant default capacity can be treated as a constant so public St static final int I can say default uh capacity right and this is equal to 10 right now I need to define a Constructor I can say Okay stack using an array there is a Constructor and I'm not getting any default capacity so that means my array size will be 10 in this case so I can initialize my data array so I can say this is equal to new in how many integers the default capacity right and what is the initial position of the top so top is the index at which I'm going to store the element uh at which I'm stored the last element so in the beginning I can say my top is at minus one why because I have not stored anything when you insert something you can okay three is there and top will come here so top will move after you can do the insertion so I can initialize my top variable as minus one I can have another Constructor in which I'm getting some capacity as user input so I can say fine I'm getting some capacity so in this case I can uh say okay the array that I'm creating it has this particular capacity right or you can also put put a check that if your capacity is less than one right that means is it is it negative or zero in that case we can throw an exception I can say Throw new exception uh invalid tack capacity right so something like this we can do and here we can say okay this function can throw an exception CL exception so this is how we will create the Constructor for the stack class right and we are using a fixed size array now we have to uh Define three functions okay we have to define a push function okay I want to push something into this stack so I'm going to get data right right now we have to check whether my stack is full or not only I can push right so how do I check how do I check right so let let me do one more thing Let me also write a function that will that will give me the size of the St right so I'll say public int um get size right the methods would be made public I want to see uh what is the current size of the stock right can I say uh the current size is nothing but the value of top + one so in the beginning top is minus one and if you have not inserted anything this output will be zero so Min -1 plus one it will be zero when you inserted let's say something so top will be at index zero what is the size of the stack the size of the stack is one right so when you're going to push how do you check whether the stock is full or not right what you can do just think about it okay so what we can do is we can check that whatever is the current size of the stock is it equal to the array capacity right so I can say if I can call the get size function which is basically giving me top plus one is it equal to the capacity of the St right so how do I know so I can say that capacity is nothing but uh AR length right so array has a property called as length if these two are equal that means my uh array is already full okay so we we are getting an error Here data. length because of this reason uh data is a variable here and data is also an array here right I need to make it something different I need to say this is some item that I'm pushing into the stock and now this data means the arrs right if they are equal so in that case I cannot push anything more so I can say Throw new exception and the exception name is stack is full right so that is some message we can display and we can tell this method also throws uh exception all right but if if this is not the case so what I will do I will increment my top I okay fine increment the top variable and at the new position of top you are going to store that item right that's it if the stack is not full right oh function can be made as void public void push so we don't return anything right now what is happening that your top was here I said push three so my top comes here and I put the item I say push four my top comes here and I put the item again I push five top comes here and so on right eventually if your top uh top plus one is this value that means if my stack is full okay so get size is how many elements I have currently stored let say 6 seven and the capacity of there is also five so if it is there so I can say stack is full right so that is how we can perform the push operation on the stack right now let us talk about how do we remove something from the stack right now I can say uh I will have public int pop okay I want to remove the topmost item so again here what you can do you can make a check that if my stack is empty right then I have to throw an exception I cannot uh pop from an empty stack so if get size tells me okay this size is zero there are there is no data in the stock so you can say uh throw new exception tack is empty right and here we can say this method row exception okay if this is not the case I can easily remove something from the stock I will store my answer so answer that I want to return it will be uh data of top right what I can do I can reduce top top minus minus and I can return the answer that I have so let's see what we are really doing so we are saying okay 1 2 3 4 this is my top right I want to remove this so I can simply say okay this top will come here and I will copy this four in a variable called answer and I will return it right you might say okay if I print the St I might see four that's not going to be true because we will only print up to 1 2 3 right up to top right this data if you want you can make it zero or you can keep it as it is right so just to make it little more more clear I can say answer of top I'm making it zero so that sorry dat of top I'm going to make it zero so that it looks good when you try to uh look at the entire array right so I so in general you not going to look at the whole array but only the array Del the top but that's okay so this is a optional step if you would like to do right because data can be zero also right again this is an optional thing if you want to that is how you will remove something from the tack right now we have the method to look at the topmost element right so sometimes this method is called as top sometime it is called as Peak right if you want to look at the peak method uh it's pretty easy you just need to do the similar thing right so I okay if the AR is empty then you can throw a new exception that stack is empty otherwise you get the data but you don't remove it so that's it you can or you can simply return data off top okay the topmost element you can return directly so that is your Peak method right let us add some more meth methods if you want to print the stack so I will print everything up to top right public void um display so I can say for in I equal to top I greater than equal to Z IUS minus so I will iterate on the items in the reverse order so if it is like 1 2 3 4 I will first say okay I'm going to print from top to the bottom right like this this so what I will do I'll okay s out data of I that's it right so that is my display method and uh I can give a new line here okay so any other methods if we would like to write so maybe we want to write a method called as is empty or is full so we can write those method as well so I I can I will write is empty method whether the stack is empty or not so I can say public in public Boolean is empty so this is helpful when you want to continuously remove elements from the stack until the stack is not empty so this method can be used right now I can return if my get size is equal to zero so this expression will evaluate to true or false so I think this look looks good next we will test the functionality of this stack that we have created now let us write one more class so that we can uh test the functionality of this stack class so I'll call it as uh stack demo. Java right so in this stack demo we will create a stack object so main method is there like in this tack s sorry this should be tack using an array right stack using an array I call it as stack this is equal to new stack new stack using an array right I've created the stack object or just call it as s let us push some numbers into it so I can say s do push one s. push two uh s. push 3 so we have to push method can throw an exception so I can say Main can also throw an exception right so s do push 3 4 5 whatever it is right and then we can try to extract items from the St so four five six I've added six items I can say Okay s do display show me uh the stack right let us run this and see what do we get right and at the same time I will do one more thing I will pop items from the stack until the stack is not empty so while the stack is not empty what I will do I'll give me the topmost element so I can say s. Peak print the topmost element so s out uh topmost element and remove it so I can say s do pop right pop function you can also use because it also gives you the element and remove it right but here we are not reading the value from the pop we are just reading the value from the PE Peak function so so when we are printing it you see six is at the top then five then four then three then two and then one right if if I do not call the display method instead I use this while loop what is the first element that will get removed that will be six last in first out then five then four then three then two and then one let us go and run this code and we will get a same output by removing all elements from the stack as well right so you can see that means our uh class is working perfectly fine by default the capacity is 10 so if I show the capacity is five and I try to insert six elements then this code is going to throw an exception that the stack is already full and I cannot push any more elements into the stock the next implementation of stock we will see using a dynamic array and a link list let us talk about Dynamic stack now there are two options to implement it one is is you can use an array or one is you can use a link list so when I say array we can use a dynamic array right so suppose you are implementing the stock using an array and at some point your array got full okay your current size is equal to capacity right what you can do is using the same logic as err list inside your push method what you will do you will say fine I will create a new array of double the capacity if this is C I will create an array of 2x of my capacity and I will copy the elements here right so that is how my push method will uh get changed right and pop will remain same I'm not going to shrink anything so pop will remain same even the top method will remain same no changes right nothing changes here only in the push method we are going to change so array will not overflow instead it will get doubled right and again this copying is a expensive operation right right so we should make sure that this is not happening happening too frequently right that is why initial capacity is important right so that is using an err list right now if you want to discuss it in the code so you can say okay I have a class called stack either you can keep a error list object here right because we have already implemented error list it can be your implementation it can be Library based implementation as well whenever you call get a call for push some item I you can simply say Okay a do add the item I so add function we know it adds at the end of the AR list the code becomes even simpler right or if you don't want to use uh the inbuilt class right what you can do you can take the manual array like we did in the previous example and write the doubling logic inside the push method so I'm hopeful that you will be able to do that part right another option is you can use a link list also right now suppose we are uh building a stack I got one I insert that node into the link list my head is updated tail is also updated right now suppose you you got two now the question is where should I insert two should should it go at head or should it go at tail right one option is okay if I put it at tail insert at tail if I do it this tail will go here right okay and suppose I got three then you can again insert it at tail this tail will go here and uh three is also inserted right now the question is if I want to remove something if I want to pop out three right how do I move this tail back right I cannot move it back in order one time right I have to Traverse from the beginning this is going to be time taking so push is going to be order uh one but my pop is going to be order of n which is not acceptable here right so hence I need a better implementation using a link list so let us do one more try suppose I got one and both head and until they got updated right if I want to insert two two will go here I will create a new node okay and I will connect this node with the head so basically I'm inserting at the head only this head will move here fine night because that that we have seen how to insert at head then I insert three I create a new node connected with the previous head and I update this head right this head can come here now if I want to remove something I can say Okay I want to remove the topmost node I want to pop this note right how do I remove it this is now pretty easy how we can say okay fine let me move the head from here to here and this node now becomes eligible for garbage collection right that means popping is very easy even looking at the topmost element is very easy so the element at the head is the element at the top so again if I want to remove this thing my head will go here and the node two it will become garbage collected so using link list also um building a stack is very easy if you want to insert something or you want to push something you can say okay I will call the add front method of the link list right or insert front whatever it is and if I want to pop something I will say remove from the front Okay I think add first we call called it as ADD first I need to add at the first position and I need to remove at the first position right and Peak is nothing but it is the get first I want to get the first element of the link list right that is how it's going to work right so regarding the implementation I think it's now pretty easy given that we have uh implemented array list we have implemented link list what you can do you can also uh put that code inside your uh Dynamic tack class as well right now three options either you write entire code that is option number one you define the node you write how do we insert at front second option is you can use uh the link list class that we have created or the ARR list class we have created so you you can use your library version okay if you don't want to do that you can also use the collections um error list or the collections link list right any any code you can use to um build your own version of dynamic stack right and the behavior wise it will have same functionality except that it will not get full unless your system memory is not full right so that's all for dynamic tack hope you understood the functionality of of dynamic stack okay I'll show you one more implementation of uh implementing Dynamic stack using the stack using aray class so this class we have uh just written so what I'm doing I have created one child class called Dynamic stack and it is extending the stock using array class that we have just written inside this class I have only updated the push method so basically I have overwritten this method right and I have provided two Constructors so that I can provide uh build the dynamic stack object right so the first Constructor does not accept any capacity so I call the Constructor so this is basically calling this method with the default capacity so I okay go and create a stock with the default capacity right and if I get a capacity from user then also I can I call the Constructor of the parent class so super is for calling the parent class and I give the capacity okay you go and call the Constructor that that is here right so this Constructor is getting called right and I pass in the capacity so either I pass in the default capacity that is 10 or I give the user defined capacity right so I give that so this calls the parent Constructor and initializes that array right of that particular size right the pop method I told you it's not going to change the peak method it's not going to change in the push method if my array is full right so if get size is equal to data. length right and what I will do I create a new array of twice the size I copy all the elements into the new array okay and I say okay this dot data should now point to this array right what happens so data was pointing to the old array right now data is pointing to the new array so this reference is gone that means this array will be garbage collected right so this is ARR ARR is a local variable it will be destroyed DED but data is a class member so it will not get destroyed so using the this keyword is optional it is for more clarity that we are talking about the data member not any local variable right so that is what we are doing here and then after we expanded the array we call the push method of the parent class in the parent class now if if your array has already expanded you will never get this uh condition this condition will never be met which condition that data do length is equal so exception will not be thrown and what will happen top Plus+ and data of top equal to item so this code will actually execute if condition will not be true before calling the push method of parent function I simply expand the array in case of a dynamic array this is what I rarely do and it will work so what you need to do you need to replace this stack with a dynamic stack you can try it out and it will work right so that is another way of using inheritance and creating a dynamic stack object for you one small change I wanted to discuss was I did a change that I made these uh data members which were earlier private I made them as protected down right why because I want to use uh these data members in the child class as well right so that is the only change I have done in the class called stack using an array so let let us start by understanding the fundamentals of a q what is a q a q is just like a real life Q so in most general terms a q represents a sequence of objects waiting to be served in a sequential order okay so one thing you need to remember is Q is also a linear data structure like other linear data structures you have seen so far arrays array list TS link list q q is also a linear data structure that stores the data in the sequential order starting from the beginning of the queue right for example if you go to a bank right the person who enters the queue first it is at the front of the queue second person is behind it third person is behind the second person and so on right so in general Q has two ends one is called as front from where the people will be served right and one is the rear end from where people will join the queue right basically insertion of data with will happen from this side and removal of data will happen from the front side right people at the front once they are served they will get removed from the queue right now this queue can also be seen as queue of cars at a toll booth right people standing in a line to buy tickets right and in the world of computer science we use cues a lot right for example many people are uploading videos on YouTube and YouTube has maintained a queue so that people who have uploaded videos first first their videos will be processed right we might maintain a few of videos on the server waiting to be processed right similarly on in software applications for example an application has to perform several tasks it might maintain a queue of the task that it needs to perform so that our work gets done right so Q is again a very important very interesting data structure right now let us talk a little bit more about the operations so as I discussed one fundamental operation on the is insertion right I want to insert something into the Q right so the kind of q that we are discussing current now it is called as fif Q first in first out Q why because the person who joins the queue first is the first one to get served right in in a fif Q insertion happens at the rear end of the que so this is your let's say rear end right whereas deletion happens at the front end of the cube so this is your front side right so anything you cannot show okay I want to remove something from the middle of the queue that is not possible only the data which is at the front of the queue will be removed right there is one more operation so we have seen uh insertion we have seen deletion right we will discuss how these operations are implemented using other data structures right there is one more operation that is called Peak so I want to look what is the uh front element okay who is standing at the front we call that operation as Peak so just in case of stock if you remember uh the peak operation Returns the top of the top element of the stock in a que Peak operation should return the front element of the que right the person who is standing at the front of the que so that is what Peak operation will do right as a next step we will look at the implementation of a fif Q right so there are three common ways to implement a queue we can use a fix size array right and we'll see see how this array will behave as a circular array when we are going to implement it okay so in this case Q will have a limited capacity because the array size is fixed suppose n is six I cannot have more than six elements in this Q at any given point right second is I can use a dynamic array I can write my own Logic for creating a dynamic array for example if my Q gets full I will say fine I will double the array I will create a new array of double the capacity of the given size right now if again the Q get is full I'll again do the same thing right this is called as implementation using a dynamic array the other option is if you do not want to write the functionality of doubling it is already implemented inside your AR list class you can also Implement Q using a AR list right third is we can use build a queue using link list as well right you know link list is a dynamic data structure so we will look at how a link list can be used to implement a queue as well right so let us start with the first uh implementation that is implementing a queue using fix size array now let us talk about how we can Implement operations on a queue using a fix size array so the three operations that we need to build are NQ DQ and Peak so NQ NQ means I want to insert something into the Q DQ means I want to remove the element at the front and Peak means I want to get the element at the front these are the three things that we will have in a p4q first in first out right now let's see how we can use a fix size array to create these operations on the que right in the beginning I should know if something is coming at what index I will insert it into the queue and at what index I will remove it from the queue right what I will do I'll say okay let us take a variable called front and it is here right we can also take another variable rear but again that that is optional if you're maintaining the size of the cube in the beginning size is zero front is also at zero that means um nothing is inserted in the queue yet right someone says okay person one is going to join the queue and I will insert it right what I will do I will insert it at the rear end okay so how do I compute the rear end let's see the rear end can be said as front plus size I will tell you why right so what is front front is 0 what is size size is 0 so 0 + 0 is 0 so I can insert person one here in the cube right and I will increment the size the size will become one right size is going to become one right so I'm not going to change the front look carefully I'm not going to change the front right now uh it was 0 + 0 that's fine right now I can say again I want to insert person two okay I want to insert person at what index I will insert I will insert it at the rear end so what will be the rear my what will be the rear value now it will be f plus size so f is zero fine size is one it is going to be one I can insert person two at this index very good right now let's say one more person wants to join the queue so I want to insert person three right size is already two right I've inserted two elements but what I will insert I will insert it at the rear index what will be the rear index 0 + 2 that is going to be 2 that means person three will be inserted here and this is the new rear okay so front is not changing rear is changing in this case again I want to insert person 4 let's insert person 4 size is already three now right size is already three what will be the new index 0 + 3 it's going going to be three I can insert person 4 at this index and my rear is already here right now suppose I've done lot of insertions I want to remove something right so I have inserted till person 4 also and I want to see how my front is going to change right now suppose I want to remove something I want to uh perform DQ right so that means I got a query to remove the front element the front element will get removed right now how do I remove it if I move this f one step forward and I will have to reduce the size right now the size was four because four elements are there in the Q right my size becomes four from four it becomes three and I say okay F should move one step ahead so I'll say okay I'll take this front one step ahead that means this P1 is uh it's kind of a removed it's not there right so the area between front and rear it is the content of the queue right now suppose I want to insert something more right so what I will do I'll again do um front which is at one okay plus size which is at three so look carefully so 1 + 3 I get an index 4 that means the next insertion will happen at this index can I insert something of course I can insert something because Q is not yet full I insert something at this Index right now suppose I want to do one more insertion again um what is the value of size now size is still four size is four right so what will be the value of rear so it will be front which is one plus rear which is at which is plus size which is four right it is going to get five now is this five a valid index is this five a valid index the answer is no right now I will get a problem that if it it will give me index out of bound exception but Q is not yet full Q is not yet full so how should I handle this case right the way to handle this case is by treating this array as a circular array right if you exceed four you should come back to this index you should kind of rotate and you should you you should come back here right now how do I achieve this I have to say take a mod with five every time you hit a five you go back to zero again you start filling the Q from this index now suppose I got this uh P5 I have already got I want to insert P6 this P6 will get inserted here right what I I'm saying is the rear will not be updated using this formula the rear will be updated by using front plus size mod of the capacity of the queue the capacity is 5 right so I have to take a mod with capacity so that means if you hit the capacity if the rear index hits its capacity it will be again shifted back to zero provided your Q is not full you you have to check that okay if my size is five and I have only four elements right then I can add more the size is five and I've already added uh if the capacity is five and the size is also five in that case I will throw that the Q is full I cannot insert anything more right so I will insert it here right now my front is still at P2 right front is still at P2 but my rear is here right now someone says Okay I want to remove something or let's say I want to insert something right what is the size the size is five can I insert something more the answer is no right so what you will check that if your size is equal to the maximum capacity that we have allocated I cannot insert anything into the CU so I have to throw some kind of error that that Q is full right now again let's say I want to insert uh perform the remove operation right so how I will do it I'll just fine I'll move this front from here to here I will reduce down the size from 5 to 4 and this makes that P2 is not there right so P2 is not there I'll either make it zero or I'll just keep keep it like this right now I can insert something right I want to insert something so what is my front front is at two what is my rear sorry what is my size the size is five 2 + 5 Mod 5 it gives me two oh sorry the size is actually Four the size is four so 2 + 4 that is 6 mod 5 it gives me 1 2 + 4 mod 5 it's 1 that means the rear should come here and the next insertion will happen at this index so if p7 comes that person 7 will be stored at this place again if you want to remove something you will remove from the front so the front is P3 so you will read the elements in this order right the elements will be removed in this order right one thing you have to notice when you're moving your front right FR your front will also go like this it will go to P3 P4 P5 and again it should come here P6 p7 right basically what I'm trying to say is that when when you're doing this operation that uh front will move like f = to F + 1 here also we should do mod with the capacity so that my both front and rear move in a circular fashion inside there right at at any given point um I have to check if the Q is full I cannot insert something if the Q is empty I cannot remove something right so we have to handle two cases that if size equal to maximum capacity I cannot insert and if the size is zero I cannot remove right so those these will become our special cases in the code right I cannot remove so I hope you understood the logic for the fix size q and now we will jump into the implementation let us start implementing Q using a fix size array I will be using Java but you can use any language of your choice for the implementation so let's begin the first thing I will need to do is I need to create a class queue and I need to Define few data members as we have discussed earlier that if you're using a fix size array we will need a object reference to store this array right so you can call it anything I am just going to call it as ARR right so let's create this variable data member so I'll say private it's a integer array and I need to Define what is the maximum capacity of this Q right so that I will Define using a constant because I'm taking a fixed size array I okay fine this constant will be a public static Final in called as default capacity and this is equal to 10 right one thing I need to notice that if someone is inserting in data into this Q what is the current size of the Q so I'll take another private variable to denote the size of the Q right and now in order to uh perform operations like uh insertion and deletion I must know the front of the que so I'll create another variable that is private int and I call it as front right these are the four data members that we will need so one is your capacity let's say that is 10 then there is your front which is initially at zero and there is size which which will be also at zero right we need to initialize these data members so that part we will do in the Constructor for the que right so I'll say fine let let create a Constructor and in this Constructor I'm going to create a q right so maybe I'm going to get some capacity as input right if nothing is given I will use the default capacity so I'll create actually two Constructors one is the parameterized accepting capacity and other one does not accept any capacity from the user so in this case we will use the default capacity so one thing we can do is uh from this Constructor we can directly call this and we can say okay fine you can call this Constructor and give default capacity as a parameter to it right so that will help me to avoid creating an array here and that part I can do directly here right let's see how we can do it now if my capacity is less than one if someone gives a wrong argument maybe a negative capacity in that case my code should throw an exception so I can say Throw new exception that uh invalid capacity you are giving it to me right and also we need to Define that this rows an exception right all right now let's do the actual work actual work is that we need to initialize this array right so I need to say that fine this array that I have right so again I'm using this um which is optional here but uh it's a good thing to do because you are clearly referring to the data member of the class so this do array should be a new array of capacity right now this capacity can come as a argument from the user directly or if the user does not give then this Constructor will be called and this capacity will come from here right that will be your 10 right and here also we need to say that this method can also throw an exception so this is how we have initialized our array now we need to initialize the size and the front variables initializing them is pretty easy so I can say this do size it is zero and this dot front that is also zero right so I hope this is clear so we have created a new queue of given capacity it can be fixed size it can be uh given by the user as well right so we have a capacity right let's say capacity in this case is 1 2 3 4 5 6 so capacity is six front is zero AR is refering here and the current size of the Q is also zero so the Q has been initialized correctly now the next operation that we need to build on this Q is NQ I want to push something into it so I can say public void NQ and I'm going to get um some data or value to add into this Q now since it is a fix size q and and it is possible that Q is already full so how do I check if the Q is full I can simply say that fine if the current size if this dot size that is my data member it is equal to the capacity of the Q so what is the capacity this dot array dot length right length of the given array then I can throw new exception that my Q is and here I can say that this method also throws a exception but if the Q is not full so we can insert it right so if the Q is not full we can say okay fine we will push something at a rear index so we will need to compute that rear index let's see how we can compute that I can say the rear index according to the formula is the front index plus the size and then we have to take the mod with the capacity so that capacity is nothing but this do array do length that is the capacity now in this case rear will be 0 + 0 mod with 6 in that case it will be zero so I will insert something here and then again size will also increment so we will uh put the data so we'll say this do array add the rear index I want to put the value I'm storing one and I need to update the size I need to say the size is now one so next time the rear would be 0 + 1 mod 6 next time the insertion will happen here maybe I push two so I'll do the insertion at this index so to in order to achieve that I have to say this dot signs Plus+ so I need to increment the size as well that's how the NQ operation will will work right and finally you insert here you insert here you insert here you insert here now if you try to insert the Q is full you have to remove something so maybe this gets removed so your F will come here right let us look at the remove method as well so in that case we can call the method as um public now either you can make it as void or you can make it as int so you also want to return uh what has been extracted from the cube right in that case you can make the return type as in now this method can also throw an exception if your size is Z zero that means Q is empty you cannot remove anything from this Q if this dot size is zero what you should do you will say Okay row new exception that Q is empty but if this is not the case I can say throws new exception here sorry throws exception but if this is not the case what we discussed what we will do right so we will store maybe this data one we'll store this one here we can see okay our output the answer that we want to return is present at this do array of front right or this dot front whatever right so you can definitely return this answer but you have to update your front and you have to update your size as well right I can say fine this do front will move this do front equal to this do front + one mod capacity so capacity is this do array dot length right and the size will reduce this dot size minus if you remember from the diagram this is what we discussed earlier also that this is how my front will change in case of removal right okay and this is how I will compute rear right in the case of insertion right we have already discussed how it's going to work so I'm changing the front and I'm changing the size as well this is my DQ method right now let us write some more methods that would be helpful so one method would be Peak if I want to look at the front element I can say fine public int Peak now if again the Q is empty I cannot look at the front element so if this do size is zero I can say fine um so new exception the Q is empty Q is empty that means I cannot remove anything from this Q otherwise okay let's just fix the error otherwise I can say return the front element this do array of the index which is this dot front okay that that is my Peak method return the front element so the complexity of this method would be order one here also DQ method it will be also order one the insert method that is also going to be order one the constructors are also order one apart from it we can make two three more methods one is to check if the Q is empty or not that can be a Boolean method I can say public Boolean is empty or just empty right I can return true if this do size is equal to zero I can make a method called public Boolean full so I can return if this do size equals this do array do length Okay that will tell me if the Q is full what else I can also make a method to get the size public int size I can return this do size from this method anything else that you think would be helpful maybe just a method to print the entire que right so maybe I want to display the entire queue right in Java uh this method is called as two string which is present in the default class I need a way to look at um all the elements of the cube right so right now I'm not going to iterate from uh front to rear I will just display the array so it's more of a method for debugging not for um doing anything else okay I'm just going to print my array or we can say we can print one simple way you can do it s out uh rs.2 string and you you can see this do AR right but now instead of doing this you can also say that fine I would uh print elements from rear to front suppose this diagram is your Q so maybe I want to print the elements from uh rear to front right or front to rear so how I can do it right now suppose if my front is at two right so I want to print let's say 1 2 3 4 5 6 so I want to print all the elements from front to rear of the que I want to display all these elements so my output should be 1 2 3 4 5 6 so how I can do it very easy I can I know this index I can compute this I can compute this I can compute this so this is f+ 0 this is f+ 1 this is f+ 2 this is f + 3 this is f+ 4 right and of course you have to take the mod so that you can rotate in this circular fashion so very easy I can can say for in I equal to 0 I less than this do size okay and I can okay the current element the current index will be nothing but this do front plus I take a mod with this dot capacity that is array dot length now I can say s out that uh element so this do array of index followed by a comma and S out this looks good to go this will print all the elements from front to rear now let us test our functionality in the Q test file so we have created a q test so here what we need to do we need to create a que right so we'll say psvm that is the main method now we can create a q object object QQ equal to New Q let's say the capacity is five now I want to add certain elements to it shows exception right we have to tell that main can also throw an exception here now capacity is five so what do I do I say okay fine uh let's push Q do nq1 it's a 2 3 3 4 5 then I remove something let's say Q do DQ Q do DQ and then I can say 7 and 8 and then I can say Q do display right now let's see how this queue should look like let's go and run the code I inserted 1 2 3 4 5 so Q was full then I removed something right so I removed this I removed this my front is here and then I ened seven and 8 so seven and8 they will come here right so if I now print my Q it should be like this 3 4 5 and 78 yes that is what I'm getting right that means my Q is behaving in a correct manner the front element would be this next front would be this next front would be this next front would be this next run would be this so I hope you understood uh the implementation of Q using a fixed size array next we will jump into the dynamic array implementation of the queue so let us now discuss the implementation of a dynamic que right now there are two ways one you can use a link list or you can use a dynamic array as well right in this implementation I'm going to show you how we can use a dynamic are functionality and we are going to extend the implementation of the Q class by adding this functionality it okay so Q we have already written what I'm going to do I'm going to create a class called Dynamic Q which will be the child class of the parent class so Dynamic Q extends the Q class right now one thing to notice that this Dynamic Q it's going to behave in a similar way the operations NQ DQ Peak they will remain same the only thing is the logic in the insertion operation that is NQ operation it's going to change right so first of all let us start by creating the constructors for this class so I can say public Dynamic Q again there can be two types of Constructors one without the capacity and one with the capacity right so public Dynamic Q where I going to accept some capacity right now in this case in the first Constructor what I'm going to do I'm going to Simply call the second Constructor with default capacity so I can set this and call it with the default capacity basically what is happening if I want to create a dynamic Q object in which I'm not getting any capacity so I make a call here if I get a call here again what I can do I already know how to create an array of given capacity that I'm doing in the parent class right so Q is my parent class Dynamic Q is my child class if I want to create a size are in both so if I get a call here to create a dynamic Q I can redirect the call to the parent Constructor so I can say super and I can pass in the given capacity that I'm getting right basically I'm calling the Constructor of the parent class right now this is a spelling mistake Dynamic now the parent class Constructor if you look carefully here right so basically what is happening the call is going to come here to this Constructor so we are already initializing the are correctly size is set to zero front is set to zero and we are also throwing a exception we can also say that our Dynamic Q can also throw an exception okay this can also throw an exception now the errors are resol right so Constructor part is now there won't be any change in uh other methods except NQ let us see if I want to NQ something uh let's say public void NQ so I'm going to overwrite the method that I have written for insertion you can see we are overwriting this method right now there are two things we have to do we have to expand the array right and then we have to put the element if the Q is is full okay put the element right expand if Q is full and then we have to put the element right now this functionality we were not doing in the previous uh implementation now we have to do this functionality right now assume that your Q looks like this so suppose Q is like this 1 2 3 4 5 6 right and suppose my front is here that means if I want to read data I will read the data in this manner right so my capacity was six size is also six that means my queue is full and I want to create a new queue a new array basically with double the capacity let's just say this this is going to be 2x twice of the original capacity if I want to copy this data can I copy it directly can I say I'll copy five six 1 2 3 4 will that be correct the answer is no why because if I want to do a next insertion right so at what index the next insertion happens it happens at front plus size right so in this case front is at two fine size is six next insertion will happen at the eth index that means I will start filling from this index but is it correct the answer is no right because what happen at these places we don't know right so the correct way of doing the copy is you create a queue of uh double the capacity right you iterate over this part let me change the color you iterate over this part in a circular way and you copy the elements here right so you copy 1 2 3 4 then you copy 56 this is my front this is my front now if I want to do an insertion so my rear would be front plus size front is zero fine size is six I'll start copying from the six index 0 1 2 3 4 5 6 that is correct so if I want to push something that insertion should happen at these places right so let's see how we can do do this right so let's say this is my original array this is my temp array in which I'm going to form a copy I will say if what how do I check the size if this do size is equal to this dot array. length right now one thing you will notice that these members were earlier private I've just made them protected now right I've made them protected so that I can use them in the child class right so coming back here so I can access the data members of the parent class because they are now protected right so what what I have to do I have to create a new array of double size so let's say there is a new array called temp that is equal to new end of size twice of this dot array dot length so this is created now I have to copy the data so I can say for in I equal to z i less than this do array. length that is the size right or you can say this do size both of them they are equal i++ right I'm going to run a loop these many times right okay so I'm going to itate over these positions 78 will come later right I need to copy these values right I can say temp of I and at the iest index in the temp what should I copy at this index what should I copy I should copy the element from the front so this is f+ 0 then at the next end index I should copy this value this is f+ 1 then this is f+ 2 f+ 3 f+ 4 f+ 5 and so on right I can say this is going to be equal to uh this dot array of Let's uh find the old index so this is going to be this dot original front plus the original size with the original capacity mod right so the elements at the um at this particular index right mod this dot array dot 10 this is what I need to do right sorry this do front plus this dot plus I sorry that's a mistake F + 0 f + 1 F + 2 F + 3 right basically the I element okay so the element are let's say temp of three will be equal to array of f which was let's say 01 2 plus I I is uh 3 mod 6 it will be array of five so fifth index 0 1 2 3 4 5 so that element is four that's correct at the third position I'm putting the value that is four right AR of five this is what I need to do right so just like we did in the display method in the Q that is the same logic we are using here right now once this is done temp aray has been created right so I've erased all of it I'll just do it once again it was like 1 2 3 4 5 6 right this is my front now I have copied this data like this 1 2 3 4 5 6 I have to reset the front here right this should be the new front okay and this was my array this was my tempate one thing I need to change is that this ARR should refer to this memory this connection should get broken I can see this dot ER this will be now refering to Temp object and now doing this no one is referring to this memory so garbage collector will clean up this memory and this dot front will be set to zero right but have I really done insertion as of now the answer is no we have still not done the insertion part right so how do I insert I can say fine at this position which is rear rear is my f+ size mod capacity I will do array of rear equal to the value that I'm inserting and I will do size Plus+ right now this code I'm already doing in the NQ method of the parent class so I can just call that method super. NQ and I can give value right now this method will get to know that the array has been changed because error is now refering to this memory right and it will try to push something into this method uh something into the new array because we have changed ARR which is now referring to the new array right so I can say this method can also throw an exception throws exception this error should get resolved let us look at the NQ method of the parent class so here what is happening this is what we are doing right now this condition is handled in the child class if Q is full double it when you come back into the parent method this condition will not be true what code will execute this code will execute right that is how we have implemented Dynamic Q using a dynamic array right now let us test down test our functionality let us go back into Q test. Java right earlier I was creating a queue of fixed size so if I try to uh let's say push six elements in a queue of size five I will get a exception right I'm using the fix size Q let's see so I'm getting an exception that Q is full right now if I replace this Q object with the dynamic Q object let me show you if I do this I should be able to hold it right yes I'm able to hold it I do not get any exception because q q is getting expanded right and even I can put more elements I can say fine let me put 9 10 11 12 right and so on so let's see what output do we really get I'm getting everything from 3 to 12 which is correct right so you inserted 1 2 3 4 5 6 then you removed 1 2 the elements at the front then you inserted 7 8 9 10 11 12 okay irrespective of the initial capacity which was five you're able to hold more elements because your array is getting expanded during the insertion process right in this case you will never get a q is full exception unless you run out of your HEAP memory or something like that right that is uh Dynamic Q using a dynamic array right next we will discuss Dynamic Q using a link list so so far we have seen two implementation fix size array implementation and dynamic array implementation we have seen right you can also use a error list object uh if you want right now Third Kind of implementation why will involve a link list because link list is also a linear data structure right now you might ask how we can use a link list it's pretty simple and very intuitive as well now suppose you are inserting something so one is at the beginning then you insert two then you insert three then you insert four right now if I ask you uh this is let's say head and this is tail right if I ask you where is the front element right so I want to get the front element so that is one if I want to remove this element can you remove it of course yes you can say okay I will move this head here and that means this element will be removed if I want to read the front element again that element is at present at the head of the link list if I want to insert something it should go at the rear end so where is the rear end the rear end is at the tail right so you can easily insert something here and your tail will come here right so your head and tail uh data member will behave as front and rear for the link list so this will be your front this will be your rear you can always insert at the rear end which is insertion at tail and it will be a order one operation and you can always remove from the front end which is again going to be a order one operation right so very simple implementation and we have already covered link list I will not write the code using link list once again you can either use the same class object so in your Q class you can say fine I'm I'm going to create a link list object link list L and whenever you want to NQ you add it to the link list and whenever you want to remove you remove the first element of the link list okay so those methods can be implemented or you can Implement all those methods from scratch as well right so that is about uh implementation using a link list now before we wind up this tutorial I want to talk a little bit about about the Java q that is part of collections framework right so the Java Q supports three types of operations so one is your insert remove and examine right so examine is like getting the front element right now there are uh two variants of the methods that are provided so in one variant the methods throws an exception like the variant that we have coded those methods throw an exception if you want to add something the method is called as ADD instead of NQ right so you will say okay I will create a q object and I will call the library method add right if I want to remove the front element the method is called as remove instead of DQ and if you want to get the front element it is called as element right if the Q is empty it will throw an exception right and the second set of methods they're also same but instead of throwing an exception they will return a special value maybe Boolean value whether the operation was successful or not right so add and offer they are equivalent methods remove and pole they are equivalent methods element and Peak they are equivalent methods okay so I've discussed about Q interface in my Java Collections tutorial on the channel right so what we talked about is that in Java Q is actually a interface okay and there are three implementations there are three classes that implement this queue so your link list class it implements your fif que that we have just seen that we can build a queue using a link list okay and there is something there is a class called as aex so AR DEC is a class that implements another kind of queue in which you can insert and remove from both ends right so it is called as a dou ended que so in this case the behavior would be different you you can add at first position you can add at last position you can remove at first position you can also remove at last position so it stand it is a doubly ended que it's called as deck right it's not DQ it's called as deck right it's a different type of Q and third type of queue it's called as a priority queue which we will of course discuss it is based upon the concept of keep data structure in this case the elements don't maintain a fif ordering but they maintain a priority ordering so again it's a big topic we will discuss it separately but if you want to see the code demo how these different cues are how these classes are different in Behavior check out my video on data structures and in which I have discussed the complete collections framework as well as different implementations of Q as a part of that video let us start the topic by understanding what is tree data structure in computer science a tree represents a hierarchical structure with a set of connected nodes right so for example if you look at this diagram this actually represents a tree and this node it is the starting of the three it is called as the root note right we will discuss where it can be useful so in this structure each node in the tree can be connected to many children this is a nonlinear data structure the first nonlinear data structure that we are covering is a tree so far we have talked about array we have talked about link list all of those data structures were linear data structures because they were following a sequence here there is no sequence here there is a hierarchy right so each node can be connected to many children so two is connected with seven and five it is connected with two children so s and five they are children of two but must be connected to exactly one parent so each node must have one parent I cannot say seven will have two parents no seven will have only one parent that is two five has only one parent that is two two has only one parent that is seven 10 has only one parent that is also seven right so except for the root node which has no parent so root node has no parent rest all the nodes they have one one parent right now because of this property there will be an interesting observation suppose you're creating a tree in which you are going to have n nodes okay for example I have three nodes here so how many edges you will have except for the root node for every node that you will have that you will add there will be an edge so there will be of course n minus one edges in the tree right so in any tree that you are going to create irrespective of is it a binary tree or not each node that you add will add a edge in the tree except the root node okay so root node does not add any Edge in the tree except the root node if there are n nodes in the tree there are there would be n minus one edges okay because root node has no parent rest all the nodes that you add they must be connected to a parent through an edge right so this is an interesting observation you can note so in every tree there will be n nodes and there would be n minus one edges in the tree right so that is tree data seure now let us talk about where this data structure can be used how it can be helpful in computer science okay basically trees are used to represent or manipulate hierarchical data in applications such as file systems or directory structure right so all of you have worked with the file system so what happens in the file system you say okay I have my PC in this I have certain drives C drive D drive e Drive and then inside this I have folders F1 F2 F3 F4 and here also I have folders then I have subfolders right maybe I have photos here maybe I have some documents here right now we often do operations like that okay I want to move these photos from here to here right so what is going to happen you're not going to copy this data you're going to say okay I'll cut and paste so if you simply want to move this photos from here to here what you need to do you do not need to uh copy this information to some other part of the disk you only need to change the reference right that okay earlier this reference was stored by uh F4 now this reference is stored by F2 basically the links right the links to the folders and some folders they can be easily changed if the data structure is implemented using a tree right this is something we will discuss right file system is a good example of um a tree data structure right multiple inheritance trees in programming so this is used when you're using objectoriented programming Concepts and you have a class see which is going to inherit from class A it is also going to inherit some methods from uh class B right so this is not exactly a tree I would say because uh this node this is inheriting from two different classes irrespective of that fact basically uh the trees are internally used by the compilers to see what methods would be part of the class that you have implemented using inheritance okay then again in natural language processing basically whenever you have a sentence for example I am going for a party right now this sentence can be broken down into uh certain components maybe you have a verb maybe you have a subject maybe you have a predicate or you have even for language parsers okay so what are your parsers whenever you write code uh it goes through a language parser so that compiler can figure out if there is any error in the code is it it is having the correct Sy Tex or not so they again form a par tree of that code right again it's an interesting concept that you will learn in compilers right again they are used a lot in understanding of the language okay then in HTML there is a Dom tree so whenever you open up a website right you see there is a HTML code right inside HTML code there are lot of tags there is head there is body right inside body there is a paragraph there is a div there is a image right so if you look carefully this whole document forms a Dom tree so inside Dom tree you have head you have body right then you have certain elements you have div you have paragraph here you might have image you might have some text what is happening you want to say Okay I want to uh click this particular button and on clicking this button this div uh will change its color right so how do you fetch elements from this huge web page so there are methods like document dot get element by ID document. get element by tag name what it is doing it is traversing this Dom tree it is a tree of objects okay it is a tree of objects uh in your web browser again it's behind the scenes it is doing some kind of search operation on this tree and it is trying to manipulate this tree right for examp example you scroll your web page and a new item is added from the bottom so maybe it is adding something in in the list right so your tree is getting modified right then of course there are uh trees which are used in search operations like binary search tree there are trees which are used to implement data structure like map self balancing trees okay so they are used to perform faster searches and keeping data ordered we will talk about bsts in the coming class in machine learning there is a concept called as hierarchical clustering so it is a part of uh a clustering technique okay where I want to group together similar items so it comes under the part of unsupervised learning so there also the tree data structure is used right so we see lot of applications are there and that becomes uh very important for us to understand uh the tree data structure in this video we'll be uh talking more about binary trees in general because that they are the most common ones uh that are widely used okay so let us start with binary trees so let us start by understanding what is a binary tree as I discussed it is the most commonly used uh tree structure uh in which you can have at Max two children okay so it constrains the number of children for each parent to at most two that means uh node can have zero children for example in this case the nodes d e FG they don't have any children they're also called as Leaf nodes the nodes which don't have any children they're called as Leaf nodes node can also have one child right or it can have two children right it cannot have more than two children for example if I draw a few structures you have to tell me whether it is a binary tree or not is it a binary tree the answer is yes each node has zero child one child or two children right okay is this a binary tree the answer is yes so this node the node C it has one child A and B they have two children and DF they have they don't have any children hence in this case we have three leaf nodes so this is again an example of a binary tree right now what we are going to learn in this tutorial we are going to learn about different operations how do we create a binary tree how does the node structure look like how do we perform search or update operation on a binary tree how do we display a binary tree and there are four popular ways to do it pre-ordered reversal in ordered reversal post ordered reversal level order reversal okay so we are going to look at all those all these things one by one and we'll be starting with uh creation of tree first let's begin with that let us talk about creating the tree so first of all we need to understand the structure of the node that is going to create the tree right so in this tree if you look carefully there are so many nodes and this box represents one particular node okay that is the root node right I have the root node now what is this root node going to contain or any node going to contain it is going to store three things one is your data one is the address of the left node one is the address of the right node okay in Java we also call it as reference right now suppose this object B it is created at some memory address let's say uh 2 250 right this is the location of v in the Heap where it is created so A's left is going to store 250 let's say this is created at some location 380 so a is right is going to store 380 right a itself is created at some some location let's say 400 the root is going to store 400 okay so root is not a node root is just a reference to the root node okay so root variable is holding the address of the root node right now B's left is refering to so D is created at some location let say 560 so here we will have 560 now D is left and right they are they are null they don't refer to anyone because D is a leaf node right so D is a leaf node e is a leaf node f is also a leaf node so they're left and right they are null now B is a node with a single child right because it does not have any right child hence this value is also null and here I will store the address of e here I will store the address of F right so I hope you understanding the structure of the node so I need to implement a class called node in which I will have three things one is my integer data data can take any type just to keep it simple I'm taking it as a integer one will be my node left a reference of the next left node and node right a reference to the right node if the left and right node does not exist then I will set this value to null right now let us see in the code how can I implement this node class so let us go to intellig now I am going to implement the tree data structure I have a class called binary tree I have a class called binary tree test both are empty classes as of now in order to build binary tree class I need to Define that what is node right so node will have three things one is my data one is my left and one is my right apart from it I also need to give a Constructor here that whenever a new node is constructed what data it should take okay data I will know but at the time of construction of new node I do not know what node will go into the left what node will go into the right so I will simply say that my data this is equal to D and left and right they will be set to null by default so whenever you're creating a new node you do not know the left and right uh nodes so these will be set later right now comes the binary tree class now suppose we want to create a tree like this okay or let me take up another example in which I have numeric data I can say okay let me create a tree like this one connected with two and then it is connected with three right let's a very simple tree three notes now how you will read this tree the first thing is how do I read this tree the first input I will get is the root node okay user will enter one I will say fine and input is one let me read this create a node called a root node and root node is going to point to this node right and in the left of this I will again read from the user right user says okay fine the next node is two I'll say fine I'll create a node called two I will attach it in the left of one like this okay and now what is the next note I will read right now it can happen that I have something in the left of two or I have something in the right of two or I I have something in the right of one right so I do not know the way we are going to do it is we are going to read now what is there in the left of two okay so if the uh left of two is null right I will input minus one so minus one in the input will denote that near is nothing here so I will simply set this value to be null what is right of two I'm again going to say it is - one so I will set this value to null right now this option is gone I've read it this option is gone now I can only read this I'll come back here I'll say fine this two is done now try to read what is there in the right of one right so I'll say okay the next input is three I will create a new node and I will attach it of course here but before that I will read what is in the left of three right so attach part will happen a little later right I'll read what is in the left of three so this value would be minus1 minus one what is there in the right of three again I say minus one now this node is constructed or in a way I can say this sub tree has been constructed so once it is constructed I will return it back to the parent so the parent is one it will get connected here right so this will become more clear once I write the code so idea is I will of course do it for a bigger tree as well this is little tricky right so what the idea is we are going to build a tree recursively we are going to build recursively right now how we are going to build a tree recursively many tree operations they recursive in nature right I say okay fine I will build the root node that is one then I will build the complete left sub tree in the above example the left sub tree has only one node so it looks easy right I will build the complete right sub tree right okay I will build the complete left sub tree and I will attach it here that is part one I will build the complete right sub tree and then I will attach it in the right of one right so we will do it for a bigger tree as well so let us jump into the code first and try to see how this can be written of course I will do a dry in and explain you how you can build a more complicated tree like this with the same code okay let us go into the binary tree class one thing is for sure that every tree must must know what is the root node what is the root node this is something that will be the property of the tree every tree must know what is the root node just like in a link list every link list knows what is the head of the link list what is the tail of the link list in in case of three you must know that what is the root node right so one thing is there I'm going to read this tree so user will uh input will come through the user right so let us see the tree instruction part in this binary tree class what I'm going to do I'm going to first Define the data members of the tree so I have only one data member that is the root of the tree right now this root should be initialized where it should be initialized of course when the tree is created so when the tree is created it is created when the Constructor is called I need to define a Constructor called finary tree right now in this Constructor what I need to do I need to take input from the user so in order to take input I will need a scanner object I will say scanner SC this is equal to new scanner system. in so scanner object is used in Java to read inputs I have imported the scanner right now the building of the tree is recursive in nature so I will create a helper function to do it so I can say fine node let's say create tree and to this create tree method I'm going to supply the scanner object so that this method will actually read from the user okay I say fine the root should be initialized by calling the create tree method so create tree is a helper method getting called in the Constructor that will read the tree from the command line right now I'm going to pass the scanner object here so that I can use it to read data from the user right I'm I don't want to create this object again and again uh inside this method okay so I'm creating it once and that object is being circulated across all the recursive function calls that are going to happen right now suppose I read something I can say okay uh data that I'm going to read is scanner do next in so I'm going to read something all right now I have read something from the user let's say this data is one right what I want to do okay this data can also be minus one right I'm asking okay tell me what is the next data so I will actually have a two two types of case one will be my base case if my data is minus one then what should I return I will return a null that means okay I don't want to attach any node here that subtr is just null I will return null but if it is not minus one if it is something else basically I'm talking about the recursive case for example if my my input is one what I will do I will create a new node I'll say fine I'll call node root this is equal to new node and uh I give it the value data right if root is confusing to you just call it as n right I create a node called n which is initialized with this data so suppose my input is one right I say okay N is a new node now what should I do I need to read the left sub tree basically I need to create a left sub tree here and attach it here right what I can say that in the left of n n. left should refer to a new tree which is equal to create tree again scanner will get passed what should n. WR point do n. WR should also refer to a new tree called create that is returned by the create tree method and again the scanner is going to get passed and then I can return n what I'm saying that n do WR should also point to a new tree left sub tree right sub tree right this is the recursive way of constructing the tree now you might ask okay how does this method will actually work I will show you it will actually work let's see how it's going to work right so let us take an example of a more complicated tree or let's first start with a simple tree right I have a tree like this 1 2 3 right now for this tree what is my input going to look like so input will be 1 then it will be two then it will be left and right of two which is -1 Min - one then it will be three and left and right of three which will be minus1 minus so given this input I actually want to create this kind of a structure let's see how it's going to happen right so I said fine uh root is equal to create tree I call this method create tree it reads something from the user so one integer it's going to read so it's going to read one so data is not minus one fine I come here node n this is equal to new node so basically I have a stock call in which n is going to say N is a new node where the data is one fine now n. left it makes a new call n. left right so I said fine in the left of one I want to create tree so again create tree is called if you come again in this function you read something from the user so you read two fine you said fine I create a new node n okay new node n is created so earlier n was here now the new n is here right it's a local variable it is created in every stack call right it is here this is equal to new node where the data is two fine now n do left this is equal to create tree right so again I call I make a function call create tree go and do something right so I've made a call for here right now if I go and read what is the next number it is minus one so I return null basically what happens so two's left made a call and it got a value that is null so two's left starts pointing to null now what is the next call that is going to happen we are in this stack and I make a call that two's right this is equal to create tree so I make another call here and this value is also null right once these two calls are over this one and this one I return n so I return this n back where I return it to the place from where it was called so who called it one called it one gets to know that my left should refer to this node so by returning this n this answer goes back to the previous function and once left is now connected with now what is the next call we are going to make one's left is now created so this call is over one's left is now created right now one says okay fine my left is created I'm pointing to two I will make a call to update my right so n do WR this is equal to create tree right so this was already read again a new function called is made you read the next number that is three you create a new node from line number 29 you said the new node is three n do left this is equal to create tree so three is left makes a call to create tree which again reads a data that is minus one so you return a null so three is left says okay make a call that call says I will return null now three's right says make a call to create tree it goes and reads A number that is minus one again again it returns a null right and then you return n so now n is this right so it returns three back when you return three back what happens who called three so one's right made a call to create this tree so one's right is now going to store the address of three so it gets connected here from here if you return n where does it go it goes back to the Constructor because this made a call to create T finally root is referring to the address of one right okay I'll hide myself so that you can see root is refering to this one right so this is how it is uh happening right so this is a small example demonstrating how this small tree is constructed using this code right now I will run this example on a run this code on a bigger example as well now some of you might not be convinced that whether this code will work for a bigger tree or not so let us rerun this code on a bigger example okay so this is the method create tree that again I'm explaining with a big big example so let's say I have a tree which is which should be built like this let's say I have one I have two I have three I have four I have five and maybe I have six now what input should I give so first of all I will give the root node okay so input will be one then I will go left input will be two then again I will go left the input will be four then I will go left of 4 which is minus1 I will go right of four which is also minus1 okay then I will come back because four is done I will come back I will go in the right of two the right of two is again minus one then I I will go back two's left is done two right is done right I'll go in the right of one so right of one is three then I will go in the left of three which is five I will go in the left of five which is minus1 right of five which is also minus1 then I will go back will go in the right of three which is six then left of six right of six - one minus one right so the goal is given this input I want to create this tree structure in the output from this input I want to create this tree structure right now let us see how we are going to do it again I'm going to read some data so I will read the first number that is one I say fine data is equal to scanner. nextend it's not minus one I create a new node n right so fine let's create a new node and that is having data one let me draw the stock as well side by side so n is refering here right now what so if you want to learn ke what is the function that is currently executing so that is at the top of the stack n is created now you make a call n. left equal to cre create tree so you're making a call to create something in the left of one right so one makes a call for the left part so again you go call this function you read data so data is the next number that is two fine you again create a new node now this function is paused this function is paused here you said fine I'm going to create a new node and that node is two that no is two right now it is not connected it's not connected with one and again you say I want I want to connect something in the left of two what will be that something again you make a function called to create tree so again this is paused and it is expecting to build its left tree so you again call the function create tree you read the data so now you're going to read four so you read four you read four now four says okay I'm I a new node and I will create something in my left a forge left makes a call to create tree the force left again makes a call to create tree and in this case you read data the data comes out to be minus one and if the data is minus one you return null fors left gets to know that my value is null so a null is returned from this function which is attached with left of four then then you hit this line for the first time in this function called right and do WR this is equal to create tree now you say okay I will again call create tree I will read this number this number is again minus one it returns a null in the right also fours left and right they are null that means the sub tree of four has been created this sub tree is finished I will return n this is null and I will return n so n is this where this return value will go it will go back to the place from where it was called so who called it two's left called it so two's left is now connected with four and this function call is over right so two is left is connected with four right now this is the point where this connection has been established right two made a call to four four said okay I'll will build myself I will build my left and right which are null and now I will return myself right so two's left is over now what will happen two will make a call on the right the right sub tree two makes a call here and right this is equal to create tree now what do I read next again it is minus one I return a null I return a null from here so two's right is null two's right is null it's not refering to anything right so this value is null now two's left is done two's right is done I I say return n so return N means what is the function that is at the top at the top I have this function I'm going to return this sub tree this whole sub tree back to one so basically one will get to know that my left points to this end and hence the left sub tree of one has been built now I will build the right sub tree right okay so one will say okay fine my left sub tree has been built this is over from the call stock so once one is now connected with two and four right this tree a one will say okay now it is my turn to call the right so once left is done it will execute this line n do right this is equal to create tree now you again make a call next number you read is three so you create a new node called n this is the new node so three is created and then you again make a call to the left so you read a number five is created this is new node and you again make a call to the left minus one so five's left is null again you make a call on the right so five's left is null again you read minus one so five's right is also null then you return n so you return five five gets attached in the left of three so five is returned it gets attached in the left of three so five goes here then again what's going to happen you'll say Okay I want to build something on the right of three so three's left is done three's right is done I'll again make a call it will read six a new node will be created six okay and again you say okay I will read the left which is minus one I'll read the right which is also Min - one and then I will return n when you return n this six is returned back to the right of three so this six is being attached here and then you say okay I'm going to return n when you you return n you return this three back to one so once once right is going to point to this subtree 3 5 and this sub tree is attached with one so finally when you are here this call is over right so you will return n so n will be this node and it is returned back here root equal to create tree this this becomes the root of the tree so root is a data member of the class and hence root of the tree gets updated I hope you're now convinced that how this structure can be made so easily with this recursive function okay with this recursive function okay this way of building the tree it is called as pre-order right pre-order means first we are building the root node then we are building the left sub tree and and then we are building the right sub tree then we are building the right sub tree right so right now we have built the tree using a pre-order recursive build tree function right or create tree function right next we will look at how we can print this tree in a similar way now let us talk about tree reversals okay so tree reversal is a way to iterate over all the nodes of the tree right now this reversal can be helpful if you want to perform operations like counting the number of nodes searching for a given node updating a given node right so in order to do all these operations we must know how to Traverse a given tree right so a tree has been built a tree has been created we want a way to go to each and every node of the tree right so as I discussed if you want to do a treat reversal there are two broad techniques right so treat reversal so one is your recursive Tech technique that okay you start with the root node then you iterate recursively on the left tree and the right tree right there is a recursive way of doing it there is a iterative way of doing it right so we will discuss all these ways now right in recursive way again there are it depends upon the ordering okay the way is same we basically recursively iterate on the left and right seies but based upon ordering there are three different ways one is called as pre-order reverse Ral one is called as in ordered reversal and one is called as postorder reversal we will be looking at all of them in iterative there is only one way that is called as level order reversal right so all of these traversals they're going to travel all the nodes but the order in which you will see the output it will be different so let us start with the pre-ordered reversal given this as the tree right 1 2 3 4 5 6 so I will just redraw this tree 1 2 3 4 5 now what is this pre-ordered reversal ISS that fine what I will do I will travel the root node then I will recursively Traverse the left sub tree okay this will be a recursive call and I will recursively travel the right sub tree again a recursive call okay it is very similar to the build function what we are doing in the build function also if you look carefully we are first building the root node and then we are recursively building the left tree and then we are recursively building the right tree right if you see in this case the output will be very similar to the order in which you have built the tree so if you start traversing you will say fine I'll start with the root node I will print one I will go to the left sub tree so this whole is my left sub tree so I will print the root node that is two and then I will go to the left sub tree so left of two is four so I'll print four and I will go to the left now left is null so I come back I will go to the right right is null I come back a four is done this whole tree has been printed I come back to two I'll go to the right of two again it is null I'll come back so this whole tree has been printed I go back now left of one has been printed so I go to the right of one so I come to three I will print three I will go left now I'll print five I will go left I'll print right of five again null so five is done so this whole tree has been printed I'll go back so add three I'll say okay let's go right I'll print six I'll go left I'll go right nothing happens this hold three has been printed I come back now three has been printed so root has been done left of three has been done right of uh three has been done well return so this hold Tre has been printed I come back and at one I see one has been printed already because before printing left and right I print one this output is called as pre-order output in which before for printing left and right nodes I print the root note right so 1 2 4 3 5 6 this will be the pre-order output for this tree right now let us see this thing in in our code as well let's write a pre-order print method let's write a method called void display and this is going to be the method that will display the tree right inside this logic can be changed I can display a tree in a pre-order way or in a level order way or any other way right I'll again create one more helper method so I will say void pre-order so void pre-order print now this is a recursive function so I have to tell at what node I'm currently at so I will start with the sum node that is root node okay so what I will do I'll say fine I will have a base case what will be my base case what is the smallest tree I can get that the tree is null the root is null in that case I don't need to print anything I will simply return otherwise what I will do I'll print the root data and I will go on the left and the right tree so I'll say find uh s out root do data go and print the left sub tree recursively so pre-order print root. left then pre-order print root. WR that's it and in the display method I can call pre-order print with the root of the now let's do one thing let us test our binary uh tree because we have the create method we have the print method now I can create a binary tree and try to print it I can say fine I want to create a binary tree object this is equal to new binary tree I have defined the class now as soon as this Constructor is called your tree will start getting built because we call the create tree method here right now I can call T do display right now think of any tree that you want to make we will give it as an input here sorry I should run this file now this is waiting for the input right so let me draw a tree let's say Tre is 1 2 3 4 5 six right now how this tree will be given as input so you will input one then two then four then left of four Min - one right of four Min - one right of two Min -1 then three then you will input five left of five right of five right of six right of three that is six left of six and right of six okay the same input that I have shown you in the example also this input is given and now I'm saying that let me print this tree what I'm getting I'm printing one I go here then I go to two fine then I go to four fine then I go to three I come back I come back I go here yes then I go here five then I go here six absolutely correct right so if you look at this was a pre-order build right and this is actually a pre-order print if you see the output will be exactly same 1 one 2 2 4 4 minus one I'm not printing skip skip skip then 3 5 3 5 absolutely correct minus one I'm not printing six six right that means my both functions are working fine Tre is getting built correctly and Tre is also getting printed correctly as well right now I will show you two more variations of this print method that is called in order print and post order print so now let us discuss the next type of recursive printing that we call as in order print okay so I hope pre-order is clear now we are moving to in order so nothing is going to change the order of printing is going to change okay so earlier it was root left sub tree and right sub tree now what we are going to do in order means root will be printed in between so before you print the root you will print the left sub tree okay and after you print the root you will print the right sub tree that is what the in order printing would mean let us dry run this Logic on our uh code and see what do we get in order so what I want to do so I will start from the root node I want to print this root node but before that I will have to print the left sub tree right now at the left sub tree again if I am at two I have to print the left sub tree so that means I will have to print four so four will be the first output that I will get now I will print the root so what is the root the root is two all right then I will print the right sub tree so right sub tree of two is null right then I can go back to one so for one I have seen the left sub tree is already printed then I can print the root so I will print one and then I will print the right sub tree now I at three right before I print three I will have to print the left sub tree so only one node I will print five then I can print the root node that is three then I can print the right sub tree that is six right this will be the output we can expect by traversing this uh three in a in order fashion so let us jump into the code and see what we will change right just like the pre-order print method what I will do I will create one more method called as in order print so in this case the root will be printed in the middle and this call will be now in order print root dot left and this will be now in order print root dot right okay now in the display method instead of calling pre-order print maybe let's just call in order print this time I want to display the tree using in order print I will pass the root of the tree as a parameter here let us give the input for this tree and see what output we get we are getting 421 536 is it the expected output 421 536 the answer is yes right now you might be interested in doing a call stack analysis of this right so let us see how we can do the call stock analysis as well right in the beginning what is happening uh let me also copy paste the code this is the code right let us do the call STI analysis this is the method that we are calling right so the call stack is empty so we called in order print where the root node is one so I say root is one but I'm not going to print it so root is not null I will just call on the left so I make a call here right so that means root is now two I'm at this node but I'm not going to print it again I make a call on the left that means root is four okay I'm not going to print it because root is not n again I make a call on the left when you make a call on the left of four you actually come here this is null if this is null you return okay so you return then you make a call then you print the root data so that means you print four this is the top of the stack and this is the root that we are talking about so you will print four then what's going to happen you will say okay I'll go right right is null again you make a call to null and you return so you come back again you are here now for four you have done all the three things left is done root is done right is done so you return so from here you go back and this is gone from the stock right now what is the new top right how do we come back to two this is how we come back to the two the new top is this now this is the root node that is currently you're talking about have I printed the left yes have I printed root. data no I will print it now have I printed the right no so I make a call on the right of two that is null and I again return then this is done so I come back now what is the top node the top node is one so have I printed left yes have I printed root. data no I will print one and I will make a call on the right so I make a call on this tree right so again you do a similar process you come at three right so root is three then you make a call on the left that is root is five so five's left is null so you print five five's right is null you come back so five is done then you go back the new top is now three right it was five now it is three three says okay my left is done I will print myself and then I will go right so root will be six so you come here right you went here then you came here six now root is six left and right they null so six will get printed right is null right and then six will be popped off right then so for three right is also done so this call is over right and you come back at one so for one left is done root is done right is done so this call is also over right finally the call stack will be empty and this is the output that you will get right so I hope you have understood the in ordered reversal now make a bigger tree and try to uh generate the output for that particular tree right and next I will discuss post order reversal let us talk about post order print so as the name suggest post means the word after okay in this case what we do we print root in the last so first we print the left sub tree then we print the right sub tree recursively of course and after then we print the root right if this is the tree once again what I will do I start with one but I have to first first go in the left sub tree then I have to go in the right sub tree and then print one right at two I again have to print left sube that means I will print four then I will print the right sub tree so right of true is null then I will print two so I will print two then at one I have to print left which is done I have to print right sub tree and then I will print two so at three I will say Okay print left sub Tre which is five then print the right sub Tre which is six then print the root that is three now for one left sub Tre is done right sub Tre is done then I can print the root that is one right this is what the post order output would look like right you might be asking uh why do we need so many traversals okay for example what happens in certain problems is in certain problems you are expecting that um you are expecting output from the left and and right sub tree for example given a tree I want to calculate the height of the tree right for example I want to calculate what is the height of this tree right in order to calculate height what you will need you will need to know that what is the height of the left R Tree let's say this height is three what is the height of the right sub tree this height is two and can you say recursively at this root node the height is uh nothing but it is the maximum of left and right okay maximum of the answer that you're getting from left comma right and one more than that so can I say the height will be four what is this this is the answer from the left subt Tre what is this this is the answer from right subt Tre so what I'm trying to claim is in order to build the answer at the root node you need the answers for the left sub tree and right sub tree and hence in problems like these you would of course need a post order reversal right so that is the idea when you need answer answer from the uh child sub trees to calculate the answer at the root you will definitely need post order reversal there right so now let us write the code and then we will do the dry run of that code right writing code is very easy so I I'm in the in this class if root is null I will return right then what I will do I'll go on the right a left post order root. left then I can say post order print root. WR and then I will uh print the root note so s out root do data right now let us go and um call Post order print in our display method so I can just pass the root here T do display it's calling the post order print method now for the same input let's copy this input and we will will see what output do we really get now we have given the input I'm getting 425 631 is it the same output as we have got 425 631 absolutely yes now let us do a quick call stack analysis of this method as well so I'll copy the code I'll put it here and uh let us do a quick call stock analysis let's say this is my call St in the beginning I give one as my root node root is one then I say okay um make a call on the left my root is two I make a call here now code is paused right call will happen later again at two I make a call on the left I come here root is four a four makes a call on the left left left is null I return then four makes a call on the right right is null again I make a call and return now I can say print root do data I will print root do data this is the top of my St I will print four right then uh if four is gone from the stock what is the new top the new top is two right that means I am in this function I'm at two so I'm printed the left I make a call on the right right so two says okay go and print the right right subtr is null I return then what happens left and right they are done I will print root dot data that means I will print two right now two is also gone we are done one is at the top of the stack now at one I said okay go left which is already done left is done go right I come here so now one makes a call to three now three says okay go left three makes a call to 5 R5 goes here and R5 says okay go left which is null go right which is null and hence you print five so you will get five as the next output right now once five is gone you're back again at three three says okay my left is done this is done I will go right so I go to root node that is six root becomes six in this call so this is the top six say go left null go right null and hence you will print six right and then six is also gone from the call stack then what happens you are at three three says okay my left is done right is done I will print root data so I will print three I will get print three three is also gone from the stock and now top is at one so for one left is done right is done and hence you will print the root dot data that is one right this is the output of the post order print I hope you have understood post ordered traversal next we are going to discuss the level ordered reversal okay let us jump into the uh iterative traversal which is also known as level order traversal okay so that means we won't be using recursion we would be using some kind of iteration to iterate on the tree okay uh some kind of loop so let us take this example of tree once again and idea is instead of U going in a depth first manner okay so in all the traversals that we have done so far what is happening we are starting from the root node we are going here then we are going here so all these traversals they are depth first traversals that means you first go deeper into the tree and then that's how you iterate okay so your pre-order post order and in order they are depth first traval right but now the traversal that we are going to do now it will be a breadth first traversal that means if I have a tree like this I will be going across the breadth of each level this level this level this level right that means I can expect an output that is 1 2 3 and 4 5 6 right so level order reversal so this is my level one then I am printing level two and then I'm printing level three okay what is a level all the nodes which are at same distance from root node so level one all the nodes are only one node it is at distance Zero from the root node or let's say level zero level one all the nodes are distance one from the root node and this is my level two all the nodes are at distance two from the root node okay so this is also known as breadth first traversal right breadth first reversion right now let us see how we can achieve this kind of a reversal uh right so let's draw this tree once again now if you look carefully if you start uh doing any traversal that is a recursive reversal right so from one you come to two right and at two you do not have a direct way of going to three right so that means with recursion it will be very difficult for us from two to go directly to three right and if we go to three we don't know a way to come to four right so we cannot go back and forth right so how this is achieved this is achieved by using a concept of a q data structure okay what we will do we will create a q q you know it is a P4 data structure first in first out so in the beginning I will push this node in the Q fine right and then I will say okay like Q do push root now I will pop one node from the queue so I will pop this node and I will push the children of this node into the queue so I will print it output will be one this is popped and what are the children of one children of one are two and three right now how do I know the children because I'm not going to store an integer value here I'm going to store the reference of this note right so I'm going to say okay this root is the address of this node is stored there so if you know the address you also know the uh child values right so you know the children are root. left root. right I will push the reference of two and three in the Q right next I will again pop one node I okay let's remove two let us print it and let us push the children of two in the que so two has only one child four will be pushed into the Q right again repeat this process pop one node so now you're going to see that okay one is done two is done the next node is coming is three right I will pop it I will print it and I will push the children of this three okay into the que so I will push 56 so look carefully when the second level or the first level is popped the next level is already in the cube right the next level is already in the cube let's say I have some more notes let's say I have uh 7 8 and 9 right so let us just extend this example a little bit now I will pop four I will print four this will be removed four does not have any children so nothing will be pushed next I will pop five I will print five and I will push the children of five into the que so I will push seven and 8 into the cube right next I will pop six I will print six and I will push the children of six into the Q so nine will get into the Q next I will pop seven I will print seven and uh no children so nothing will happen next I will pop it print it no children nothing will happen I will pop nine print nine and the Q is empty right so no children so Q is now empty this will be my output of level ordered reversal right I hope you're convinced that this is the correct output for this tree right now let us look at this implementation in our code as well let us discuss uh the implementation of level order print so I'm going to create a method called as void level order print and first of all I will I will need a q object right and I also need to pass the root here I'll say okay fine I'll need a que of node called Q This is equal to New Link list in Java Q is a interface and Link list is a class that implements the methods of the Q right we need to import this from the uh util package okay so linkless is imported Q interface is also imported so to start with you can say Okay Q dot offer that is your add operation right and I can offer root inside the Q that means I can add Q right I said you will do some work while the Q is not empty so while the Q is not empty what you will do you will pop out something you will say okay give me the node which is at the front of the Q node F this is equal to Q doole right so this removes the first node like we have seen in the diagram we are always removing the node at the front of the cube right so this is going to remove it and return it right now I can print the data of this node so I can say s out F do data and now I can check if the left and the right side if they're not null I can push them into the Q if F do left is not null I will say Q do push p f do sorry Q do offer F do left and if the right child is not null sorry if yeah if the right child is not null I can the Q do offer F do in this way Q is getting uh filled using these if conditions and it is get getting empty from the front using this whole operation right that's all that is the code and now I can just run this code in the display method or here I can say uh T do level order print okay root so it's better to call it uh internally because root I don't want to access it outside so okay I'll just call it from the display method because we are testing the functionality so I can say level order print so here I can just call T do display so now my tree will be displayed in a level order fashion let's see what output do we get for the given tree I'm getting 1 2 2 3 4 5 6 which is correct and uh if you look carefully here for this tree I'm getting 1 2 3 4 5 6 yeah this is the tree actually so I'm getting the correct output which is this I hope you understand the level audit reversal and how it is achieved using the Q data strcture the code is very simple and uh you can also do a dry run of this code at your own let us start discussing binary search tree data structure so right now we have learned about binary trees which we said it is a tree in which every node can have at Max two children a binary search tree is a special kind of binary tree which is optimized for the search operation okay so that is why the name called binary search tree in short we also call it as BST BST is a special kind of binary tree with the following properties the first property is the value of all the nodes in the left sub tree of a given node should be less than the value of G given node for example if this is the root node and it has certain value for example this value is eight then all the nodes which are in the left sub tree they must be less than eight okay and all the nodes which are in the right they must be greater than it so this is the BST property right now how this makes searching easy for example you are searching for five you don't need to have to Traverse the entire tree you will have to say okay I will go into the left sub tree right now this property that we are talking about that nodes in the left sub tree would be smaller nodes in the right sub tree would be greater it is not just applicable for the root node but it is applicable for all the nodes of the tree okay so we'll see an example how do we construct such a tree where every node follows the BST property so this this we call as the BST property right or the bstd properties so this is what makes this tree very special and efficient as well right now suppose we are given this data and we want to create a binary search tree from it right now how we will create it let us discuss so first of all we are getting eight right so8 will be the root note because my tree is currently null so eight becomes the root note right now next element that I'm getting is three now three I know it it is is less than 8 so it will go in the left sub tree of eight so three will go here next I'm getting 10 so then I know it is greater than eight so it will go into the right of it it will get connected here right now I I want to insert one so again I do not know where it will go so I will start from the root node so 1 is less than 8 I will go left 1 is less than three so I will again go left I will insert one here then I get six six is is less than eight I go here now six if you compare with respect to three it is greater so it will go here six gets inserted here then we have 14 so 14 is greater than 8 I go here it is greater than 10 so I go here so 14 will get inserted here then I have four four is less than 8 I go here it is greater than three I go here but it is now less than six so I have to travel the branches accordingly so that means four will get inserted here then I have 13 the 13 is greater than 8 go here 13 is greater than 10 go here 13 is less than 14 so you will go here and finally I have seven right so seven if I start with respect to root note less than 8 go here greater than three go here greater than six go here seven will get inserted here right so this is how the binary search tree is constructed okay so we have discussed how do we create a binary search tree so we have to insert all the nodes one by one right now how much time it will take to insert one node right so it will depend upon what is the height of the tree now suppose if this tree height is H and I want to insert a node in the worst case I have to travel one branch for example if I want to insert let's say 20 right or let's say I want to insert 12 right so what I will I have to do I have to start with eight go here it is greater than 10 I have to go here it is less than 14 I have to go here and it is again less than 13 so I have to go here and insert so this is how 12 will be inserted in the tree right now let us talk about searching okay how do I search for a given note now for example I I want to search for let's say seven right where is seven present or if it is present or not so I just want to Output yes or no whether this is present or not I start with it if seven is present it must be on the left so I go here at three if seven is present it must be on the right so I go here at six if seven is present it must be on the right so I go here now I hit a node which is actually seven right that means if I'm again performing an operation like search I will do it in order of H time where height in the worst case can be n also for example if you say Okay I want to insert these nodes into the binary search tree so it will form a skewed tree like this 1 2 3 4 right so a height can become n also so that is why I'm not saying order of n or I'm not saying order of log right so the height in the worst case will be uh can become order of n right and in the best case if your tree is a fully completely balanced tree like this okay in the best case if a tree is like this the minimum height it will have would be log of n right so height will be greater than log n greater than equal to log n and it will be less than equal to n so height lies in this range right so accordingly the creation and the searching time okay not about creation but inserting one node okay so inserting a single node will take order of H time where H is the height of the tree searching for a given note will take order of H time where H is again the height of the tree I hope you understood the fundamental concept behind binary search tree and now let us dive into the implementation of it so let us start by building a binary tree binary search tree class okay so in this class what this class should know that what is the root of this tree so I can okay private node root I I have a root node which is a private member because I don't want a outside world to access this root directly right now I want to initialize this root node by creating a tree right I can okay there is a binary search tree Constructor and in this case I can say this do root this is equal to some build tree method that I I'm going to create right now let's see what is this buildy method going to be so I can say Okay public void or public node built tree so built tree is going to read data from the user and it's going to insert all the nodes into the tree one by one okay so in the example that we took we said okay we will take these nodes and we will insert them into the tree one by one so if you take eight you inserted into the tree then you took three you inserted into the tree then you took 10 you inserted into the tree then you took one and so on right so we what we have to do we have to insert nodes into the three 1 by one so we will also build a insert method that will do the work for us right now how do I read this data so I will read it till I hit minus one right so this is one way or you can ask how many nodes you want to insert and then you can read n numbers both are fine right so I can do this as well or I can say okay I will read and followed by n integers right so right now I'm doing it this way that okay I will read everything until I hit minus one so I can say okay fine scanner equals new scanner and now I'm going to read data right so I can say int data this is equal to scanner do next int while this data is not minus one what I will do I'll insert nodes into the tree so while data is not minus one I can okay this do root is given by the insert function and what what I need to insert I will say okay take root and take this data insert it into the tree okay so for example if I want to insert six I okay fine take this root node take this number six and go and insert six into this tree so maybe six will go here right something like this I'm going to do so I will give data as well right and finally I can okay build Tre is going to return root right that is fine or you can do it like this as well node root which is initially null you can say say it like this as well I'm finally returning the root node which will get updated here and this root is the data member root that is here right now let us write the insert method that is going to insert data into this tree so this is just like a rapper function okay so the actual insertion will be done by the insert method I want to say okay uh node insert I'm going to get root node now this root node is uh in the beginning it is this root node but it's going to be a recursive function so this root node is going to change right and the key that I want to insert right okay so I'm already getting the key now can you think how this insertion will work okay so let us take an example of beginning what is going to happen in the starting in the starting you're going to insert eight the root is null so here the root is null and the data that you're getting is eight so if the root is null can I say inserting it is very easy just create a new node and return it so your root will get updated so you can okay root is equal to insert uh you give the current root node maybe you can give the this root node that is fine and you can give the data right so what is going to happen you're going to say fine I'm inserting uh I'm inserting something into a n Tre so you can say if root is null that means you can insert it directly you can create that node and you can return it so you can say return new node and the data is equal to key so this this will also act as a base case and it will also help us in the beginning to create the actual root node of the tree right but if this is not true for example I've inserted eight now the root is pointing here right and suppose I want to insert three now this three is given input to this tree right I will compare is three less than 8 so I will compare if root dot data sorry if key is less than root do data then what should I do I should go and insert in the left sub tree right so I can say okay root. left now this will point this will point to a new sub Tree in which three has been inserted so root. left this is equal to insert method again where in the root of left and the key will remain key right now this is a very important step you have to see right what I'm saying is that go and insert three in the left sub tree of eight so so if you hit this what will happen your root will come here again you will observe that root is null so you will return new node of that key so you will say okay fine I'm going to create a new node three and I'm going to return it where you're going to return it you're going to return it from here that means it will get updated in the left of eight so this is how three will get connected in the left left of it okay let me finish the codee I will do a complete dry run okay and the complimentary case okay we can make it less than equal to so if duplicate elements are present all of them they will go into the left sub else this is not the case else root. WR this is equal to insert root. WR comma that means if it is greater go and insert that node into the right sub tree and update the root. WR okay and once it is done what I have to say I have to say return root right now this is important because every function is expecting that address of a tree or a sub tree or a root node will be returned so we are going to return the current root now let us take an example of let's say 8 3 10 1 6 and let us try to insert some of these numbers into a okay so I'll just take this example and I will IUN this function what is happening oh okay I think I missed out one thing here I will have to read the data again also so I have to say data equal to scanner. Next in so I'm inserting a number okay and then I'm reading the next number right so first of all I will read eight fine so if for eight root is null the root will point to 8 I will okay return new node of key so insert call is over next time I'm reading this number three using this line data is equal to scanner. nextend data is not minus one so I okay root is equal to insert into this three right so root is now eight and I'm saying insert three so if you want to insert three what what will happen the base case is not true you come here if key is less than equal to root data yes root. left this is equal to insert root. left comma key right so I will draw the call stack as well so I have have eight so eight makes a call on the left so left is null so you hit the base case you say return new node of key right so it returns a new node three so this function returns a new node three now where is this three getting updated so three is getting updated in the root. left so it is getting connected in the left of 8 so this is how it is getting connected right so this is over and now from this function call you return root you return root so you basically return the address of 8 back into the uh build tree function okay now you want to insert 10 okay you got 10 again you compare 10 with respect to 8 right so what happens you call the insert function take this tree insert it now root 8 is not null n is not less than root so you come into the lse block you say root. WR this is equal to insert root. WR comma key root. right this is null that means you again hit the base case this base case returns a new node that is 10 where is this node returned it is returned to the previous function which is this and where it is getting updated so 10 is getting updated in the right of eight so you get 10 here and this base case is over so8 is connected with 10 and you return root so what is the root not this eight is the root node so you return this address back into the main right now comes the next node you read one and you want to insert one into the this particular tree so now this is the tree 8 3 and 10 right now you want to insert one here one is less than 8 fine so it says go and insert one in my left sube it makes a call here right it makes a call here now when you reach three so your root is three right and you again compare is three is 1 less than equal to three the answer is yes so you again make a call root. left this is equal to insert root. left so you make a call here so you make a call in the left of three now this value is null so you return a new node that is one this one is updated in the left of three so you return one one gets attached in the left of three and then you say return root effectively now you're returning the address of three back to 8 now 8's left is again earlier it was refering to three now again it is referring to three but now with three one is also attached okay so that is what I was saying that one gets inserted in the left sub Tre of 8 right so this is again updated so earlier it was storing the address of three now again it is storing the address of three and again you say okay from this this function I'm going to return root so you are going to return the address of eight back into the built tree method okay let us do one more insertion let's say I want to insert six so six is less than 8 so this is now the tree 8 3 1 and 10 right now 6 is less than it I go here 6 is greater than three I go here so again what happens this is null so you return a new node so you create six so that address is attached in the right of three and from three you say return root so three gives it address back to eight and 8 gives its address back to me right so by keep on doing this you will be able to insert all the nodes until you hit minus one into this tree right so I hope you have uh understood the insert method the insert method is going to take order of H time to insert insert one node into the tree right now let us ryun this code and see if it works okay I want to execute this code dry run we have already done so I have a binary search tree test class I've created a main method so I have to create a BST object here so I have to say binary search tree BST this is equal to new binary search tree this will automatically trigger the built tree method and it it will start reading input from the user okay but if I want to display this tree maybe I have to do some kind of traversal as well so I go into the binary search tree class and here we can write a method for doing the in order print of this tree right so void in order I can say node root and here I can okay if root is null do nothing thing otherwise do a in order print on the left sub tree print the root data and do a in order print on the root dot right so let's call this as in order print in order print okay let me create a display method from where I will call the in order print method so I can okay uh in order print and here I give root or you can say this do root both are okay this do root means we are talking about the data member root okay so display method is done so I am going to create the BST and I can say BST do display let us execute this code the build is complete it is waiting to uh waiting for us to give input so let us give the input and here we got some output so this is the output of in ordered traversal of this tree and this output looks sorted let us see uh what output we should ideally get let us quickly create a tree with these numbers so I have uh 8 I have three I have 10 I I have 1 I have six I have 14 I have four the four will go here then I have 13 so 13 will go here then I have seven so seven will go here that's it right now in ordered reversal that means before printing root node you will print left and then you will print right so now we know all the nodes in the left subt are smaller all the nodes here are greater right and if you do it for every node you will observe your output will be sorted so at three if I okay go left that means I will print one then you will print root that is three then you will print the right sub tree so for six you will print left root right so you will print 4 6 7 and then you go back here for eight left sub tree has been printed so you print root and then you print right so you come here at 10 you say okay left which is null then root which is 10 then the right sub tree so again here left root right so again you will print 13 and 14 so this is the expected output of in ordered reversal let us verify if it is correct so we are getting 1 3 4 6 7 8 10 13 14 which is absolutely correct so that means our build tree and the insert methods they are working perfectly fine right so I hope you have understood the insertion in a binary search tree so now let us talk about the search operation in a binary search tree so given this BST I want to search for a particular node for example let's say I'm given that I'm searching for a key that is two how do I search for two right so I will start from the root note I will compare 8 with two so I will see okay 2 is less than 8 so I will go here I will go left two is also less than three so I will go here and here I compare if two with one so what happen happens if two is present it must be on the right of one so I go here so I go in the right of one but as I reach here I see that I'm hitting a null value that means two is not present right so one of our case would be that if I hit a node that is null right that means the given key is not present so I can simply return false that will be one kind of a base case right now suppose I'm not searching for two but I'm searching for let's say uh seven right so seven is present here let's see how we can do it now if I compare seven with 8 I know it is less than 8 so I will go left if I come to three 7 is greater than three so I will come towards right and at six 7 is greater than six so I will again come towards right so now I'm hitting a node where my root data matches with key so what should I return of course I should return true so if root data matches with my key I would be returning true from the method right now let us talk about a recursive case if we are searching recursively so what exactly we are doing right so we are saying that fine I'm going to compare root node with uh the given key let's say the the key is seven so I'm comparing eight with seven right now if the key is not matching so what I'm saying that okay if the key is lesser I will search in the left sub tree whatever is the answer of left sub tree I will return that answer now suppose the left sub tree says true the key is found I will return true but if the left sub Tre says false I will go and search I will not go and search in the right sub tree why because I'm already checking whether I should go left or I should go right right because if the key is less than or equal to it will be present in the left sub tree if the key is greater than or equal to root note it will be present in the right SE Tre let us take an example of 13 right so now 13 is greater so I will not make a call in the left sub tree I will make a call in the right sub tree I okay go and search in this tree now at 10 13 is greater what I do I say okay go and search in the right sub tree at 14 13 is less than 14 so what do I do I say go and search in the left sub Tre now at as I reach this note I say okay this matches my key what I will do I will return true this 14 will also return true this 10 will also return true and this eight will also return true so this is how true will be propagated back right so what I have to do if root data is uh let's say root data is greater than equal to key right so that means key is less than equal to root data that means I will return the answer of the search method by calling the left sub tree so I will say Okay return whatever has been returned by the left sub tree for that key so root. left comma key right otherwise I'll say return whatever has been returned by the search method by calling it on the right tree so root. WR comma key so this will be my search method now let us quickly write this method in our code as well and then we will see whether this works correctly or not it should it should work right so this I'm writing it recursively you can also write it iteratively right so the only thing that you need to do is you need to reavel at Max from the root node to one of the leaf nodes in the worst case that means the complexity of this method will be order of H where H can lie between n and login right so in the best case scenario when the tree is perfectly balanced your hi will be login in the worst case if all the nodes are on one side that is called as a skewed tree your complexity for search operation will be order of n now it is much better than um binary tree because in binary tree you have to search for across all the nodes but here we know that we have to move in One Direction either left or right but not both okay let us quickly code it up and see so let us write uh a method called search so it will have Boolean return type so I can say Boolean search I'm going to get the root node and I'm also going to get uh the key that I'm searching for okay let's say this is some search uh function right so it's a recursive function so I have to write a rapper function as well so I can say Boolean search uh where I'm just getting the key so it will return whatever has been returned by the search function and here I will pass the root node and the key now let us see how this can be done so I discussed there will be two base case so you can stop if your root is null that means the key is not present so I can say return false in that case but if your root matches with the key you can return true in that case okay otherwise I have to compare okay so I have to say if root do data is greater than equal to key or you can say key is less than equal to root data then you have to call the search function on the left and you have to return whatever that function is returning so return the output of the left sub tree so search in the left sub tree that is root. left comma key else you can return output of the right sub tree so root. right comma right so this will be your search function recursive function is the search function so this looks good now let us test our method so here I can okay uh s out T do search let's say I'm going to search for four sorry this is not uh the correct file I have to do it in binary search tree BST do search I can say let's say search for 4 and BST do search for let's say 41 right so I will s out the output and same here this looks good to go and let us run our code now let us give some elements let's say 10 20 30 41 3 5 6 8 9 - 1 right this creates a tree and for the value four I'm getting an answer false that four is not present and uh for other values I'm getting the tree is uh the 41 is present the 41 is present here right and you can see in order display is looking sorted and four is not present in this and 41 is present okay so this is how the search method is working I hope you understood the search method really well next we will move on to deletion let us discuss deletion in a case of a binary SE tree so deletion means that okay I've given a particular note and I want to remove that note okay for example someone might say that okay let us delete 13 or let us delete three or let us delete eight right so if You observe closely there are three kinds of nodes okay so there are nodes which have no children also called as Leaf nodes there are nodes with zero children deleting them is very easy there are also nodes which have one child deleting them is uh slightly more difficult and there are nodes which have two children they are even more tricky to delete okay for example node like eight if I want to delete this node then how would my tree structure would look like so we have to discuss all these scenarios now right so let us start with scenario one and let me create a copy of this tree as well so that I can use it right suppose I want to delete a node like four or I want to delete 7 or I want to delete 13 so deleting it is very easy so suppose let's say I want to delete 7 right so that is my case one case number one so in that case what I need to do first I need to search for S where is this seven located right so I need to reach that node so I start from eight I say okay seven must be on the left so I go to three so three says seven must be on the right so I go here now six says s must be on uh right so I go here right if I reach this node what should I do I would say okay fine this is the node that I want to delete I will somehow delete this node and I will return a value null to the parent so basically what I will do in every call I will try to change the tree I will say okay in the right of six I will attach a null value and this node is now referenced by no one so that means this will be automatically garbage collected okay so garbage collector will come and it will get garbage collected because no one is referring to this node okay so garbage collection mechanism will clear out the memory occupied with by this node so what what I need to do is I need to reach this node and if this matches with the data that I'm uh finding out I have to uh return delete null okay so when I return null value that will get updated in the right of six okay so I will also update so that means uh the return type of the function will be of the type node it will not be a void function there will be a function and I okay fine root. write this is equal to some delete node and uh Delete node returns a null value which gets attached in the right of six okay so this function is delete node something like this I will be doing so just to give you an idea how it's going to work so basically we are going to update the right reference in the parent that is case number one this is how it will be deleted now let us write the code and see case number one and then we will discuss case number two and case number three so I am in the uh file called binary search tree. Java which we have written now we are going to define a method called as node remove and here we are going to accept the current root node and the key that we want to delete right of course there will be some base cases which we will see okay and there will be some recursive cases as well right so one thing that I told you that first we have to search for the node okay now uh three possibilities can happen so if you are at 8 and that the node that you're deleting is also eight then you can do work there but if the data is lesser than eight you have to go left if the data is greater than eight then you have to go right so first let us do the searching part so if the key that you are that you want to remove is less than root. data in that case you do not need to do anything at the current root note what you need to do is make a recursive call in the left sub tree for example this is8 and I want to delete something which is five a five is not present here so what I will say okay I'll say okay go and remove five from the left sub tree the remove function will go and remove five from the left sub tree so you say root. left and key go go into this tree and remove it now it is possible five might be present here or five might be present here or five might be present here we do not know right so whatever it is uh after removing five whatever is the new root of the tree that will be given back to me so I will say okay 8. left this is equal to remove so I can say root. left should be updated by the reference of the new Left sub Tre that I I'm going to get now it is possible that here the node was six and nothing changed still I will get the address of six back here right so that is something we have to do root. left this is equal to remove so I make a call in the left sub tree to remove it so this is a recursive case right else it is also possible that key is greater than root data that means I have to do the same thing but in the right sub tree for example I want to remove 10 I can say okay go and remove 10 from the right sub tree and whatever is the new tree give the reference back to me I can say root. right this is equal to remove root. right comma key right else that means this is the node where I have to do the actual deletion that means it is the case of equality right so this is the node to be deleted now I I said there can be three cases case number one that I have a node with node children in that case it is pretty easy that for example if you're talking about a node like this uh a node like seven right if you have already traversed till this node and you want to delete this node it matches seven so what I can say I can simply say return null right I can simply say return null so I can say if root. data matches key I can say return null now this null will be attached in the uh back in the parent right so if it was present in the left the left value of the parent will become null for example six and seven right so six made a call on the right that okay delete uh the seven node from this sub tree now 7 is equal to 7 so I'm saying return null right this null is returned and root. WR called the remove function which returned null so this remove function returned null eventually what will happen the right of six will start referring to null and from six we will return the address of this sub tree which is nothing but this node itself right so finally what what we have to return we have to return root also right like if we are not returning null that means if we are returning from some other node we have to return the same roote that we were getting as input so six will return its address so seven returns a null okay which gets attached to here six returns 6 three returns 3 8 returns 8 okay this is how it's going to happen so we have discussed the case with zero children now let us discuss the case when we have one child right now suppose I want to remove 10 right now look at look at this I want to remove 10 so let me draw this diagram again right I want to remove 10 right now this is case number two where I have one child right now if you look carefully if I want to remove 10 what should I do right so that simply means that it is a node which has either a left child or it has a right child right if I want to remove 10 can I simply say that whatever is the left sub tree or the right sub tree of 10 this will get connected directly here and 10 will be removed so if I simply say remove 10 and this child will be connected here is it correct is it a BST the answer is yes for 8 14 is greater and 13 is less than 14 so it is correctly placed okay what I'm trying to say is if you have 10 and if you want to remove 10 right what so you have to actually return the non null child of 10 back to eight what is the Nal child so this is the right sub tree right if you want to remove this node you have to return the reference of this right sub tree back to it so8 will point to 14 and the remaining sub tree will get attached as it is so nothing changes in the sub tree nothing changes in the sub tree right okay this is the point that I'm trying to make right so how do you reach 10 by the search mechanism that we have already written right I want to delete 10 so 10 is greater so I will come here now at this node 10 is equal to 10 what should I do I will return the non null child of 10 back to the parent so this is what I have to do now let us see how we can write it in the form of code all right okay so I think I have made a small mistake this is a node to delete so of course the data will be equal because we are in the else case but case one was no children okay so I need to fix this case so the condition would be both left and right of that node are null okay so I'm fixing a small mistake here root. left is null and root dot right is also null null would be Capital small small so I can return null right the root do left is null and root do right is also null that means if it is a leaf node okay now let's talk about case two that means exactly one of the child is not done so lse if root. left is null that means the left child is null and the right child is not null in that case can I say I will return root. right back to the parent else if it is the other way around if root do right is null that means the right subtree does not exist so we are at a node where the right sub tree is null but the left subtree is existing and I want to delete this note so what I need to do I need to return the address of the left sub tree back to the parent so I can say return root do left now what's going to happen this will get attached here but do you really think that this node will be deleted do you think this node will be deleted the answer is yes why because who was storing the address of this node the address was was being stored here if this is updated if this is updated if the right of this root node is updated then no one is referring to this note that means in a way this object becomes eligible for garbage collection so this will get deleted right so this is what we need to do now we have a third case which is case three that means a node has two children we need to delete a node with two children so let us discuss how this case three will work so let us discuss case number three this is the tree and suppose I want to delete a node which has two children so it can be any node which has two children so let's say I want to delete eight right now if I directly delete eight this tree will be split into two parts which I don't want this tree should remain same right this tree should remain same so what I can do is I need a way so that uh I do not disturb the tree structure a lot right if I talk about in ordered reversal of this tree I get 1 3 4 6 7 8 10 uh 13 and 14 right so this is what I get right if I want to delete8 the new root node should be either Seven okay or it should be either 10 so one of them should become the replacement of this no right now how I'm going to do it so it can be the largest node in the left sub tree that is option number one right option one is make the largest in the left sub tree as the root node right option number two is make the smallest in the right sub tree as the root Noe in the right sub tree as the root so you can use any of these options okay so if I show you if I make smallest in the largest in the left sub as the root node in that case seven will become the root node okay now how it is done let us see now suppose you have reached the node which you want to delete and it has two children right so you will okay I'm going to find out the largest node in the left TR Tre so how do you find the largest node in the left TR Tre you start from this node and you try to keep on going right you always go right and eventually when you stop here because the right of this node is null so you you have to stop at this node and you will have to say Okay this is the largest node and I will put this node here right now putting means I will copy the data so you will copy the data seven here so this data is copied right I'm not changing the node structure I'm just copying the data so seven is copied here right now if you copy seven here what you will observe you will observe this seven is duplicate right this is present two times this is duplicate right now what I can do is can I make a recursive call to remove seven from this sub tree from this particular sub tree can can it be done the answer is yes if I remove seven from this tree then my work will be done right now if you look carefully now seven will be a node which has either okay it will have either no children for example in this case or if it is the largest node it will not have any right child right so seven can have a left child can have a left sub tree right seven can have a left sub tree right that means if I'm recursively removing seven from this tree two two things can happen seven does not have any any child it will fall back to case number one that a node with no children so it can be easily removed I can return a null here right or seven has a left sub Tree in that case that sub tree can be returned here and it will be correct to attach it why because all these nodes they are greater than six but they are less than seven so they can be attached directly in the right of six right so seven still can be removed so this if this is the case it will handled by case number one if this is the case it will be handled by case number two that a node has one left child or right child but it it cannot have both okay so you can see largest node can never have a right child okay similarly the smallest node can never have a left child because it is a BST right if it is has a left child then it is not the smallest right so we are going right until we don't find anything on the right so seven can be replaced okay so that means in this case seven is not having any left child I want to remove this node I will make a recursive call on this left sub tree to remove seven so seven will be removed and this is how the tree structure would look like right so I hope you're able to understand new tree would look like this it will be 7 3 1 6 4 and here I have 10 14 and 13 this is how the new Tre would look like if you talk about the in ordered reversal it will be 1 3 4 6 7 10 13 14 is it correct of course it is correct is eight removed yes eight is removed from this reversal right now let us look it in into the code how this can be actually done right so I have case three where the node has two children so this can be handled by the else block so what we need to do so we need to uh so first we need to do is we need to find the max node in the left sub tree okay so I can okay I will take a temp variable node temp this is equal to root do left I can say while temp. right is not equal to null so I will move this temp towards right so temp equal to temp. right so if you are confused what we are doing suppose this is the tree 8 let's say I have uh 5 6 7 and I have some nodes here as well right I'm saying okay I want to find the largest in the left sub tree so I start a temp here so temp do WR is not null so temp goes here again temp. right is not null temp goes here now temp. right is null so what what do I do I stop so even if it is a left sub tree temp will stop at 7even right okay so we found out the node now what I need to do I need to replace the data here so I can say okay fine root. data will be replaced by temp. data the data of the temp I copy this seven here right now what I need to do I need to recursively delete the node 7 from the left sub tree can I call the remove function yes because it will either lead to case 2 or case one which I have handled right so I can say okay fine now my function is to remove the node with temp. data from the left sub tree so I can say remove root. left the node is called temp. Data I'm not I don't want to remove eight now I want to remove seven now so that is why the value is not key but it is temp. Data but after removing this something will be updated right so I'm am standing here I'm making a function call on this left sub tree this left sub tree will tell me the updated uh address of the left sub tree or the updated reference so I have to say at root. left this is equal to remove right so whatever uh is the tree after removing please tell me right so root do left this is equal to remove right so once it is done what should I do I will simply return the address of the root so this is something we will do right so I'll tell you quickly what what is happening here right okay return root we have already done at the end so no no need to do it here so we have three guesses right when we are at the node which is matching the given key that we need to delete okay we have two recursive cases which are basically helping helping us to reach a node okay so there will be a base case also right the base case would be that if node is not present so if node is not present we might end up at a value that is null right so I will show you what will be the base case now suppose I want to delete uh let's say I want to delete uh 41 right now I start with let's say 7 I say okay 41 is greater I go to 10 it is greater I go to 14 it says it must be on the right so I go here so basically the right of 14 is null if I reach a value that is null that means the node is not present so it is just like the search method where we were returning false here we will not do anything so if root becomes null at a certain point right so I can okay I'm also going to return null right so this I think makes the code complete now let us test our functionality by going to binary search tree test F okay so okay I was all doing searching earlier now I can say okay uh I will remove something and then I will display the tree okay one more thing we have to do is we cannot call the remove function directly because we have to supply the value of root so we'll uh create a rapper function let's say node uh remove key let's or let's void remove key this is the method and here we will only accept ccept the key right and from here we'll say okay let us call the remove function where we will give the actual root and the key here so now from binary search tree test we can say Okay BST do remove key and here I can give some key let's say 41 now if this is present it will get removed so I will uh give this value and let's say I want to display this tree so I have given uh this particular input so this is the tree before printing before removing then I removed 41 and this is the tree right we can experiment with uh this tree as well that we had for this tree uh the input was 8 3 10 1 6 14 4 13 and 7 let us try to play with this tree as well so I will quickly type the input so this is the tree from the diagram and uh now from this tree let's say I want to go with case one where I want to remove let's say seven I will give input as let's say seven or I can ask the user for the node to delete okay that that is also doable I will just rerun this code and I want to delete seven from this tree let's rerun it uh okay so let's say sorry this is the wrong input we have given all right so this is the input we have given and now from this input I have removed seven so you can see the seven has been removed from this tree right so that means case one is working fine now let us rerun this once again and let us discuss case two where I want to remove let's say 10 so the same input goes but I have to remove 10 so I have to rerun this code once again I will stop it and I will rerun it let's say I'm removing 10 now from this code you can see 10 has been removed that means it is working fine for case2 as well case three let's say I want to remove eight so I want to remove eight I will rerun this code and uh let's see now after removing it you can see this is the in order reversal of the tree which looks correct okay so in this code I have two fours which is okay but uh you can see8 is removed and8 was the root node of the tree right that means it is working fine for all the three cases that's about how you remove a node from a binary search tree okay if you want a small dryon we can do it once again uh let's say now you're removing it so as I discussed so what are you doing uh you had seven here right so you say Okay I want to remove it so I will I will go in my right sub tree in the left sub tree and I will try to iteratively find the largest note so it says okay three says okay temp is here temp goes here right is not tell temp goes here right then I say root. data this is the current root where I want to delete I say root do data this is equal to Temp do data so seven is copied here then I make a recursive call on this I say okay root do left this is equal to remove okay uh if I talk about in the code I'm making this uh change here uh I show you this is the remove function so I'm saying root. left this is equal to remove root dot left and temp. data so I'm not saying remove it I'm saying remove seven from this tree because s is now duplicate so I can I can say root do left should point to a new tree in which seven is removed so now I say seven I want to remove seven from here so 7 is greater than three I go here 7 is greater than six I go here so I reach finally seven if I reach seven I say return null now six right is pointing to null and I say return root so six is being returned so three refers to six this node is gone and from three I say return root so 7 now refers to this three so this is what is happening when I'm doing a recursive call for deleting seven from the I hope all those who had a doubt now it is clear and this is how removal in BST works so let us try to understand what is a hash table and how it works okay so you might be already using hash table a lot of times and it is known by different names in different languages for example in Java it is called as hashmap in Python it is called as dictionary in C++ it is called as as unordered map right so there are different names but the internals of the data structure they are same in different languages okay so hashmap in Java dictionary in Python and unordered map in C++ and in of course in other languages as well you have this data structure that is available right so the reason why we are going to study this data structure is it is very very powerful right and it is used a lot right it is used a lot right so when I'm saying it is used a lot so not just business logic so when you are uh dealing with your problem solving when you're building real software you would often require a hashmap to store data in the form of key value pairs okay so it stores information in the form of key and the value pairs but not just that we can also store key value pairs in the form of a list right why it is powerful because it allows us to do operations like insert ver I want to insert a key value pair I want to look up for a particular key right and maybe I want to delete a particular key right a key value pair so I can just give okay this is the key delete the corresponding value and the key so delete the key value pair given the key lookup means the search right I want to search for a particular key if it is present or not and if it is present what is the associated value with that particular key right so these are the three important operations associated with the hash table right and the good thing about these operations is why uh this is so popular or why this is so powerful because these operations are performed on an average in order one time so order one on average that means most of the times these operations will be performed in constant time okay so we will discuss the scenario when they're not performed in constant time but you can say Okay most of the Practical scenarios these operations would be performed in order one time by the hash table right so now let us discuss where this can be used okay so I discussed that it stores information in the form of key value pairs okay suppose you're building a uh application for a restaurant and user item user of wants to order particular item right so user says Okay I want to uh check if Dosa is available and what is the price of the Dosa the restaurant owner might instantly reply that okay the cost of the Dosa is 100 right so given this key you are telling the value in order one time okay maybe I want to order some uh coke maybe this is price at 50 maybe I want to order some noodles right this is cost costing maybe 70 right so what can happen with this menu what are the operations we might be doing on a restaurant menu right so if we are building an online menu we might might be adding a key value pair okay a new item has been added maybe a pizza has been added so you will supply okay Pizza has been added and it is associated with some object or in this case that that object is nothing but an integer object only right the cost of pza is is 250 right so I can say I want to insert a new key value pair that is doable second is I can look up now I can ask what is the price of the coke so the hashmap will tell me in order one time yes the price of the coke is 50 rupees then I can delete I can say Okay Coke is not in the stock delete Coke so it will be deleted from the table so these are the three operations that our hash table is going to support right now of course we saw that this can be used in business logic when you're building an application a hashmap can be useful data structure to use right because it provides fast lookups fast inserts and fast delete operations as well right but one major application is also in the uh language runtime right so whenever you are working with a language like Java or C++ you know uh you create certain variables you create certain classes so you say okay I'm going to create a variable uh int X and I'm going to say this is 10 right then you say okay int y this is 20 right so what happens is how these variables are stored so these variables are actually stored in the memory right X is a bucket that is storing 10 Y is a bucket that is storing 20 right but when you want to make a change you want to okay X is equal to x + 2 right so your compiler needs to know where is this x located so that I it can go to that location and change that bucket now suppose this bucket is at some address ABC right let's say abc2 0 right this is some address written in a hexad decimal format right so the compiler maintains a symbol table for all the variables and the classes that you are going to all the objects that you are going to create so there is a symbol table right maintained by the compiler right so this symbol table will tell that okay X is a bucket which is present at this location ABC 20 right now when you do this Operation X is equal to x + 2 so I'll just scroll up a little bit when you're doing this Operation X is = x + 2 so the compiler will look at the symbol table where is X located it will go to that location and it will make the change right similarly Y is located at some location maybe 11 462 right and maybe right so 11 1462 this is some other location for y so y will it will again look up at the symbol table where is y located it will go to this location and it will make the change in the Y right similarly if you create some objects let's say dog D this is equal to new dog so this dog object is created at some location in the Heap right so similarly your D will be mapped with some address right now what is your symbol table a symbol table is also of a form of a hash table right it is also a form of a hash table right that your compiler is maintaining and it is called as symbol table right similarly when you have classes and objects right so you say Okay I want to create a new class called dog a dog has certain properties right let's say it has a certain name it has a certain breed it has a certain method what is happening so you are also you're able to map dog with various uh attributes and various methods right so all these features right they they are powered by the language runtime and language runtime might be is actually using hash table internally so that you can uh do lookups very very fast okay if this functionality is slow your language will become slow so that is another application of H table it is used in the internals of the language so I hope you got a good introduction about H table now we will jump into the internals of the H table so let us talk about has table internals right so what is exactly a has table from inside basically it is nothing but it's a container okay it's it's like in the simple form it can be an array as well okay of some size right so basically whatever data we are given we have to map this data with a certain index in this array right so suppose I'm getting Dosa right so the first step of a hash table is that we have to Hash the key value right we have to produce an integer location for a given key now given key in this case I'm taking it of the string type but it can be any object right it can be student it can be book so for that particular type of object you need to tell the has function how the that integer value will be computed right so right now I'm assuming that there is a has function which is going to accept some key let's say Dosa and it is going to produce an integer location right so maybe that integer location is 0 1 2 3 4 5 6 and so on right maybe Dosa will get stored here and the value will also get stored here right I got noodles so noodles will go also go into this and maybe I get a location six so maybe noodles get stored here and 150 get stored here right in the same location right so what is this has function doing hash function is taking input a key and it is producing a integer location in the array right now you might have some questions right how big this array should be right now if I have six keys and if if I have six uh let's say six size of the array right and I have 12 Keys then of course I cannot store 12 keys in this array right so it's going to cause problems so we will look at how to handle this very soon right this is not the completely correct imp mation we are going to discuss it step by step right so the idea of hash function is that it is going to produce unique integer location for every key but it is also possible that for two different keys they get mapped with the same location for example if I get something like Coke and this since this is a mathematical function it might compute similar location as well right so it might say Okay C should also go here right so this is called as a collision we will discuss how do we handle Collision right so maybe 200 something but the idea is how big this array should be right so one thing we need to notice that this if it is producing an integer then integer can take any value right so integer can be in the range maybe 0 to 10 it could be in the range 0 to 100 right it could be even in the range of 0 to int Max right so that means like if I talk about every possible integer that can be generated this range can be int Max as well right but do I really need to create this big array okay int Max is approximately 10 power 9 uh elements right if I talk about how much space this array will take in the physical memory this will come out around 16 GB right so will you need 16 GB of an array right or can you create this big array the answer is definitely not we cannot create this big array because this amount of continuous memory might not be available and secondly suppose you have created this big array and you have only 1,000 keys in your key value pairs in your data set right then you are allocating space for 10 power 9 elements and you just need space for 10 power 3 elements that means you're doing lot of uh space wastage which is not a good option right then how big this array should be it should be roughly of the order of number of keys that you are you want to insert right so you if you have an idea okay I want to insert somewhere around 1,000 Keys then it is good enough this array should have around 1,000 buckets inside it right or if you want to insert maybe around 500 Keys it should be of the order this much right so what I'm going to say that table size should be of the order number of key value pairs that you're going to expect right now it might happen that you expected 500 keys but in practice since the data was Dynamic 700 Keys came right so we will also look at techniques to grow this table dynamically during the insertion process right so that is something we are going to study right what happens if there is a collision how do we grow the table how do we initialize the table so all these concept we are going to see next so let's begin starting with the hash function we will talk about insertion searching and deletion in the hash table so we are discussing har function right so as I discussed harh function can accept key okay input is a key it can be of any any it can be any type of object forever case I'm just assuming it to be a string and I want a integer value in some range okay in some range that is from 0 to n minus one where n is the size of the table right so n is the size of the table that I implementing right so for example just to keep things simple I'm going to assume that I have a small table where the size of the table is just 7 so 0 1 2 3 4 5 and six so indexing is from 0 to n minus one so I have this array right or I call it as table as well so this is having a table size of seven right now I have a hash function which knows how do I convert a given string into into a numeric value so suppose I'm getting a key like Dosa comma 100 right the goal is to generate a integer map it with a integer right and that value should not be random it should be same always so whenever you ask Dosa you have to tell me at what location this Dosa is present right so goal is to convert this Dosa into a number in the range 0 to six right how do I do it one simple way could be that I iterate over the asky values of Dosa add them and since this addition will produce a number much larger than seven okay for example uh your capital a right it I think it has a ask value of 65 B is 66 C is 67 so D will be 68 right so similarly here you will have certain values 68 plus something plus something plus 65 this is going to produce a large integer right maybe of the order 200 to 300 right but I want to map it in the range 0 to 6 right so what I will do how do I reduce a bigger range which is some larger range into a smaller range right I can say okay fine this can be easily achieved by using a mod operator right so I can say mod with n so I can take a mod with n so let us assume that this mod gives us an answer that is four so that will be called as a hash index okay so basically the index in the table produced by hashing theh index is let's say four so that means Dosa will go at this particular index and this value will be stored at this place right now the question is what should I do maybe I am getting another key right in which the result is also four right the result is also four so can this happen the answer is yes so I can say okay I have maybe Coke and maybe 150 right I do not know I add the letters of coke right and I take a mod with n right now mod with n can produce the same result for many numbers right so maybe this also leads to four what happened here right what happened here C is also fighting for the same position that means I also want to store Coke here right now this thing is called as a collision right we have space for only one key value pair but we want to store maybe two or more key value pairs at that particular location right this is something called as a collision right so what happens right so what is a collision a collision is a scenario in which basically two key value pairs two or more key value pairs they get mapped with the same bucket mapped with the same bucket so this what does this mean right can we avoid collisions the answer is no can we reduce collisions the answer is yes right we will talk talk about both the things right so in order to reduce collisions right what we need is we need a good hash function so we will work on both the fronts right so collisions should be it they cannot be avoided right so how irrespective of how good a hash function is collisions cannot be avoided but they need to be handled right so cannot avoid collisions right okay but I can reduce the chances of collisions but chances of collisions can be reduced by using a good hash function right but chances of collisions can be reduced using a good hash function right using a good hash function now how do we design a good hash function we will discuss by taking an example of string right and secondly since you cannot avoid collisions so even if the Collision is happening you need need a way to handle that Collision right so they still need to be handled so we need something called as a collision handling scheme right Collision handling scheme this is something we will discuss very shortly right now there are two important things here one is what is a good hash function second is a good second is we need a good Collision handling scheme so first good hash function will reduce the chances of collision but they still can happen so if the Collision is still happening we need to handle it using Collision handling scheme so let us discuss what is a how do we design a good hash function and how do we design a collision handling scheme next so let us discuss the properties of a good hash function right so I am going to discuss the properties of a good hash function right so basically a good hash function should have two properties first it should ensure a more of a uniform distribution okay it should ensure more uniform distribution right and secondly it should be fast to compute right so that means we do not spend a lot of time in Computing the hash index itself right for example in our case what we were taking I will take examples of two hash functions okay so let's say example number one in which I'm simply adding the ask values and taking a mod with the table size so I'm saying fine uh I will add Dosa D + o plus S Plus a and I will take a mod with the table size right now is is this function fast to compute yes because I just need to iterate on the uh letters of the key right so when when I'm talking about I'm going to insert many key value pairs so what is n n is the number of key value pairs okay so key 1 value one key2 value two right key3 value three I want to insert many key value pairs so my hash index does not depend upon the value n but it depends upon how big my key is so in general the key would be small length so we can assume that okay if it is a name of a person and the phone number as the value the key would be maybe maximum 50 characters or 100 characters so yes in this case this is a fast hash function right but if this hash function is going to minimize the chances of collisions maybe not right why because if I talk about English language right in English lot of words they are anagrams that means uh lot of words have same set of letters in them for example let's say the word is tab right so it is made up of T A and B and if you add you will get certain some right but if I talk about the word b right it is also made up of same letter s so in this case we are sure that these two are going to collide because our hash function is doing a very simple sum right so in maybe of course there could be other words also maybe the word is mango right now it is possible that even if you do a mod with table size you might end up at the same Index right so we do not know so in this case it is of course difficult uh to tell whether the Collision will happen or not but it may still happen right but here we are sure that a collision will happen right so many words in English they will have such a scenario right what we can do is instead of doing a simple addition right we can do a weighted addition right so this is like a simple addition of ask values we are doing right so a better way would be that you do not do a simple addition in your hash function but you do a weighted addition right so example two of building a hash function would be that you do some weighted addition right so that means you are going to multiply each letters ask a value with some weight right so for example I choose a weight maybe generally it is a prime number right so maybe I choose a weight as let's say 31 right or 29 right what I can say that fine I will multiply Dosa with powers of two so let's say the weight is 29 so 29 power 0 that is 1 into D + 29 power 1 into o + 21 s into s + 21 s into a and then I take a mod with table size right what I'm trying to claim is now if you do it for B and tab it is less likely that you will have a collision right so I'm saying you multiply uh 29 power 0 which is 1 this is 29 and this is 29 squ right and then you like it's a weighted addition again 1 + 29 into a + 29 squ into B and of course mod with the table size mod with the table size right now earlier we were sure that these two values are will surely Collide now we can okay the chances of the collisions are less okay so there is a less chance of collision right these are the factors that you can keep in mind that okay if I'm building a has function function can I modify it some way so that it reduces the chances of collision and it is fast to compute right so here also it is fast to compute right maybe if you have a string in which the length is too big maybe you can restrict that okay I will consider only the first 10 letters of the string for this weighted addition that can also be done right so that will even make the function bit more faster right so if you are thinking that the keys are too too long you can restrict to maybe the first 10 letters or maybe something like that right so now we have a good hash function which is the second one the second one is obviously better we are doing weighted addition so it is going to reduce uh the chances of collision right but a collision can still happen right so how do we handle if still a collision happens so here comes a collision handling scheme right so let us discuss about Collision handling scheme now so you have seen how do we design a hash function now we need to discuss how how do we design a collision handling scheme right so collisions can still happen we need to handle them right so let us talk about how do we design a collision handling scheme right Collision handling scheme right so there are actually multiple schemes but I will particular particularly discuss one scheme right so in this case what we can do we can do something called as separate chaining so we are going to discuss only one scheme uh there are other probing techniques as well right so I will discuss separate chaining right so this is one of the most popularly and widely used schemes in implementing a hash table right now I'll just copy the diagram that we have seen earlier this is the diagram right so let me just copy it uh okay so here we go the idea is that if a collision happens what should we do right that is what needs to be addressed right that we are going to address using a technique called as separate chaining so suppose we got Dosa and it G get mapped with index 4 so what we will do we will not store it directly inside this bucket but instead every time we get a particular bucket mapped with Dosa we will start a chain from there right so what what is a chain a chain is like a link list so it's exactly a list right that means each bucket is actually going to hold the address of the first note of the list right so for for for example I'm going to store Dosa comma 100 here right now suppose I got Coke comma 150 the coke goes into the hash function and maybe this time I get two so I will start a chain from Two and Coke will go here Coke comma 150 it will be stored here right now suppose I got something like noodles okay and noodles is going to have a value let's say 120 Now Noodles if it goes to the hatch function let us assume the hash function computes the index 4 right at index 4 we already have Dosa so what we will do we'll also try to store noodles at this index how so we can okay we can add noodles to this link list now suppose this is some address let's say this is uh 150 this is 270 right so this is storing 270 this is storing 150 so each array bucket is actually storing the head of the link list right now how we can insert noodles in this chain in order one time it's pretty easy so you can okay I will create a bucket called noodles let's say this bucket is uh this node is created so I'll create this node and with the given key value pair right so it's a new node with the given key value pair right now in this new node what should I do like how do I add this node in this link list right so I can say okay this is some array right so or this is some table I can say array of uh and let us also compute the index so I can say index where I want to store this is given by the as function of the given key right so I get to know the index also so add this index I need to store noodles so one thing I can do is either I can insert at head or I can do insert at tail since I'm not maintaining the tail of the link list explicitly but you can maintain if you want I can also do a direct insertion at the head right so that means we can say okay uh this node 4 will refer to Noodles and noodles will connect here so right now this is connected here so what I can do I can ask noodles to connect with Dosa right so I can say n do next so in every note I'm also going to have next field right so that I can actually form a chain just like a link list so every node is going to have a next field so I can say okay you should connect here right so I can say end. nextt should be equal to array of index array of index is storing 150 so that 150 will be copied here right and now I can update array of index to point to this note so I can say array of index should should point to n so basically I'm changing this connection like this n is what whatever it is this will be now referring to this note if you look carefully we have actually formed a chain right so this is let's say this is some address let's say 480 this is now storing 480 right so you can see we are actually forming a chain right we are actually forming a chain so this is exactly how the insertion is going to work and this is the code to insert right do you think will it work in order one time absolutely yes this insertion will be always order one right because we are inserting something at the head of the link list irrespective of the chain length the insertion will be always order one right so I hope you have understood insertion but is it done the answer is no we are not yet complete right we have to still discuss One More Concept but that concept I will discuss after discussing searching okay so this is still not complete so this is insertion part one right okay so there is something more to the insertion that is going to come up right let us discuss searching how we can actually search in such a scenario right so we are discussing searching now right so now what is the purpose of searching the purpose of the searching is that given a key I want to look up for the value of that particular key right if I ask okay I want to know what is the price of Dosa how I will find it so first of all Dosa is a key this is given as input so Dosa will go to the hash function the hash function will generate a index where this Dosa can be present in this case hash function gives me a index 4 that means now at index 4 I actually have a chain right if I write it little more clearly so this chain looks like this I have noodles and which is like 120 and I have Dosa which is part of the chain and this price is 100 right and of course the next is null now I have to iterate on this chain to check if this chain can contain Dosa or not so if I iterate on this chain I will find Dosa at this particular position and once I find Dosa I can return the value that is 100 100 right that is how searching is going to be performed so we first find the bucket where the hash function is telling me okay in this bucket you have to check and in this chain Dosa can be present Dosa may not be present right now you might ask okay if you have to iterate the chain then what is the time complexity of this operation my answer is it will be order of chain length right now how do we figure out chain length Okay can this chain length become very large the answer is yes it can become very large right so the key to successful search operation is that we have to ensure that this chain length is very small okay so we have to ensure that chain length is very small right maybe two to three nodes or maybe three to four nodes right and this is achieved using a concept called as rehashing and load Vector so we will discuss this concept ensure that the chain length is very small so if the chain length is very small we can say okay on an average this operation will be order one maybe I say okay the chain will have only three nodes two nodes right but now let us discuss how this chain length will be decided right how this chain length will be actually decided right now suppose I have a hash table where I have seven nodes only right and I keep on inserting data right if I okay my table is 7 and I insert 70 key value pairs inside it right what will be the average chain length if I talk about the average chain length in this case I can okay I have done 17 insertions across seven buckets so it will be 70 upon 7 that is 10 10 is a big number I do not want to keep this much chain length right so this quantity that I have just written here it is actually called as load Factor so load factor is a technical term for the average chain length Okay so how do we compute load Factor so we say Okay total number of key value pairs that have been inserted into the har table the total key value pairs I have inserted upon my table size or in other words you can say current size the number of key value pairs that have been inserted upon table size that could be another way of writing it right so I write this one looks a little more better to me so in the current scenario if you have 70 key value pairs inserted in seven buckets this is 10 it is actually huge it's bad right so what do we need to ensure we need to ensure that our load Factor does not exceed a certain threshold right so in some languages it is one and some languages it is 7 whatever is the case we need to ensure that it does not exceeds the threshold value of let's say 0.75 right now what does it mean if I have let's say say 10 buckets and I insert seven key value pairs so what will be the load Factor it will be 7 that means on an average every chain has less than one node right so that also means that my table size will be slightly bigger than the number of keys I want to put so if I want to put let's say 100 Keys then my table size could be of the order 150 right something of that sort right so that is something we need to ensure right now how do we ensure that our table grows dynamically as the data in the table is increasing right one thing you can do is if you have an idea that okay I'm going to insert somewhere around 70 gys you can in initialize your table size um around 100 okay so generally it is a prime number right so if it could be like 103 something of that sort right or 107 right so you need to ensure that if it is a prime number it it ensures uh slightly better distribution right of the keys right so what I'm going to do I'm going to do insertions and I'm going to show you how the load factor is going to change and what happens if the load Factor exceeds the certain threshold so going back I'm going to discuss the insertion logic once again and now apart from doing the insertion in the chain we will also discuss the concept of rehashing and how how do we increase the table size dynamically let us talk about rehashing uh according to the load Factor let us talk about rehashing right so rehashing is a mechanism that is going to help us expand the table size and bring down the load Factor let us try to understand insertion and the rehashing procedure with the example okay for example now suppose I have a table which is of size 7 0 1 1 2 3 4 5 6 right now I'm going to insert certain key value pairs inside it and I will calculate the load Factor during the insertion process for example I insert a right so the locations are decided by the harh index so now the load Factor will be 1 upon 7 which is .14 right which is well below the threshold okay so our threshold is let's say 75 so it is below the threshold I will not do anything that means on an average every bucket has1 14 elements inside it right if I okay I will insert B maybe it goes here now my load factor is 2x 7 which is about 28 right then I insert C maybe a collision happens and C goes here but in on an average each bucket has now 42 elements so it is 3x 7 that is my load Factor right and maybe I insert d so it's going to be 4X 7 right so it's going to be around 56 right so it's it's around. 57 on the calculator and similarly if I insert let's say e maybe e goes here right so it is 5X 7 it's going to be around 71 it is still below the threshold then if I insert the Sixth Element maybe if it goes here and it collides right so it's going to be 6x 7 which is around 85 now at this point what do I see I see that the load Factor right has reached 85 that means it is close to one that means on an average every bucket has around one element each right it is the time to grow the table right so what is a table this is my table I want to grow this table I want to make it bigger right what I will do I will create a new table or a new array right which is approximately double of the given given size right so maybe this table size was seven so I generally look for a table size which is a prime number right so this new table size could be let's say 7 into 2 is 14 what is the nearest prime number close to 14 it could be 13 also it could be 17 Also let's say this is 17 right so I'm taking the next biggest prime number right now what I will do this table is empty right this table is empty and my goal is to remove all the entries from this hash table and put it into this hash table now you might ask why can't we uh use this hash table right the reason being um your table size has changed and your hash index that we saw right so we saw it was a weighted sum okay it was a weighted sum of um the letters of the string taken with taken mod with the table size now table size has changed so my hashing will also change that means if I now insert at a earlier it was going at position one it might go at certain some other position so a might go here C might go here B might go here and D might go here and since the number of buckets they have also increased that means my distribution uh will also change and it is possible that the number of collisions that are happening they might reduce right so what I have to do I have to do rehashing so this is what rehashing is so we have created a table of size double the capacity right and we we iterated over every chain in the origal table every node we added again into the har table once we are done what we will do we will delete this from the memory this will be cleared off and now my hash table is going to refer to this table right now in this table if I compute the load Factor okay if I compute the load Factor now this will be much much lower than 85 why because it was now 6x 7 now this will be 6 by 17 so if I calculate this value 6 upon 17 this value comes out to be35 35 right so I can keep on adding more entries into this table right again if again it exceeds the uh threshold what I will do I will execute rehashing once again right now what I'm trying to say is that this rehashing is a special mechanism that will be triggered from the insert method when my load Factor exceeds the certain threshold right so it will be some condition like if my load Factor exceeds the certain threshold I will have to call the rehash method from the insert function right so this is something I will show you in the code as well right but I hope you're understanding the reason of rehashing right what is the importance of rehashing so if you have done rehashing right can I say the average chain length will be always less than one that means on an average no bucket has more than one note right so it might happen that some buckets may have zero nodes some buckets might may have two or three nodes but I'm going to say this average chain length will be a very small number and it it is it can be treated as constant so that is why we say that our search is order one on average right order one on average right that is what what my search operation will be right now another Point what is the complexity of rehashing right so of course we have to iterate on the entire table and put all the keys into the new table so it it is going to take order of end time right then how my insertion can be order of one so if you look carefully this rehashing is not happening again and again so it is happening once in a while so you you inserted this element we took order one time this element it took order one time order one time order one time order one time and at this point we saw that load Vector is increasing and it is going to trigger the rehash function so it is going to hit order of end time right so can I say that for six elements I spended constant time but for one element I spent order end time right so if I talk about on average how much time I spent on each element so again if I take an average it it's like a worst case right in 1 six is like a worst case worst case yes it can go order of n but on an average we spending order of one time in doing an insertion right you might ask how can I bring down the time of rehashing so if you know that okay I'm going to insert about 500 keys so you make sure in the beginning that your table size is big enough so that rehashing is never triggered okay or it it is triggered very very rare right so so the correct way to do it is initialize a large enough table okay it should not be too big that you're using too much of memory so you have to make a balance between effective memory memory utilization so you should know from the historic data okay how how big table should be sufficient so if you're storing phone contacts you know in general people might have 500 to 1,000 contacts so you can initialize a table of the size around 1,000 right so it is just large enough just large enough so that rehashing is never triggered right or it is triggered maybe just once right it is never triggered right so this is something we can do right to make sure that almost every insertion is order one right so I hope you understood the concept of rehashing and I'll show you in the code as well let us discuss the implementation of has table so I'm using C++ but you can also use Java or any other language to map the same functionality in in your own language right so first of all I discussed that har table is a table and in this table is going to uh contain the address of it it is going to contain the head of the link list so link list is made up of nodes so node will store Key a value and the next field right so that is what I've defined in the node structure so I'm using templated classes so it's like gen in Java and templates in C++ these templates allow me to uh hold data of any T type in my note right for keeping things little simple I'm assuming that my key is always a string but it can be of other data types as well for that also you need to use templated classes and you need to provide a way to convert that data type into a hash index value right so for now I'm dealing with strings only but I'm saying the value can be of any type it could be in it could be string it could be float because we are not Computing any hash on the value we are just going to store that value as it is and third thing is the next property that is of the node right whenever I initialize the node I set the value of key I set the value which is the value and by default I set the next as null right and this is my Constructor and if I want to delete a node so this deletion will happen if we I'm deleting a certain value or I'm doing rehashing and I want to delete some data right this is actually a Destructor which says that if next is not null delete next so basically it is a recursive way of deleting the node right so that means if I uh make a call at this point it says okay if I'm going to delete this node and if the next is not n first delete it if the next is not null first delete it so it's a way in which I can delete the entire chain at once right so this is something um which you can also like it's uh it can be implemented in other way also right so you might not necessarily do the same thing but in my case I'm doing it I will tell you why right so uh that is about the node Constructor and now let us come to the has table class right what I have done I am actually create keeping a d Dynamic array called table so table is referring to an array right you might ask why St star because see uh each each bucket in this array is going to hold an address of the node so it is of the type node Star right and what is table table is a pointer to an array of pointers right because each bucket is going to point to the head of the link list so each bucket is of the type node star hence the type of the table is node star star right it is going to be a dynamic array refering to an array of pointers okay so I have a table which is not initialized at the moment I have current size I have table size so current size will be zero in the beginning so I will show you uh the Constructor for this yeah this is the Constructor so whenever a new hash table is created right so current size is set to zero table size is set to default size I'm taking a parameter with a default value of seven so if user gives me let's say I want a table size of 107 it will be 107 but if nothing is given by default I'm taking it very small and it is seven right then I initialize my table array so table is an array that points to an array of node star and this is of size table size these many buckets I have initialized and by default in every bucket I'm putting a value null right so this is null this is null this is null right so instead of having garbage it is better to initialize everything with null that is how the hash table has been initialized I hope you don't have any doubts till now now comes the interesting method that is insert right now if I want to insert something right so I my table is ready so table is here my hash function is also ready okay I'll show you the hash function let's I want to insert Dosa comma 100 what do I do I will show you the hash function let us understand the insert so my key that is Dosa it goes through the hash function and I get an index so maybe the index is four right at this index what do I do I will create a new node so I say okay there is a new node called n which is Dosa comma 100 in this line I do this work and I say end. next this is equal to table of index so table and this is index n. next will point to whatever this is pointing to so it is currently pointing to null the next starts pointing to null right then I said table of index is equal to n so this index is going to hold the value n so n is let's say 248 that is the address of this node so it is going to store 248 right so this is how this node gets attached to the beginning of the table current size Plus+ so current size becomes one then I compute load Factor so which is 1 upon 7 is it greater than 7 the answer is no right so if it becomes then I will trigger rehash I will show reh rehash method also right so this is about the insert functionality right so I hope you're getting it let's say I'm inserting one more node which at the index 4 so I just want to show you how the chaining is going to work let's say I inserted noodles and for noodles also I got an index 4 so noodles comma 120 I created a new node called n right then I said n. next is equal to table of index table of index is storing this value so noodles starts pointing to this value right and table of index is equal to n so this connection is broken and this starts pointing to this no so you can see in a way we are forming a chain in which noodles is getting inserted at the head of the link list right this is nothing but insertion at the head of the link list current size Plus+ so current size is two load Vector is 2x 7 which is again less than 7 so hence I do not trigger rehash at this moment right I hope you insert you understood the insert method next I want to show you the hash function that I've used here the hash function I've made it as a private so what I'm doing I'm simply multiplying the numbers let's say the word is Dosa what I'm doing I'm iterating over this and I'm multiplying it with powers of 29 so it is one so initially it is Multiplied with one then in the next iteration power becomes into 29 into 29 next time it becomes power becomes again power into 29 so it gets multiplied with 29 squ and again it becomes 29 CU right so in order to avoid overflow I'm doing a percentage mod at each step because if you take mod at the last uh or if you take mod at each step we know this is the property of mod so mod can be taken at each step as well so this is a better thing to do because it helps us to avoid overflow right I'm taking a mod with power also and I'm taking the mod in the answer also so I get an index which is in the range 0 to table size minus one because I'm doing a mod with table size so I hope you understood the harh function as well right now what I need to do is I need to understand the rehash method right so if we understand the rehash method our insertion will be complete so I have written a rehash method as well which is actually a private method as well so what I'm doing in my rehash method that suppose I have a old table like the actual table in this I have inserted some keys let's say a b is there C and D is there what do I do I say okay old table is going to point to table so this was my table now old table is pointing to this table I create a new table okay which is almost double of the previous size + one I'm just making it as a odd number instead of making it as a prime number I'm saying this is my table now which is also the data member of the class right so what do I do I initialize it with null so all these values are set to null and then what I do I copy elements from the old table so I iterate over the old table and how do I do do the work let me show you so I do do it like this I take a temp variable which is the ith row so temp starts from here okay okay temp is referring to the head of the link list and while temp is not null so I copy the key I copy the value so I say okay give me this key value pair and I call the insert method so insert method We Know by default it acts on the table which is the data member of the class it is going to insert automatically in the new table right and temp goes as next so temp comes to this node again I copy b i and insert it in the new table right so once it is done I make a Destructor call if old table of I is not null delete all table of I so in Java there is a concept of garbage collection but in C++ we have to use explicitly we have to invoke uh the destruction of this this entire link list by saying delete old table of I so I initiate a Destructor call from here which makes a call to a a is being it being a recursive Destructor a makes a call to B this way this entire row is deleted right and then I go to the next row so my ey is incre increasing so I go to this row this row this row this row this row I do the same work and all the nodes are inserted in the new table and finally I say okay I want to delete the array that is old table so I also want to clear up this memory I say delete old table this old table is gone and since it is a local variable this is also destroyed right so till now you have seen the insert functionality and we discuss that uh the function rehash will be triggered from the insert whenever load Vector exceeds the threshold okay so we basically double the table size here right now let us talk about searching a little bit how do we actually do searching in a harsh table so searching is pretty easy so if you have a hash table right and you want to search for a certain key let's say Dosa so that key will go through the hash function the has function will tell you the bucket so maybe this is the index of the bucket and in in this bucket there might be a chain in which Dosa could be one of the item right so maybe this is some X item some y item some Z Item so you need to iterate on this chain linearly right so I start temp from this node while temp is not n while I do not hit the end of the chain I compare is the key of this node matches with the given key if I'm that I'm searching so if that happens I return the value otherwise I go to the next node if I hit end of the chain that means I did not found the key so I return null in that case right this is how searching is done right so on an average what we are saying that this chain length is so small right because of the rehashing and the load factor that we are maintaining right so we can say okay iterating over a very small link list will take order one time on average okay so we are not talking about the worst case a worst case scenario might be like this uh a single bucket has all the nend nodes inside it right so B basically chain length is of the order n but this is a very less likely scenario because uh this can be only possible if your har function is too too bad it is producing the same bucket for many different types of keys okay in general it's not going to happen so that is why we say on average it's going to be order one most of the times right so I hope you have understood the search functionality as well right on a similar lines you you might have to do erray as well you might want to delete a particular key as well right now how you have to do it now the this is pretty simple if you know how to search then you can also know how to delete right so suppose I want to delete a key that is y what I will do I will pass y to the hash function it will give me the index I'll find this link list now the problem boils down to deleting this node from the link list now you have to handle these cases this node could be the last node in the link list it could be middle of the link list it could be beginning of the link list right so if you know deletion in a link list you can easily handle the code to erase a particular key value pair from from the hashmap as well so let us talk about graph the graph is a network like data structure consisting of nodes and edges so it is a data structure that means it is able to hold data and the data is in the form of a network okay and consisting of nodes and edges so if I look at this figure all these circles they represent a node and all these lines they are representing a connection between these two nodes for example this Edge is connecting node 4 and 25 so can we think of any real life example where the data might have connections in between certain objects of course yes if we talk about cities then cities are connected with each other through connections which we call as roads if you talk about a social media graph for example this is person a and he's connected with a person b and a is also connected with a c so we say B and C they are friends of a or a and B are connected A and C are connected if I talk about uh this person D is it connected to a we say no the person a is not connected with D or D is not connected with a because there is no direct Edge in between them so if I add a edge they also become direct connections so there can be many many applications in real life where graphs can play an important role so let us try to understand the application first then we will dive deeper into the implementation and coding so graphs as I said they are used in many real life applications and they represent a network of nodes such a network of nodes can be a network of cities a network of places landmarks anything it can also be an electrical circuit when you use when you use your Mobile phones it has something called as a a circuit okay it has a a motherboard on which you have certain elements certain small small embedded systems on it and there is a wire connecting these elements so it is possible that we want to find out the most optimal route for the wire so that we can reduce the cost okay because it is a copper wiring it can be expensive it can be a graph algorithm can be used here to minimize the total length of the wire that can be used to connect all the components in this circuit and of course social media networks we have just discussed that Facebook Twitter LinkedIn all these networks they can represent graphs so let us go into the applications in little more detail the first example is an example of shortest paths we often use apps like Google Maps Uber Ola and many other apps to compute to in our daily life okay so these apps they try to figure out what is the shortest path between the set of nodes that are there and should I go from this route or should I go from this route if you want to do such a calculation okay if you want to go from source to a destination then what path would be best can be easily devised using a shortest path algorithm known as D's shortest path algorithm we will discuss that algorithm in this series then of course if you want to book flights okay you want to say okay I have to go to this region maybe there is a flight which cost 80 and there is a flight which cost 20 should I take this flight or should I take these three flights maybe they are cheaper but they are taking more time so there might be trade-offs again you have to look at what you want what is your requirement do you want to optimize for time or do you want to optimize for the total cost of travel the social media networks I have discussed so I will give you one more example in some networks when you connect with a person for example Facebook if a and b are friends then this connection is biral that means a is connected with b b is connected with a but in some other networks this connection is having a direction for example on Twitter if a follows B it does not mean b is also following a so these edges they can be biral or they can be one directional so we call such a graph as a directed graph or directed edges okay so this graph has directed edges because a is following C and B but B is not following this so in such a case this is called as a directed Edge and in example of Facebook it is called as a undirected edge because there is no fixed direction if a and b are friends then B is a friend of a and a is also a friend of B right now these kind of representations the graph like representation is important to build algorithms if you want to find mutual friends if you want to generate news feed for a it will see the post from B and C if B is following someone then this person's post will not be visible to a all these algorithms require graph like representation of the objects involved then there is also something called as shortest round trip if you think of a traveling if you think of something called as uh a school man okay what is the purpose of school van it will start from school and it will drop all the children on the way and it will come back to its location so in this case what is happening we are doing a cyclic tour we are coming to The Source by covering all the points in the city where we need to drop the children now it is possible that multiple Roots can be devised but we want to devise a root which cost minimum so such root design can be used in for Amazon delivery Vans for school Vans and this is a very famous problem in graphs called as traveling salesman problem we will also discuss this problem in the coming series let us talk about one more application so when you are installing software you might have seen that the software is installing list of dependencies in a certain order for example you have to install a software X for X you need something called as let's say uh c c is dependent upon something called as b b is dependent upon a and there is something called as d x is dependent upon D and D is also dependent upon a and b right now in such a scenario if I have to install the dependencies what is the first thing I will install of course I will install a if I install a then B and D they do not have any dependency so either I can go with b or I can go with d so I can install B and D if I have installed B and D then X has only one dependency that is C so I can install C and then I can install X so if I install the dependences in this order right my software will be installed correctly so this kind of a graph it is called as dependency graph and it is an example of a directed a cyclic graph that means there is no cycle it is directed and from this graph we need to figure out what is the correct order of installation of software right it is often used while installing software on on systems on servers on when you're installing libraries and modules they follow this particular order and this dependency graph can be easily created using a graph algorithm called as topological sorting we will learn about this algorithm in the coming series of videos okay so that is another application of graph so let us talk about one more application that is routing algorithms so Bellman Ford is a very popular graph algorithm that is also used in finding uh shortest paths this algorithm is also used in uh routing algorithms so when you so you know the world has lot lot of routers right and these routers are continuously exchanging data packets so which data packet should go there and what is the shortest time in which it can reach to the desired location all this routing is done using a distributed version of Balman Ford algorithm which is again a very interesting algorithm in itself so let us talk about one more application so if some of you have done machine learning then you know in deep learning the Deep learning models they do gradient computation which is a important step in training of the machine learning models okay so this these gradients are used in Back propagation to adist the model parameters and the way these libraries like tensor flow py torch they have buil bu they build a computation graph of these gradients so that the computation can be optimized so you do not need to worry about how how to construct the graph the libraries like tensorflow pytorch they automatically do it for you again this is inspired from the idea of graphs itself and in traditional computer vision what happened image segmentation algorithms were used which were based upon the concept of network flow which is again a graph based algorithm so if you do not know what is image segmentation so image segmentation is basically extracting out uh objects from an image it's like drawing a boundary on an object that is like one one entity in case of this example the car is one object the building is another object this foot path is another object the road is another object so this these kind of algorithms are often used in self-driven cars but in today's world we have deep learning techniques for image segmentation but the traditional way of doing this segmentation was based upon a graph algorithm called Network flow again let's do one more application in WebCrawler so basically when you want to build a web crawler for example you want to crawl amazon.com and you want to scrap the entire website so when you go to amazon.com what happens you load the code the code is loaded in the browser so in the code you will see it it there are lot of products and with each product there is a hyperlink you want to go and scrap all those products so what do you do you you build a web Scrapper that reads these links adds them into Q maybe this is some TV button okay so you go to that page it opens up and then again there are many many links here so you can also use these links crawl further right so it's like a three veral so web crawlers use bread for search to crawl the web so if you have built a web Scrapper you would have know that you often do a BFS like thing and you Traverse the Dom tree and a tree is also a graph okay a tree does not contain a cycle but it is also a graph example so let us do one more application nowadays we also have databases that are inspired from the idea of graphs one such database is called neo4j so these kind of databases are used in recommendation engines fraud detection and many AI based applications apart from it there are lot of other applications of graphs such as in linguistics social sciences biology Neuroscience Atomic and molecular structure computer processing flood fill and more so what is this flood fill this is an interesting application I often cover in my course when you use a paint bucket tool like this and you drop it in an object it automatically fills the color till it hits the boundary like you you can see here right so this again is an example of graph and this Matrix is an example of a 2d implicit it's a 2d Matrix which is representing a implicit graph so we will discuss about what is an implicit graph and how do we build algorithms on implicit graph that will be covered as well so that's about the applications next we will dive into the more technical Concepts and understand how a graph can actually be created and stored inside the memory next thing I want to talk about in graphs is classification of graphs though we have talked briefly about weighted and unweighted graphs let us try to understand with some more examples basically there are two criteria for classifying graphs one is weight of edges there can be graphs in which there is no weight associated with the edge that means each Edge is treated equally each has a unit cost okay you can say okay it is a unweighted graph such a graph is called called as unweighted graph but it can be scenario for example if you talk about roads so each Road might have a length or it might have a time to travel from B to Z right so some kind of weight or maybe some kind of fuel cost so we can say that in such a scenario each Edge is having a different weight and we need to store that weight as well okay so earlier if I'm representing a edge as a comma b in a unweighted graph now I have to represent Edge as a comma B comma 10 that means the time to travel from A to B or the edge weight from A to B so this is a case of weighted graph right that means in the implementation also we will have to store this weight associated with the each Edge and then there is direction of edges now there can be scenarios where the edges are not having any specific direction for example talk talk about Facebook friends if a and b are connected they are connected that means a is a friend of b b is a friend of a but edges can have a certain direction for example a Twitter graph so if a is following B does not mean that b is also following a so in this case Edge will have a certain direction that means a is following b and a is following C and B is following C something like this this is an example of a directed graph and weight so this is an example of undirected graph let us look at some more examples okay so we have discussed graphs whose edges or paths can have values associated with them they will be called as weighted graphs Ed Edge value can represent either the weight or some kind of cost or length of that path for example in roads it might be the distance in kilometers so directed undirected graph we have already discussed graph edges can have specific Direction attached to them they're called as directed graphs okay now in such a scenario you might have two-way edges for example from 1 to two there is an edge from 2 to 1 there can be Edge as well and it is possible a different weight is associated with each of it Edge for example you're going from Delhi to Bangalore via flight now this flight might cost you 4K but this flight might cost you 5K so this is an example of a directed and a weighted graph in a undirected graph there is no direction of the edge that means you can travel in both directions you can go from A to B you can go from b b to a for example in roads okay so I hope you're able to understand through these examples so let us try to make a matrix and uh let's summarize right I can say graph can have weight weighted graphs or unweighted graph they can have direction or they can be undirected okay what what would be an example of a directed and a weighted graph for example from A to B okay and there is a cost associated with it this can be your graph of different flights across cities because flights will have a cost and they will have a direction if there is a flight from A to B it is possible that there is no flight from B to A or B to a flight has a different cost this will be a directed and a weighted graph let's look at an example of a directed and unweighted graph I talked about topological sorting in which we said that there are certain tasks and there are dependencies for example B is dependent upon a c is also dependent upon a and C is also dependent upon B so this is an example of a directed a cyclic graph Okay so so this is an example of a dependency graph in this graph there is a Direction but there is no weight it is an example of directed and unweighted graph so an example is dependency graph okay then there is an example of undirected but weighted graph so I want a graph in which there is no Direction but there is a weight maybe the road Network I can say okay the roads are generally two way so there is there is a cost so there is a weight but there is no Direction so 100 200 10 20 this is an example of a undirected and a weighted graph then undirected and unweighted graph so that means no direction and uh no weights as well so it could be simple Facebook graph in which you're representing who is connected with whom A and D they are friends so there is no weight so maybe Facebook friends graph okay or Facebook Network it is possible that it is United but depending upon how Facebook implements it this graph can also become weighted Facebook might represent a score a friendship score on each Edge how strong these two people are how strong their bond is so it is possible that this graph can be made as weighted also so I hope classification of graphs is clear through these examples and next we will dive into the implementation how to create a graph and store it on your RAM now the next question arises how do we actually create this data structure and how do we work with it so there are three common representations for graph one is called as Edge list one is called as adjacency Matrix and one is called as adjacent list we will go over all of them one by one each representation has has its own set of advantages and disadvantages but in general this representation which is called adjacent list this is the most popular and most commonly used in many algorithms but this does not mean that edge list is useful or essency Matrix is useless so they are also useful they have their specific applications in certain type of algorithms so let us discuss Edge list first and what is a EDG list so in a edge list we represent graph in in terms of a list of edges right so suppose we have vertices a b c d so we will make a list of vertices and if we have edges we will note down what edges we have we have AB so AB is an edge we have AC we store that we have ad we store that we have BC we store that we have cd we store that so right now I'm assuming this is a undirected graph so when AB is an H it also means B a edge is also there that means if you can go from A to B you can also go from B to a as well right similarly if you can go from a to c you can go from C to a as well right so in my code I will be storing two copies ad is there da is there BC is there CB is there DC is there right I'll be storing it like this that will be more helpful because if I at D and I want to look at what nodes I can visit so I can clearly look at this there is an edge from D2 a and there is an edge from D2 C right right I can look at this or you can say okay I'll iterate through the whole list of course you will have to iterate through the whole list and you have to look at what pairs contain d right from that you can get this information from D where you can go right but this kind of representation is pretty I would say inefficient if you have to find whether there is an edge between let's say B and D I want to see whether there is an edge from B to D the answer is it is inefficient because you have to spend you have to do a linear search over the whole list so that means you have to spend order of e time looking for whether such an edge exists or not right similarly if you have to do an operation like okay give me the neighbors immediate neighbors of B right this is now a very common operation in graph algorithms such as BFS DFS D exas we often need this operation right neighbors of B what are the neighbors of B so again you cannot tell directly you have to iterate over the whole Edge list to find out what are the neighbors of B again this operation is going to be inefficient it is going to take order of a time right but one thing this Edge list is good at for example suppose this was a this graph was a let's say a weighted graph let's say 10 5 2 1 six right and I want to pick edges based upon their weight right so now in such a scenario I will be storing three things in an edge so I will be storing a b followed by 2 I will be storing a c followed by the weight right in case of a weighted graph I need to store three things right and so on maybe I want to pick edges based upon their weight so what I can do if I've stored all edges in the form of list I can easily do sorting on this list I can do sorting on the list in like e logy time right e logy time and I can pick edges maybe based upon their weight right or According to some criteria right so maybe I want to do sorting on the list based upon weight of edges this kind of algorithm is actually helpful when we deal with a topic that is called as minimum spanning tree right when we are building a minimum spanning tree algorithm we actually need to pick edges based upon weight in such an algorithm we will go with a edge list kind of a representation right so that means this representation is also useful but but it depends upon the algorithm what kind of operation do we want do we want to get neighbors of a node or do we want to sort edges so if you want to sort edges then Edge list is the representation that we will use so I hope you are able to understand Edge list and now in the next video and now we will discuss the code of edgelist so I'm going to show you how we can create a graph using EDG list so I am in my intellig ID and I'm going to create a class called as graph using edist this class will be responsible for holding the data of the graph effectively what I'm going to do is I'm going to keep things little simple I'm going to fix number of nodes let's say number of nodes is given as input by the user let's say user says four nodes I'm not going to take input the names of nodes I'm going to assume that the nodes are always numbered from 0 to n minus one so this is from 0 to 3 right this is is something which is very common in many coding problems and we often use we make this assumption okay and you can also verify from the problem statement if this is not the case then we will discuss it separately right so number of nodes are four and let's say the graph looks like this 0 1 2 3 right so what is expected in the input that you will be given how many edges are there so number of edges will be input that is also four and then you will be given the names of edges so 0 1 is one Edge 0a 3 is another Edge 1A 2 is another Edge 2 comma 3 is another Edge so you will be given these numbers input so what is our expectation that this graph should be able to hold these pair of edges so 0 comma 1 I want to hold 0a 3 I want to hold 1 comma 2 I want to hold and 2 comma 3 I want to hold right now if you look at this list can you visualize this graph of course yes right that means this information is sufficient to store this graph right what I'm going to do in this graph class is I'm going to make a list which is able to hold a following Edge right now it is possible that each Edge might have a certain weight let's say some weight W1 W2 W3 W4 right in such a scenario I can add W1 W2 W3 it will be list of edge where each Edge object is a collection of three numbers in this case right so what we can do is we can define a class called as Edge right we can define a class called as Edge right and uh in this class I can have three things one is maybe the source so I call it as U I have V and I have weight right so that means uh the triplet if there is an edge from U2 V with a weight w I'm going to store a triplet U VW and I'm going to create create an edge object out of it right then I can make a list of edges I hope you understood the concept let us dive into coding so I need a Constructor for The Edge class so the Constructor is going to expect U V and W right for one Edge object I can say this do U equals U this do V equals V this do weight equals weight right so later on I want to print the edges so I might need need a method to display an edge right so I can just use the two string method which is going to show me which is going to print which is going to return a string representation for this Edge so this will be helpful when we are going to print the edge so if I want to do s out an edge I will see that the edge will be printed like this U equal to something V equal to something and we equal to something this overwrites the default uh two string method right and it is autogenerated by the ID for me right so I have the two string method with me right this will be helpful if I'm going to display the graph that means I'm going to display this EDG list in the output so I don't have to like I don't have to write for each Edge I have I don't have to do this work because it this method will be called when I'm going to print it so I can simply say s out some Edge right so something like this we can do so so now coming to this actual class right so let's make this class as public in this class what information it needs to hold it needs to hold how many nodes we have number of vertices number of edges is optional because it can be judged by the length of this list right so user is going to enter the edges and we are going to store them right so that is simple and uh so let's have a Constructor right so the construct and apart from it we need a list of edges right so list of the type edges L let's create the Constructor graph using Edge list in this Constructor I'm going to get number of vertices which I can initialize this will be list of edge so I can say this do V equal to V and I also need to create this list so L is a new list so it can be a link list or an array list and uh I can say it is a empty list right so when a when a graph is created it knows how many vertices it has and it creates a empty link list okay now I want to add edges in this graph maybe I need to create some method add edge U comma V and weight right I want to push an edge into this graph I I can simply say uh if there is an edge from U to V so I can say um L do add what I should add I should add a new Edge which goes from U to V and is having a following weight so I'm doing it for a directed graph right I'm going doing it for a directed graph so I think this implementation looks complete to me now let us test our implementation by going to Main right so here what I need to do I need to create a graph object right which I am doing right and uh then I'm saying that fine okay so here I've passed one more parameter which is going to tell whether the graph is directed graph or undirected graph so this is a optional thing if you want to accept that okay this is a directed graph then you can add just this Edge but if it is a undirected graph gra you also need to do one more U line of code where you are adding The Edge from U to V right so you're saying that okay A and B are connected that means a is a friend of B there is an edge from A to B but there is also an hedge from B to a right so you can do this thing in case of a undirected graph that can be handled by putting a if condition here but for now I'm keeping things simple and I will modify this code a little bit earlier I did it for undirected graph right so it's it's just a signal the graph whether you want to add this Edge like one time or two times right and now I want to display the graph I basically want to display the edge list so I created a graph object using this class new graph I initialized the number of vertices which actually we are not using as of now but this might be helpful in future right for some other use case so now if I want to display this Edge list so I can say Okay void display okay or let me see if I can do a two string thing here right so here I'm going to modify this right I'm going to or this is fine actually this is fine so it is going to return a list let's see what does it return right I'm going to say s out graph show me the graph right so let's go and run this code okay so this graph says that okay I I know two things I have vertices which are four and I have a list of edges which is this list okay so there is an edge from 0 to 1 with weight 10 so 0 to 1 weight 10 0 to 2 weight 20 0 to two weight 20 1 2 2 weight 30 right so you can see this is completely fine and we are able to see uh The Edge list that we have implemented that is the idea behind Edge list now you can use this Edge list to do sorting so right now I have hardcoded values here but what you can do you can ask the number of edges put a for Loop take input those edges and inside the loop you can call this function g. add edge and this is going to add all the edges in your graph right so in generally I've discussed how the input is given number of nodes is given number of edges is given followed by list of edges is given right so pairs like 0a 1 comma 10 followed by next pair 0a 2 comma 20 right this will be input you can scan it and call g. add edge to add it in your graph right so I hope this representation is clear next we will discuss another implementation the next representation of a graph it is called as adjacency Matrix so what is this it is a 2d Matrix matx which is of the size V cross V where V is the number of vertices of the graph the number of elements in The Matrix indicate whether pairs of the elements of the Matrix actually not the number of elements element of the Matrix indicates whether pairs of vertices are adjacent or not basically if there is an edge from 1 comma 2 right so what we will do we will have a adjacency matrix okay so in this case there are five nodes so there is a five cross five Matrix right and there is an edge from 1A 2 so what we are doing we are saying that Matrix of 1A 2 will be true so if it is a unweighted graph there is no weight so I can simply set this Edge as true so 1 comma 2 is true or it is one right and similarly if it is a undirected graph there is no Direction so Matrix of 2 comma 1 is also true right so this value is also true so this value 1 comma 5 this is zero so this basically indicates there is no Edge from 1 to 5 right so if there is an hedge from X comma y then in in my Matrix Matrix of X comma y will be set to one and Matrix of 1 y comma X will also be set to one that indicates that X and Y they are connected right so this is pretty simple and the problem with this approach is that as your n grows right so if let's say you have th000 nodes right your Matrix will be of the size n square right that means it will have 10^ 6 elements so if n is let's say 10^ 7 your Matrix will be of the size 10^ 14 you won't be able to hold this big Matrix in your memory right so it it is not suitable for large number of nodes okay it is suitable for small number of nodes but again there are certain advantages and disadvantages for this right one is one disadvantage is that you're going to waste a lot of space so in most of the graphs if you have n nodes you might not have n s Square edges that means lot of zeros will be there in The Matrix which is leading to space wastage secondly if you want to find neighbors of one what nodes are connected with one there is no way you have to iterate over this whole list which is going to take order of uh order of V time right because there are V vertices here you have to go to each vertex and check whether one is connected with it or not right that is again a problem we do not want to go to Five because one is not connected with five but we are still iterating right so this is a major disadvantage that means you cannot get neighbors of a node in order to get neighbors of node you have to spend order of p time which is not very efficient operation right but there is one advantage as well what is the advantage if I have to check if there is an edge between 1 comma 3 right so that check can be order one why because you just need to go to 1 comma 3 this index and check yes this value is one so you can check yes this value is one so that means I can figure out whether an edge is present between two nodes or not in just order one time right you might ask what if the graph was a weighted graph 1 comma 2 was having let's say w weight in such a scenario instead of storing 0 or one here you will store 0 followed by weight right zero and weight so 1 comma 2 has having W weight so 2A 1 is also having W weight right so you can store integer values 2A 5 has 8 weight so 2 comma 5 you can put this value as 8 and 5 comma 2 as also it right so depending upon the use case this Matrix can be an integer Matrix or it can be a Boolean Matrix right so I hope you understood the concept of adjy Matrix now let us look at the implementation of adjacency Matrix let us Implement graph using adjacency Matrix again I will have to keep number of ver veres and I will have to keep a Boolean Matrix so I can say a Boolean some Matrix let's say called adjacency Matrix and uh we will initialize this Matrix in the Constructor right so I have graph using adjacency Matrix I'm getting the number of vertices this dot V equals V and adjacency Matrix equals new Bo of the size V cross V so I hope this Matrix this initialization is clear by default I think all the values would be false and now we can write the add edge function right so I'm not going toh take the weighted graph because I've taken a Boolean Matrix so I will take only two parameters The Edge from U to V and also I'm assuming the graph is a undirected graph right but if you have a directed graph then it is even easier right so if there is an hedge from U to V what I need to do in The Matrix for the U row and the V column I need to mark this as true so I can say adjacency Matrix of U comma V will be marked as true rest everything is false right and adjacency Matrix of V comma U this is also true right so the other way around we also have to do right so that's it now what we need to do we need to test our code right this adds an edge to our graph and now we can have a display method right that is going to display the Matrix so I can add a two string method here which is going to display the vertices and the adjacency Matrix let's go to main here and now I have to create a graph using using adjacency Matrix I've added few edges and uh now let us go and run this code and let's see what output do we get now we are getting okay in this graph object we have four vertices and now adjacency Matrix is being displayed like this so This is actually how a 2d arrays stored in Java right so if I talk about a 2d array the 2D array is a 1D array of rows right and each row is actually point is storing the address of an array right this is how it is being done right this is how it is actually done 2D array is an array of rows and each row is let's say this row is 30 C this is 97d right so what we are printing is we are printing the address of each row of the uh array right so this is the address of a one array zero throw first row second row and third row if I want to handle this uh in a correct manner right so I have to say that we do not want to convert this 2D Matrix into string directly we have to use a method called uh deep two string that will actually iterate deeply into each row and then it will print convert the contents into the string right so I'll do it like this this will actually give me the string like representation of the full 2D array right let's uh go and run this code once again and see what do we get yeah this time I'm getting the correct adjacency Matrix I will draw it for you so what I did I give four vertices let's say 0 1 2 and 3 then I said one and two are connected fine 0 and three they are connected okay 1 and three are connected okay and two and three they are connected okay so this is how the graph looks like and then I have a 4 cross 4 Matrix 0 1 2 3 0 1 2 3 it is false false false true so here I have a true here false false true true so here I have true true false true false true so true true then I have true true true false t t t if you look at this zeros zero is only connected with three so we have a true here then look at one one is connected with 2 and three so one is connected with two and three correct look at two two is connected with 1 and three two is connected with 1 and three correct look at three three is connected with 0 1 2 so 0 1 and two yes this is a correct representation of the adjacency Matrix for this graph so I hope you understood this concept pretty easy nothing fancy in it and you can easily modify the code for a directed graph by making this as a integer Matrix and putting the weight here right so that's all next we will discuss adjacent list now let us talk about one more implementation of graph that is called as adjacency list this is the most widely and most common used representation in many graph algorithms what do we do in this representation the adjacency list represents a graph as a array of Link lists the index of the array represents a node so we will try to understand now suppose I have one to two there is an edge right so what I really want to do is that with node one I actually want to store all the neighbors of one so one is connected with two one is connected with three one is connected with four right so basically there is a key value mapping so key is one value is the list of nodes with which it is connected one way to store it is that we create an array now Suppose there are five nodes so here they they have assumed a one based indexing but in our code there will be a zero based indexing right what it is saying that it is a link list right so if you talk about one one is connected with 2 3 4 similarly if you talk about two two is connected with 1 3 and 5 so I know two is connected with 1 3 and 5 three is connected with three is connected with 4 and 2 right so and one also so it is connected with 1 2 and four four is connected with 1 and three and five is connected with two right so each of this is like a link list we can definitely add more to this link list for example if five and six are connected I can say okay in link list of five you can add six and in six at the sixth position you can add five okay so why we are using this link list because it is easy to add into this this so we can easily do a add operation right but how many link list do we need do we need one link list no we need an array of Link list so this data structure is a array of Link list right so right now we are assuming a one based indexing but it will be zero based indexing if I talk about array of one array of one is nothing but it is a list what about array of two array of two is nothing but it is a list and what does array of denote array of two denotes a list containing neighbors of two right so if we implement this right so what we are going to store we are going to store this this this this this and we are going to form an array out of it right so this is what an array of List look like some of you might ask what happens if nodes are not numbered 1 2 3 suppose they are numbered as Delhi Mumbai japur in that case in instead of using an arrrow of lists you can also to create a hashmap where the key is a string and the value is a list of string that is also possible right that is also a way to implement a adjacency list with so in in case of zero based numbering it becomes easy because ARR indexes are numbers themselves but if you have something complex like Delhi Mumbai jaur aabad you can also use a hashmap in place of it right so I hope you are able to understand this concept now let us talk about advantages advantages of this representation so the First Advantage is efficient storage we are not wasting any space unlike we did in adjacency Matrix right we are only storing the value of edges where the edges actually exist so it is efficient in terms of storage right they are also useful for storing sparse graphs that means um which have much lesser edges compared compared to like what will be a dense graph so if you have five five vertices and you have let's say V Square edges in that case that means every node is connected with everyone in that case adjacency Matrix can be easily used right but if you have five vertices seven edges it's kind of a sparse graph right number of edges is much less than V squ right and the biggest Advantage is efficient retrieval of neighbors as I told you that this is an important operation then we frequent do in algorithms like BFS and DFS we can easily find neighbors of any node if I ask you okay find neighbors of three what you need to do you need to go to array of three which is an order one operation and then you need to iterate on this list basically in order of neighbors time if three has three neighbors out of 100 nodes you can get those three Neighbors in three units of time you don't have to Traverse the whole list of uh nodes right so this this is a very efficient operation because of these two reasons it is a very widely used one is efficient storage second is efficient retrieval of neighbors this makes adjacency list a popular choice for graph representation and is used in many algorithms such as BFS DFS shortest path algorithms and much more now let us discuss implementation of adjacent list let us start implementing graph using adjacency list so we are discussing adj s list implementation for the graph one thing we need is the number of vertices next what do we need we need an array of Link list so how do I create it I can say list of what list of integers if I simply write adjus list this makes one list object but I need a array right now I need to initialize this array inside okay this will be integer here right because my collections does not accept primitive data types I need to initialize this object in the Constructor itself what is the size of this list that will be known when we are creating the graph object I can get the number of vertices and I can say this do V equals V and I can say this dot adjacent the list this is equal to New Link list of integer and how many objects I do I need I need V number of objects okay so I have created an array in which this adjacency list right but right now this object is not created right only an array is created so what I need to create I need to create a link list at each index so how do I do it I can okay I will iterate over this I equal to 0 I less than V and i++ right so basically when I say I'm creating this array that means the array bucket can hold the address of a link list but right now that is null right so what do I want I want this bucket to hold the address of a link list object how do I create this link list object I have to use new right I have to say adjacent list of I this is equal to New Link list this actually creates an array in which each element is a link list object right so this is the correct way of constructing a adjacent list now what do I need to do I need to add elements into the link list right I will have a function called void add edge edges from U to V what do I do now I can say okay if there is an edge from U to V what should I will do and maybe I can accept is it a undirected graph right if it is true I will also add an hge from from V to U right so I can say uh adjacency list of U dot add V something like this and if it is a undirected graph I can say adjacent list of V oh it will be Boolean right bu is in C++ it just in a list of V do add something like this basically what I'm saying that go and add an edge from 1 comma 2 so 0 1 2 3 so in first link list it will add two and in second list it will add one then I say okay go and add 1 comma three in first list it will add three and in third list it will add one something like this basically if one is connected with two one is connected with three if I read this I see one's neighbors are two and three right if I write it little more clearly so two and three they have been added into the link list which is at the first position right so this is how the add edge function looks like then I can display the graph so I can write the two string method which is autogenerated and here similar to the previous case normal two string will not work I want to iterate deeply into into the data seure I will use deep two string method and this adjacency list will be converted into a string like representation that I can print now let us come to our main which is here and I have created a graph right I'm I'm trying to add edges in it and I'm trying to print it so this I have already written before so I'm just going to run this and you can see the graph class we have just constructed now let us try to visualize this graph one is connected with two fine undirected graph Z is connected with three okay 1 is connected with three and two is connected with three this is how the graph looks like and now if you talk about the adjacency list zero is connected with three okay one one is connected with 2 and three one is connected with two and three that that's correct so list of one it is storing the neighbors of one list of two so two is connected with 1 and three absolutely correct what about three three is connected with uh 0 1 and two so three adjacency list of three storing neighbors of three this is how this 2D array okay it's it's it's not a 2d array it's uh it's a array of Link list right each link list is denoting the neighbors of the ayat node right that is the adjacency list implementation I hope you are able to understand this this implementation so pretty easy nothing fancy nothing difficult and if you have uh more complex data as I told you instead of having this you can also have a hashmap where key is your um this this will become your key and this will be added into the list corresponding to that key right that's all for uh this implementation okay so we have discussed the most common L used implementations of the graph adjacency list adjacency Matrix Edge list there is one more representation that is sometimes convenient for certain type of problems okay so sometimes we are given a graph in which we are saying okay there is a 2d Matrix and it is given that each cell is connected with let's say the four neighbors something like this or each Connect Cell is connected in the Four Neighbors which are of the similar color right and you have to do something right in this case what you have to do you do not need to construct a graph you can directly deal with the Matrix right so if I say okay what are the neighbors of this one either it will be four-way connectivity it will be mentioned in the question then you can go in these directions or it can be eight-way connectivity that means the diagonal directions are also included this kind of representation is helpful in some algorithms like floodfill right so what is happening in flood fill there is a 2D image which is uh made up of some pixel values right so you are filling the color until you hit the black boundary and how are you finding the neighbors you are going in this four-way connectivity or doing the eight-way connectivity right this is not possible for every type of graph but certain problems where graph could represent an image right or the neighbors have this kind of relationship where they can be represented using a 2d array right so we will deal with these kind of problem problems in the series and I hope you learned a lot of Concepts from today's video so let us talk about graph reversal first what is actually is a graph reversal so graph reversal also known as Graph Search is a way or is a process of visiting each vertex in a graph such reversals as I told you are classified into two types one is BFS which stands for bread first search and it is a iterative way to Traverse the graph and second one is a recursive way called depth first SE in this tutorial we'll focus on BFS and its applications so BFS actually has many applications and one of the most commonly used application is finding shortest paths in undirected graphs we'll also look at such applications in this tutorial so let us start talking about BFS it is a technique for traversing a finite graph that means the number of nodes in the graph would be finite and the way it works is it visits The Sibling nodes before visiting the child vertices so what does it mean means if you have something like a node a and it has children like B and C and then you have some children like d and e and so on the way it works is if you look it in the form of a tree suppose this graph is a tree now this is not a tree because I'm added one more edge here the way it works is it will visit this node then it will come at B but it will visit sibling of B that is C next so it will visit BC then it will visit d e FG and so on in a way if you look at in the form of a tree tree like traversal it is like a level order traversal that we have done in a tree but in a graph it will be quite similar but there is one catch the catch is graph contains a cycle right we have to make sure that we are not visiting a node which is already visited for example from this node one if you visit two and two is connected with three three is connected with one so there is a cycle if you say okay I'll visit one I'll visit children of one that is two I'll visit Three from three now you cannot go and visit one again right so this is something we have to make sure is handled properly by our algorithm so before I dive deep into the algorithm or into the code let us try to understand some applications of BFS BFS is can be used to find all the vertices within a connected component so we want to see what parts of the graph are connected it is also used to finding shortest between two vertices in case of a undirected graph that means all the edges sorry unweighted graph that means all the edges they have equal weight there is no weight assigned to any Edge if it is a weighted graph then we have to use a different algorithm it can be used to check a graph for bartness it can be used for cycle DET detection in undirected graphs it is also used in Ford ferson algorithm for maximum flow it is also used in serialization der deserialization of binary tree it is also used in maze generation algorithms and it can also be used in algorithms like floodfill there are many many applications and that is why understanding this algorithm becomes very important so let us now dive deep into the algorithm now suppose a graph like this is given so what kind of graph it is in my case it is a un weed graph and it is also a undirected graph that means edges don't have any specific direction if 0 and two are connected two and Zer are also connected so we can go both sides right so now in this algorithm what is the input the input is a source vertex that means you're given a starting point from that that point you have to Traverse the whole graph starting point point could be zero it could be three it could be six it could be any node so just to keep things simple I'm going to take 0 Z as my starting point right and let me also draw the adjacency list that could be possibly a input for this algorithm so that means 0 is connected with 2 and one one is connected with 0 and four the neighbors of one are 0 and four neighbors of two are 0 3 and four so 0 3 and four neighbors of three they are 2 and six neighbors of four they are 1 6 5 I'll write it as 5 6 then I have neighbors of five which are only four and neighbors of six which are three and four right one thing I told you that if you start from this Noe right so what we need to do we need to we'll be using a q in this algorithm you will understand why this Q is going to be very very helpful let me draw a data structure here which is a q apart from it we will also need something to maintain whether a node has been visited or not right because the graph contains a cycle and it is possible that we are coming to the same node again and again right so this is a q it is a empty Q as of now the Q you you know it has a fif property first in first out property right it is a fif Q here and apart from it I'm Mak making one more data structure which is going to denote whether a node has been visited or not so 0 1 2 3 4 5 6 I think this is sufficient we don't need so we will Mark whether a node is visited or not so right now it is nothing is marked nothing is visited we'll start from this node that is the source node let's just assume the source node is zero we'll mark it and we will put it into the que zero has been visited zero goes into the Que and I am going to mark it as visited so here the circle denotes the Q has been visited now what you will do next you will look at this adjacency list you will find out the neighbors of zero the neighbors of zero are 2 and one so you will pop this node out the node is zero you will look at neighbors of zero that is 2 and 1 you will mark them as visited and put put them put them into the Q so you from zero you can easily visit two and you can easily visit one what I'm trying to is I'm marking 1 and two as visited and I'm putting 1 and two into the Q so first I visited two and then I visited one both of them they are into the que that means I've marked one and two as visited now what you will do next nothing you simply have to pop out a node from the queue every time and do the same process again so now you will remove two look at the neighbors of two which are 0 3 and 4 so now 0 is already visited so you do not do any work at zero then three and four three is not visited you can visit Three so Mark three as visited put it into the Q and mark four as visited and put it into the Q okay now two is gone two has been removed next node you will get from the Q it is going to be one so you will remove one from the que and you will Mark neighbors of one has visited so neighbors of one 0 and four so look at 0 0 is already visited four four is also a neighbor four is already visited so you do not do any work so you do not do any work right so in the meanwhile you can print the nodes that you have seen so far so you have seen zero you have seen two you have seen one next you will pop out three so remove this node print this node look at the neighbors 2 and six two is already visited do nothing at two six is not VIs visited so Mark six as visit put it into the que so you have to tr you have traversed six as well so six is now also into the que next you will pop four so print four look at neighbors of four four neighbor is one which is already visited its neighbor is five which is not visited so you will visit it put it into the Q six is already visited do nothing to do here right next you will get six from the queue remove it print it and now look at neighbors of six six neighbor is only uh three and four right but both of them they're visited so you will not do any work so next you will remove five five neighbor is four so this is also removed four is already visited hence you do not do any work and now what you can say is that your traversal is done right your traversal is done so what happened during this traval we visited each node once and in the worst case we are traveling through all edges once right what we have done like we have traveled through through through some edges and we also checked that from four I can go to one so we did check this Edge right we did check this Edge one was already visited so we did not Mark anything here right so we did not Mark anything here what I'm trying to say is when you're running this algorithm each vertex is going into the q1's and it is coming out of the q1's and when you're finding the neighbors of a node you're traveling through all the edges right all the edges are being covered at most twice for example neighbor of four is six neighbor of six is four each Edge is counted at most two times so if I talk about the overall time complexity of this algorithm it will be linear in terms of number of nodes and number of edges this is what we are doing right I hope you have understood the basic BFS idea next we will look at the implementation and code this algorithm so let us discuss the implementation of BFS I already have the boiler plate code ready which uh is basically adding edges into the graph the BFS function is something that I'm going to write now so return type is void we do not want to return anything the method name is BFS but what we we may expect as input is One Source node from which we should start doing the BFS for this graph so this is the graph so I told you we will be needing two data structures one to maintain whether a node has been visited or not I can maintain a Boolean visited array and this will be a array of size V where V is the number of vertices in the graph next thing I will need would would be a data strcture Q so in Java we have q as a interface so I'll create a link list which provides me with the implementation of Q as well link list of integers we will just call it as q and I will say this is equal to New Link list all right so that are the these are the data structures that we will be needing now let's start with the algorithm so in the first step what I will do I will start with the source node mark it as visited push it into the queue so I have to do three things Market as visited so visited of source is going to be true I will say okay this is going to be true and then I will Traverse the neighbors of this node so first thing I will do is I'll push this into the Q so I can say Q dot add last the node is Source okay and second thing I will do is I will mark this as VIs visited the visited of source this is going to be true now what can I do now I can say while my Q is not empty so I will stop once all the nodes have been popped out so how do I add into the Q and remove from the queue so you know if you have to add something into the que that addition will happen from the ending so add last and if you have to remove something from the beginning so we can call remove first method I can okay the node at the front of the queue so that is int node this is going to be Q do remove first all right now what can I do I can okay for this node the node that I've removed from the Q is zero right so I need to Traverse what are the neighbors of zero so Zero's neighbors are there in adjacency list so they are 1 and two so what I need to do I need to Traverse on these neighbors if the neighbors are not visited I will mark them as visited and I will push them into the cube so this is what I do I can say okay for every neighbor okay so to get the neighbors what we can do we can use iterator I can create a iterator of the type integer and call it something like it trate it and now I can say give me the neighbors of this part particular node so if you know the uh this is the adjacency list I I want to iterate on this adjacency list of the node so I can say okay while it do has next that means the next node is present basically it it is a way to iterate on the adjacency list sorry you have to call a method called list iterator because we are iterating on the link list so zer zeros neighbors are one and two right so these are stored in a list which is which was a list object so adjacency list of node is a list we have to get the iterator using this method list iterator so it will iterate over these nodes until the list is uh not finished it will go over these neighbors now I want to get the node right so how do I get the node I can okay the neighboring node is nothing but it do next that is the neighboring node and now what I need to do if it is not visited if not visited neighbor what do I need to do I need to mark it as visited I can say visited of neighbor this is equal to true and I need to add it into the Q so I can say Q dot add last and the item is neighbor we are iterating over all the neighbors and if the neighbor is not visited we simply mark it as visited and we push it into the so I hope this should suffice and one more thing we can do in the v Loop is we can print out the node we can see what output do we really get I can say s out node now let us test our algorithm on the graph I have already conf structed so let me show you in graph main I will go and this is the graph same as uh this graph and now we are going to run BFS function on it I can say G do BFS let's say the source node is zero so let's go and run this code and see what output do we get we should get all the nodes from 0 to 6 because we are doing a graph reversal let's see the output okay we got an error index 6 out of bounds for an error of length four okay so here we have to give uh we have seven nodes actually input needs to be fixed okay so this is our adjacency list and we are getting 0 1 4 3 65 so we are getting all the nodes that means the graph reversal is correct now the ex output will also depend upon the way you have stored these nodes okay so you said okay Zero's neighbors are 1 and two after zero it will print one and then two but if you say in my adjacency list I will store two and one first that means I will add this Edge before this Edge then the output will be 0 2 1 and so on so right now our goal was to visit all the nodes which are which can be reached from node zero so we are getting 0 1 2 4 3 6 and 5 that means this output is correct we are able to reach all the seven nodes including zero now let us discuss one application of finding the shortest path from The Source node to all other nodes okay so what we are going to do we're going to do shortest path from source to all other nodes in a undirected graph in a unweighted graph un un weed graph so this graph is a example of a unweighted graph so graph can be directed or undirected but it must be a unweighted graph for the BFS algorithm to work for finding the shortest path right so we are going to talk about BFS shortest path algorithm the algorithm is very simple and it is very similar to just doing BFS so let us try to visualize what we are doing in BFS we are starting from node 0 and we can mark the distance of 0 as 0 and from 0 we are visiting the nodes 1 and 2 since we are visiting a node for the first time we will be updating their distance and we will be saying this distance is one and this distance is also one because we are coming from 0o and 0's distance is zero next you know in the Q what you have done you have said okay Z is there then you pushed one then you pushed two and so on right so now next next item you will pick is one and you will upgrate the neighbors of one neighbors of one is let's say four and zero zero is already visited so you will not go there so you will say Okay since I'm visiting four via 1 this distance must be two distance of four I can say distance of uh the neighbor is one more than the distance of the parent so parent is one okay so distance of parent parent node is one child node node is four or the neighbor node is four Four's distance is one more than the parent I will visit four and I will push four into the Q so next I will remove two so two's neighbors are zero already visited three three is not visited so I can visit three and I can okay this distance is going to be two so I will push three into the Q and two's neighbors is also four but four is already visited so we will not update it so it is not possible that your reaching a node later which is already visited and the distance will get minimum it's not possible in case of a unweighted graph if it would have been weighted graph this was this could have been possible right now four is already visited and since you are reaching from two again node is already visited so this distance will be either greater or equal to two so it is we will not update it so we will not do anything at four so two is done two has done its work next we will pop out four and four can now update its children so four children are six this distance is three so you push six and four can also update five so this distance is also you can push five next you can pop out three now three again it will try to visit six but six is already visited so hence you don't do any work then you try to pop out uh six you can remove six easily but there are no nodes no neighbors of six which are not visited then you pop out five there are no neighbors of five which are not visited so if you look at these values you will find that these are the shortest distances from zero to all these nodes these are the shortest distances from zero to all these nodes so that means distance of 0 is 0o distance of one is one distance of two is one distance of three is two distance of four is two distance of five it is three and distance of six it is three the one observation we can make out from here is that BFS visits nodes in increasing order of their distance from The Source node this distance was Zero these two distances were one these two distances were two and these two distances were three right so this is an observation right so when I said you can get any ordering so that means between the these distances the ordering can change the BFS might produce an output like 0 to 1 it might produce 43 it might produce 34 56 might get 56 or 65 right different orders but the distances of these nodes will be in in in increasing order from the source node that is how we can find shortest path from source to all other nodes in a unweighted graph by simply using the BFS in the next part we'll show you the code changes that we need to do for this algorithm so it is very simple take a moment pause the video and think what changes you will make into the code all right so let us discuss the code changes now apart from the visited array what you need to do you need to maintain a distance array the distance of each node from The Source node so you can okay I need a distance array which is uh of size V and in the beginning you can say distance of source you can update that distance of source as zero and rest is very simple as you are visiting more and more nodes you need to update the distance you can say okay I'm going to visit the neighboring node so when I'm visiting this neighboring node I can say distance of this neighboring node is one more than the distance of the node that is parent of this node so that node is nothing but this node so this node is distance of node so that's it now now what we can do in the same function maybe we can either return the distance array or we can just print the distance array so here I can say um let's just iterate over the distance array for I = to 0 I less than v i ++ I can show the node which is going to be I followed by the distance which is distance of I so let's go and run this code and we should see we're getting node zero at distance zero 1 at 1 2 at 1 3 at 2 4 at 2 five and six they at distance three this is how easy it is to make changes in the code and now we have made shortest path algorithm using BFS now some of you might be wondering that okay we have figured out the shortest path but we have only figured out the distance actually what if if I actually want to figure out the exact path from let's say 0 to some node five right maybe I want to find out what is the shortest path should I go like this or should I go like this or should I go like this what will be the shortest path from source to destination in a unweighted graph so again this thing is very simple what we were doing we were doing BFS zero was visiting one and two one was visiting four two was visiting three and three was visiting six no I think it was like this four was visiting five and six and then uh three something like this with it right so now again if you want to find out the shortest path to reach five you will know that okay five was visited from four four was visited from one and one was visited from zero right what you can get you can you can actually store the parent so you can store parent of five is four parent of four is 1 parent of one it's zero and parent of Z is let's say 0 or minus one anything you can put what you can do you can store these parents for every node and then you can do Trace back you can okay I'll start from five and okay from where I should go so this is my destination node who is the parent of five how do we arrive at five we came from four so I can go to this node okay how do I came at four I came from one so I I can go to this mode how do I came at zero I will go to zero okay how do I came at one I came from zero so I go to zero who is the parent of 0 minus one that means we have finished the entire path in this way you will be able to store 5 4 1 0 in a array or in a array list so this way you can also print the shortest path from The Source node to the destination node the only changes in the code you need to make is you need to create a parent array and when you're visiting from a node to to a neighboring node so you can say Okay parent of neighbor will be equal to node something like this and then you can simply put a v loop at the end once all the nodes have been updated your BFS has been done you can okay while I don't get the source node let me travel back from the destination node so you will travel this way you will travel this way and you will eventually reach the Source not so this is something you have to try you have to figure out you have to make the required code changes in the algorithm that we have discussed now we will discuss one application of BFS in solving a problem so we are given a snakes and letters board which looks like this and what we need to do is we need to find out the minimum number of moves that are required to go from source which is from cell one to destination which is cell number 36 so first of all we need to decide whether it is a graph problem so if you look carefully you can analyze that we can clearly see there are 36 vertices there are 36 nodes where you can go clearly we see vertices but how do we decide the edges right so basically it it the question says there is a regular dice so on your dice you can throw any number of your choice from one 2 3 4 5 6 right the rules of the board are very simple Whenever there is a letter you can climb that lead but whenever there is a snake you will be cut by the snake and you will reach the tail of the snake so you can cut down from head of the snake and you can reach the tail this position right so basically like in any snakes and lers Gom you have snakes which can cut you down and bring bring you down and there are letterers which you can climb and move to the top the question is how many minimum number of dice moves will be required to reach this destination so you can assume there is only one player it's not a two player game so the question is only about finding the minimum number of dice move we need to think carefully what kind of graph it is if you analyze carefully you will analyze that if you count the if you look at the dice moves at one you can throw a one that means you can reach two but at two there is a letter that means you will reach 15 so if I talk about this Edge there is a Edge from 1 to 15 in this graph then if at 1 if you throw a dice two you can reach three there is an edge from 1 to three also if you throw a three on dice you can reach four that means there is a edge to four as well and all of these edges are directed edges and then if you throw a four you will reach five but on five there is a letter so that means the EDG is from 1 to 7 right and if you throw five you can reach six that means there is an edge from 1 to six also right now if you throw six you you can also reach seven that means it is the same Edge we will not count that edge again again starting from two so two there is a letter so we do not need to do anything then you go at three so from three again there are edges so there is an edge from three to four if if you see carefully from three you can go to four and so on from three you can go to seven also from three to 7 there is an edge and so on that means how many edges I have so I have approximately six edges starting from each vertex from approximately 6 hes from each vertex okay if the vertex is V I can go to V + 1 I can go to V + 2 I can go to V + 3 V + 4 V + 5 this would have been the case if there was no snake and no letter but now what is happening is suppose I go to V + 1 here there is a starting point of the letter so that means I will reach at some other position so that means there might be a factor which will add up or which will be subtracted and that Vector will come from if there is a letter at that position or if there is a snake at that position right that is what I'm saying that it is an example of a directed graph it is an exam is is it a weighted graph the answer is no it is an example of unweighted graph that means all edges are equal because the cost to cover an any Edge is D throw so it does not really depend what number you throw on the die each move is counted as one through right so if you analyze carefully you will see it it becomes an example of a directed United graph and if it is uned graph we can use the BFS shortest path algorithm to find out how do I reach this node right so in this case if I analyze a little more carefully I will see from one I can go to 15 from 15 I can throw three Z and I can reach 18 18 there is a letter I can reach 29 in order to reach 29 I just need two moves then I can throw one to reach 30 and then I can throw six to reach 36 so I guess in four moves I can easily finish this game so I hope the problem statement is clear now it's your turn to figure out how do we construct such a graph take input such a graph so regarding input you will be given the number of vertices is the number of snakes the number of letterers as well as the position of the letter for example 2 2 to5 there is a letter 5 to 7 there is a letter right similarly positions of snakes will be given as pairs 17 to 4 there is a pair right so take a moment to think how do you input such kind of a graph and how do you make your BFS algorithm run on it all right so let us discuss how we are going to build the algorithm so I have written some boiler plate code it's not the complete code so I'm going to read some some inputs I'm going to ask enter the number of vertices source and the destination so I'm going to read these three things after that I will create a graph since I know the number of vertices right I can create a graph object or I can do it later on as well that's fine and I'm going to read the number of snakes and their positions so in our scenario we have 1 2 3 and four snakes number of snakes in my case are four and these are the positions of the snake 17 to 4 so I'm taking in this direction head to tail so that means 17 to 4 if there is a snake you look carefully 17 to 4 this is the snake similarly I'm reading the letters in this direction 5 to 7 there is a letter so 5 to 7 there is a letter the question is how do we like handle this data what should I do with this data first of all I need to read this and I need to make sure that this data is used in my construction of the graph earlier we were creating a hardcoded graph so we'll not do that thing here right so we'll uh create our own graph so first thing is here I'm just reading the number of snakes I'm not reading what snakes I have so I need to implement Logic for that as well right this part I'm going to do it right now so let's try to understand how we will actually create a graph so we'll create a graph object see and we will of course we'll try to add edges to it add edge now in Edge you need to know that from where the edge starts and where the edge ends right and it is a directed Edge so it's not a uh undirected graph so I will set this third parameter as false now if if I talk about vertex one so I told you from one I can go to let's say vertex I I can go to I + 1 I can go to I + 2 I + 3 I + 4 I + 5 I + 6 and plus something right this value would be zero this value would be positive value this this could be negative value what is this something going to be it will depend upon whether there is a snake or a letter starting from that position for example I + 1 at two I have a letter which gives me which actually takes me to 15 right which which is actually taking me to 15 that means I'm getting a jump of 13 right so for example if I is 1 I take a move of one I reach two and two there is a letter which is giving me a jump of 15 - 2 right so basically there is a letter so the Delta that is given by the letter right so if I go to let's say uh I I + 3 so there is no letter here so this Delta will be zero this Delta will be zero I + 4 I reach five at five I actually reach seven so this Delta is two how do I compute this Delta this Delta I have to compute and store it in an array I have to compute and store it in an array so that means in an edge this becomes the starting point and this becomes the ending point of the edge so this Delta is very easy to compute for example you are given that there is a letter from 2 to 15 you can easily say okay I'm going to store it in some kind of array let's create a board array right so it's it's a 1D array of 36 positions and in each position I'm going to store a Delta if someone says okay there is a letter from 2 to 15 that means at the second position in this array I can store 15 - 2 that is 13 at the second index in this area I can store 13 if there is a snake at let's say 32 which takes me at 30 let us assume this index is 32 so at 32 I get a Delta of minus 2 so if I reach 32 effectively I reach 30 so 32 minus 2 this is how I'm going to do it once all the edges have been inserted into the graph I can easily run BFS on it so let us try to insert all these edges into our graph what what I'm going to do I'm going to run a loop let's say for I equal to z i less than snakes I ++ I can okay snake has a head and snake has a tail I'm going to read these values I can say head equal to um scanner do next ENT tail equal to scanner do next int and I'm also going to create a board array so so the board array can be created here so int board and this is equal to new int how many I'm going to do v+ 1 because it is a one based indexing here so I've created a board array I have to move this code here because V is not input yet so this Bo array will come here or you can do it like this that's fine that's fine board array is now created now when when I'm reading this snakes right so I I have to update the board array so I can say Okay Board of head in case of snake the snake is going to bite from the head right so Board of head will store a value that is equal to because now it is giving you a decrement so from 17 you going going at four right let's look look once again from 17 you are going at 4 so Board of 17 you should say that my value is nothing but 4 - 17 so this value should be -13 so this is how it should be so it should be equal to tail minus head so tail is a small value head is a large value so this value needs to be negative this will update the board array for uh snakes similarly we need to update the board array for letterers and we will utilize this array while constructing the graph I will show you how make a similar loop I have the letters instead of next here I will have letters now the letters are given in this fashion bottom to top so letter also has a head and it also has a tail so tail is this number is smaller this number is bigger tail minus head would be a positive number here that is fine so I think board array looks fine so I can just display you the board array as well I can say s out arrays dot two string and I can give the board array now I have this board array I have these Delta increments again I need to figure out how do I insert all the edges now that thing is fairly simple you need to go to Every vertex and create the next six edges that will start from that vertex for example if I start from five or if I start from I I can go to I + 1 plus both of this position that you have reached if you do 5 plus let's say some number five or 5 + 4 You Reach 9 but 9 is not the end position you actually reach 27 right I + 2 plus Board of this position I + 3 up to up to I + 6 basically from I node where I can go so here I'm going to use the board array to decide where I can actually go so this will be Board of I + 1 Board of I + 2 and so on so let's see here as well so let's create the graph now so I have graph G how many vertices I have I have V vertices I'll just keep V + 1 because it is one based so we we are also adding zero here this is equal to new graph new graph of V + 1 vertices all right I have to add edges right right so I can okay for INT let's say source which starts from or let's say I'm going to add edge from I to something so I to some J okay so if I goes from I can start from source which is one the smallest node I can go till less than destination that is my last node i++ I'm going at every node and I can throw a dice at every node I can throw 1 2 3 4 5 6 I can throw a dice dice can take a value one the maximum value dice can take is six and I can say dice ++ so what is the node at where I'm reaching the jth node is uh I + dice right but this is not final I also have to add Delta so I can okay J equal to uh J + B of J in this value what I'm I'm saying is from I you throw a die you reach i+ dice now at this position it is possible that there is a letter the letter gives you a jump of 13 so you have to add this VOR also that is stored in Board of J but if there is a snake that takes you down so you have to decrement this value also that addition subtraction is already handled in the board array now if J is less than equal to destination that means I do not want to add any Edge that goes out of of the board so I can say G do add edge so U is my i v is my J and uh it is a it is not undirected graph so this value is going to be set to be this completes the graph creation process now what we need to do we need to run BFS algorithm on it so as you know we have already implemented the BFS algorithm I'll just copy this code and tweak it a little bit so that we can do it for this particular problem I can say BFS shortest path so in this case I'm getting Source I'm also getting the destination so if the user is interested in finding out U minimum number of moves so you do not need to print distance every node you can simply return the distance of destination and you can change the return type to integer this can be done now one thing might ask ask is user might ask you to give the path also as I discussed with you along with the visited array you can create a parent array as well and you can say okay this is equal to new new integer of v and here you can say okay for first node that is my source node the parent is let's say minus one so parent of source this is minus one or you can set this is the source itself something like this so that you can know right right now I can I I'm just saying this is going to be minus one and whenever you visit a node you can set the parent parent of neighbor is going to be the node now as I told you you can back track and you can find out the complete path as well let us discuss that thing as well if you want to do the path printing that is fairly simple you can start from the destination node let's say 36 now 36 nodes from where I was visited so maybe the parent of 36 is 30 right so I can start from this node Reach This node again Ask the parent go back go back and so on I can trace the path until I hit one or minus one something like that so I can say fine uh I take a temporary value which is destination and I can say while parent of destination or while parent of temp is not equal to minus1 what do I do do I say okay fine I will print out the destination I will print out the temporary node so basically what I'm saying is temporary node is this temporary node is 36 I will print it out and I will go here this will become the new temporary node but how do I update this temporary node so fairly simple temp equal to parent of temp at every node I take it back to the parent so this is basically going back to the previous node in the path how it was disced covered then I'm saying return the distance of the destination now let us go and run this code I think it should be fine yeah it seems fine so let us try to execute the code so I've given the input I've just combined the input and I'm giving it but now I'm getting a error actually I'll will tell you what what is the error so it is saying exception in thread main index 38 out of bound so in main this is the array so this is going out of bound why this is happening because if you add something to let's say node 35 you say okay I will take a jump of three you will actually reach 38 so actually I'm checking it here so instead this check should be done here right so when I'm doing this value when I'm Computing this J so I should do this thing here if J is less than equal to destination then I should do J equal to board of J and again I should check if J is you can do it here and that is fine so if J is now less than equal to destination then you can actually add that edge I think this would be okay or you can do uh two conditions here right you need to check that see what is happening is I added something here I said okay 35 + 2 or 35 let's say 33 + 2 okay and Suppose there was a letter here right it might it's not going to take you out but but what I'm checking is that when I'm adding this value Board of J J must be less than destination and when I'm adding The Edge that edge must be less than destination let me run the code okay so I think I commented out the shortest path let's rerun this code and uh it should be good to go now so we do not need to print each and every node while reversal right one more attempt and then we should be good to go we are doing BFS we are printing the out outut of reversal which we don't want so let's paste the code and here we are getting yes this is the correct output so we are getting the path and we are getting the shortest length that is going to be four if I show you this is the path that we are getting from 1 we went to 15 29 30 and 36 and it took four number of moves four moves were required to cover this you can verify also 11 15 29 30 36 from 1 we went to 15 then we went to 29 then we went to 30 and then we went to 36 yes these are the four moves that were used so I really hope you understood this algorithm really well and the application of VFS we have seen through this problem let's try to understand this algorithm called depth first search or sometimes called as depth first traversal so it's an algorithm for traversing the graph or searching the graph it can be used on tree so on tree the pre-ordered reversal that you have done it's actually a depth first search algorithm starts at root node so in in case of graph there is no root node so you can arbit you can select any node as the root node and or you can have a some specific node and you have to explore as far as possible along each branch before doing the back tracking so we'll try to understand this through an example and of course this algorithm since you are doing it recursively uses extra memory which is usually a stack so if you're using a stack in case of recursion it will be created automatically even if you are doing this algorithm iteratively you can maintain a stack like data structure and do the work which is needed to keep track of nodes discovered so far along a specific branch which helps in the backtracking in the graph we will understand this concept when when we are running through the algorithm and this DFS has many applications some of the applications I've listed down here it is used in finding out connected components you can also use BFS here basically you want to look at what components of the graph they are connected so for example if this is a graph this whole thing is one graph it has two connected components so you can do a reversal from this node which will actually visit this whole component and you can do a reversal from maybe this node which will visit this whole component so we'll do a separate tutorial on connected components topological sorting it can be used it it is also used in finding out bridges in a graph cycle detection it can be used we'll look at cycle detection in this tutorial strongly connected components is a different concept which is used in directed graphs so DFS again is used there and it can be used to solve puzzles with only one solution such as mazes maybe you want to find out a path in a maze maybe there is only one solution so you can easily use DFS along with backtracking to find out that particular path it can be used in maze generation with the randomized DFS algorithm and it can also be used in finding by connectivity in graphs so let us try to understand the algorithm next so DFS can also be used on a tree so if you have this tree so what this DFS will do will it will start from let's say root node it will go in this direction here here here then it will backtrack and it will enter into these branches so it's just like a pre-ordered reversal that we have have done on trees but in case of graphs the situation is little different why because graphs can contain a cycle so we have to see what to do in case of a graph let us try to understand with the help of this graph how DFS will actually work let me draw the adjacency list as well that will be input and that is how the graph is actually stored with zero we have the neighbors which are 1 and two with one we have the neighbors 0 and four with two we we have the neighbors zero three and four with three we have the neighbors 2 and six with four we have the neighbors 1 2 and six five we have only one neighbor that is four with six we have two neighbors that are three and four so this is how the adjacent list of the graph will look like now we need to understand how this DF is is actually going to work so we are going to start from this node it can be any node so I'm going to take zero as the starting node from The Source node and now since the graph can contain a cycle I need to maintain a visited array I'm just drawing it here so initially nothing is visited so this is a visited array 0 1 2 3 4 5 6 so I need this much array right I I'll call it visited this will help me to ensure that I do not visit the same node again if it is already visited we'll just backtrack we'll go back I start with zero I said fine I will mark this as visited and since it's going to be recursive algorithm so this node is in the stack now zero can say okay what are my neighbors neighbor of zero is one it will pick this node the first node I will try to iterate but first I picked one and I will make a DFS recursive callon one I will go to this note I'll mark one as visited one is is in the stack also and now from one I can go to some neighbors right so one's neighbors are zero zero is already visited so I'll not go here I will if I go I just come back right so I I say okay this or I will not go so this node is not visited this zero is already visited so I will not make a call but what about four four is visited so I'm iterating on this list four is visited right so I make four is not visited I make a call on four I go and visit this node four so four is marked as visited and four goes into the tack so I think on the diagram you should also see a zero here before one you have a zero right so this this portion got little cropped out from the screen 014 this is how the stack looks like at the moment at four I again do the same work I look at what are the neighbors of four the neighbor of four is one which is visited so don't do any work the neighbor is two which is not yet visited now what four will do four will visit two I'll go and visit this node so two is visited and two is now part of the stack now at two I look at what are the neighbors the neighbor is zero which is visited the neighbor is three which is not yet visited so I go to three this note I mark this three as visited and I come to three what are neighbors of three so it is 2 and six two is visited I don't do any work six is not visited so I go and visit six I go here so six is marked as visited so three is three is in the stock six is in the stock now at six I look at the neighbors the neighbors is three which is visited don't do any work another neighbor is for which is also visited so don't do any work now what I can do so six is already visited and six does not have a neighbor which is not yet visited right so what you will do you will go go back this is important so this is backt tracking so you come back at 3 so from 6 you are now coming back at 3 so 6 is popped from the stack now at three you look at I was running a loop I was trying to Traverse the neighbors and I already went and explored six so this is over so from three I cannot go anywhere else this list is over so I will just go back I will backtrack I will come back at two so at two I see okay I was at I went to three three is visited can I go to four four is also visited so I cannot go to four so two's neighbor have been visited so I can say okay just let's just go back from two I go back to the previous note so before two I I came from four so I come back at 4 this is backt tracking now at four I can okay I went to two so two is visited what about six sorry what about five this neighbor is five actually Four has a neighbor that is five four has neighbors 1 2 6 and five five and six actually Four Neighbors it has 1 2 3 4 yeah four has four neighbors it will look at five can I visit five the answer is yes I can visit five so four will make a call at five and five will say okay I'm visited now so if I talk about the order right so it it was like 0 1 2 3 6 and then sorry 0 1 01 4 2 3 0 1 4 2 3 6 and now you are actually visiting five right you're now visiting five from six you come back three you come back to two come back to four and now four will say okay four has a neighbor that is five it is not it visited it will go and visit it and five will say okay I can only go to four but four is visited hence I will go back so it will simply return I I go back to four now four says okay five is visited what about six six six is also visited six is not visited by four but it is visited by three it will not go to six also now four says okay all my neighbors have been done I will go back it will come back at now 1 right so here after four you went to five five is over four is over now you come back at one one says okay all my neighbors have been visited now I will just pop I will come back at zero now in this T you are in this function Zer Zer says fine all my neighbors one has visited now zero looks at two two is also marked visited in this array so it says okay my list is also finished I'll just go back so this is also popped off from the call St this is how the DFS algorithm works and given this adjacency list this will be the output that we will get so the idea was to Traverse all the nodes and this is what we will get get by traversing all the nodes okay so I hope you understood the algorithm fairly simple if the graph has multiple different components then we will see that you need to initiate DFS from one node in each component okay so this is something easy that can be done later on but first of all we'll focus on this simple DFS algorithm where we are assuming there is only one component okay so we are assuming one component in the graph as of now so let us code this algorithm next let us look at the implementation of DFS in Java so I already have the graph class which is implemented in the previous tutorials in this I'm going to add a DFS method and this is going to accept the source node from where I'm going to start the DFS so I'm assuming there is a single component in the graph so what I need to do so firstly I need to build build a visited array that is the data structure we will be needed so we can keep things simple we can create a Boolean visited array and this is going to be of size V that is the number of vertices in the graph so initially everything will be said to false and in Java by default the Boolean array is false now I actually want to do this traversal recursively I cannot make this as a recursive function because I cannot create this array again and again in the recursive function so what I want I want this array to be shared across all the function calls that I'm making for that is why I need to create another function which is going to help this DFS I can call that as DFS Helper and here I'm going to get the source node or the node the current node where I am and the Boolean visited array so this array will be passed and it will be shared across all the function calls right so I can simply make call to DFS Helper and I can give Source node and the visited array as input to this function right now here what I need to do as soon as I come to a note the first thing I will do is I will Mark that node as visited so I can okay I can print out that node that is fine and I can say visited of that node this is equal to true that yes I have visited this node let us take a small example let's say I have 1 2 3 and four and five let's say this is the graph so if I start from this node so I will mark this as visited and now I will look at neighbors of one one's neighbors will be let's say two and four so I'll iterate on this list and I will go to the neighbor which is not yet visited so right now two is not visited I'll make a call to two Okay so how do I do it so iterate on this list we need to create a list iterator I think this part was not visible I'll just hide myself what I'm saying is that one has neighbors 2 and four so I'll make a call at two first so how do I get that for that I need to create a list iterator first so I can say fine let us create a iterator iterator of the type integer let's call it it which is the iterator to iterate on this list so I can say Okay adjacency list of this node which is let's say zero Source in my case dot list iterator so using this iterator we can easily iterate so while I have items in this list while it do has next what to do I can okay give me the neighboring node so the neighboring node node this is given by it. nextt so I will now check is two not visited yes two is not visited so how do I check I check from the array so two is not visited neighbor then what to do I have to make a recursive call so I can make a call to DFS helper give it the node the node is neighbor and give it the visited array I'll show you what's going to happen in this scenario so I have this let's say 1 2 3 4 5 so generally in the code the indexing is assumed to be zero based but in the example I took it one based but hopefully you will understand that part so I check one is connected with two and four so two is not yet visited so one is visited so as soon as I come to one I mark one as visited then I iterate over the neighbors of one I check two is not visited I make a function call on two so two is now visited now I look at neighbors of two so two has Neighbors which is one and three out of this one is already visited so I don't do any work so I'll make a call at three so as soon as I come to three three is visited and three has neighbors again two and four so three looks at okay two is visited so I'll make a call at 4 at 4 I have again Neighbors which are one and five so four says okay one is visited don't do any work make a call at five so four visits five so five is now visited now five has only one neighbor four which is visited so this Loop will not run for five because it will iterate on four and four is already visited so this if will not execute and while will not do any work so you will simply return right so from here you will come back so you come back here now at four you see five is done the list of four is also finished so this Loop is over four goes back to three so three says okay I can go to four this is also done so three three's Loop is also over you go back at two so at two you have gone to three that's also done now Suppose there was a note six here right what will happen now two will see okay yes I can go to six so two will go to six and six will get visited and you will come back right and of course these nodes are also marked visited this Loop is also now over now at two you will say okay my list is done I will go back it will go back here now one will look at okay can I go to four but four is already visited hence you do not go you do not make a call at four so this Edge is not considered and at one you can see okay this list is done because four is also visited and hence I go back this is how it will go back into the main so in this case the output would look like 1 2 3 4 5 and then you have gone to six as well right this is how the DFS is going to get performed using this code now let us test our code is does it work fine or does it work as expected you have understood DFS on graphs next thing we will learn is how do we do cycle detection on graphs basically we will do this algorithm of cycle detection on two types of graphs one is on undirected graph which is given here and secondly we will do it on directed graphs in which the algorithm will change a little bit this graph is an example of a undirected graph so now how do I detect a cycle in this I can use BFS or DFS right if you remember the fundamental difference between a tree and a graph is that a tree is always not containing a cycle tree does not contain a cycle but every tree is also a graph basically if you you have a cycle in a tree it becomes a graph right and every tree is also a graph so if I give you an example let say this is node a it is connected with b and it is also connected with C so right now it is a tree right and it is also a graph but if I add this Edge it definitely becomes a graph right it is not a tree now because it contains a cycle right so now what is the significance of cycle or how do we detect a cycle so it it is pretty easy let's say I start traversing this using any algorithm let's say BFS or DFS let's say I start with a and I make a DFS call on its child that is B at B I make a DFS call on its child C and C will now look at its neighbors it will see okay I discovered a neighbor right now C has two neighbors so one of the neighbor is let's say B right so if C looks at B right B is already visited but is it really a cycle the answer is no I cannot say that this Edge is going to create a cycle the answer is no right let's say there is one more Edge from C to d c makes a call at D and it visits D is this Edge causing a cycle basically the answer is again no right what is the difference between this Edge this Edge right so basically before visiting d D was undiscovered D was not visited but B was discovered B was discovered now suppose I create one more Edge which is this Edge right so if I now C makes a DFS call on let's say a right but as soon as I make this call I see okay I'm landing at a node which is visited and I can say it is a cycle right it is a cycle right basically what I'm trying to say is that B was also visited D was not visited so here we are sure there is no cycle but here the answer is no because B was discovered but it was parent of C it was parent of C right was parent of C whereas from C when you go to a a was already visited and a was not the parent of c a was not the parent of C in the DFS call so this is the condition that if we encounter a node which is already visited and it is not the parent of the current node then we can definitely say yes there is a cycle that is present right so let me dry run this algorithm on this graph so let us create a adjacency list so Zer is connected with let's say 1 and two one is connected with 0 and 4 two is connected connected with 0 3 and 4 then three is connected with 2 and six then four is connected with 1 2 and six then five is connected with just four and six is connected with three and five right now suppose I start doing a DFS from node zero and I want to check if there is a cycle or not I start from this note zero I said okay go and make a call at its neighbor so one is the neighbor it is not visited so right now my goal is to itate on this but I make a reest call on the first note that is not visited so one is not visited I go here now at one I look at the neighbors the neighbor is zero but if you look at zero 0 is already visited 0 is visited but Z is also the parent of one so hence we we have to skip this node we will not do anything at zero what about four four is not yet visited so I go and make a DFS call at four right now we come at four four is now marked marked as visited one is visited zero is visited Four's neighbor is one so I will not do any work like C's neighbor is b b is visited four is one is visited but one is parent so we will skip it what about two two is not yet visited so I can go at this node and I can mark it as visited right now look at two now two has a neighbor that is zero now this is an interesting case Okay so two has a neighbor that is zero so I will draw this Edge separately I'm going to mark this Edge in red the two says can I go to zero what is the condition at zero 0 is already visited right and zero is not the parent of two right so basically you are hitting this Edge we will call this Edge as a kind of of a back Edge right so it is taking us back in the same path from where we started or to one of the ancestor nodes okay so it is an edge from the current node to some ancestor node why ancestor because if you look at the path that we have traced is 0 1 4 2 and then from two we are going back we are going at zero this is like a back Edge right as soon as I get this Edge it will be the terminating case right so at this point I can directly say without looking at the rest of the graph yes there there is a cycle so this is going to return true okay so I'm going to say okay I'm going to return a true from this node two so this true will be told back to four okay so two will say okay that yes I found a cycle okay so what four would have said that okay I do not see a cycle in my I am not seeing the cycle as of now but let me call a neighbor and check if it can discover a cycle so two discovered a cycle so that true is returned to four four will also return true one will also return true and zero will also return true right because it's going to be stack based algorithm so this true will be propagated back to the main in this manner right so there will be a base case there will be a recursive case let us try to write the code and understand this algorithm in little more deta so let us write the code for cycle detection I'm going to make a Boolean method which is let's say detect cycle and here I need to give some Source node from where I want to start right or you can take zero as well right so we are assuming that the nodes are numbered from zero and uh we can ignore this Source we can directly give zero as well right so now since it's going to be a recursive function like DFS right so one thing we did in DFS was we maintained a visited array so we here we also need to maintain a visited array that will tell whether node has been visited or not the Boolean visited this is equal to new Boolean and the size is let's say V right so by default this visited array set to Falls in Java so I'm not explicitly setting it and here I can say okay I'm going to create a helper method detect cycle Helper and I'm going to give it a node let's say zero and I'm going to give it the visited array right so this is this method is just like a rapper function because we need to create we the visited array and this needs to be shared across all function calls so we are going to make a helper method Boolean detect cycle helper it's going to accept the node and second thing it's going to accept as the Boolean visited array so now here we will return some true or false right so let's see how this is going to be so first of all when you are encountering a note for the first time so definitely you should Mark that node as visited so visited of node this is equal to True next thing you will do is you will iterate over the adjacency list of that node and you will make recursive DFS calls right so let's see how we can do it so just like before we have done here here right so I'll show you so you will create a iterator to iterate on that node right or like in DFS right something similar we will do right so I'll just copy this not code and I'll show you what modifications you need to make in the DFS code right so here we go so we have created an iterator to iterate over the adjacent list of the given node and then what I'm saying I'm finding out the neighbor right so if if the neighbor is not visited now here the call will be different okay so if the neighbor is not visited I will go and visit that neighbor and I will also store the result what that neighbor is saying for example let's say one is connected with two two is connected with three three is connected with four and four is again let's say connected with one right so I will make a call at two that is the neighbor now this two is supposed to return some result back to one right so that result can be true or it can be false two might have called three three might have called four four might have called one and here it saw yes there is a cycle so true true true that will get propagated back right so if the neighbor is not visited definitely we have to go and check that okay yes is there a cycle at that node or not I can say Okay Boolean I can say um cycle found it's something like this so did it find a cycle in in in in that part of the graph right so here I can make a call to detect cycle Helper and here I can give the node which is going to be the neighbor and I'm going to give the visited array right now this is like a recursive case you called some node that node said yes I found the cycle if the answer is true if cycle found is true you can directly return true from this point without iterating on the remaining adjacency list of the current right and there is one more scenario that can happen outside this if right outside this if so it's it's like a recursive case I have written here so this is like a recursive case there can also be a base case right so base case would be that you are hitting a node which is already visited right so I can say Els if visited of neighbor this is true right this is true right and there is one more condition right so I'm basically saying something like this one is connected with two two is connected with three three is connected with four and now you said Okay I I came to this node I came to this node I came to this node from 4 to one there is an edge as soon as you discover this Edge that fine I am going to a neighbor which is already visited and this one is not the parent of four okay so Four's neighbor is also three but three is the parent of four so you cannot say about cycle at this node okay but you can say about cycle because of this Edge the four is taking me to the one which is the which is not the parent right so you can say the neighbor that we have discovered is not equal to parent of four but how do we get parent of four that is a question so this is this is the neighbor right so that mean and this is the parent so we want that this neighbor that we are discovering should not be same as parent because Four's neighbor is also three right if it is three then we cannot say anything right we we we have to skip this but this neighbor if it is not same as parent then yes definitely there is a cycle but how do I find the parent of current node right so that is a question this parent we will have to maintain in the function call by passing one more parameter right so parent and uh here we have to so when you discovered this neighbor right the parent of this neighbor is going to be the current node right so this will be node so I'm setting the parent here if neighbor is not equal to parent then I can say return to right since I'm using a l if condition here right this El if will be only executed if the node is already visited right so if it is not visited it will go here but if it is is visited it will come here so that means writing this part is optional so I can just remove this and I can just simplify the condition to be only this neighbor is not equal to parent I'm going to return R but if I come outside the Y Loop that means I could not detect any back Edge right so this is actually the point where we are detecting the back Edge back Edge and this is actually the recursive case this if condition is a recursive call that's it right this is kind of a base case that we found a back Edge right otherwise if we could not find any back Edge we are going to return false from that I think this function looks uh good to me now we have to give a parent here as well the parent of the source node we can just set it to minus one no parent right and let us dry run this code and let us also test the functionality first so here in the main I have uh this file so I have created a graph I have done the DFS simple DFS works but now I want to S out uh about the cycle detection so if G do detect cycle you can just see out s out yes there is a cycle else you can say s out there is no cycle let's go and run this code so let's see what output do we get so it says yes there is a cycle I'll show you uh this is the same graph that we have in the figure so yes it contains a cycle so so let me dry in this code for you once again I'll do it on a smaller graph let's say the graph looks like this 0 1 2 3 4 and let's say this is The Edge right you start from zero so parent is minus one you look at neighbors of zero right so you said okay visited of node this is true so this is marked as visited then you iterate over the neighbors so neighbors of Z r 1 2 one and three first we will go to one one is not visited so we make a recursive call and ask did you find a cycle one is now marked as visited and when I marked one so I said the parent of one as the node so this was the node this was the neighbor so neighbor's parent is going to be the node parent is zero one's parent is marked as zero and again same story repeats at one what do I do I make a recursive call so I ask neighbor of one right one has two neighbors one of the neighbor is zero zero is visited but what happens here is this condition true what is the neighbor neighbor of one is zero what is parent of one that is also zero so we do not execute this L if block so we basically ignore this case okay we do not do any work here then we look at the second neighbor so one has neighbors that are zero and two right so nothing happens here what about two so two is not visited so we make a recursive call right so we go to this node we make a recursive call now two is marked as visited parent of two is one now two also has two neighbors two has a neighbor that is one and it has a neighbor three so I do not if I look at one one is already visited right so I come into this L if okay if it is not visited I go here but if it is visited I come here so what is the neighbor of two that is one what is parent of two that is also one so this condition is also not true so I do not do anything here so nothing happens here we talk about this Edge 2 to three so I go to three now at three what happens three has two neighbors 0 and four so I go to zero is zero visited yes Zer is visited so I do not go into this if block I come into this else block what is the neighbor right so what is now the neighbor of three so the neighbor of three that I'm considering in here is because of this Edge that is zero what is the parent of three the parent of three is actually two right so they are not equal yes 0 and two they are not equal that means yes return true so without looking at this part of the graph three returns are true right now two got to know yes there is a cycle found so two also returns or true it goes back one also gets to know yes there is a cycle found so as soon as it gets a true it returns a true zero gets to know yes there is a cycle it returns a true back to the main so this is how this algorithm is working and I hope you understood it now we will talk about cycle detection in case of directed graphs so in case of directed graphs not just the structure of the graph but the direction of edges also decide whether there is a cycle or not if you look at this example the edges are like this and if you start from a you can go to B you can go to C but from C you are not able to go to a right and of course there is no Loop present here right so hence there is no cycle but if I change the uh direction of the just this Edge I reverse it right I can go from A to B B to C and from c i can again go back to a node I can go in a cycle so hence yes there is a cycle right now I will tell you if you use the same algorithm which you used on undirected graphs what is the problem you're going to face right it's not going to work in the same manner so let me take up one more example let say the graph is like this let's say a uh from here we have B let's say c d e f and let's say this is connected like this and let's say I have G and it is connected with let's say C right now suppose you start doing DFS from a and you say if I hit a node which is already visited I will say there is is a cycle this this is the logic we did in the undirected graph so let's say you started doing DFS you started from a you went to C okay from C you went to D from D you went to E from E you went to F and from F you cannot go anywhere else so you come back and you say okay no there is no cycle you you come back you return false right and from E again you come back D you again come back at C and again you come back at a and from a you come back at B now you go to v b is not visited right from B you go to G and from G you go to C and now you see that I am going to a node that is already visited this Edge right and it is c c is not the parent of G that means I'm going back in the path but is it really a cycle my question to you is is it really a cycle the answer is no if you start traveling from a you can come to C and you cannot get stuck into cycle from C you can go to E right so this is not a cycle or you can go to d right and go this way so this is again a case of non-cyclic graph right but if you run the previous algorithm that we executed on a directed graph it is going to say yes there is a cycle because from G you discovered a node which is already visited right hence we need to fix this algorithm right so we need to fix the algorithm for directed graph for directed now the question is how do we fix right the thing is we need to again detect back edges correctly right so from G to C this is not a back Edge right I will tell you what is a back Edge in case of a directed graph the back Edge is a edge that takes you back to from one of the node to some of to some ancestor node in the same path right from the current node to some ancestor right ancestor so let us take take another example inspired from this graph only let's say I have a I have C I have F I have D and I have e and I have F then I have let's say B then I have let's say G and then I'm pointing to let's say C and let me add one more Edge in this graph so this graph this Edge maybe looks like this let's say the edge is like this do you see a cycle here the answer is yes there is a cycle right or let me add two more nodes right let me add a node let's say h and let me add a node that's it let's say one more node I have added now in this part of the graph there is no cycle but yes in this part of the graph there is a cycle because you can revolve in this path again and again right so let us try to see what is a back Edge in this scenario right so let's say we started doing DFS from a I went to C from C I went to D I went to E from E I went to f from F I cannot go anywhere so I will just come back right so what is the state of the call stack the call stack has a it has C it has D it has e it has F now F says I cannot go anywhere so I'm just going to return false so false is propagated back then e says okay I cannot go anywhere else I will come back D says I cannot go anywhere else I'll come back he says I cannot go anywhere else I come back to a now a says okay let us go to B B goes into the Stock B says let's go to G G goes into the stock now from G I can go to c c is already visited but is it a back Edge the answer is still no right because in the current path right so if G is giving giving me a edge that is pointing back to one of the ancestor in this B stack only then it will form a cycle right so the answer still here is no so I'll will not take this Edge so can I go anywhere else okay so basically what is the condition I'm going to check here so when I'm checking g2c C is visited C is visited but C is not in the stack C is not in the tack that means I came to G via path which does not include C okay it is not in the stack that is the important condition right now G can say okay let me go to H H is not visited fine H goes into the stack now H says I can go to a so what is what happens here we are going to a node that is visited and that is also in the current path right that means from H I can go to a from a if you a again you can go to h a b g h that means these nodes will form a cycle a b g h right what is the condition to detect a back backage so I will say okay in this DFS reversal this Edge from Edge to a this is forming a back Edge right because I'm going back to one of the ancestor nodes right the condition is from the current node to some ancestor which is in the stock we have to check two things we have to check that this node a is visited and a is also present in the stack a is in the tack right if both of the conditions are met we can say yes there is a cycle and recursively H will propagate back so H knows yes there is a cycle G knows yes there is a cycle B says yes there is a cycle and a also tells back yes there is a cycle so this is propagated back there is a cycle so again this can be implemented recursively but how do you check whether a is in the stock right so we cannot directly look at the recursive stock so what you have to do is you have to maintain another data structure either you can maintain a hash map or you can simply maintain a array right so whenever you are hitting a node you mark it as visited okay so when I hit a so these nodes will remain visited right but when you're going back when the nodes are getting popped from the stack you can remove that node from the stack array also right I can simply create an array called instock so if you're visiting a node next you can Mark that yes it is visited but when you're going back you're backt tracking for example when you went back from C you can say yes this node is not in the stock right so you have to maintain two Boolean arrays one for visited one for stock while backtracking you will unmark from the stack are right so I'll write the code first then we will do the dry in but but I hope you understood the concept that here just being visited is not sufficient we also have to to check whether the node is in the stack or not right so this is the main tweak that we will use in this algorithm