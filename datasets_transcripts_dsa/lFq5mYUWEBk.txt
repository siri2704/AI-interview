we looked at general tree in last tutorial where we went or electronics product category example and we implemented a code in Python for general tree in this tutorial we are going to talk about binary tree especially binary search tree this will be two part tutorial in this one which is part 1 we'll go over search and insert operations will go or some theory first and then we'll do coding in Python and as usual we have an interesting exercise for you to solve so make sure you watch till the end in the part 2 we will cover the delete operation let's get started first we need to understand what kind of problem does a binary tree solve well in many programming languages such as Python there is this thing called set and set is more like a list the only difference is that when insert elements in the set it makes sure those elements stay unique so for example if you are at rating 3 you through this kind of contrary records if you just told them in a list then you can have duplicates like this see India is our repeated two times USA twice but the same thing if you store in a set the set will remove the duplicates so this is an important data structure which is available in Python Java different programming languages and you will find it very useful now internally to implement set one of the ways you can use is binary search tree so binary tree is nothing but a regulatory with a constraint that it has at most two child nodes here this node 12 has to charge node 7 and 14 20 has only one node 23 but which is okay the maximum number of on child nodes that a particular node can have is 2 if you look at our example of a electronics product tree here say cell phone had 3 nodes so this is not a binary tree binary tree is this ad makes two notes now binary search tree is a special case of binary tree where the elements have some kind of order here the order is all the nodes on the left-hand side of this particular node has value less than this particular node so 15 if you look at this whole left tree all the element values are less than 15 and on the right hand side the values are greater than 15 and that applies to every node if you look at any node less at this this no 27 on the left hand side you have values less than 27 which is 20 and 23 right hand side you have values greater than 27 which is 88 another property is elements are not duplicated so if you try to insert 27 again in this tree it will not insert a duplicate the elements are always unique now in this tree if you want to search for number 14 what you can do is you can start with root node 15 and then you can see if the value that you are searching for is less than or greater than 14 is less than 15 hence you are sure that it will be on a left subtree so then you go here you find 12 now 14 is greater than 12 hence you know it has to be on a right hand side this way what you're doing is in such operation which is very common in computer application whenever you are writing software searching through a list of elements is a very very common operation and you want to make sure you do that search in an efficient way if I had store all these numbers in a single list then finding element or searching an element might be linear complexity because if you search elements one by one then your complexity will be order of n but if you search this way then what you're doing is every time you are reducing your search pace by half for example here when you decided that 14 will be in a left hand side tree you eliminated searching right tree so you eliminated you eliminated these four elements are right on a first go so thinking about such complexity since we reduce our search space by half every time let's say you have our number of nodes in a tree is 8 when you search for an element when you make a decision whether the element is in a left tree or right tree you are reducing the space by half so now your space is 4 then in that tree when is further searched you make the search space by 2 1 so 4 if the total number of nodes in your tree is 8 you can search an element in 3 iterations and 3 compared to 8 is nothing but a log to the base 2 hence the search complexity in binary search tree is order of log n which is very efficient operation like if you think about it for 8 you achieve your search result in only 3 iteration if you had done linear search you might have to do a titrations now let's talk about inserting an element let's say you want to insert number 13 in this binary search tree what you can do is first compare it with 15 you know that 13 is less than 15 hence you want to put it in a left subtree so you will come here now you realize that 13 is greater than 12 so it will go in a right subtree then you come to 14 here and then 13 is less than 14 so you insert it in a left subtree of 14 here the insertion complex the city is or also order of log n there are certain terms associated with binary tree in general such as level depth number of elements and there is this great video which will clear all your terms so I highly recommend watching this video I'm gonna provide a link of this video and a video description below if you want to search through the binary search tree there are two approaches you can take one is breadth breadth-first search and the second is depth-first search these are also called traversal techniques which means how do you traverse your binary tree to find the element that you're looking for in this coding tutorial we are going to cover in order traversal which is a depth-first search traversal technique so let's go over this depth first search traversal techniques a little bit so let's say if you have a tree like this in the inorder traversal what you do is you see when you say in order or preorder or postorder you are referring to your base node so here the base node is 15 when you are doing inorder traversal you try to make sure this 15 node is in the order which means you first visit your left subtree then this particular node and then right subtree in in pre-order traversal actually you you visit your root node first then left subtree and then right subtree and in the post order you visit your left subtree then right subtree and then your root node so for example in inorder traversal okay what you do is first you take left subtree so when you are traversing this particular node 15 you come to your left subtree now how do you traverse left subtree well you apply recursive technique here so here again you apply the same rule for 12 the left subtree 7 so first uses 7 then use it 12 then use it 14 so you get 7 12 14 now your left subtree is done so you visit root node which is 15 so you see 15 here then you visit a right subtree ok right subtrees these four elements okay they're also you apply recursion and you first visit left subtree of 27 which will be 20 and if you recurse if you traverse that you will get 20 and 23 then 27 and then then 20 then 88 in pre-order you first visit the root node which is 15 then left and right subtree or remember we always visit left subtree first and then right subtree we never do right or right first and left after that in any of these techniques so that's an easy way to remember left and right there always in sequence left comes first right comes second now pre-order postorder in order is decided by where do you put your root node in between your left tree and right tree if you put your root node in between left and right tray it's called in order if you put your root node before left and right subtrees called pre-order so this is pretty easy to remember now let's get into coding here I have defined binary search tree node class remember we are implementing a binary search tree so there is a general tree which can where a node can have any number of elements binary tree will have at Mach max two elements and binary search tree is a binary tree with a specific order we're left search tree has all the elements which are less than the current node and the right hand side has all greater elements so when you add a method called called add child here what I want to do is here I have this node okay it could be a root node it could be any node in the tree and whenever I want to add a child with a value data I need to check the value first so what I need to check is if data is equal to self dot data which means the data that I am adding a that value already exists see if value already exists then you don't need to add anything because binary search tree cannot have duplicate elements so here you just simply return but let's say that is not the case and the data that you are adding is less than the value of current node what this means is here we'll have to add this value which means data in left subtree okay and if the value is greater than then add data in right subtree correct okay now let's write cool to add it in a left subtree so now left subtree first you need to check if your left element has some value which means you are not a leaf node okay if you are in else case then it means that your left node is empty okay and if left node is empty then it's very simple you can just say self dot left is equal to binary search tree node of value data so tree is a recursive data structure hence you can just create a tree node and that node will have a value is equal to data so if you look at the constructor data goes into cells or data and then left and right child would be none and you created that node and assigned it to self dot left but let's say self dot left already has awesome tree some value then what you will do is you will say self dot left dot think about it what will you do here well you will recursively call a child method with value data because self dot left itself is another small subtree which will have had a child value so you can call that method with data and it will go into recursion it will go come here and you know it will just work out similarly you can add code for your right subtree it will be very similar code okay and once you have done this now what we are going to do is now I will implement inorder traversal method because using that method I can print all the elements in my tree okay so I will define this method call in order traversal and here this method will return a list of elements in your binary tree in a specific order okay so let me just call elements as elements so my goal here is to return these elements and here here I want to fill this list with all the elements in a binary search tree in a specific order now what is the specific order in order traversal means first you are visiting your left subtree so you need to check if self dot left meaning on the left hand side you have some elements then you can say elements is equal to self dot left dot in order traversal it will require some thinking to understand this recursive method when you say elements is equal to elements plus something this method will return some list and it will add that list to this particular list now here it will call this function recursively and when does a recursion end well we need to write some more code here so just assume that this method will work okay so just leave this far aside in order to means you visit area left tree then you visit the B's node and then you visit the right tree so let me write it down so visit left tree first then visit the base node which means this particular node and then visit right trick okay so let's visit the base node so the base node is nothing but in the elements you a plan self dot data which means this particular node has a value data and that I want him in certain elements so inserted elements from the left subtree then this particular node and now I will do same for right subtree so if self not right then elements is equal to elements plus self dot right dot in order traversal here I have written my main method that I had these list of numbers and I want to build it tree out of this okay so let let me write a helper method called build tree and this bill tree takes elements as an input and this will build that tree for you so your root node will be your binary search tree node let's say you assign the first element here as a root node and then you run a full loop on elements which are from ring which are in range 1/2 the length of this elements okay so we are going through this list and building the tree and to build a tree we already added add a child method here so here you can just simply say add child and then once the tree is build you return this root like this okay so here I can now say numbers 3 is equal to bill tree with numbers and once the tree is built I would like to print it and the way you print it is by doing this travel LC if I do in order traversal this particular method if you look at this method it returns all the elements in the tree in a specific order in an ascending order okay so let's run this code and see how this goes great so you realize that when I give this list it will build a tree and then when you do in order traversal it returns a list in a sorted order so one of the utilities of binary search tree is to sort the elements in the list the other utility is of course to implement set type of class where the elements are unique so here if you give same element let's say I give 18 and 4 it will remove those duplicates see 18 and 4 appeared only once so to implement set this can be very useful now I am going to implement a search method here in my binary search tree class where you are searching for some value now the first thing obviously that you do is if he of yourself dot data is equal to the value that you are searching for then you are lucky you can just return true here but let's see if the value that you're searching for is less than self dot data what does this mean well this means value might be it's not guaranteed to be but it might be in left subtree okay and if value is greater than self dot data then it means well might be in right subtree okay so if it is in left subtree how do you implement it first you check if self dot left in my left subtree do i have any content okay let's say that is yourself not left is none you know you don't have anything which means you have you have reached an end and you can safely say return false which means this value doesn't exist in my tree but what if there is a left subtree well in that case you can't again call a recursion you can say self dot left now in my left subtree search for this value well okay so i hope it makes sense it will do a recursion it will further go into left subtree and run the same function see this search is the same function that you're calling and this concept in computer science is called a recursion and you'll do the same thing for your right subtree as well now let's taste this method to see how this looks so I did this travel show now I will do this so numbers tree here numbers tree or search okay let's search for value 20 and when I run it it returns true because value 20 exists in this now how about 21 when I run it it will return false because it doesn't exist 200 also doesn't exist so this makes your search operation very efficient you achieve order of log and search complexity which is pretty good Here I am showing you example of binary search tree which contains string okay so it's not just for numbers you also use stringers and elements and here I have all these elements here and I'm checking if UK is in the list and if Sweden is in the list okay so here you clearly know UK is very easy okay you guys here Sweden Sweden there is no Sweden okay so let's run this code and see what happens so here say UK is in the list none okay so looks like we get none because here we need to return this so this is what I was missing we need to return at this particular value okay so that return was missing and that is the reason we saw none so let's run this again and here it is saying UK is in the list true Sweden is in the list false if you want to print this particular tree in a sorted order you can say country tree dot in order traversal run it and you just sorted your countries by alphabetical order in Python you can do less than greater than type of operation with string string as well and that is the reason you are seeing this countries list you know in a sorted order that's all I had for this tutorial now the most interesting part of this video tutorial it G which is an exercise I had this exercise for you what you need to do here is the binary search tree node class that I implemented in this video tutorial if you right-click on this this is available here you can see that the whole class is available you need to enhance this class and add following five methods Fineman fine max will find a minimum and maximum element you already know how to traverse the tree so you need to traverse the tree and just find a minimum element you think about it if you keep on going left left left left the left most node or left most leaf is actually a mini element maximum is the rightmost leaf in your tree calculating some means you just Traverse through the tree and just take a sum of all all of that and we already implemented in this class in order traversal so this method you can modify a little bit and you can get post order and preorder traversal easily so work on this exercises on your own first and then you can verify your answer with my answer by clicking on this solution link the link of this particular exercise is available in the video description below so please go check it out in the next tutorial we will cover the delete operation in binary search tree and we'll have some more exercises thank you for watching