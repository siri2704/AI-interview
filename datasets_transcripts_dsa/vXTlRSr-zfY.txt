[Music] hello guys welcome back to te do and in this video we will look at lowest common ancestor of deepest leavs problem which is from lead code number1 123 uh this problem is not clearly mentioned so there are multiple assumptions uh which will clarify this question which I will be mentioning after going through the problem statement now if you are a complete beginner to this topic then you should consider solving uh lead code number 236 first and then come back to this problem it is lowest common ancestor of any two notes in a binary tree I have already made a detailed video for the techniques required and the link for that it will be present in the description below you can just find it out now let's read the problem statement in this problem given the root of a binary tree return return the lowest common ancestor of its deepest leaves recall that the node of a binary tree is a leaf if and only if it has no children and the depth of the root of the tree is zero if the depth of the node is D the depth of each of its children will be D + 1 okay the lowest common ancestor of a set s of nodes is the node a with the largest depth such that every node in s is the sub tree with the root a depth and height are very similar terms if you look at the bottom reference and you you look up then that is called height and if you are present on top and when you look down then that is called called depth okay that is the only difference between depth and height if you look at this tree then in this case the deepest leaves are 7 and four and the lowest common ancestor between them is two and that is why two is the answer right so in this case we will be returning two as the only node but the output will be showing the entire sub tree which is 274 okay so that is how the output has been formatted now if you look at the constraint it is saying maximum 1,000 value starting from Z and all the values will be unique right so even if you end up writing an N Square algorithm it will become 10 ^ of 6 less than 10 ^ 8 so it will pass within 1 second now let's uh look at the assumptions the first assumption is if we have only one deepest Le example let's say five then the LCA will be taken between the same node five and five which will be five if you look at this example there is only one deest leaf three and the LCA between the three and three will be equals to three right but if you assume it more correctly then maybe uh you would be confused between three and two because the deepest two leaves are three and two right but the problem fails to mention and clarify this thing that if even if there is one node uh you have to take the LCA between the same node I mean that node itself will be the LCA the second assumption is the deepest leaves always assumes the farthest two leaves at the last level so if you consider this tree then at the last level you have 7 8 9 10 11 12 you cannot just take any pair of notes and try to find the LCA it is asking you to find the LCA between all these noes and if you know the property then the LCA between all the notes will always be equals to the LCA between the two farthest nodes that means 7 and 12 okay so that is how it is uh you have to see what are the first and the last node at the last level and you have to just find the LCA between those two noes and in this case it happens to be zero fine so this is the highest LCA that you can get highest means in terms of height when you move bottom up this is the highest LCA fine so these are the two things which are not clarified in the question I hope this is clear now now just to recap about how to find LCA between A and B there are two common strategies to find it one is the common path method in the common path method uh we can start with the root node and we can maintain a path value and as soon as we see that zero is actually present in any of the LCA then we have found a valid path okay but zero is not so I will be making a left call and I will be inserting zero into the path one is also not matching insert one into the left part it it will become 01 now three is also not matching so you will be backtracking to one and make the right call to four so the path here will be 0 comma 1 now since four is matching with this four so one of the path which is for four will be 0 1 0 1 and 4 right now again you backtrack and try to find the other other element right which is five now you go back to zero when you go to the right side your path will have zero is 2 equals to 5 no go to the left side and include this two 0a 2 is 5 E equals to 5 yes so for five as well you have found the path which is 0 25 so you have recorded both the paths so the lowest common ancestor will be move from left to right and find the last common node and that will be the LCA right so the LCA between four and 5 is zero in this case this is one way now another way to find the LCA is the guaranteed pair DFS method in this case it will only work if the pair of nodes are actually guaranteed to be present in the tree now according to this problem we are trying to find the uh LCA between the deepest leaves so first I have to find out the deepest leaves isn't it so if you are finding out the deepest leaves then you know that they exist otherwise you will not be able to find it and therefore the guaranteed pair DFS method will work here because the two nodes will be guaranteed to be present in the tree now let's say that I try to find uh I mean the LCA between four and five using the DFS method I will start from here and I will match if it is matching with any one of them I will return true but it is not matching so I will go to the left side match it with one yes it is matching right so if it is matching with one you return a true immediately right now go to the right hand side and search for uh four right and why are we not searching on the sub tree of one because I know that if I cannot search for anywhere then it must be in the sub tree of one and in that case one will become the LCA right so I'm searching elsewhere if I search at two then two is also not equal five is also not equal so this will return false six is also not equal it will return false and then it will return false so take the r of false and true and this will return true but we did not find any node where we get true from one side and another true from the other side because if you have a node X which gets true from one side that means you found one of the node on one side and another node on the other side this means X is the LCA but there is no such node and and that is why one will become the LCA if you take a dry run on this 4A 5 then I can start at this zero I can keep finding keep finding this will return false and keep finding and this will return true okay so this will be returning a true fine now on the right side keep finding and this is returning true because five is matching and uh this will return false false or true will be true now the first node where you found uh true from both the ends the only node where you find true from both the ends is zero and that is why the LCA will be zero in this case right so I think the guaranteed pair DFS method is also clear now once you have learned about it then you can use BFS to do level order traversal and find out all the notes at the last level so you get that all the notes at the last level are 7 8 9 10 take the first node last node and apply your DFS technique the guaranteed pair DFS and find out the LCA between 7 and 10 and that will give you the result you can also enumerate the path record the path root to node path for both seven and and 10 and take the last common uh node value right so that will also become the LCA in this case we are traversing over the tree two times and that is why the time complexity will be order of n space complexity will also be order of n because of the call stack and the tree can be a skew tree and also because of the BFS the last level can have half of the total of the tree nodes in case of a perfect binary tree perfect binary tree right so this is one solution that you can do a better solution could be based on the height you can say right height or depth whatever you say so if you know that at zero at node zero if the left sub tree height is same as the right subtree height then what can You observe you can observe that the deepest leaves on the left side and the right side will be at the exact same level will be at the exact same level that is why the left sub tree height and right sub tree height are same and if that is the case then I know that the leftmost node in the last level will be in the left sub tree and the rightmost node at the last level will be in the right sub tree and therefore the LCA between them is going to be zero right that is why for any node if I find that the left subre depth is equals to right subre dep depth then that node will be the LCA okay so if the left subre depth and right subry depth of a node are same then that current node will become the LCA otherwise let's say that I remove these two noes okay I remove these two nodes then the left sub tree depth is greater than the right sub tree depth what does it mean it means that the deepest leaves at the left side are actually at a higher depth as compared to the deepest leaves on the right side and what this problem is trying to find the LCA between the deepest leaves in the entire binary tree and that is why if you are at zero and if you find that the left sub tree depth is more then the LCA must be on the left side zero is not the LC but it will be on the left side so we will be solving the left uh left sub tree instead the right sub tree we will be removing this right so that is why if the left sub depth is higher than the right sub depth then the LCA is on the left side otherwise the LCA will be on the right side okay so this is an important observation now based on this observation can we find uh the height of the entire tree yes we can actually precompute the height of the entire tree in this case how to do that I can just uh start my pre-computation from this node zero and I can say that it will be asking the height on the left side the height of 0 will be equals to 1 plus maximum height of the of the left sub tree and the right sub tree okay so recursively we have to check for one it will be asking what is the height of three three is the leaf node it will say height is one it will ask four what is the height four will ask 7 7 will answer 1 it will ask eight 8 will answer 1 so max of 1A 1 + 1 it will be returning two 1 will be returning Max of 1A 2 + 1 which will be 3 now 0 will ask 2 2 will ask five five will return one 2 will ask 6 6 will ask 9 9 will return one it will ask 10 10 will return one 6 will return Max of 1A 1 + 1 2 2 will return Max of 1A 2 + 1 it will be 3 and 0 will return Max of 3A 3 + 1 which will be 4 in 1 DFS you can precompute all the Heights or you can say all the depths right and uh I can store it in a hashmap so that the next time I apply DFS I can optimally choose which side to go the technique that I will be using is pre-computing the height or you can say the depth and apply two times DFS in the first DFS I will be calculating the height or the depth okay so in this case I will be traversing as I said previously and I will be pre-computing the node with with their corresponding height or depth fine so the first DFS is done the second DFS will be for finding the LCA of the deepest leaves so let me show you in this case if I start my DFS at zero I will be checking the left uh child height and the right child height that means the subt tree rooted at the left side and the subtree rooted at the right side look at the map they have the same height this means zero will be the LCA immediately return zero okay now let's assume that these two nodes are gone if these two notes are gone the height of two will be changing to two Okay the height of five and six uh will also be changing to one five was already one six will be changing to one right so if these changes happen now if you are at zero find out the height at 1 it is three height at two it will be two this means that the left sub tree is higher as compared to the right sub tree so the LCA must be on the left side so go to the left side and and and check for one check the height of three it will be one height of four it is two so that means the LCA must be on the right side so go to the right side and check uh the height of the left side 7 which is 1 8 which is one so both the heights are same so that means four is the LCA and the answer is LCA equals to four in this case right so I will be traversing only the height of the tree in the second DFS right but it can be a skute Tre and therefore the time complexity can be order of n the first DFS time complexity is n second DFS can be n and the space complexity will also be n because we are solving it by DFS recursion right and these are all the three cases that I have already mentioned okay I have already explained these three cases based on all these observations what we can do is we can apply only one time DFS and while applying the DFS I can keep tracking the depth values or the height values I can keep tracking the depth or the height values and I can keep uh tracking or return learning the LCA values together okay if you know all this then you can also do it in 1 DFS so let's do uh see how to do it in 1 DFS call so when you start at a node okay then you will find out what is the candidate LCA on the left side and the candidate LCA on the right side along with the depth okay all the all the cases here all the three cases are same but in this case when I return I will be returning in a subtree what is the LCA and uh what is the depth okay so if I if I check this 478 then what will this sub problem for return it is a sub problem right if I'm solving this for four it is a sub problem so four should return that four is the LCA in this sub tree which is 4 7 8 rooted at 4 4 is the LCA of the deepest leaves and the depth value is two that is why it will be returning right it will be returning that so this is a sub problem so what I will do is I will be solving it bottom up I will be solving the smallest problem and move up the order and then I will be applying the logic what we learned previously based on the left sub tree depth and the right subtree depth isn't it so let's see I think if you look at the dry run it will be easier to understand so at zero I will not do anything I will just make the left call and get the answer from the left sub tree I will get the answer from the left sub tree now for this three it is a leaf node so when it makes the left call it is null so it will be returning null comma 0 that means it is it is out of bound okay so this three will also make the right call and this will also return null comma 0 so this makes three the leaf node now what three should return is three is the LCA and the depth value is one okay so one got 3 comma 1 from the left side meaning 3 is the LC and one is the depth now you check the right side okay check the right side so it will ask four four will ask seven so seven being the leaf node it will return 7 is the LCA and the depth is one now four will ask right side and it it is a leaf node so it will be returning 8 is the LCA and the depth is one now four got seven as the LCA with depth one and uh from the right side it got8 as the LCA with depth one now since both the depths are same on the left and right side this means that if you take the LCA between the deepest leaves within a tree rooted at four then four will be the lcf that is what we already learned right so if left sub tree depth and right sub tree depth are same four will become the LCA so what it will return is it will return four as the LCA and the depth becomes Max of left comma right + 1 so left depth is one right depth is 1 Max of this is 1 + 1 it becomes 2 so 4A 2 is return to one now one sees that okay on the left side the depth is one on the right side the depth is two this means that the LCA must be on the right side so it will be returning 4 comma 3 white is returning 4 comma 3 because LCA is on the right side but the depth will increase by one if you include one also right okay if you include one then the depth will always increase by one so the depth will always keep changing but the LCA may not change now it will again ask the same question on the right side on the right side it will make a call to two two will call five five being the leaf note it will be returning 5 comma 1 5 is the LCA 1 is the depth it will ask six 6 will ask 9 9 will be returning 9 comma 1 it will ask 10 10 will be returning 10 comma 1 now since six knows that the depth on the left and right side are same it knows that 6 will be the LCA right 6 will be the LCA and the depth value will increase by one fine now two got one depth from the left side two depth from the right side this means LCA must be on the right side so the same LCA will be returned which is 6 comma uh 3 now the height will keep on increasing I mean the depth will keep on increasing because we are moving up now zero got three depth from the left side three depth from the right side this means that both the uh left sub tree height and right sub tree height are same so zero will become the LCA because the deepest leaf on the left side and deepest leaves on the right side are at the same level so if you consider the leftmost uh deepest leaf and the rightmost deepest Lea then uh you will get zero as the LCA always so that is why the LCA will change to zero and the depth will increase by one so that makes it four 0a 4 and in the caller function you get it and the first node that you get as the return value will become the LCA right so this we have solved by just one time recursion so the time complexity is order of N and the space complexity will be order of n because the tree could have been a skew tree right so I hope all these techniques are clear let's now look at the code if you are someone who is looking to prepare for top product based company within a limited time of just 3 months then we have brought for you both the DSA and the system design live interview training program the most important feature of this program is you get a filtered and condensed structured curriculum in-depth discussion of all the topics and my guarantee of your understanding one-on-one Guidance with me and live weekend classes to know more about the training you can WhatsApp us on this given number in this code I have taken a pair node integer and defined it with a short name p and it is pair tree node star and integer type now this is the main driver function LCA dest leaves and the root node is shared now I will be getting the result and returning the first value which will become the LCA right so I will be calling the find LCA by passing The Root node now at any point of time it will have a node and if it is null this means that we are out of bound it is out of bound so it will return null pointer with a depth value of zero now this will get the return value from the left sub tree this will get the return value from the right sub tree Once you have got both the return values fine let's say that it has gone LCA 1 comma height 1 or depth 1 and this has got LCA 2 comma height 2 now I will be checking which case it is hitting if height one and height two are same then the node X will become the LCA and it will be returning X comma uh height 1 + 1 because height 1 and height two are same otherwise if the left subtree height is higher then the LCA 1 will be returned with the height 1 + 1 okay otherwise if the right sub tree height is higher then the right subtree LCA which is LCA 2 will be returned with height to plus one fine so I think it is extremely clear and if you still have any doubt then feel free to comment below and I'll try to help you as soon as possible like and share our video And subscribe to our channel in order to watch more of these programming videos see you guys in the next video thank you