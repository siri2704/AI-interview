hello everyone welcome to this video by data sense we continue our course on Python and as you know we are presently working on data structure and algorithms so we have covered data structures part in previous video we talked we talked about the linear search right what is a linear search uh so what happens it is when you have a list like this and you have to expor through elements a b c d e f g something like that you you do that linear search and the time complexity of that is nine because you are just uh going from 0 to n like from here to here you're going and you only have you take one variable let's say you take uh so we used to like variables like for I for a in s correct so technically what are we doing we uh this a variable we are iterating from here to here to here to here so it is only moving in One Direction and once a time so it is a linear approach now in this particular uh video we will be talking about the algorithm 2 which is little bit Advanced and it it is used for advanced questions uh because this uh linear search does not work always so linear search or has complexities when it arrives to when you say when you solve complex questions for example let us say I'll talk about that question here that suppose you have uh list here okay now when you have to find triplets or suppose you have to find cup pairs or you have to find triplets or you have to find find uh like quadrates right there this particular approach is not good because uh as the variables increases i j comma K comma L our time complexity will increase and uh so it will move from o FN to O FN squ to of N cuq and so on I'll show this using an example just now and there we actually use the two pointer technique twooter technique is very very uh effective in DSA so you should uh absolutely focus on what how it is done what is the architecture of it what is the intuition behind two pointer technique so uh let's dive in without wasting much time now we will go towards a question first of all let us say uh so let me just zoom in a little bit okay so now if I if I go here and if I see that there's a question that there's an array and you have a Target so given a sorted Arrow of integers find two numbers such that they add up to a specific Target number and please return the indexes of the two numbers so you have an array and you have a Target you have to find two elements so that sum is equal to 9 so let's let me open up workbook so how will we do here is that let's say I copy it uh so let's say I copy this thing from here okay so I have an array I have a Target now what do I need to find so 27 1115 so I have uh an array 27 1115 so let's first of all discuss here how are we going to do it so we have an array is equal to 2 7 11 15 okay and you are given a Target let's say that is equal to 9 now assuming there is only one such pair you have to find a pair uh we know that there is only one pair which is summing to 9 uh that is this one but this is a very small array what if the array is very large and you don't know about numbers right how do you build a build a solution so that doesn't matter whatever is the array size whatever is the target you are able to identify those particular numbers so if we go our traditional way uh how we do it which is also called the brute force method I'll I'll speak what what do you mean by Brute Force Brute Force means the most basic method where you uh with time comp time complexities High I mean you go to the most basic level to solve a problem right so that is called Brute Force uh the the method that we have been using till now is generally called root Force so uh how will you do that let's let's talk about the intuition about this so you have this array okay 2 7 11 15 2 7 11 15 and what you want to do is uh you want to find a pair so you want to find a pair technically that is a comma B such that the sum A + B is equal to 9 okay you want something like this so you will need to have two initializer two variables basically uh so you will need to have an i and you will need to have a j okay and what you will do that you will uh so you will keep for example I fixed at some place and you will for example let's say I is equal to two here okay let's say I is equal to two then uh J will take what what values J Will 2 comma 2 is not possible because I and J have to be distinct correct so J can be 7 it can be 11 it can be 15 so there are three pairs like this 2 7 2 11 and 215 okay when I is equal to 7 what can be value of J uh so J cannot so I is equal to 7 it means that J can be so J cannot be two I mean uh two and 7 seven and two we are considering same so uh let's say J is equal to 11 and 15 okay so what will be my thing it will be 711 and it will be 7:15 we can also take 72 I mean that's I'm not just including right now but you can take that let's say I is equal to 11 then J can be 15 okay yeah so let let's take that as well let's take that 7 comma 2 okay and if I is equal to uh 11 J can J can be 15 J can be two uh J J can be seven so again there are three sums okay so that is possible 11 comma 15 11 comma 2 11 comma 7 so what what do we see that for every i j and now when I put I = to 15 again I will have three values okay so what do I see there are total three 3 3 to four total 12 possible cases 12 operations are there 12 operations will be there okay so technically what we have to do this is four if you know math it is 4 C2 right so uh four four four fact sorry it will become 4 P2 right so so that is the thing 4 P2 means 4 factorial by 2 factorial divid by 2 factorial and uh something like so it will come out to be total 12 operations we just saw so what do we see here that to get uh after this what happens we have 12 pairs to each pair I will pass the condition if a + b is = 12 then print uh then print that pair okay so for example so uh this so we need nine not pair so this seems fit to me okay I'll one by one search everyone I'll down close this close this close this uh this this will make sense to me okay and uh close this close this uh and close this so I will have only two pairs 27 and 72 okay 27 and 72 will will be meaning here now uh so so what we did we explored all the possible 2D combinations and then we uh then we put the filter and then we then we select it then we select it okay that's how we did it okay after this you can just pass it to a set to get the value the what is the problem with this particular thing the problem with with this is that when as your array size increases okay your complexity increases so uh first of all let's do using this method let's solve this question using this this so suppose we have this array uh right array we the same array that we just spoke about and we have a Target nine now we want to do it using the brute force method uh which we generally do so what will be my Approach towards solving this particular question so what I will do is that I have to find two elements whose sum comes out to be nine so what I will do I'll create two iterators because I will have to store one number in I I like I have to get something like AB right so I need one it it Ator for a one iterator for B so that I can eventually check their sum so what will my first step uh my first step will be to uh First Step will be to get all pairs okay second will be to uh check pairs with some nine okay and I uh like I and I basically select those pairs which have sum equal to 9 so what I'm doing I'm exploring all the possible Pairs and here we have four so how it will start we will have to initiate two values I and J so what I will do for I in range now I will vary from 0 to three 0 1 2 3 in range and for that we can take length of ARR okay because length of AR will give me four uh 1 2 3 4 and so it will be range of four means 0 to three it will go and now on the next wrer let's name it J now J will if I is varying from this to this the J will vary from this to this because both cannot be same at any point of time so for J in range one to length of ARR okay or even you can do that like let's say you don't you want to keep it like this for J in uh let's start let's let's make it J even go from zero to this point let's go even like forther more root Force right so what what I have to do uh I have to create an like uh an array like this in which I will store values so right now I'm getting all the pairs which I will be storing in there so what I will do rest do append and if you know in append we can only add one element so what we will do we will add a r r i comma a r r j okay this is the slicing uh because I and J are what they are indexes they are not the actual values they're the indexes okay and uh so I I close this now once now let's see what is rest coming out to be let's say I do print re okay so I've have got all the pairs two 2 27 like all the pairs which are present there and I have even made I and J equal so that uh I and J can be equal of course there sum will never be uh come out to be nine because nine is an odd number and of course now what I need to know from this is that now I want to select those values of those lists out of the list of list which have a sum equal to 9 so what I will do and I will store them in a new so let's let's name final list Final equal to this now what I'm doing is for list in re s okay so what I'm doing now if I see this list has two elements zero and one so if list of zero okay plus list of one if this is equal to 9 so what I have to do if this is equal to 9 what I will do final do append and uh I have to what uh append list so I have to append like uh this okay inside this I will append two things I'll first of all add list of uh zero comma list of one okay and now let me print final print final so if you see 27 and 72 so basically technically I mean they are same now we idly we want only 27 uh but it depends I mean whatever the pair is we we can eventually take a set of it but we see that we have 27 we have got one pair from this through this method but what is the problem with this method uh the so basically to avoid this what we generally do is we have to make this vary from one to so that the pairs do not contain the same values right now if you do you'll get 27 now I have to know okay I'm able to get the value the the value of the index uh the value of the number uh pairs which are sum is n but what is the problem with this the problem with this comes like this let me explain you what what will be the eventual problem with this kind of method this code is not optimized the reason being presently my array is my array is of length four okay 1 2 3 4 I am initializing two values I is varying from 0 to 3 it means it can take four values and let's say if I'm making J vary from 0 to three as well uh four values okay so so what is happening uh the total number of operations total operations are how much is equal to I into J and this this is equal to 16 and so it is what time complexity it is of complex it o n Square because because there are four elements so this is of time complexity o n square and the problem with this is that as the array size increases for example you have an array of let's say 1,000 elements okay so your time complexity will increase if your 10 let's say if array has 10 1,000 elements okay so 1,000 into 1,000 so it will become total operations will become 10 ra to the^ 6 okay uh and although there are thousand there are thousand elements but your 10 so there are 10 three elements and if you run using this method it will be 10 6 operation or combinations and this is not good anything beyond 10 to the^ 9 is generally not considered good uh and you have to test on like thousand or millions of uh possible rows like possible elements in an array so this is not a good approach uh generally o n or o n are the best approaches so that you have to diverse only once you don't now imagine now let's say there is a case of triplets so what you will do you will have I J K now let's say there uh it can take 1,000 values it it will also take 1,000 values it will also take 1,000 values so it will become 10 ra to the power 9 operations and which is not good so many combinations okay and this is not ideal for your computer system uh so this code will not at lot of websites like if you go to lead code or some other in they will not accept this code or even in interviews they will say no run me a code in time time complexity o n where you don't create two variables inj you create only one variable or you Traverse only once or you travel Traverse only once in the in the in the array okay here what what is happening we are traveling two times first I is traveling from 0 to three and then and J is also traveling from 0 to 3 and they are doing at at a different point of time that's why the time complexity increases so a better method to to solve this is called two-p pointer approach so I will speak about two-pointer approach now so in the brute force method we saw that we basically when we have an array uh right and if we have to for example let's say we have to get two variables three variables four variables my time complexity increases because it become every time uh I introduce a new variable I have to Traverse that array that many times for example if there are two variables I'll be traversing through my list two times right and therefore it will it become n s if there are three so I J K so it will be it will travel three times and it will become n Cub four * mean n ra to the^ 4 okay so my objective is to solve something in complexity o o o n that is I only want to use one one so n doesn't mean one variable N means you Travers through the array only once okay so you either go through this once or you either go through this ones right or you come halfway here and halfway from here so overall overall distance that you travel inside the array that should be n only right uh if there are n elements it should travel only you should there should only be n operations at then only it's called o n it has nothing to do with the number of JK I am using it has to do that how many times are you traversing inside the array that is the main concept now let us understand the two-pointer algorithm the two-pointer algorithm basically it has multiple types if I uh if I just show you the booklet the it has uh so let's come here it's a technique is a approach used to solve various problems in data structure and algorithms it is specially used problem involving array okay the main ideas is to two points to Traverse the data structure typically to find so we have to Traverse through the uh like whatever we have array here and in this case we want to Traverse only once not multiple times so there are three methods there are three techniques of two pointer technique in this video I'm just going to walk you through the basic one which is uh when both pointers moving to towards each other right so it is often used to find pairs that sum to a Target value in a sorted array and then there are some others as well when one pointer is moving uh so so so what if there are three types of cases that you created this array okay you created this array like this and you have three methods so uh first method is when uh so you have three methods to solve it so you your F first iterator is here your first iter is here is here and your second iterator is here okay so let's say this call this is I this is J and you move towards each other okay this is called first method this is called uh when uh two pointer technique when both move towards each other one is where I is stagnant here okay and another is J J moves J moves from here to here in that case I remains fixed at this point we utilize it in some other method manner but J moves from here to here okay so that is the main thing and the third thing approach is when both move I and J both move from in one in one direction right and that is used in uh so if you see uh both pointers move in the same direction commonly used in problem involving slide sliding window fun windows so that we will talk later when a little more advanced DSA comes in so we are in this video we are focusing oursel to the first case where both pointer move towards each other okay so let me refresh the page and I'll walk you through uh how to build this the first I'll walk you through the intuition behind this so what happens so let us say we uh so we have this array right 2 7 11 and 15 okay so how two pointer appro algorithm works here this is two this is 7 this is 11 this is 15 okay this is my array uh remember the key Target is to I want to solve it using n o n complexity means I have to travel to the through the whole array only once okay only once I don't want to travel multiple times okay so that is my objective so what I do is I I create two variables one I create left I assign it here it to two Okay and then I create a right pointer so I assign it to 15 so let's say the left I have named it I and right I have named it J okay these are the two po pointers that I have assigned so what will the index value so I will be equal to zero and J will become equal to 0 1 2 3 it will be be three or you can say length of array minus one because we are talking from the end I mean this length can vary so in general uh this particular this will be so this will be the first pointer and this will be the second pointer which we are using here okay so now the main main thing starts that we have to iterate so basically we have to iterate What will what we eventually do we will have a we have a condition that I for example array of I plus array of J this has to be equal to 9 right we know that we have to test it for this okay we want to test it for this so what will happen there will be few scenarios when we will move sometimes we will move I here sometimes we will move j here okay so what will happen overall uh either I will move till here and J will move till here to get the sum okay so for example in this particular case the some we know that 2 and 7 are there so what will be happening I will remain here and J Will Traverse from here to here to here to here here okay so I didn't travel the whole I I traveled this part I mean technically REM in this and J traveled here so combined I + J they traveled only n that that is the length of the array so the number of operations remained to be n okay now for example let us say the sum they asked were uh 18 let's say they ask for some 18 so what will happen I I will Traverse I will Traverse from uh here two I will Traverse from 2 to 7 okay and J Will Traverse from here to here so again I + J combine they have moved how much equal to n only so in any case we are move we are traversing from here to here and maximum this sum is equal to n so that's why this whatever approach we are using it has it will be of time complexity o n but how do we solve the question using this method oh I understood that okay let's say uh have some distance I will move some distance J will move towards it and combining they will be forming a maximum step of n but how do we ensure that sum is becoming to be equal to uh 9 so let's solve that thing as well so okay so let's uh start solving this once again so let us say uh we had this array right we had this array which was equal to 2 7 11 and 15 okay we had this array now what we did we initialized two pointers as we discussed so one this is the this is my first pointer which is I = to 0 and this is my my second pointer this is J equal to 1 2 0 1 2 3 3 or you can also say it length of array minus one okay I have initialized two pointers now so what one will uh move from here to here and one will move from here to here okay so we see that and this is of time complexity o n as we discussed because uh at any point of time they combin will not move more than four because either it will move here and it will move here and then they will meet here or they will meet here uh something like this will happen okay we have to make sure that we Loop till they till they meet each other till they meet with each other so what is going to happen is that I will I I will start this particular J J from right right and suppose they are at this particular point right now tell me can J go beyond I and can I cross J uh so is that possible that is not possible because for example let's say I is equal to 1 that is this and J is equal to 2 if I say that J is equal to 1 and I is equal to 2 that is not possible it is because it is an exact same replica of this right these and these two combinations are exactly same okay so this is not possible so we will Loop this particular thing till left part that is I is less than J so what will be my Loop condition so I'll basically I'll start a while loop while my I or left part I say that is less than the right part or you say that is while I is less than J so this is a very important thing till this we will be executing our Loop so this is my first thing that you need to understand why I and J cannot pass it will move some some steps here it will move some steps here they will meet at some point but they cannot go pass each other because it will eventually meaning the same thing only okay so combined I and J as we saw I + J they are moving n Only and that is why this is a n complexity now there are three scenarios okay there will be total three scenarios which we need to address each of them scenario one so let's discuss about so what we'll do basically we will create a sum always in uh we'll create a sum that is equal to a r r i plus a r r j okay we'll we'll we'll keep a track of this there some when where for example let's say my I my first pointer is here and my second pointer is here or let's say some uh something like that so we'll always keep a track of their sum okay for example here it became 13 uh some at some place other they will have some other values okay and then I have a Target sum which I want to achieve Target is equal to 9 here the question says Target is equal to 9 now there are total three scenarios possible there are total three scenarios possible so I'll discuss them one by one the first scenario is that sum your total sum is greater than Target okay so for example in this case 211 your sum is greater than Target Target was nine so what will you do eventually what will be happening you'll be you have to either move this to the left or you have to move this to the you have to move either left pointer to to the right pointer or you have to move right pointer to the left pointer okay now tell me if sum is greater than Target and we know that this scenario is only this array is sorted so remember this AR you have to sort this sort this array always okay from ascending to descending now if sum is greater than Target so what will you want to do you will want to reduce the sum of course if you have to reach to the targ Target and how reducing sum is possible you have to basically either decrease this or decrease this so you have to either decrease this or decrease this now decreasing this is not possible because this is already in ascending order so this this can only move right and this can only move left so if your sum is greater than Target what you will do you will move take your right value take your right uh I mean right pointer you will reduce this you will move it to the left okay this is your first scenario second scenario if your sum is less than the target okay we do not see that here but what if your sum is less than the target there you will move from left to left plus equal to 1 you do something like this let me explain you through a bigger example as well so that you understand it even further so let us say there is an array okay let's let's create a different array so let's say there is an array 1 4 8 3 and let's say 7 and 9 okay now we want we technically want that uh the sum of uh basically the sum of the two point so let's place the Target that we are looking for okay okay so let's the let the target be uh for example so we have to think of a sum 8 3 11 4 so let let the target be 7 okay or let's say the target be for example 9 + 7 9 + 7 we can we can make it we can make the target for example 9 + 7 16 okay let's let's make the target 16 okay so the target is 16 Okay so how how will this thing function your I will start from here I equal to 0 and your J is equal to 0 1 2 3 4 5 Z is equal to 5 okay so we will see what all steps we will be doing now the first step is to calculate the sum sum of of a uh so what is the sum a r r i plus a RR J okay this is my sum so in scenario one what so we have a sum and then we have a Target that is Target is equal to 16 okay so let's see so let's keep this as our sum okay and this be our Target now in scenario one when this is my I this is my J what is my what is my sum 1 + 9 that is equal to 10 okay and my target is 16 so if if you see that this particular sum is less than the target so what do I need to do I need to increase so I need to increase this because 9 cannot be increased so I'll have to increase this so what I will do I'll shift I from here to here okay so I'll do I + = to 1 I = to I + 1 now what becomes now my I value becomes 1 in second scenario Now what is my sum now 4 + 9 it is 13 okay here my sum is 13 now is my target is still 16 it is still less than this so what I will do I will move my left pointer towards right once again so I will do it here okay so my I becomes equal to 2 here now now when my I is equal to 3 what is my third sum so 8 + 9 that is 17 this becomes 17 okay and uh this is uh 16 so what do I see that the sum my my sum value is greater than this so what do I what do I need to do I need to reduce the number so I will move nine from here to here okay uh and and that's how it will function now my I is equal to 2 so my J will move from 5 to J will become equal to 4 okay now after this what will be happening after this uh similarly depending upon the scenario I will either move this to the left or this to the right so this is what my I'm saying when my sum is my sum when my sum is greater uh so when my sum is greater I I I have to reduce the Val to reduce the value so I'll move from right to left and if my sum is left I'll move from left to right so that is the thing and what is my third scenario when sum is equal to when sum becomes equal to my Target that is the value that I need to store okay there I need to store that particular value this is called two-pointer approach uh so I try to explain in as much detail as possible now let me uh take the current example that we were doing uh that we were doing here that is 27 1115 okay okay so this was so that things are little bit easy to for you to guys to understand 271 and 15 okay uh we are ensuring that there is only one such some possible right now I'm not complicating the things so for example in the previous question multiple sums were possible multiple cases were possible right so uh I'm trying to explain through where there's only one pair 27 so what we do we start with this point I equal to0 okay and this is J is equal to 3 Now what is my sum my first sum so my for for first scenario my sum and my target I will check so what is my sum in the first 15 + 2 17 and what is my target 9 so my sum is greater so I have to reduce the value so I will move j to here now my J becomes equal to 2 so what is my second sum uh 11 + 12 13 it is still less than Target so I will still move it towards right okay and what is my third sum my third sum is nine and this is nine and because these are equal then I will stop so basically I will store these these two values in my list and that is how you use two- pointer approach to arrive at a solution so I hope this uh theoretical explanation is clear now I will move towards the coding part so we will come towards the coding part now here in coding part what do we have we have array equal to this and Target equal to this right so we start the coding part the first of all thing that we need to do we need to define a left pointer so let let's say left pointer I is equal to zero and the right pointer that is J is equal to length of length of a r r minus one which is equal to three okay so now if I uh I have got this part now I'll start with my looping condition remember we have to Loop till I is less than J so while I as while I is less than j i Loop this till that particular uh scenario so if I do this now what will now now what will happen that uh okay while I is less than J so we'll start the coding part of so first of all we need to create a temporary sum so temporary sum is equal to what it is a r r i plus a RR J I'm creating a temporary sum for every everything after this I will have three scenarios so just like we discussed we have three scenarios total that we will be discussing the first scenario is when the sum is when temporary sum is equal to Target so what do we do we have to store that value so what we will do we'll create a simple blank uh array and we will do rest do append and in this we will append my I comma J that is the indexes I'll append if if I have a match I will append there and then I will break the code okay then I will not move forward now what I have to do next L if so in remember in Python we if have to use l l l if we directly write LF now for LF we have to write down if TMP let's say the second condition will be if this sum is less than Target okay so let's go there if my tar my sum is less than Target for for example so what will I do I'll move my left pointer okay I'll move my left pointer towards right so basic because right now my sum is less than Target so it is lying somewhere around here and something is here so I have to increase that particular sum to increase I have to move that left from here to here so I will do left plus equal to 1 so or you can simple say uh I + equal to one you can do like this and the third condition will be when the sum is uh basically when your sum is greater when your sum is greater you have to move your right value towards because you have to drop off value because you have to drop the values and you have to reduce the value you have to move from here to here and so what you will do you will do J minus equal to 1 sorry minus equal to 1 and now I'll print rest so if you if you see that if now if we printing we are getting 0 one 0 one are what they are the indexes of this particular thing so we can uh this is the syntax of that particular code that we start with two pointer here with left pointer and then the right pointer then we iterate till while is like I is less than J and then we create three scenarios when one one is when sum is temporary sum is equal to Target which is our ideal scenario that we want if such thing appears we will uh basically return it in my in my array otherwise if Le it is less I will iterate towards light right or left depending upon the scenario if I want to increase the sum I'll move from I'll increase my left pointer and if I move to reduce the sum I'll move my right pointer towards left and finally I will print it so this is the code part for this particular scenario and this is called two pointer technique so this is uh about this video now if you see there are two assignments uh questions one is where you have a difference right where you have to Target is difference and another is product so these two questions are entirely based on this method only that we just discussed so I want you guys to try this on your own and this is your today's assignment these two questions okay so what I will do I will just uh uh paste this particular code in in the I'll paste this particular code here so that you guys can refer to it okay and uh yeah so that's about this particular video This is called twop pointer approach where uh which it is used to reduce the time complexity uh I'm not I actually tried my best to explain you but still if you guys don't understand uh let me know I'll try to come up with more explanation this particular thing will come with time to be honest right and that's why I I just introduced this concept here so that you can uh try a couple of question this is the first question of two pointer technique there are very Advanced question of two pointer technique as well but these are the first where you have to get two values where their Su is equal to something so try using the approach that I told you and let me know if you guys don't understand anything and thanks again for watching the video you guys are really doing great it's it's been two weeks and I'm like we are really lucky that you guys uh have thoroughly solved every assignment every video you have watched so we are grateful to you please keep learning please keep doing things par DSA problems we have started now and uh complexity will increase so try your best and watch the video understand practice on your own and let's repeat the do this on a loop till 31st of August and we will definitely see a rise in our python level so thanks again for taking out the time and I will see you in the next video