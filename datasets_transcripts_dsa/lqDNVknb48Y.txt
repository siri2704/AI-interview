[Music] hello everyone welcome to codesoft in this video we are going to talk about a very important concept that is the sliding window technique and to illustrate that we will take the help of a problem that is maximum sub array sum of size k so let's get started now what is the sliding window technique so we have seen that the problems involving you know the sub arrays they require nested loops for solving it but you can also reduce that to a single loop using this sliding window technique okay now sliding window technique is basically taking help of two pointers so let's imagine there is a window now every window has a starting point and an ending point so these two variables represent the start and end of the window and when we move these two variables one step ahead the window actually slides towards the right and this is how we are sliding the window so this is just a brief about this technique in the problem that we are going to discuss you will be able to understand more better so the problem says that you are given an array of integers that is of size n and our aim is to calculate the maximum sum of k consecutive elements in the array so now let's look at an example test case so we are having an array that is having nine elements and k is equals to four this means that we have to create sub arrays of size four so all the sub arrays of size four possible are we will start from first element that is one and it will go till ten because this equals to four elements so this is the first sub array of size four this is having a sum of 17 the next will start from 4 and go till 23 this will have a sum of 39 so on the sum will be 38 37 27 and the last one will be this starting from 3 and ending till 20 so this will give us a sum of 24 so the maximum sum out of all the sub arrays is 39 and this is the answer that we have to return so now i would request you to pause the video and try the brute force approach and then have a look at this video so the brute force approach says that traverse through the array go to each element one by one let's say we first go to 1 and then start another small loop that will pick up the next k minus 1 elements and add all these elements then go to the next one that is go to 4 pick up next k minus 1 terms and add them to four then pick up two add and pick up next k minus one terms and add them to two also maintain a max sum variable and whenever you create whenever you form a new sum compare it to maximum if this is greater than maximum then update the maximum with this sum and go on so at the end of the loop you will actually have the maximum variable having the maximum value now you need to take care that whenever we will be starting the loop we do not have to go from 1 till 20 we just have to go from 1 till 3 because 3 will be the last starting point of our last sub array you can see from this case okay so this is the brute force approach okay so now let's talk about the brute force implementation so we have declared a maximum variable initializing it with int min because it is having no maximum value so the minimum possible value we will insert it in the maximum variable after that we will have to traverse one by one to each element so for that we have declared a loop that is i equals to zero i less than n minus k plus one now what is this n minus k plus one so let's have a look at this with the example n is for n is 9 is in this case k is 4 so n minus k that is equals to 5 plus 1 equals to 6 and the loop says i less than 6 so the last value that will be that i can store is five so the five fifth index is zeroth index first second third fourth and fifth so three is the fifth index that is the last value for i and that is what we actually want because i refers to the starting point of our sub array and you can see the last sub array is having the starting point of 3 so that is why we have declared is i less than n minus k plus 1 inside this loop we declare a variable current sum that will actually store the value of k elements starting from i now we have declared a variable j equals to 0 j less than k j plus plus so this loop will actually count k elements starting from i that is why it is storing the value of current sum equals to current sum plus a r i plus j so at the end of this loop the the k values the sum of k values starting from i will actually be stored in current sum after this we will just update maximum equals to max of current sum and maximum so we will just check that maximum is greater than current sum or not if maximum is smaller than current sum we will insert the value of current sum inside max and at the end of the loop we have actually traversed all the sub arrays so our maximum will actually we will just return our maximum so this is the brute force approach to the problem now we will see how we can actually apply the sliding window approach to this problem so for that i will just illustrate you so you can see that in this brute force we are actually applying two loops so the complexity is o of n into k because the first loop is of n and the second loop is of k so we can reduce this reduce this problem to off n problem with the help of the sliding window approach so this is the array now the first k terms will be this right so as i told you that this this is the window that we are actually looking for this is the first window now to declare a window we need two variable one as the starting point so let's name one variable i as the starting point and one as the ending point so this will actually be our ending point so this is our window first window correct now let's just count the sum of it that is 1 plus 4 plus 2 plus 10 that is equals to 17 correct so we have just taken our first window now what we have to do we have to slide this window one step ahead that means that i will go from here and j will go go till here so after doing this what you can see we have formed the next sub array that we require correct but if we talk about the change in the sum the previous sum was having this four value the next sum what the next sum what it is doing is it is just subtracting this value right and adding this value correct so what we have to do we just have to subtract our ith value that the previous i and we need to add the jth value and this will actually give us our sum so the previous sum you can see was 17 if we do 17 minus 1 that will give us 16 and we will add plus 23 that will give us 39 so this is our next required sum now in the next loop that will be this one we just have to do 39 minus 4 that is the previous i that is 35 and we need to add this 3 so that becomes 38 so this is how we will slide one step ahead subtract the ith term add the new jth term and go on till the end of the window very clear so this is just taking single loop we do not so basically what it is doing is that whenever we create a sub array we are not traversing that sub array we are just subtracting the previous value and adding the next value a very good solution to this so now let's go to our editor and implement this problem first thing is let's just declare a variable that is maxim this will actually hold the maximum sum at the end of the problem first step according to the problem is that first just save the first k k value sum that is the first sub array sum just store it somewhere so let's just create a variable as current sum or let's say window sum because we are dealing with window and declare it as 0 correct go from i equals to 0 i less than k that is pick up first k elements pick up the first sub array and just add that into windows sum so this is what we have done so at the end of this our windows sum will have window sum will have the value 17. add this value to like just put this value inside maximum variable why so because we we are assuming that the first k values are actually the maximum values whenever we will encounter new sub array we will compare it with maximum and update the maximum accordingly correct now what we have to do we have to declare our two variables that will actually be the start and end of our window correct so let i equals to 0 and i equals to 0 so this is our starting point of the window and let's start a loop that is j equals to k and j less than n j plus plus now what we have to do you have seen that we add the previous value of i and add the next value of j like subtract the previous value of i and add the next value of j so that is why i equals to 0 that is the starting of previous window and j equals to k that is the start of next window correct so what we have to do is just just go to our windows sum and subtract the arr i value correct and add the error j value this is what we have to do so what we are doing is as we discussed in the uh in the figure that we have to de we have to subtract the ith value and add the jth value after this just uh increment our ith value so that when we are moving we are sliding our window for calculating the next sum before doing that we just have to check if our window sum is greater than max sum just update the maximum with the windows sum this is that at the end of any sub array or any window we compare the windows sum with the maxim to actually update our maxim with the maximum value and end up at the end of the loop we will just have to see out our maxim to check our final value so let me just run this problem and k is not defined yes k is not defined because we have to define k equals to 4 in this problem and let's run it let's just run it again okay so what it is saying no match for this operator yeah because this is double correct and you can see our output 39 is coming that is what we are requiring so again illustrating what we have done here is that we first pick up a window size start an i from here put a j into here when we move to the next window we subtract this value and add this value and so on so forth we go till the end and just keep on adding and subtracting values to get the sum so this was the sliding window uh implementation you can see that we have solved the problem in of end time which is a very good solution so thanks for watching this i hope this is clear and stay tuned to add more festoons into your knowledge until then please keep subscribing thank [Music] you