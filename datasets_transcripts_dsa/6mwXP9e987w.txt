right see the problem given an array of n elements majority element is an array of majority element in an array a of size n is an element that appears more than n by two times in the array return if majority element exist otherwise return minus one if anyone is not clear let me check once in this array first element second element third element fourth element fifth element sixth element seventh element seven elements are there what is 7 by2 3.5 more than 3.5 more than 3.5 it may be 3.6 3.7 whatever it is more than 3.5 it may be 3.5 because of elements here more than 3.5 maybe you can take four also is there any element which is repeating in the given array four times or more than four times check 1 2 3 4 four times one person repeating so this person is called majority element so majority element exist so you have to return him in the given array if majority element exist return that person what is majority element definition in the given array an element is set to be majority element if that element is appear more than half is 3.5 half is 3.5 more than half more than 3.5 because of number of elements more than 3.5 is I think four four or five and so on I taken four so one person repeating four or more than four I think majority element exist that is 13 can you see one more example first element second element third element fourth element fifth element sixth element seventh element eighth element 8 by 2 four more than four more than four that is 1 5 6 7 and so on any person any person in the given ary who is appearing five or more than five times I think 1 2 3 only three times majority element not exist return minus one and the similar we can see 1 2 3 4 5 in the given array five people are there 5 by 2 2.5 more than 2.5 that may be three any person is there in the given array three or more than three times yes there so majority limit is 81 so you have to write algorithm If majority element exist you have to return him otherwise return minus one you have to plan one other for this let's see how you are going to do it's one of the famous problem of computer science so what you want to say is you have to find out majority element in the given array in the given array if any element is repeating more than half time if any element repeating more than half time that person is majority element I think in this array if you observe Right one person repeating more than half so 13 is the answer in this array if you observe I think elements are 1 2 3 4 5 6 7 8 people are there 8 by 2 is four so I think someone should repeat someone should repeat five or more than five then only is the majority element is there anyone repeating more than five or more than five anyone i think it is repeating only three times right so majority element not exist then you have to return minus one right next one similarly like this I think here five people 5 by 2 3 point right so 2.5 more than 2.5 maybe three right anyone repeating three times yes so majority element exist so we have to find out this is the challenge what we given yesterday right let's see the answer for this I hope you tried it I hope you tried it let's see the answer let's see the answer yeah I written the code also it is a very simple algorithm it's a very simple algorithm it's a Python program it's a Python program so please write properly i written the rough code i written the rough code so what exactly this program is so you have to find out the right majority element so these are the elements let's let's write the elements one time 55 65 30 Next one is 80 30 30 so total I think six people 6 by 2 is I think three let me write one more time 30 so I think totally seven people majority element exist that is 30 everyone 1 2 3 4 5 6 7 so what what what is the one simple idea what is the one simple idea is take the element 55 count how many times 55 will come take the first element see for i in range n so take the first person take the first person right first person you take make the count as one index is I index is one right take the first person now that will be compared with all other people so like this right this will be compared with all other people is there anyone exactly like me so I think I done the counting i done the counting 55 counting done lastly check right count count is greater than n by2 no no if it is not here if it is true if it is true return if not if not execute the code this loop is going on this loop is going on right remember this code is belongs to this this code is belongs to this right so this code is belongs to this please careful be be careful with the spaces python programming space important you have to give spacing properly in C language it may not be big problem because brackets are there but in the Python language no brackets and all you have to keep space properly see this for loop story right these people inside this for loop story inside this definition story inside like that so for each person do the counting I done the counting of 55 only one time happened as soon as you select this person count is one is index also I one so you keep on count if you after counting count is greater than n by2 then is the mid element is the actual majority element if not if not right I value two i value two i value 2 so count becomes one index becomes two now that will be compared with all other people so I + 1 onwards it will so I think if you take this one it will be compared with all other people so like that it will be keep on going on so every person every person you have to compare with all other people n every person approximately n every person approximately n like that it is going up worst case this algorithm will take order of n² time order of n² time complexity so if I want to say to be frank if I want to say to be frank first person first person right first person n minus one comparison second one nus2 comparison third one nus 3 comparison and so on lastly 2 and one it is sum of n minus one natural number to be frank sum of nus one natural number nus 1 into n by 2 which is going to be order of n² which is going to be order of n² this is the time complexity for this what is the space i not taking anything extra constant space space complexity constant right everyone know this everyone so this is the almost like main program this is almost like main program from main program I took one array in Python programming language there is no main like that there is no main like that so this is I think outside code which means main program so one array I took which is also called in Python programming language this is called list two right one list I took length of the list I calculated which is n right which is n now find majority array I passed list I passed and n also I passed at the end of the story you will return whichever is the majority element so you will return that will be stored here you will print that person you will print that person suppose majority element not exist right if majority element exist You will return here you will return here if majority element not exist at the end of the for loop there is a return minus one so you will print minus one something like that very simple if anyone is not getting two inner loops whether you write Python whether you write C language it is up to you c language Python language both are same in C language brackets are there or C++ language also brackets are there here brackets are there space you have to adjust space you have to adjust i hope everyone fine so the answer for this problem is under n² one of the algorithm but one more famous algorithm there I return that also right this is the famous algorithm one more famous algorithm there I am going to explain that I am going to explain please listen roughly please listen roughly right so majority element I will first explain let me explain let me explain the majority element how to find out so one yeah if you want you can start from zero indexes I'm writing So I think approximately 11 people 11 by 2 5 something so six people majority element means six people required six people required so let me try this so some elements so 10 20 30 30 40 50 30 60 30 I think some I think 30 is repeated more than half 11 people 11 by 2 5.5 more than 5 is 6 so 6 * 30 is there I hope so so majority element exist we want to see answer as 30 how we are going to proceed this there is one algorithm that is I think Mo's voting algorithm mo's voting algorithm so why it is called voting algorithm is whenever elections are going on if anyone got more than 50% he will be the winner right comparing all the people who ever got more than more votes whoever got more votes the e will be taken like something like voting algorithm going up comparing other people comparing other people you should get more votes right that's called more voting algorithm anyhow right something related to voting kind of thing but don't bring voting which is a complex area right elections politics is a dangerous area don't bring that story here this is also called mor voting algorithm I'm going to explain how it is very simple very simple so let me change the color very simple so let us assume I started this process let us assume that first person let us assume that first person first person is the right majority element let us assume careful carefully everyone let us assume that first person is the majority elements majority element index majority element index is equal to zero assume that first person itself is majority element so is is index I return and one more because of already one time already one time first person 10k is count is one is count is one assume that first person is majority element so majority element index is zero right so and one more one time already 10 came count is one now what you do is this person right this person this element can compare with the next person if it is right if it equal to the next person then count will increase if it is equal to the next person count will increase so ask the next person next person and majority element majority element index is zero right a of zero means this person this person compare if both are equal count could have been incremented because both are not equal right i think some some other element came some other element came so both will be cancelled different element cancel so count became zero count became zero and one more thing is majority element is there at the zero index we said now no more is not majority element now no more is not majority element and when our right when our count became zero when our count became zero again right again I think cancellation is done no one is good no one is the majority element as of now again start from second element what the meaning let us assume that majority element index is one count is one start it right so those people who are not getting very simple very simple whenever count became zero again start from Starting process what the meaning let us assume that 20 is the majority element so is index is one count also one start again this will be compared with the next element are they same no if not same means they both will be cancelled each other so count became zero whenever count became zero then again again right this process is cancelled again majority element index is next element what are the meaning 30 is the majority element index assume so index is two count is one as usable because one time 30 came right do the story now series one do the story very interesting are they same yes count will increment by same means count increment not same means count decrement again same count increment be careful be careful same means very simple algorithm yeah same person getting more words increase already one vote came one more vote increase already one more vote one more vote increase but opposite vote came cancel it because you have to get a finally majority so to me opposite person got cancel it this that is the reason more voting algorithm until now 30 came three times now see 40 came is 30 40 same no then decrement but after decrementing counting zero no if it is zero you have to start from It is not zero continue no problem next one next one this 30 majority element index is two with the two person with the two person compare every time you are comparing majority element index two with that person compare so I think 30 and 40 I compared there is no equality i remove 30 and 50 also compared both are not equal again decrement it is not zero if count zero then I will start again from starting next one this 30 and 30 both are equal s2 this 30 and 30 both are equal s3 this 30 and 60 both are equal no cancel cancel right i hope every everything is fine cancel that is also fine next one next one so I think cancellation next one this 30 and 30 yes increase right so one time scanning is done one time scanning is done i hope everyone is fine so lastly after completion of this process after completion of this process you don't get a majority element you will get the most probable majority so right I think most probably most probably majority element exist in the second index at the end of the story whoever there in this in this area this person is most probable person most probably most Probably majority element exist majority element exist at second index it will give most probable it will give most probable most probable majority element exist at second index now some people are asking s what should I do now very simple right that person only compare now this person second index 30 that person right take one per loop or while loop whatever it is count how many times 30 came let's check I will take one scanning I will count how many times 30 came 30 came how many times let's count right till now zero 30 came one time 30 came two times 30 came three times 30 came four times 30 came five times 30 came six time six which is greater than which is greater than 11 by 2 so it's a majority in so to find out most probable person one scan required to find out most probable person to confirm to confirm one more scan so n time here n time here go over 2 n which is nothing but order of n time and I have not taken any extra space I used order of one space order of one space i hope everyone got it so algorithm also available let's come here algorithm also available let's come here right i think there are two steps here most probable person finding and confirming right most probable person finding and confirming see find candidate find candidate one story is majority is majority one more story one more story one is for most probable person one more thing is for confirming purpose see this is for confirming this is for confirming this is for most right most probable person finding probable person finding it is the confirming confirmation confirmation purpose this confirmation purpose this okay i think everything is fine so you can see the story you can see the story whatever I discussed with the help of example same thing here see this one start here majority element exist at index zero count is initially one right one right take the zero zero person is the most probable is the most probable right uh majority element so count is because of one time you are taken then start the for loop what the for loop right you have to check this person this person you have to check with the next one who is the next one who is the next one six majority element right a of majority element index is equal to A of I you are taking one for loop with I you are running with the I you are running so it is keep on going it is keep on going so whenever it is coming increment by suppose suppose opposite is coming decrement by right next one if count is zero count zero oh so all cancellations done so again majority element index will start from I count is one continue this loop again same story happen right this is I think one for loop is there one for loop end time now next one after after finding so you will return the majority element you will return majority elements can you see this one majority element so let me let me go here yeah see find candidate so let us assume that candidate is let assume that the candidate is 30 so 30k now so is majority confirmation purpos so I went so that after completion of take is very simple take one for loop count if count is greater than right length of a by two then return true assume that true it is true is equal to true print candidate so printed over so first e will call Then he will call right afterwards then he will call so like this so if you want I will give the numbers also so first it will start from here one it will go here it is two it is three it is a four that's it because of space not available i written random places so this is the store print majority person I will go here find candidate so E will be he given 30 30 next one is 30 is majority element you will go here yes e return true e return true so print true suppose E return false print false that's it this is one of the nice algorithm time complexity is only order of n right time complexity is only order of n so I already explained so this one this one will take n time this also will take one more n time so total 2 n which is order of this is for time complex space complexity i am not taking anything extra space that's it i hope you are enjoying the ep 30 days challenge i hope you are enjoying you are really enjoying this i hope you really enjoying right any doubt is there right if you have any better answer you can type in the comment section right so that so that we will also improve right if at any new suggestion there we will also improve if you have any doubt you can ask we are going to reply thank you so much thanks everyone [Music]