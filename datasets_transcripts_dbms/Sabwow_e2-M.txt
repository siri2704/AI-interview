Lossless Vs Lossy decomposition
Whenever we normalize the table. Means we need to decompose the table. That means whenever we normalize the table, like. First, second, third. Take it to BCNF So the means i have to decompose the table. Now whenever we decompose the table So there is audit, EF codd, there are two rules which we have to follow These rules are very important. The first rule is that in the lossless Vs lossy decomposition whenever we decompose the table,  the decomposition always should be lossless. And second one is dependency
preserving decomposition. So in this video we are going to discuss. First, Lossless Vs Lossy decomposition That's whenever we decompose the table. So after that we have to join that table. Why we have to do it , we will see in the example So our Joint is lossless or lossy? Okay, so let's examin the table. For example, there is a relation R In the R, we are having some values over there. Now for the example We need to normalize the table, for normalisation be had
already discussed that we need to decompose the table. If we decompose this table, Like I decompose this table in two parts. R1 R2 R1 table and R2 table. We are dividing the R table into two sub tables R1 and R2. In R1, attributes are AB. And In R2, attributes are BC Now if R1 will be AB Then How will it look? In R1, I have . A. and B And you can copy the values as it is., 1,2,3 2,2,3. Its 2,2,3. And In R2. In the R2 table, we are putting two elements, two attribute B & C. B and C Placed here. So in B & C. 2,2,3 1 2 2 Now, There is a rule of decomposition that whenever we divide
the table into two parts there should be some common attribute between the two tables. Atleast one common attributes must be there, like here I have put B common here. Why do we keep it common? Next time or in the future, if we get any query And in that query, we have to rejoin the both the tables So we have joined on basis of this Common Attribute If there is nothing common between the two. If there are two sets between in
which there is nothing is common. So we don't need to join the sets. So here if there is no relationship between these two tables. So there will be no query that I will need to join these two tables. So where do you need to join? One table and the other table are related to each other. And to show that relation. Atleast one common attribute should be there. & here I have kept the common attribute B. Now you can keep it more than one. But must be an atleast one. So I kept B common here. & simply divide the base level into two tables, A and B are placed here, B and C are placed here. And copied the value as it is. Now, R table no longer exist in the database means I have two tables R1 and R2 R1 and R2 Now lets suppose, There is a query. If a query comes that, Like You need to find the Find the Value. Find the value of Find the value of C. Find the Value of C. If the Value. of A is 1 Means you need to find value of C. If the value of A is 1. means if value of A is 1 then its correspomding, what will be the value of C. if you look carefully, then A attribute is in the R1 table. And C attribute is in the R2 table. So if these two have different tables, then you can't give the
answer of this query directly. To answer this query, We need to join these tables. I have to join these tables. Join is again very important topic in Database Basically in join, we are merging both the tables in a way. Now How we write? How to write the Query for that. Like, Select. Select. What we need to select Find the value.of C, if the value of A is 1 Find the value of C, where is the value of C? In R2 So means Select. R2.C Select R2 means Table Name Dot.Column name. Selected table Name.column Name. From From R2 Join Which join we are using here? Natural join. For the Types of Joins, you can see my video on Join. once here, we are straightly
using the Natural joim. I am explaining the natural join again here So that you get absolutely clearity of it. Selector R2.C from R2 Natural. Join R Select R2.C from R2 natural join R1 Where R1.A Equal to 1. Where R1.A =1 mean where In the table R1 the value of A is 1, corresponding to that i have to find value of C in R2 Here the main important thing is natural join, This is the important part. Natural join, actully what is natural join?  in the John database, we first cross product two tables. Then applied a condition on it. So firstly i have to cross
product these two tables. So how to do the cross product? First row of this table will be multiply  with all the others row. means if I have X number of rows in this table & Y number of rows in this table So the total number of rows in the cross product will be X into Y So here we are going to multiply the first row with these three rows You just need to follow this. like in the R1, i have two attributes, A & B. In the R2 i have two attributes, B& C.
Two girls are friends, now what's the first of the rest? One to? Now first row of the R1 is 1& 2. ! & 2 1, 2 will be multiplied with all the three rows of other. so what are the three rows 2, 1, 1, 2 2, 2 & 3, 2 3, 2 and now copied the 1, 2 from here  now the second row, of first table  will be multiply with all three means 2,2 2, 2  the first will be multiply with all. 2, 1 2, 2, 3 So we will copy from above Now The third row, 3, 3 will be multiply with all three rows 2, 1 Three, three will multiply by all three. 3, 3, 2 2, 3, 3 3, 2 So as we have discussed, that R1 has x number of rows, and R2 has Y number of rows, so totle number of rows will be X into Y. means if there are three rows in this. Three rows in that, then total will be nine So you can count, your total nine rows are here.. So what we have discussed is that what is actully join? Join is asctully a join is actully a cross product Plus some condition. So what is this natural join? Natural join is Cross Products plus some condition. What is the condition of it. Natural join always checks the equivalence of the common attributes. means two tables which
have common attribute. where are their values equal to each other. Whatever the common attributes in two tables whatever common,  as B is the common atribute here So where B is equal in this table 7 that table It will pick that row & reject the rest of the rows. So if you see here. These are R1 rows and these are of R2 So you see carefully First R1.2 And here 2 of R2 This one & this one both are equivalent. So if these two are equal. So that means It will select it. Select it. othervise will reject it, then here value of B, on both the sides are equal, so it will select that row also. Now see here Here the B's value is 2  here R1.B's value is 2 here  R2.B's value is 3 Means they are not equal. So, natural join will reject this row. No, 2, 2 Again equal, So means this row will be select 2, 2 again equal, this row will be select. 2, 3, here B's value is 2 here the B's value is 3 Means they are unequal. so it will reject this row. Three, two rejected Three, two again rejected. three, three select So Whatever the number of rows, which are selected Now see, now from here B is common attribute in R1 & R2. So if I join these two? so after joining you can write B once instead of writing twice. because he has allready selected that value of B, where the value is same in both the sides. So instead of write B twice, you can merge this table
and write it even once.  How? So this new table. can be rewrite like these After joining a new table has come we give them a name R,  or R dash  R dash And A came in it, B. And C B wrote once because
already in the natural join, whereever the value of B is equal, select that rows & reject the rest of them. So now you can remove those rows from here. So let's remove there rows from here, after merge them, write them in R dash table. So Rdash table will be heaving now  One Two, One One Two and One. One, Two, Two, One Two, Two Two, B will be Two & One  Two, Two, One A will be 2, B will be 2 & C is 2 So 2 2 2 3 B will be 3 & C will be 3 So 3 3 So, This is the Table after the join So this is the table after the join. Now Lets see. Select R2. C from this were R1. A=1 here the value of A is 1 at this point Value of A is 1 Value of A is 1 , but the value of C is 1 & 2 as well. for the value of A as 1 the value of C is coming 2 i.e 1& 2 And if you compare with the original table here. Because we divided this table into two and then join it again, that means this is the orignal table. We re-joined the original
table which we had earlier. But if you look  at carefully, in the orignal table three tuples are there. But when we saw them afetr joining, Then how many tuples are there? Five tuples It is not like magic . It is actully a flaw. That's  we call, Lossy Decomposition. Here when there are three
rows in the original table. So after joining, we devided that table & joined it again So, how the tables, How the table can contains five number of rows. So because of that,here  if you see the original If i have to answer this query according to the original table that find the value of C, where the value of A is 1 So here the value of A is 1 & corresponding to it, the value of C is 1 here. so the answer should be 1 only But if you look at this table carefully. after joining it if you see
the answer in this table. here for value of A as 1, here the value of c is coming two that is i.e. 1 & 2 which is the inconsistence. That means there is a big
problem in the database. according to one here are two values While the original table says that according of one there is only one value. So this is called the Lossy Decomposition. Why we are saying lossy? You might be thinking, that here i am getting something extras. I have not loss, there were three in the original table and rather i am getting five. I am getting profit here. No, no no  guys, we are not talking about the number of toples that it became three to five In this five, are all five valid? No, So that means, we haven not to see here, why we are saying lossy. we are saying lossy, in terms of inconsistency there is a duplicacy in database, There is a problem in database. So that problem we are saying Lossy decomposition. So if you see carefully, in the original table one-two-one. one-two-one. Two-two-two This is allready there,One- two-one is there Two-two-two is there Sorry 2, 2 Two-two-two is there And Three-three-two was there. That means there is only three
tuples in the original table. one-two-one Two-two-two & Three-three-two if you see these two tuples carefully One-Two-Two, Two-Two-One it's not in the original. So these are extra, means,there are inconsistency in
the database So this is a big flaw, it should not be there. So in the technical terms we called these extra tuples, Spurious toples Spurious toples fine, So these two toples which are extra because of it which, these decomposition is Lossy not lossless nad lossy in what term,  in terms of inconsistency There is a very big problem in the database. Due to which we called it, Lossy decomposition Now if we summarize this whole, Why is this problem coming? We just divided one table into two and then joined it again. So what we did wrong here? that rows has become three to five So you look carefully, when we divide the table in to R1 & R2 What was the common attribute there? we kept the common attribute, B. B So that we can keep any
attributes common here? Or is there any criteria to keep common. Yes, there is a criteria for that. So there is also a criteria to keep common what is the criteria? just note it down this very important. Common. attribute should be  candidate key or super key of either R1 or R2 or both. This is the very common condition for that the common attribute, whatever you are putting common
attribute in these two tables, that common attribute must be or should be the candidate key or super key of either R1 or R2, and you can say both means the candidate key in the original table, that is what we have to keep common between these two. So here, we did a huge mistake that we kept B common here. Because what are the values came in B? 2, 2, 3 which itself contains duplicacy, then how it will bring
consistency in the database. That's why we have to, If you look at A, then 1, 2, 3 Yes this can be the This is what the candidate key. So this can be the Common between the two attributes If you check for the C,1, 2, 2 No, there is also the duplicacy & B there is duplicacy in the data. So neither B can be kept common here nor C. For practice, in both the tables, you can keep C common here. Like here you can put AC in R 1 & BC in R2 But if you see carefully You will get spurious toples in it as well. means you will get lossy decomposition then what is the final solution. The final solution is In both the tables Whatever will be common that will be candidate key. So according to this table we have the candidate key, i.e. A because what is candidate key. which is unique. So which is unique here? A. 1, 2, 3 So means , whenever you decompose the table, that means, you have to put AB in one & AC in the other A B & AC in other. So if you follow this one. In which, you keep candiddate key common in both, Definitely you will not get any spurious tuples, you can try for that You have three tuples. When you decompose & join again, again three tuples will come this is called the Lossless join Decomposition So you can note down the condition for that. The first condition for the lossless join decomposition is Whenever you dcomposing the table into two, three or four, So whenever you take the union of it, like if you do R 1 union R2, that must be equivalent to R, means, if you take the union
of attribute which is in R1 & the attribute in R2, then the attribute of the original table should be equal. Like we have taken AB in R1 then AB union of AC So it is A B C And if you look at the original table, we have three attribute in the original table A B C means this is equivalent to A B C This is the first condition. The second condition is Second condition is Whenever we divide the table. into 2, 3, or 4 like we devided, decompose it into two,  if i check the intersection between them then must be not equivalent to the phi. means AB in in R1, AC is in R2. If we take the intersection between them, so what will be the intersection i.e.  A, which is not equivalent to phi What does it means whenever we decompose the two tables, there must be atleast one common attribute between them The third which is the most important condition, whatever you keep common here that must be the candidate key or super key of either R1 or R2 or both. Means either it is the cndidate key of R1 or the candidate key of R2 or both, means the candidate key can be either of the two. so this is the very import point overthere you can note it down Fine, so these is all about the Lossless VS Lossy Decomposition This is the same condition we use in  fifth Normal form. right, So you note it down, This is all about the Lossless VS Lossy Decomposition Thank you