hello everyone and welcome to my YouTube channel topic storage strategies which is a unit six of dbm ser which we are doing so today's video we will be covering following topics so these are the three methods as a part of storage strategies we will be covering today so first let's start with indexing index already normally coding indexing 1 2 3 [Music] 4 and IND now IND understand that so indexes are special lookup tables that the database search engine can use to speed up the data retrieval dat retri special look TBL by using the index indes a database index is a data structure that improves the speed of data retrieval operations on a database table just efficiency an index in database is very similar to an index in the back of a book just book number 62 I have to go indexes are used to retrieve data from the database very fast the the user cannot see the indexes they are just used to speed up the searches and queries so indexes as a user point of viewr point of view important updating the table with indexes takes more time than updating a table without because the indexes also need an update so only create index on columns that will be frequently searched against so the syntax usually which will be to create and drop the index will be this x will be create index the name of the index which we are giving on the table name on which you're creating an index and the column names inside that let's see an example create index and I'm giving the index name as index student name on student table with student name as a column now let's understand syntax to drop an index drop index the name of the table dot the name of the index which you have created earlier let's see an example drop index is your syntax student is your table name dot index student name this is the index name which you have created so this is how we can drop that index also dropping the index means deleting that index now what is indexing it is a way to optimize the performance of the database by minimizing the number of disk access required when a query is processed it is a data structured technique which is used to quickly locate and access the data data in a database for an example number from the student database just approximately let's say 60 students data stored of different divisions right so by using indexing it becomes very fast for me to locate this 15 role number in the database now index structure index is creating using few database column first search key and second pointer search key employe ID it becomes very easy for me to locate that data similarly student RO number primly ACC now pointer is based basically the block number address right so loc pointer is nothing but the address of that particular data block the First Column is the search key that contains a copy of the primary key or the candidate key exactly these values are stored and sorted order so that the corresponding data can be accessed quickly usually RO number employee ID primary Keys usually sorted and the second column which is this is nothing but a data reference which can contain a set of pointer holding the address of the disk block where that particular key can be found now indexing has various attributes the first one is access type this refers to the type of access such as value base search range access Etc access time it refers to the time needed to find that particular data element or set of elements the insertion time it refers to the time taken to find the appropriate Spates and insert a new data deletion time will be exactly time taken to find an item and delete it as well as update the index data structure space overhead it refers to the additional space required by the index I hope this terms are clear now let's understand different methods or different types of indexing which we have in dbms so there are three types of major indexing primary secondary clustering the primary further has it dense and sparse let's start with the primary indexing first if the index is created on the primary key of the table then it is known as primary index these primary keys are unique to each record which we already know that as the primary keys are stored in the sorted order the performance of the searching operation is quite efficient because it is very easy for me to loc number 9 8 7 6 5 St and proper ascending order it's very easy for me to go directly to the 10 so let's take an example there is a student table with role number name address City and mobile number as the few columns inside it so I'm creating an index with syntax create index I'm giving the index student role number on the student table with role number as the attribute so this is my index name this is my table name and this is my attribute name so the exercise for you that you have to create an primary index for employee table with the employee ID name address and city now like I said the primary index is further divided into dense index and sparse index let's understand them one by one DSE index there is an index record for every search key value in the database index we already know that the search key and pointer right for an example if I want to search number 1 2 3 4 and exact add datab 1 2 3 4 5 and so on data stored here right so for one it will access over here it will go over here it will go over over here so for every record we have an index key over here it is exactly the replica so in dense index there is an index record for every search key value like over here if you see 101 one2 one3 this makes searching faster but it requires a lot more space to store index records and every data BL add dat OCC in this the number of Records in the index table is same as the number of Records in the main table because exactly so record index record contains search key value and a pointer to the actual record on the dis we have understood that address store of this actual record now let's understand sparse index index records are not created for every search key it's like dense every search key record the index record appears only for few items in the data file it requires less space less number of index key generate less maintenance overhead for insertion deletions but is slower compared to the dense index for locating the records because1 first 4 104 so it took a little more time to check one by one each of them and then find this one soace OCC to search a record in sparse index we search for a value that is less than or equal to the value in index for which we are looking after getting the first record linear search is performed to retrieve the desired record4 101 if I start looking I will check 10 one is lesser than 104 I might try to find a Higher One 105 is the higher record then it will keep on doing the linear search to find 104 in this sparse in this in the sparse indexing as the size of the main table grows the size of the index table also grows similarly now let's understand the secondary indexing which is also called as multi-level indexing if I want to try and find record 101 first I will generate the index 101 there will be another multi level which is the secondary index from primary it will go to secondary and that record will fetch the data from the main table so to reduce the size of the mapping another level of indexing is introduced that's what we understand over here a huge range for the column is selected initially so that the mapping size of the first level becomes smaller over here then each range is further divided into smaller ranges like this range could be divided into two parts this range could be divided into further two parts the mapping of the first level is stored in the primary memory over here so that the address fetches faster the mapping of the second level and the actual data are stored in the secondary memory hard disk both of this are stored in the hard disk now how to find a particular record so if you want to find a record of role number 112 which is this then it will search the highest entry which is smaller than or equal to2 the first level index what it will get is 101 at this level then in the second indexing level so if we want to find the record role number 112 of naita then it will search the highest entry which is still smaller than or equal to 112 in the first level index so what is it going to get of course one one over here at this level then in the second index level again it does the max 112 less than equal to 112 and it will get this 111 over here so this is the first one this is the second one now using the address 111 it goes to the data block and starts searching each record till it gets 112 so it will start till it searches the record 112 2 so it will directly find the next value itself is 112 this is how the search is performed in this method inserting updating or deleting is also done in the same manner only so basically secondary index primary indexing level of indexing create secondary indexing over here now let's go to the next method which is clustering sometimes the index which is created on non primary key columns which may not be unique for each each record in this case to identify the record faster we will group two or more columns to get the unique value and create the index out of them this method is called as clustering method the records which have similar characteristic are grouped in indexes are created for these groups for an example here the index is created for the non key value primary key rare scenarios that I want to search data on a non key on key column so this is the department over here c e EC me right I will search for the similar data and group them together so the C has been grouped together e has been grouped together EC has been grouped together me has been grouped together however it will point to the first one with that group again e is pointing to the mea which is the first one EC will point to the first one AJ and Emy will point to the Nan first record in that group group so this is my index table and this is my main table from which it is accessing the record so it has grouped them first and then found the index of the first one and accordingly it pointed let's understand the next one which is B tree B tree is also called as balanced tree nowe already [Music] [Music] so this is what is called as balance tree so we can say that B3 is a data structure that stores the data in its node in a sorted order in a sorted order we can represent sample berries as follows for example like I told you there is one root node further there are Leaf nodes below that just remember this always that the left hand side is always lesser than the right hand side even in this if you see the keys over here it's an ascending order always so B stores the data in such a way that each node contains keys in an ascending order each each of these Keys has two references to another two child nodes over here like we see the left side child node keys are less than the current keys and the right side child node keys are greater than the current Keys we understand that that 11 is the current key so left hand side is lesser than that and right hand side is greater than that so suppose we want to search 18 in the above B Tre structure first we will fetch for the intermediary node which will direct to the leaf node that can contain a record for 18 so first we'll see this is the root node we want to search 18 so obviously 18 is greater than 11 so I will go on the right hand side only so in the intermediary node we will find a branch between 16 and 20 nodes over here further I will go to Leaf node so then at the end we will be redirected to the fifth leaf node here in dbms we will perform sequential search to find the 18 we will start from here and in a sequence we will start searching and there we will find 18 as a node now let's understand the next method which is nothing but hashing so for a huge database it can be almost next to impossible to search all the index's value through all its level and then reach the destination data block to retrieve the desired data so hashing is a technique to directly search the location of the desired data which we are looking for in a query on the disk without using the index structure so index structure use data is stored in a form of a data blocks we already know that whose address is generated by applying a hash function in this method since there are no indexes so the address is generated by using a hash function there are different hash functions we will see that in a memory location where these records are stored known as data block or it can be called as data bucket also hashing uses a hash functions with search Keys as parameters to generate the address of a data record data bucket and the memory location where the records are stored what is a hash function it's a function apps all set of search keys to actual record addresses generally the hash functions use as a primary key to generate the hash index address of the data block so the type of hashing methods which we have are static and dynamic we will understand them one by one but for now what is hashing database data so it becomes very difficult and timec consuming process indexing through search so hashing Techni which comes very handy function which we will use to generate the address of particular data block so there are two types of hashing methods one is static hashing and another one is dynamic hashing let's understand static hashing first in static hashing the resultant data bucket data bucket means what the data block address will always remain the same same for an example if you generate a address for say student ID equals 10 using a hashing function mod 3 now when you divide 10 by 3 what is the remainder you will get that is going to be one so your resultant bucket address will always be one it will not change so you will not see any change in the bucket so even if data grow address is going to be always one only therefore in the static hashing method the number of data buckets in memory always remain constant they never change Dynamic any gases exactly opposite so the drawback of the static hashing is that it does not expand or Shrink dynamically as the size of the database grows or shrinks dat bucket right so in Dynamic hashing data bucket grows or shrinks which means added or removed dynamically as the record will increase or decrease Dynamic hashing is also known as extended hashing as it can extend right so for an example in Dynamic hashing the hash function is made to produce a large number of values for example there are three data records D1 D2 and D3 the hash function generates three address address generate 0 1 01 1 0 1 and 1 0 1 0 respectively this method of storing considers only part of this address so for example initially it will take only first one one bit to store the data which is 0 and one so it tries to load three of them at address of 0 and one because in the third one also the first bit is one only so in zero and one may D1 D2 D3 don't now D1 is stored in zero D2 is stored in one but where will we store D3 because that is also one again so so as we see the problem that no bucket address is remaining for D3 the bucket has to go dynamically to accommodate D3 so it changes the address have two bits rather than one bit so for example one bit bit 0 1 1 Z and let's say 1 one so if you see over here D1 went at 01 D2 went on one Zer and D3 went on 1 one so it changes the address and have two bits rather than one bit and then it updates the existing data which have two bits address so update and then it will try to accommodate D3 so this was Dynamic hashing these are some majorly asked questions in exams which you have from this unit explain the indexing and the different types of indexes which we have understood today explain the B Tre and explain the hashing if you have any doubts or any question please do mention them in the comment section I will try to reply as much as I can also please try to complete all the exercise question if you do that you will be able to follow along the series very well and subscribe my channel and ring the bell icon for the next video I will see you in unit 7