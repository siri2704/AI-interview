hey welcome to giraffe Academy my name is Mike in this tutorial I'm gonna show you guys how to convert an ER diagram into a database schema so basically we're gonna take all of this information inside this ER diagram which we created in the last tutorial and we're actually gonna take this and use it to create an actual database schema so from this diagram right here we'll be able to you know create and define actual database tables that we can use in our relational database so let's go ahead and get started I'm gonna show you guys basically step-by-step how we can start converting this into database tables and database relations so the first step step one is the mapping of regular entity types so for each regular entity type we want to create a relation which is just a table that includes all of the simple attributes of that entity so here we have all of our regular entities we have branch client and employee so what we want to do is just create relations or you know basically database tables for each one of those regular entities and then the columns of those relations are gonna be all of these attributes that we define so from that from everything that's inside of the green squares we're gonna get something like this so we have our employee relation we have the employee ID which is the primary key first name last name birthdate sex and salary and we have the branch with that information that we have the client so I also want to show you guys when we had a composite attribute so this name attribute over here we're just storing the sub attributes so we're just storing first-name and lastname alright so here we have three relations and let's see if we can start adding to those so step two is the mapping of weak entity types so over here we have one weak entity type which is inside of this green square for each weak entity type we want to create a relation or a table that includes all of the simple attributes of the weak entity and the primary key for the new relation should be the partial key of the weak entity plus the primary key of its owner in this case the primary key of the owner is going to be branch I because the branch is the owner in other words the branch is the entity that's participating in the identifying relationship with branch supplier so over here we'll see what happens so you see we get this new table branch supplier and the primary key is branch ID supplier name and supply type so for this table we included the suppliers name and the branch ID both of those come together to make our composite key it's a compound key and then we have supply type and then we end up with this so now we have four tables employee branch client and branch supplier and they all have their associated attributes so step three is the mapping of binary one-to-one relationship types now a binary relationship is a relationship that has two entities participating in it for example all of the actual relationships up here are binary in other words there's two parties that are participating and what we want to do is map one-to-one relationships so we only have a single one-to-one relationship here it says manages or relationships so a branch can be managed by one employee and an employee can manage one branch so for each one-to-one binary relationship we want to include one side of the relationship as a foreign key and the other and we want a favored total participation so in this case we want to basically include the primary key of one of these entities as a foreign key in the other entities relation and we always want a favour the total participation so if a particular entity has total participation in the relationship then you want to add the foreign key onto that entity so in this case branch has a total participation so we're gonna add the employees ID as a foreign key in the branch relation if both of them are partial participation or both of them are total participation then you can just use your own discretion but in this case it's pretty clear that we're gonna use branch so over here on the branch relation I added in a foreign key which is just manager ID and this is a foreign key which points to this employees ID up here so that's how we're gonna link those two together step 4 is the mapping of buying one 2n relationship types so unlike a one-to-one relation now we're looking for one to N and you'll see that we have three of them here so branch handles a client and employee supervises or is supervised by another employee and a branch has employees working for it so basically what we want to do is we want to include the one side's primary key as a foreign key on the N side relation or table so basically what this means is that okay so for example in this case we have a branch and an employee I want to include the one sides primary key right in other words I want to include the branches primary key because that's on the one side as a foreign key on the employee relation so basically on the employee relation now we're gonna have a branch ID column that'll store a foreign key to the branch same thing down here for a client and branch so the branch over here is on the one side and basically what that means is that we're going to store in the client table a foreign key to the branch and then same goes for this supervisor relationship so on the employee table we want to store a foreign key to the supervisor so over here let's take a look so employee we have a super ID and we have branch ID and that's because the branch was on the one side of the relationship and the employee was on the N side of the relationship which means that we're going to go ahead and store the branches ID as a foreign key on the employee table and then the same goes for the supervisor ID so obviously with a supervisor ID it's pointing to the employee table so we have to store it on the employee table and then down here in the client table we stored as a foreign key the branch ID and again that's because the branch was on the one side of that cardinality relationship you see branches on the one side and the client was on the N side and so that's why we in stored we stored branch ID as a foreign key on the client table all right and then step five is the mapping of binary M to n relationship types so in this case we only have one instance of this a client can work with an employee and an employee can work with a client so what we want to do in this case is we want to create a new relation so we're actually going to create a new table whose primary key is a combination of both entities primary keys and we're also going to include any relationship attributes so over here the clients primary key is client ID the employee's primary key is employee ID so what we're going to do is create a new table where we have a composite key which is the employee ID and the client ID and actually this would would be what we call a compound key because both of its keys are actually foreign keys and we want to store in this relationship the attribute on the relationship or any attributes on the relationship which in this case is just sales so down here we created a new table or a new relation which is work song and you'll notice the key is employee ID and client ID so both of these individual parts of the primary key are actually foreign keys themselves so this is a special situation and then over here we have total sales which was the attribute that we stored on the relationship like that and so basically that in essence is going to allow us to take this ER diagram and convert it into relations now if you have more complex relationships like if you have non-binary relationships then it gets a little bit more complex when we're mapping them in this case I'm just kind of looking at basic ER diagrams I don't want to get too complex so in this case in five steps we were able to basically convert the ER diagram into a set of relations but if you do have more advanced types of ER diagrams then there are gonna be more steps but for our cases there's only going to be five steps that we need to basically convert this into relations and so now basically what we have here is we have our database tables right each of these relations is itself a database table so when I'm designing my database now I know I have to have an employee table with all this stuff a branch table with all this stuff client table etc and so what we can do also and what you'll see a lot of times is people will draw a little arrows to define the relationships so this can get a little bit messy which is why I kind of saved it for the end but you can see over here for employee on the employees for foreign keys I'm drawing arrows to what they relate to so for example super I di have an arrow going back to employee ID branch ID I have a little line here going over to branch ID manager idea over here we have a line going up to employee ID etc so this is basically just like mapping out all the different relationships this like I said it gets a little messy and it's pretty difficult to read if you have more than a couple tables but you'll also you'll see people doing this a lot so I just wanted to show you guys how that works so now that we have our you know essentially our relations our database tables we could actually create a database so over here I have an example of what a database might look like from these relations so we have our actual database so up here we have all of our employees and you'll notice that we have our employee IDs so we can define like the supervisor of each employee so like Angela Martin's supervisor is employee number 101 so Angela Martin supervisor is Michael Scott right you'll see how easy it is now for us to define all this stuff Angela Martin also works at branch ID number two so that links over here to the branch so branch two is Scranton etc and then we have our client table over here we have our works with table so the works with table has the employee ID and the client ID and then we have our branch supplier table so all of these got basically put into our database and then we started putting information in there and so really what this is is it's a way for us to go from just a set of requirements like we saw in the last video to our actual finished database table what you see here and designing a relational database schemas and you know the schema is just like this whole thing right it's not super easy right if you have a very simple database you know if you have a very simple set of data storage requirements then obviously the scheme is going to be very simple and you might not need something like an ER diagram but with something like this in the ER diagram is hugely useful so here's think you don't necessarily need the our diagram right you don't need it but it's a really really great way to convert requirements into an actual database schema or a set of relations and so that kind of shows you guys how you can do that now here's the thing with ER diagrams I only showed you guys one example and I think this is actually a pretty good example because it covers all of the main use cases but you know the only way that you're gonna get good at using the ER diagrams and building them and you know converting them into database schemas is just by doing it a bunch and so just by practicing so obviously I'm not gonna spend you know dozens of videos doing dozens of these examples but hopefully this example kind of shows you guys the basics and now you can go on and you know design your own ER diagrams and then convert them into database schemas following those rules and all the rules that I showed you guys for converting ER diagrams into relations though that's going to apply to any ER diagram so what we talked about in this video will you know you can basically take any ER diagram and convert it into something like this hey thanks for watching if you enjoyed the video please leave a like and subscribe to drop acad to be the first to know when we release new content also we're always looking to improve so if you have any constructive criticism or questions or anything leave a comment below finally if you're enjoying chopped Academy and you want to help us grow head over to draft Kadim e-comm forward slash contribute and invest in our future