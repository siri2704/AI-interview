in this video I'm going to discuss logical design so logical database design when we talk about database design in general there's usually two types of design we do there's logical design which is when we design our needs for how we're going to store data in a database without respect to the relational database management system in other words it doesn't matter if it's Oracle or MySQL or post gear we don't care what the rdbms is going to be we're to make our design irrespective of that we don't really care about what what's you know what type of system we're doing so it's regardless of the rdbms uh we don't care about the limitations of any particular database management system we don't care about the features or anything like that we try to put all that stuff aside and concentrate more on what our data needs are what are the things that we have to store how are they related to each other that's really what we're concentrating on in logical design later on once you finish the logical design you might move to a physical design and in physical design that's where we take our logical design and we adapt it for whatever particular database management system we're using so at that point we can start thinking about the limitations of certain dbms certain things that they can't do uh that we don't care about in a logical design and we can also think about some advantages of certain database Management Systems certain things they can do uh that maybe we don't didn't have to think about in The Logical design in this video I'm going to going to use some some vernacular that I'd like you to be familiar with so in logical design we typically use the terms entity and attribute but later on when we move to physical design which some of you may already be familiar with the term entity would become table so we call it a table in physical design that's our table in the database for example and an attribute is really a column or a field in that table and a collection of Records or rows uh can can form that table in the theoretical realm which in some CL database classes you go into database Theory uh they'll talk probably talk about tables as being relations so you may have heard that term I use the same term attribute and a tuple is a collection of Records so I just want you to be familiar with those terms again I'm going to use the terms entity and attribute since we're talking about uh logical database design in this particular video so in order to show a logical design one of the tools that we use to do that is an entity relationship diagram or an ER diagram I'm not going to talk to you about how to use any specific tools to create these diagrams Microsoft Vio is one popular tool from Microsoft there are many others out there and I have a video which shows you how to use Microsoft viio to create the diagrams that I discuss in this video so an ER diagram is basically a standard method to diagram entities their relationships and the attributes sometimes you'll hear me call it a modeling technique the modeling the term modeling technique is borrowed froml uh certainly if you're interested inl you can go take a look at that as well and I do have some videos that discuss uml uml has a diagram called class diagrams which is very similar to what we do with an ER diagram the syntax is a little bit different the focus is a little bit different but there are things that are very similar about that so I certainly encourage you to take a look ATL and be familiar with it you'll certainly see it in the industry quite a bit but ER diagrams are also quite common in fact in many projects I've seen both class diagrams and er diagrams the class diagrams may be more geared towards the software design whereas the ER diagrams are more toward geared towards the database design and they have their strengths and their weaknesses in both Realms but in this uh video I'm going to talk mostly about logical database design so we're going to use ER diagrams they they certainly lend very well prior to creating an ER diagram a few things should have been completed you should have done some analysis about your needs for this database you would have identified nouns so in your analysis you may have done interviews you may have collected artifacts such as business documents you may have looked at standard operating procedures you may have done some questionnaires there's various ways that you would gather all the information about what the system needs to do do and what the database needs to store you would have picked from that your nouns which is a person place or thing you would have grouped those nouns into common themes so you would find groups of nouns grouping into common themes those common themes that you identify become our entities or our tables in our database other nouns uh would become the attributes which describe those common themes so you have a major topic which is our common theme and then you have nouns that describe those so you're sort of subdividing which nouns describe something and which ones are something that we are actually going to keep track of in the database some of the nouns will uniquely identify a specific instance of an entity in some cases it may be a collection of nouns that describe something and in some cases a single noun May describe an entire record in most cases you want to try to find something that's going to primarily identify or uniquely identify any single instance of an entity and we'll call that a primary key and we probably talked about in other videos about other uh about primary keys and what they are and I'll touch on that a little bit again in this video so what exactly is an entity as I discussed an entity is that person place or thing that we have to keep track of in our database once you know what all of your primary entities are going to be or the major topics you've identified we have to diagram those the way you diagram an entity is you draw a box and in the the top of that box you're going to have the name of the entity the entity's name and that will eventually become our table name in a physical design below that in the bottom of the Box you're going to have attributes so you're going to list the attributes one on top of the other just as you see here in addition one of those attributes that you've identified is going to be the primary key it gets a special place in the diagram so it gets its own slot underneath the entity name if you have multiple fields or multiple attributes that make up a primary key you would list all of them in that top section it's typical to underline those and in many cases in some tools you'll have the ability to have this extra little area on the left where you can identify which are primary keys and forign keys now in logical design we're not worried about foreign keys yet although I'll talk about those so you understand the concept uh but in many cases when you label something as a primary key it'll give you the little identifier PK next to it in that area off to the leftand side but again it's typical in some drawing tools to underline uh and put PK next to it and sometimes the PK is off by itself in that left hand side in that box I know in Microsoft Vio it'll look very similar to this but in other drawing tools it may look a little bit different the important thing is we should be able to easily identify which of the attributes is a primary and a foreign key we should be able to easily figure out what the entity's name is and we should see a list of all of those attributes so these are the four basic parts of an entity in an entity relationship diagram there are different types of entities so these are just a few types of entities a domain entity is any entity that describes the Core Business uh or something that we're to which we're trying to solve the problem with this database so for example in a customer relationship system the customer would be a domain entity their phone number may be a domain entity for example linking is when we use extra tables or extra entities to connect other entities together and you'll see that later on we usually do that when we get to uh more into the design um the physical design that is lookups can be for lookup values to uh ensure data Integrity for example um if you have uh maybe patients you can have uh male or female so you might have a lookup to make sure you're putting invalid values for that uh it could be maybe male female or other or something like that and then you have weak entities which depend on another entity for its meaning um for example the phone number doesn't really mean anything unless it's attached to some other object like a person or a customer or an employee and so forth and so on so that might be an example of a weak entity let's not worry too much about those types for right now the important thing is once we have our blocks with all of our entities and as I said before we're going to start with the entity name we're going to list all of our attributes and one of those attributes is going to be something like uh in this case the ISBN is the primary key for a book so this might be a database that's going to contain books now the books as you know uh would probably have an author right so most books have an author and we might have a primary key in this case I made one up called author key so these two tables are these two entities have a relationship to one another and to show that relationship I would draw a line between the two now I didn't talk about foreign keys but when we get to design we're going to talk more about foreign keys so a foreign key is how we relate to another table uh and again I we'll talk more about that in the design I just wanted to show you real quick that typically you would also see in these diagrams the far and key I also want to mention too that if you look at the ISBN we talked about this before um that primary key would be a natural key so that's a good example of a natural key if you recall from earlier uh when we talked about in in an earlier video we would have talked about the different types of primary keys so a natural key is one that we didn't make up so anytime you have an attribute that we don't make up but yet uniquely identifies an entity that's a natural key on the other hand the other table I made up that key author key so I made that up that's the primary key it's the the prim it's uniquely identifies an author but there isn't anything inherently unique about an author so I had to make something up so that is a surrogate key so it's a good example of a surrogate key now there are several different ways to show the relationship between different entities and I'm going to talk about two well I'll talk sort of about three uh notation Styles different types of notations you can use the simplest is the arrowhead notation and that's simply where you draw a line from the prim table to the foreign table so you can see in this example a book has an author so my arrow points to the author in other words the forign key points to the primary key and author and that's why I wanted to show the forign key in this particular diagram so you can see that eventually the forign keys would be in that uh left-and side table in this example and it would point to a primary key in another table so the arrowhead notation is okay it doesn't give us a lot of information about cardinality which I'm going to talk about in just a minute but the other notation we can use is crowsfoot this is a pretty common notation in ER diagrams and it's used in Microsoft Vio so if you're going to use Microsoft viio you'll see the Crow Foot notation it's you know when you go to create your diagram in Vio that's that'll be one of the options The Crow Foot notation and this one has several different symbols so when you look at crowsfoot the circle means zero the the uh straight line is going to mean one and the Crow's foot means many and you'll know what this means in a little bit we're going to talk about this in more detail uh but that refers to the cardinality so when we talk about cardinality that is the degree to which different entities are related or the numbers of things that can be related to the number of things on the other side I'll show you an example so here we have a book on the left a book has one and only one one author for an example so I would show the symbol and you can see I've added the symbol on the right hand side of our relationship line I added a symbol that has one and only one so I would read it as the book which is on the left and then I would look at the relationship symbol or the notation uh in this case the Crowfoot notation on the right hand side as it connects to author so I'm reading a book as it connects the author so a book has one and only one author then I would read the other way so it started author and I might say that an author has one or more books so an author can write many I'm sorry one or many books or one or more books however a book can have one and only one author now some of you may be saying Brian wait a second books can have many different authors you can have a couple different authors of a book and yes that's absolutely true you could so in many cases there's lots of different ways that you can interpret the cardinality or how tables relate or how entities relate to one another but in many cases we can look to the business rules that we discovered in the analysis phase so when we do our requirements Gathering and our analysis those business rules that we turn up may help us determine what the correct cardinality is so in this particular case perhaps there is a business rule that I can only have one author per book it'd be a strange business rule but if that's a business rule we would Express that in the database and in our logical design by showing that business bus rule uh so again you can look at those business rules to kind of determine what that cardinality should be if it's not determined in the business rules then you have to use your best judgment to figure out what that cardinality would be so this is an example of the cardinality between book and author some cases as you can see here we have repeating fields in an entity and this is not good so T technically typically when you see repeating fields and you can see in this case I have subject one subject two subject three anytime you see a number on the end of an attribute that's usually not a good thing there's usually a hidden attribute in there so in this case we're going to take any repeating fields that we see like this and you can create a new entity for that so in this case I move the subjects into a new entity and for example I could show that a book can have one to three subjects and a subject can appear in zero or many books um so that's a different notation style this is more like a class diagram you might find inl but it is also a notation style that you could use it's an alternative to the Crow Foot and again it can be used in Microsoft Vio so this could also be I kind of like this notation because it has a little bit more information than the crows foot so in the crows foot for example I couldn't show the exact minimum and maximum cardinality I couldn't say how many maximum records there could be or minimum records but with this notation I can I can use an integer to show exactly how many records I can have so when I read this I would say a book can have one to three subjects and a subject can have zero to many books and if you think about it that's a business rule that might make sense if you go to the library back in the old days with the card cataloges most books could only have three subjects so you had three primary subject areas and they would put you know a card for each subject area in the card catalog so if you're looking up by subject now of course today most cataloging systems can support far more than three subjects but that could be a business rule that we could express with this type of notation now we haven't normalized this yet but what we've kind of done here is taken a first step towards normalization I'm going to talk more about normalization in a later video I don't want you to think if you if you if you're familiar with no u normalization don't think that you have to start normalizing during The Logical design we're going to talk about that later later on again we want to separate that physical design from The Logical design we're really just trying to think about the entities and how they relate to one another during The Logical design and then we'll move to the next step in the physical design where we start to normalize that database so don't worry too much about normalization yet onetoone relation we have a couple different types of relationships um so a onetoone relationship is a relationship where for each record in the primary key table there is no more than one related record in the forign key table um so typically a one: one can be either one exactly one on one side to exactly one on the other side or it could be one on one side to zero or one on the other side so it could be optional to one so it doesn't have to be exactly one sometimes is none or one but the point is there are there's never many you can never have many of anything on either side it's always a one to one match on each side so let's there's a couple different examples but you won't see onetoone relationships very often many of you when you create an ER diagram you may not see any onetoone relationships because they're not commonly used but one way you could use them is to obviate the need to store null values in a table another place that we see them sometimes is for security to uh segregate different parts of information about a single entity if you need to store it in two different places um so null just so you know means nothing we haven't talked about the term null in these videos yet but a null basically means that there's nothing there it's the absence of any data uh it doesn't mean zero so some students will say well null must mean a zero but that's not exactly true zero is a number but a null is literally nothing is there at all not even a zero um why do we not want to store nulls nulls can ruin your day in databases we'll talk about why later on but it's generally best practice if you can avoid putting nulls in your database it's a good idea to avoid that so a onetoone relationship gives us a way to do that let me show you what I mean take for example our books now a typical bookstore like Barnes & Noble or something like that they don't just sell books they also sell music and they sell magazines and they sell movies and so forth and so on so maybe instead of having a table called books I have a table called media and it could describe any one of those things that we sell so I have a primary key here I've changed it to Media key instead of the ISBN because now it's not a book it may not necessarily have an ISBN so I have to create my surrogate key uh I have a title format release release date publisher ISBN issue volume and so forth now if you think about it if this were my table these are what the values of that table would look like so for example the first record is a book it only has a publisher and an ISBN books don't typically have issues in volumes uh they don't always and of course format and release date might not apply to a book either however format and release date would apply to a movie so Rocky is a movie I might sell a format that is Blu-ray that was released on 1121 1976 uh and likewise I could sell magazines and a magazine maybe wouldn't have an ISBN number it maybe wouldn't have a format but it would definitely have an issue and a volume number so different things are important to me in different uh um in different ways for this particular entity so maybe I don't really have a single entity here I have an entity with some weak relationships um and I'll show you what I mean so me all media regardless will always have a title so I can leave the title in my media entity however I could take the format and release date which I know are typically for movies or videos and I can move that to a new table called video then I'll take publisher and ISBN which I know are usually for books and move that to a book table and I'll take my issue and volume which are typically for magazines and move it to a magazine table so now this is what my database will look like and when I store data it's going to look more like this notice there are no nulls now because my title exists in the media entity and then I have an entity each for these different types of media so I don't have to store all those null values that you see at the bottom it doesn't really save us on any storage space we'd really be using about the same amount of storage so some students will say oh maybe this will save space but not so much but what it does is it it relieves the need for us to store nulls in our database so it makes it much cleaner it's generally best practice to avoid those nulls so that's one use of a one to one and if I were going to diagram that it might look like this so my media can have one video Zero many videos zero many books zero many magazines a magazine can uh be in zero or uh one media and really that zero to one probably should be a one to one uh so magazin should all magazines should have one and only one media all book should have one and only one media and so forth and so on so I could certainly make that change this diagram It's A Minor error here but that's roughly what one of these uh uh ER diagrams what it would look like if we had some onetoone relationships so another use of a onet to one is for security take for example if I had an employee table everyone should be able to look up an employees last name and a first name and maybe some other details like their email address or phone number and so forth and so on how however two attributes about an employee that I would not want everybody to have access to would be social security number and salary but that entity you know when we do our initial run through the analysis that entity has these attributes those are all unique attributes about an employee an employee doesn't have multiple salaries they don't have multiple ssns so they all apply uniquely to that employee but I want to separate that for security reasons um so you can move that to another table uh so it would look something like this so every employee would have one and only one employee payroll record and an employee payroll roll record always relates back to one and only one employee one thing I want to mention about what I've showed you here with the onetoone relationships is in many cases these decisions to go to onetoone relationships are being made in the database design not necessarily in The Logical design so I'm thinking for example with security I'm thinking about the limitation that most database engines do not allow you to limit access to certain columns you can only do that at the table level or at least it's you know only feasible to do it at the table level for a large database so it becomes easier to separate that data so that might be the real reason for doing this but in reality it's okay if it's all in one table in my logical design same with the other scenario for the onetoone relationship um when we have uh null values you know that's again that might be a database limitation that certain functions break when you have null values so it's best practice not to do that so that's a decision we would probably make in the design phase but I just want you to understand why we might have a onetoone relationship a lot of students when they look at logical design they say I must be doing something wrong because I don't have any onetoone relationships and that's simply not true it's going to be pretty common for many of you when you do an ER diagram to not have onetoone relationships they're not very common now one that is very common is a Ono many relationship you'll have a lot of onet to many relationships uh they are by far the most common relationship between tables or between entities I really should say in most ER diagrams and in most databases in general for each record in the parent there can be zero to many or infinite records in the child so if you look at my example at the bottom an employee can exist in one or many departments and a department can contain zero or one employee and that Crow Foot notation shows you that in that little diagram and again this is the most common Rel relationship you're going to see is a one to many now one thing you might run into when you do these uh these types of relationships these one to many some students have the tendency to think well an employee can be in one or many departments and a department can have zero or one employee but also a uh employee can have zero or one department and a department can have zero or many employees so they might look at it two different ways and people will get confused because they're looking at it in two different directions but you can't do that and if you do think that it's possible that the department um you know that this could happen and you were to design it like this if in your logical uh um database diagram what you end up with with is a stalemate there's no way to have this type of relationship because an employee can't be in a department until a department has employees right so I can't create my department if it doesn't have any employees and I can't create my employee if they don't have a department so you get into this stalemate situation going around and around the board so if you do see a relationship like this typically it means what you actually have is a many to many relationship which is okay you can have many to many relationships so if you find yourself in this conundrum where you've got many things on both sides and you're trying to force it into a on to many relationship instead what you probably have is this a many to many relationship and in fact this is probably what an employee and Department relationship would look like because employees can be in one or many departments and departments can have zero or many employees in and of course this all depends on the business rules but assuming the business rules support this you might have a diagram that looks like this so one to many you can have each record in the primary entity can have many related records in any related entity there really is no primary entity here they're both primary entities because they both can have many records in the in in the uh pier in the related uh entity the thing about these many many relationships is they can be shown in our logical design but later on when you do a physical design you're going to have to get rid of these many to many relationships you're going have to find a way to uh correct this so that you don't have it there is no database management system that can support or at least not any relational database Management systems that can support a many to many relationship so you won't be able to have this later on in your physical design and you wouldn't be able to codify this into any kind of code to build a SQL datab datase you wouldn't be able to build a relational database if this is the relationship however in your logical design it is valid to have this so it is okay in The Logical design but when we step into the physical design we're going to do some things to make sure that this doesn't happen the other thing I want to mention real quick in our physical design is we would also be adding our foreign keys so we would start to think about those foreign keys and we would use that logical design to determine where those forign keys are going to go and what they're going to be so I'll talk about that later on when we talk about the physical design there are some advantages to using naming conventions so now that we know how to create these diagrams when you're putting things in the diagram when you're labeling things it's important to use some kind of consistent naming conventions as you do this so entities or tables they're typically named with single nouns it's um you know a lot of folks have the tendency to want to call a book table books because it's going to contain lots of books but but most people tend to use singular nouns when they uh name an entity so it's a good idea to can be consistent and use that it's kind of an industry standard although at the end of the day is it going to break anything to use a non- singular noun of course not everything will work fine but as a matter of convention usually that's how it's done attribute names typically we want those to be unique will it break anything if they're not unique in a database no uh it'll work fine but to reluce the ambiguity generally we recommend keeping all the attributes uh unique one way you can do that is always prefix the um the attribute name with the name of the table in which it appears so if you have last name in the employee table instead of just having last name you can have employee last name so that it's not ambiguous you know exactly what that attribute is primary Keys uh can also be consistently named so for example if I have an employee table and I have a primary key I might call it employee key uh and if I have a department table I might call it Department key for the primary key so you can keep those names consistent as well so that anytime you're looking at a list of attributes it's easy for you to pick out which one is the primary key again these are not required rules they're just best practices firing key should also retain the same attribute name as the primary key to which it references and we're going to use primary Keys more later on in our physical design um one thing I want to note here too is is generally we don't want to have spaces between our words so if you have multiple words in an attribute name or in an entity name or anything for that matter you generally don't want to have spaces in that uh but it's also hard to read when there's no spaces so if you take a look at employee key that's two words put together so one of the other conventions that's pretty common is to use uppercase letters for to separate the words rather than a space so instead of having employee space key I have employee key but the K is capitalized and also notice that the E on the front is lowercase again it's just a convention uh it won't break anything if you don't use my conventions here but these are pretty common conventions in fact the one I'm describing here for employee key is typically called the Camelback notation so you'll hear that called Camelback notation because it's got the humps right you're reading the words and it and they have humps uh and it is a pretty good way to write that out without the spaces if you don't do the capitalization it gets harder to read those hard to see them so it's a good idea and again these are all just conventions they're not necessarily required once you finish the ER diagrams a picture is worth a thousand words so it's a good idea to keep these around you're going to use these ER diagrams when you do your physical design later on so definitely keep these diagrams keep them handy you're going to use them as you go through the process and it's always good to have these diagrams to go back to in a complicated design so you know why you made a certain design decision so again it's a good idea to keep them laying around so we can go back and reference them later on so documentation is of course important we're going to use them in physical design uh we're going to use them when we do normalization uh as we generate SQL code we're going to go back and use these ER diagrams whether it's a logical design or a physical design so let's tie it all together uh here's all the tables I used in my examples so when you create an ER diagram it'll look something like this you're going to have all your different entities ities you're going to have um and all your relationships between those entities not every entity relates to every entity you can see here we have kind of two islands in this entity relationship diagram you've got the book stuff on the left or on the right hand side and on that bottom left we've got some employee stuff uh so they're not directly related to one another um notice too I'm missing my primary key on some of these in a good entity relationship diagram you would of course have all of your primary Keys identified since it's a logical ER diagram you don't necessarily need to start thinking about the foreign keys yet we're going to cover that in the physical design uh and you also um wouldn't have to worry about data types and things like that so we'll talk about that stuff later on so that's how we do a logical design using entity relationship diagrams if you have any questions let me know in the comments thank you for watching