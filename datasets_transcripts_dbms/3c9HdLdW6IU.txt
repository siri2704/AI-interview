>> Manidipa POD: Hi. Good evening everyone around.  >> P Baskaran Nadar: Not.  >> Manidipa POD: So you had one session for week 10, Right. Can anyone just tell me what part of it is left?  Up to, which part was covered was serializability covered.  I think not a lot of people joined that session because it was just before the exam.  So, I think the locking part serializability, these things were not covered in week 10. So we are probably going to have one extra session for that. Or if it's not possible, then we are going to take that up during the revision sessions. Because anyway, I think the deadline is gone for week 10. So today we are going to start week 11.  WEEK 11, We will cover all the concepts today, next.  >> CHANDRADITYA SINGH: Man. Sorry man. I have a simple doubt.  >> Manidipa POD: Yeah.  >> CHANDRADITYA SINGH: a general note about reattempt, so, how to know that I am eligible for that or  >> Manidipa POD: Opiated. >> CHANDRADITYA SINGH: Yeah.  >> Manidipa POD: in the grading, document is the criteria mentioned Think it should be there.  >> CHANDRADITYA SINGH: Because I didn't get the.  >> Manidipa POD: Okay, yeah, then you should be eligible for the attempt.  >> CHANDRADITYA SINGH: But in the dashboard the score is showing 80 and I don't think it's very fail or So, that's  >> Manidipa POD: Yeah, but that's the mandatory question. It's overall score. You got 40% above but The mandatory question has to be passed. Okay. Yeah you should be eligible. Let me ask you servants. So did you get any email regarding that?  >> CHANDRADITYA SINGH: Yeah, no, it was a general email that it was schools. Not any personal email that you are available for Opie or not.  >> Manidipa POD: Okay.  I think you should be eligible. So what you can do is you can write a mail to support, okay? Or you can just make a post and discourse and ask you sir. Just tag him in that. That what's the procedure for reattempt?  >> CHANDRADITYA SINGH: Here. Okay, so if someone is a fail to its own in Dashboard now, like a copy field,  >> Manidipa POD: Yeah. But see your overall score is above 40%, right? But you did not solve the mandatory question.  >> CHANDRADITYA SINGH: Okay.  >> Manidipa POD: So I think that's why it's not showing.  >> CHANDRADITYA SINGH: I have written the code but didn't win the answer, right?  >> Manidipa POD: Yeah, so that those are the two criteria for passing a period, 40% all over and the python to be questioned.  >> CHANDRADITYA SINGH: okay, post  >> Manidipa POD: Just make yeah, just make a post and tag me your future. Alright. So week 11, we are going to start today. We are going to discuss all the  concepts today and your practice and activity questions will be done in Saturday class.  Yeah. Is the PDF visible to you? So see in your N term examination from these last four weeks.  9, 10 11, 12. There is going to be a 50 to 55 percent weightage, right? And the maximum number of questions are from that are going to come from week 9, 10 11, these three week 10 is very important so whatever is not covered. We are definitely going to cover that in an extra session or individual session. So Week 11 is about backup and recovery. okay, so if you have gone through, at least the videos in week, 10, then you  know about transactions, right? And something we call as transaction logs. So transactions are what? Like simply like a money transaction, like we do in banks, right? So we transfer money from one account to another account. Just like that in a schedule There are multiple transactions. Now, there are two types of  schedules. One can be a serial schedule. One can be a concurrent schedule, so you know, serial schedule. What happens? The transactions happen, one after another. They don't happen at the same time, right? Like if I want to transfer 50 rupees from my account to your account, so  this is one transaction, let's call it t. 1 Right. If this is a schedule, In a serial schedule. Now, if I have two transactions, T1, and T2, So the way transactions work is first, you have to read, right? So, Let's say a wants to transfer 50 rupees to these account. So first, I will read, whatever the balance is there, that is in A's account, okay? Because if he doesn't have 50 rupees, he can transfer. Then I will do whatever the changes I want to make, so is account if I want to deduct 50 rupees, And then I'll write back the final value that is now present in as account. okay? But at the same time, this transaction, the 50 rupees that I have taken out, this has to be transferred to these account, right? So in these account what is happening, I mean, in these account first, I again, read the Amount that is present currently. And then I add that 50 rupees to his account and right back the final value. So after each of these transactions, I have to do something called a commit to make sure that these changes are persistent right? That they don't get reversed or deleted somehow. so once a transaction has been committed, everything that we have changed or  whatever manipulation we have performed in a transaction is now permanent and those changes will show in the database So this example, right here is a serial schedule. So once T1 completes execution then only T2 will begin execution. Now, there are another type of  transaction as well, which is called concurrent transaction concurrent schedule. So, in that case, the these two These operations are interleaved. So, maybe first it's it can be like this. So, first I read from is account. Then I deduct 50 rupees.  Then I again start executing T2. I read from these account, then I add the 50 rupees So like this whenever these two transactions get Interlift, that means they're  occurring at the same time so it's a parallel, a concurrent transaction. So realizability. I don't know if it has been discussed but it only occurs in case of this concurrent transactions, right? That is the only time when there is a  possibility that some inconsistency might happen in the database, let's say to  transactions are running. Concurrently Now the money was deducted from one account but it never got added to the account where it was being sent to  So, the total sum of before and after a transaction should always remain same. Like if a had 50 rupees and B had 0 rupees in the beginning, right? and then A transferred this 50 to B, so now, >> P Baskaran Nadar: that's,  >> Manidipa POD: Yeah. >> P Baskaran Nadar: I,  Debiting and crediting should happen in the same transaction. >> Manidipa POD: Yes. But I am, I am breaking down this into two just as an example. Look at this whole thing can happen in T1. Only. I'm just >> P Baskaran Nadar: Well. It should. Yes.  >> Manidipa POD: Okay, so if you want, you can take this entire thing as a whole transaction and entire and the transaction is T2. Okay? That will make it clear since I'm not using the slides, This is just a small example, just a brief. Okay.  so, when 0 B had 0 initially and A had 15 initially,  And then 50 is transferred to B. So now A has 0 and B has 50. So this entire sum of 50 rupees should remain consistent before and after, right? So whenever some kind of dispute happens in the middle of the transaction, then this consistency will be broken. And in most cases, concurrent transactions are where this dispute happens. So that's where we have the concept of serializability. So that's where we check. That  whether a concurrent schedule means a group of transactions. So whether a concurrent schedule, is equivalent to a  Serial schedule. Okay, so if we can manipulate the transaction, the different statements in the transactions in such a way that it can give me a serial  schedule, which is having the exact same effect on the database. Then we can say that these two are equivalent. Okay. Now, all of these transactions is read, Write operations, commit operations. Whatever is happening. A log is kept of every action. So that is called your transaction log. So whenever any kind of dispute happens in a transaction and we need to reverse it. That's when we go to the transaction logs to get the database back to the  last stable state, or the last consistent state. So we have to reverse our actions or undo,  and in some cases, we will do the undo operation that is we will undo all the changes we have done till now and in some cases we will redo them also. So after we do the undo, operation will again, do the redo operation. Okay. So these are all part of recovery. Now before that we will get into what is the backup.  Right? So a backup is nothing but a representative copy of data, right? So whenever we use backups in our phones or you can see that your chats are backed up. So there is basically a copy of your data that is stored in case you lose the data, somehow you can get it from the backup. Right. Then there are two different types of backups here. So there are different classification. This is just one classification. One is physical backup. One is logical backup. So when I keep a copy of the physical database file such as the actual data, the log files. These transaction logs, right? When I keep a copy of these, these are called physical backup. Logical backup is when you keep a copy of the logical data that is extracted from a database. So, logical. Data means what just like the  logical level of schema, right? So we have the tables, the procedures, the different views So, the different functions that we use. All of this forms the part of the logical backup. These are two different sets.  So in case of unexpected failures in the database, maybe some kind of server error, whatever failure happens. If you have a backup, you can still reload the database to its last stable state. Now, recovery is the process where we do this restoration, okay?  So this restoration is done based on the database log records of all the transactions in the proper sequence in whatever. If t 1 occurred after T2, then then backup will just undo it. I mean recovery will just undo it like that first. It will undo T2, then it will undo T1. okay, now typical log file will contain information about every transaction that has been executed all the different transaction states. What values were modified all of this. So, the type of backups that we are going to discuss is this? The Backup strategies, Right? So there are three different backup strategies First is the full backup. Full backup means it is backing up everything, okay? All the data is going backed up. Let's say we have a company and a company will obviously have a large database in multiple files. You know, employ files. Project files everything. So, a full backup does an entire backup of the entire database. Now this is a complete copy, which stores every object it has Tables procedures, function views, index everything. So a full backup is the best way to restore all components of the database. Just like it was before the crash happened.  Right in a full backup. Needs to be done at least once before any of the other different types of backups that we're going to discuss. So you'll see that we have multiple questions in Pyqs as well where we give you a backup schedule for a company, right? so, On some days, you will see there is a differential backup being performed on some day. You'll see an incremental backup in performed, but there is always, at least one full backup, right? Because without the full backup, the other two types of backup cannot restore everything. Okay, the frequency of full backup now that will depend on what your  requirements are now. Usually full backups are not done on a days daily basis. you know,  Because they are very costly and they take a lot of storage. So full backups usually are done. Maybe once a month. Now, there are also applications that need a full backup done on daily basis,  you know. So where that can be true is that if you if you have a 24/7 if you have such a company by 24/7, availability of the server, is not a requirement That means, if even if your server is blocked, and you're taking the backup. So during the time of the backup. So what we are discussing right now is called cold, backup strategy, okay? Hold back up means while you're taking the backup.  Nothing else. I mean the server cannot be. Accessed, the database. Cannot be accessed. Okay, everything is at a halt while you're taking the backup. So if you have such a work environment where this is not a problem, 24/7, availability is not a requirement, then you can perform full backups every day. Okay. Now, backup administrators may not be available on a daily basis. So primary goal is what to reduce to a bare minimum amount of media that we are required that are required for a complete restoration of the database,  so, full backups are Costly take more storage and are usually not done on a daily basis. So there has to be some kind of backup that we can do on a daily basis that does not take as much time or as much cost. So that is your incremental backup so  incremental backup will target. Only those files or items that have changed since the last backup So, the last backup can be anything, okay? It can be a full backup, maybe you did a full backup on Monday, okay, after that, you changed some files, then on Tuesday night, you want to do an incremental backup, which will just back up the changed files. Nothing else. Wherever changes or modifications, I've been done  Only those files will be backed up. Now, the previous day backup, can be full. Can we IMPLEMENTAL can be  differential, doesn't matter an incremental backup will only restore, sorry, make a copy of the modified files, right? So these are smaller backups. They are, they're not backing up the entire database. So they need a very short duration to complete compared to full backups.  Okay. Now for most organizations, full backup is done once a week, once a month, like this and incremental backups are done for the rest of the time. So a backup schedule can be like this, that's given below. You can see on Friday, there is a full backup that we're doing. Then on Saturday, we're doing an incremental backup. So whatever files change between Friday to Saturday. Only those are being backed up now. All other days you can see are incremental backups so then you do the full backup again next week on Friday. So this ensures that the backup window is very minimum during the peak  activities because in most companies or whoever's music and database is requiring, 24/7, availability, right? You cannot have your system down for half the day for a full backup. So this keeps incremental backup keeps the backup window, very minimal so that you can still have all your other activities running smoothly. Now, the third type of backup is differential backup. So, differential backup what it does. Is it backs up all the changes that have occurred since the most recent, full backup. Okay. Not incremental, not differential. So, if a full backup happened on Monday, then two more backups happened incremental backups on, Tuesdays, Tuesday, and Wednesday, then, if you have a differential backup, it will backup every change from that last full backup on  Monday. Okay, not from the last like last backup, if it is, incremental it won't take it from there. It will take from the full backup so differential backup rolls up a lot of changes into a single backup job. So obviously this will take more time than incremental backup but less time, then full backup also more space than incremental but less space and pull back up. so, differential backup does not backup everything like a full backup but it will process every change that has occurred since the last full backup. Right.  so, to evaluate how these types of backups work You can consider this schedule. So on Friday, you can see, there is a full backup then on Saturday this incremental will roll up the changes between Friday and Saturday. This incremental on Sunday will roll up changes between Sunday, Saturday and Sunday. Then this between Sunday and Monday, but on Tuesday, there is a differential backup. So this differential backup on Tuesday will roll up all changes generating after this full backup on Friday. Everything rolled up into this backup Right. so,  Recovery on any given day. Okay, so let's say your your system crashes on this Thursday. Okay, then, what data do you need?  so you need the full backup, the most recent differential backup and if there has been any more incremental backups after that, Okay, so if I say that, The fullback of happened on Friday. Differential happened on Tuesday and Wednesday also, it was fine, but on Thursday, we had a system crash. So, we need to get it back to the last stable state. So, at that time, which backup sets you will load, you will load the set full backup set from Friday. The load the full, differential backup set from Tuesday because that rolls all these changes Sunday and Monday. And you will take you have to take the incremental backup set from Wednesday  because you cannot find it anywhere else, right? No more. A differentials were done after that. So three backup sets are enough for this case, if on Thursday was a crash.  He does a graph makes it look easier. Differential roles up all the changes so everything in these incrementals are rolled up in differential after that the incremental changes are on their own, right?  So this is also good example. Let's say on Ah, Yeah.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: To a man.  >> Manidipa POD: yeah, this  >> SANDEEPKUMAR SUDHAKAR SURKUTE: Only the changes of that day.  >> Manidipa POD: Yes. See here on this, the full backup is performed, right? And only file, A is there. Now after this day, three more files are added. We see So these modified or new files are going to be backed up in the next day's incremental backup, it will not backup the file. A that was already backed up.  okay, only the modifications then after that vcdr added then some new file F is added on the next day so the differential backup what it does. Is it will take every change from the last full backup so it will backup BCD, as well as it. Okay, after differential. If two more files are already DNA, then the next incremental will not take B C  it will just take the D and E, that is whatever changes have been made since the last backup.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: Oh man, your presentation is not visible in between sometimes, I don't know. it's the case for me or for everyone.  >> Manidipa POD: Oh, is it for everyone? Okay.  >> 24F2008979 ARJIKYA: My name is Visible.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: It's not now.  >> Manidipa POD: oh, Okay, okay.  >> 24F2008979 ARJIKYA: I think the issue with these connection of this person, this guy  >> Manidipa POD: Now, you can maybe try to rejoin once. Okay. So incremental doesn't care whether the last backup was differential or full whatever it was, you can just take whatever files have been modified after that. Now, see after this incremental backup of D and E these two files. One more file was changed which is G. Now, after that, there is one more full backup. The next day, the full backup will roll up every change since the last full backup. Right? So you are taking a B C, D, E, F g everything.  Okay, this is a good representation of how the three types of backups work. This type of questions will come in in term, okay? So you will be given a schedule like this for a company. Now, a full backup will usually be done only once a month so you can see on Sunday, there's a full backup, right? But differential backups are done every week. You can see on The next week on Sunday, there is a differential. So every Sunday there is a differential backup and on the first Sunday of every month. There is a full backup. Okay. So now questions will be like. So if there was a crash on the 18th day of the  month, okay? That means this day, if there was a crash on the 18th day. Now the question will mention whether the crash happened before the backup of that day, was completed or after. Okay, because that will change the number of sets using to load. so let's say, for example, in this case, On 18th Wednesday. The crash occurred before the incremental backup for the day was completed. So now for a full recovery of the system, how many sets of backups do you need to reload? So, how many sets do we need? Obviously, you have to take the full backup from the first day. now, do I need to take the incremental backups from two, three, four, five, six, seven, I can just take the differential most recent differential backup. Do I need to take this eight three differential backup.  >> 24F2008789 DISHANT KHATRI: Yes.  >> Manidipa POD: Why do I need this?  >> 24F2008789 DISHANT KHATRI: and this is a differential, it will  >> Manidipa POD: But before 18th, what was the last differential backup?  >> 24F2008789 DISHANT KHATRI: 15.  >> Manidipa POD: So, differential backs, back up backs up from when from the last full backup,  >> 24F2008789 DISHANT KHATRI: Okay.  >> Manidipa POD: So, every >> 24F2008789 DISHANT KHATRI: Might.  >> Manidipa POD: changes from 1 to 14th, are rolled up into this 15th day. Differential backup. >> 24F2008789 DISHANT KHATRI: 15, Differential backup. It will take from one full backup. It will not take from it, differential.  >> Manidipa POD: No, differential backup. >> 24F2008789 DISHANT KHATRI: Okay.  >> Manidipa POD: Okay. So you can take this set from full backup. That is the first day of the month, they set from differential backup, the most recent differential and after that however, many incremental backups happened. Okay? So 16 and 17. These two incremental backups you have today. So total recovery will take four sets of backups. Now, if on the 18th day, the backup was completed. And after that, the crash occurred, then you have to count this 18th set also Okay. So, two types of questions can be there, one, where the days backup was not completed. And crash happened one where the backup was completed. And then crash happened, so that will make the sets differ by one, okay? For that day. So always take the full backup, most recent, differential backup and whatever incremental backups followed that. Alright. Is this clear for everyone?  Because this in this question comes in in terms, okay? You can check the pyqs also.  Okay, now we'll come to hot backup and cold backup. So till now, whatever strategies we have seen this incremental, differential full backup, these are  all hot backups means what that the system is not available while you are taking the backup. Now.  You can simultaneously take the backup and have your system available to the user.  Okay. Now there are some systems where high availability is a mandatory requirement. okay, so you you have hedge funds, you know, trading companies, where the you cannot afford to lose, even a few minutes to back up, right? You always need your system up and running, so they use the hot backup strategies. Okay, it refers to keeping a database. This is the actual definition keeper database up and running while the backup is performed. Concurrently  now, we will only discuss hot cold backup strategies in our syllabus hot backup is not required. So, cold backup, like a differential incremental are preferred for data backup.  Okay, so hard backup is used to wear. Usually every company will use a mix of the two, strategies, hot backup and cold backup, okay? Now, hot backup is used for important backups, which need to be done right now. so we use that for transaction log backup because this is something that needs to be immediately backed up, right? Whenever a transaction is happening simultaneously. We need to keep a log record of every action that is happening in that transaction. And we need to back it up immediately before it is lost or something, corrupts it because in case of a system failure, if you need to redo or undo, the transactions, the transaction log is our only way, okay? So transaction log backup is usually done using hot backup. Gold backup is done for the basic data backup. Okay.  Now, transaction logging is used in circumstances where possibly an inconsistent backup is taken. Like I said, so the like I said that before, and after I transaction our requirement is that the entire sum or whatever data was there, present should be the exact same. Right. so, whenever there is such an inconsistency in the database, you can you definitely know that something went wrong during the transaction. So, at that  time we go to the transaction logs, okay? And there we can restore consistency by doing a redo or undo operation. By using the logs. So, the information that is regarding the data backup versions while at recovery at a given point can be inferred from the transaction log back upset,  so when it comes to database recovery transaction logs at the first thing we  come to right and we have these recovery in detail, so we'll discuss that. Now, transaction failure can be due to two different things, one can be logical. errors, some internal logical condition that is giving some error because of, which the transaction cannot complete system. Errors can also happen. So in case of a system error, you know, your database has to terminate all active  transactions. Again, system crash can happen. So these are the different types of failures that can happen that can lead to database recovery. So system crash can happen, which is a very powerful failure. So at that time, you know, Some hardware or software failure, it causes the system to crash.  Right now, non-volatile storage content. So non-volatile storage means what Whatever is stored. In the disc. Right. Volatile storage is what which is lost after we turn off the power, so whatever is in the RAM, right. Random access memory that is volatile storage That is only available to you while you are working on a process, which is in the memory currently. but when you have non-volatile storage, whatever is stored in the disk that is usually assumed not to get corrupted because of a system crash, right? Because that is a stable storage. So disc failure is what this is. like this is a rare type of failure where your actual hard disk is feeling so in at that time the non volatile storage contents are also corrupted, right? So  whatever is part of the disc storage a disc crash will definitely, you know, destroy all of that. so disk Failures can also be recovered. Okay, we'll see how  So consider that transaction, Ti that transfers, $50 from account eight account B. Okay, this is one transaction.  now two updates, okay, so there we have to subtract 50 from A's account, add 50 to B's account. Now, the transaction requires updates to a and B to the output to the database. So, whatever changes that is a equals to a minus 50 that we wrote in the  beginning that update has to be written to the database, right? So, that happens when you actually do the commit, then it will become a permanent change. Now, a failure can occur after one of these modifications have been made. So this is what I was trying to describe with that. Example, obviously, as you pointed out this entire thing is one single transaction. I just broke it down to show you how an error can occur in this. so, let's say you took out $50 from his account, but before you even Sent it to be his account, the modifications are made, okay? Some kind of failures. Okay. Now, modifying the database without ensuring that the transaction will commit okay, that can leave the database in an inconsistent state that is before the commit operation, has been issued. You have already modified the changes in the actual database that can result in inconsistency. Because what, if further down the line, the transaction is just midway and you have already made the changes in the database, but for the down, the line there is some kind of a system crash which doesn't allow the transaction to complete so it never commits, right? So not modifying the database. Also can result in lost updates. Now, there are two different things, either you modify the database too early and then the transaction doesn't commit. So it is  inconsistent or you do not modify the database and some updates are lost just after the SO. If failure occurs, just after transaction commits, and you still haven't modified the database, by that time, then also the updates are lost.  So there are two parts to this recovery algorithm, right? First part, is that actions that are taken during the normal transaction processing to ensure that enough information exists to recover from failures  The one thing we can do is while we have while the transaction is running at that time, we take some actions to make sure that we store some information which can recover from a failure later on and the Part B of this algorithm is that you can take actions after the failure that has occurred to recover the  database. Right. Okay. Where acid properties discussed in last session.  >> 24F2008979 ARJIKYA: Yes.  >> Manidipa POD: All right. So you know that a consistent database means that it should ensure that all the acid properties are in order. Atomicity. Consistency, durability isolation. All of this. Okay? so, whenever we do recovery, we ensure that these four properties are, you know, being that stable in the database, we can say that. Yeah, this satisfied all that asset properties. Now two types three types of storage will discuss mainly two types of storage are there, okay? One is volatile storage. One is nonvolatile storage. So volatile storage, like I said, your main memory that is the RAM or cash memory, right? These two types of memories, they are volatile  storage. So they are only whatever content is present in main memory or cash memory. That only is present in that memory. Till the time, the process is running. Okay, or your System is your system has a power. You haven't shut it down, you haven't turned the power off.  Only till that time, that content will remain there once some crash happens or somehow you have done the power of that. Not data, is gone from main memory. Non-volatile storage is what like this disc. So any type of secondary memory, right?  Flash Memory Your pen. Drive is all of these things. They are what they're  non bulletin storage so they survive the system crashes. But still there are some  Points at which they may feel. Okay. Now, what is stable storage. So this is the term. We are going to use in this week a lot, stable storage. This is an imaginary form of storage, okay? So we think of it like it is some different storage that is stored somewhere else which can survive every failure. Now this storage actually doesn't exist This is a storage that we create.  By maintaining multiple copies of us of a nonvolatile media.  Okay. so, if you have some data, let's say Which is present on a volatile storage, okay? And we make multiple store copies of it. And we store it on a non volatile storage like this. So we call that a stable storage, it doesn't actually exist. It is only part of the nonvolatile media. Only the disk tape these things only but since multiple copies are there, so it is set to be indestructible in a sense that okay. If I have five copies of the same data, maybe two of the copies, get corrupted. Then also I have three more copies from which I can recover. Okay so it is in a form not destructively easily. The Stable Storage, How do we implement this? We have to maintain multiple copies of each block, right on separate discs. The copies can be at remote sites. Also, like you, you don't have to maintain the copies on your disc. Now, failure, during the data transfer will result in inconsistent copies, right? So block transfer can result in so either it can be a successful completion while you're copying the data, that is what we're saying. So let's say I have this this file and I am trying to make two copies of it, A and B. Okay. Now one thing is that it is a successful completion, right? So we have completed the copying of the data transfer the data successfully another thing is partial failure. So the destination block that is the data that I have copied somehow has gotten copied, but the information present is incorrect somehow. Okay. And a total failure means that the destination block was never updated That means the data never got copied at all. So these three types of failures  can happen now, how we can protect the storage media from failure during data transfer. So one solution is that You execute output operation as follows so assume two copies for each block. So  this A1 file. I am maintaining two copies A and B. Okay. When the first so first, what do we do? We write the  Okay, that means let's say is the first physical block. So I first do the first right on this block Once the first write operation is successful. Then we write the same information on to the second physical block.  Now, the output will be completed only after both the rights are successfully completed. Okay, so now we have two copies of the same data. This is implementation of  stable storage. So now even if one of the copies get somehow corrupted, we still have one more copy to fall back on.  Okay, so it's not a step separate storage or something. It is just the disc only. You're using to store multiple copies.  Now, how can I protect the storage media from failure during the data data transfer? Like I said, that three different types of failures can happen. So either it can be a partial failure or total failure or it was successfully  completed. So copies of a block may differ okay due to failure. So what happens if the first copy that I made this a copy has all the correct information but some of the B copy has some corrupted information. So at that point these two blocks will differ Right. So you have to first find those inconsistent blocks. If I want to recover from failure, so, I have to first, find which blocks of data are inconsistent, which are  which are some kind of corrupted data in them, So, the expensive solution will be what I have one good block. I have one  corrupted block. So I have to match Every. Line of data from the two blocks and see that, which one is different. That is going to take a long time. And it's a, it's an expensive solution, a better that You can record. The in-progress disgrace. Okay, that means while the describes are happening. You can record, you can keep a record of those on a non-volatile storage.  Okay. You can put them on volatile RAM or a special disk area that is blocked out for that. So these are these are in progress records while you are transferring the data. So, you can use this information during the recovery, once the corruption has happened, you can use this record information during recovery to find the  blocks that can be inconsistent. So, you only have to now compare. You don't have to  compare the actual data. You only compare these records  Okay. now, if either one copy of an inconsistent block, is detected, So check some is one such method that we use for a red direction. so, if any of the copy is inconsistent, you can just overwrite it by the copy That has the proper information in it. Right. And if both of the copies have no error, Okay, but they are somehow different then. Usually, by default the second block is overwritten by the first block. Okay. so, this is one part of recovery just This is recovery for physical actual disc blocks. Okay, where you are. Keeping  the copy of your data as backup? Now, physical blocks are. What see? Now we will discuss about two different types of blocks. Okay, one is your physical block, so that is the blocks  reciting on the disk, secondary memory. These are always non-volatile when you turn off your computer, whatever is stored in your drive. It is always stored there, right. In the next time, you turn it on. You can access that data. Now, one is system, buffer block.  Which is volatile system, buffer block is residing where in main memory. That is in the ram, right? So, whatever is present in main memory cache memory, these are always volatile. Now block movements between disk and main memory. So we know that whenever we are Doing some operation on our computer, right? So where does the information already decide? It is always in the disc, right? We take that information. Let's say you are watching a movie.  Okay, that you have downloaded. So is the entire movie brought at one time into the ram? It's not, right? So we bring frame by frame. Because main memory size is a lot less than your known volatile storage disk size, because RAM is very expensive, right? Specially, you know, you if you have heard about, it's Ram. So these are all very expensive memory. So we cannot have a lot of that. But we have, you can see  you have one terabyte of discs storage but ram how much real we have 4g. We have 8 GB, right?  So you take the blocks of data from the non-volatile storage that is your disk Can you bring them temporarily into the main memory just till the time that you are done with working on them? And then again you store them back into the stable storage. Right. the block movements like this from disk to main memory or from main memory, to disk. These are initiated through two operations. One is your input block. One is your output block. So whenever I write the command input B, It takes the physical block, B from the Disk. Okay, physical block means coming from the disk. We take the physical block B, and we take it to main memory, bring it to main memory. And then we perform whatever operations. We need to perform on it after the operations are done. Now, some modifications I may have performed output B is the command, which will, again transfer back the Current block which is in main memory. This block B back to the disk, okay? So it replaces the appropriate physical block there, like from where I took this block, it will take it back to that place. In the disc. Okay. So if we assume for simplicity that each data item fits in a single block in reality, it is not the case, okay? Block storage is different in reality. A file may not see block size is fixed, but a file. If I want to store it in a particular block, it might be stored half into one block, half into another block. If it is big enough to not fit in a single block. But in our  case, for the sake of this discussion, we are assuming that every day item fits perfectly inside a single block, okay?  So each transaction P, I has its private work area, right? So every for every transaction now, we are going to have a buffer Okay, where this that is. The private work area. For this transaction, whatever  modifications, it's trying to make, it will do it in that buffer. Okay. So in that buffer it will maintain what local copies of all the data items that it needs.  Okay, so now we are bringing items from the disk to the main memory. And again from main memory, we are taking local copies to these transaction  buffers. Transaction buffers are present. Well, they are part of the main memory, only whatever processing we do has to be part of the main memory, right? So main memory gives out a little bit of space or a  little bit of memory to every transaction, which is called the transaction  buffer. So, every Ty ti transaction has its private work area. So, TI is local. Copy of the data item x is denoted by x. I So, some see, this diagram will help. Okay. So in disk, I have two copies, I have two date items, A and B. Okay I issue the command input, A it will take data item A from the  This to the main memory, that is the actual buffer. Okay, now from This main memory. Some transaction. TI wants to access this. This block X.  Okay, in X we have stored a the block A that we took from disk is toward here in x, see this is the buffer block of A  When a transaction wants to work with this block, it will make, it will issue a command, okay? Called, Read X. So that will do what it will read. Whatever is present in X and make a local  copy of that and transfer it. Well to the private work area of T1. Then why this distinction is made here every thing that is happening in the main memory and that is happening in this system buffer and the private work area, private buffer of every transaction, all of this processing happens in memory and this is the part of the disc. Okay, where the actual physical blocks are stored. so, whenever a transaction is happening, the processes first, the physical block  is brought from the disc to the system buffer by the input command. Then the private buffer of the transaction that wants to work on that data.  Issues are read command on the system buffer, which creates a local copy of that data, and brings it to the private buffer of that transaction. So this x 1 is local copy? Okay. Now, let's say I finished some modifications on this. Now, I want to take this Y1. Okay. >> P Baskaran Nadar: One clar. >> Manidipa POD: Yeah.  >> P Baskaran Nadar: From the database angle, input and output is not a part of a database, right?  >> Manidipa POD: Yeah. >> P Baskaran Nadar: That's a more to do the system. Does it automatically? It is not underground. Is that so?  >> Manidipa POD: Hmm.  >> P Baskaran Nadar: Buffer.  When I, when I say, when I write when I read right? I do it in temporary  >> Manidipa POD: Hmm. >> P Baskaran Nadar: private area. When I complet  >> Manidipa POD: Yes.  >> P Baskaran Nadar: So, from the buffer, it the responsibility of writing and reading it from the disk is the operating system. I have no control on that, right?  >> Manidipa POD: No.  You are only showing the commit to mean that the transaction is ended here now.  >> P Baskaran Nadar: That's got. >> Manidipa POD: all the database are modifications will be done. It can be done before the commit or after the commit, that depends on the modification scheme. Whether it's immediate or not.  >> P Baskaran Nadar: If there is a failure. From the buffer to synchronizing to the disc.  >> Manidipa POD: Right.  >> P Baskaran Nadar: How reflect?  >> Manidipa POD: Yeah, we are going to discuss that. Okay, just let me come to the recovery part. All this will discuss  >> P Baskaran Nadar: Thank you. >> Manidipa POD: Yeah.  Okay. So first, take the physical block from disk to main memory buffer. The main memory buffer to make a copy of it. Local copy take it to the private work area  of the transaction transaction buffer. Once the once the whatever modification you want to do is completed then you again issue a command called Write, okay. You can do right of x, then it will write back this modified version of the  file back to the main memory buffer from which you can use output command. Write it back to the disc. This is the entire procedure, okay? How transactions work  So, transferring data items between system, buffer and private work area is done by two commands read x, write x read X, assign value of data item X to local variable x. I Which is I is just indicating the transaction index. Right. And write assigns the value of local variable excite back to the data. item x in your system buffer. So transactions have to perform read X before accessing a file from the system buffer and write x can be executed at any time, before the transaction commits. So before commit is issued, right? It must have written back to the system buffer. After that, you can come it at any point. After the commit is done. So if it is a immediate modification scheme, In that case, database doesn't work. Wait for a commit. Okay? It will immediately reflect the changes in the database. but in case of a deferred modification scheme, we will wait for the commit and only then we will reflect the changes.  Okay. So note that output bx need not immediately follow the right, right? So a transaction might have written back to the system buffer and it stays there. And we can just output the block to physical storage whenever we want. So that is a systems decision to make, not ours. Now, we come to log base recovery.  So a log is kept on stable storage because we know that log records are our only way to recover the transactions, okay? In case of a crash. So we want to ensure that this is a placed in such a storage, which cannot be easily destroyed. So we keep it on stable storage table. Storage means what again, we  know that multiple copies of the same data that's it. So log is nothing but a sequence of log records, which maintains information about the update or any activity, any modification that has been done on the radio is via transaction. So when a transaction TI begins, its operation it will first. So there are a series of commands or log records that have to be issued for every single  transaction. The first log record is always TI start.  Okay, so first a transaction when it begins, it will write this log record. To the log.  Log file actual now before TI executes. Okay.  Before it executes, the right X. Write x is executed when it wants to write back the modified data item to the system buffer. So at that point, one more log record has to be returned in the log file. That is ti x b1 v2. Okay. X is what? X is the file in which we are doing the modification right now. Let's say X contains the value V1 before I did the modification with the transaction. And that is the old value. And v2 is the new value that x is storing after the modifications are done. So, ti x v1 v2, This log record has to be written back to the log file before the right x command. That is before that file is send back to the system buffer from the transactions private work area. Okay.  so, when ti finishes now, when the transaction is done,  So it is at its last statement. Now, at that point, the log record ti commit is, issued.  The log file for a particular transaction has to have ti start.  And then any changes it has done has to be recorded in this format, TI xv1, V2. Where v1 is first the old value, then the new value. And then when the  transaction successfully finishes, then only the issue this ti commit low record.  so now, there are like I said there are two different modification, skins one is the immediate modification. One is the deferred modification. The immediate modification is what we are going to follow in our syllabus. But both are done in real life. Okay, immediate modification scheme allows what? so we can update, okay, it will update.  it will allow the update of an uncommitted transaction to be made to the buffer  or even to the disk, okay? So let's say some transaction is running and it has  Written back to the system buffer. Okay. From which it got the local copy So, in immediate modification scheme, you can update, whatever changes have been made. While the transaction hasn't committed yet, but you can still update those changes to the system buffer or even in the physical disk. Before the committee is issued. So you can update the log record. So Update, log record has to be written in  that case. You know, before a database item is written, you have to do the update log  record. So we assume that the log record is output directly to stable storage log records are stored in, stable storage, always The output of updated blocks. To disk storage can take plus at any time. Like I said, so we Bring the modified blocks from transaction buffer to system buffer. Now from  system buffer to disk that that output operation can happen at any point, okay? That depends on the system when advert, whatever point it sees fit, it can make that change. now, order in which blocks are output can be different from the order in which they are written. Of course, maybe I took block and block B in this order of Block B was first output. Then block yours output. This can also happen, but in immediate skin, the most important thing is that it doesn't require a commit in order to make the changes to the buffer or to the disc. So, when I make the changes to the disk, right? That's where my data base is also stored. That means that modifications without a commit are made in the actual database. also sometimes Now in different scheme, what happens here?  we perform the updates to buffer or disk only at the time of transaction, commit only after summit has been issued, then we will update whether in the system buffer or in the disk, okay? So this obviously, simplifies some of the recovery but it has an over, it has an overhead of storing the local coffee because you have to maintain that local copy until the transaction commits, right? So that storage is extra here. While in case of immediate, you can immediately ride back to the system before or even to the disk.  So we cover only immediate modification. A transaction is set to have committed when it's commit. Log record is output to stable storage. So what happens first  Transaction will work. It's way through whatever modifications it wants to make. And then at the end, the transaction when it finishes a TI commit record,  Is output to the stable storage where the log file is being stored. Right? Once that commit has been output to actual stable storage, then only we say that the transaction has successfully committed. Okay? And all previous log records must have been output already. So the log file needs to be in a  particular order, right? It should start with that. Ti start, then, whatever  modifications are done and it should end with that commit. so it cannot happen that you first output the commit back to the log file and still some of the modified log. Records are not output, so it has to be in the order. First, the start, then all the modifications in order. Then the commit Okay, rights performed by a transaction. May still be in the buffer when the transaction commits and maybe output later. So rights are one thing that we you, we allow that okay? They can still be in the buffer. Okay.  Okay. Immediately this example will make it much clear, see this is We have an example for both.  So here t0 is the transaction, and t1 is a transaction, two different transactions we have but log record. See first when the transaction starts t start, this log record is, they should find after that. This t0 transaction is  making some changes to the block A it is changing so the previous value was thousand after some modification. The new value is now 950. So this is that  format. T 1 x v1 v2. So that is written back to the log file, then t 0 b. This also some  modification happen that is also written back to log file. so at that point, what rights have been done in a This 950 value has been written. And in b, the new 2050 value has been written. See? At this point, nothing has been output yet, okay. T0 hasn't committed at this point and nothing has been output to stable storage. so after that here t 0 commits, Okay. so t 0 commits here, but, Here, BB and bc. Okay.  Now, you can see that after t, 0 commits t, 1 starts, right? And it makes some changes to see but it commits only at this point, but you can see that already the output the blocks bb and bc, Okay? These two have been output to stable storage. So bb is fine. It is it was  Changed by T0, which has already committed. So now we can safely move it to the stable storage but bc this transaction T1, which was working on this variable c, right on this file c. This one hadn't committed yet yet the modifications were already output to the stable storage. That is block containing the C file has already been output before the commit, so this is immediate modification. This output of block bc to stable storage before. Commit means, this is  immediate And ba is being output here.  Okay, after t0 is committed even bv. Okay, both of these both of these blocks means deferred,  This is deferred skin. So after the commit has occurred only, then these are output to stable storage. So we will be following immediate modification here. Yeah. >> P Baskaran Nadar: It may ask a clarification, Please go.  back. Stay on this. In this commit doesn't signify anything. >> Manidipa POD: Commit. >> P Baskaran Nadar: because once, Each right.  >> Manidipa POD: Yeah.  >> P Baskaran Nadar: Or is it a single? I mean, how, what is the purpose of a commit?  >> Manidipa POD: Commit means what when the transaction has reached its end, okay. Then we show a commitment that after this, the transaction doesn't need to run anymore. It has run all of its statements. >> P Baskaran Nadar: Right.  >> Manidipa POD: yeah, Intermediate >> P Baskaran Nadar: no, no, if there is a right. And if there is a time taking for a commit before that anyway, the disc gets updated, that's what you're saying. modification. So, commit really has. Nothing to do with the disc operation.  >> Manidipa POD: You know, in immediate modification, it has nothing to do. Yeah. >> P Baskaran Nadar: So it only signifies the end of transaction. Thank you.  >> Manidipa POD: In deferred scheme, commit is important because before that, nothing can be output to stable storage.  Right. >> P Baskaran Nadar: but he in this course, follow immediate Modific so,  >> SANDEEPKUMAR SUDHAKAR SURKUTE: ma'am, if it is immediate, then why A and B waited until T1 committed or let's  >> Manidipa POD: n, a and b are >> SANDEEPKUMAR SUDHAKAR SURKUTE: say, till that's  >> Manidipa POD: Okay. P1.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: Where is that specified?  >> Manidipa POD: Say it is written b c output before t1 commits. So that signifies immediate So it is not waiting for the commit Right. It is already output. The IT has already output the file onto the disk.  >> P Baskaran Nadar: Is it a chance that we make or is it?  common, why bc is Why C is? >> SANDEEPKUMAR SUDHAKAR SURKUTE: No. no. Where did we decide that sees has to be immediate transfer and a and b, how to be a deferred?  >> Manidipa POD: well, you didn't >> SANDEEPKUMAR SUDHAKAR SURKUTE: Or we are assuming.  >> Manidipa POD: decide this, okay? This is just an example of immediate and effort modification how it works.  Okay, so >> SANDEEPKUMAR SUDHAKAR SURKUTE: Oh, okay.  >> Manidipa POD: If you follow immediate, then you can do this type of thing. You can output the  >> P Baskaran Nadar: Okay, are we expect?  >> Manidipa POD: disk block before the committee is issued, No, no, no.  >> P Baskaran Nadar: okay, this is more for  >> Manidipa POD: This is just theory. Okay? This is just to understand how recovery works. Yeah. >> P Baskaran Nadar: Just how the real life situation is going to be complic. That's okay, but the question. >> SANDEEPKUMAR SUDHAKAR SURKUTE: but,  >> Manidipa POD: No, no free questions from recovery are going to be. I will discuss that also at the end, so that is more. >> P Baskaran Nadar: I know.  >> Manidipa POD: based on transactions, okay? That whether a transaction committed before a system failure or not, if it didn't commit, then how can we recover it? That type of thing. The questions won't come from this. >> P Baskaran Nadar: What?  >> Manidipa POD: recover, this deferred on immediate modification scheme.  >> P Baskaran Nadar: Yeah, because these are all very involved topics which I wanted to know.  >> Manidipa POD: Yeah, these are much more in-depth. Okay. And that is.  >> P Baskaran Nadar: Hey, you. just another understanding is all right but then if the questions are going to  >> Manidipa POD: No, no.  >> P Baskaran Nadar: be probably checking whether you know, whether you to the level, of committing writing this  >> Manidipa POD: You can take out the Pycus also from this part of the from week 11, whatever we learned, actually, a lot of this stuff that we are learning has a lot more  >> P Baskaran Nadar: I,  >> Manidipa POD: deeper scope, okay. So on this, you can do a lot.  >> P Baskaran Nadar: I know, I know that. That's okay, I'm Michael. I'm and I just mounted a clarification because I wanted to be clear, whether we need to  >> Manidipa POD: No, no question will come from this part that much. I can tell you. Okay. What >> P Baskaran Nadar: but,  >> Manidipa POD: type of question can come, is that you may be given a log file. Okay, so log  >> P Baskaran Nadar: Yeah.  >> Manidipa POD: file is given to you there, you know that, okay? Two three transactions,  >> P Baskaran Nadar: Yeah, if you walk us through on that, that will be more relevant or more.  >> Manidipa POD: Now, I will take questions also but I have to first go through the theory. Okay.  >> P Baskaran Nadar: Good.  >> Manidipa POD: Alright, so now see why we are focusing on these things that how a log record.  Looks like so that is because we will have some questions on them. Now, undo of a log record. Now, two different things will learn. One is redo operation. One is under operation. Okay, so when we do an undo, Just by the name of it, you can understand that we are undoing, whatever we did  That means if I change the value of x from V1 to V2, undo operation will change it back to the old value, which is V1. okay, and redo operation means what It will write back the new value, v2 to x. So, a redo can only be done usually after you do an undo.  Right. So first you take maybe some type of error occurred and your current modifications are lost okay, what you still have the log records. So from the  log records, you can first undo the transaction. Take it back to its last table state. Take the data was back to the last consistent state. So that is, let's say V1 when the value of x was v 1. So you first undo and make sure that the value of x is currently v 1. And now you want to redo. That means you have what you want to have the same effect as the transaction did. When everything was running smoothly before the crash. So now you have the log records from after also so you can redo the entire transaction and again issue  the new value v2 to x. Okay. Now, undo operation of a transaction ti. So there are special log records for these also Okay, undo, and redo operation. So, under operation of a transaction, TI restores, the value of all data items that were updated by DY, To their old values. So if update was done from value v1 to value v to undo will take it back to the Value V1, old value.  So it is going backwards from the log record of TI, right? So if it committed, Right then.  Then the changes can be affected. So, in that case, we will go to the log records and read from the last log record and go backwards and undo every operation that has been made. Okay? Until we get back that value V1. Now each time a data item is restored to its old value v. A special log record has to be issued which is  called redo only Okay, this this log record is known as redo. Only it is written in this format. Ti comma, X comma V,  okay, so if old Rick, if old value is v and we are doing this for the data item x, which stored this old value. And which was modified by transaction TI.  Then, the log record will be ti comma, x comma V. Once you do that undo, okay? once the restoration is completed, then only this log record will be written out to the log file.  now when undo of a transaction is complete, then you issue one more log record which is ti about. Okay, This means that when you see this ti about in a log record, you know that the undo is completed successfully, okay? This is under operation. Now if I want to do a redo operation, it will set the value of all data items updated by TI to the new values. So it will go forward. So it is just opposite of each other and domains you go backward in the log file.  And redo means you come forward, right? So redo will set all the new values back whatever modifications ti originally performed. So, going forward from the first log record of Ti, that means it will start from  t. I start that log record and then go sequentially until all the modifications are performed. So in this case, in case of redo, no extra log  Records are printed out to that log file. Okay, only in case of undo,  Now, something called compensation log records. This also will know. So ti let's say it is a transaction that needs to be rolled back. That means we need to Roll back. These B1. >> SANDEEPKUMAR SUDHAKAR SURKUTE: So remember what was the V in? The what was the V in the redo red?  >> Manidipa POD: V1. Okay. The old value. so, >> SANDEEPKUMAR SUDHAKAR SURKUTE: Okay.  >> Manidipa POD: In this one. See. So roll back mean.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: So, for to, with redo command, how will it go to V2? >> Manidipa POD: Redo command does what?  >> SANDEEPKUMAR SUDHAKAR SURKUTE: because,  >> Manidipa POD: it will. It will roll forward, right? We still have the log records, if the transaction happened. No. >> SANDEEPKUMAR SUDHAKAR SURKUTE: But now we are lost. We have lost the V2 value. No.  >> Manidipa POD: You haven't lost.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: because we have stored already redone redo, only log, >> Manidipa POD: No, no. See  How it works is. Your previous log. Records are all fine. They're all present in the log file, okay? However, the transaction worked every log record for every read and write operation is stored on that log file. After that. If you do the undo, it will write back some special log records like this. But doing redo is not a problem Redo means what you just have to start at the TI start command. After that the read write operation log records are all present in your log file so you can just follow them sequentially. Until you find the commit. Okay. So, in case of redo, we just redo whatever the transaction did in that same, sequence. But in that case, no extra log records are written back to the log. That's all  >> P Baskaran Nadar: I click on. just, >> SANDEEPKUMAR SUDHAKAR SURKUTE: So, so ti.  xv kind of tells us that. Now start ta with x being taking the value v which is the old value. so and go forward, that's what redo only, this log will suggest us  >> Manidipa POD: Redo is possible when we have done undo, right?  So, redo only means that this X has been restored back to its old value. That means undo has been  started and no operation has been started and X has been restored back. And when I issue, when I seen a log record, the TI award is a log record, that is present. That means that a complete successful undo has been done. Of a transaction.  Okay, after that, if I want to do redo, all I have to do is just go this ti transaction. If I want to do a redo, just go to the T. I start command, it will be somewhere in the log.  So just go to the TI start and then start issuing the record simultaneous. I mean sequentially as they are stored in that order, then you will eventually come to the place where you can issue v2, the new value.  Right to X. But in this case, in case of redo, you don't need to output any new log records like this TI about or something, you don't need that. In case of  redo,  >> P Baskaran Nadar: Just a minute during the undo.  >> Manidipa POD: Hmm. >> P Baskaran Nadar: We are rewarding.  >> Manidipa POD: Right.  >> P Baskaran Nadar: Now, why are we writing it as a redo in the lock? Of.  >> Manidipa POD: It is just a name for it. Okay, redo only we call.  >> P Baskaran Nadar: It's not this redo is not what we are going to.  >> Manidipa POD: No, no. This has nothing to do with the actual redo, okay. It is just the name for this command.  >> P Baskaran Nadar: Confusing. >> Manidipa POD: It's a bit confusing. Yeah.  >> P Baskaran Nadar: So much is there. So and this  >> Manidipa POD: That's why I see all of this information that I'm telling you, right? You don't have to remember all these log records or anything, because questions won't come  from here, >> P Baskaran Nadar: Conf.  >> Manidipa POD: Of course.  >> P Baskaran Nadar: So that's why that's okay. Since you mentioned, this video is just for the naamka sake. It doesn't matter.  >> Manidipa POD: Yeah, it's just for a name, it has nothing. >> P Baskaran Nadar: Just with that. Thank you.  >> Manidipa POD: Okay, so in case of undo, we have to do two extra log records that have to be output to the log file. One, is this redo only log record? One is the about log record. So, if I find these two, then I can say that successfully under was completed. Then I can start my redo operation which will start at t. I start. Okay, so you have to go forward from the first floor record of Ti ti, first love record will be this. Only t, I start where the transaction started and then you go for further whatever issue if this transaction had you just do that again, right? You're just retracing the steps of that transaction. Now, this one see. A transaction TI, if it has to be rolled back, rolled back means we have to scan the log backwards. Now, okay, from the end, Whenever we say that we need to roll back, a transaction means we have two retrace, the steps of the transaction backwards in the log. And for each log record, ti, that we find of the form. So this is now showing you okay, how the undo procedure actually works? so first What do we do? We scan from the end and every time we find this type of a record, this record means what that TI transaction changed the value of data item x, i from V1 to V2, So, I need to undo this operation, right? Undo will be done by issuing the old value v1 back to x. so I we have to write another log record for this, which is Ti x. Okay, it is similar to this one. T. I x V this only it is just showing how this is written how this procedure works. So we first find such a log record, where a modification was made to a  variable change from an old value to a new value. And then we perform the undo by writing back. This value old value v1 back to x and at that point we show this redo only log record which is also known as compensation log record. CLR okay.  Now, once the transaction once we hit the TI start, okay? We are rolling backwards, right? In the log file. We are going from end to beginning, so we are going upwards in the log file. So at some point, we are going to hit this t. I start that is where this transaction started once, we reach that command that log record. Then we know that, okay, this is where the transaction started. That means I have rolled back all the way to the start of the transaction, so I can stop now. so you can stop the scan there and then you can issue ti about. Okay. This is the under procedure Is this clear to everyone? Should I explain this again? Okay, then not explain.  The just very simple, okay? Your log file has all the information. If you want to redo start at the end of the log file, go upwards backwards. Just roll backwards every time you see and write that has been performed where x is was changed from V1 to v2. You change back x is value back to the old value. That is V1 and you write that compensation log record or redo only record to your log 5  Once you are scanning backwards backwards and you hit this ti start, this log record, you have reached here, that means no more changes have to be undone, you have, and then all the changes that that transaction had did. So now you can successfully issue the TI about, which will signify that undo operation was successfully completed. Okay. Now while recovering after failure so transaction. Ti needs to be undone when if the log record contains the TI start, that means the transaction actually started. Okay. But does not contain either the record PI commit or about. So, how do we know that we need to undo some transaction when we check the log file? And we see that some transaction had started, but before it could come it Okay, some kind of system crash occurred. So it couldn't commit. That means  commit is not there, but start is there. That means here, we can issue an undo Another thing is what that if commit is not there, we also check whether a ti about, is there, okay.  Which means that it has been undone already. The under operation has been performed already. So if that is also not there. If both of these are not there, but t I start is there, then you do the undo operation. Okay, and when do we do a redo operation? When the trans when the log records contain TI start, that means the  transaction had started. And it contains ti commit or about that means either the transaction committed. Or an undo. Operation was performed on it. That's why TI about its present. That's why I said that either. If a transaction has been undone then only it will be redone or if the transaction had committed already. okay, if I already come, if it had already committed and I want to just redo In that case, t, I start and ti commit will both be present.  Okay? Or the second case is that it started and it didn't finish. So we didn't undo operation. So now a TI about record is present In that case, we can also issue. >> P Baskaran Nadar: If it was aborted. What is the person? Redoing it.  >> Manidipa POD: So if it was awarded means or TI about is it should win when we have  successfully completed undo.  >> P Baskaran Nadar: No. This is doing the recovery, right?  >> Manidipa POD: Yeah.  >> P Baskaran Nadar: So, the about could have been even intentional.  >> Manidipa POD: No. Yeah. What is the command, which is it should win? It is given here that you only show that when you scan the entire file and you reach ti start and you  successfully show that undo has been completed Yeah. >> P Baskaran Nadar: I do love finds this isn't the compensation law, okay? About Po. is appearing in, which means there was another atom we earlier  >> Manidipa POD: Yeah, that means you had done and undo operation earlier. That's why about is there in the log file? Okay, so if what is there, then you can do a redo or if commit is that they not. So you can do what you do, okay? But if you want to do an undo, it should  not contain even commit. Or about that means this did not finish executing and undo wasn't done previously, then you wish you an undo command, okay? It may seem strange, to do redo transaction if the record TI about is in the log. Okay? So that's just your question yti about is in the log. So if you want to see how this works, you have to note that if TI about is in the log, Then so are the Redo only records written by the undo operation. Right, that means the CLI records. Are there.  Still, a record means read only records are this Ti XV? V1. You can say if you want to signify this as the old value. So if a, what is there, that means, definitely this redo only records are also there, right? That were created by the undo operation. So end result will be what to undo ti is  modifications. In this case, So that is our goal. We undo the modifications first, whatever t I did. Then we do the redo.  Okay. so, redo the readers, everything, the original actions including the steps that are restored. That have restored, the old value that is known as repeating history. So this is a bit confusing to understand. I'll try to make it simpler. See,  Let's say and let's say this T. I transaction has issued a lot of log records. Okay, it started here. Then it did some redirect operations here and then we can find when we are  looking through this, we can find that. There is a TI award here. So, ti about from this, I can understand that an undo operation had been done on  this. Right. And then if an undo operation has been done, that means that there are  definitely CLR records That are returned. because every time in an undo, when we change our value back to its old value,  when you change your data item back to its old value, we always write back CLR records for it, so that the transaction will also contain records like this. Ti x v1. Right? If it was working on some other data item DIY, Let's call it V3 sum value. Some old value. okay, these records will also be present if about it's there because of what means successful undo. So after this, after finding this, when you want to do the redo, so redo will start from here T. I start. And it will do all the changes. All the original actions that the TI transaction did including these, Okay. The redo will do everything that is present.  So these this is called repeating history because some of the steps, okay? That  restore the old value. Those are again performed. So that is a redundancy here, okay.  That means whatever was done in undo. So redo doesn't redo will only stop when when it reaches the end of the log records, So that will also contain this CL or log record. So in that case, what happens that redo readers all the original actions, including the steps that restored, the old value, So, the CLR records are also executed. That is repeating history but despite is like, you don't have to understand it in great detail. Just the important thing to understand this when an undo happens, we roll back to the start of the transaction and undo all of the changes that were made and get all the data items back to the original value before the transaction happened. And in redo, we just do the opposite of it. We start at the start log record and we come sequentially down till the log records. End for that transaction. We and we again to the same actions that that that TI transaction had done.  Now, see this this type of, this is a good question. Where this type of question can come  So here you have a log record. That is recorded at three different instances of time.  You don't think, okay, I can see this.  Let's keep it for now. So t0 started. Okay, This is the first instance. A so t  0 started, then t 0 changed value of a, from thousand to 950 t 0, change value of B from 2000 to 2050. Okay? This is instance, a, This is the same log record at three different instances of time. Now, at instance b, we can see after this, t 0 committed.  Then another transaction t1 started and it changed value of data, items C from 700 to 600. Right.  now again, in instance, c, we can see that after, this t1 started change value of C then t1 also committed in this instance, So, there are three instances of the same log.  Okay, now some things that you need to understand here. So recovery actions in each of these cases, above how it will work at any of this instances if you had to recover, then how it will work. So in instance, A if we want to undo, why we will undo because we found that t 0 record but there is no commit or about that. We can found that we can find in the log, right? That means we have to issue an undo.  The undoor of t 0 will do what go from last to first like this. Roll back to the beginning.  So on the way, whatever changes you see like, log records like this T 0, B 2000.  2050 have to undo these and restore back t 0 B, this b data item to its original value. That means 2,000  so now, you tell me if I do an undo and B is restored to 2000 and A is restored to 1000.  Then these CLR records will be written, right?  T, 0, b, two thousand. This record will be written. Once it is restored back and t 0. A 1000, this record will also be written. These are redo only or CLR records.  This will be written back to the log. and after that, once we reach the start, we know that all the under operations are done. So we can successfully you should t 0 about so that will be part of the log. This is the >> P Baskaran Nadar: Up DJ. Go back. Delay encountered. A t, zero start, or should  >> Manidipa POD: Yes, tell your encounter, t0 start where the transaction started.  >> P Baskaran Nadar: A.  >> Manidipa POD: Okay. So at that point, you can say that everything has been undone  successfully. >> P Baskaran Nadar: Then I can. >> Manidipa POD: Then you can issue about. >> P Baskaran Nadar: Okay.  About now in the second stage, middle, whatever you give.  >> Manidipa POD: Hmm. >> P Baskaran Nadar: T zer.  >> Manidipa POD: t0 has been on this one instance, B, you're saying  >> P Baskaran Nadar: Middle.  >> Manidipa POD: Yeah, this one right? >> P Baskaran Nadar: Yeah.  >> Manidipa POD: So here, see how we are doing? The recovery here, t0 has been committed, right? If we saw the log record as at this instant. Okay at this. Instant. If I saw the log record and I wanted to do, Some redo or undoor operation based on what is present in the log record. So at this point I can see T0 start and commit are both present.  >> P Baskaran Nadar: Oh, correct.  >> Manidipa POD: that means I do not need to do an undo operation undo is done when commit or  about or not there.  >> P Baskaran Nadar: My scanning back. Will stop at T1 start.  >> Manidipa POD: But you want to do a redo of t 0, right? >> P Baskaran Nadar: No, no.  Assuming in this option B, that you have chosen.  >> Manidipa POD: Hmm.  >> P Baskaran Nadar: if it was a crash after the T1c 700 modified to 600, At that stage, I am restoring it back.  >> Manidipa POD: Yeah, you are distorting it back. Now while this recovery you have to do two different operations. One thing is, since you know that t 0 committed, that means there is no need to undo but T1 didn't commit. So there I have to do an undo. Okay. >> P Baskaran Nadar: Correct. That's  not. Now that's why I'm asking. If I were going to undo the T zero should I stop with the T 0 or maybe something else was before how long I go up.  >> Manidipa POD: no, once you are, once you're undoing a particular transaction, if you find it start record, you stop there.  Okay, we are not undoing multiple transaction at the same time, just one at a  >> P Baskaran Nadar: Okay.  >> Manidipa POD: time. So if you're undoing T so you as soon as you find T1, start you can stop scanning backward. >> P Baskaran Nadar: Happy one. >> Manidipa POD: Yes, of T1.  Here then. >> P Baskaran Nadar: For t1 and if there is t 0 then I got to go further up. So all the transaction start till the start.  >> Manidipa POD: Yeah, but in that case if you had to do it for t 0 as well. Okay, if this commit was not there, tease your comment was not there then first you are undoing. What P1.  >> P Baskaran Nadar: That is okay. That is a really that  >> Manidipa POD: Okay, then you write this T1 about.  >> P Baskaran Nadar: Going for each transaction till the beginning. That is what you  >> Manidipa POD: Yeah, exactly. >> P Baskaran Nadar: if there were I mean for a hypothetical case, if t 0 commits, there were two commits. Two transactions, where they often, then T1 was there. Then I  >> Manidipa POD: Hmm.  >> P Baskaran Nadar: The one.  >> Manidipa POD: you don't need to go into the committed transactions. You start with the ones that are not committed, because Undo is the more important operation here.  First you do the undo. Okay, see in instance b what happens? T 0 is committed, so no undo required, t1 is not committed. That means undo required. So you have to do two things, you have to do the undo for t1, and you have to do the redo for t 0.  >> P Baskaran Nadar: That's okay.  >> Manidipa POD: Why we do this redo is because Some corruption might have happened. Okay? Due to this system crash. So to make sure that the database is still consistent. We will again. Retrace the steps of the transaction by >> P Baskaran Nadar: Okay.  >> Manidipa POD: Okay. >> P Baskaran Nadar: Thank you. Thank you.  >> Manidipa POD: So, if I do redo of t 0, right?  Then redo doesn't ride back. Any extra log records and unlike undo. So nothing else will be written back to the log but since I'm doing undo of T1, so two more records will be written back to the log. One is for undoing this right?  operation. So C will be restored back into its old value. That is 700 so a CLR  dog record like this will be output t 1 C 700 and then we reach t1 start that means undo is successfully completed so we should be one award. Okay.  Now at instant c both are committed t 0 and t 1. That means no undo is required. Only redo we will do. Okay. So, if I don't want to do only redo that means I just start from the start of both of these.  >> P Baskaran Nadar: What?  >> Manidipa POD: And I can just retrace the steps. Okay. So A and B.  >> P Baskaran Nadar: Would we are supposed to do first and do and then redo, right?  >> Manidipa POD: Yeah, in in case a transaction needs an undo in that case if commit is already there, then there is no need for undo.  >> P Baskaran Nadar: then why we are going to do redo,  >> Manidipa POD: Yeah, then only you do the redo to make sure that if there were some  inconsistency due to the crash that happened after the commit, So we it is a procedure to still do a redo operation. If there is a crash,  >> P Baskaran Nadar: But in the earlier slide, we said that. Yeah, first we do on  >> Manidipa POD: Yeah. See undo is done first in case the transaction hasn't committed.  >> P Baskaran Nadar: that's okay, so big  >> Manidipa POD: In, in that case, you do the undo first, then you follow it with a redo. >> P Baskaran Nadar: So as a procedure for the section C that your children, we go to the T zero stock, undo all. And then because it has been committed transactions, the redoing it, so there it is.  >> Manidipa POD: We redo all the yes. All of this will redo for both. >> P Baskaran Nadar: So, we So it is a two phase operation first is undo and then redo wherever it is completed transaction.  >> Manidipa POD: Oh, see, I think it is getting a little confusing. Let me again say this. Okay, in, let's take instance B, fine. In instance, B. >> P Baskaran Nadar: Yeah. See ah,  >> Manidipa POD: E 1. We can find the start record but no comment record. That means we know we have to do undo. Okay, so for T1, we do an undo operation. Okay.  Now, what P0? I can find both records. So in that case I will do just a redo.  Okay, I'll trace it back to the start and I'll do the redo only. No one do. so these three instances have three different meanings first, instance means that only t zero started. And it did not commit. That's it. That means I need to do an undo for t 0. Then second instance is that T0 started committed then P1 started but that did not commit before the crash. So in that case, what do you need to do? You need to undo t one and redo t0. Okay, so transactions. This is a This is the rule. This is actually what I was going to discuss in the numericals. So as a rule >> P Baskaran Nadar: The number. Ed. Yeah.  >> Manidipa POD: when the crash happens, okay? When the crash happens transactions,  >> P Baskaran Nadar: ah,  >> Manidipa POD: that are still running, at the time of crash, that means that have not committed yet. Those transactions have to be  mandatory undone. Undo is mandatory for them transactions that had committed before the crash. Okay? Now, there is something called a say, Okay, that I had to discuss after this. Then I thought I'll explain it but let's think of it like, it's a checkpoint. Okay. So some checkpoint before the crash occurred now if some transaction committed after the checkpoint, but before the  crash occurred so it has committed for those transactions. We do and only a redo operation. No undo. now, if there is some transaction that committed even before the checkpoint, For those transactions, nothing is done. They are just ignored. Okay.  in case of a transaction which did not commit before crash,  Okay.  You have to do the undo first and then you can do a redo. You can't directly do a radio. Is it clear?  >> P Baskaran Nadar: Incomplete transactions. We have to read  >> Manidipa POD: We have to undo.  >> P Baskaran Nadar: Undo. No redo. Right?  >> Manidipa POD: The incomplete transactions. First you have to undo, then you can read You can retrace the steps. Okay, but first undo needs to be done.  Okay. >> P Baskaran Nadar: and for,  >> Manidipa POD: Only do.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: so in complete means we are saying before comm  >> Manidipa POD: Okay. Correct. In complete means crash before commit so you do undo operation complete transaction means it has Committed before the crash. So for that, you do a redo. Now, we come to the Concept of checkpoints.  >> P Baskaran Nadar: I think you can walk through with some actual numbers and show us.  >> Manidipa POD: Yeah, I have all that, but before I discuss checkpoint, I cannot show you that, okay. It will not make sense. So let's first do the checkpoint thing, then I'll  show you how we do and works.  >> P Baskaran Nadar: Okay.  >> Manidipa POD: So what is checkpoint? It is just a recover, it is just a part of the recovery procedure, okay? So just like see. In our computers. Also, we do a regular check, right? Maybe some antivirus or something. You have regular check of your system done, whether it is running smoothly or not, right? Maybe once a month one, six months. So these are what these are checkpoints at which you are checking that whether everything is running smoothly or not. Similar thing is done in the recovery procedure as well, okay? So redoing and undoing all transactions that are recorded in the log can be very slow, so if we want to redo and do every transaction, that will be a very big process. so what we do is we have some checkpoints to make sure which transaction need to be mandatory undo and which need to just redo and which don't need anything redo or undo. Ok. So we classify them as such we don't do and for every transaction so,  >> P Baskaran Nadar: Okay, I got it this. is something like a certified as of now everything is. All right. You don't have to go back to check.  >> Manidipa POD: Correct. Right. That's why we have multiple checkpoints, okay? Yeah. Yeah. >> P Baskaran Nadar: Certified, audited statement.  >> Manidipa POD: They're also known as safe points. Okay? In some questions, we'll find it. I'll discuss. So redo undo, All of all transactions is not possible, very slow, so  processing, the entire log is time consuming, if the system has run for a long time, that means if the system is running, you have no checkpoints in between. So only when a crash happens, then only you check to see what went wrong. So at that time millions of transactions might have happened. So if you have to retrace back all of them, it's a very long procedure. So we might do some unnecessary redo transactions that that do not need a redo.  Okay. That have already output that updates to the database. So that's what I was saying that if some transaction has committed before even the checkpoint. That means they don't need any redo operation as well because those changes are written back to the physical storage to the database. Those are already permanent changes, they are not affected. Okay.  so to streamline this recovery procedure, we periodically perform something called checkpointing. So what happens all updates are stopped while we do a checkpoint. Everything is stopped the output. If all the log records that are currently in memory, Onto the physical storage or stable storage, we output all modified buffer  blocks to the disk, you know, that some blocks from transactions can stay in the  system buffer until the system sees, it fit to output it to the disk so all such buffer blocks are output to the disc. We write a log record called  checkpoint L on two stable storage, where L is a list of all transactions active at the time of that checkpoint. okay, so when a checkpoint happens,  Everything is halted.  Okay, no, updates are done. Every log record is output to the civil storage. Every buffer block is output to the disk only then we issue something called checkpoint l where L is a list of every transaction that was active during that time. This is checkpointing multiple subject, points are done, right? So that we don't have the log records as one whole log record since the beginning you started using your system. So there are multiple checkpoints  So, during recovery, what we do, we consider only the most recent transaction. that started before the checkpoint, okay? Or in a better way you can think of it. Like we check from the most recent checkpoint. Now, checkpoint, that was last performed. Okay, and we scan backwards from there.  So we scan backward, from the end of log to find the recent checkpoint L. Okay. So once a crash happened, you go to your log record. You scan backwards until you find this checkpoint L command for the last checkpoint that was done. now, only the transactions that are in L L is what list of transactions that were active during this checkpoint? Or that started after the checkpoint.  We are going to check only these others can be ignored.  Now transactions, that committed or aborted before the checkpoint?  >> SANDEEPKUMAR SUDHAKAR SURKUTE: Others could be and  Hello, I'm Aud.  >> Manidipa POD: Yeah, yeah. One >> SANDEEPKUMAR SUDHAKAR SURKUTE: yeah, I'm saying then if we are going to consider only the L L list, Then, but we are. >> Manidipa POD: Hmm.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: writing all the log records also to the disk before we start this checkpoint. So, those Will be just stored. We will not actually use those log records. like,  >> Manidipa POD: They are stored for now. They will be used when we need to do an underwear redo. Okay. >> SANDEEPKUMAR SUDHAKAR SURKUTE: No.  no man. Let's say we're doing this checkpoint l, okay? At this point, only the current active transactions are being stored in the L list capital L, okay?  >> Manidipa POD: Yeah.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: ah, but when we were doing this, you this para a, it says all log records currently deciding in memory are also written to the stable storage. >> Manidipa POD: Right. Yeah.  Yes. >> SANDEEPKUMAR SUDHAKAR SURKUTE: so,  So all these blog, recordings storage may not be necessary.  That will.  >> Manidipa POD: This. Wait a second. Your voice is breaking up. Can you repeat it again? The last part.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: oh,  >> Manidipa POD: Yeah.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: Audible Map. What's the?  >> Manidipa POD: Yeah, now it's okay.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: point of para? A basically, Ahmed para, what's the point of parai? If we are going to come back to only the checkpoint? That's my question in short.  >> Manidipa POD: So, let's see. We are, we are doing what output all log records. Currently  deciding in main memory on to stable storage right before the checkpoint. While the checkpoint is done doing it's job. So  >> SANDEEPKUMAR SUDHAKAR SURKUTE: Yes, ma'am.  >> Manidipa POD: these are the log records of the currently active transactions, right? So, these are what.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: Med currently active current. Ly happened around in Parisi.  >> Manidipa POD: No, no log records. Okay?  >> SANDEEPKUMAR SUDHAKAR SURKUTE: Okay.  >> Manidipa POD: Log records of a speracy is saying what checkpoint L is. L is a list of all transactions that are active at the time of checkpoint. Now better a saying output or log records, currently deciding in main memory. So what are the log records currently deciding in main memory, the log records of these transactions only that are part of L.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: Now, they could be.  >> Manidipa POD: Active transactions, only.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: Like we are.  >> Manidipa POD: Find some previous ones, okay?  >> SANDEEPKUMAR SUDHAKAR SURKUTE: How because from half an hour system is on.  >> Manidipa POD: but what did I what did I >> SANDEEPKUMAR SUDHAKAR SURKUTE: The records are.  >> Manidipa POD: say that? No listen. What did I say that? We are following immediate run, immediate modification, right? So, whatever changes are being made are immediately being made. To the physical storage itself. So, log records are also immediately.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: oh,  >> Manidipa POD: sent to the physical storage so these log records which are currently deciding are the log records of the currently active transactions. Okay, so  >> SANDEEPKUMAR SUDHAKAR SURKUTE: you say, residing in memory, here you  >> Manidipa POD: Yeah, definitely see in main memory. Anyways, we are only having those. I mean it is mostly the case that we are only having those law records which are currently active transactions. It's main memory, doesn't have that much space to allocate  even log records which are done which transactions are completed, right? So we usually output them back to the stable storage as soon as possible. so current ones are just the log records of currently active transactions, so those will be output to stable storage during checkpoint whatever log records are present, okay? And then the checkpoint itself, the checkpoint L will be a log record, which is output.  Yeah, are you asking something? You think your voice is breaking up again? Should I continue?  >> P Baskaran Nadar: At work.  >> Manidipa POD: Okay.  So we scan backwards from the end of during recovery. What we do is we need to check What is the most recent checkpoint? Okay, so we scan from the end of the law record and until we find this checkpoint l this log record. so only transactions that are in L that is the transactions that were active  during the checkpoint or that started after the checkpoint. Okay. There will be some transactions which started after the checkpointing was done.  Only this set of transactions, they either need to be redone or undone. Other Transactions. I am not worried about. Okay, so transactions that committed or aborted before the checkpoint already, have all that updates output to stable storage because we are using what immediate modification. so already everything is updated to stable storage so you can ignore those now this is the type of sum that will get in in term  Okay. A diagram like this will be given to you. Now, PC is the checkpoint, TF is the System failure point. Okay. So we will ask you in the options, it will be given choose the correct options. So, in some option it will be written that T4 needs to be undone, is this correct? Yes, because you can see T4 started here but it did not end. It was still running. Well, the system crashed, that means this has to be undone. For T3. What will you do? See it is. It started after the checkpoint but it committed before the system failure. That means what? The transaction committed. Okay, but Some of its updates might not have been gone to stable storage yet. Okay. That modification might not have happened till now that's why we do just a redo on these just to make sure that yeah, everything is output back to stable  storage. For T2. What do you do? It is a transaction that started before the checkpoint  and it was running. After the checkpoint but it committed before failure happened. So for these transactions, also, you do just a redo And for transactions, like T1, which started and committed before the last checkpoint. These you can ignore So redo for those which either were active during the checkpoint or after the  checkpoint, but committed, before failure for them. Only redo and undo for those which started after the checkpoint but were running during the time of failure for them, you have to do undo first. Okay, so any transactions that committed before last checkpoint should be ignored like T1. Any transaction that committed since the last checkpoint need to be redone. That means these T2 and T3 committed since the last checkpoint. But before failure, so only redo for these Because you can't do an undo right for T2 and T3. The log records will contain a COMMIT operation  >> P Baskaran Nadar: Okay. Just just for clarity. System failed at TF.  >> Manidipa POD: Hmm.  >> P Baskaran Nadar: After.  What would be the state at that time? Yeah.  >> Manidipa POD: so, at that time, all the transactions,  were active, that were active during the failure. You first have to do the redo undo, then only >> P Baskaran Nadar: No.  Correct. After say after say few minutes and then we got into the store. there are operational, state will be  Assumed that T1 has been corrected. T2 has been corrected? T3 is corrected T4. That is.  >> Manidipa POD: P1 is ignored, only T1. Nothing is done T2 and T3.  >> P Baskaran Nadar: That is okay. They all redone in the restoration process.  >> Manidipa POD: Yeah, exactly. In rec.  >> P Baskaran Nadar: I'm asking you stayed when the system starts.  >> Manidipa POD: So at that point T2 T3 are completely restored. Okay? Yes. >> P Baskaran Nadar: everybody is completed right before we re because it has been undone. But >> Manidipa POD: Yeah, for T4, if you want to, again, do this transaction. Then you have to do a redo after the undo.  >> P Baskaran Nadar: Yeah, that that is by the application side. I mean,  >> Manidipa POD: Correct.  >> P Baskaran Nadar: Okay, thank you.  >> Manidipa POD: Okay, after that, you can again start your normal transition.  >> P Baskaran Nadar: we know the operation was aborted in between because of the system failure, I may have to initiate the whole thing again from the system level.  >> Manidipa POD: Right? Because you will have that about command, right?  >> P Baskaran Nadar: It will.  >> Manidipa POD: Written back to log.  >> P Baskaran Nadar: Okay.  >> Manidipa POD: so, any transaction that was running during the time of failure, needs to be undone and then restarted. Okay. So P4 will be undone in this four. So this is that, I have question that will come. Okay, we'll give you a diagram. Like this three. Four options will be given some of those will be true. Some will be false, you have to just identify. So a false statement will be like this, that T2 has to be undone, that will be  false because it committed, right?  >> P Baskaran Nadar: Is that a possibility of giving a log with the numbers and  >> Manidipa POD: yeah, yeah, I'll show you that example also Here. So from here, only this two types of questions. Come now, let me take and obviously the back of one. Just give me a second. I'll take a few IQ.  Okay, so this is all the theory that you need to learn for week, 11 apart from RAID architecture. So red architecture will be done in next class because there is only you have to memorize things from there, okay? If you want, I can give you the PDF from last term but I marked. What is important that you have to  memorize? >> P Baskaran Nadar: He shared me.  >> Manidipa POD: Yeah. Okay. I'll share the video. Just wait, let me get that B like you.  So 11.4 is something that we don't discuss. Okay? So don't bother about it too much. You can go through it once, but it just has a lot of Information that is not required. So and it's all very difficult to understand.  So if you don't get it, it's fine. We also skip that 11.4 it's not required.  >> P Baskaran Nadar: What is that 11.4?  >> Manidipa POD: 11.4 Lecture. Okay, that you can skip for a week 11. You >> P Baskaran Nadar: Even. We also. To also is much more than that.  >> Manidipa POD: So week 12, say in week 12, we are only going to discuss in 12.1 and 12.2  nothing else. Okay? Nothing else is >> P Baskaran Nadar: Okay.  >> Manidipa POD: required. Just the first two and I will give you exactly the type of numericals that will come from there. We'll just practice those  >> P Baskaran Nadar: Okay, I just finished watching all and then I was little confused with that. Are we?  >> Manidipa POD: No, no. All that is not required. Yeah.  That part is very independent. You know, from there what type of question can come is one thing. Your relational algebra type of question might come okay Because in 12.1 you can see some of those questions are there.  >> P Baskaran Nadar: That optimization is okay. That's all >> Manidipa POD: Yeah, that is that is going to come and some other block nested loop. Join from there. Some questions?  Yeah, okay, I got this. Okay. Do so we need a log record type of problems, right?  >> 23F3003828 ADITYA SATYAM: You know, 11.4 is not required, for example.  >> Manidipa POD: They can just go through the lecture ones that's enough because we don't discuss that problem. That lecture. And find the log record. Just one second. Let me check another paper.  I think it was in September 24th.  But the thing is that your that thing wasn't covered. No, ah >> P Baskaran Nadar: but,  >> Manidipa POD: locking procedure  >> P Baskaran Nadar: The.  >> Manidipa POD: Yeah, don't worry about it. It's fine. Don't have to do that.  But this locking protocol is very important. I don't think it was discussed. Yeah. Okay. I got the problem. Okay. Can you see my screen?  >> P Baskaran Nadar: No, we screen is not visible.  >> Manidipa POD: Right.  No.  >> P Baskaran Nadar: No not yeah. Now is something Okay.  >> Manidipa POD: Okay, see here. I think we have one problem.  >> P Baskaran Nadar: I went through this, yes.  >> Manidipa POD: Yeah, this is one problem. Okay. This is the one that we just saw. So from here you can solve right? Tell me which one is wrong. T1 needs to be undone, is this correct? Do we need undo 41? No. >> P Baskaran Nadar: No.  >> 24F2008789 DISHANT KHATRI: People that day.  >> Manidipa POD: Correct, T1 needs to be redone. What about the next T2 can be?  >> P Baskaran Nadar: Yet.  >> 24F2008789 DISHANT KHATRI: people said,  >> Manidipa POD: also, you  >> P Baskaran Nadar: All committed. He also has  >> Manidipa POD: So, third option is saying, you want T2 T3 has to be redone. Is that correct?  >> P Baskaran Nadar: That's only right.  >> Manidipa POD: P4 needs to be undone. >> 23F3003828 ADITYA SATYAM: This.  >> Manidipa POD: Sorry so C and D are correct. Okay, this type of >> SANDEEPKUMAR SUDHAKAR SURKUTE: Correct.  >> Manidipa POD: and this one also lets solves since we're already doing  >> P Baskaran Nadar: This is okay.  >> Manidipa POD: Okay, this is very easy question, but still, let's do it. So this is the monthly backup schedule. It is asking that A with a number of backup sets that need to be loaded for complete recovery. If there is a system failure on 11th day of the month. So tell me how many backup sets need if eleventh day, the failure  occurred after the backup for the day was completed. So how many sets I need?  >> P Baskaran Nadar: This isn't anything nice.  >> Manidipa POD: White 5 6.  >> 24F2008789 DISHANT KHATRI: Man 3.  >> Manidipa POD: Three sets full differential incremental.  So A is 3, okay? And B is the number of backup sets that need to be loaded for a complete recovery. If system failure on 25th day before the backup has been completed for the day. So this is the day. So, how many sets do I need?  For full differential. Incremental incremental, so B is for just asking what is B minus k? So that is one is the answer, okay. Now, log record question, right?  It's not in this, but it's Well okay, one more paper I have there. It was in present with me. >> P Baskaran Nadar: there was The right question was wrong in this? I think.  >> Manidipa POD: Rate architecture.  >> P Baskaran Nadar: Yeah, I think so. In this side. It made a one wrong statement.  >> Manidipa POD: Could be, maybe we.  >> P Baskaran Nadar: Very one is supposed to be. Fully fault tolerant. But  >> Manidipa POD: Haha, right. I think there was one wrong statement video evaluated that later. >> P Baskaran Nadar: That I found.  >> Manidipa POD: Yeah. Okay, this question is good. Sorry. >> P Baskaran Nadar: Thank you. >> Manidipa POD: Yeah. And that's why we have to email. We're trying.  >> P Baskaran Nadar: Topics.  >> Manidipa POD: Yeah, and definitely.  >> P Baskaran Nadar: You know, from my IIT. If it says that there is wrong, then we probably go on and look at  >> Manidipa POD: Yeah, because students spend a lot of time on this questions, right?  Understand that. See in this paper. I think we have one log record question. Yeah, this is one. Okay.  >> P Baskaran Nadar: yeah, this this  >> Manidipa POD: Yeah, so it is saying that we have log record of a transaction like this.  Okay, so these are the log records given. So you have to just suppose the transaction failed before step 5.  >> P Baskaran Nadar: Okay.  >> Manidipa POD: 1, Which QP is this?  >> P Baskaran Nadar: There's no checkpoint here. Of course. We assume that it is before.  >> Manidipa POD: No, I think this is true.  But it doesn't know what.  >> P Baskaran Nadar: Not that question was. Okay, we could discuss that  >> Manidipa POD: No, I think that is from current. That is a question I prepared for later, it's not the one. From September, you can take one.  yeah, this  These are all in the same file. Okay.  This one.  >> P Baskaran Nadar: Good.  >> Manidipa POD: okay, so t0 start, you can see all the log records, given in this order, so suppose that there is a system crash after the last log record, that is this one. Okay, so what would be the values of a b c? D stored on disk at that point,  that you have to find out?  Yeah. >> P Baskaran Nadar: The disc. Okay. So  >> Manidipa POD: So consider, this is immediate modification, okay? Everything is immediate >> P Baskaran Nadar: Right.  >> Manidipa POD: So T0 first made a change to A and change it from thousand to 800. so first check, which transactions actually committed because >> P Baskaran Nadar: just,  >> Manidipa POD: those are only valid.  >> P Baskaran Nadar: Just a minute. This is not talking about a recovery process. They are just  >> Manidipa POD: No, this is no this is not recovery. It is saying that at the time of failure. what is the value that is stored in disk  For the four variables. Okay, at that time so if some transaction hasn't committed, So, we are not going to take their updates into account. Because, anyways, they will be undone, right? Only the updates that matter are the transactions that  committed? So, which ones committed, T2, committed, and T1, committed. T0 did not commit. So any update that it made will anyways, be lost. So it will not be considered Okay. >> P Baskaran Nadar: So basically we can go from the bottom up, whatever has been committed. Those.  >> Manidipa POD: Yeah.  Like, if you go from bottom up, then it will you will get the correct answer soon. So, >> P Baskaran Nadar: Logical way. Looking at right?  >> Manidipa POD: Right. Because see both T1 and T2 commit and T2 has changed, DT. One has also  changed D but which change will persist the last change.  >> P Baskaran Nadar: Correct.  >> Manidipa POD: Right. So D value will be 710 for sure. After that D hasn't been changed. Right. >> P Baskaran Nadar: So we can. >> Manidipa POD: some, if there is some modification that see like this modification in this question is t1 is the final one but it can be interlived. Also, maybe after t 1  T 2 also did something and then the commit of T2 happened like this, okay? Or like  in this example, see if T2 here change D, right? If T2 had changed to be, Then that would be the final value of b because p 0. Changing B. Doesn't matter. >> P Baskaran Nadar: So go by the variable basically.  >> Manidipa POD: Yeah, go by the variable and see which transaction made the change.  Right. >> P Baskaran Nadar: Section, which was the last commit. That would be Okay.  >> Manidipa POD: So, both transactions that have committed their changes are valid. Now, the last transaction that committed, if it >> P Baskaran Nadar: Yeah.  >> Manidipa POD: changed some value, that was changed by the previous transaction. Then that last commit will persist the last change will persist Okay. >> P Baskaran Nadar: Okay.  If I go from the bottom, First transaction, B. It is not t, 0 is not committed. from the  >> Manidipa POD: T. 0 is not committed. Correct.  >> P Baskaran Nadar: I don't I can ignore that.  >> Manidipa POD: Ignore it. >> P Baskaran Nadar: so,  By T1, which was committed. So, T1 should be 750. B.  >> Manidipa POD: B should be 750, okay?  >> P Baskaran Nadar: Now, let me look at d d, has been committed by D t1, which is committed. So it is 710. Deeply seven.  >> Manidipa POD: Right. These 710  >> P Baskaran Nadar: C is modified by T0, which is not been committed. Correct.  >> Manidipa POD: Right.  >> P Baskaran Nadar: So C will be 170.  >> Manidipa POD: 1700, whatever was told value.  >> P Baskaran Nadar: a is modified by T0, but that is also not committed.  >> Manidipa POD: Right.  >> P Baskaran Nadar: So, it  >> Manidipa POD: so even also cont, >> P Baskaran Nadar: oh, Is that the right? Correct logic. >> Manidipa POD: So see option, A is thousand, B is 750, C 1700 d710. That's the correct one.  >> P Baskaran Nadar: Okay.  >> Manidipa POD: Okay. So this type of question only will come from log records and Med from your backup only that backup recovery monthly. Scheduled type of question and some Security question. >> P Baskaran Nadar: Thank you very much.  >> Manidipa POD: Yeah, don't worry. So another question that will come, is definitely that one that we did that checkpoint question, right? So these are the three main types of problem, we can practice. So just get all the vyq sets and practice these problems. Okay? >> P Baskaran Nadar: Thank you. Thank you.  >> Manidipa POD: okay, then  Yeah.  >> 23F3003828 ADITYA SATYAM: can I get the last opp questions?  >> Manidipa POD: This recent dopey.  >> 23F3003828 ADITYA SATYAM: Yes.  >> Manidipa POD: Question set. Which set do you want?  >> 23F3003828 ADITYA SATYAM: It's set. How many sets are there, man? I don't know.  >> Manidipa POD: Two sets are there, I think. so,  >> 23F3003828 ADITYA SATYAM: okay, then  >> Manidipa POD: you can do one thing. I don't have the questions right now but you can just post on discourse and tag user, that would be better. I think he has the sex So, we can give you. Okay. >> 23F3003828 ADITYA SATYAM: Woman.  >> Manidipa POD: Yeah. I said that you make a post on this course and you can take you sir on me and we can give you the set there, you just mentioned with it.  >> 23F3003828 ADITYA SATYAM: Okay.  >> Manidipa POD: Yeah. Okay. So in Saturday session, the AQ PQ part of this will be discussed with radar architecture, Okay? So please be present  >> 23F3003828 ADITYA SATYAM: Week, 12 Mem.  >> Manidipa POD: No week, 11 only.  >> P Baskaran Nadar: I, >> 23F3003828 ADITYA SATYAM: Okay.  >> P Baskaran Nadar: Is there possibility anytime that?  >> Manidipa POD: Yeah, on the see we will have two divisions sessions before in terms. Okay. So all the topics that you have this difficulty in will discuss them. Anyways, I'm trying to plan one, extra session for week 10. So if that is possible, they are also, you can take it up.  >> P Baskaran Nadar: Because a terminology little confusing. I don't know whether to take the, you  >> Manidipa POD: okay, we will discuss it in either in revision session or in extra class will discuss  >> P Baskaran Nadar: The middle one left.  >> Manidipa POD: That's that's left by sidewise. That's your decision, okay? Or it will be  mentioned in the question, which one you need to take.  >> P Baskaran Nadar: Mmm.  >> Manidipa POD: okay, you're saying that now that when a node is filled and you need to split it, Yeah, so either you can pop the left one or the right one. If the node has an even number of keys, right in that, >> P Baskaran Nadar: Yeah.  >> Manidipa POD: case, there are two possibilities. So you can either take left or right. That will be mentioned in the question which by saying you need to do left or right.  >> P Baskaran Nadar: I come across some questions which are not clear about.  >> Manidipa POD: Yeah, proper previously that happened. That's why from now on we just mention it in the question only. Yeah. >> P Baskaran Nadar: Good. Thank you.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: I'm ah, I  like, if you may recall not that Mozart Srinivas and all those Einstein etc, being put  So I feel on the right side is the route, okay. so,  >> Manidipa POD: Hmm.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: I feel that should have come down right first and then she never should have followed You know. because,  >> Manidipa POD: going to share that part with me like the slide or something so I can check once.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: I,  >> Manidipa POD: Okay, no problem. Just do one. >> SANDEEPKUMAR SUDHAKAR SURKUTE: I am actually traveling in a train so trying to attend somehow. So I won't be able to >> Manidipa POD: thing. If you have, if you get that slide, okay, just share it to me on discourse. I will check it once and tell you, whatever is good. >> SANDEEPKUMAR SUDHAKAR SURKUTE: harm them because other online,  in net resources, then I searched, because on the left subteries, you are following that, you know? So  >> Manidipa POD: Yeah, this thing depends on the biasing. Also right. Whatever biasing we have followed there. So I don't exactly remember if you followed left or right, I have to check that so that way it can differ on both things. Okay, left biasing  >> SANDEEPKUMAR SUDHAKAR SURKUTE: But in the slide.  >> Manidipa POD: is the different result, right?  >> SANDEEPKUMAR SUDHAKAR SURKUTE: but in the slide, there is no mention of bias or something like that. Slide. Just oh,  >> Manidipa POD: I know that is not giving, that's why. I do it when I discuss that but I didn't discuss it this term so I don't know.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: so,  >> Manidipa POD: Let me just give me that slide. Yeah, you can find it.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: Understood this bias and all any live session is there?  >> Manidipa POD: Yeah, previous term only go to Week 9 session. I took that for be treated  history.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: Okay.  >> Manidipa POD: Okay. Yeah. >> SANDEEPKUMAR SUDHAKAR SURKUTE: Okay, right.  >> Manidipa POD: Okay, thanks. >> P Baskaran Nadar: Thank you. >> Manidipa POD: Yeah, thank you. >> P Baskaran Nadar: I,  >> Abhinav Kumar: Excuse me.  >> Manidipa POD: Yeah.  >> Abhinav Kumar: I have a little concern regarding the Opa desert. It can I ask  >> Manidipa POD: Yeah.  >> Abhinav Kumar: Well in okay, I did all the questions except the seventh question. Five months  question and I did the like Python DB the mandatory question. But still, I got a  out of 100 Mark.  >> Manidipa POD: so, >> Abhinav Kumar: I should have 80 out of  Yes. Yes, it was hundred out of hundred in summary, okay.  >> Manidipa POD: Okay. Okay, so >> Abhinav Kumar: but,  Yes, yes. So I have also  >> Manidipa POD: Right, right? You made a post on discourse, right? I saw that today, only, yeah, I have I have >> Abhinav Kumar: Yes. Yes.  >> Manidipa POD: stick to, I have asked you sir about it. So I think he is checking that what the discrepanc  >> Abhinav Kumar: He replied that I  >> SANDEEPKUMAR SUDHAKAR SURKUTE: Num different questions at different weightage.  >> Abhinav Kumar: Can, can I just complete?  >> Manidipa POD: Yeah, one.  >> Abhinav Kumar: Okay, so he replied to me that I should have used variable but I did all the correct, like, Python DB the whole structure including the variable, okay?  >> Manidipa POD: No. >> Abhinav Kumar: but,  >> Manidipa POD: I think what is wrong is? So there are three levels of questions, right? So there's Marks Division based on that. So, which questions you got wrong, that is what matters. So which level questions you got wrong? According to that, the Marx is deducted. Okay, not every question will have same marks.  >> Abhinav Kumar: Thing. But I, as I remember, I did all question rights because the all question  >> Manidipa POD: Okay. >> Abhinav Kumar: test cases has 100 of 100 out of hundred.  >> Manidipa POD: okay, so the last one, >> Abhinav Kumar: Okay. Yes.  >> Manidipa POD: Okay. And  Right. >> Abhinav Kumar: And I did the ninth question. The date of birth portion on Python TV. Okay. there I I hope so have 100 out of hundred just cases  >> Manidipa POD: So, what did you tell you about this?  >> Abhinav Kumar: But I just like will tell you the reply of yourself.  >> Manidipa POD: Yeah.  >> Abhinav Kumar: We don't have any private test cases in an SQL only for Python. DB it is the  >> Manidipa POD: Hmm, that's right.  >> Abhinav Kumar: old host, he just pasted here.  Yeah, I wasn't ever that that private desk is a good affect my final score like this during the exam when I saw 100 out of hundred in somebody after submitting, my Python Data West question, I assume it was correct and moved on you to the time constraint, right?  >> Manidipa POD: Hmm.  >> Abhinav Kumar: Because when he discussed the mock the question, 8 also didn't pass the private test cases.  Okay. So on exam day, I thought the same logic applied. Now I'm confused about, which question caused my score to drop, 80 to 60.  So he again replied. Hi you need to restore the value in variables say X, but I didn't select wrong inquiry. I did.  >> Manidipa POD: Yeah, like after you read the >> Abhinav Kumar: I should.  Yes, yes. I,  >> Manidipa POD: Okay. That should not cause a  >> Abhinav Kumar: Yes, I again replied. So  you can check my code. I did the same. But what I did in last to arrange the output to something different manner. But it was working for me.  >> Manidipa POD: I mean, the formatting you did in a different way.  >> Abhinav Kumar: Yes, yes, you said you are just testing and you will not bother that much and my test cases was also passing. So I thought not change that would and jump to other question because it was my first question that I was attempting in the exam, the Python Division.  >> Manidipa POD: Hmm. Okay.  >> Abhinav Kumar: So everything was going good, so I didn't really think about the printer statement and the arrangement in the last segment.  >> Manidipa POD: Okay. >> Abhinav Kumar: so, Due to the confusion.  >> Manidipa POD: so what we can do is I think we can check your questions, ones. That which ones got marked as wrong, which one got deducted. so, let me talk to >> Abhinav Kumar: Yes, yes. Can I, please?  >> Manidipa POD: you sir. After this class we can take. Can you just yeah just paste your student information in the check like your roll number or something student ID.  >> Abhinav Kumar: Thank you.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: I'm just one link to question. OPP results are out. So if there we are past means passed. Now there is no.  >> Manidipa POD: Who. Yeah.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: and it's mentioning like a programming quiz 2 and then marks are given but it was only one programming quiz for us. No,  >> Manidipa POD: Now, only one will be.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: but it is written like Programming Quiz 2 and then the marks are  >> Manidipa POD: Yeah, because this is actually the OP2, right? So for DBMS we only have OPA 2? No P1. Let's say it's marked like that.  >> SANDEEPKUMAR SUDHAKAR SURKUTE: Okay, so we should not worry about that. Number of  >> Manidipa POD: No, no, if you if it's five minutes first, it's fine. Now enough Kumar this one, right.  >> Abhinav Kumar: Yes, I am also pasting the exam shift and the date.  >> Manidipa POD: Yeah, so that I just mark the information like we talk to you servants.  >> Abhinav Kumar: Map one, little request. Don't deduct my marks over a little confusion because I just  saw all the things were going, right? And I just jumped onto the. I can do the question in the right manner, but since it was,  >> Manidipa POD: Yeah, I get it and maybe see maybe that wasn't even the issue maybe in some  other questions will check that. Okay. As. >> Abhinav Kumar: Okay.  >> Manidipa POD: long as your test cases are passing or getting hundred out of hundred, there should be no issue.  >> Abhinav Kumar: Yes, yes, I am. I remember that I did all questions, right? Okay. Just the thing, I didn't try to guys screenshot of all. But I remember all this.  >> Manidipa POD: And that's all right. That's all you. Not your what that is not what you're  >> Abhinav Kumar: Yeah.  >> Manidipa POD: supposed to do in exam. Anyways, we will check it.  >> Abhinav Kumar: Let me just. It's not.  >> Manidipa POD: Yeah, I'm  >> Abhinav Kumar: I pasted the email and shift.  >> Manidipa POD: Yes, I've copied it. I'll talk to you sir after the class. Okay, we'll check which question.  >> Abhinav Kumar: Okay, thank you.  >> 24F2008979 ARJIKYA: Actually. >> Manidipa POD: All right. Yeah, thanks. Thanks for joining. Yeah.  >> 24F2008979 ARJIKYA: Excellent man just just when I'm sorry to interact. Then I also had a very reg questions 7 of set B 931. Like the interpretation of the question, there was some ambiguity in the  >> Manidipa POD: Hmm. >> 24F2008979 ARJIKYA: interpretation or the premium. >> Manidipa POD: Did you post on this course?  >> 24F2008979 ARJIKYA: I had.  >> Manidipa POD: Okay.  >> 24F2008979 ARJIKYA: But still the  >> Manidipa POD: Okay, can you just post the question ID? Let me check.  >> 24F2008979 ARJIKYA: You want me to post the question here in the chat?  >> Manidipa POD: Or you can you can just post your discourse post link. Okay, I'll check from there.  >> 24F2008979 ARJIKYA: Children, just  >> Manidipa POD: Will it be okay if I give you the answer for that one that we had? I mean the actual query that we have for that question.  >> 24F2008979 ARJIKYA: The query has service yet the courier to share the body the solution of along  >> Manidipa POD: Okay. >> 24F2008979 ARJIKYA: with the query. But my concern is like the The.  >> Manidipa POD: Okay, let me check one.  Okay. >> 24F2008979 ARJIKYA: I've shared the query in the  >> Manidipa POD: for find the user ID and total quantity of product purchase total amount spent  by using server will produce, right? This question, I saw on discourse also, so this means that we need to find The user ID of the person. Okay. Now, three things we need to find what one is the user ID. One is, the total quantity of products that person is purchased. And one is the total amount that the user has spent right in total.  Given that the condition is that he or she must have purchased products from this particular category.  >> 24F2008979 ARJIKYA: At least one product.  >> Manidipa POD: yeah, I mean  the list of products that they have purchased from there at least one product should have been from electronics.  >> 24F2008979 ARJIKYA: So right man, but the query that Saras shared now, so it only considers only the electronic category, the solution that shared  >> Manidipa POD: Okay, that means all products from electronics.  >> 24F2008979 ARJIKYA: Only from electronics, Mem.  The question in, this was my interpretation. My this is my  >> Manidipa POD: No, no. Okay, okay I get it. I get it. What is wrong and see. The thing is that Here, the question is saying, total quantity of products purchased and total amount spent, right? so, according to the query, what it means is total quantity of product purchased from electronics and total amounts, spent by user, only on this category of items. Not overall category. Yeah, this is what the explanation I saw you wrote. I saw that query and >> 24F2008979 ARJIKYA: How they should?  >> Manidipa POD: I did not answer because views are already wrote it. But the thing is that we are I know this interpretation, you have done a lot of people could have made  that interpretation that we are talking about. some person who has purchased one item, at least from electronics and we want their total whatever they have purchased that total quantity, it  >> 24F2008979 ARJIKYA: That's what I'm saying on that in the focus on the users. Now, that user who has bought the product from Electronics Categ,  >> Manidipa POD: yeah, I think the wording >> 24F2008979 ARJIKYA: it's  That's what?  >> Manidipa POD: Because this means that what we are trying to get you to write. Is that total quantity of products from electronics and total amounts spent on electronics.  >> 24F2008979 ARJIKYA: We have United States for that.  >> Manidipa POD: But yeah, but you are thinking that it is for the whole. So that thing we that thing, I think we could have mentioned that products purchased and total amount Who have bought products from electronics and only about that category. So this thing we could have mentioned Yeah. So >> 24F2008979 ARJIKYA: Like man, the products purchased from the Electronics credit union.  Product purchase one. >> Abhinav Kumar: Same thing, here happened.  >> Manidipa POD: yes, at the time we thought that this would be enough explanation because we are writing this that products from electronics, but  >> Abhinav Kumar: I was I was writing. A different query for this only.  >> Manidipa POD: Yeah, so some people obviously interpreted the other way that we are talking  about the overall purchase. you know, just the electronics one, I don't know if this question is being a very evaluated or what I don't think. So. Yeah. >> 24F2008979 ARJIKYA: Name. The marks have appeared in that.  >> Manidipa POD: And some people I think, can I mean, what is your love? This thing, Crit. >> 24F2008979 ARJIKYA: When my >> Manidipa POD: for creative. >> 24F2008979 ARJIKYA: oh, my point of contention was like the focus is on user same and if you see them in this,  >> Manidipa POD: Right. It is on user, but  >> 24F2008979 ARJIKYA: So, the >> Manidipa POD: So when I talk about the user itself that person might have purchased from different categories of items, right?  >> 24F2008979 ARJIKYA: Exactly, man. I have to find the users from electronics that are purchased overall because it should have been in the electronics must have been  electronics, but he purchaser  >> Manidipa POD: Hmm, that's that's what I'm saying. But this wording could have been changed here.  >> 24F2008979 ARJIKYA: synonym, I have also posted this one also, like, If we had to find it out, this could have been.  You know. The query or the.  >> Manidipa POD: Right. In SQL, query to find user ID total amount of products. Purchase total amount spent by users, where products, but okay? So instead of who have, if we  wrote, where products, purchase word from electronics, right?  >> 24F2008979 ARJIKYA: Because of focus here becomes the products purchase on the electronics. Getting  >> Manidipa POD: Right. Because actually we want the focus to be on the category, but in our  >> 24F2008979 ARJIKYA: Consum. >> Manidipa POD: wording it the focus goes to the user. Right. >> 24F2008979 ARJIKYA: man, The focus went to user because even from the construction of the sentence, after this, the users became that  >> Manidipa POD: Who.  this would have been a better wording. Correct. But that is a where products are purchased from this category, correct? Because this one is ambiguous, two interpretations. Are there >> 24F2008979 ARJIKYA: He?  >> Manidipa POD: So, if people had, I mean, you know, if someone tried both only then they will know.  >> 24F2008979 ARJIKYA: He wouldn't.  >> Manidipa POD: like,  >> 24F2008979 ARJIKYA: Okay.  >> Manidipa POD: I understand what the problem is in this. We also discussed this problem, you know, after we saw your post, We discussed this I think yesterday when we were discussing that the wording could have been changed here.  So in reattempt, we are going to try to avoid any such ambiguous questions.  I mean, this seemed fine to us when we were doing the testing and all, but we didn't think around the student point of view that they might think differently. So that thing, yeah, this is one thing we could have changed. So what is the criteria for your reactantropy? >> 24F2008979 ARJIKYA: Then either.  >> Manidipa POD: When?  >> 24F2008979 ARJIKYA: the DB op connectivity. Question should not be elected. Should be left out. So it fails  >> Manidipa POD: Or the 40% is not done.  >> 24F2008979 ARJIKYA: 40% of 48, 35% is, I think?  >> Manidipa POD: Okay. So like only if you have failed you can go for the attempt. >> 24F2008979 ARJIKYA: Yes.  >> Manidipa POD: Okay. Right. So reactant you have to make sure like I think already tested for creating no such questions in video.  >> Abhinav Kumar: now, one clarification  >> Manidipa POD: Yeah.  Then it's fill. >> Abhinav Kumar: Like, if I have a score more than 35, but someone is filled in Python DB then.  >> Manidipa POD: Yeah. >> Abhinav Kumar: Then, but  Okay. Okay, so ah, and how much time, you know that if I am fail or not due to the question or >> Manidipa POD: The scores are. Okay, after we check we'll let you know in one day I think by tomorrow only we'll check it. Okay. Because right now I'll send this information to view certain will check.  >> Abhinav Kumar: Again, that little request now, just check the good and hope.  >> Manidipa POD: Yeah, definitely. We  >> Abhinav Kumar: the statement don't like  >> Manidipa POD: Let's see if if we see that the code is running correctly, you are getting  hundred out of 100. The correct output is coming. Why would we deduct anymore? So, okay, let's just check what is going on? Okay, no, nothing extra, really deducted.  >> Abhinav Kumar: Oh, okay.  >> 24F2008979 ARJIKYA: so then, >> Abhinav Kumar: Thank you.  >> 24F2008979 ARJIKYA: what can be done in my case, not like, is there any opportunity to go for re or something?  >> Manidipa POD: This one. I don't think anything can be done now but let me ask you said if the students who if they want to take a reattempt but then there comes the question that if you do a reattempt and then you get worse marks there then which marks we keep and and it's a whole big thing. >> 24F2008979 ARJIKYA: I know she. Funny the second consider the second box. It's not about that. I don't give a worry about that.  >> Abhinav Kumar: best of,  >> Manidipa POD: Yeah, but then a lot of people are going to register for that, right? So if >> 24F2008979 ARJIKYA: You know, that's me.  >> Manidipa POD: we have to do it for everyone, Ok, let me ask I am not sure but let me ask maybe we can let you know in  announcements or on discourse. If any such thing we can do.  Okay.  >> 24F2008979 ARJIKYA: Yes.  >> Manidipa POD: I have to discuss with the whole thing. So let's just  >> 24F2008979 ARJIKYA: Yes, but you understand issue and  >> Manidipa POD: Yeah, I get it. We discussed it at length, only. We got it. What the ambiguity  was? But let's see if we can try for the attempt, okay? Yeah.  >> 24F2008979 ARJIKYA: Thank you. And thank you so much.  >> Manidipa POD: Yeah, thanks. >> 24F2008979 ARJIKYA: Good.  >> Abhinav Kumar: and your uncle like,  >> Manidipa POD: Yeah, thank you. 