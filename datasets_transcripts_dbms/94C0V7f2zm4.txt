Hello friends, Welcome to Gate smashers In this video we're going to talk about concurrency control protocol concurrency control protocol basic aim is to achieve serializabity and achieving recover-ability and what are serializabity and recover-ability we had already discussed Conflict serializabity, view serializabity and in that we've discussed that how to check that which schedule is serializable or which one is not But Aim of concurrency control protocol is not to check but how to make them that how to make it serializable or how to make it recoverable Schedule are concurrent but how to make them recoverable and serializable that comes under concurrency control protocol and how we achieve this By using the locking protocols We've various locking protocols Simple locking protocol under which comes Shared Exclusive locking protocol There are 2 PL Rigorous 2 PL Strict 2 PL Time stamp protocol so there are various protocols But among these the shared exclusive protocol and time stamp are the most important ones So like the video Subscribe the channel who has not done yet and press the bell button So that you'll be getting all notifications Will start with Shared-Exclusive locking It is very basic and the first locking protocol or we can call simplest locking protocol that is shared-exclusive locking and here if we discuss we're using two types of lock Shared lock and exclusive lock We use shared lock when if the transaction locked the data item in the shared more then it is allowed to read only and if in exlusive mode data is locked then read and write both can be done, it means Lets say transaction is T1 And Transaction has to perform Read(A) A only want perform read so what we'll do We'll take shared lock on A Now in this case there is no benefit of taking exclusive Why? If only read is to be done then we can achieve our work with shared mood only and when is work is over Then what we'll do We'll unlock it So S means shared and U means unlock A means on which data item you're taking A,B,C you can take anything Same if we talk about transaction T2 Read(A)  and Write (A) both If transaction has to perform  Read(A)  and Write (A) both and in this case if I say that we've to take shared lock That won't apply What will apply in this case ? In this there will be exclusive lock on A What we can do in exclusive lock case Read and Write both and on shared lock case what we'll do only read and now if you are only read in exclusive you can do that also but there is no benefit of that, by default we set the algorithm or set software in such a way that if want to read take shared and if want Read and Write  both Then use exclusive lock and when its work is over means when read and write is done then it will perform unlock A Like if someone else request they can get the lock because in a transaction there is work done on multiple data items So it is not unnecessary that only T1 need lock There is T2, T3, T4 everyone acquires lock so they will request for lock so the concurrency control component that will check It will check compatibility table and here the compatibility table is important Questions may come on this There is simple thing is compatibility table On one side we're saying grant and on other side we're saying request As we know there are only 2 locks- Shared and exclusive so how many case can form 4 case, Shared - Shared Shared- exclusive Exclusive-Shared Exclusive- exclusive So same we are doing here Let's say grant means If on this side grant is there and on other side request so lets say we already grant shared lock Means concurrency control component shared lock on A I'm taking about A data item, not separately A, B, C Lets say we're only taking about A data component and I've given shared lock (A) and if someone else also request that I also want shared lock(A) means on same data item and will be allowing the request obviously yes Reason I've just told you what we do in shared mode Only Read is done and there is never a conflict between read and read No As I've already told you Conflict serializibity all these conflict read, read, read, read, write what are they that I already made videos about Link of that I've mentioned in description box, do check it once As there are many things in this that we had already discussed and we're using it directly here So there is no conflict in Read and Read we're only checking data So here you can grant Let's say we already granted shared lock and request came on exclusive lock Means A needs exclusive lock So will that be granted ? No we'll not what we'll do We can no it, as I've written X here, so here I'm doing yes and here I'll write no No means that we won't grant it and reason is Means if a transaction has taken shared lock let's say it R(A) Read(A) and second transaction is saying that I need exclusive lock means what it want to do Read(A)  and Write (A) both and if we allow here in future there can be Read(A) and Write(A) conflict So to prevent that what we'll do is No So next is if we had already granted exclusive lock already we granted exclusive lock (A) and if someone ask for share lock, So will we give ? No, same Write and read, means we're already doing read and write one transaction is already doing and second one is saying that I've to read so same Write, read problem so we won't allow and on 4th case also we won't allow Write- write problem, one is already doing Read-Write and second one is saying that I want to perform same on Read-write on same item so if we allow that So again problem on inconsistency can come so to prevent what we'll do is no So basically our Shared-exclusive locking protocol It's main purpose is that we are trying to achieve serializabity because of which we are trying to achieve consistency if we achieve this so the acid property that we discussed earlier In that C which is consistency we are trying to achieve that So this compatibility table is very important you should know this