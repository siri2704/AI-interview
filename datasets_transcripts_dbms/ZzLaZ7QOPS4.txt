hi everyone welcome to go classes in this lecture we are going to study SQL complete summary this is going to be the complete summary lecture the complete lecture of SQL and let me tell you that every important point every tricky question everything I will cover in this lecture okay also if you did not study SQL so far then also so you can watch this lecture and after watching this lecture we will solve every gate question every gate previous year question you will be able to solve based on SQL you will be able to solve after watching this lecture okay so let's start now so let's see what is SQL the full form of SQL that is structured query language and this is a database language we already know okay so you can see you can pronounce this as SQL or you can pronounce as SQL okay so this is a standard query language which is supported by most dbms software most relational dbms software they support SQL query language so you can see this structured query language this is most commonly used relational databased query language okay for rdbm software we use this query language most commonly okay so let's see let me tell you the first point first important point about SQL that is SQL is declarative not procedural okay so SQL is declarative what that means and what this procedural means so let me tell you SQL is declarative it simply means let me tell you what declarative means declarative means that see when some language is declarative it means that you just Define what to do you will not Define how to do okay if you want to if you want to receive some information you want to retrieve some information then you will just you will just specify what information you want you will not specify the stepbystep procedure to retrieve the information okay so remember SQL is declarative means what it means it simply means that SQL query specifies what information we want okay so I can say that just only specify we only specify we only specify what we want okay what we want not how not how to get it okay not how to get it okay very simple and what procedural means procedural simply means that you will Define the stepbystep procedure how to get it okay basically here in the procedural what we Define we Define defines a step byst step procedure step by step process procedure okay about how to get the information okay how to how to get the task done so very simple SQL is declarative means we will only specify what we want we will not specify the order in in which it will be executed okay we never specify the order in which this query will be executed we just specify what we want okay so you can easily see consider this example you can see this real word example what is declarative what is procedural see this real word example if you want to make a cup of tea then declarative language what it will do remember this is our task our task is I want a cup of tea okay then the declarative language what it will do it will just simply say what we want okay means get me a cup of tea but the procedural language what it will do it will give the stepbystep procedure how to get it done so remember this is our task okay our task is this now to carry out this task the declarative language will simply Define will simply specify what we want okay get me a cup of tea but the procedural language will Define step byst step process okay how to get the task done give me the step byst step procedure so you can see go to the go to Kitchen okay get sugar milk tea mix them heat over the fire okay till it boils then put it in the cup and bring it to me okay is this clear please tell me this analogy is this clear procedural versus declarative so remember SQL is a declarative okay in SQL when you write SQL query then you are basically specifying what you want you are not specifying how this will be executed okay how this information will be G uh basically how this will be implemented how this will be executed okay how the SQL compiler or the dbm software how that will carry out the task that you will not specify you will just specify what you want okay so you can see SQL is declarative not procedural declarative programming is where you just say what you want without having to say how to do it okay you can see so declarative programming means here you just mention what you want okay what you want without having to say how to do it okay similarly with procedural programming you will specify the steps to get the result okay step by step procedure to get the result and remember SQL is declarative so the queries don't specify the steps to Pro produce the result okay in the SQL queries we don't specify the steps to produce the result we just specify the information we want what we want we just specify that okay so I hope you understood okay very simple now let's move on so you can see SQL is declarative not procedural now one thing I want to tell you that this point we will revisit after some time we will revisit this point SQL is declarative what it actually means we will revisit this point after some time so remember this point okay we are going going to revisit this point now let's see the next topic that is set versus multiset multiset is also called bag okay these two they are same either you can call it multi set or you can call it bag now what are the difference between set and multiset so you can see set you already know set what are set set is unordered collection of items which do not have duplicates unordered distinct collection of items okay set is unordered collection of items which are distinct means there are no duplicates and what is a multiset multiset means bag both are same so what is a bag bag is unordered collection of items but duplicates are allowed may contain duplicate okay so remember the difference between set and bag bag means multi set this is another name bag or you can call it multiset so remember set is unordered the order doesn't matter unordered collection of items where no duplicates yes or or no where we have no duplicates okay so unordered no duplicates in bag this is also unordered the order doesn't matter this is also unordered but remember here duplicates allowed here duplicates are allowed okay is this clear so very simple point for example if I give you consider this structure 1 comma 2 comma 2 okay so here you can see remember if this is a set then this is same as 1 comma 2 if this is a set okay if this is a set so okay let me let me clarify this remember when I say that you have a set you have a set 1 comma 2 comma 2 then this is same as 1 comma 2 the duplicates you will remove yes or no the duplicates are removed no duplicates okay so the duplicates you will ignore so remember if I say this is a set it means there are no duplicates okay so this is same as this and I can say this is same as this but remember when I have multi set or when I have bag if I say that this is a bag 1 2 two then remember this is not same as 1 comma 2 is this clear okay remember here you can see that this item two we have two times but here this item two we have one time so remember in a bag you can see duplicates are allowed so duplicates matter okay so remember this bag and this bag they are different it's like this in this bag we have these same chocolate two times same chocolate two times here this chocolate we have one time so they are different agree with me yes or no okay you can consider this real life bag there is a real life bag so you can see that unordered order doesn't matter but duplicates are allowed so can I say every set is bag can I say every set is a bag yes every set is a bag because remember duplicates are allowed it is not necessary that you have duplicates it is not necessary every set is a bag but can I say every bag is a set can I say every bag is a set every bag is not a set okay so you can see for example if I give you this 1 2 two then remember this is a bag this is not a set okay this is a bag this is not a set because in a set we don't have duplicates we remove the duplicates in a set we remove the duplicates so remember if I say this is a set if I say this is a set then it simply means you will remove the duplicates so this will be same as this okay so very simple point so remember this is a bag but this is not a set I hope this point is clear so every set is multi set but Converse is not true okay is this clear now let me tell you some more points for example consider some bags I'm giving you I'm giving you some bags okay for example you look at this bag can I say this is same as this are these two bags same yes they are same because they are unordered bags are also unordered okay but remember this 1 comma 112 that is different from 1 to2 that is different from 1 Comm 2 okay is this clear that is different from 1A 1A 2 okay is this clear so very simple point I hope all these points are clear now remember for example 1 comma 1 comma 1 here this item one we have three times this item two we have one time this item three we have four times okay so this is another bag so in a bag can I say that frequency of items matter yes or no this is another bag and can I say that frequency of items matter yes here you can see the frequency of one that is three okay this one is appearing three times this two is appearing one time this three is appearing four times okay so very simple in a bag frequency of elements matter okay this is what I can write that in in a bag in a bag the frequency of elements matter frequency of elements matter okay so very simple point so you can see tell me is this a bag or is this a set look at this table is this table a bag or is this a set you can see this tle is repeating okay you can easily see so this is a bag this is a bag of tles this is a bag of tles this is not a set of tles okay remember here we have how many tles there are total four tles okay remember there are total four tles here okay for example look at this look at this bag he in this bag we have total three items okay in this bag we have three items okay is this clear very simple Point okay for example look at this bag in this bag how many items we have four five and eight so total eight items we have very simple so here you can see this is a bag of tles because this tle you can see this is repeating okay okay so can I say this is a bag of tle yes okay this is not a set of tles I can say this is not a set of tles okay very simple now let me tell you one very important point about SQL about this SQL query language let me tell you very important point that is this SQL treats table as a bag not as a set in SQL our table our relation is a bag okay so duplicate rows are allowed is this clear this is very important point because remember if you study relational algebra then there our table our relation does not have duplicate tles but in SQL our relation can have duplicate tles our input relation can also have duplicate tles our output also can have duplicate tles so remember in SQL the input output basically everything is a bag of tles so duplicate tles are allowed I hope this point is clear so remember SQL allows same tle to appear more than once in a relation okay so in SQL remember your table your relation is a bag of tles it is not a set of tles it is bag of tles so duplicate rows are allowed I hope this point is clear okay so you can see that in the relational algebra our input our table that is set of Tes yes or no there are no duplicates so you can see in a set we have no duplicates okay for example your relation algebra that uses set semantics so when you solve any question of relation algebra then your table has no duplicates okay now remember our SQL uses bag semantics what it means it means that duplicates are allowed duplicate tles are allowed and number of duplicates is also significant the frequency also matters okay very simple point so I hope all these points are clear now let me tell you the difference between relation algebra and SQL what are the differences between these two okay because there are many misconceptions here so let me tell you about the difference between these two SQL and relation algebra so that when you are solving any question of relation algebra and when you are solving any question of SQL then you can take care okay all these small small points you can take care so let me tell you the first important Point what is that the first important point is relation algebra uses set semantics it mean it means that in relation algebra our table our our table is a set of Tes okay but SQL uses bag semantics so remember relation algebra treats the table relation as a set of tles so not duplication of tles but SQL treats the table as a bag of tles so duplication of tles is allowed this is very important Point okay is this clear let me create the diagram so remember when you are when you have a relation algebra query so this diagram will help you so if you have relational algebra in this relation algebra remember our input and output that is set of tles okay that is set of tles our input and output but remember in SQL our input and output there are bag of tles so you can have duplicate rows okay is this point clear okay so very simple point I hope this point is clear bag means multiset another name for bag is multiset okay now let me tell you the second important point that is there are no null values in the relation algebra if you remember when we studied relation algebra at that point I told you that there are no null values in the relation algebra okay so when you are solving relation algebra question will you ever consider null values in your input table in your table will you consider null values no so remember there are no null values in the relation algebra but SQL table can have null values okay so null values concept is not there in the relational algebra now you might be thinking sir in relation algebra we have outer joints full outer joint left outer join yes or no we have outer joints and in the outer join when uh the output of the outer joint that has null values yes or no you might be thinking see I'm saying that there are no null values in the relation algebra but you might might be thinking sir outer joints have null values so let me tell you outer joints are not considered part of classical relation algebra you can consider that outer joints they are basically they were added as extended features of relational algebra so remember outer joints they are extended features of relational algebra they are not considered part of classical basic algebra basic relation algebra okay so this is very important point I'm telling you that whenever you see any question of relation algebra then you never have to worry about null values never don't worry about null values there are no null values in the relation algebra but SQL may have null values in the SQL table you can have null values you can see this screenshot you can see from this University okay you can see there are actually no concept of null in the relation algebra okay so this is a university screenshot you can see there are actually no concept of null in the relation algebra in the relation algebra we don't don't have concept of null values now let me tell you the third point that is the third difference between SQL and relation algebra so in the relation algebra can I say that your table must have at least one primary key can I say in the relation algebra can I say your table your relation must have at least one primary key yes there will be actually exactly one primary key in the relation algebra your relation your table will have exactly one primary key there will be at least one candidate key yes or no all these points you already know but remember in SQL in SQL you may not have a primary key you may not have a candidate key okay so you can easily see for example in SQL this type of table is allowed okay SQL table okay consider this table R in SQL this type of table is allowed a b okay for example 1 2 I told you duplicate duplicate Tes are allowed okay yes or no now you tell me here you look at this tell me is there any primary key here is there any primary key in this table okay you can see if there is primary key then you cannot have duplicate Tes so there is no primary key here yes or no in this there is no primary key okay is this clear so very simple okay because if you primary key then you cannot have duplicate there is no primary key there is no candidate key here there is no okay so very simple now you can easily see that in general SQL table is not required to have a key okay SQL table may not have a primary key may not have a candidate key but relational algebra must have exactly one primary key and at least one candidate key you can see that relation algebra must have primary key and candidate Keys okay you can have at least one candidate key so you can see this is the screenshot from naate book this is the book nawate okay you can see this in general SQL table is not required to have a key although in most cases there will be key but in general SQL table is not required to have a key okay is this clear an SQL table but now you tell me one thing if I tell you that SQL table has a key now can you have duplicate tles if I give you this information that SQL table I give you this information that you have SQL table and in this SQL table this is a key this is primary key now can you have duplicate tles now you cannot have duplicate Tes so remember if I give you this information in the question in the question if this information is given that your table has a has a key has a primary key then you cannot have duplicate tables so remember an SQL table with a key is restricted to being a set okay since the key value must must be distinct in each tle very simple Point okay so these are the points these are small small points I hope all these points are clear please tell me all these points are they clear let me know anyone has any doubt in these points so let me give you the summary what are the difference between relation algebra and relation and SQL and these are important points so when you are solving relation algebra questions then what you should keep in your mind and when you are solving SQL question what you should keep in your mind okay so what is the first point tell me the difference between relation algebra and SQL relation algebra Works purely on relational model remember this works on pure relational model works on pure relational model yes or no because in the relational model we we don't have duplicate tles we have exactly one primary key in any table we have at least one candidate key yes or no so relation algebra works on pure relation model this SQL this is based on relation model but not exactly okay yes or no is this clear so remember SQL is based on okay this is based on relational model this is based on relational model but not but not I can say but not exactly is this clear this is Loosely I can say Loosely based on relation model okay I can also say that this is Loosely based on relation model so this is based on relation model but not exactly and this works on pure relation model okay this is the first difference what the second difference the second difference is in the relation algebra there are no duplicate Tes there are no duplicate tles okay or I can say you have set of tles but here you have bag of tles here our relation is bag of tles okay what the third the third is there are no null values in the relation algebra we don't have any null values we don't have the concept of null values but here null values might be there null values allowed null values actually matter they are actually important in SQL null values are actually very important okay now what was the four fourth Point must be a key yes or no key is mandatory primary key candidate key okay these things are mandatory but in this okay key may not be there okay I hope all these differences you understood is this clear please tell me very simple one more point about null values see relation algebra has no null values and as has null values why because actually null values these are practical features see relational algebra is theoretical language this is a formal query language this is a theoretical query language this is purely based on Theory but this is practical query language this is commercial query language yes or no this is real world query language and this is theoretical query language so in SQL null values matter in SQL null values they are very important but in relation algebra we don't have null values okay is this clear so remember when you are solving any question of relation algebra then don't consider null values because as I told you there is no concept of null values you can see there is no concept of null in the relation algebra you can see this screenshot from this top university okay now let's move on now let's see SQL basic query how the basic SQL query looks like okay so you can see this is your basic SQL query so we have these keywords in SQL we have select from where okay select here we will write the attributes from here we will write the name of the tables and where here we put the condition okay so let me tell you that this is a basic SQL query the basic SQL query is this the basic SQL query has these keywords okay there is Select keyword this is a keyword select keyword there is from keyword and there is where keyword okay so these are the keywords select from where okay in this from here we write the table names okay basically for example R1 table R1 table R2 table R3 these are the table names okay in the select here we write the attribute names which attribute we want to project okay for example attribute A1 attribute A2 attribute a A3 A4 okay so these are the attributes we want to project and in the where we write the condition we write the condition for tle selection okay so let me tell you one thing this is the this is how the basic SQL query will look like and now few more things actually in SQL this select this keyword is used for projection of attributes okay so let me tell you that this select this is this is used for projection of attributes okay is this clear projection of attributes basically which attributes finally we want in the output in the output which attributes we want so this select keyword is used for projection of attributes okay do you remember in the relational algebra this select this was used for selection of tles yes or no but remember in the SQL query this select keyword is used for projection of attributes means which attributes you want in the output okay this where okay why this where is used this is used for tle selection okay this is used for tle selection okay based on this condition the tles which will satisfy this condition they will be in the output so this is for tle selection okay very simple and this from this is used for cross product means these tables we have to use means you just you just consider the cross product of these tables okay so from this is basically your cross product I can say Okay so this from this is like your cross product that you consider these tables okay is this clear very simple so this is the idea this is basic SQL query this is how it will look like okay so from these tables we are taking these attributes and this is the condition remember for tle selection the tles which will satisfy this condition only they will be in the output and only these attributes will be in the output so this is how the basic SQL query will look like now let me also tell you the conceptual evaluation of basic SQL query so this is your SQL query you have okay this is your SQL query okay you have select select let's assume you are selecting these attributes a comma B these attributes you are selecting from let's assume you are selecting from R Comm s okay maybe T from these tables you are selecting where where some condition is there okay some condition tle selection condition okay some condition some condition is there some condition C is there okay is this clear for example some condition let's assume that condition is like this that where C is greater than 5 okay this condition is there is this clear so where you have C greater than 5 so let me write it where C greater than 5 now let me tell you the conceptual evaluation when you see this query then what actually this will output so let me tell you the conceptual evaluation conceptual meaning conceptual evaluation of this query okay of basic SQL query so the conceptual evaluation is like this okay that first you do the cross product of these tables okay this is the conceptual evaluation that first you do the cross product of these tables so R cross s cross t means every tle of r with every tle of s with every tle of T yes or no the combination of all the tles very simple so first you consider this cross product so this is your first thing first you will consider the cross product then you will apply this condition okay on this cross product on this cross product remember R comma R cross s cross t on this cross product remember you will apply this condition okay it is like this that in the SQL in the relation algebra we use this yes or no for selection of Tes so basically you will apply this condition I can say on this table you will apply this condition this condition you will apply C greater than Z this condition you are going to apply on this table okay only those tles where you have C greater than Z so I can say that R comma R cross s cross T in this you just select those tles where you have C greater than z c greater than 5 Okay C greater than 5 this is the condition now what the third thing the third thing is you will project these attributes okay you will project you will project attributes a comma B only okay now you tell me one more thing SQL treats the table as a bag yes or no duplicate tles are allowed so you tell me one thing in the input table can you have duplicate Tes in the input table in the r comma s comma T in these tables can you have duplicate Tes yes you can have duplicate Tes tell me the output Can it have duplicate Tes the output Can it have duplicate Tes yes it can have duplicate tles okay I told you that SQL query the input is duplicate the input is bag of tles the output is bag of tles so this is the conceptual evaluation of basic SQL query first you will do cross product of these tables then you will apply the tle selection condition and then you will project the attributes a comma B let's see example consider this table so this is your you can see Pro product table the name of this table that is product so this is your product table now you consider this query look at this query this is Select these attributes so remember in the final output we will have these attributes from the product table this is your product table where this is the condition okay this is the tle selection condition where category is equal to gadgets means this category this should be equal to gadgets only only these tles will come in the output okay so finally output will be what very simple remember first you will apply this yes or no the conceptual evaluation what is that the conceptual evaluation is first you will do this okay from this product table from this table we are going to we are going to apply this query on this product table next then the second step is this condition yes or no you will select the tles okay so you can see we will select the tles where category is equal to gadgets so you can see where category is equal to gadgets so these tles are gone okay this tle is gone this tle is gone so finally these two tles will be remaining and remember we are projecting these attributes we are projecting this P name price and manufacturer so finally your output will be this okay for this query this is the final output is this clear please tell me this is the final output is this understood let me know very simple now let's see now consider this query in this query what this star means what this star means this star actually means that we are taking all the attributes okay so remember let me tell you this point that if we want to project all attributes if we want to project all attributes project all attributes if we want to project all attributes then what we can do we can use select star then use select in the select clause in the select Clause you just put a star okay is this clear from RS and where you have condition where there is some condition there is some tle selection condition okay so very simple point that use this this star will simply means all attributes okay very simple so here also you can see that again the same thing from product table this is your product table okay so let me write it this is the product table and from this table you will you will select these tles where category equal to gadgets okay so remember you will select these tles so these two tles will be gone these tles will be gone and finally you are projecting all the attributes so this will be your output we are projecting all the attributes very simple now let's see this find all 18 year 18 year old students okay so now let's write the query write the query to find all 18yearold students so tell me how you will write let me know what will be the query very simple prom so this is your students table remember the name of this table is students table so this is the students table so from this students table we want where age equal to 18 yes or no and we want all the we want all the attributes so it will be select star from students where a equal to 18 yes or no so this will be the answer so you can see from students where a equal to 18 select St now one more thing I want to tell you here okay actually for this query you you will write you will write uh for for this query you can write the SQL query yes or no now let me tell you that you can see this concept students s what this means tell me from students s what this means actually this is also correct for example I can just simply remove this and I can simply do this this is also correct query this is a correct query okay from this is your students table okay where AG equal to 18 select star okay give all the attributes now you can easily see students s what this actually means this simply means that this is like that this table we can refer with this name s okay so let me tell you what this s simply means it simply means this is called alas okay this is called alas or you can call it renaming basically renaming it is basically renaming okay alas or you can call it range variable okay or you can call it range variable these are these are formal names this is range variable or you can call it tle variable or you can call it rename okay all these things are same or you can call it rename renaming so very simple that basically we are renaming this student table as s so we can refer to this table by this tle variable okay you can call it range variable or you can call it tle variable all these are different different names for the same thing you can call it l s you can call it renaming you can call it range variable or you can call it tle variable it simply means what it simply means that this table we can refer by this name s okay very simple so you can see from students s that basically this is your table s s. a is equal to 18 okay select star very simple so this is very intuitive now let's move on tell me the answer for this question find number of tles in the output of both queries two queries are given to you this is Rel algebra query this is SQL query find number of tles in the output of both the queries so what that will be first let me tell you about first let's see this query this is relational algebra query now remember in the relation algebra okay forget about this query for now in the relation algebra this is our relation algebra query right okay yes or no this is relational algebra query so in the relation algebra query we never have duplicate Tes in the input in the output yes or no relation algebra treats the table as set of tles we don't have duplicate tles so when you have relation algebra query see simply you can remove the duplicate tles do we have duplicate tles if there is duplicate tle you can remove it if there is duplicate tle we don't have duplicate tle okay but if there is duplicate tle you can remove it because in the relation algebra our input output basically everything is set of tles okay now let's see from this member table this is the member table we are projecting this pi means projection okay projection of attributes so finally we are projecting GID so your output will be what your output will be GID okay so this will be your output GID there will be DPS okay there will be go there will be ABC you will only have duplicate tles okay you sorry you will only have distinct tles you will never have duplicate tles in the relation algebra query your output will always have distinct tles okay you will have set of tles very simple so that's it yes or no that's it so your answer will be for this query the answer will output will have three tles simple now you tell me about the next query about this this query select G from member from this table from this member table we are projecting G ID okay so duplicates will be removed or not duplicates will not be removed yes or no okay because SQL will have the table as a bag of tles SQL treats the table as a bag of tles so duplicates are allowed duplicate tles are allowed so here you can see the output the output will be GID output will have remember will have all these six tles okay so in the output basically you will have like this DPS gov ABC gov ABC go okay so I can say that output will have six tles simple okay so you can see this is the answer so the answer for this query has three tles this query will have three tles this query will have six tles okay let's move on now now if you want distinct tles then can you do something if I only want distinct tles I don't want duplicates I want distinct tles then SQL gives you a facility SQL gives you this keyword distinct what you can do you can use select distinct okay you can use this select distinct now if you use this select distinct then all the duplicate tles will be removed from the final output from the final out output all the duplicate tles will be removed so remember if you want duplicate if you want distinct tles then use the keyword distinct in the select CLA meaning that only distinct tles should remain in the result is this clear very simple so in the select Clause just use this keyword distinct simple very simple then all the duplicate tles from the final output will be removed okay you can see now in the same table if I use distinct keyword okay for example if I do select distinct select distinct if I use this select distinct okay select distinct GID select distinct GID from from Member table right from Member table okay now you tell me now what will be the final output the output of this query if I run this query select distinct okay remember select distinct what what it will do select distinct it will remove all the duplicate tles from the final output from the last output all the duplicate Tes will be removed okay so from this table from member from member we are projecting G okay we will Project G but we will not have duplicate tles we only we will only have distinct tles okay so we will have DPS gov ABC okay that's it so so we will have only three tles okay the output will have only three tles it will give you three tles only so this is the feature that is given by SQL okay now let me tell you one thing that in the in the SQL tell me can I say we Clause can I say that is mandatory in every SQL query is it mandatory that you have we clause for example look at this query see this query do we have we clause okay in this SQL query from this table we are projecting this attribute so in this SQL query do we have from do we have we Clause we don't have we Clause right so let me tell you this note that in SQL select and from they are mandatory in all SQL queries this is important point that in the select uh in the SQL query these two select comma from they are mandatory without select comma from you cannot write SQL query okay but where Clause is optional now for example look at this query find name and find name and login for all students okay this is your student table then what we are doing here do we need we Clause do we need to filter the tles tell me do we need do we need the wear Clause we don't need wear Clause we just want name and login for all the students name login we just want to project the these two attributes yes or no these two attributes we want to project so very simple this is your answer that from this is your student table okay so from students s again I'm telling you this s this is your tle variable or I can say this is your alas okay alas that this is your student table you can refer this table with the name s okay this is your alas that this is your student table we can refer this table by this alas s okay okay so you can see select as. name as. login very simple now one more important point that is SQL is case insensitive okay tell me in SQL when you write select when you write this select something something then is it mandatory you should write it in capitals no remember you can write select you can write for example you can write like this there is no problem you can write like this s e l e c t okay all these are fine is this clear so SQL is case insensitive so keywords okay remember keywords you can write in upper case lower case doesn't matter okay for example you are from you can write like this also you can write like this also that is fine that is fine okay you can write like this also so everything is fine another thing the table name so these are for keywords yes or no these examples I have given for keywords that keywords are case insensitive but remember the table names are also insensitive for example the table name students okay you can write it students also is this clear you can write it is to like this also you can write is this clear okay similarly the attribute name okay for example if I write as name or maybe age okay the attribute name for example age you can write like this also you can write like this also you can write like this also okay I hope all these points are clear that SQL is case insensitive okay so whether you have for example table name okay you can see this is your table name this is the example for table and this is the example for attribute okay understood now now where is the where is the exception do we have exception okay SQL is case insensitive so remember the uppercase lower case these things don't matter so where is the exception the exception is only with the strings so remember SQL is case insensitive but okay but strings but string name is case sensitive okay the string name that is case sensitive and it is written in in the single quote okay for example if I have a table let's assume this is the table R and in this table in this table let's assume you have S name okay s name now let's assume that s name that is Ram okay let's assume so you can see and so on now here let me tell you that if I want to write for example if I want those tles where s name is Ram okay let's assume here you have for example okay Raju okay here we have Ram okay and so on so now if I want those Tes where you have this s name equal to Ram then what I will do very simple from from this table R okay I want where I want where s name this s name is attribute so tell me does case matters upper case lower case does it matter s name is attribute so here it doesn't matter right okay so s name s name is equal to but here this is a string right yes or no here this is a string so remember we write it in the single quote okay string is written in the single quote so you will write Ram like this okay is this clear please tell me and you will select select star okay so very simple I hope this point is clear so remember string is written in single quote and remember string is case sensitive what this means what this means see string is case sensitive what that means that means like this if I have this and if I write this then how many tles will be there in the output tell me see here you have capital r a m here you have small okay if I write like this then tell me how many tles will be there in the output so the output will have only one tle okay is this clear so very simple SQL is case insensitive the only the only exception is string string is case sensitive okay and it is written in the single quot very simple this is a simple point I hope you understood this so for example look at this example see this is a string right I want those tles where category is equal to gadgets where this attribute category this is equal to gadgets so what I will do you can see this is the attribute name this is the attribute name but this is a string so string is written in the single quote and you can see gadgets gadgets so that is the reason you can see your output will be this I hope this point is clear okay you can see case insensitivity you can read this remember SQL is case insensitive okay all these things you can read so basically upper case lower case letter these things don't matter okay whether you have keyword or or whether you have attribute names relation names alas names of attributes names of relations alas okay all these are case in sensitive as I told you the only exception The Only Exception is that inside the inside the single quot yes or no this is the only exception string inside the single code that is Cas sensitive okay so you can see now let's move on so that's it we have seen the basic query this is our basic query select from where from these tables based on this condition you select the tles okay this is the condition for selection and you project these attributes okay this basic query this is called f sfw sfw yes or no so this is also called sfw query or you can call it spj select project join what is Project here in this entire query which attribute is used for projection in this query which attribute is used for projection for projection this attribute is actually used okay select attribute uh this keyword this keyword is actually used this keyword is used for project then tell me which which which keyword is used for select see this keyword is used for projection of attributes then which keyword is used for select select means selection of tles okay so for that we use where keyword bear keyword for selection of tles simple okay and this join this is your from yes or no this join this is a from from keyword because we are doing the cross product so this is from keyword we use from keyword for join simple okay now so you can easily see that this query this SQL query this is this corresponds to but not exactly equivalent okay so this corresponds to basically first you will do the cross product then you will do the tle selection and then you will project these attributes so this remember this SQL query this is similar to this relation algebra query yes or no this SQL query this is similar to this relation algebra query but can I say they are exactly equivalent can I say they are equalent let me know what is the difference they are not equivalent this query this query they are not equivalent they will give you different they can give you they may or may not give you different result so tell me where is the difference the difference is here we don't have duplicates but here we have duplicates here we can have duplicates yes or no so in the SQL duplicate tles might be there but here we don't have duplicates so remember that is the reason but not really equivalent to they are actually not equivalent because of duplicate tles in the relation algebra we don't have duplicate tles okay so we have seen the basic SQL query this keyword you can use distinct if you want distinct tles okay the conceptual evaluation we have already seen first you will do the cross product of from okay from uh this from list so first you will do the cross product then you will select the tles then you will project the attributes and then you will apply the distinct keyword and you will eliminate the duplicate rows so so this is the conceptual evaluation simple okay let's see this query tell me the tell me how many tles will be there in the final output let me know so these tables are given to us and this is the SQL query how many tles will be there in the final output so here you can see this is your students table remember this is the students table and this is the enrolled table okay now what this query is doing see what is the conceptual Evolution tell me what is the first step of conceptual evaluation how you will evaluate how you will understand this query what the first step the first step is cross product of prom Clause yes so no you will do cross product of these two tables s comma e okay this will be your cross product so you can see step one that is cross product you do the cross product of all tables from the from Clause okay very simple so this is the this is the cross product yes or no this is the first step very simple so first step is done now what the Second Step the second step is after doing this cross product you will apply this tle selection condition yes or no you will select tles so this tles will be selected so you can see step two step two is tle selection make sure that where close is true okay so this tle selection what is the tle selection you can see s do S ID equal to e do S ID and e do grade equal to B so you can see e do grade e do grade must be equal to B yes or no and and there is and E do S ID s do S ID they must be same so only this tle will be selected yes or no only this tle will be selected all the remaining tles will be eliminated okay very simple so finally this is your second step now the third step is you project these two attributes s name and ECI okay so the output will be John's history 105 yes or no so the third step step number three that is you will project The Columns okay so remember s name ECI ID so this will be your final output so your output final output will have only one toule yes or no in the final output there will be only one tle very simple now let's move on now let's solve this question tell me these tables are given to you this is the sers table this is the board table and this is the reserve table now this is the query in the output how many tles will be there let me know tell me one thing will you do the cross product will you do the cross product let me know will you do the cross product no of course not yes or no there is no need to do the cross product okay see see First Step conceptual evoltion first T that is cross product of sellers comma reserves so only these two tables you have to you have to consider only these two tables okay so you will do the cross product actually in the cross product how many Tes will be there in the cross product cross product means every tle combined with every tle okay so total six tles will be there in the cross product yes or no now remember after the cross product you will select the tles yes or no you will do the tle selection so the tle selection condition is given to you that is B ID must be 103 so after doing the cross product you will select the tles where bid equal to 103 so if b equal to 103 then which tle will be gone see you can simply remove this tle sorry you can simply remove this tle because bid must be 103 so you can just simply remove this tle and you can see this is the condition seller S ID Reserve S ID they must be same okay so you can see this row this will match with which row see this will match with actually okay you can see because this this tle is already gone so this will not match with anyone so only the that this this will be this will happen so in the final output only one tle will be there and you want s name so your final output okay the final output will be S name s name that is Bob that's it yes or no only one tle in the output is this clear let me know very is simple Point remember in the conceptual Evolution the first step is you do the cross product but you don't have to do the cross product in the gate exam okay you don't have to do the cross product you can logically understand okay just understand logically that these two tables we are considering okay so just look at these two tables forget about this table yes or no I don't care about this table this B table I don't care so only look at these two tables now this is the tle selection condition that seller Sid equal to reserve Sid and and and B must be 103 see in the cross product you want those tles where B ID equal to 103 so this tle you can simply remove okay yes or no this you can remove so very simple only this tle will be remaining bid equal to 103 and then you will also see that seller Sid equal to reserve Sid so you can see that only this will match this 95 this 95 95 and 103 that's it so only this tle will be there in the output and and finally you are projecting s name so this will be your final output only one toule in the output you can see okay this will be your final output Bob now let's move on now tell me the answer for this question write a SQL query to output table r as it is we want to write SQL query to output table r as it is basically we want to read table R we want to read table R so tell me can I can I give you this in the options let's option A is given to you option A is R is this correct option A that is R is that correct or not option b is from R is this correct option C is Select select a star from R so which is correct let me know remember in the SQL query select comma from they are mandatory I told you I told you that in any SQL query these two keywords they are mandatory they must be there in the every in every SQL query so this is actually correct this is not correct this is not correct in every SQL query select comma from these keywords are mandatory I told you so remember very simple select star from R okay tell me one more thing if I give you this option is this correct select distinct star prom R is this correct no this this is also not correct yes or no this is also not correct because your table your table R it can have duplicate Tes so we want to read table R so we want duplicate Tes yes or no okay but this will remove the duplicate Tes so we want to read table R so this is the answer answer will be option C now let's move on so you can see if you want to read table R reading table R then how to do very simple select a star from user you are reading the table user very simple simple and this star this means all columns we are projecting all the columns I told you where close is optional but select comma from they are mandatory okay now let's move on now consider this query and tell me in the output how many Tes will be there tell me quickly this query on your screen this tables are given to you you can see this is the students table and this is the enrolled table so tell me in the output how many tles will be there so what you will do tell me very simple from students comma enrolled these two tables you have to consider where where there is and here okay there is end here basically in the cross product we want want those tles this is tle selection condition we want those tles where e gr equal to B okay where e do gr equal to B so you can see you can just remove these tles yes or no we want e do gr equal to B this e do grade this must be equal to B so you can simply remove these tles okay only these two tles will be remaining now S ID and E do S ID they must be same so you can see this will match with home 5366 okay so you can see this actually this will match with this they will match yes or no and this will not match with anyone so finally you will only have one tle okay that's it so remember your final output will be this this is the final result you can see on your screen okay the final result will be you can see we are projecting s do name e. CID so your final output will be Jones history 105 this is your output okay so we have seen all these things now SQL one important point do you remember I told you that SQL is declarative and I told you we will revisit that point okay so this is a small point this is a small D2 so an important Point SQL how we understand SQL and how they actually happen see how you understand query and how actually the query is executed they are actually different okay so do you remember I told you SQL is declarative declarative means we will Define we will specify what we want we will not specify the step by step procedure to get the result yes or no I told you SQ is declarative means we don't specify stepbystep procedure to get the result yes or no we just specify what we want we don't give the order of execution we don't specify the order of execution so you you you can see we are saying SQL is declarative not procedural but we are also providing evaluation order yes or no isn't it contradictory see what I'm saying on one side you are saying SQL is declarative okay this is side one you are saying that SQL is declarative declarative means we specify what we want we don't specify how to get the result we don't specify the order of evaluation okay on one side you are saying SQL is declarative on another side you are giving the SQL evaluation order you are also giving the SQL evaluation order do you remember the SQL evaluation order what was that the SQL evalation order first you do the from Clause then you do the where Clause then you do the select Clause yes or no this evaluation order also you are giving so tell me there is a contradiction do you agree with me on one hand you are saying that SQL is declarative on other hand you are giving the execution evaluation order that first you do this then you do this then you do this so tell me is this contradiction or not let me know so where is the mistake either this is wrong either this is wrong one of them is wrong so tell me which is wrong let me know I hope you understood my question yes or no because remember SQ is declarative means we just specify what we want we don't specify we do not specify the stepbystep order of of execution okay in which order to execute we don't specify that but we are you can see we are giving this order of execution so either this is wrong or this is wrong one of them is wrong which is wrong let me know so the answer is actually this is just a conceptual order of evaluation for our understanding this is not how dbms will do dbms will not do like this yes or no the dbm software it will not do like this so remember this is actually correct SQ is declarative this is actually correct and remember this is not a evaluation order please understand this is just con this is not evaluation order this is just a conceptual evaluation order this is just a conceptual evaluation for human understanding for our understanding of query okay is this clear so remember this is just a conceptual evaluation nothing else the dbms will not do like this dbms is not dumb yes or no for example just just see just think about it if if you give this query let's assume there are there is a table R in this table R let's assume you have these attributes and there are let's assume thousand tles okay in this R there are th000 tles just think about it and there is table s in this table s let's assume you have C comma D and here let's assume you have another th000 tles okay or maybe 10,000 T now now consider this query this very simple query we want from from R comma s from these tables we want all attributes select a star okay where where this B is equal to 5 okay this B is equal to 5 b is equal to 5 and let's assume D is greater than 6 okay consider this query now see very simple now you can see easily see that this is your query now you tell me one thing let's assume that in this in this table there are five tles with b equal to 5 okay only five tles with b equal to 5 and in this table only two tles with d greater than 6 yes or no are you getting my point let's assume two tles with d greater than 6 okay see very simple two tles in s with d greater than 6 and let's assume okay let's assume two tles or maybe three tles in r with with b equal to 5 okay now you tell me okay just think about it and tell me is dbms dumb that dbms first it will do the cross product just think about it that dbms is very dumb dbms right yes or no it will be a very dumb dbms if it does like this okay dumb dbms will do like this that first it will do the cross product if you do the cross product how many tles will be there in the output 1,000 multiplied by th 10 10,000 multiplied by th000 yes or no that is 10 to the^ 7 yes or no that is 10 to the^ 7 tles okay yes or no is this clear next what is next next it will do the where close okay yes or no now next it will do Bal to 5 and D greater than 6 and then it will do the projection project all attributes so okay just think about it will dbms do like this dbms will never do like this will never never do like this okay so again I'm telling you this order of evaluation this is just a conceptual order of evaluation for human understanding for our understanding dbms will not do like this remember SQL is a declarative language so in the SQL query we are just specifying what we want what what result what information we want but we do not specify the order of execution okay and so tell me who will decide the order of execution order of execution will be decided by the dbms dbms will decide we don't know we do not know how the dbms will execute there will be a lot of parallelism let me tell you okay actually let me tell you internally what will happen the DM software first it will pass the query okay see when you give this query to the to the dbms when you this query then first the dbms will check whether this is valid or not then what the dbms will do it will convert this SQL query to relation algebra query okay this SQL query will be converted to relation algebra query then relation algebra query will be efficiently optimized okay so remember this SQL query will be converted so let me tell you internally something like this will happen this SQL query okay this will be converted to relational algebra query equivalent equivalent relation algebra query then that will be optimized okay that will be optimized another query another relation algebra query you will get okay then there will be a lot of parallelism okay parall a lot of things will happen Okay so like this like this so very simple Point anyway we don't have to go into this this is not in the syllabus that how the execution will happen Okay so how the execution will happen that is that depends on the dbms dbm internally it will execute okay it is possible that first dbms will do this then dbms will never do the cross product dbms will simply do this so remember a lot of things are there internally dbms can do a lot of things okay so that's it so this is what I'm saying that SQL is declarative SQL is not procedural so this evaluation order that we study that first you do from then you do where then you do select this evaluation order that we study this is not actual evaluation order this is not how dbms will do okay so let me tell you this that this is not how dbms will do dbms will not do like this dbms will not execute like this so if you study any standard book then you will see this word conceptual evaluation now is this clear what this conceptual evaluation means and this is a misconception I have seen many students they they have this misconception that okay this is how the execution will happen but think about it if this is how the execution will happen then why are you calling SQL declarative okay there is some contradiction yes or no very simple point so remember this is just a conceptual evaluation if you study any standard book they will use this word conceptual evaluation but actual evaluation that is very much different dbms will not execute in this order okay this is how we understand we understand the query like this okay so you can see the evaluation of SQL query that we study that is conceptual evaluation not how DBS will do okay not how the query will be ex evaluated by DBS dbms will evaluate the query in very efficient way in a different way in a very efficient way okay you can see this screenshot from the Rak Krishna book you can see conceptual evaluation strategy okay this simply means uh how to evaluate the query for easy to understanding purpose rather than efficient yes or no we we understand the query by this conceptual evaluation but dbms will execute in a different way dbms will execute the query in a very efficient way in a very different way okay so you can easily see there will be a lot of query optimization but that is not in the syllabus so we will not go into that okay one simple point I wanted to tell you I have told you okay now this homework question I want to give will you try this let me know so this is the homework question this query is given to you these two tables are given to you number of tles in the output so this is your homework question one please write your answer in the comments this is your homework number two so please write your answer in the comments okay try to solve these questions and write your answer in the comments for this homework number two the answer is available in the next slide okay I will not show you but answer is available on the next slide so try to solve this question and put your answer in the comment now let's see SQL writing and understanding SQL queries so let me tell you some simple steps to write and understand SQL query if in the gate exam SQL query will be given to you how to understand that so these are the steps look at the given database okay first you look at the given database and you decide which tables you need for the information you want some information for that information which tables you need okay so first you decide that that is your step number one first you decide which tables you need for your required information for your desired information the step number two that is draw the table side by side and think about the idea do the mapping okay and finally implement the idea so let me tell you actually most of the time what will happen see for example if I give you a query like let's assume this query is given to you from this table r s t okay and where this condition is there okay some condition is there right and some attributes you want so when you have this query then let me tell you what you will do first you think about the idea before solving before writing the query before understanding the query first you understand the idea first you write them side by side because anyway you are doing the cross product okay so first you write them side by side this is R this is s this is table T then you decide what condition is given to you for example this type of condition might be given that okay this attribute value should be equal to this attribute value yes or no this attribute value should be equal to this attribute value maybe this attribute value should be greater than this attribute value and in the final output maybe the question is saying that okay final this will be in the output this is projected this is projected in output so very simple so just think about the idea what is the idea okay is this clear right write the table side by side and think about the idea now let's see some examples find the names and ages of all the sellers these are the database this is your database in the database there are three tables okay sailor BS reserves in the seller table you can see this underline what this means tell me this underline what this means S ID this is underline this means this is a primary key so your Sor table Can it have duplicate tles let me know your seller table Can it can it have duplicate tles no it cannot have dup duplicate Tes because there is primary key we are saying that Sid is a primary key so you cannot have duplicate so you can see the this is your database these are the tables okay so now you tell me if I want this information names and ages of all sellers then how many tables I need let me know first to decide which tables you need this is what you decide first which tables you need so you need only one table yes or no I want names and ages names and ages of all sellers so only this table is required okay very simple sellers so very simple from the sellers table from the sellers okay this sellers I can I can give this alas s yes or no this alas S I can give from the seller I will just project yes or no select select s do name and ages yes or no so select s do s name comma as. a simple that's it so this is your query is this clear this is your query so you can see if I run this query on this table then how many tles I will get in the output okay this is your query select I want attributes which attributes I want I want s name I want age these attributes I want from the Sor table okay so tell me if I run this query on this table then how many tles will be there in the output so duplicates will be removed or not let me know duplicates will be removed or not duplicates will not be removed okay so you can see 1 2 3 4 5 6 7 8 9 10 10 tles will be there in the output all the tles basically all the tles will be in the output so I can say output will have 10 tles 10 tles in output okay and only these two attributes will be in the output s name comma is only these two attributes and is there any duplicate tle in the output do we have duplicate tle in the output yes there will be duplicate tle you can see horio 35 horio 35 yes or no this duplicate tle also will be there so that's it so you can see if you use distinct keyword then how many tles will be there in the output so you can see without distinct 10 tles okay without distinct remember without distinct this horio 35 horio 35 duplicate tles will be there without distinct but if you use distinct with distinct with distinct what will happen with distinct this duplicate will be removed so you will have nine tles you can see only one time horio 35 one time let's see this query find all cell with rating above seven how many tables we need first to decide remember step number one step number one is look at the database and you decide which tables you need for your desired information I want sellers I want all sellers with rating above seven so rating I can get here in the seller table so only one one table only seller table we need okay so your query will be this you can see from the seller table where rating is greater than seven remember we want rating greater than 7even so where rating is greater than seven only those tles we want okay and we can use select star yes or no we can simply use select star so either you can do this or you can simply use star select star okay so this is same as basically select star simple okay so this is the query now let's see this find the names of sellers who have reserved bought Number 103 how many tables you need for this information step number one look at the database and you decide which tables you need for this desired information find the names of seller who have reserved Board number 103 okay I want names of seller which table will give me names of seller I want names of seller which table give me names of seller there is only one table which can give me names of seller that is seller table yes or no Sor table next reserved Board number 103 for this information we need Reserve table so only two tables we need seller comma Reserve table now you think about the idea step number one is over now step number two what is that that is the idea you write them side by side see sellers this is your sellers table and this is your reserves table okay what we want let me know what we want see in the reserves table you can see S ID bid day this is the primary key the primary key is Sid bid day that is the primary key so in the in the reserve table you have Sid you have B and there is day and in the salers table you have S ID s name and there are other things okay in the output what you want you want this in output okay so just think about the idea you want this in output and so can I say names of seller who have reserved Board number 103 so can I say this S ID and this S ID must be same for example here you have S ID 102 okay and the name is let's assume Raju now you can see this Sid it is possible this can book many table many book many Bots yes or no okay it is possible that it is possible that 102 can have for example maybe this Bo this board number 101 102 103 okay all these boards yes or no so very simple Point what we want we want that Sid must be same okay so this Sid I can say this Sid and this Sid they must be same they must be equal so only these conditions you and remember B ID must be 103 B ID must be 103 then this s name we want yes or no is this clear please tell me we want s name we want those sellers name who have reserved bought Number 103 so very simple so you can see we will first we will check that S ID must be same that this 102 okay which which BS this 102 has booked this seller which BS this seller has booked maybe different boards this seller has booked okay in the reserve table can I say Sid is the primary key in the reserve table can you have duplication of Sid in the reserve table can you have duplication of Sid yes we can have duplication of Sid because in the reserve table Sid b day this is the primary key this combination is the primary key okay all these three attributes combined that is the primary key okay so you can easily see that for this Sid we will see that boat ID must be 103 and the name this name we will put in the output so finally your query will be this that okay from from sellers okay this alas we can use reserves from these two tables okay where which type of Tes we want we want those tles remember ultimately we want those tles where s dos ID must be same as R.S ID and R.B ID must be equal to 103 then we will select s do s name so this is the query okay is this clear so this is the query now so you can see very simple on your screen you can see this query if you don't want to use alas then can you do if you don't want to use alas then also you can do without alas also you can write from sellers comma reserves seller. Sid equal to reserve. Sid and B ID equal to 103 okay and you project s name so like this let's move on tell me the answer for this question find seller S ID who have reserved at least one bot I want seller Sid who have reserved at least one bot how many tables we need for this query first you tell me how many tables we need I want seller S ID who have reserved at least one board see for this information only one table is enough this table is enough only this table that is enough because in this table see in this table we have Sid we want Sid we have Sid and in this table every Sid has booked at least one bot yes or no because this is the reserve table so in this table every every person in this table has reserved at least one B okay so finally what I can I can do from Reserve table from Reserve table very simple I will simply just select S ID that's it just select S ID this is your query select S ID from reserves that's it this is your SQL query very simple now let's move on now let's see the let's see this find sellers name who have booked at least one bot now which tables we need now which tables we need now we need sellers name this sellers name who can provide sellers name can be provided by only sellers table yes or no and at least one boat who have reserved at least one boat for this information we need these two tables okay these two tables we need very simple and what what condition we have to put see this is your sellers table and this is your Reserve table okay so what condition we which type of tles we are looking for see we are looking for this type of tupple see notice we are looking for this type of tle there is s name this we will put in the output in the output we will put s name so we are looking for this type of tle where this S ID and this S ID they must be same right yes or no if you have one2 you have one2 so they must be same that's it and this s name we will put in the output there is no other condition we don't have any other condition okay yes or no so you can see 1 0 to one2 that's it this is what we have to check that 1 to 10 02 because remember because in this Reserve table everyone in this Reserve table every Sid has booked at least one bot okay very simple so your final query that you already know that from from these two tables okay from sellers table let's call it s from Reserve table let's call it R okay these are the alas now what you need where there is only one condition you have to put that is that s dos ID is equal to R dos ID okay and you will select what you will select you will select s name that's it this is your query is this clear you will select you will project s name now tell me the answer for this find the names of s who have reserved a red bot so tell me how many tables we need names of seller who can give you sellers table yes or no color who can give color board table okay who will give you the color see the color is given by the board table yes or no look color is given by the board table you can easily see you can easily see so Bo table so you need boards table you need seller table and Reserves so you need Reserve table okay so all these tables you need now what is the idea you just think about the idea okay everything else you can easily do see just think about the idea which type of tles you are looking for you need sellers reserves okay and Bs okay all of them you need yes or no so tell me which type of tles you are looking for this is what I want to ask you okay what type of tles are you looking for so let me know for example in the sellers you have S ID and there is s name only these are important in the reserves you have S ID you have B ID in the boards you have B ID you have color okay so tell me which type of tle are you looking for so we want names of those sellers who have reserved a red bot okay so remember we want this in the output we want this in the output where this seller for example this seller 102 this seller 102 remember this seller 102 must reserve a Bo okay this Bo for example okay maybe Bo number Bo number two and this Bo number two has red color yes or no this Bo number two this would have red color is this clear this is the idea so remember these two things must be same very simple these two things they must be same these two things they must be same and this must be red and the output will be S name this type of tle you are looking for yes or no at least one this type of tle must be there do you agree this type of at least one tle must be there this type of tle what you are looking for very simple so you can write the query okay so the query will be from sellers reserves BS from these three okay the condition will be what the the tle selection condition that will be where where seller Sid equal to reserve Sid and and Reserve bid equal to b b ID and Bo color equal to Red okay project s name project s name so you can see this will be your query names of seller who have reserved at least one bought so these three tables you need and this will be the condition seller Sid equal to reserve Sid and Reserve bid equal to b b ID and B color must be red and then you project s name so this is the query very simple let's move on now tell me the answer for this query output of the following query let me know so this is the query you can see from BS comma reserves from these two tables Bo ID equal to uh reserves dob ID and Bo color equal to red and we are doing R.S ID so tell me what is the output seller who have reserved all the red Bots or at least one red bot let me know can I say we are getting sellers who have reserved all red Bots no the answer will be at least one red B okay this will be the final answer yes or no sellers who have reserved at least one red B okay because what will happen see in this query what actually what will happen first you will do the cross product every tle of reserves with every toule of bots yes or no every tle of this table with every tle of this table okay then finally this condition you will apply and do you remember that this condition is applied on every tle yes or no see this condition will be checked for every tle individually okay yes or no this condition checked soorry remember this condition is checked for every tle individually independently okay very simple so finally answer will be sellers who have reserved at least one B what is the answer for this question what is the output of the following query this query is given to you this is the database that you already know okay we will use this database these tables seller bought Reserve okay so this is the query on your screen now you tell me the answer what this query is giving giving you from sellers comma sellers you are using sers table two times sers x sellers y okay alas you can see sellers alas X sellers alas y so this seller table you are using two times where X age is greater than y Ag and you are projecting X name X age so what the answer name and age of youngest seller oldest seller name and age of sellers who are not youngest who are not oldest what is the answer let me know let me know so for this question the answer will be option C not option b the answer will be option C think about the idea think about the idea okay just see when you have this query then always write the idea this is the answer okay let me tell you what the idea tell me on your screen this query is there you just think about the idea do you want to lose to marks in the gate exam because you don't want to take your copy pen you don't want to use your copy pen so you will lose two marks in the gate exam take your copy pen take your copy pen see option b is saying all day Sellers and option C is saying not youngest okay for example first let me clear this point for example okay just think about it let's assume you have these sellers S ID s name is okay so let's assume there is a seller S ID 10 11 12 13 let's assume here the age is 20 here age is 21 here age is 22 here age is 30 so who is youngest and who is not youngest who is oldest so can I say this is oldest these simple simple things I have to tell you okay this is not good okay this is Young this is youngest and these are not youngest yes or no is this clear oldest people can be multiple for example this also can be oldest there can be multiple oldest people all all of them are oldest yes or no these are oldest but you can see all these are not youngest so I hope this point is clear simple okay now you look at this query and think about the idea so tell me side by side I will write the tables how many tables I need side by side I will write the tables saor table alas X seller table alas y two table I will write side by side very simple okay now here you have S ID here you have S name and here you have age these things you have similarly here you have S ID you have S name you have a okay yes or no so here the cross product will happen that you already know okay the cross product will happen correct in the conceptual evalation the cross product will happen after the cross product yeah I can say every tle of every tle of this with every tle of this yes or no you will have every tle of this combined with every tle of this okay finally what you want you want this type of tle you are interested you are interested in this type of tle where X is means this age this value this value must be greater than this value okay is this clear so this type of tle I am interested where this value must be greater than this value greater than okay and remember I want this s name in the output this will be in the output and S ID uh is in the output okay so these two things in the output yes or no so that's it now you tell me so ultimately which uh I can say what we are getting in the output now just see if I give you the saor table okay let's consider the this table seller I'm giving you S ID s name age okay some Tes I'm giving you okay for example I'm giving you like 10 11 12 13 14 okay s name can be anything it anywh doesn't matter okay this can be anything let me just quickly write it a b a c b okay let me write it like this now the age let's assume that age is 20 20 20 1 30 30 okay let's assume these are the ages is this clear okay so now you tell me in the previous query what is happening there will be two copies of the seller table seller X seller y yes or no correct okay so finally in the in the query what is happening that there will be two copies of the seller table you will do seller seller X cross product with seller y cross product with seller y this is what you are going to do okay yes or no seller X cross product with seller y so every tle remember in this tell me how many will be there in this how many will be there in the cross product tell me in the cross product this is your cross product so in the cross product how many tles will be there let me know in this cross product so you can see 5 into 5 there will be 25 tles yes or no remember every tle combined with every tle this tle will be combined with every tle okay this tle will be combined with every tle this tle will be combined with every tle so every tle combined with every tle so in this cross product there will be 25 tles okay is this clear now out of these tles which type of tle are we looking for for example okay just tell me remember we are looking for this type of table where X do a is greater than this should be greater than y do a okay X do a must be greater than y dos so because of this okay tell me for this seller for this seller will we get this type of tle for this seller are we going to get this type of tble where x. AG is greater than y. see this tle will combine with every tle right this tle it will combine with every tle but you can never get for this seller you can never get x x is greater than y is yes or no okay for example whatever you do you combine this with anyone okay this tle you combine with anyone you will see that you will never get x a greater than y is this type of tle you will never get for this seller for this seller also you will not get this type of tle okay but for this for this seller what will happen see for this seller what will happen you can see the age is 21 and this will combine with everyone so so this 21 this will combine with this also yes or no okay finally you can see similarly you can see look at this thir look at this 13 okay this also this 30 this will this this tle will combine with everyone okay so it's like 20 similarly for this 30 okay 21 so anyway the point is that because of at least one tle we are getting these people in the output do you agree because of at least one tle okay so that's it finally in the output these people will go okay these people these people remember these people will go in output okay in the output we will have these people okay these people we will have in the output is this clear let me know so finally I hope you understood the answer so remember for this query on your screen for this query actually output will be what see the output is output is name and ages name and age of those sellers name and age of those sellers who are older than at least one person yes or no can I say who are older who because of this condition okay who are older than who are older than at least one person who are older than at least one person means who are not youngest is this clear please tell me let me know did you understand so finally the answer will be option C I hope this point is clear simple right okay so remember who are older than at least one person who are older than at least one person at least one at least one person so it means they are not youngest so the answer will be option C now let's move on okay this query you can easily write find the colors of BS reserved by Luber how many tables you need if you want to write query for this then tell me how many tables you need we want colors of boots for that we need this BS table okay we want Luber Luber means we want s name s name equal to Luber and reserved so we need these so these three tables we need yes or no all these three tables we need so what is the idea the idea is very simple that the name seller name must be Luber yes or no the idea is this remember this type of tle we are looking for I am looking for this type of tle where s name is Luber okay and this Luber this Luber must Reserve at least one B of at uh I want colors of boards okay there is a board table in which we have colors so remember this color will be in the output yes or no I will put colors in the output because I want colors of bards which are reserved by Luber so this Luber okay the Sid there will be some s yes or no now this Luber must Reserve okay this Luber means this S ID must reserve a boat okay yes or no whichever boat okay whatever boat you have for example let's assume you bat 30 here also 30 okay and finally this color we want okay this color we want in the output so remember these are the conditions you have to put that name must be lber this is the first condition this is the first condition the second condition is this must be same as this they must be equal okay and the third condition and the third condition is that bid they must be equal okay so three conditions are there and in the output we will put colors okay is this clear so very simple so finally your output will be this you can see that s name must be Luber and R.B ID equal to B dobid and S do S ID equal to r. s ID and you will project the color so that's it so these are the SQL queries I hope you understood is this clear let me know did you understand so far everything that we have seen so far did you understand now let's see SQL keywords some more keywords we will see that is Union intersect except these are the keywords okay and these are also very important so let me tell you that we have in the SQL in the SQL these are the key wordss SQL provides some keywords okay and what are those this is a keyword Union another keyword is intersect this is the keyword intersection is not a keyword okay intersect is the keyword so remember these are the keywords okay keywords these are the keywords so you can see Union is a keyword intersect is a keyword and accept is a keyword also let me tell you this accept some people use minus not some people actually Oracle database used by Oracle database Oracle dbms uses this keyword minus but this is more standard a standard SQL keyword okay so very simple so remember these are the keywords this minus is also a keyword which is used by Oracle database okay and other you can see accept now these are the keywords and what what is the purpose what is the purpose of them the purpose the purpose is very simple that this is used for Union let me tell you these Union intersect and accept okay these are actually same as your relational algebra means they are actually set Union let me tell you the the purpose is set Union please understand the purpose is set Union mean duplicates will be removed duplicates will be removed this keyword will remove the duplicates okay is this clear intersect this will do the set intersection basically these keywords will treat the table the input as a set of Tes these keywords they will treat the input table as set of tles and they will produce set of tles there will be no duplicate tles is this clear so that is the reason again I'm telling you that the purpose is set Union set intersection and Set set set difference okay I hope you understood is this clear so very simple so remember these keywords they will remove the duplicates they will treat the table as it doesn't as if it doesn't have duplicates okay so they are they are like I can say set operations they will use the set semantics okay I can say that they will use set semantics this is what I can use set semantics they will use is this clear actually what these keywords will do let me tell you so first of all these are the tables these are the keywords one more thing I want to tell you that if you want to apply these keywords the the query format the query format will be like this query format using these keywords like Union intersect okay how the query will look like what the query format accept okay so tell me one thing can I write like for example R Union s okay can I can I write like this R Union s can I write like this no that is invalid okay why what is the reason tell me why what is the reason the reason is simple that because in the SQL query you must have select comma from okay you cannot do like this actually the query format will be what okay let me tell you the query format the query format using un comma intersect comma accept the query format will be like this that there will be a query here okay you will write some subquery basically there will be a subquery here subquery q1 there will be subquery Q2 okay and you will use here these keywords for example you can use this keyword intersect okay this is the format is this clear please tell me the format is clear this this is your entire query this is your query this is the query okay so in the query there will be subquery q1 intersect subquery Q2 or one more thing if you want to apply Union intersect except then these two must produce the result which is Union compatible do you remember there is something called Union compatible means remember I can easily say this is a note okay to use to use these keywords like Union intersect okay to use Union intersect except if you want to use them then what should happen this would happen that the output of this subquery and the output of this subquery they must be Union compatible yes or no result of subquery q1 and Q2 must be Union compatible must be compatible Union compatible and what that means when we say Union compatible what that actually means Union compatible this means okay two tables when can I say two tables are union compatible so let me write on the next okay what is the definition of union compatible okay see if you have R okay let's assume these are the attributes ABC and if you have S let's assume these are the attributes DF then Union compatible means the number of attributes must be same okay also the domains must be same means okay Union compatible R comma s are union compatible are union compatible these are the conditions the first condition number of attributes must be same three attributes so three attributes okay is this clear number of attributes in R comma s must be same okay and and the second Point what is that remember in this order the domain must be same for example the domain of a comma D must be same the domain of a must be same as domain of D the names can be different no problem the names can be different but domain must be same domain of a must be same as domain of d domain of B must be same as domain of e and domain of C must be same as domain of f okay so this is the union compatibility Union compatibility definition is this clear so very simple very simple thing the query format using these keywords Union intersect except this is the query format okay there will be subquery q1 there will be subquery Q2 and here you will have this keyword intersect or Union or accept so remember this will be the query format and also let me tell you the result of this query and the result of this subquery the result of these two subquery must be Union compatible okay you can see to use these keywords the result of subquery q1 Q2 must be Union compatible okay very simple all these points are very simple so if you want to use these then you can apply them on any two tables which are union compatible means number of attributes must be same and the columns should have same domain in the order the columns taken in the order must have same domain okay so very simple point I hope this point is clear now let's move on so that's it now one more thing I want to tell you I told you that Union intersect and accept they treat your table input also output as set of tles is this clear so remember they will ignore the duplicates in the input is this clear so you can easily see that here you can see the set santic the union accept intersect what they will do they will remove the duplicates from the input table and they will remove the duplicates from the output table is this clear so you can see duplicates are removed are eliminated from the input and duplicates are removed from the output okay or or you can say that they will ignore the duplicates from the input table in the input table all the duplicates they will ignore they will assume that there are no duplicates they will assume there are no duplicates and in the output also there there will be no duplicates is this clear so these three keyword they use set semantics means the input they will consider the input as set of tles and they will consider the output also as set of tles they will produce set of tles and they will assume that input is set of tles okay I hope this point is clear so for example if these are the tables R comma s now let me give you some queries okay tell me the answer for R Union s is this a valid query is this a valid query R Union s this is invalid SQL query okay this is actually invalid SQL query okay this is not valid so what is valid query then the valid query is like this see I can do this so how to write r i want to write r as it is I want to write r as it is so what I will do very simple select from r this is same as R yes or no similarly select star from s this is same as s yes or no this is actually equivalent to R this is actually equivalent to s that you already know okay now you tell me now you tell me so if I do their Union how many tles in the output what will be the output of this so the output tell me the output okay important Point again I'm telling you this Union this uses set semantics right yes or no this Union this will use set semantics so it will assume that your input table has no duplicates okay so from the from the input table just ignore the duplicates see from the input table just ignore the duplicates ignore the duplicates in the input table in the input table ignore the duplicates and the output also will not have duplicates okay so the output will be like this output will be output will be A1 A2 A3 A4 A5 that's it so five tles is is this clear so output will have five tles so remember this Union this will ignore the duplic duplicates ignore duplicates in the input table in the input table ignore the duplicates or I can say first eliminate duplicates from the input table okay very simple ignore duplicates in input tables is this clear so remember first you ignore the duplicates in the input table and in the output also you must not have duplicates okay and remove duplicates from output okay so that's it I hope you understood this now tell me what will happen if I have intersect what what will happen if I have intersect so again the same thing will happen this intersect what it will do it will ignore duplicates in the remember it will ignore duplicates in input table because remember these they will use set semantics yes or no they use set semantics they don't consider duplicate apples okay these keyword they use set semantics so this will ignore the duplicates in the input table and output will also not have duplicates so the output will be what so the output will be very simple okay intersection just do the intersection so that will be A1 A2 that's it so there will be only two tles okay so the output will have only two tles is this clear simple right now what about accept what about accept let me know if I put accept here again it will ignore the duplicates in the input table first you ignore the duplicates in the input table in the input table you remove the duplicates and then in the output don't put duplicates so except means set difference R minus s yes or no basically you are doing R minus s okay so only this tle you will have A3 so there will be only one tle that is A3 is this clear please tell me let me know okay you are doing the set difference R minus s so only A3 tle will be there only one tle in the output I hope all these points are clear now now let's move on now let's see some more SQL keywords that is Union all intersect all accept all okay remember Union all intersect all and accept all what these keywords will do what these keywords are going to do so tell me Union all these are SQL keywords and what is their purpose okay so let me tell you this Union all intersect all accept all these are the keywords and their purpose is what what do you think what is their purpose if you remember Union what this does this does set Union right so what this Union all will do it will do bag Union okay intersect all it will do bag intersection and accept all it will do bag difference okay is this clear so remember this keyword will do bag Union this keyword will do bag intersection this keyword will do bag difference okay very simple point so these are the keywords okay so remember these keywords they use bag semantics they use bag semantics what it means it means that they will they will not ignore the duplicates right yes or no they will not ignore the duplicates and in the output also duplicates might be there it is possible that output can have duplicates they will not ignore the duplicates so remember they will use the bag semantics so you can see see the difference SQL keyword this is a keyword Union this is a keyword Union all what this keyword will do this is used for set Union means this will treat the input as a set and produce set of tles is this clear this keyword will treat the input as a set it will ignore the duplicates from the input and it will produce set of tles Union all this is used for bag Union means it will treat the it will treat the input as a bag and it will produce bag of tles okay similarly intersect this is a keyword intersect all this is a keyword you can see this intersect this will use this is used for set intersection okay this is used for set intersection means this will treat the input as a set and it will produce set of tles intersect all this is used for bag intersection it will treat the input as bag and it will produce bag of tles okay very simple next you can see this is a keyword accept this is another keyword accept all this keyword is used for set difference it will treat the input as set it will ignore the duplicates from the input and it will produce set of tles except all this is used for B difference it will treat the input as bag and it will produce bag of tles okay now let me quickly tell you what is bag Union bag intersection and bag difference how to do Union of two bag how to do Union of intersection of two bags and how to find set difference uh the bag difference the difference of two bags okay so let's see let me tell you this is actually very simple when I say bag Union then just do frequency Union see this is actually very simp simple because in the bag frequency matters do you agree with me in a bag frequency of element matters so when I say bag Union then just do frequency Union and when I say bag intersection then what you will do see these are very simple in a bag frequency matters that you already know so when I do bag intersection then what you will do then you will do frequency intersection then you will do frequency intersection and when I do bag difference then what you will do when I say bag difference then what you will do then you will do frequency difference okay is this clear these are actually very simple concept frequency Union frequency difference frequency intersection okay so let's see this example look at this example I want to do bag Union this is a bag remember okay remember this is a bag okay you can see this is a bag I want to do their bag Union then what will happen you will do frequency Union okay means okay basically you will take everything you will take this one is two times and this one is three times so in the output one will be five times you are doing frequency Union please understand please understand you are doing frequency Union one is two times one is three times so in the output one will be five times two is one time two is one time so in the output two will be two times three is one time so in the output three will be one time okay is this clear simple right agree with me next bag intersection this is a bag this is a bag you will do frequency intersection frequency intersection one is two times one is one time what is frequency intersection this element one is two times here the element one is one time what the frequency intersection frequency common what is frequency common frequency common is one is one time so you can see one will be one time time next two is one time two is one time so frequency intersection two is one time next you can see three is one time three is zero time so you can see here you don't have three so this is bag intersection what is bag difference or I can say bag minus that is frequency difference see this element one is two times this element one is one time so 2 minus 1 frequency difference frequency difference so this one will be one time two one time two one time one 1 - 1 0 3 0 time 3 1 time 3 0 time 3 1 3 0 time 3 1 time so that is minus one so you don't put three okay don't put three is this clear let me know okay in the same question you tell me if I do 1 2 3 minus 1 12 1 now tell me now what will be the Answer 1 2 3 minus 1 12 1 you are doing back difference okay so remember you will only have three that's it nothing else yes or no very simple I hope this point is clear so again I'm telling you that bag Union means frequency Union bag intersection means frequency intersection bag difference means frequency difference so these points are very simple okay now let's quickly see some points okay let me give you some results some quick results so let's assume you have two tables okay let's assume let's assume there is two set R and in this set let's assume there are M copies of elements a there are M copies of element a okay and in this s there are n copies of element a they can be zero right do you agree yes or no so these are the bags remember there is a bag s there is a bag r okay you have bag R and there is a bag s okay so in bag R you have M copies of element a and there are n copies of element a so now now you tell me if you have these then quickly tell me in our bag Union these are bags so you are doing bag Union in our bag Union s how many copies of element a in this R bag Union s how many copies of element a that will be m+ n copies of element a because you will do frequency Union right yes or no copies of element a is this clear simple right very simple result so in in this R bag Union s okay in this there will be M plus n copies of element a you will do frequency Union okay this is called frequency Union you are basically doing frequency Union next what about what about R inter bag intersection I am doing bag intersection remember so in if I do bag intersection s now you tell me in this how many copies of element a tell me how many copies of element a very good you are doing the frequency intersection frequency intersection so that will be whatever is minimum okay minimum of M comma n these many copies of element a yes or no so what is this called This is a frequency intersection you are doing the frequency intersection okay what about the last one if I do r r bag difference R back difference s okay means R minus s now tell me in this how many copies of element a let me know you will do the frequency difference yes or no you will do the frequency difference so M minus n but that can be negative so I can say whatever is Max either zero will be Max Max or M minus n will be Max whatever is Max okay these many copies these many copies of element a these many copies of element a simple right yes or no is this clear because when you do M minus n it can be negative also so that is the reason okay 0 comma M minus n whatever is Max that will be your answer so this is your frequency difference okay you are basically doing frequency frequency minus okay you are doing frequency minus simple this is what you are doing that's it so you can see whatever we have seen that is written here on your on this you can read this okay so that's it now let's see now let's come back to Union all intersect all accept all I told you these keywords they will use the bag semantics yes or no these keywords Union all intersect all accept all they will use the bag semantics Union all it will do the bag Union it will do the bag intersection it will do the bag difference okay now you already understand all these Concepts very easily you can do yes or no so can I give you okay let's see this question in this question if I ask you what is their Union all if I apply Union all then what will be the answer see tell me is this is this a valid query first of all you tell me is this a valid query is this a valid query this is not a valid query but this is only for understanding purpose actually this is not a valid query okay so let me give you like for example let me give you valid query okay see valid query will be something like this okay if I want to do for example R Union S I want to do so what I will do I will do select star from our okay Union all Union all what I will do I will do select star from s yes or no are the union compatible this and this if I want to apply Union all then they must be Union compatible are they Union compatible yes they are union compatible yes or no so this is the this is the query now tell me what will be the output of this query what will be the output of this query you will do Union all means bag Union just do the bag Union okay so how many tles will be there there will be total eight tles is this clear so this is your query this is your query q1 and the output is this is this understood please tell me let me know simple right very simple okay similarly you can do if I do intersect all what will be the output so you can see if I do intersect all then you will do the frequency intersection okay you can see A1 A1 so one time A1 will will be there in the output you can see okay if I do intersect all then this output I will get you can see A2 A2 how many times I will get frequency intersection frequency intersection so A2 I will get only one time A3 zero time A4 0 time A5 zero time so this is intersect all okay next this is your accept all this is accept all because you can easily see in the accept all what will happen 1 - 1 0 2 - 1 so A2 will be there yes or no 1 minus 0 so A3 will be there so this is the answer I hope you understood you can see this let's move on so I told you that these are the SQL keywords Union except intersect these are SQL keywords they use set semantics they will ignore the duplicates in the input and they will not produce duplic in the output and these Union all except all intersect all they use bag semantics so they will do frequency Union frequency intersection frequency difference is this clear let me know please tell me did you understand these six keywords let me know so these keywords will use set semantics they will ignore the duplicates in the input and they will not produce duplicates in the output okay so everything that we have seen everything is written here you can see this is very beautiful slide okay okay see this bag number one and this is bag number two is this a valid query is this a valid query yes this is a valid query basically we are doing Union all bag Union so what will be the output you are doing Union all bag One Union all bag two they are union compatible you can check yes they are union compatible so I can do Union all now the frequency Union will happen Apple two time apple one time so Apple three time okay tell tell me order of tles matter or not let me know order of tles matter or not order of tles doesn't matter yes or no I told you that bag is unordered bag is unordered so unordered tle unordered collection of tles so remember order of tles doesn't matter you can put all the three apples together no problem order of tles does not matter so you can see three apples will be there yes there are three apples next three oranges will be there yes there are three oranges okay here accept all frequency minus 2 - 1 that will be 1 so Apple will be there 1 - 2 so orange will not be there intersect all do the frequency intersection one intersect two so there will be apple one time okay one intersect two there will be orange one time so you can see this let's solve this ugc net August 2016 question consider the following Oracle relations two relations are given given to you this relation has two attributes and these are the tles this relation has two attributes and these are the tles consider two SQL query these two SQL query are given to you this is query number one this is query number two for each of these queries what the cardinality means number of tles in the result obtained when you apply these queries on these instances okay so these queries these two queries we have to apply on these instances and we have to find out how many tles will be there in the output okay so let's see this first of all you tell me what the first query let me know look at query number one what query number one is doing select star from one select star from two accept so basically this query number one what this is doing see this is basically it's it's something like this that from this table from this table you know this table 1 XY from this table you are you are removing this table okay yes or no from this table 1 XY except except this table 2xy okay so tell me this except is this set set difference or is this bag difference this except in the SQL this is set difference yes or no so remember this is set difference what it will do what it will do it will ignore the duplicates in the input and it will not produce duplicates in the output yes or no do you agree this this keyword this will ignore the duplicates in the input and this will not produce duplicates in the output okay what about this one select start from one select start from two accept all so this key this query this is basically it's like 1 XY except all 2xy okay and this accept all this is your bag difference this keyword is used for bag difference okay frequency difference yes or no this will do frequency minus it will do frequency minus okay so now very simple you have these two queries sql1 sql2 so you tell me what sql1 query will give you output and what SQL query 2 will give you output okay here you have accept 1 minus 2 accept here you have this keyword accept and here you have this keyword accept all okay so what this key what this query will actually do it will ignore the duplicates first let me tell you about SQL query 1 okay so you have accept so what it will do it will ignore the duplicates in the input yes or no just ignore the duplicates in the input ignore the duplicates in the input agree yes or no for example you can see 1 16 you can ignore 48 you can ignore okay you can say 255 1 1 so that's it okay now you you just do okay from 1 minus 2 1 minus two so tell me how many tles will be there so you can see you can see this tle will be there in the output yes or no okay so in the output this tle will be there 2 five this tle will be there okay this tle will be there this tle will not be there okay because you are doing minus so this tle will not be there this tle will not be there so that's it so that's it this will be your output okay so remember sq1 this query will produce only one tle output has one tle only one tle will be there in the output that's it very simple what about SQ 2 what about query 2 except all this will do the frequency difference okay what is the frequency of 25 it will do the frequency difference s okay 25 frequency is one and here 25 frequency is 0o so 1 - 0 that is 1 okay so remember the output will have 2 five what else next what the frequency of 16 that is three frequency of 16 that is 2 so6 will come one time 3 - 2 one time yes or no next what the frequency of 48 two times yes or no frequency of 48 that is two times here frequency of 48 two times so zero time that's it okay so there will be two t in sq2 in this query there will be two tles so that's it finally your answer will be for this question answer will be 1 comma 2 respectively answer will be option b so this is a good question yes or no this type of question they can ask you very simple okay did you notice one thing the question is not directly asking you this statement see the question is not directly giving you this statement because this is not a SQL query yes or no from this table minus this table directly the question is not giving you this because this is not a SQL query you have to write like this select star from one that simply means this table one select star from two that simply means this table two similarly here select a star from one that simply means this table and select a star from two that simply means this table okay now let's move on now let's see some SQL queries using Union intercept accept actually let me tell you one thing a lot of tricky questions can be created based on Union intersect and accept and I am taking all the tricky questions all the tricky variations that can be created in the gate exam based on Union intersect except okay so let's start you use your mind uh you use your brain so tell me the answer for this question output of the following query what is that just think about it and tell me just take your copy pen create the diagram create the idea and you tell me the answer output of the following query from these tables seller Reserve bought okay all these three tables we are using where this is the tle selection condition S ID equal to RS ID rbid equal to b b ID and either the color is red or the color is green those sellers names we want okay we are projecting seller name so what is correct output color is red or color is green so name of seller who have reserved green or red bot green and red bot empty table what is the answer so for this question the answer will be option A there is nothing tricky here this is very simple question C what this question is saying just consider the idea okay just create the idea these are the tables seller table is there Reserve table is there and board table is there okay these are the tables now in the Sailor table you have S ID and there is s name remember we want this s name in the output okay next in this here you have S ID you have B ID and in the bo you have B ID and you have color okay and what the question is saying the question is saying that this type of tle we are looking for where where seller Sid equal to reserve Sid means this Sid for example if you have one Z to here you have one Z to here so they must be same okay so this seller is booking rbid b b ID they are same for example if you have 20 here then 20 here they are also same and color must be what this color must be here here in this tle either you must have red or you must have green either you can have red or you you can have green remember in this tle here in this cell either you can have red or you can have green okay these seller names we want seller names in the output so very simple point this type of tle we want where we want the name of sellers who are booking a boat whose color is either red or green yes or no very simple here either you must have red or you must have green simple yes or no is is this clear so very simple that we want name of sellers who have reserved a Bo a red or green boat so the answer will be option A tell me the answer for this question if I do and if I put and here means boat color is red and boat color green so can I say that name of seller who have reserved a red and green boat option A can I say answer is option a name of seller who have reserved a red and green B can I say answer is option A the answer actually will be empty table see just take your copy pen and think about it just create the diagram if you create the diagram you can solve any question any tricky question you can easily solve okay see the question is saying these three tables we are using this is the selection condition and we are projecting s name okay again what you do just create the table side by side if you create the table side by side you will see what is happening here okay you have Sor table where you have S ID and you have S name this s name we want in the output you have reserves table where you have S ID and your B ID and there is a board table where your B ID and there is color okay now the question is saying that we want this type of tles see the question is saying saying tle tle condition is given right this is the tle condition tle selection condition which tle we want tle selection condition so which type of what which type of tle we want so we want this type of tle where seller Sid equal to reserve S ID Reserve bid equal to board B ID means this seller Sid this must be same as Reserve S ID and this B ID this must be same as this B ID this s name we want in the output and and color must be red and color must be green okay means in this tle in this tle in this tle here you must have the color must be red also and the color must be green also is it possible see in this tle in this tle in this cell you must have red also green also is this possible either you will have red or you will have green can you have red and green okay yes or no see very simple that color must be red and color must be green means in this tle you must have red and green here in this cell yes or no here you must have red and green can you can you do that is it possible will you ever get this type of tle tell me in the cross product of these three if you do the cross product of these three will you get this type of tle where you here you have red and green both simultaneously simultaneously no you will never get so empty table yes or no so this type of tle never possible this tle not possible so empty table yes or no so the output will be empty table okay so finally for this question answer will be option C is this clear agree or not so this is a tricky question do you agree with me in the gate exam many many people they can click this okay that reserved a red and a green bot okay many students they will click option A but actually the answer is option C I hope you understood the logic so tell me in the gate exam will you create this type of idea yes always create this type of side by side table and just think about what type of tle you want okay let's see this so what is the correct query then what do you think what is the correct query I want sellers who have reserved red and green B okay those sellers who have reserved a a red b and a green B so what the query then see very simple very simple Point what you will do you will need multiple table yes or no okay remember you will have this type of situation that seller you will have okay now this Reserve see let me tell you what you actually want what you actually want let me tell you then you will understand what I want and what you actually want Bots actually this is what you want that this seller ID this S ID yes or no see this is what we actually want that this S ID this 102 this we want in the output what this 102 should do this 102 what this ID must do this ID must book a must book a boat with red color agree we want those sellers who have booked a red color boat and a green color boat basically those sellers we want who have booked at least two boats one red color boat one green color B yes or no so I want this type of tle where this seller has booked this seller 102 this is booking a boat with red color but I also want I also want that this this seller another Reserve table I will take another Reserve table I will take that this seller okay this same seller remember this same seller 102 this is booking another boat maybe 25 number boat whose color is green I will take another boat table yes or no so remember we need five tables we need is this clear to everyone please tell me now you can see this type of tble I want I want this type of tle where this seller is booking a boat with red color and this seller is booking a boat with green color is this clear let me know please tell me so this is your query this is the idea I hope you understood is this clear let me know so this idea is clear now you can write this query you can see seller table one time Reserve table board table Reserve table board table seller table Reserve table board table Reserve table board table five tables we are taking and this is the query we can write okay you can easily write and you are projecting as name so this is the idea I hope you understood okay so remember they must be same they must be same they must be same this must be red they must be same and and they must be same okay like this so anyway very easily you can do you can easily solve this question so I hope you understood and this is the final query you can read now let's move on tell me the answer for this query for this query can I say this is the output is the following query output correct I'm asking is the following query output correct is this correct output is this correct output think about it and tell me tell me what this is doing okay see there is Union here tell me what this is doing just tell me just simply tell me what this is doing these are names of people who are booking a RedBot names of people who are booking RedBot so these are names of RedBot people seller names seller names booking RedBot yes or no booking a RedBot and these are seller names booking a green board seller names okay and then we are doing the union of them so will it give me seller names who have reserved a red or a green boat sellers who have reserved a red or a a green Bo will it give me yes it will give me there is no problem see very simple what you are doing see first you are you are finding all the red bot people okay remember what we are doing see first we are finding s name of red or those who are booking a red bot okay let's assume these people are booking a red bot let's assume these people a b c a these for different people two different people can have same name yes or no so let's assume these are the red B people these are the redb people okay yes or no then we are doing Union we are doing Union with what union with green board people these are the s name of green board people let's assume the green board people for example okay these are the green board people now very simple so finally I can say these are the green bought people do we want their Union you just tell me this point do we want their Union do we want their Union these are the red Bo people these are the green Bo people do we want their Union very simple point I'm asking name of sailers who have reserved a red boat or a green boat will it give me if I take if I take Union of this and this if I take this Union as is as this is given in the question Union red Bo people Union green Bo people if I take their Union will I get this answer name of seller who have reserved a red boat or a green B yes the answer is correct yes this is correct okay now a simple question I'm asking yes this is correct yes this will give me all seller names all sellers names this will give me all sellers names who reserved who reserved a red or a green B okay okay one simple question I'm asking you please tell me does it matter to you is this B and this B they are same see they can be different seller right does it matter to you that this B and this B they are same seller or different seller does it matter to you does does it matter to you this B and this B they are same seller or different seller does it matter to you does it matter to you that they are same seller or different seller maybe they are different seller with same name or maybe they are same seller does it matter to you it doesn't matter yes or no we want all sellers who reserved red or green board so it doesn't matter whether they are same seller or whether they are different seller it doesn't matter so very simple so finally remember is this query output correct the answer is yes okay this is the correct output remember remember this is the correct output the answer is yes okay now let's see this query is this query output correct if I do intersect of red people green people if I do their intersect will I get name of sellers who have reserved a red and a green bot will I get Common People simple question see very simple let's assume first of all you notice what this query will give you these are RedBot people or not this will give you names of RedBot people yes or no names of RedBot people correct and similarly this query will give you names of green board people yes correct names of green board sellers okay now I am doing their intersect see maybe this type of situation happens see notice see these are the red I got red red B sellers red B sellers names I got them okay let's assume these are the red bot sellers names A B A okay and I am doing their intersect intersect with green board sellers names okay yes or no for example maybe here you have B DB okay maybe this is what you have now you just tell me if I do their intersect see these are the people these are the people who are booking red Bo these are the people who are booking green Bo if I take their intersection I will get those people who are booking red and green yes or no that's correct right so where is the problem see if I take their intersection these are the people who are booking red boat these are the people who are booking Green Boat if I take their intersection I will get the names I okay just take the intersection if you take the intersection then what I will get I will get the names of those people I will get the names of those people who are booking red and green see this is booking red and green this is booking red and green yes or no see see see see this is this person this person is booking red and green this person is booking red and green so finally I got names of those sellers who are booking red and green is this so can I say names of seller who are booking red and green is this correct let me know name of seller who are booking red and green is this correct no there is a problem no there is a problem there is a problem no where is the problem you tell me see the problem is this okay what if C see see see what if this person this person this person what if they are different people three different people having same name so should we have B in the output see assume three different people have same name assume assume three different people have same name this is a different seller different seller different seller they have same name so should we should we put B in the output if I want sellers who are reserving red and green B remember these are sellers these are sellers names who book red and green Bo who book a red and green board okay now you just tell me very simple Point assume these three are different people same name assume these three B okay see this B this B and this B assume three different people same name three different sellers but same name it can happen right three different people same name so we should not have B in the output yes or no do you agree with me we should not have B in the output we must not have B in output but this query will give you B in the output see this query this query will give you B in the output yes or no this intersect this query will give you B in the output but actually name of seller who are reserving red and green Bo according to this according to this B should not be in the output so did you understand that this query is actually wrong let let me know did you understand please tell me very simple point it's like this see it's like this let's assume okay there is a Babu there is a Babu ra here who who is booking a red bot okay and there is another Babu ra from parallel universe who is booking a green Bo okay yes or no they are actually different people they are actually different seller with same name they are actually different sellers okay but their name same they are different seller with same name so actually we should not have baba in the output yes or no okay can I say Babu ra has booked green and red boat can I say can I say Babu ra has booked red and green babua should not be there in the output yes or no babua must not be here this Babu ra will not go in the output right but if you but if you do intersection of these then Babor will be in the output yes or no is this clear did you understand see ideally babau should not be in the output but if you do their intersection baboro will be in the output okay yes or no so ideally versus actually so this is what I'm saying that this query look at this query this is doing intersection red red people name green people name you are doing their intersection so this query does not give you this output I hope you understood so this type of question they can ask you in the gate exam and this is a major I can say uh major mistake prone question right many people many students will make mistake here many students are going to make mistake here can you tell me why the mistake is happening can anyone tell me why the mistake is happening what is the reason for mistake you tell me why the mistake happened why this query where this query failed this query failed I know but where this query failed this query failed because s name this is not a key yes or no very good this is non key this query is failing because two different people can have same name bab ra okay so remember this is a non key this is non key attribute so that is the reason this query is failing if I use S ID will this query fail if I use S ID now will this query fail tell me okay I'm asking in the same query if I use S in the intersect in the intersect if I use S ID here S ID here S ID S ID is of all seller who Reserve red Bots and green boards now will this query pass yes or no now this is a key right now will this query pass the answer is yes is this query correct the answer is yes okay now this query is correct because this is key you cannot have two different seller with same ID we cannot have different seller with same S ID so now this query will pass so all these tricky tricky variations I'm telling you are you understanding let me know remember many gate questions can be created in the future in the future gate exam this type of question can come and a lot of students will make mistake I don't want you to make mistake I want you to understand the logic just understand the logic what is happening okay so far everything is clear now let's see this tell me the answer for this is this query output correct on your screen now we have accept again RedBot people see these are the Sid who are booking red B these are the Sid who are booking green B now can I say if we take accept then we will get S ID of all sellers who are reserving red bot but not green bot now this is correct yes this is a correct okay now you can see this is correct this is correct why see from the redb people from The redb Sid you are removing greenb S ID okay so we will get those sellers who are booking red Bo but not Green Boat okay and you can see this is a key so there is no problem two different sell cannot have same Sid two different seller they cannot have same Sid so this is a correct query yes or no is this clear except from the red SIDS from the red SIDS we are removing green SIDS okay those SIDS we which are booking a red bot from that we are removing those SIDS which are booking a green board so we will get those SIDS we will get those sellers who are booking a red boat but not a green Bo we will get those sellers who are only here who are not here okay so yes this correct this is a correct because remember these are keys this Sid is a key okay is this clear now in the same question if I put s name in the same question if I put s name now tell me is the output correct s name minus s name s name minus s name green s name minus red s name will I get those sellers who are reserving red bot but not green bot the answer is no but tell me why the answer is no see what we are doing we are doing red ass names we are doing red ass names minus green as names okay and remember this is not a key this is not a key so where is the mistake give me a situation where this query will fail give me a situation where this query is going to fail where this query will be failed very simple consider this situation let's assume that you have okay just consider this situation let's assume you have seller okay I'm giving you this situation that you have this Sid S1 and Sid S2 let's assume this person is booking red bot and his name name is Babu ra okay is this clear and this seller this different seller with same name different seller with same name is booking green board okay now you tell me this Babu should be in the output or not the first Babu ra should be an output or not let me know ideally okay ideally what should happen ideally first Baba should be in the output because this babau is booking red B but not green B look at the first bab ra this first Babu ra is booking red B but not green B ideally this s Babu ra S1 okay ideally this Babu ra who S1 S1 Babu ra yes or no ideally Babu because of S1 because of S1 ideally this Babu ra must be an output must be in output because because this Babu ra this first Babu ra is booking a red bot but not a green bot so ideally this would happen but what this query will do but this accept query what this will do will remove B yes or no we'll remove babo okay from from this minus babo minus babo Bab minus bab so Baba will be removed yes or no is this clear so that is the reason I can say that this accept query s name minus s name okay red s name minus green s name this query will not give you your desired result this query will not give you those sellers who are booking a red B but not a green B so this is a wrong query so we have seen all the all the tricky questions we have seen what are the conclusion you will you would like to draw tell me some conclusions can we draw from our analysis some conclusions I want to write what are those the first conclusion the dangerous combinations you tell me about the dangerous combinations where you should take care what are the dangerous combinations tell me let me know the dangerous combinations the dangerous combinations are non key minus non key non key except non key yes or no non key except non key this is a dangerous combination or not you should take care I'm not saying that this will always be wrong yes or no can I say this will always be wrong non key minus non key can I say this will always be wrong I'm not saying I'm saying this is a dangerous combination when you see this type of situation you should take care you should do analysis okay what about non key intersect non key what about non key intersect non key tell me this is also dangerous combination yes or no what about Union is that dangerous if I do Union is that dangerous that is not dangerous right yes or no non key Union non key that is not dangerous this is a not Danger this is not dangerous okay I hope I hope this point is clear and what about key minus key okay not dangerous combinations now I want to tell you not dangerous combinations what are those for example key minus key that is fine key attribute minus key attribute okay key attribute intersection key attribute that is fine key attribute Union key attribute that is also fine okay all these are actually not dangerous combinations so that's it okay so many combinations can be created remember I hope all these points are clear so let's move on now so we have seen we have seen this okay let's move on write SQL query to show only the distinct tles of the input table write SQL query we want only to show we only want to show the distinct Tes of the input table so tell me can I write like this for example if I want only the distinct tles of the input table I want then what I can do the query number one one query I want I can write is distinct I can use distinct yes or no I can use select distinct star PR R yes or no that's it okay select distinct from table that's it very simple can you give me some other creativity can you give me some creativity using intersection using intersection I can do security 2 what I can do I can do intersect or intersect all should I do intersect or should I do intersect all should I do intersect or should I do intersect all select a star from R intersect yes I should do intersect because intersect will remove the duplicates it will remove the duplicates select a star from R so remember this intersect will remove duplicates yes or no it removes duplicates simple so I can do this so this is the query to I can use is this clear so this is another application of intersect you can do intersect can I do Union tell me if I do Union can I do Union Union will also work yes or no Union is also going to work okay so remember you can do Union also so that is also fine you can do Union also you can do that is also fine because Union will also remove the duplicates okay so Union also you can do okay can I do accept accept I cannot do I can do intersect I can do Union these are fine okay so that's it now let's see the next topic that is aggregate operators should we discuss this in the next session or should we continue so let's study SQL aggregate operators this is the next Topic in SQL there are some aggregate operators and let's study them let me tell you one thing for now we will assume that there are no null values in the tables okay this is actually the null values I will discuss I will discuss everything about the null values how to handle the null values but for now we will assume that there are no null values in the table remember we will shortly study about the null values also okay so for now assume that there are there are no null values in the table now let's move on so in SQL there are five aggregate functions these are AVG that is used for average Min n this is used for minimum Max this is used for maximum sum this is used for total and count this is used for count remember these are the keywords average is not a keyword so tell me which is a keyword SQL keyword see AVG is a keyword this is a keyword but average is not a keyword is this clear average is not a keyword so remember these BL these are these are the keywords these are SQL keywords okay and what they will do what these aggregate functions what they actually do what they actually do they summarize right they provide summary they provide summary okay for example if I want to find out what is the average then that is a summary what is minimum what is total sum what is total count so that is a summary so remember aggregate functions they provide summary they summarizes your column your your attribute okay and these are the keyword these are the five and these are very intuitive okay you already understand for example what this minimum will do what this keyword will do it will provide you the minimum it will provide you the maximum value it will provide you the total summation it will provide you the total count and it will provide you average and what is average how to find the average how to find the average that is total total divided by count yes or no total divided by count that is your average very simple so these things are very simple now now let's move on okay let's see the syntax let's see the syntax of these aggregate operators the syntax is like this okay let me tell you the syntax is like this for example this Min okay in the bracket you will write attribute name is this clear this is the syntax here you will write attribute name this is a attribute name okay this is the syntax minan a what this will give you tell me this will give you in this attribute a what are the minimum value yes or no so remember this is the syntax Min a similarly Max a attribute name similarly count a attribute name remember similarly Su a AVG a is this clear and we already understand what they will do okay we naturally understand yes or no they semantic we naturally understand right semantic okay their behavior we naturally understand their name itself is telling you we naturally understand okay so remember this is the syntax now what you can do you can also put if you want you can put distinct also for example if you want summation of distinct value sum distinct you can put distinct also okay distinct a so if you put distinct a then what will happen then you are doing summation of distinct values is this clear if I put for example count distinct a then this will give me count of distinct values of a if I ask you what is average distinct a then this will give me average of distinct values of a okay tell me about this minimum distinct a does it does it change does it matter if I ask you minimum in the distinct values of a will it be same as minimum in the all the values of a yes remember this will be same as minan of a and similarly max if I distinct I can put this is not a error okay don't worry this is not an error I can put you can put no problem you can put distinct but the result will be same as Max of a but here remember these okay they will Ignore the duplicate and calculate yes or no ignore duplicates and calculate ignore duplicates and calculate very simple okay so here we are doing the Su of distinct values of a so remember you ignore the duplicates and then you calculate very simple so this is the syntax I hope you understood now let's see some examples but before that one more thing I want to tell you that is Count star this is a special again I'm telling you don't confuse count star with count of a see we have seen count of a this is different this is different count okay but count star is different this is very special I can say this is a special okay what this count star will do it will always calculate the number of tles it will always calculate count number of tles number of tles in the table that's it okay it will always count number of tles in the table in the table that's it okay is this clear this will always calculate this will always count number of tles in the table also you cannot put distinct with count star for example count distinct star count distinct star this is a this is invalid okay is this clear this is error I can say this is a okay this is error so again I'm telling you very important thing I'm telling you that don't confuse count this don't confuse this count of a and this count is star they are actually very different okay sometimes they can be same sometimes they can be same but when you have null values then they are very different okay is this clear when you have null values don't worry but the point is simple don't confuse them don't mix them never mix them study them separately study this separately study this separately okay this will count the number of is the number of values of a this attribute a and this will count number of Records number of tles in the table okay so don't mix them this is my suggestion don't mix them study separately okay their behavior is also very different when you have null values when you have null values then they they will behave in a different way but anyway so don't mix them study separately and remember this will always whether you have null values whether you don't have null values this will always what it will do okay actually this is very simple this count star this will always count number of tles that's it that's it this will always count number of tles in the table okay so very simple I hope this point is clear now let's see if this is your table then what will be sum of B let's quickly see if I ask you sum of B what that will be that will be 2 + 4 + 2 + 2 okay so the answer will be 10 yes or no very simple sum of B okay now tell me what will be sum of distinct B what will be sum of distinct B what that will be if I ask you sum of distinct B I told you this is this is this we can use this distinct keyword we can use some of distinct B that will be 2 + 4 that will be 6 okay so that is going to be six okay next what about mean of a mean of a is one yes or no minimum of a that is one what is mean of distinct a that is also one okay that is also one that is same as mean of a next what is Max of B that is four Max of B what are the maximum value and what what is Max of distinct B that will also be four that is same as Max of B okay correct next what is count of a that will be four yes or no count of a will be four if I ask you count of distinct a count of distinct a what that will be distinct a count of distinct that will be two okay yes or no very simple what about average of a that will be total divided by count total divided by count yes or no so total divided by four what is average of distinct B distinct a average of distinct a this AVG of distinct a so what you will do very simple remember this is same as sum of distinct a divided by count of distinct a okay is this clear sum of distinct a divided by count of distinct a so remember some this average of distinct a that will be I can say that will be 1 + 3 / 2 so that will be 2 is this clear let me know so 1 + 3 divided by two so very simple okay remember average of distinct a that is sum of distinct a divided by count of distinct a very simple so that's it now let's see this this is the table that is given to you now the question is asking from R from this table select sum a count a Max B Min B average B so what will be the out in this table what is Count star in this table what will be count star count star will be always it will always count number of tles so that's it count star will be four okay count star that is four now let's see this so from R select these are the you can see seel in the select you can see in the select we can put aggregate operators yes or no you can see in the select Clause we can put aggregate functions yes or no so remember your output will be what if you if you if you do this query then output will be this okay output will have these will be the attributes sum a count a Max B okay and so on right you are getting the point so tell me what is sum a sum a that is 1 + 3 + 3 that is 7 okay it will happen like this so you can see this is the tle you will get seven count a count a is three next what is Max B Max B is four okay next what is min B what is min B Min B that is two okay and finally what is average B average B that will be summation divided by total so you can see 3 so that is 9 divided by 3 that is okay so that's it very simple and what will be count star and if I put count star also then what will be count star count star will be three okay so that's it very simple all these points are very simple so we have already seen that you can use this distinct or you can use without distinct okay this will do the counting this will do the summation this will this will do the average minan Max okay now let's see this remember I told you distinct is not allowed with count star yes or no we cannot remember SQL does not allow distinct with count star this I already told you so count star is special yes or no count star is special I told you that count star is special you don't have count distinct star you cannot put distinct star no count star is special very simple okay next you can see you can use distinct with mean and Max remember but it will not change the result you can see it is legal to use distinct with Min and Max even though the result will not change okay so this is another Point very simple now let's move on so whatever we have seen that is written here you can read it okay now let's see this find the average age of all sellers how many tables you need to answer this query how many tables you need tell me I want average age of all the sellers so only one table we need that is sellers table yes or no so very simple from the sellers table from the sellers table what I need I just need so select I need average age of all the sellers I need a AVG average age yes or no AVG of AG that's it so this is your answer okay I want average age of all sellers so that is very simple and that will be AVG of age so like this you can do from sellers s you can use alas okay you can use this alas AVG of s. a so like this you can write let's see this find the average of sellers with rating greater than 10 how many tables you need how many tables you need let me know to answer this question see rating is here rating is here and age is here so only this table we need sellers that's it so the query will be what query will be from sers table from sellers table remember what I want I want only where I will put the where where Clause I will put because with rating greater than seven I only want those people who have rating greater than seven yes or no so where rating is greater than sorry rating of 10 rating is equal to 10 okay yes or no I want those people who have rating equal to 10 of 10 so we rating 10 then very simple here I will put select select average age yes or no AVG age that's it very simple so this is your answer you can see this I will select where close I will only select those tles where rating is equal to 10 average of age AVG age okay now consider this query and tell me is this a valid query in the select Clause can I use S ID comma Max as means I'm using aggregate function I'm also using a attribute can I do this can I do this no this is illegal okay remember this is invalid this is invalid query this is invalid query very simple this is invalid query remember when you have this aggregate in the select Clause when you are using aggregate function then you cannot use unaggregated attribute okay is this clear I will also teach you when when we study this group by Clause then you will see that when you have group by then we can do this okay when you have group by Clause there is a group by Clause so there is a group by Clause when you have group by Clause then you can do this but that we will study after some time okay so don't worry about that for now you just see when there is no Group by remember when there is no Group by then in the select close you cannot use unaggregated attribute when you have aggregate function if you are using aggregate function in the select Clause you cannot use unaggregated attribute okay is this clear so very simple this is the note when there is no Group by remember when there is no Group by then if we are using aggregate function in the select Clause then no unaggregated attribute is allowed unless there is a group by Clause okay unless there is a Group by Clause if there is a group by Clause then it is allowed okay if there is a group by Clause but if there is no Group by Clause then if you are using aggregate function then you cannot use unaggregated attribute okay is this clear so remember this query this is invalid query yes or no remember there is no Group by first of all no Group by you are using aggregate function now you cannot use unaggregated attribute so this is actually in valid query this query you can see this is illegal in SQL okay very simple now let's move on now tell me if I want name of oldest seller then can I can I write this query I want name of oldest seller then can I write this query I want name of oldest seller oldest seller I want then can I write this query that from the seller table where AG is equal to max age where AG is equal to max age so can I say this query is correct this query is not correct why this query is not correct why because where Clause will apply on every tle independently individually I already told you that where Clause this is tle selection condition this will apply on one tle at a time independently indiv individually yes or no tle selection condition tle selection condition applies on one tle at a time tle selection condition applies on one tle at a time at a time individually independently independently is this clear okay see what this query will do notice what this query is going to do consider this query I'm putting age is equal to max age right yes or no see this is my purpose name of oldest seller oldest seller so from the saor table where age is equal to Max H okay we are thinking if you look at this query it looks like correct okay it is looking like a correct query but actually there is a problem what the pro what the problem C okay just consider let assume these are the sellers okay and this is seller name and this is a age now let's assume that that this is seller name a b c d and these are the AIDS 20 21 22 23 now you tell me remember PR seller that is fine this is your seller table okay now where where age is equal to Max a this will apply at one toule at a time okay yes or no remember this will apply one tle at a time okay yes or no tle by tle tle by tle individually independently individually independently individually independently so tell me when you apply this on this tle then what is Max a see when I apply this on this tle then what is Max AE let me know when I apply this query then what is Max age max age of this tle see for this tle age is 20 and for this tle max age is also 20 yes or no for this tle max age is also 20 age is 20 max age is 20 so this tle will be selected this tle will be selected right okay very simple similarly for this age for this age also the same thing this this will be selected because for this tle for this tle Max AG is 21 for this tle max age is 22 for this tle max age is 23 all the Tes will be selected so remember this query will give you what this will this query will give you all sellers names is this clear you will get all sellers names please tell me understood or not let me know because remember this is where this is tle selection condition this tle selection condition will apply to one tle at a time individually independently okay so when you apply this condition on this tle then max age is 20 for this tle this condition will apply on this tle so max is 20 for this tle okay is this clear let me know so actually where is the problem in this query why problem is happening let me know see when you write this query I want age of oldest seller I want age of oldest seller right okay oldest sellers now this is what I want now when I write this query that okay that from sers table from SED table where where age is equal to max age okay select name of oldest seller I want name of oldest seller select s name so where is the problem happening see the problem happening is let me tell you the problem is this actually we want max age of the entire table but we are getting tle wise max age yes or no see this is giving you tle wise max age right yes or no this is giving you tle wise Max AE but actually we want this is not giving us Max a of entire table yes or no not not this is not giving us Max AE of entire table yes or no do you agree with me we want Max a of entire table here yes or no I want Max a of entire table here but this is giving me but this is giving me tle wise Max a okay this is not giving me Max AG of the entire table so what is the solution then tell me what is the solution tell me the solution let me know the solution what is the solution please give me some solution the solution is you something you basically you find here remember remember our purpose is to find Max a of the entire table so you do something you do something and you put a query you put a subquery to find max age of antire table mix a of entire table yes or no just put a subquery to find Max AG of entire table so you remove this I want Max AG of the entire table then what I can do very simple from the entire table from the saor table okay I will select I will find the max a from the S table let me find the max AE let me find Max of a yes or no let me find Max of a from the S table let me find Max of a that's it now I have Max a of the entire table yes or no now I have Max a of the entire s entire table is this clear Max a of the entire table I have but one more question I want to ask what is that one more question what is that see one more question is this that a should be equal to a value is this a value or is this a table is this is this a value or is this a table just tell me is this a value or is this a table this is not a value this is a table yes or no this is a table right do you agree that this is a table this is something like this max age let's assume max age is 50 so this is a table this is not a value this is a table so can I do this that age is equal to table can I do this age is equal to table because this is a table right this is a query this is SQL query this is subquery this will give you a table this will give you this type of table Max is 50 so can I do this age is equal to table the answer is this is allowed because there is a guarantee that you will have one tle see SQL knows remember SQL DB your dbms knows that you are using aggregate function here when you use aggregate function here is there a guarantee of one tle dbms knows that you are using aggregate function inside you are inside you are using aggregate function so there is a guarantee of single tble there is a guarantee of single tble so dbms is thinking because there is a guarantee of single tle single tle you are getting okay no problem let me convert this table into value so please understand in the normal scenario in the normal scenario this query will be invalid okay because age is equal to table okay yes or no you are putting table here age is equal to table so in the normal scenario this will be invalid but because I using this aggregate function here dbms knows that you are putting inside you are putting this aggregate function so there is a guarantee of getting a single tle Okay so no problem this SQL will convert this table into value okay SQL internally internally converts converts this into value is this clear so SQL will internally convert this into a value okay because there is a guarantee of getting a single tle if you don't have aggregate function if I directly put something else then this is illegal then this is invalid because there is aggregate function so dbms knows there is a unique tle there is a single tle so dbms will allow SQL will allow this so SQL will internally convert this into a value is this clear please tell me let me know let me know so I hope this point is clear when we use aggregate function inside this subquery then SQL will internally it will convert into value if you write like this age is equal to this okay so this is allowed okay so remember remember this is fine this solution is perfectly fine let me know is this point clear let me know no single tle and single attribute single attribute single tle okay single attribute single tle see here single single aggregate function single tle there is a guarantee of single aggregate function single tle okay this will give you the guarantee this will give you the guarantee of single tle single tle comma column okay a student is asking can we put two two attribute function uh two aggregate function a student is asking can we put two aggregate function tell me what do you think just use your common sense it's not complicated tell me if I use two agregate function here if I use to aggregate function here then then this will be illegal then this will be invalid okay here you have single tle single column so this is a valid SQL will internally convert into value okay let's move on so we have seen this as I told you that SQL will internally convert into SQL convert such a relation to field value okay so remember this is also correct you can also write like this this is also correct both are correct both the queries are correct okay you can write age is equal to this or you can write this equal to age means it's like this a equal to b or you can write b equal to a both are fine okay so very simple now let's move on if I want to count number of sellers then this is the query very simple from seller select count star this count star will give me number of tles okay very simple so count the number of sellers like this you can count the number of sellers just do count star this will give you number of tles okay so aggregate function we have already seen I told you count star counts the number of rows okay count star will count the number of rows that's it okay so SQL summary this we will continue in the next session I hope you loved this session please tell me in the comments please let me know did you like this session we have covered every important point every every concept every tricky question okay in any Concept in any concept what tricky questions are possible in the gate exam where they can basically uh they can try to you know uh what is the word so they can basically where you can get Negative marks okay where you can make mistake okay so where they can trap you yes trap okay so everything we have discussed okay so please tell me did you like this session and we will continue this SQL complete summary in the next session okay so to be continued okay thank you everyone one very important note I want to tell you that SQL queries that we that we that we execute all these SQL queries these are retrieval queries means you have your database which is stored in the hard drive right yes or no see this this is your hard drive in the hard drive you have your tables your database this is your database now this is your hard drive okay now remember now when you are executing any SQL query okay this SQL retrieval query okay so SF W okay when you execute this query then remember this database will not change this data will not change okay these tables will come in the main memory these table will come in the main memory and here everything will happen your original data will not change remember SQL retrieval queries all these queries that we see select from where okay all these queries all these SQL retrieval queries they will not change your original database your stored database is this clear they will not change your stored database basically these tables will come in the main memory and then then the output will display to you okay so is this clear so remember when I say that Union for example okay you have query here and you have Union here Union here then remember I told you that Union will ignore the duplicates in the input table okay it's not like that Union will go and remove the duplicates from the original database from the stored database from the stored database the union will not remove the duplicates from the store database Union will ignore the ignore the duplicates in the input tables in the main memory okay is this clear so when you apply for example this is your table R this is your table s so from the store database table R comma s will go in the main memory in the main memory okay and there this Union will ignore the duplicates of R comma s is this clear so all the SQL retrieval queries that we study sfw select from where all these SQL retrieval queries that we study they do not change the stored database they never change the stored database okay okay thank you everyone please put a comment