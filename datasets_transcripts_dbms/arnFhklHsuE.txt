hello everyone welcome to the first video of the database fundamentals which is the part of system design uh so what is database database is basically collection of data which is stored or managed in a way that allow easy access manipulation retrieval of data Etc right so in today's video we're going to learn about some of the basic concepts I can write about these Concepts uh what all these which are going to cover in today's video first one is what are the different types of database that we have what are the Core Concepts of database when we talk about Core Concepts first will definitely be asset properties so what are asset properties then the next one will be what is a transaction and what are different concurrency control in addition to the transaction what is a SEMA design how should we design our SEMA when it comes to an interview problem what is normalization and finally what is indexing these are the uh main Core Concepts that we are going to talk about in today and basically in the future videos after that the third one would be the query optimization so in query optimization basically what is the query optimization plan and finally what is SQL no SQL pattern so these are some of the main Concepts that we are going to cover on database fundamentals okay so talking about the first one which are which is the types of database basically we all know that there are three types of database one is relational database then we have uh I can write it here let me take the next one will be non relational or basically no SQL database and finally the third one will be new SQL database so what are these three types of database when we talk about relational database we know that it is nothing but a structure data right which has predefined table rows columns the data types Etc right so it has fixed SEMA structure when it comes to scalability though so talking about scalability since it has a lot of constraint the scalability would be vertically scalable because when it comes let's say there is a table which is relationally um a subset of other parent table when we are going to do horizontal scaling right at that point of time we are not aware how to scale particular table which one to send to different server right so in this way we can't really do horizontal scaling but we have to stick to Vertical scaling so this will uh be vertical scalable then comes to consistency part so what will be the consistency over here since this particular structure data relational data is bided by a lot of constraints so this will definitely be having strong consistency now what is strong consistency when we talk about it what happen is let's say whenever a user or a client makes a request at that point of time first it goes to the leader SEMA or the master table uh database that we know and then once we update or make an insert call to particular leader SEMA before committing that particular transaction it updates or replicates the modified data in all its replica and once all the replication will be done in all the cluster then only it uh it does commit the transaction so this is called as a strong SEMA and this is Avail uh applicable in mostly all the systems which deals with accuracy so be it Financial system or any system which has or which requires accurate data that will have strong consistency or basically relational database um and finally some of the use cases of relational dat database is basically MySQL Oracle and pgsql did you get this much uh let me know in comments if you have any other uh questions coming to no SQL data so again top going with the structured format it doesn't follow any structure database right so when it comes to key value P or the document related database if you want to store document video content or long document storage then this will come into non- relational or no SQL database so it is not structured how about the scalability since this particular database doesn't abide by a lot of constraints we don't have to define a lot of data types so we can actually go and do horizontal scaling how about the consistency again since this doesn't require a lot of constraints this doesn't this particular site of type of database needs to be highly available and we can trade off consistency with availability so we can say that it is highly available and eventual consistency is fine for it now what is does eventual consistency again taking the particular example when a client makes a request at this point of time just updating the later SEMA or the later database without updating all its replications and committing the transaction is called as eventual consistency So eventually it will replicate all the data to uh its subset all the replication database understood and finally talking about the use case so what would be the use case or which sort of database system is following no seal pattern mongodb is the one cassendra is another one and let me know what are the other ones which is following me no no SQL in the comment section the final and the third one is new SQL now what is new SQL when it comes to structure this also follow structure data like the relational database so it also has table it also has columns right how about the scalability now this particular database unlike the relational database follow horizontal scaling now you might be amused or you might be thinking that if it is a structure data how it is going to follow horizontal scaling the answer lies in the sharding pattern so what happens is relation is in relational database when we do sharding the developer manually perform sharding selecting keys on which we have to do Shard right however in new SQL database the system has the ability to automatically Shard the database and thus it leads to horizontal scaling not just this it also have two-phase Commit which will basically uh coordinate with the distributed transaction so that it follows the asset property so how about the consistency again this follows strong consistency because it follows the asset properties like relational database and finally what are some of the examples which uh is built on new SQL database we have one database called is cockro TB which follows the new SQL database okay so this is the type of database we have covered now coming to Core Concepts the first concept that we are going to talk about is nothing but the asset property let's talk about asset property so as the name suggests what does a stand for a stand for atomicity now what is atomicity basically it ensures that a transaction is either completed or committed fully or it gets rolled back or no changes have has been made at all let's take an example that you want to transfer $100 from account a to account B now if while performing this transfer in between the system crashes or some error happens in that case the amount has been deducted from account a how however it hasn't been credited to account B right so in that case we have to make sure that the transaction will get rolled back so the transaction is either completed fully or Nothing what does C stands for C stands for consistency now what does consistency means consistency means it guarantees that a transaction will bring the database from one valid state to another now taking the same example let's say two customers or two people are going to uh deduct account from account uh deduct amount $100 from account a however the amount a has only $100 balance if two account holders will deduct the amount from account a simultaneously at the same time then at that point of time the overall balance will be become minus 100 right however we have the constraint applicable for that particular account as zero the amount should never go below zero at that point of time the system will become inconsistent so we have to make sure that a transaction whenever a transaction happens it move from one valid state to other that is follow all the rules that we have defined got it the third one is isolation before isolation let's talk about consistency so we have already talked about consistency what are the types of consistency one type is a strong consistency I have already told you what does a strong consistency mean right so what does a strong consistency mean that when a request being is being made by a client first the leader will update the data and simultaneously applicate this particular update to all the other applications or the follower database that it has once all the application is successful then only it will commit the transaction and update the client that okay this particular transaction is completed so this is called as strong consistency the second type is eventual consistency what does eventual consistency mean it only update leader and some of the foll so it doesn't update all the followers but only update the leader database and some of the follower database right and then update the client that okay the transaction is completed and in the meantime it will eventually update the rest of the followers now what does I stand for so I stand for isolation and what does isolation mean isolation basically means that it it it basically ensures that concurrent transaction doesn't interfere with each other okay so to simultaneous purchase shouldn't oversell a product in Amazon so this is particularly related to isolation now in isolation also there are different types of isolation so mostly there is four types of isolation what are they first is read uncommitted now what does read uncommitted mean read uncommitted basically allows all the dirty read okay so it allow all the dirty reads now what does dirty reads mean so let's say we have Commit we are about to commit one transaction the transaction hasn't been completed but in between simultaneously read is happening at that point of time if we have updated one row and the user is reading that updated records before completion of of the transaction then it means dirty read so a read uncommitted allow dirty reads to happen second one is read committed unlike read uncommitted this prevent dirty reads so it can the user can only read committed transactions okay it cannot read uh uncommitted transactions however here what happens is here non repeatable reads can happen now what does non repeatable reads mean I'm taking an example okay let's write some codes so we have a transaction let's say begin transaction then we'll select price from products where here broad sorry broad ID is equal to 1 so we are trying to get all the prices from products table where product ID is one we haven't committed this particular transaction but in the same time we have another transaction and what is this transaction doing so basically this is updating the products table we are setting a price where prod ID equals to one sorry I didn't set the price so let's say price equal to 120 okay so now this is updating the product table for the product id1 and now it is setting the price is 120 while this was happening we have uh this particular query was returning a value of 100 let's see and now we have updated from 100 price to 120 and here we have also committed the transaction now let's commit the transaction now this transaction is completed so now the particular price of product one is being set to 120 and now this time we have once again the query is products where prod ID equals 1 and now we are committing the transaction at this point of time now the query will return 120 right so what happens is we have begun one transaction which was returning earlier value of 100 at the same time we have started another new transaction which is updating that particular value from 100 to 120 and now while again executing that particular query since we are selecting the price of that particular row which is prod ID one we are getting this time the updated value as 120 so this is called as non- repeatable read we in for a particular transaction you are getting multiple values so read committed however preventor read it doesn't prevent non-repeatable reads in order to solve this issue we have the next isolation which is called as repeti reads now what are what is repeatable read so it prevents dirty read it prevents non-repeatable read to however the problem over here is Phantom read so this particular uh type of isolation allow Phantom reads now what is phantom read right so basically Phantom read allows a transaction to read set of rows matching a particular condition and at that point of time another transaction whether insert delete or modify a record and affect that result of the first query this is called as Phantom read again and we can take one example let's say we begin a transaction and uh we are selecting count of records from the accounts table where the balance is greater than 5,000 okay now at this point of time we are getting 1,000 records are there we haven't committed above transaction but at the same time another transaction has has been initiated which will insert This Record into the account table with ID in balance and values as 4 and 6,000 not five let's say 6,000 okay and we have Commit the transaction now again will perform the same query we can let's say copy this particular record so we are executing the same query this time this will now give us 1,1 because this particular transaction has already committed and now we are going to hit the commit so this problem is called as Phantom rates wherein the transaction is changing its value because of another transaction okay in order to solve this particular problem of phantom read our final isolation is called as serializable read so this will prevent this is fully isolated and oh sorry this is fully isolated and it will prevent dirty read non-repeatable read and Phantom read okay so these are four types of isolation that we have finally talking about the D so what does d stand for d stands for durability and what is dur durability it ensure that once the transaction is commited it remains persistence even after the system might crash so let's say we have completed the ticket booking for by a couple of customers and after that the syst system crashes at that point of time after the system reboot it should show those two customer has uh the tickets booked for that particular system got it so these are all about the asset properties now what is the next uh next database core concept that we have let's cover transaction also today okay so our next component is is Transaction what is transaction transaction is basically sequence of operations which is treated as single unit to update the database system okay so you can write this as sequence of operation which is treated as a single unit of work it can have multiple select queries insert update queries and once all the operation has been performed then we'll complete a particular unit of work and thus we'll complete the transaction let's write an example of transaction so the first syntax is always begin transaction after that let's update the accounts table wherein will set the balance equal to balance minus 100 where account oops ID equals let's say a okay now let's update the accounts table again and this time the set balance equal to balance my plus 100 let's say plus 100 and we account ID will take this time as B so we are making two update calls okay the transaction hasn't been committed yet so that's all part of one unit of work what to do now U let's let's do that we'll select all uh the records from the account where now balance is less than zero okay if the balance is less than zero then we can roll back else will commit so what we'll do uh let's write a if statement wherein we can select balance from accounts where balance is less than zero if this is the case then will rule back else will commit the transaction so now now this time we have committed the transaction and finally we'll end the if statement so this is our particular transaction wherein we are making two update calls one select query and if all these logic has been performed then we'll commit our transaction moving forward what are the components which are there in a transaction so the first component that we have is a transaction manager now who is a transaction manager or what is the functioning of transaction manager basically it manages the transaction life cycle what are different life cycle of transaction we have active uh active transaction we have committed transaction or we have Ro uh roll back stage so these are the these are the life cycle of transaction basic and transaction manager this manages these transaction life cycle the next one or the next component that we have is lock now lock are basically of two types one is exclusive loog and the second one is shared log now as the name suggests exclusive log is being placed on rows to prevent any concurrent right so whenever we have placed an exclusive log while updating a particular record we have to make sure that no concurrent updates or reads has been made from that exclusive log uh but in shared log it ensure that repeatable reads can happen with the snapshot for a particular transaction uh duration so the if the transaction has been committed earlier we take a snapshot of that transaction and we can show that particular snapshot to the customer or the user are for the shared lock third one is locks or before logs let's take mvcc so what does mvcc stand for mvcc stand for multiversion concurrency control it basically create the database a snapshot to allow the reads without locking so we don't have to lck a particular uh database we can allow the snapshot to be read without locking it and this ensures repeatable read with the same snapshot for a particular transaction duration so what is it it is multiversion concurrency control talking about the fourth component that we have it which is log how many top types of log do we have we have undo log and we have redo log what is the use of undo log can you guess yes as the name suggest it tra CH uh it tracks changes changes for the roll back and case of failure so whenever uh we are making any changes we are logging all the transaction details so that in case of any failure we can roll back the stract changes how about the redo logs as the name suggest the these track the committed changes for recovery after crash so as the system crashes this particular redo logs will help us to make the system up with the committed track so this will particularly commit track committed changes for recovery after the crash now the last component that we have is commit protocol what does commit protocol mean we have something called as write ahead log which is also called as W so here all the changes are get will get logged before applying to the particular database so what happens is on Commit whenever we commit a transaction these logs will get flushed from the disk to ensure durability okay so this is about the commit protocol now we have talked about the components that exist uh in particular transaction right but how about the working how does the transaction work so the first part is the transaction manager will begin the transaction after that the logs will be required for isolation so we have to make sure that we are not allowing dirty reads non-repeatable read reads or Phantom reads within the database system uh if if we want to allow if you want to make the system highly available then that is another case but accuracy is also important right so based on the situation we have to determine that logs are particularly required to ensure the isolation level what is the third step the third step is the updates whatever updates we are making these should get logged to redo or undo uh for atomicity what uh what I mean by this statement is let's say uh whenever we are making any changes first thing is apply log second thing is write logs so that if the system crashes we have undo logs and redo logs for our recovery uh regarding the roll back okay fourth step the changes should be written in the memory disk so it's not just the logs but the changes should also be written in the memory dis so that at later point of time when we want to roll back to previous version we can do that fifth statement the commit protocol ensures that all changes are finalized and logs are persisted once we hit the commit transaction stage at that point time at that point of time it ensures that all changes are finalized and logs are persisted and finally if error occurs we have to undo the log to roll back it to previous version Let let's write it down once again one is transaction manager begin transaction second is the logs are required for isolation what is the third step third step is update the logs what is the fourth step fourth step is changes should be written to memory disk once the changes is made what you want we have to do the commit to make sure that change is persisted and final if error occurs then we have to do roll back using logs so this is the working of transaction I think we have cleared enough uh Concepts in today's call uh in the next video I can cover up the SEMA design normalization indexing and finally the query optimization plans that we have let me know if you guys have any doubt other than that see you later bye-bye