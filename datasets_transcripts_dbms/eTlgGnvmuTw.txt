Hello friends welcome back to another session of tbms today I'm going to discuss B+ trees and how a B+ tree is used in dbms for indexing a B+ tree is a self-balancing MV search tree that maintains sorted order and allows efficient search insert delete and range queries so it is widely used in database indexing and file systems due to efficient disk access patterns so what's the structure of a B+ Tre plus Tre will be having a root node internal node and then a leaf node so a root node can be a leaf node as well and otherwise it acts as an index node to direct surges internal node contains only keys and act as decision points for traversers whether to take the left subtree or the right sub tree so each key in an internal node separates two children sub trees and then Leaf node stores actual data values okay so link together for efficient range searching every leaf node is at the same depth ensuring order of lock in time complexity for operations and internal and leaf nodes internal nodes store only keys and act as navigation pointers and leaf node contains actual data records and then multiv tree okay so each internal node can have up to M children aode can store up to M minus one keys and the b+3 is designed to minimize dis IO operations by reducing the height of the tree the linked Leaf nodes allow fast range queries and Order traversal the operations that you can perform on a B+ tree are search operation insertion operation deletion and range queries search operation takes order of login and then insertion also takes logarithmic time and deletion also takes logarithmic time and range queries take logarithmic time plus order of K so how is the search operation done start from the route and Traverse down using the keys and we compare the keys uh and take the direction where it is greater than or less than the value that we want to search Once at the leaf node perform a binary or linear search for the key and then you also will be retrieving the dis addresses pointing to the full Tuple and then insertion operation so insert in the appropriate Leaf node if the node overflows then we are splitting the node and pushing the mid key which is the median to the top node okay so that's what we'll be doing um so a deletion operation we remove the key from the leaf node and if the node underflows like there will there there is a uh formula or the property of the B+ 3 where there will be a minimum number of keys as well in the node okay so the minimum number of keys will be M by2 seal okay so if it is lesser than the minimum number of keys then we have to borrow a key from the neighbor bring sibling or merge with the sibling and adjust parent pointers so this is for the delete operation and coming to the range queries we start from the first key in the range and follow the linked Leaf notes until the end of the range so this is what we'll be doing for each and every operation on a B+ Tre so these are all the differences between the B Tre and the B+ Tre so coming to the data storage so in B3 the data is stored in the internal nodes and as well as the leaf nodes but coming to the B+ 3 the data is stored only in the leaf nodes okay and the internal nodes will be only like pointers leading to the leaf node and then coming to the leaf node linking so there won't be any linking in the B trees for the in for the leaf notes but in the b+3 the leaf notes will be linked for the faster range query okay and then the range queries are slow in B trees okay because it has to Traverse the entire tree and then it in b plus three it is fast because there is a linked list traversal in the leavs leaf notes all the leaf notes are connected in a linked list okay preferably it is a dou link list so all the notes are connected in a dou link list so search performance is order of log n in B3 and then in the b+3 the search performance is order of log n but more or cash friendly so the real world applications are database indexing so where Oracle us es B+ trees for indexing I have shown this as a lab experiment so if you want I'll be giving you the link of that lab experiment in the iard so you can see that practically how a b+3 is used for indexing an oracle okay so let us see uh how many maximum number of keys and the minimum number of keys of B+ three of order M will be having so for the internal node so the max keys will be M minus one and the minimum key will be seal of M by2 minus1 for the leaf node it will be M minus1 so the max keys will be M minus1 and the minimum keys will be M minus1 by 2 whole seal okay and then for the root node if internal then there will be M minus one and for the root note there won't be any condition for the minimum number of keys it can also have one children and one element in it and so on so for say for example the B+ 3 is of order M which is equal to so order 5 B+ 3 what will be the minimum keys for the internal node so the minimum keys will be two and the minimum keys for the leaf node will be two okay so the maximum keys will be M minus one which is four and the maximum children will be five okay right so I'll be showing you how to construct a b+3 for the following data so this is a sailor table so the salor table is having S ID the name of the Sailor and then the rating and then the age of the s so here you can see this is the Sid Sid is the primary key so these are all the data in the primary key so you can see that the data is unique over here and it is not null so we'll be constructing a B+ Tre for the Sid and U for the primary key Oracle automatically constructs a B+ tree but if you specifically want to create an index for some other uh attributes over here you can also do that as I already told you I have created a video for for creating an index explicit creating explicit indexing uh so you can watch that video and this is where like uh your Oracle itself will create a implicit indexing b+3 for the primary key okay so Sid is the primary key and we'll see how that B+ Tre is constructed so let us create a B+ Tre for the Sailor table where Sid is the primary key in the sailors table and the values in the b+3 will be the SIDS from the sailors table okay so we'll try to create it that way and as you can see like we have the order of the B+ 3 uh m is equal to 5 so what does that mean is that so when you have a B+ Tre of order five it means that you will be having the maximum number of children as five and the maximum number of keys in the node will be M minus one which is four okay so this is the node structure and we'll try to insert the keys into the node okay so the first key is eight so eight is put in the three and then next is 11 11 is checked against 8 8 is lesser than 11 so 11 comes after8 so you just have to see to it that the order inside the node the element order inside the node should be in ascending order okay next element is two two is lesser than 11 and also 8 so we need to insert two here so 2 so 2 8 11 and then we have 24 24 comes as the last element inside the node okay fine so the node is fine but when we try to insert the next element then there will be a problem okay so because that that is a overflow condition so what will be the order of the elements so the order of elements will be 2 6 8 11 and 24 so we'll imagine that we have already inserted the element and now we'll try to find the median okay so the median of this is eight right so we have to split the node and we have to construct the three from bottom to ro okay so the tree always goes from the bottom from the leaf Noe to the okay so now we are splitting so what will happen eight will go onto the top and eight will have the left child which will be having elements as two and six and on the right side like8 will be having 11 and 24 okay not only this we have to remember one of the important b+3 properties which is that all the data will be in the leaf node itself the internal nodes will be like pointers so eight also will be on the right side okay so as You observe that whatever elements will be there on the left side will be lesser than the root and the elements on the right side will be greater than or equal to the root okay so uh and also the root node element also will be included in it so 8 11 and 20 4 will be on the right side so what's the next element so the next element is 16 so where do 16 go 16 is greater than 8 so this is how we are navigating to the lead so 16 is greater than 8 so it comes onto the right side and then it is inserted in ascending order so 16 comes uh here in between 11 and 24 so we have to insert 16 over here so 8 11 16 and 24 will be on the right side the node is fine because the maximum number of keys in the node will be M minus one which is four so there are four elements in the node so the node is good okay so we'll try to insert the next element so the next element is 18 so 18 is greater than 8 right so it comes onto the right side so what will be the order of the element so it will be 8 11 16 and then 18 and then 24 okay so there are five values in the node so which is an overflow condition so since there is a overflow condition what we need to do we need to take the median which is 16 and 16 will go to the root node okay so 16 will go to the root node so let me show you that so what will happen 16 will go onto the root right so on 16 goes onto the root then again it will get a right child so which will be having 16 and also 18 and then 24 so I'll draw it neatly and show it you this is how the leaf notes will look like so we'll take the next element so the next element is 10 so 10 is greater than 8 but less than 16 so it comes onto this particular uh node okay and 10 is inserted in order so since this is greater than 8 and less than 11 so it comes in between so 8 10 and 11 so since the node is having enough element so there is no need to split because there is no overflow condition so the next element is taken so the next element is 12 so where do 12 go so 12 is greater than 8 and less than 16 so 12 comes here in the same node okay so it will be 8 10 11 and 12 so since there can be the maximum number of values in the node can be four so yes this is having four elements so there is no overflow condition so we take the next uh Sid so the next Sid is 40 so 40 is greater than 16 so what what happens it comes onto the this node okay so 40 is inserted here in in order so which is greater than 24 so it is inserted after 24 okay so there is no overflow condition so the tree is good so we'll take the next element which is 36 36 is greater than 16 so it comes into this node so what's the order so the order is 16 18 24 and then we have 36 and then 40 okay so this is is the data that we'll be having in this particular node so since there is a overflow condition because the maximum value should be four but there are five values here so the median is taken so the median is 24 and 24 is taken to the root so what will be there at the root so I'll be having 8 16 and also we'll have one more element which is 24 and then the data is splitted like this okay so I have 24 and then 36 and then 40 or here okay so 24 36 and 40 as the right child of 20 okay right again after this split and moving up of 24 median onto the root we have to check whether this node is having is overflowed or not okay so this node is not overflowing because there can be four elements there are three elements okay this is fine okay right so this is how the B+ 3 looks like so we'll take the next element so the next element is 9 so 9 is greater than 8 and less than 16 so 9 comes over here in this particular part so where a the order will be 8 9 10 11 and 12 so since there is a overflow condition 10 will go on the okay fine so what will happen 10 will come here in order so it will be 8 10 uh 16 and 24 at the root and there is no overflow condition at the root so there can be four elements so four elements will be there at the root so there is no further split needed here at this particular route okay so this is how the B+ Tre looks right now after inserting 9 so we'll try to insert 41 so where do 41 go so 41 will be greater than 24 so it will come onto the right sub tree of 24 so 41 will come here so since there is no overflow condition there can be four elements in the notes so 41 fits in here okay so no more no need of splitting and all that so we'll see what is the next element so the next element is 26 so we'll see where it fits in so 26 is greater than 24 so it comes onto this side so if you just take the order of this so it will be 24 26 36 40 and 41 so this will be the order of the elements in this particular node but since uh there is a overflow condition so 36 is the median so what we need to do just push 36 onto the root okay so 36 will go on to the root like this and 36 will have a right child uh which will be having uh 36 so which will be having 36 and uh 40 and 41 okay so 40 and 41 and uh so we won't be having 36 40 and 41 so we'll be having 26 here okay uh so this is how it has gone onto the root okay so there is a split um in the leap node but if you just observe like the node at the root right now so there is a overflow condition okay there can be Max of four elements in the node but there are five elements in here okay so we need to now split this particular node take the median and then split so what is the median here 16 is the median so 16 will go onto the root and then its left child will be having 8 and 10 and the right child will be having 16 24 and then 36 so this is how the root node looks like so 16 goes onto the top and then it will be having 8 10 as its left node and then 16 24 and 36 as its right node and then these are all the leaf node so this is how it split but as you observe like each and every node will be having the elements in sorted order but how do the data the leaf noes will be stored so say for example 2 is the Sid of a particular sailor so when can I find two okay so first thing is I'll try to see whether two is existing or not yes in the index I found two okay and the navigation to finding whether two is there or not is very easy we'll try to see whether two is less than 16 or greater than 16 so 2 is less than 16 so I'll come on to this direction and then I'll search whether in this particular elements I'll be searching whether 2 is less than 8 or greater than 8 so 2 is less than 8 so I come on to the this side so finally in the leaf node I found two right so what will be there at the leaf node okay so at the leaf node so after finding two now I would like to get like where what is the address okay so the disk address pointing to the full tle I'll be getting here so for two I'll be having some dis address which could be like 0x A1 and so on for six it could be like 0x A2 and so on so what is all this so this is the dis addresses pointing to the full t so when I find two what I'll do is I'll take this address so this is the disk address and I can directly go on the disk and find the Tuple okay and also I can uh also see whether a particular Sid exists or not so say for example I want to know whether 32 is there okay so 32 Sid is there so I'll start at the root not so 32 is greater than 16 so I come in this direction onto the right child and then see whether um uh this is internal note so again I'll compare so uh it is greater than 24 but less than 36 so this pointer I'll be taking I'll be navigating in this direction and then I'll come to the leaf node and see that 32 so 24 is there and 26 is there but there is no 32 here so from this I'll be knowing that Sid 32 do not exist okay so I'll be able to navigate or find out whether the Sailor exists or not and also I'll be able to BU the uh I'll be able to retrieve the tle in a very faster way rather than doing a full table scan I hope you understood B+ R uh if you find this video helpful like share and subscribe and comment thank you for watching