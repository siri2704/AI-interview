hello everyone welcome back to my YouTube channel in this series database management system and today we are going to learn about unit four which is relational database design in this video we will be covering all the following topics which you can see on the screen one by one so without wasting any more further time let's get started so topic functional dependency and its types so without wasting any more further time let's get started with our first topic which is functional dependency and its type functional dependency table student table let this table be r as a relation so let R be relation schema having an attributes A1 A2 A3 and so on so this is A1 A2 A3 A4 let's call that so let attributes X and Y are two subsets of attributes of relation R let's say this is my X attribute and these are my y attribute so if the values of the X component of a tuple uniquely or functionally we can also say determine the values of the Y component then there is a functional dependency from X to Y which means on the basis of x if I can determine the values of Y then it is called as functionally depend dependent so this value is determinant and this value is dependent RO number M it is denoted by this Arrow so role number role number determines name SPI and bl it is referred as Y is functionally dependent on the X or X functionally determines y so we can either say this that X determines y or Y is determined by X both the ways right let's see this with the diagrammatic representation Also let's take an example consider the relation account a account table account number balance and Branch te attributes account number can determine both balance and Branch so x value account number becomes my X and balance and Branch becomes my y so there is a functional dependency from account number to balance and Branch this can be denoted as X determines y so account number determines balance comma branch now let's understand the types of functional dependency full functional dependency and partial functional dependency in a relation in a relation the attribute B is fully functionally dependent on a if B is functionally dependent on a but not on any proper subset of a example is role number semester Department name you it can tell me the SPI we need all three attributes to find the SPI just SPI which is B attribute is fully functionally dependent on all three of them we cannot get the spi's value this is called as full functional dependency a partial dependency the attribute B is partially dependent B is functionally dependent on a as well as on any proper subset of a just enrollment number Department name can determine SPI so this is my B attribute and this is my a so B is determined by a but SPI could also be determined by just enrollment number also so enrollment number is sufficient to find SPI Department name is not really required to find SP so then this is a partial functional dependency now let's understand transitive functional dependency in a relation if attribute a determines B and B determines C then we can also say that a can determine C which means C is transitively depends on a via B for example table subject faculty we have given the subject faculty and the age so example subject determines the faculty and faculty determines the age then we can also say that directly subject can also determine the age therefore as per the rule of transitive dependency subject can determine age should hold that makes sense because if we know the subject name we can know the faculty's age also simple as that let's understand two more types of functional dependency one is Trivial functional dependency next is non-trivial functional dependency in Trivial X which is the determinant and Y which is the dependent is a subset of X which means Y is also a subset of X example is role number Department name semester can determine the role number now role number is also included in this set of X so this is a trivial functional dependency Now non-trivial function dependency exactly opposite Y is not subset of X role number Department name semester determines the student name but student name we can see it's not not there in the set of X so that is non-trivial functional dependency now let's understand the next topic which is Armstrong's exams or inference rules these amstone Exum or inference rules are also the properties of functional dependency these are set of rules used to infer or derive all the functional dependency on relational database rule follow so it will be very easy to find any kind of a functional dependency so the first one is reflexivity if B is a subset of a then we can say that a determines B we have seen this in the trivial type of functional dependency already b a subset here then this is valid function dependency let's understand augmentation if a determines B then we can also say that AC determines BC C is the new variable so if any new variable joined with this we can also say that AC can also determine BC self- determination is simple if a determines a that is also a valid functional dependency next one is transitivity if a determines B and B determine C then we can say that a can determine C we have already seen this in the transitivity type of functional dependency now let's understand the pseudo transitivity if a can determine B and BD can determine C so you can already assume then a d can also determine C like this rule also says it's just that new variable has been added over here decomposition if a determines BC so we can decompose a can determine B also and a can determine C also Union if a determines B and A determine C so together a can determine b c both this is the union rule composition if a determines B and C determines D then AC determines BD AC can determine BD so this was the rule of composition here we composed it here we decomposed it all this inference rules we will be using it further let's understand our next topic which is closure of a set of functional dependency given set F functional dependency there are certain other functional dependencies also that are logically implied logically imped by the rules example f is a relation in which a determines B and B determines C then we can infer that a determines C already with the transitivity rule the set of function dependency that is logically implied by f is called the closure of fically imp from the function depote with f plus so let's understand this more with an example suppose we are given a relation schema R is the relation in which we have attributes a b c g h i and a set of functional dependencies are a determines B A determines C CG determine H CG determine i b determine H so a can determine B and you can see B can determine H so here we can use the transitivity rule a determines b b determines H so we can also say that a determines H transitivity rule so the functional dependency a value logically implied over here let's see the next one next schema a b c g h i these are the attributes function dependency a determines B A determines C CG determines H CG determines i b determines H it's the same example which we have seen in the last one so this is the first pattern which logically got employed so this was the first closure let's see the next one same [Music] example CG can determine H CG can also determine I rle we have CG which can determine H CG which can determine I so we can Union that that CG can determine hi I together a our closure a can determine the value of c and CG can determine the value of I which rule can be applied over here we can apply the pseudo transitivity rule over here a can determine C and CG can determine I so we can also say that that a g can together determine I's value this is my sud transitivity rule let's see the next one we have a determines C so with the augmentation rule we can say AG can determine CG this is also logically implied now AG can determine CG since we have that and CG can determine I we have that over here so over here we can apply the transitivity rule that AG can determine I value also that's the transitivity rule we can apply multiple rules together to find the final closure so we actually found out several closures in this so we can say that f+ equals a determines H we found out CG can determine hi we found that multiple times AG can determine I we found these closures clure as an answer let's compute the closure of the following set of the functional dependency a b c d e f a can determine B's value a can determine C's value CD can determine E's value CD can determine F's value B can determine E's value so let's find out the closure a can determine b and a can determine C we can use a union rule over here that a can determine b c both over here CD can determine e and CD can determine f f again a union rule over here CD can determine both E and F together a can determine B and B can determine e simple transitivity rule we can use over here so a can determine C also a can determine C and CD can determine e pseudo transitivity a d can determine E's value a d can determine together E's value also again over here a can determine C and CD can determine F suo transitivity rule can determine F's value also so the final closure which we get is all these values over here let's see the next example AB can determine c d can determine AC and D can determine e so over here we can use a d composition rule D can determine a so decompose D can determine a also and D can determine C also that's a decomposition Rule and since D can determine AC and D can determine e d can determine AC and D can determine e we can do Union D can determine a c e all three so this is the closure which we get so I hope now you're able to understand closure set more further questions definitely towards the end so you can try and solve that also and if you have any questions or queries let's understand the next closure which is the closure of attribute sets given a set of attributes a the closure of a a under f is the set of attributes that are functionally determined by a under f it is denoted by a+i algorithm to compute a plus the closure of a under F we need to find out so these are the certain steps we will do let's understand this more further with an example so algorithm better so consider the relation R which is a schema a b c g h i these are the attributes for this relation a set of functional dependencies F can be given as a can determine B A can determine C CG can determine H and CG can determine i b can determine H these are the functional dependencies which are given we need to find out the closure of AG so let's see the steps now in the algorithm result equals a while changes to result we can keep on doing changes to the result and we will run a loop over here for each B which deter Min y in the relation F then we will go in the next if B is the subset of the result then we will do the result Union with Y else the result will be equals result and end [Music] example so the first condition here a can be determined B so a is a subset of AG we know that so we can say that result a b g because so we are checking the first condition that a is determining that a is determining b and a is the subset of AG then we can do the union of them function dependencies a determines C so in this this a is also the subset of a b g so we will now do the union of them it becomes a b c g third one CG can determine H CG can determine H now CG is it a subset of abcg yes it is a subset of that so result will include CG also in it next one CG determines I is CG the subset of ABC G yes it is so I will also get included in this B determines H is the B subset of a b c g hi I yes it is so again now I will also new member get added the final result the closure attribute set of ag+ will be a b c g h i let's see the next one given a function dependencies fds for a relation schema a b c d e f is the functional dependencies which has the set of functional dependency a can determine BC value CD can determine E's value B can determine D's value and E can determine A's value so we need to find a closure for a for CD for B for BC and for E so now you need to solve this exercise by yourself and then check your answers with these answers too first to understand what is canonical cover let's understand what is extra near attributes to understand that let us consider there's a relation r with a schema r equal a a b c these are the attributes and there are functional dependencies a can determine C and A can determine C over here so in AB can determine C so then B is the externus attribute now why B is the externus attribute but because if you can see AB can determine C and A alone also can also determine C so B the reason is there is another functional dependency that a can determine C which means when a alone alone can determine C the use of V seems to be unnecessary an extra attribute an attribute of functional dependency is said to be extra if we can remove it without changing the closure of the set of functional dependency AB can determine C and A alone can also determine C we any ways want to determine C so why to use an extra attribute which has no use such attributes are called as extrus attributes now let's understand what is canonical cover a canonical cover of f is a minimal set of functional dependency which is equivalent to F okay having no redundant dependency or redundant part of dependencies dep repeating lot of redundant and duplicate dependencies it is denoted by by FC a canonical cover for f is a set of dependencies FC such that you four conditions satisfy H that F logically implies all dependencies in FC FC logically implies all dependencies in faning no functional dependency in FC contains an extern attribute and each left side of the functional dependency in FC is unique which which means there should be no externus attribute and each of the left side functional dependency has to be unique understand this with an example imagine there is a functional dependency where a can determine b and a can determine C so we can apply a union Rule and make it even shorter and minimal version that a can determine BC both so the algorithm to find the canonical cover is this that we need to repeat and use a union rule to replace any dependent icies in functional dependency where A1 can determine B1 and A1 can determine B2 so we will use a union rule to combine them that A1 can also determine B1 and B2 find a functional dependency where a can determine B with an exous attribute either in a or in B so a note would be that test for exous attributes done using FC and not F star this means over here we need to test and check without the externus attribute does the meaning change or not the closure meaning has to be same until F does not change let's take an example and see more over here that consider the relation schema where R is the relation and a b c are the attributes where the functional dependency would be a can determine b c b can determine C A can determine B and ab can determine C so we need to find a canonical cover and make it a minimal version of it so let's see we can combine a can determine BC and a can determine B over here into a can determine BC because this is again a redundant value we have already the meaning same over here next one a set is a can determine BC B can determine C and ab can determine C now this is the minimal version we have now now a is a external in AB can determine C AB can determine C the a seems to be exterus why check if the result of deleting from Ab determining C is implied by any other dependencies if I remove the a is it implied by any other dependency yes can you see B can determine C so yes in fact B can determine C is already present so set is now a can determine BC and B can determine C minimal version we can decrease this more further C is externus in a can determine BC so let's check if a can determine C is logically implied by a can determine B and any other dependencies yes using the transitivity rule if a can determine B and B can determine C so the canonical cover would be a can determine B and B can determine C this can imply the entire dysfunction dependencies which was given earlier to us so it's a reducing form you can reduce the functional dependencies as much as you can by applying the rules and by removing the externus attributes but the meaning of the closure should not change let's see another example over here the relation are there are attributes A B C D E F and the functional dependencies are like this a can determine BC CD can determine e b can determine d and e can determine a we need to find the canonical cover the left side of each FD in F is unique can you see a is unique c d again is unique we do not have that repeated B is unique e is also unique we don't have that repeated anywhere also none of the attributes in the left side or right side of any of the functional dependencies is externus let's check is there any attribute which is extern a can determine BC can we see is BC or any of that attribute is extern I don't think so because that meaning is not implied by any other functional dependency similarly over here also similarly over here also and here also I don't see any external attributes you can take a moment check by yourself also therefore the canonical cover FC is equal to F so it cannot be reduced any further because all the functional dependencies over here left side is unique we don't seem to find any external attribute also so s a cases function dependency and canonical cover has the same result let's understand the next topic which is decomposition decomposition rule already let's apply them so decomposition is a process of breaking down a given relation into two or more relations [Music] Canon multiple relations say minimal format [Music] Max OPP relation R is replaced by two or more relation in such way that each new relation contains a subset of the attributes of R together they all include all Tes and attributes of R so the types of decomposition which we are going to understand today is lossy decomposition and loss less decomposition let's see what is lossy decomposition a decomposition of a relation R into r R1 and R2 is lossy when the join of R1 and R2 does not yield the same relation as an R let's consider this as relation R this as R1 and this as R2 so when we decompose this relation into two of them the result which comes is this which is not similar to the relation R so in this case we tend to lose some data so that's why it's called as lossy decomposition the is advantage of such kind of recomposition is that some information is lost during retrieval of original relation so from a practical point of you decomposition should not be loss A decomposition right let's understand this now with the second one loss less decomposition consider this as the relation R R1 R2 is relation R R1 and R2 divide here now if you see the difference in this and in this is a lot over here account number and balance table and balance and Bank name table if and if you join both of this the result becomes this where the account number balance and Bank name gives a more number of tles over here however over here account number table balance and Bank name table so now when I join them the result is exactly same so yeah loss lless decomposition this is also referred as nonadditive which means non- loss decomposition and all decompositions must be lossless we should not be able to lose any data or add any more data now let's understand what is anomaly and its different types so what is an anomaly these are the problems that can occur in poorly planned or unnormalized database where all the data are stored in one table there are three types of anomalies that can arise in the database because of redundancy which are insert delete and update redundancy duplicacy again I'm repeating I have said this already but just to remind you guys that redundancy means duplicacy we do not want any kind of duplicacy in our database design so such kind of anomalies happen during insertion deletion or updation let's see how so first one is insert anomaly let's consider this with an example ex Le that there is a relation or a table employee Department in which we have employee ID employee name City Department ID Department name and manager such attributes in this we have already seen that employee ID is the primary key so an insert anomaly occurs when a certain attributes cannot be inserted into the database without the presence of the another attribute for example there is a new Department which has started which is a IT department and we want to insert the data of the IT department however there is no employee assigned to that department yet when we try to insert the data of this department it will not allow as the employee ID is the primary key so it cannot be null it cannot be empty so this kind of problem in a relation where some tle cannot be inserted is known as insert anomaly let's see the delete anomaly so again it's the same relation and employee ID is the primary key a delete anomally exist when a certain attributes are lost because of the deletion of another attribute let's say I want to delete the data of employee J now in this case the data of manager and the department everything gets deleted now consider there is only one employee in some Department it department and employee leaves the organization so we need to delete the tle of that employee but in addition to that information about the department is also deleted this kind of a problem in the relation where deletion of some tles can lead to loss of some other data which is not intended to be removed is known as delete anony now let's see the update anomaly we will use the same table and update anomally exists when one or more record or instance of duplicated data is updated but not all so suppose the manager of CE department has changed this requires that the manager in all the corresponding to that department must be changed to reflect the new status we fail to update all the tles of given Department then two different records of employee working in the same Department might show a different manager and it leads to inconsistency in the database so if you see I want to update the manager of the C department where I put sha and this same is not updated in the other department so the such kind of anomaly is called as up update anomaly how do we deal with such insert delete and update anomaly so the one way is if you see divide this table into two tables one could be the employee table and one could be the department table and we could link them so such type of anomalies in the database design can be solved by using normalization now this is another very very important and a very good concept in database management system so let's understand what is normaliz ization and what are the normal forms which it has so normalization is the process of removing the Redundant data the duplicate data from the tables to improve data Integrity scalability storage efficiency because duplicate data to storage right data integrity means what completeness and accuracy of the data inconsistency dat scalability ability of a system to continue to function well in growing amount of work storage efficiency to be able to store and manage data that consume the least amount of space and what we do in normalization it is a generally a process involves splitting existing table into multiple more than one tables which can be rejoined or linked each time a query is issued like we saw in this example over here how about if I divide this table into two parts our most of the problems and anomalies will be solved in such cases now how many forms of normalization are there and which we are going to study also is 1 NF which is first normal form 2 NF second normal form 3 NF third normal form bcnf which means Boys called normal form 4nf fourth normal form and and the fifth one fnf fifth normal form as we move from 1 NF to 5nf number of tables and complexity will be increasing but the redundancy will be decreasing start with the first normal form which is 1 NN so the conditions for a table to be in first normal form are that each cells of the table should contain a single value it cannot have multi values a relation R is in the first normal form if and only if it does not contain any composite attribute or multivalued attributes or their combination so this is a very very important rule no composite attributes or no multivalued attributes a relation R is in first normal form if an only if all underlying domains contain Atomic values this again says the same thing that each cell will have only single value in it let's see this with an example over here so we have a customer table which has customer ID name and address so in customer relation address is a composite attribute can you see that there is a jam Naga Road Raj code is so address is a composite attribute which is further divided into subattributes like Road and City so customer relation is not in one and F because we can see there are composite attributes over here so the problem will be it is difficult to retrieve the list of customers living in jamnagar City from customer table the reason is that address attribute is a composite attribute which contains Road name as well as the city name it is possible that city name word is also there in the road name over here so in our example Jam nagar word occurs in both records in the first record it is a part of the road name and in the second one it is the part of the city so to overcome that what we could do is divide this address into two more parts like Road and City so each cell will have a atomic which means a unique value in it so the solution we divided the composite attributes into number of sub attributes and insert value in proper sub attribute Road City so you have an exercise to do that you have to convert the below relation into one NF first normal form there is a person ID full name and City it I think it will be very easy for you do solve it and do let me know how was it in the comment section let's see another example over here student table with a role number name and field in subjects all the subjects over here so can you see what is not right in this so in a student relation field in subjects attributes it's a multivalued attribute which can store more than one value so the above relation is not in 1f now we have to make it in one andf it is difficult to retrieve the list of student failed in dbms if I want to find out that which of the students failed in dbms it will be very difficult for me because now over here dbms either dbms at the first place either at the second place so the reason is that the field in subject attribute is multivalued attribute so it contains more than one value so it is very difficult for us to to retrieve any single Atomic value so how do we solve this we divide this field in subjects into another table itself only so student table what we do is role number and name we have put over here except the multivalued in the result table I have given it one more primary key as result ID and I have added role number and subject I have used the primary key of the student table as the foreign key in the result table to link them and the subjects over here so the solution is the first table contains all the attributes except the multivalued attribute that is correct with the same primary key second table contains the multivalued attribute and we have placed the primary key in it as the result ID we have inserted the primary key of the first table as the foreign key in the second table so now this is my one NF form let's see the second one 2 NF now what are the conditions for a table table to be in two NF that it has to be of course in one NF and each table should contain a single primary key so a relation R is in second normal form if and only if it is one andf of course that has to be there and every non primary key attribute is fully dependent on the primary key a relation R is in second normal form if and only if it is in one and F and no any primary key attribute is partially dependent on the primary key so we are trying to say the similar thing over here except the primary key other elements should be dependent on the primary key let's see that so there is a customer table customer ID account number Access date balance Branch name these are the attributes over here but can you see there is one attribute which is not totally dependent on the primary key and we can see over here there are two primary Keys T1 the function dependency one which is customer ID and account number can determine access date balance and Branch name what is function dependent to account number itself alone can also determine the balance and Branch name so balance and Branch name are partially dependent on the primary key which is customer ID Plus account number so the customer relation is not in 2nf how do we solve this problem so for example in case of a joint account multiple or more than one customer have a common account so if an account a01 is operated jointly by two customers say 0 one and 02 like over here then data values for attributes balance and Branch name will be duplicated in two different tles of customers c01 and C02 can you see that it has been duplicated so how do we solve this is we use a decomposition rule over here we decompose the relation in such a way that resultant relations do not have any partial functional dependencies so we remove partial dependent attributes from the relation that violates 2 NF I have decomposed into the table one and table two now account number is one primary key over here and customer ID is another primary key over here account number we are using it as a foreign key over here and we have placed them in a separate relation along with the prime attribute on which they are fully dependent the primary key of a new relation will be the attribute on which it is fully dependent keep the other attributes same as in that table with the same primary key so on the account number balance and Branch name are fully dependent same over here the access date and the account number is fully dependent on the customer ID 3 andf the third normal form of course the condition over here is it has to be in 2 NF which means by default it will be in one one NF also and there is no transitive dependency transitive dependency a is dependent on B and B is dependent on C then indirectly a is also dependent on C so that should not be there a relation R is the in third normal form if and only if it is in 2 andf and every non-key attribute is non-transitivity dependent on the primary key we can also say that no any non-key attribute is transitively dependent on the primary key let's take an example over here we have a customer table which has account number balance Branch name and the branch address over here so the functional dependency one we can see that account number is determining balance Branch name and Branch address what is the functional dependency 2 that Branch name can determine the branch address so account number can determine the branch address also using the transitivity rule so Branch address is transitive dependent on the primary key account number so customer relation is not in 3nf so the problem will be in this relation Branch address will be stored repeatedly for each account of the same branch which occupies more space so account number one branch name is same however the branch address over here is repeated again Branch name is also repeated again so this creates a redundancy so how do we solve this we decompose the relation in such a way that the resultant relations do not have any transitive functional dependency I have divided into the table one and table two table one will have only Branch name and Branch address Branch name as the primary key and table two will have only the details of account number balance and Branch name so we remove the transitive dependent attributes from the relation that violates the three andf we place them in a new relation along with the non-prime attributes due to which transitive dependency was occurring so the primary key of a new relation will be non Prime attributes due to which transitive dependency has been occurred so we keep the other attributes same in the table with the same primary key and add Prime attributes of other relation into as a foreign key so the primary key of the table one which is the branch name has been given in this table as the foreign key Branch name so this both the tables could be linked and there is no transitive dependency over here let's see the next one bcnf Bo called normal form now the conditions for that should be that bcnf is based on the concept of determinant who is the determinant a account number is the determinant and balance and Branch are the dependent so the left side attribute will be a determinant condition for bcnf that it has to be in three andf and every determinant should be a primary key a relation R is in bcnf if and only if it is in 3 NF and for every function dependency that X can determine y x should be the primary key this is the major Rule and we can say that in many different ways that every Prime key attribute is non-tr transitively dependent on the primary key or no any Prime key attribute is transitively dependent on the primary key let's understand this more with an example over here student table we have a role number we have a subject and we have a faculty three attributes so what is my first function dependency that role number and subject both can determine the faculty what is the functional dependency two that the faculty can determine the subject so we can say that the role number and subject can determine the subject that is a transitivity rule so in function dependency to determinant is what is the faculty this which is not a primary key so student table is not in bcnf so the problem will be in this relation one student can learn more than one subject with the different faculties then record will be stored repeatedly for each student language fac faculty combination which occupies a more space over here if you see dbms dbms are more number of times and same way the faculty is the faculty data is also getting repeated over here so here one faculty teaches only one subject but a subject may be taught by more than one faculty so a student can learn a subject from only one faculty let's see how we can solve this the solution would be we decompose a relation in such a way the resultant relations do not have any transitive functional dependency so we remove transitive dependent Prime attribute from relation that violates bcnf so we have removed the faculty and put it in a separate table place them in a separate new relation along with the non-prime attribute due to which transitive dependency occurred which was RO number the primary key of a new relation will be this non-prime attribute due to which transitive depend dependency occurred in this table The Faculty has become our primary key over here due to which the transitive dependency was occurring and we keep the other attributes same as in that table with same primary key and add a prime attribute of other relation into as a foreign key so over here the subject becomes the foreign key so faculty which is a primary key of the table one is also the foreign key in the table two and this was the attributes due to which the transitive the transitive dependency was occuring let's see now the multivalue dependency so for a dependency X can determine y if for a single value X multiple values of Y exist multiple values of Y is there then the table may have multivalue dependency how do we understand that there a student table and there's a student role number 101 who is studying DS dbms DS dbms subjects and so the Redundant data has been repeated so multiv Val dependency is denoted by double lines and multivalue dependency is represented by X dependent on y with the double lines over here because it is a multivalued now let's understand the next one which is a 4nf fourth normal form the conditions for this will be the relation has to be in B C and F and it cannot have multivalue dependencies like we saw in the previous table there are multivalue dependencies over here so let's see the student table over here the same one one1 role number it has a multivalued subjects and multivalued faculty we can divide this and decompose this into two tables the subject and faculty separately so the above student table has multivalued dependency so the student table is not in 4nf how we can make it in 4nf by by decomposing it into a two Separate Tables over here so a table can have both functional dependencies as well as multivalue dependencies together role number can determine the address role number can determine the subject which is multivalued that's why I have put the double arrows RO number canine faculty also again Double Arrow because it is a multivalued now how do we solve this for subject we have used role number and the subject as a SE separate table for the faculty I have again used the role number and the faculty attribute and for the address role number and the address attribute so like this each table has a separate data and are linked by role number as a foreign key let's understand now 5nf which is a fifth normal form the condition would be the first foremost we already know that it has to be in 4nf it cannot have lossless decomposition into any number of smaller tables so which means student result relation is further decomposed into a sub relation so the above relation is not in 5n F this table can be further decomposed into sub relations we have already seen that and we can do that the result ID role number result could be one table the role number name and subject could be another table so it could be further decomposed so this is not in five andf if there are any lossless decompositions how we can solve this that we decompose it more further let's see how student table role number and name the subject table subject ID and the name of the student and the result table with the result ID role number subject ID and the result now can this table be further decomposed I don't think so so that's why now this is in fifth normal form let's start with the next topic before I move on to the next topic let's revise all the normal form once and summarize them rule normal forms apply that to be in the next normal form it is important that it is already in the previous normal form so there was one NF just first rule would be it cannot have composite or multivalue attributes which is no 2 NF it has to be in 1 NF and it should have only one primary key for 3 NF it has to be in NF and it cannot have transitive dependency bcnf determinant has to be primary key for NF no multivalue dependencies and five and n f it cannot have lossless decomposition so this is in summary the rules which you should remember that one and F no composite and N attributes two and F only one primary key three and F it cannot have transitive dependency bcnf the determined has to be primary key 4 and F no multivalue dependencies and five and F lossless decomposition should not be there now let's start with our next topic which is how to find a key let me just quickly remove this okay now the conditions to find a key the attribute is a part of a key if it does not occur on any side of functional dependencies second one the attribute is a part of a key if it occurs on the left hand side of the functional independ but never occurs on the right hand side attribute is not a part of a key if it occurs on the right hand side of the functional dependency but never occurs on the left hand side then it is not a key the attribute may be a part of a key or not if it occurs on both the side of the functional dependencies conditions then we will know how to find a key let's understand this with more an example let a relation r with attributes a b c d with functional dependency C can determine a b can determine C we need to find the keys for relation R so attribute not occur on any side of fds so this is correct because s d is not occurring on any side of the functional dependency attribute occurs on only left hand side of the function dependencies yes we can see B is appearing only on the left hand side of the functional dependency attribute occurs only on right hand side of the functional depend dependencies yes a can occur on right hand side of the functional dependencies so this condition says it cannot be a key however attribute occurs on both side of functional dependencies which is c c is occurring on the is occurring on the left hand side and on the right hand side also so the core is the two conditions which is correct which is D and B so B determines C and C determines a so using the transitivity rule B can determine a also so so BD is the key over here as these two attributes are the correct ones so these are our keys let's understand with the next example let a relation r with attributes a b c d function dependencies C determines d c determines A and B determines C we need to find the keys for the relation so the core is B Because if you can see over here B can determine C and C can determine A and D both so therefore B is the key next relation a b c d with the functional dependency b b is B is determining c d is determining a we need to find the keys of the relation the core is b d over here because B can determine C and D can determine A and D can determine a so BD is the key next one relation r with attributes a b c d function dependencies a B BC can determine d and a can determine C we need to find the keys I want you to try this first by yourself and then look at the answer over here if you can see the core is going to be a q because a can determine B over here and C can determine D so a is a key the foure is a because a can determine B and C can determine D and A can also determine C so the core is a a is our key example we need to find a candidate key again a key and we need to check for the normal forms over here suppose we have given a relation r with four attributes a b c d for each of the following set we have function dependency B can determine C and D can determine a we need to identify the candidate key and also the best normal normal form which it satisfies 1 NF 2 NF 3 NF or bcnf so the cand candidate key over here we can see B can determine c d can determine a so the candidate key will be b d so relation R is in 1 and F but not in 2 and F why in above function dependency there is a partial dependency how we can understand that because B can determine C and C depends only on B but the key is BD so the C is partially dependent on key BD also same way in the function dependency D can determine a a depends only on D but the key is BD so a is partially dependent on key BD also the functional dependency over here is c can determine d c can determine A and B can determine C what will be the candidate key over here the candidate key over here is only B because as you can see the left hand side element the left hand side attribute is again getting repeated and B is the only one which is not getting repeated over here we need to to identify the best normal form the relation R is in 2 NF but not in 3 NF why because in above functional dependency there is a transitive dependency so as per function dependency B can determine C and C can determine D so we can also say that that B can determine D so D is the transitive depends on the key b as per functional dependency B can determine C and C can also determine a so then we can also say that B can determine a again using the the transitive rule so a is transitive depends on the key B let's see the next one over here in the functional dependency a can determine B BC can determine d and a can determine C so the candidate key very simple over here is a relation R is in 2 NF but not in 3 NF why because again there is a transitive dependency over here as per function dependency a can determine b and a can determine C so we can also say that a can determine BC using the union Rule and as per function dependency a can determine BC a can determine BC and BC can determine D so then a can determine D also using the transitive rule let's see the next example function dependencies a b c can determine D and D can determine a we need to identify the candidate key what will be the candidate key A B C and and B C D how relation R is in 3 andf but not in B CNF in the above function dependency both function dependencies have the prime attribute which is d and a d and a independent right side let's understand how to normalize the database as a software contract and consultancy firms maintain the details of various projects in which its employees are currently involved these details comprise of for example employee number employee name date of birth Department Code Department name project code project description project supervisor so you have to assume the following each employee number is unique each department has a single Department code each project has a single code and supervisor each employee may work on one or more projects obviously possible and employee names need not be necessarily be unique because repeat project code project description project supervisor are the repeating fills which will be there so we need to normalize so we need to normalize this data in to maybe the third normal form so now let's make this into a table over here attributes properly table like it was displayed over here employee number employee name date of bir Department Code Department name project code project description and supervisor this is my normal formly into one NF so to do that I have divided this into the two tables over here employee number employee name date of birth Department Code Department empe and project description and project supervisor this is my first normal form is first normal form say 2 andf convert the employee table Remains the Same the employee table Remains the Same but the project table can be further divided project code project description project supervisor becomes my one table and with the employee number I can determine the project code so this becomes my second table with project code being the foreign key from the project table Department project table and employee number table now this cannot be further divided so this is my last normalized pum which is three NF question and try to solve it by yourself also all this condition must be satisfied now these are few questions which are usually asked in exams of unit 4 you can try to solve each of them if you solve all of them by yourself then you would be able to score very good in this unit take a screenshot of this and try to solve this questions if any doubts or queries you can mention in the comment section also these are another questions then do give a like and in the comment section you have understood it and also do subscribe my channel for the next video I will see you in unit 5 thank you very much