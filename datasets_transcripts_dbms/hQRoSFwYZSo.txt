hi very good evening all of you hi after today you have to wait for a long waiting time you are waiting and maybe some of the students thought that yes ma'am is celebrating Durga Puja so ma'am will not take to this class but you are wrong I will be there definitely I am there for you so please please please inform your friend that yes ma'am is here so join life quickly quickly join live quickly tell them yes ma'am is live here and today we will do the complete dbms complete complete because those who know me they all they are it is my favorite subject and this is the request came from so many students previously also in the comment section I saw that yes so that's why I thought today I give a choice and it was the first choice so that's why I take that okay let's start first come first services so those who are here I want to see this yes who are here hi Divya Deepa and Selby Regina saranya so what you have to do you know that I hope so that share this link watching this in your all the social media WhatsApp Facebook everywhere in status please add the status yes watching this so your friends can come and tell your friends to join quickly I hope I am audible visible everything is clear is uh just let me know and before starting I can see yes yes very good evening very good evening good evening all of you as we did the software engineering so here that dbms will be we will complete here tbms also we are going to complete today's super fast way yes good good Goods let's start it let's start so here in the dbms as per the previous years analysis as we are doing always the previous years analysis as per the previous years analysis you can see the functional dependency normalization ER diagram SQL B tree relational algebra so always 9 to 10 marks questions are coming every year every year you can see here here was the sixth question from functional dependency and normalization functional dependency a dbms concept key concept referential Integrity relational Big Data X cable again here in the December 2018 normalization uh SQL data warehouse indexing transaction concurrency so these are the topic always repeated now what was the new addition in 2020 these all the topics came same same same way in 2020 also in 2021 what is the new addition with this topic 2021 also normalization was there and all other topic was also there with that another uh question was there actually it is the yard diagram topic only from the ER diagram little bit in depth question from ER diagram there was two question and another topic is that that is the B tree from the B tree uh question came like uh what will be the number of keys required that question so we will do all the question here today 2020 2021 all the solution also I will provide you and with conceptually first we will learn from first we will start with functional dependency normalization minimal cover everything we will do transaction we will do indexing we will do everything so let's start it without wasting time so here these are the topic you can see most important topic most important chapter of dbms here I am I already told you that Dimitri was there so here diagram SQL relational algebra basic concept of dbm is Data Warehouse indexing transaction concurrency if you cover this topic then after that there is nothing to do and dbms is very scoring area 20 out of 20 is easily you can get here and this is the area where also again comprehension type question are coming already two times they ask comprehension type question one year there was functional dependency another year there was SQL so means you can understand from dbms high chances there you can get again another question what are the area where you can get 10 marks question in dbms this is first of all functional dependency normalization next one is relational algebra and relational calculus and SQL from this area also 10 marks question can come that is comprehension type question ER diagram also the area here also 10 marks question can come and transaction concurrency also the idea where Denmark's question can come these are the four area from where easily they can ask you 10 mark question means five question from one topic so must do this topic so that your this marks will be you will not miss this marks okay okay so can we start I hope so yes everyone good evening Mayuri Meenakshi mini Tamil Sanju priscal saranya everyone lekka previously I told everyone good evening good evening so let's start the functional dependency and if you learned with me dbms after learning my lots of students are doing interview and they are getting the job also for functional dependency normalization because after landing with me it is super easy for everyone so dbms will be also easy for you so here under the relational database model I am not coming here these are the relational database model you already know that so this is the concepts are very very important 2021 question was they are from this concept 2021 question was they are from this concept here attributable Tuple relation degree cardinality column rational instance rational key and the attribute domains what are that so first of all attribute attribute means whatever you are writing whenever you are drawing a table this is the table right here baby this is a maybe student table in the student table you are doing the roll number after that you are giving the name then all these are call attribute and here we are storing the data these are the rows these are the columns right so in this table only you can see this is the where you are writing the attribute column or attribute these are the attribute customer ID customer name status this is called Tuple or rows this is called Tuple or Rose domain what is domain here it is the not null means here you you have to do something it cannot be blank it cannot be null that is called The Domain primary key means you are setting the constraint here this is the primary key when we are setting it as a primary key it will identify all other attribute and it cannot be repetitive value it cannot be repetitive value in a database always remember that right now after that next concept is that what is degree what is degree and what is cardinality degree means total number of attribute in a relation that is called degree cardinality means what the total number of row present in the table how many rows are there in the table that is called the cardinality so remember it cardinality means number of rows and degree means number of attribute okay and next one is the relational database that you all know so these are the main important points okay clear now next one so here under the functional dependency these are the functional dependency how to represent the functional dependency a implies B A plus b means here whenever I am writing the functional dependency it is very important to understand that a can determine B when I can say when left hand side whatever is there in the left hand side like that if I am telling that key role number one roll number one name is Priyanka it cannot be possible roll number one name is maybe other than that maybe Sanju it cannot be possible so when there is rule number one then it have to be a single name it cannot be multiple name okay so here it is a question for you how to determine the functional dependency here from here your concept will be clear tell me quickly tell me the answer here a implies B hold or not a implies B hold or not here quickly tell me the answer a implies B hold or not here how to check it good evening thulasi okay not hold how to check it I am telling you how to check it whenever you are able to see that a implies B this is the left hand side implies the right hand side first of all check that in the left hand side is there any duplicate element in the left hand side is there any duplicate element if there is no duplicate element then no problem remember always if there is no duplicate element then no problem if there is any duplicate element then we have to check that with the same element right hand side also same element have to be do so here A A these are the duplicate element A1 A1 here A1 is telling B1 here A1 is telling B2 it is not possible when here A1 is telling it is B1 it have to be B1 it cannot be B2 that's why I told roll number one name is Priyanka so next anywhere where is roll number one it have to be name is Priyanka it cannot be any other name so that's why this is not possible this is not hold same way if I am going for a implies C is it holding or not now you have to tell me is it holding a implies C everyone I need answer from everyone those who are live here so that your concept will be clear your division will be done these are the very important concept tell me tell me quickly okay so answers are coming answers are coming so yes these are the answers see that a implies C is also not holding B plus C is also not holding because aim plus C this one this one here is C1 C2 it is also not possible when you are doing B implies C for B two B two here is B2 B2 here is C2 here is C1 not possible same place they also not possible only for a implies D it will be whole because where A1 A1 here is D1 D1 that's why there is not a problem a implies D will properly hold here that is the understanding what is hold or not how to do I hope it is clear I hope this is clear to everyone now again the next question consider the relation a b c the tuples are given here now options tell me the answer quickly which is the correct option here which will be the correct option where here it is the revision series it is the marathon so we have to go little bit quickly tell me what will be the answer here it is aim plus b b c implies a B plus c a c plus b okay answers are coming here b c implies a it is asking you which does not hold does not hold your answer will be which does not hold please please please be clear about the question you must read the question properly it is asking you which does not hold which one is not holding here when you are doing BC together here it is 2 3 2 3 2 3 implies one here two three implies 4 here it is not possible this one is not possible that's why not BC yes that's why it is the correct answer please read the question very carefully please change your habit otherwise write down that not qualify it otherwise remember that you have to see not qualified if you ignore this not in the question then you have to be ready to see the not qualified now it's your choice what you will do okay now it's your choice I will not tell anything now tell me this is expected question I am telling you this is a expected question very important question try to do it which of the following instance these are the instant which of the following functional dependencies hold in the above instance very good question try to do and after that I will tell you the answer I hope those who are watching you've always already pressed the like button if you forgot to press the like button then please for please at least press the like button I can see till now only eight like button is there no one like this class so you can dislike also so you can press a like button if you like this class otherwise you can dislike also but press it any one of them you can press it you can press it any one of them okay so answer is coming answer is B definitely answer is B here but it is B implies a b implies a whenever I am checking 1 1. and that is 8 8 that is okay 2 2 that is 10 10 it is asking you that which of the functional dependencies instance so this is correct now a implies B for same way eight eight that is 1 1 10 10 there is two two so this one is also correct a implies C when it is 8 8 here is 14 here is 16 not possible a b implies C 8 1 8 1 again 4 16 that is not possible C implies a 16 16 here is 16 16 and for here it here there is 10 that's why it is not possible B implies say for 1 1 here is 14 and here is 16 not possible that's why it is also not possible so only this one is current okay okay clear is it clear yes yes or no clear I hope so okay okay now the next now we can go for the next so here in the next first of all here it is the what is called trivial dependency what is called non-trivial dependency trivial dependency means self self always remember that is a implies a a implies a b like this when some left hand side and right hand side there is some common thing that is called the trivial non-trivial means when there is no common nothing like that a implies B this is a non-trivial one where there is no common that is called the non-trivial so here you can see the trivial this is the trivial one this is also the trivial one this all are the trivial one non-trivial ID implies name name implies dob this is called non-trivial dependency theories can also come guys so that's why remember that theories can also come what is transitive dependency that you all know X implies it when it is X implies by y implies Z then it is X implies it right now here is the very important concept between Super Key candidate key this is very very important concept and always students are getting confused here remember that super key is a combination of key through which you can identify other element first of all what is key when any any one attribute or a set of attribute together can identify all other attribute of the table all other attribute of the table that is called a key now when it is super key it can be a combination of two or three attribute together those who are able to identify other element that is called Super Key now what is candidate key like that maybe here I am writing a b implies c d e all other attribute here is a b c d and e these are that tribute even also maybe here A D implies also c d e all other attribute including a b though definitely will be there now I am telling only a can also imply a b c d e so here you can see a b a d these are the super key here but a is the candidate key here because a a b a d everyone can identify all other attribute but out of them a is the minimal one that's why a is the candidate key here which one is the minimal that one will be your candidate key clear now which one can be primary key here I choose only one candidate key that is a it can be possible that a is also able to do maybe D is also able to identify all others it can be possible then out of a and d both any one of them we can choose as a primary key that is called the primary key right so that's why this is the superset subset concept candidate key is the subset of super key and inside they are any of them I can take as a primary key clear theoretical question can come from here and this is a question for you try to do this one quickly what will be the answer for this try to do this one Sachin narmada Mayuri full moon everyone what will be the answer until now I can see 32 like okay those who dislike it you can press the dislike also if you are watching and if you think that yes the class is not helpful then you can dislike also it's your choice yes what will be the answer then tell me what will be the answer for this it is a question for you A B C D four attribute four possible candidate keys are there these are the candidate Keys here so from here you have to tell me what is the answer Zarina hi Zarina welcome answer answer answer what will be the answer here and those who want to know the 2020 and 2021 previous year's question solution py QA solution these are all topic wise question solution I am providing here these are also py keys and specifically for 2020 2021 those who want to know you have to wait till the end must wait till the end everything we are going to cover here all previously especially in expected question topic wise everything we are doing so till the end wait for the end so that everything will be done for you answer what will be the answer okay answers are coming here yes this is the answer C why why this C is the answer because see that here is B here is B here is a d here is CD so b c and b together cannot be candidate key if B is my candidate key then b c have to be a Super Key it cannot be the candidate key so first of all I will check with b b is the candidate key or not how to check it what we will do okay I will check that when B is the candidate key if B implies a b implies C and B implies D these all are satisfying then I can say B is the candidate key right so how to check it first of all B implies a here you can see the left hand side these are all different attribute and I told you in the left hand side if there are no duplicate element then there is no concern with closing your eyes you can say that heat will be always satisfied so B implies a is satisfied here definitely same way B implies you will be satisfied same as B implies D will be also satisfied that's why these all are satisfying means B can determine this one also B can determine this one also we can determine this one also means B is my candidate key when B is my candidate key then b c cannot be the candidate key this is a Super Key because this is the minimal set with the candidate key when I can say super key Super Key means with the candidate key plus anything extra you are adding that is called a Super Key so here B plus C you are adding that's why you got here BC and this is a Super Key so that's why your answer will be this is not possible now sometimes students are thinking that keep minimal means they are counting don't do that mistake sometimes students are doing this mistake that minimal means they are counting that b is one attribute means this is the candidate key A D cannot be the candidate key CD cannot be the candidate key this is a very bad concept students have I don't know from where they are learning but sometimes they are telling me so always remember guys minimal means not like that you have to count the attribute here B is also the candidate key even also if if you are taking a d together a d together okay a is not a candidate key you can see if you will see that a implies B that will not hold because here is a 1 here is A1 here is B1 here is B2 so a is not a candidate key if you see that d D implies c will not hold here so a is not the candidate key D is also the not the candidate key but when you are taking together A and D together then a d will satisfy B also a d will satisfy C also that's why a d here is a candidate key and same way c d will be also the candidate key so here in this table a is also the candidate key A D um B is also the candidate key A D also the candidate Key C D also the candidate key this concept please remember here students are doing a big mistake minimal means not counting I hope concept is clear why these are candidate key because only a not a candidate key only D not a candidate key only c not a candidate key that's why together they are making so that's why I can say they are candidate key okay is it clear my class will be little bit in depth because we have to learn in depth quickly everything is not possible and dbms though definitely we have to learn everything in depth so I hope it is clear to everyone and that's why this is the answer because it is the candidate key okay yes now here the question is that identify the primary key this was the previous year's question from where Denmark's question came from this dependency only so I have divided it into conceptually part wise this is the first part of the question that what will be the primary key of this table do it what will be the primary key of this step will do it always remember definitely not is the Trap of the question previously also you saw the Trap okay answers are coming yes answer will be a now how to find out the answer always there is a easy trick to find out the candidate key sometimes students are able to mistake ma'am I know how to find out candidate key but I don't know how to find out primary key that question are also coming to me so guys candidate key means only you are able to find out primary key because whenever you are able to find out the crack candidate key any one of them can be the primary key right and if there is only one candidate key then definitely this is your primary key right so how to find out it there is a easy way easy trick is there write down all the dependency here a implies b c d implies e BC implies d a implies d now check the right hand side check the right hand side in the right hand side which one is not present in the right hand side which one is not present you have to check that so which one is not present you can see out of all other a b c d e only a is not present so candidate key means what through that I have to determine all other key so as a is not present then definitely a have to be a candidate key or the we pay you have to add something else so here whenever I am doing the closer this is called Closer a implies a can determine b c so a b c now BC can determine D so d d can determine e so e you can see a can determine a b c d all and that's why a is your candidate key means this is your primary cures clear is it clear to everyone I hope so I hope so it is clear right yes yes or no so these are the functional dependency and attribute closure but I am telling these are the closer how to do the closer okay in this way we have to do the closure and these are the question already we did it now here are some Integrity costs constraint last class some students was doing mistake in the Integrity constant when I was doing the expected McQ then some student did the Integrity consent constant concept mistake so there are four types of Integrity constraint domain constraint entity Integrity constraint referential Integrity constraint and key constraint from here theoretical question conceptual question can come okay so what is domain constraint what are the different different types of constraint please understand exactly meaning domain constraint can be defined as valid set of values for an attribute what are the valid set of values for an attribute here when I am writing age age have to be integer values 17 can be possible these are the possible but in age I cannot do a in the age how I can do a is it possible so it is violating the domain constraint here this is called domain constraint valid valid values have to be there next one entity constant what is called entity constraint and entity Integrity is the set of primary key values cannot be null primary key values cannot be null is the entity constraint write down this point in your quick revision notebook because theoretical question statement type question can come from here so primary key cannot be null that is called The Entity Integrity constant here you can see employee ID is null that is not possible according to entity Integrity constraint okay next one is referential integrity how to do the referential Integrity when you see that one table is making relationship with an adaptable and this is the primary key here and this is the foreign key here okay so which one is the parent table this is the parent table and you can say this is the child table actually because whatever primary key is there I can do the reference these only in this table D number is 11 24 and 13. out of these only I can insert here 11 that is correct 24 that is correct 13 that is current 18 how 18 can come here because in the main table there is no value for 18. and that's why it is not possible this is called the referential Integrity constraint clearance this is violating the rule of referential Integrity because whatever you are referencing that have to be in the meantable if this is in not present in the main table I have from where you can do the reference that is not possible here is it clear yes key constant what is called key constraint sometimes students are doing mistake with key constraint and entity constraint here entity constraint means key value cannot be null and key constant means key are the entity set used to identify the entity within the entity uniquely it have to be the unique value that is called key constant entity constant means it cannot be the null key constant means it have to be unique these are the lines must write down I am repetitively telling you high chances their statement type question can come which one is this which one is that even also matching type question can also come they can give you in the right hand side key constant Integrity constant domain constant and this here they can provide you something and you have to match and you will be confused so that's why exact line write it down so here you can see two thousand one thousand two is here one thousand two is there these are duplicate value that is not allowed according to key constant this is called the key constant okay they can provide you this type of table and they can ask you which constant it is violating is it key constraint is it domain constant is it Integrity constant you will be confused if you don't know exact meaning so please write it down now only is it done is it done yes or no so what you learn write it down after that I will ask you the question what you learn four types of constant one two three four what you learn in these four types of constant what you learn in the four types of constant what is the meaning exactly write it down into the comment section write it down this constant means this is the keyword what are the key word you learned I am asking you to write it down in the comment section write it down in the comment section I am asking that what you learned what is domain constant what is integrity constant what is key constant what is referential constraint this four point write it down so that your revision will be done because highly expected you can do the mistake yes DPI is writing the pie is writing everyone domain means it have to be valid value valid different data type node it have to be hard different data type also can be there to be valid value okay all of you are writing write it down so your revision will be done all the four all four I am asking you for all four and after doing give me the answer for this after doing give me the answer for this what will be the answer for this okay good good now do do this in the in this write down it in this what will be the answer yes answer will be B what is the uh what purpose of applying the data Integrity constraint in the database improving the data quality data enter the specific property that is data Integrity okay yes now do this question here understand this question understand this concept from this concept question is that that question we will do here reference table whenever you are referencing for the foreign key maintain how to maintain the foreign key and the referential Integrity like I am telling you one is the student table all student and another is the paid student okay one is the student and another is the paid student because in our class there are some paid students also and for this concept also in means in between I am telling you what is my WhatsApp number eight six nine seven three six five four six zero is my WhatsApp number those who want to join the paid course they can WhatsApp me so that you can get the complete computer science and paper 1 for instance in it you can join the pet course those who are interested so here reference table and referencing table which one is reference table which one is referred in sync table try to understand it when I am taking student means all students are here and out of them some of the students are there who are paid so this is the superset and this is the subset right now when I am trying to insert whenever I am trying to insert something in the reference table means in the student table I am trying to insert something there is no problem but if I am trying to insert here in the page it can cause violation because whatever students are there in this table out of them any one of them Conley can be insert here if not possible that may be student number 12 is not here I can insert here that is not possible that's why it may cause violation from here also conceptual question numerical question anything can come deletion whenever I am trying to delete something means I want to delete one data from the student table that is the main table it can cause violation because maybe I want to delete the student number 10 here that is referencing here in this table also pay table also that's why it can cause violation so whenever you are trying to delete something from the parent table then we have to call on delete Cascade on delete set null what is the meaning if I am trying to delete something from the parent table before deleting we have to check the sub table means referencing table also in the referencing table what are the related data that data you can delete all after that only you can delete the parent that is called on delete Cascade another one on delete set null means I am trying to delete the student Record 12 from the super class super table from the soft table wherever I will find out student number 12 I will set it the null values there that is called the set null so these are the related constraint on on delete operation and here if I am trying to delete anything from the sub table means maybe previously it was the paid learner now your subscription over now you will be deleted from the paid paid table and you will be there in the all student table that is not a problem easily it can be done and that's why it is not violating any rule at the time of updation maybe student number 12. now you are trying to update roll number as 22. can I do it no because that 12 are referencing either here also that's why I cannot do it it can cause violation here also here also it can cause violation because whenever you are updating something you have to update both parent acceptable also supportable also so these are the very important concept statement type question can come from here whenever you are inserting deleting updating which one can know can be occur and which one cannot be occurred is it clear is it clear to everyone yes or no yes or no now tell me what will be the answer for this tell me what will be the answer for this what will be the answer for this quickly yes definitely it will be the referential because here we are doing maintaining relationship definitely now do this one this is a question from this question it is asking which one can be the key which one can be the key here tell me what will be the answer this is a gate previously asked question and it can be your expected question it can be your expected question do the answer what will be the answer here this is given e f implies G F implies i j e h implies k l K implies m L implies in these are given here now out of them you have to check which one is not present just you have to check first which one is not present [Music] right so which one is not present here which one is not present here G I J K L M N I can see e is not present f is also not present right E and F is not present so that's why I will do e f closer whenever I am doing EF closer I will get E F G H I so it is not a candidate key whenever I am adding e f h then I am getting this all right I am getting this all so that's why your answer will be this one right your answer is D here B here right yes clear okay thank you Divya thank you so this is the answer B it is your answer e f h yes now here it is the another question what will be the candidate key in this relation what will be this one what will be the answer for this one quickly do this yes here same way you have to check a in plus b b c plus d e implies c d implies a which one is not present a b c d is there e and H is not present easily e h have to be a part of candidate key this is not possible eliminate it this is also not possible here is e h here is e h here is not eh it is not possible definitely it will be my answer without wasting your time without wasting your time you can eliminate all these option and you can directly answer it just by checking which one is not present it have to be a part of candidate key and in other option it is not there so in this option only it is there so it will be your correct answer just by checking because in exam Hall you have to save time you have to save time saving time is very very important why I will waste my time to check it a aeh is able to do BH is able to do DCH is able to do or not you will do the answer rightly right so answer is this one now this is the most important chart of normalization this is the most most important chart of normalization and normalization will be super easy for you when you will learn this okay so I am not going to the chat for quick revision this is very easy very easy those who don't know normalization it will be also super easy for you okay after whatever I am telling please understand it and after that you can go through this this is a quick revision chart for you after that you can go through it and let me add some um blank page here yes so how to do the normalization remember that how to do the normalization normalization whenever question will ask then first of all you have to do all possible candidate key must do it because just now in the last question you saw that there was three candidate key so always do the all possible candidate key now how to do the all possible candidate key this is the way how to do the all possible candidate key what I will do I can see here eh was not present in the right hand side I will do plus eh closer if I am doing eh closer other than e h any one is not able to see e can determine C that is done now after that H is not there so BCC anything is not coming now I will add it one by one a e h class whenever I am adding so a e h c was already there a can determine B so a b c everything is done now b c can determine D that is also done so now a e h is your candidate key now how to get the other candidate key for that what you will check you have added a now from the given functional dependency you will check that right hand side where is a in the right hand side where is a you can see here here is a means D can determine a so I can replace a with d other than that everything will be same whenever I am replacing the a with d then I will see that B can determine a A can determine B now after that e h was already there e can determine c b c came so b c can determine D that is also the candidate key now again check where D is in the right hand side now you can see here D is in the right hand side so I will replace D with someone which one I will replace BC was there now you can see he can determine C so that's why I will not replace with C I will replace with B here it is also a decision pointer remember that here BC was able to determine d so I will replace D with b or c which one here is a question mark which one I will replace b or c that decision you can take with other attribute you can see e can determine C that's why as e is there I can get C so that's why I will replace D with B so that it can come that is the decision pointer you will take B will not take C so I will take b e h now I will see that now see b e h was already there now how to determine e can determine C so now write down C now you've got BC so now you can get D also now D can determine a also so a b c d e h all are done now is it stop no check B is there anyone right hand side yes here is the B A can determine B now it is a loop here was a B will be replaced with a that's why you can stop now in that way you got these three candidate key here although this question by elimination we do it but for normalization it is required to do all possible candidate key got it is it clear yes so whenever you got all possible candidate key after that what I have to do after that I have to do it he what is my Prime attribute and what are the non-prime attribute this is Prime and non-prime attribute Prime attribute means part of candidate key non-prime means not a part of candidate key okay what of the Prime here that's why from all possible candidate key write down it one by one a b d e h these all are the prime attribute what are the non-prime attribute that is C so a b d e h only C is the non-prime attribute other than that all are the prime attribute got it clear thank you thank you sharanya thank you is it clear because I believe this revision means not my revision revision means your revision I can do Revision in super fast way so many things together but if your concept is not clear there is no meaning my target is that if anyone is coming to this class for two hours or whatever maybe they don't know anything but still from this class they can get some marks they can learn something that is my target I will come I will do everything and after that students will be not able to do anything there is no meaning no meaning right so yes so non-prime attribute is this one so this is the first thing that you have to do prior candidate key first thing all possible candidate key next one you have to do and the least of Prime and non-prime this is most important don't do the mistake here list the prime and non-prime after that your decision will be very easy and you have to come from BC and if then 3 NF then 2 NF then 1 and if this is only in our syllabus right right yes so what I will do bcnf means here we will do all left hand side is candidate key check all functional dependencies nothing else is there all functional dependencies candidate key is there or not left hand side if it is there it is bcnf if it is not there then go for 3nf for 3nf what I will do that non Prime to non-prime is not allowed here non-prime to non-prime is not allowed here Prime to non-prime no problem non-prime or prime to Prime no problem got it for 3 and F these are the three you can remember non-prime to non-prime not allowed Prime to non-prime no problem non-prime to Prime non-prime 2 prime or prime to Prime no problem okay in 2 n f into NF here what is allowed here non Prime to non Prime is allowed non-prime to non-prime is allowed here no it is also not allowed whatever here is there is it allowed or not allowed what you think what it is day by day your constraint is going down right so that's why this one is allowed here which one is not allowed here here the problem is that is Prime to non Prime is not allowed here okay this one was not allowed here Prime to non Prime here also it was not allowed here got it Prime 2 non-prime is not allowed here and here also Prime 2 non-prime not allowed here right hand side Prime no problem non-prime or prime to Prime no problem this is also allowed this is also allowed but this one is not allowed Prime 2 non-prime is not allowed here got it this one was also not allowed this one was also not allowed but this one is allowed here other than that everything allowed here partial dependency is this one this one is called the partial dependency partial dependency means Prime means what part of candidate key part of candidate key Prime means part of candidate key that is not allowed here it is not allowed here also non-prime to right hand side Prime no problem for 3 NF and 2na right hand side Prime there is no problem got it clear y Prime 2 no no not allowed that is partial dependency that's why got it that is partial dependency that's why Prime 2 non-prime is not allowed because it is the partial dependency okay a single attribute candidate key is allowed yes that is not only Prime single attribute is not a prime single attribute means it is a candidate key I cannot say when there is a single attribute in a candidate key means you are doing candidate key implies something that is in bcnf then I can say it is in BC and F Prime means Prime means always part of candidate key 2na problem will come for 2 NF remember that problem will come when the candidate key have more than one attribute more than one attribute then only there is the problem because then only the prime to non-prime I have to think if it is only single attribute single attribute in candidate key then no problem because then here this problem will not come the total candidate kit is a single one and it will be definitely in B C and F no problem will come when more than one attribute got it so Prime is different and candidate key is different don't be confused here clear concept is clear I hope so yes so that's why here is the chart for you here you can pause the video and you can go through the chart here this chart is telling this one only nothing else okay clear yes cello 3nf only non-prime to Prime 3 NF non-prime or prime to Prime is allowed Prime to non prime prime to non-prime not allowed in 3 NF also Prime 2 non-prime is not allowed in 3 NF also in 3 NF also Prime 2 non Prime is not allowed Rupa Prime 2 Dawn Prime is not allowed here I am writing Prime to non-prime not allowed in 2nf and 3nf both but non-prime to non-prime is allowed into NF but not allowed in 3 NF this one is this and this one is not allowed both okay if right hand side is prime then no problem then no problem for 2nf and 3na both okay clear so that's why here is the question for you now do this one do this one quickly here it is the relation given how many candidate keys are there and what is the relation what will be the relation here how many candidate keys are there and what will be the relation here do it quickly okay what are the candidate key one of the candidate key here CH implies Z a implies b c b implies c f g e implies a f implies e g what are the not here b c a e g only I can see that D is not there and a b c d e f g and H d h is not present right d h is not present other than that everything is present yes so that's why what I will do D and H is not present h where is H you are getting sorry sorry H was here right yes sorry sorry a g b c h a yes yes yes yes yes yes yes sorry yes hi it says they are only D is not there so I will do B closer if I am doing D closer anything else is coming no nothing is coming so that's why what I will do with a I will try whenever I am trying with a then I will get it so that's why your answer will be here d a d e d f d b all will come these all are your candidate key right all are your candidate key and after that you can check as per the relation given what are the prime attribute d a b e h these all are the prime attribute what are the non-prime attributes c g h is the non-prime attribute so here it is coming non-prime to non-prime CH implies Z that is a non-prime to non-prime it is not in three n f this is not in 3 NF right other than that this one is in 2nf this one is in 2 NF but here when I am doing a implies c b implies C these are what a implies c b implies C these are what it is prime to non Prime right this is Prime 2 non-prime so it is not in 2 NF also so answer will be what that will be only in one NF this is only in 1 and F okay because a implies c b implies C these are not into n f this is a partial dependency that's why your answer will be only this one got it I hope it is clear I hope this is clear it is already we have done now tell me identify the normal form from this relation what will be the normal form for this relation same question this is the next part same question this is the next part foreign guys it is in 2nf here only a was the candidate key so Wayne a is the candidate key what I told there is no not a problem it have to be into a name because it is a single attribute there is no problem in 2nf it have to be now we will check 3n so you can see d e D implies e is non-prime to non-prime so that's why it is not in 3 NF but it will be into NF so answer is in 2nf is it clear always I remember that whenever is a single attribute in candidate key then no problem into an F right there is no problem no causing of partial dependency there is no chance single attribute is there got it yes now here is the question and that is you have to do for the dependency preservation and when I am dividing it into two part then what it will be the answer first of all is it preserving dependency first question first option is there and after that these are all normalization preserving dependency means what whenever I am dividing a relation into two part relation one and relation two after dividing if I am doing the union after doing Union am I getting the same FD same functional dependency if I am getting it then then this is the correct answer okay then it is preserving otherwise not and for that whenever you are doing whatever if D is given must do the closer after that divide it into relation 1 and relation to then do the union of fd1 plus fd2 then check it am I getting the same one or not that is called the dependency preserving okay clear okay so answers are coming so here what you have to do a b c d e these are I am dividing so when it is dividing then add this one and this one so definitely it is dependency preserving there is not a problem because all the dependencies coming here no problem Now problem is that here you can see this is in B C and M because a is the candidate key this is left hand side is the candidate key no problem here this is coming in bcna but D implies e this is non-prime to non-prime that's why it is not in 3 NF this is not into n 3 and if this will be in 2 NF right so your answer will be R1 is in 3 NF and R2 is in 2nf it is actually in B C and F so whenever someone is in bcnf that is automatically in 3nf also in 2nf also in 1nf also and so on and so on okay yes so it is your answer now this was a 2021 question you can do it easily normalization is a topic from where always always question are coming every time so this is a question of normalization again now do that after that we will go for the next it is very easy one it is very easy one yes definitely answer will be this one because x y w z what is the candidate key here x implies Y and this one so which one is not present y w is present x z is not present x z is my candidate key definitely definitely x z is my candidate key right so C is correct primary key and here it is the prime to non Prime that's why it is not into NF this is in one and if so answer will be this one got it yes now do this one this is a expected question for you this is the expected question for you this is the expected question this is the relation these are diabetes given and you have to tell me what is the highest normal form now tell me what will be the answer guys answer answer you have to tell me the answer what will be the answer yes so here this rule of rhs will not apply the rule of rhs is not applied here because everything is present A B C D E everything is present here so which one is your candidate key here that you have to find out so if I am doing a plus I am getting a b c after that D then C D implies e that I am getting here is it is it if I am doing a a b c then D B and D then C D is implies e everything now if I am doing B Club B plus you see I am getting B B through the B I am not getting b d then after that anything else no CD if I am doing CD am I getting am I getting CD with the CD you can get c d e a b c everything so c d is the candidate key a is also the candidate Key C D is also the candidate key right even also if I am doing e e is also the candidate key you can see E A after that from a you are getting BC from B you are getting D C D is already done a b c d e everything you are getting so this is also the candidate key right yes yes right and if I am doing that BC then you can see b c d e a everything is coming this is also the candidate key so a is candidate key CD is candidate key e is candidate key BC is candidate key all our candidate key here so which one will be the answer the answer is in it is in 3 NF only this is violating here rather than that this is also bcna this is also bcnf this is also bcnf here only this one is violating here this one is violating here because here this one is not candidate key that's why it will be not in bcna but it will be in 3nf and answer will be 3nf clear is it clear that's why you have to check all possible candidate key yes why not BC guys if I am taking BC from the B I can determine d now from the uh from the D whenever c d is coming from the CD I can determine E from the e I can determine a is it or not yes Deepa yes or no can I determine or not yes clear clear actually this is violating the only bcna property other than that everything is correct because B is also Prime D is also Prime this is prime to prime it is okay for 3 and if other than that all are B C and F B determine only d That's why B is not the candidate key be determine only b d That's why it is not the candidate key but whenever you are taking BC together B is the prime that's why I told you not it is not the partial B implies D it is also Prime this is also Prime both are prime to Prime right hand side Prime no problem in 2naf and 3nf that I told right D is also Prime here yes or no these also Prime here yes or no got it here you have to check right hand side is prime or not it is prime here clear is it clear that's why you have to check all possibility how to take BC with CT there where take all the see that whatever given dependency check with all the given dependency is it a candidate key or not that is only I check CD is a candidate key or not e is a candidate key or not that is we check all the possibilities you have to check here that is we check it got it so we can take from rhs also mem as candidate key from rhs means you are taking if we take BC then B before Prime correct ma'am what are the prime here what are the candidate key you got here candidate key you got here a c d e b c this is all at the candidate key right these all are the candidate key or not tell me these all are the candidate key or not yes or no these all are able to do B is not a candidate key when also if you see that c closer C closer is also not a candidate key right so that's why what are the prime if you take not don't think like that from all the candidate key write down one by one all the candidate key you have to take and write down all one by one A C D E B all are prime here all are prime a b c d e all are prime so no non Prime here there is no non-prime all R Prime actually all R Prime here there is no non-prime attribute got it how BC's candidate key because BC together can determine all other attribute concept have to be clear BC together can determine all other attribute that's why BC is my candidate key why not BC together can determine all candidate key right hand side left hand side that is not not matter we are applying the trick where trick is not applying their hair trick will not apply here you have to apply concept you have to check BC can determine all other attribute or not BC can determine all other attribute that's why it is my candidate key that is simple my concept that is simple got it clear clear okay take write down all the list of candidate key then write it down all our Prime here these all are prime here whatever the part of candidate key is prime B is Prime C is prime D is prime is prime all R Prime got it clear okay so means concept concept is very very important why I am showing this question why I am doing in depth in-depth study is very very important there is no shortcut of success remember that there are no shortcut of success guys in-depth study is very very important if you are not doing in-depth study then you will be not able to do this type of question okay you have to check I already told you when I have started the normalization the first point that's why I told you this is the first point what you have to do that all possible candidate key that is the first point then least all the prime and non-crime that is the second point then check the remaining point that got it I told Fast Point why you are ignoring it I told the first point why you guys are ignoring it don't ignore anything please don't ignore anything I told the first point least all possible candidate key if you are not doing all possible candidate key your answer have to be wrong you will get a wrong answer and list all the prime and non-prime attribute otherwise your answer have to be wrong that is the proof I am showing here yes your answer will be wrong got it clear all the trick will not apply always trick will not apply we will apply trick wherever possible but everywhere it will be not possible TK understand it I hope it is clear yes yes so here whenever we are doing the um relationship this find the relationship set is it equivalent or not how to check the equivalent these two fds are given how to check the equivalent or not functional dependency chapter is a very important chapter and very lengthy chapter it is the main chapter of dbms that's why maybe I am taking little bit more time uh to discuss it so that you this chapter will be clear for you after that maybe I have to take Aaron to another class that is okay but clear your concept Rupa say that so many questions are coming now one of the candidate key a is a candidate key CD is a candidate key e is a candidate key what was the bcna property bcnf means when I can say bcnf bcnf means when right hand side is candidate key so a is the candidate key CD is the candidate key e is the candidate key just now I prove that so that's why this is is also in B C and F this is in also in B C and F this is L also in bcnf only this one is violating rule because this one is not candidate key that's why this one is not in bcnf this one will not in bcnf right this one is doing Prime to Prime that's why I will satisfy this is in 3nf that's why answer will be 3nf please understand concept don't do it like no understand concept very carefully clear is it clear anyone have any doubt till now yes it is prime it is not a candidate key other than that all are candidate key that I prove here you can see okay got it got it yes okay cello so now tell me how to do is it equivalent or not is it equivalent or not equivalent means you have to check whatever is given here this all the attribute all the dependency can you derive from here and all this dependency can you derive from here when I can say fd1 equals to fd2 then only we can say these are equivalent otherwise not fd1 equals to fd2 then only we can say these are equivalent otherwise not okay that is the main thing that is the main thing here so just do the closure try to do the closure whenever you are doing the closer you can see that by doing closer you will be able to do it and that's why both will be able to do from here you can see everyone that will be able to do and that's why it will be the answer that yes they are equivalent they are equivalent because problem will be only with a b a b these are together bcbc also here only problem is they are here A B implies D is coming I have to check from the fd2 can I do a b implies D yes I can do because here a implies D is there it is possible here is a implies C can I do a implies C from here I can do a implies C A implies B and B implies C that is determining a implies C so that is also done a implies D from here I can do it is a implies d so both are satisfying that's why both are equivalent here [Music] I hope I am Audible I hope yes okay now tell me which one is the Redundant here from the redundancy only you can understand the minimal cover yes how to check it see that here is the thing again we have to check the right hand side here again check the right hand side here is also D here is also D this is also implying T this is also implying D now we will try by removing one by one first we will remove this one after removing this one we have only this three now with that we will check a closer is a b c d b closer is b d e b c closer is coming BC here was d e this one is not coming here means we cannot remove this one this is important we can't remove this okay now we will try to remove this one after removing this one this three are here using this three I am trying to do a closer I am getting this one deep closer I am getting this one BC closer I am getting this one whatever is there same thing we got here also all the same thing we got here also means a d after removing this one also I am getting same means this one is the extra here this one I can remove that is the extra one and that's why a d is the extra one I can remove this one this is the Redundant one okay so whenever you are removing the Redundant one you are getting the minimal cover the next question is which one is minimal cover which one is minimal cover here so which one is minimal cover here yes so minimal cover is this one because we remove the ad after removing a d a b c I can write like that a implies b and a implies C this is I can write but don't do the mistake if it is like a b implies C don't do it a implies C and A implies B implies C don't do that this is wrong this is totally wrong don't do it the right hand side you can split the left hand side when it is together father and mother both implies child that you cannot write further employees child mother and plus child that is not possible right hand side you can break but left hand side you can't break directly that's why your answer will be this one and this one is correct okay left hand side you cannot separate yes so after uh this here mainly next another point is that that is the lossless dependency and lossy dependency how to check the lossless decomposition and lossy decomposition for lossless and lossy decomposition ultimately when it is a complete table from the complete table whenever you are dividing into two part how to divide like employee and Department you have to divide in that way so that whenever you will join these two table you should get the table again that's why one common attribute have to be there there have to be one common attribute that is employee ID employee ID other than that how we will make join when a family is divided into two part there should be a common people who can join the family in two part again if there is no Common People between these two family then they will never join okay because of network issue maybe Network issue is going on here so that's why I have to end the session so it will be never joined so what we have to do here main thing we have to check this one R1 Union R2 is equals to R R1 intersection R2 is 5 that is have to be 5 means that is not 5 means no one common attribute have to be there common attribute have to be there after that what I have to check our one intersection R2 implies that 2 minus R1 or here is a or R2 intersection R1 at intersection R2 implies R1 minus R2 any one of them have to be there so here is the question you can see ABC here was the FD you have divided into two part A B and BC now it is asking that the decomposition is lossless or lossy how we are checking first of all we will do the intersection Point what is the intersection point B r 1 minus R2 here is a trick also remember that whenever you are doing R1 minus R2 how to do whatever is there in R1 minus the common between them whatever the common between them that's why a b then common was B so A B minus B that is a so now you have to check that b implies a was present or not if you see B implies a was not present this is not present here yes or no B implies a is not present another option was there that was or again we will do R1 intersection R2 that is b r 2 minus R1 here is BC common attribute was B so BC minus B I am getting B implies C so or I will check B implies C is it there you can see beam plus C was also not there that's why this is a law C decomposition you cannot get again the same table it is a lossy decomposition here got it although there is a common attribute but this one or this one any one of them is not satisfying here and that's why it is a lossy decomposition is it clear is it clear to everyone yes yes or no I hope so yes clear anyone have any doubt okay so now do this one so here you can see another one this one when I am doing here very carefully do it a b b c c d we are dividing this one when I am dividing this one then you can see this one will be lossless because here you are getting common this one is present here after that this one is present here that's why this one will be lossless this one is clearly lossless okay so here this is the dependency preserving that I told here but how to do the dependency preserving dependency preserving means a plus F1 Union F2 you have to do the closure do all the closer after that only check it otherwise your answer will be wrong then divide it then check it otherwise your answer will be wrong here for the dependency preserving okay so this is a question for you this is the last question for today and we have completed the functional dependency chapter with this question I will take another class if you need you have to tell me if you need the next classes because SQL we already did there is a class on SQL previously we did it completely and we I can arrange the class for ER diagram and transaction concurrency and the B tree B plus 3 these are the things are there so if you want you can let me know in the comment section because it is already 10 again I have class on 5 30 am everyday paid class I am taking on 5 30 am so tomorrow also class is there I cannot continue more because I have to go for Sleep also so after this topic I have to end the session as per your feedback as per your requirement as per your comment I will decide that what you need tomorrow okay because I cannot do any shortcut in one hour I can complete dbms but that will be very shortcut and it will be not helpful for everyone so that's why I teach in depth so that at least one chapter will be done and from this chapter that is most important chapter will be done so do this answer what will be is it dependency preserving or not what do you think is it dependency preserving and it is lossless or lossy next question is that it is dependency preserving or not and is it lossless or lossy two thing you have to tell me answer guys let me know in the chat box what will be your answer okay answers are coming yes so see normally if you are checking you will feel that key as I am dividing into a b here and here is BC here I will get a implies B here I will get B implies C so you will think that c implies a will not come that's why you are telling that it is lossy right so that is wrong you have to do the closer but I am telling you have to do the closure must do the closer whenever this is a closer you are getting ABC ABC ABC this is the complete closer list make the list of completely closer all possible FD you have to do all possible FD make it the list of all possible MD after that then divide it when you are dividing you will see that a plus b b implies a will come here beam plus c c plus b will come here and after that after doing union now from this one it is coming a implies b b implies a b implies C and C implies a conson was with C implies B concern was what C implies a right so by the transitive property from C implies B this one and B implies a from the transitive property I can get C implies a here from the transitive property I can get this one and that's why this one will be dependency preserving it is correct this is dependency preserving okay and this one will be lossless also because just now we did this one this one will be lossless also whenever I am doing this one ah no ah this is the different question so whenever you will do this one as per this one here first of all you are taking here a b and here is BC right so what is the common attribute B so if I am doing R1 minus R2 that is coming but that is a if I am doing a 2 minus r 1 that is coming C so either B implies a have to be there or B implies C have to be there so I can see B implies C is here means I can join B implies C is present here means after doing doing Union I can get a b c here this one is present here that's why this one is lossless this one is clearly lossless got it because here R1 intersection R2 implies r 1 minus R2 or R1 intersection R2 implies R 2 minus R1 that is satisfying here this one is satisfying B implies C is satisfying and that's why this one is lossless so it is dependency preserving yes and it is lossless also I hope it is clear to everyone yes yes clear as I do this one and tell me what will be the answer this one a b c d this one already we did this is your home task you can try this one what will be your answer you can try it we did it also and here answer will be this one a okay here is also another question this is also your home task you can try you can try and you will get it other this one do it this one quickly do it this is not your home tasks now only do it and tell me what will be the answer with this we will end the class quickly you can tell me the answer what will be the answer for this one answer me answer answer what will be the answer what do you think answer what will be the answer he is has there is no common attribute there is no common no common means it cannot be it cannot be lossless so your answer will be here is a and your answer will be definitely this a is correct that is it is dependency preserving but not lossless not lossless means it is lossy means it is lossy this one is correct answer dependency is preserving because M implies npm plus q that will preserve but this is dependency preserving but not lossless because no common attribute here are one intersection R2 is 5. it is 5 no common attribute that's why it is law C right it is lossy clear is it clear that's another good question this is a expected question so many things are there ready for you and I am trying to end but I am not able to end as I do this one do this one all those students are going but I am I cannot go because I feel that it's required to study it's required to study this is also great question do it and tell me what will be the answer those who are there till now please reply what will be the answer for this one it is expected question who are here just tell me hi yes I am doing rinky vanilla what will be the answer you have to determine the FD determine if D here that is the task guys you have to think try to determine FD these are the twisting questions determine the FD determine it yes answers are coming some answers are coming okay yes answer will be decomposition is lossless because this one we divided into a b c and c d e so what is the common attribute C is the common attribute I have to do R1 intersection R2 implies are 1 minus R2 or R1 intersection R2 implies a 2 minus R1 means I have to get C implies what is R1 minus R2 R1 minus R2 is this is your R1 this is your R2 C is the common means I have to get C implies a b or C implies I have to do R1 R2 minus R1 that is this is our two common attribute is C that is C implies d e so either C implies a b or c implies d e have to be present here so check it this is C C implies a b is it satisfying yes because C is here no duplicate we learn here see there is no duplicate no duplicate is here means no problem this is satisfying here even also it will be also satisfied when there is no duplicate then this one is also satisfying and this one is also satisfying both are satisfying so this decomposition will be lossless clear where which concept will be required where which concept will be required is it clear why I was discussing the functional dependency how to understand functional dependency because if you don't know functional or dependency will be not able to do normalization you will be not able to do the minimal cover you will be not able to do the lossless lossy so all questions can be different different things and these are your expected area these are your expected area you have to be very clear very clear very clear okay is asking hi ma'am could not download the admit card what might be the problem admit card not release till now today they did not release admit card take it they will inform the notice in the notice they will release that for the eighth uh October we released the admit card hopefully two days before means within sixth you will get the admit card and your city allotment notification lots of students have so same queries when we will get the admit card for computer science you will get the admit card for computer science hopefully on 6th October got it hopefully on 6th October you will get it don't panic you will be able to download and I will inform you I am there right I will inform you now it is the time to download your admit card download it okay yes okay yes so bye everyone I hope this class will be helpful and those who did this class till the end those who did the class till the end I hope you will be able to do it okay bye bye everyone good night see you again your choice of question is so helpful ma'am single question covering almost all the concept yes yes that is that's why we are doing lace he is more right that is our Target I will choose the question where it is focusing the concept right good night good night everyone bye see you again tomorrow bye bye