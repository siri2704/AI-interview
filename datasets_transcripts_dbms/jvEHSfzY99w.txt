[Music] hello everyone yeah so it's my pleasure introducing consumer singh sir to you today so i have been very much honored to be mentored by him and today hosting him for this webinar so if you don't know him he has been twice icpc world finalist and was part of the engineering team that built facebook messenger and one of the initial people who moved to facebook london i think that most of you already know him and want to hear from him more than from me so i will be handing over to him yeah hi guys uh thank you so much for the introduction um today i want to cover um one thing which is on how to be successful as a software developer there's so many resources around that talk about how do you get really effective at data structures algorithms problem solving but the truth is like while that is great what i learned in my life was that when you move to software engineering you utilize a lot of that learning but it's a very different battle that you're fighting um so i wanted to share some of the insights from what i had learned then just take it as a feedback on some of the things that you should be doing the way i usually do things is i prepare a checklist every single day when i'm ending my work i just check whether i have done well on all of those checklists so this is more of creating a checklist for all of you guys and welcome any kind of feedback anything that you guys might have seen in your career as well the way i'm going to structure this is actually let's let me see if i can share my screen so i i am going to share i mean this is the the structure for this the structure is i'm going to first talk about what changes from hard skills you know technical skills i was writing code on a single machine so for example somebody told me hey i just write a code to find the first hundred prime numbers i was able to write a code for that on a single machine how does the same problem or like what else to do with the same problem when you're writing the code in a in a software engineering job so the first part is going to focus on that the second part is more of soft skills basically how do you hack your growth in a company like you'll be working with a bunch of different colleagues what do you do so that you stand ahead of rest of your colleagues you grow faster at a company again i was fortunate enough to grow significantly fast within facebook multiple promotions fairly quickly and these were the things that i had followed so might work for you might not work for you but i would love to share these things with you guys all right so starting with the first part which is um the problems when you're solving it on a single machine and when you're solving it in a distributed environment they they have different solutions so the first change that you have to do is on how you uh change the mindset to solve problems when you have the same data 100 different machines right so for example i'll just take an example here which is let's say i told you hey there is a list of integers that is given to you and you have to sort it now when you're doing it on a single machine let's say if you're doing it um using your problem solving it is super easy right like most of you guys would just write a sort function and things are done in fact most languages have inbuilt sort you do a list dot sort or sort vector dot begin comma vector dot end and and in one single line your entire array is sorted which is great however think about the case when you have the same list let's assume this is a list of a user id and every user id has some score right and i have such a popular platform that i have trillions of users and i mean user not meaning uh because we don't have population of a trillion people but let's say assume it's an entity right so some entity and every entity has some score and i have trillions of these entities right and that's why like a single machine doesn't is not able to fit that data on a single machine so that's why i have to spread it across various hundred machines right and now i say hey sort this entire list of entities with respect to score so that means entities with the highest score should come first and entities with the lowest score should come last and since it's a cross machine so let's say machine one has the the highest scoring entities machine to like the the entities after that and machine three the entities after that and so forth now if you see this problem uh i mean as long as it was sorting within a machine you can still use a sort function which you you would obviously do but the problem then becomes once every single machine has data sorted within them there is no guarantee that there is an ordering between two machines right so then you do some variant of merge sorting where you pick pairs of uh machine and then you merge their data uh so you pick machine one and machine two you do a merge between these two because they both have sorted list between them and then you do a merging with them then you might put peak machine three and machine four they will again do merge sort and then they will be sorted within them and then that way you you build it up it's a if you search online you will find this i'll go and this again like is not supposed to be a uh i'll go teaching class so i'm not going to go into depth of it i would love to but yes i mean it uses merge sort mechanism to sort it on a on a distributed environment but as you can see like the the problem became a very different problem when it was when it was given in a distributed environment very similar thing like let's take another example if i say find the median in a stream of integers now as long as that stream of integer fits on a single machine it's a very standard interview question you can you can have a balanced binary tree of the numbers that are coming in or you can have two different heaps and then you can derive your median from there however when you the data doesn't fit in a single machine and it's now split across 100 different machines then i would leave you guys to do this exercise it actually becomes a binary search problem you start binary searching for your media uh and those two are again like very different problems are very different solutions so the the first change in mindset is that the code that you are writing on a single machine had a very inherent assumption that everything is going to be on one machine all of my data is going to fit in my main memory that might not remain true when you move to a distributed setting so that's difference number one uh difference number two all of you here i can read the chat so assume that you are working in a company which has this multi-threaded environment right so let's say let's say somebody here is working at amazon now amazon has these java servers and uh it's it's multi-threaded there's a code snippet there which is very very simple if x is five then let's make y as x into 2 what do you think is going to be the output of the following code most of you would think that the output of the following code as in like the value of y after this piece of code executes is going to be 10 which is true in most cases however in a multi-threaded environment if you have multiple threads doing execution it is very possible on line number one when you checked x was five the value of y the value i was asking for value of y on line number one when you checked x is equal to five in for that thread the value of x was five and you went in but before you could execute the second statement which was y is equal to x into 2 there is some other thread that changed the value of x so for a single threaded yes y's value will be 10 which is 5 into 2 but when you have multiple threads then the value is not guaranteed to be 10 it is possible some other thread just between these two lines change the value of x so that is another thing like the code that you read they might not behave as you would have assumed them to behave in a normal competitive programming scenario or a or where and writing code on your simple machine which was always single-sided so so they again like the the resolution there is you can either put a lock there um i'm sure like if some of you might have studied operating systems and uh there were mutex locks there so you can either put that so that you ensure that there is only one thread executing this piece of code at a time so you can put a lock on x so that nobody else can change the value of x or um somebody just suggested that make x as constant so nobody can change the value of x well actually you can make excess constant only if that is allowed as part of the application right like if if your application in your application x was supposed to let's say denote uh the number of online users then it cannot be constant by definition it has to uh change as the number of online users change so so yeah mohit suggested like we make this segment synchronized which is very similar to just taking a lock which which would that that will actually also work but i'm just telling you like the the transition that happens right like when you were writing code on your single machine you didn't have to care about that right like if if i said uh you've written this code and uh you were debugging this code and like you look at this you you're guaranteed that wise value will always be 10 at the end of execution of this block that's not guaranteed in a multi-threaded production environment so you have to be cautious of those facts as well let's look at the next thing the other thing that you will realize and this is again from my personal experience when i was in college i used to pride myself on writing code that was obfuscated i i would write code that is obfuscated hard for other people to understand i would maybe use certain operations which would be more optimized for example uh for taking the maximum greater than question mark equal to this performs better slightly better in c plus for taking out the maximum rather than the max function but just writing the same code in a in a production environment is not good enough because in in your company this code is not just for you it is for you and hundreds of your team members who are also going to maintain this so every single quote that you write you have to assume that you might not remain at the company a year from now there should be other people who should be able to come and read the code and clearly figure out what is happening in the code that means your variables need to have very descriptive numbers and in fact this is what uh amazon also tests for in their interviews because they they want this to be sort of built into you so they optimize for code readability because they know that like if you are if you have empathy if you have if you want the other teams to also succeed will make your code very readable so your variable names need to be proper which denote what they are supposed to do your code needs to have be readable in the sense that if you look here in the second part with the equal to operator there is space before this space is after with less than operator there is space before space after so that the other person can very easily understand what is the variable being compared and against what even the function name the function name instead of f which could be anything now is seems to be more descriptive instead of writing m greater than question mark equal to now we are using the max operator so you have to as you move from a from a competitive programming environment into a production environment you also have to write code that is actually actually readable that people can understand quickly that also means you have to document your code i'll actually come to that right after this there's another thing here which is a code duplication now this is something which doesn't come very naturally to us but i'll actually tell you what happens in in actual scenarios let's say i had written these two functions the first function is just checking whether a user has passed the course or not and let's say hypothetically a user passes the course if their score is more than thousand right so what i did was i wrote some code to calculate their score and then i checked if the total score is more than thousand let's return true otherwise return false at the same time let's say there was another piece of code somewhere that wanted to calculate a user score so i wrote another function which was find user score which that did exactly this the exact same code has been replicated here and i'm returning the total score here now hypothetically let's say i figured out that there was a bug in this code now i have to fix that bug at two different places imagine if i would have replicated this code 100 times at 100 different places i would have had to go and change code at those 100 different places that means if if let's say i want to just change this to say that total score now is not absolute but it's relative that means i would rank every user the highest user gets 100 the second and highest gets 99 or whatever and then like so forth for changing that i will have to change the logic at each of these places which is very cumbersome that means that as you move to production environments companies try to optimize for reducing duplication of code so they would rather want that any code that has been duplicated you create a function for it and then every single reference point is calling that function so then when you have to fix that code you only change that function so there's only one place where you're changing the code rather than two or three different places this again is not very important in a competitive programming because as long as the code works as long as it gives the right output everybody is okay with what you wrote but as you get into a job this becomes important and this is something you should keep in mind uh let's look at the next thing which is which is what i was saying in just the slide previous to us uh is like the code should be readable at the same time you should document your code now this is the mistake that most top programmers make they believe that documenting the code is a waste of time why should i be documenting my code this is completely non-productive it's not getting a new feature out the truth is that you're writing code not just for now unlike competitive programming or participating in contests or participating in a hacker rank test you're writing code for the next 5-10 years if let's say you go and work at amazon if you go and work at microsoft if you've written really beautiful code and your whatever you've worked on is still functional it will probably be there even 10 years from now 20 years from now and that is what you should try i mean your whatever code you write is your baby it's your production right you would want that to be with people even 10 years from now people should be able to say and see and say for example that this code was written by archit or uh uh or aditi right and you should feel proud about that so for that reason it's it's very important that you document your code well so even 10 years from now if somebody comes and reads your reads your code and they will be able to understand the code fairly well they look at the structure of your code and they say person who wrote this code was really really had cared about me because they took this additional effort to help me understand what this code is doing and that's when nobody changes your code to succeed in in a software engineering job there are two things that happens which is unlike what you do in college code reviews either whatever code you write nothing goes into production till somebody has reviewed your code somebody will review your code and leave you advises on what mistake you make make sure that every single code review that you get is a learning opportunity for you ask yourself the question what the did this code review teach me and you should be willing to give it back as well right so become a master at code debugging in fact even today if you're in college look at code samples from different people help them debug your code because this will help you when you go and join a job code debugging is important when you do code reviews if you're not able to pick out on bugs by reading reading through the code it is possible that a buggy code goes into production and it breaks your system uh let's say if you were building messenger it would be and you were the owner for it you would be really sad if somebody wrote a code and you were not able to figure out the bug there and it went into production and messenger was down so you would want to become a master at code debugging all right so let's go to the next part which is uh now the other thing is a lot of us judge each other by just the knowledge of data structures and algorithms um i remember i mean when we were in fourth year people would compare each other on who knew how much on data structure algorithm or how much research somebody was doing i mean those were the two parameters on how we would compare each other the truth is that while data structures is really good for to help you be effective at your job it is not enough it is not enough at all and one of the the couple of examples i gave right like one was a multi-threading environment one was this distributed environment then there are other aspects like for example um there is high level design and i'll give you an example for that so let's say somebody told you that build a system which can shorten my url which is what you call a tiny url right like i have this big link can somebody shorten it and give it to me so that i can share it at different places and when people click on that link then they get redirected to the right big url like the service is very simple right like you anytime somebody requests you to just shorten a url you generate some random code you make that tinyurl.com that code and you return that tiny one and when somebody tries to access it you just since you have stored that now you also have to store the tiny code to actual url mapping since you've stored that you can look it up and then you can return the the right thing now um think about the case when uh your system has grown so big that all of the mappings that you have which is your tiny url to the actual url all those mappings cannot be stored on a single machine right so my machine let's say let's say the laptop that i have it's a one terabyte laptop i have generated so many entries that now my laptop is full and i cannot store the entries here so in that case let's say now i have two machines that are storing uh this data now some of the data is on machine 1 and then some of the data is on machine 2. so when somebody asks me hey what is the url corresponding to the tiny url let's say xyz then i search whether xyz exists on machine 1 or machine 2 if it exists at either of those places i look up the corresponding entry and i return it back very simple however let's say somebody comes and says please shorten a url for me now when i shorten the url let's say the code that i generate was abc now before i store it i want to be sure that abc has already not been generated before so i go and check in db number one which is machine number one and i go and check in machine number two let's say i did not find abc and now i proceed to write abc in machine number one it is very possible at the same time there was another thread on machine number two that was doing the exact same thing with abc so it also checked machine one and machine two and it found that there was no abc in machine one or machine two and as a corner case both machines have now an entry for abc that becomes a problem because when somebody comes and now asks you for what is the corresponding url for tinyurl.com abc now you have two conflicting entries there's one entry on machine one and now there is another entry on machine tool that means there is a consistency problem so these kind of problems arise when you are working across different kinds of systems again i know i would have loved to go into depth of this case study uh but again this is not really uh a study on high level design so i can't go into depth but uh all of this comes as part of system design or high level design like you're trying to design systems design components so that your system is full proof against any kind of consistency issues or availability issues you do it when you are designing large scale systems very similarly there is a area of study which is called low level design this is that once you have figured out your components from high level design how do you structure your code so that it is when you have to add a new feature or when you have to add a new object or a new actor for example let's say take amazon right amazon might have a ton of feature today when they when they have to add a new feature how should you design your code so that the additional amount of work to add a new feature is as less as possible i'll give you an example and this is again a very rudimentary example nothing to do with the real world but assume let's say somebody said hey actually write a code where you design this creature called lion and lion can eat drink walk and sleep so you'd write a code and you'd like you sort of define how it works how drink works how walk works how sleep works now tomorrow somebody else comes and says now i also want to support a dog who can do exact same things eat drink walk sleep in your format you will have to create duplicate the same code for a dog and then redefine those functions but it is possible dog and lion might have some similarities maybe they eat the same thing the eight function looks exactly the same so in in the current case you're duplicating code but if you use oops principle which is object oriented programming principles you can probably define a parent class which was animal and then lion could have been defined there and a basic eat drink walk and sleep function is defined for animals so as you add more animals you probably don't even need to implement certain functions those just get carried forward so your additional effort of adding a new feature or a new actor becomes significantly less this is a different area of study altogether which is called low level design and design patterns there are a bunch of books on that will actually post links to certain books that you can read on your time on design patterns some of the design patterns are builder pattern which is which exists in java factory pattern builder also exists in python there are singleton patterns and so many more features uh design patterns and different design patterns are valid for different use cases the third thing is um which is also by the way checked in interviews as well is how do you interpret questions can you gather requirements for example uh let's take the same example of tiny world right so i i say hey archit uh why don't you define like build a tiny one right and archer says great very easy i'll build this service that stores the tiny url to actual url mapping in our database and i will return whenever somebody says give me the mapping of tinyurl.com xyz i look up the mapping and i return the actual url great all done now tomorrow the person who had actually asked you came and says hey i actually want to see statistics i want to see who is accessing which url what location are they accessing it from what browser are they accessing it from which age group is going to what kind of urls and you say i haven't built that i'm not tracking when when people are requesting who is requesting i'm only tracking tiny url to actual url mapping so you forgot to store it you lost all of that data and when you lost your data then there is no way to recover it because you can't replay what happened in the last seven days so but if you knew this requirement before if you knew that statistics was important you would have designed with that in mind so the when somebody gives you a problem and in real world in your job usually problems are going to be not as well defined as you get in a competitive programming right like common programming has everything defined it gives you limits it tells you what cases are possible what cases are not possible but real world problems are not that well defined when you're defining uber like cab service you don't know you know like at what speed cars might move uh maybe the driver goes to sleep uh maybe people are not reachable there's so many different corner cases that nobody told uber in the beginning they even they had this big scandal that happened in delhi that was never specified as part of the problem you have to go and gather all of those requirements you have to foresee a lot of these corner cases yourself that is what would make you more effective as a software developer right never jump to solutions the first part is gather requirements understand what the end user might want the other thing is a lot of us think and this is just a myth that cs fundamentals are not important as long as i have done well with data structures and algorithms i'm going to do well in my job the truth can't be further away all of what you learn in as cs fundamentals in operating systems networking databases everything gets applied if you do not understand database as well then you will not be able to create the right indices you will not be able to create the right schema you will not be able to make the right choices if you do not understand operating systems then i mean these are very common problems you you if your code base is in c plus plus there's so many times that your your application would have some kind of memory leak memory leak is basically when you are allocating an object i mean for example you can say that a is equal to new end whatever but you forgot to free a i mean to free the memory that you allocated for a so it is very possible you have memory leaks and then you do not understand how to debug those memory leaks there are these softwares that help you uh analyze the memory and what kind of objects there are but those softwares don't tell you like this object is of type this it was declared on this particular line that is not what they will give you uh you will have to understand how memory is managed how paging is done to be able to make sense of that information uh java for example has garbage collection right so java doesn't care about memory leaks java says hey actually i'll i'll maintain references to objects that you create whenever an object does not have any more points of code referencing it i'll automatically my garbage collection will kick in and it will create now garbage collection would have has different kinds of variables different kinds of lives or variables so how do you tweak your garbage collection for your application because there are different kinds of applications right there are certain applications where you are you want your requests uh you have a lot of parallel requests and and in parallel they are very low on memory footprint and they get executed quickly at the same time you have these requests that might be very heavy right for example i want to fetch my news feed in in facebook now fetching a news feed for me uh if i want let's say uh 100 different items in one go that is very heavy on memory right because i am getting like 100 these 100 different posts along with number of likes the content and a bunch of links that might be in those posts so i mean even understanding that for my kind of application how do i need to tweak garbage collection that also is requires you to understand memory management that requires you to understand what how is memory managed inside let's say a unix operating system so again like cs fundamentals are important just busting a myth here this is i heard somebody say it so i wanted to make sure you guys understand that if you have to be successful as a software developer cs fundamentals are important too all right this is the the biggest myth that i have seen with people around me when people move into their new jobs they believe that writing tests writing unit tests is beneath them it is somebody else's job somebody else should come and do it it doesn't again like doesn't help me build a new feature i should just be writing code building a new feature why should i go and write test problem is you write tests so that no other person and you have to assume that there will be people who will not have the same kind of understanding as you do there will be people who will not test your part of the code they change something else for their own use and your part of the code got affected you want the right test to make sure your part of the code is not effective for example the earlier case that we took that there was a function that calculated some user score right and let's say i for my part of the code i wanted that the scoring function gets changed a little bit so i made some tweaks there but that function could have been called from 99 other places as well there is no way to guarantee that those 99 other places are not affected and something doesn't break so you write tests if you were one of the persons using it from one of those places you write unit tests so that when this guy changes this function your unit test immediately starts failing and somebody comes and tells this guy hey dude what did you do with the code this unit test is failing you should go and fix it so the writing the test helps you with the initial parameter which i told you which was make sure your code is written to survive for the next 10 years even in 10 years there are people looking at your code and admiring what you did if you write tests that is going to happen if you do not write test then somebody or the other is going to come and break your code and then somebody or the other is going to come and change your code so your code will not survive 10 years all right so we're done with the hard skills part i'm going to finish this part quickly and then i'm going to take questions from all of you guys just please take notes about what we are discussing today and then i'll take questions now software aspects this is more of how do you hack growth within a company the most common mistake again i see people doing is that they believe that their manager is somehow always judging them and that is why they don't open up to their manager and they crib um just translating it in english i mean the crypt that the manager is is at fault for not promoting me my manager hasn't been helping uh or like i'm not being promoted i'm extremely unhappy about that right you need to make sure you're talking to your manager very clearly in fact the conversation that i used to have with my manager was uh look i want to get promoted as soon as possible tell me what do you expect me to do to be promoted and the answer there was in facebook there were levels defined and the answer there was as long as you're doing what is the duty of the level above me i if i am doing already doing that then i can be promoted so the the manager would very clearly outline for me look here is what you should be doing if you want to be promoted again i'll give you my personal example so the first promotion i i joined and uh i had asked a very similar question on the second day of my joining joining my team and my manager told me look here is i've seen you in the first two days you've been writing code for this particular component if you start owning this component end to end uh in the next six months i'll get you promoted so then i knew what i had to do i knew what i had to do my manager was my friend and he was helping me and sort of helping me draw a path to how do i get promoted it's you guys should do some something very similar because your manager's job description is to help you grow the the job of an engineering manager is to help their reporters grow to help them perform better uh the manager is there to help you they're not there to always judge you and and stop your uh movement upwards so that's the first thing second thing is the second mistake i see people doing is the demand ownership they say um i want to work on this component please ask the other guy to not work on it i'll do it and i'll i'll own it right for example let's say there is a service within interview bit which is let's say takes care of engagement engagement maybe let me take a different example let's say there's a part of the individual that takes care of how mentors function how how these sessions are done right now if somebody comes and says that i want to do it and please remove the other people who are working on the mentor piece of code today i want to take ownership then that usually is not really executable because if i go and remove the other person who are working on it what explanation do you give them the solution there is that if you really are interested in working on something or in owning a component you start contributing them you start looking at what is broken there you start fixing it over a period of time you would have made so many changes to the component which are again like on the positive side that people would automatically start seeing you as the owner of the component they know that nobody knows that component better than you do and then you automatically become the owner you don't need to ask anybody so don't demand ownership earn ownership that was lesson number two on the software skill side and when you do this like you start be doing better than your peers automatically you don't really have to go and demand things from from people and or start a fight uh because you were unhappy on something the third mistake that i i see people do and then that is on both sides getting feedback as well as giving feedback i'll actually address the giving feedback part first uh most of us when we graduate out of university we are very raw right like you you talk to your friends in a very informal fashion you even abuse your friend and your friends are okay with that if something is wrong you you're very okay being very harsh to them and your friends being friends they understand however that doesn't work in an office like scenario look i mean you might go and join a company there might be 10 other people that you don't know of who might have joined along with you and there might be people who are senior to you as well right now when you see something which is broken or when you see somebody who has made a mistake and if if you really feel very strongly about what you're building if somebody made a mistake and let's say created a bug in your code you would feel really bad about it and you'll go and give a very harsh feedback you don't know anything and but the thing is when you give a feedback like that that feedback is not constructive you're not helping the other person understand how not to repeat the same mistake again and especially when you attack the other person they then start holding vendetta against you they they rather instead of improving they start thinking how did this person talk in that tone to me i will show him i will do something which will hurt him you don't want that to happen right like you're you're the reason why you went and gave feedback to somebody was not to create so there's a very simple framework of giving feedbacks uh this was actually created by mckinsey so the simple framework is when you are giving feedback do not express emotions or opinion the first part of the feedback should only be facts for example i'm going to take an example scenario so that it it makes sense let's say um interview bit actually hires problem setters to create some problems for contests or or let's say like assignments uh within scalar academy now let's say i have hired a problem setter and i had asked the person to create a problem for a contest and it was a very very important contest so the person created a problem did whatever they could from their end but in the contest let's say the problem broke it it had wrong test cases so we fixed it but like obviously like that was not a very good thing to happen where like you have this very important contest happening and there was this problem which was broken now there are two ways of handling it right like i go to the person and i start saying that hey you are so incapable you couldn't even handle uh setting a problem for this contest i had told you this was a very very important contest why couldn't you have tested it properly and all of that the person actually gets angry the person becomes starts holding negative feelings about me in in their heart however if i go and just tell them fact if i tell them hey person x you had set a problem called abc for this contest that is a fact the person cannot deny it abc had a problem in the test case test cases and we found that out during the contest it was not fixed before the contest what i feel is we should be more diligent going forward and the way to do that is maybe we should be testing them by writing solutions in different languages and checking whether those pass or not now when you're when you give the feedback in that tone the other person knows that you're not expressing your opinion or emotion but you rather telling them facts and they cannot hold a grudge against you for stating facts so your feedback should always be driven by facts and then maybe corrective actions and be willing to discuss corrective action with the person when you're getting feedback in a very similar way you should always be asking for feedback i mean even when you know you're doing well you should go and ask your manager your peers hey how am i doing can you do you think there's something else that i should be doing differently and there would be people who would not have seen this presentation and will give a very harsh feedback uh sometimes to you and in those cases make sure you don't take feedback on your ego to understand the underlying reason that somebody is giving me feedback is because i did something wrong how do i fix what went wrong how do i figure out corrective action for what went wrong if somebody is giving me feedback one very common uh thing that we do is we get defensive uh we start saying anybody else uh it wasn't my fault it it i actually had good intentions but look the situation was like this which is why it happened don't get defensive let the other person complete and try to reason maybe there was a mistake on your end whatever little accept that and say that hey i'll figure out a way of fixing that going forward when you do that then you improve over a period of time if you get defensive if you never accept that you make a mistake look all of us make this make mistakes if you do not accept you will never improve so always get feedback never take it personally and figure out corrective action while giving feedback be very polite state facts and state corrective actions that you youthful when you do that you will move up the ladder because people will like you you don't want to create enemies anywhere especially so in your current company right last thing this is i promise this is the last thing as i said be nice be respectful do not pick create enemies mostly you have you would have to work in teams more so because teams can get done a lot more than you can individually do the third thing which a lot of people do is they they spend too much time on counting how many lines of code i have written or how many number of hours i've spent in the office don't do that look at impact what what should i do so that let's say my product becomes better more people start using it and state that i mean when somebody asks you what have you done in the last six months there are two kinds of people there are there is a person one who would say i have written thousand lines of code in the last six months uh and i have gone and done these many meetings and i have i i've done some x and y and z and there's a second person who would talk about the change that brought that person would say hey actually uh in the last six months i have increased the number of users using the product from let's say a hundred thousand to a two hundred thousand i have reduced let's say latency or uh the time that the service used to respond back with by by let's say 100 milliseconds so when you state impact that's a very positive sign for the person who's asking you for um for what you've done right like managers usually optimize for impact rather than what you what number of lines of code you wrote or like how many number of hours you spend in office and the last thing is and this is again like something which was very common within facebook there was a very term which would go around which was growth mindset always think about growing no matter where you are you might be the ceo of a company you might have already become like this vp of your organization even then always keep thinking about what do i need to do next so that i grow have a growth mindset and usually growth happens when you learn new things so prioritize learning new things never be afraid to take risks maybe today i am coding in java this new company that looks very exciting quotes in ruby it's okay i'll learn ruby and then i'll be able to go and do well there uh so do not be afraid of learning always prioritize learning if you are capable then everybody would want you the best job guarantee is capability nothing else can give you job guarantee jobs go away people get laid off but a capable person is always in demand so always focus on growth learning building capability if you're capable you'll always be in demand and you'll i mean as a result you'll end up making a lot of impact as well as a lot of money i mean both happen in in parallel so that is all from my side guys these were my learnings personal learnings again there are some of you who might have had different learnings but i would love to take up questions as well and uh um naman is also here sure uh thanks enjoy uh so guys uh i will be taking questions from slido and uh you can post your questions here in this link uh or it's or the link is present in the description of this video uh so we will be taking questions from there or you can put your questions in the comments i will be taking from both these sites okay okay so let us start with the questions uh so uh the most popular question we have is that uh for cp we mainly focus on algos and ts right uh but what topics should one be proficient for building large scale systems i think in the chat you mentioned about high level design and low level design but is there anything specific in them how to learn them and also i'm like an extension to this pro this question is a question from a person who is not from a cs background so as you mentioned that cs fundamentals are important and uh the high level and scalability things are important so how can he learn those things right so usually like there are people who learn in two different sets and and like there's some people who find it easy to learn on their own like being very motivated all throughout for them i mean if you want to learn let's say high level design there are a bunch of resources on the internet there are some very good books we'll post links and resources just after uh just after this session is over uh where we would give you links to some of these resources uh in general like there's a blog called highscalability.com which discusses the architecture of different websites how how have different companies scaled so so i will post resources there you can you can go through it and this there is a second uh set of people who might not have the same background as other people and they might not be able to understand these resources at the in the same fashion as somebody else might there bunch of courses that are there all around i mean there there are some paid resources for example educative.io has some good content on high level design scalar academy at the same time does very formal uh a course um with proper teaching material on both hld and nld um so so you can join scalar academy that that also will help you at the same time like when it comes to uh cs fundamentals now people who come from cs background who have spent time in colleges they have they have gone through formal course work of doing that even if you're not that doesn't put you at a disadvantage there are still ways of learning it and to be honest like you don't need to go and read the entire book for uh for operating systems there are certain things that get used more often than not anyway so so when it comes to learning cs fundamentals as well again like scalar academy addresses that piece as well uh but if if you're again interested in learning on your own uh we'll post some resources for cs fundamentals hld lld uh these are free resources on the internet you can go and read up there if you're able to understand and go through all of it on your own it would suffice if you struggle consuming the content then you should look at certain courses paid courses that are there which are which have live learning and which have mentors who can answer your doubts which will help you um understand these guys uh sure uh so the next question is um during the session you had discussed that how building systems is different from competitive programming but if we have to talk about some skills from competitive programming that helped you add facebook were there any skills from competitive programming that helped you there and what were they when you do competitive programming for a while there are two or three things that you learn to do one is uh if you look at development cycle let's say let's say uh let's say sachin is is a developer right and if sachin is writing spending 10 hours developing something the typical pattern is people write code for two or three hours and then they debug the code for the next remaining five six hours majority of the time is uh is spent on uh debugging so if you've done combinative programming if you keep writing code very often um i mean completely you do well in complete programming if you make less bugs like you're able to get your code right in one go i mean your code compiles runs just in one single code so one thing which you get really good at is writing bug free code so your efficiency as a programmer goes up um because you've written these complex codes and which have run uh in in the first core right so one is writing flawless bug free code saving your time on debugging two is that when you are when you're working with a very large system which has a large core base the one skill that you really need is that you go through the code once and you're able to understand what is happening in the code and then like again the more coding and uh the reading through other people's sport you have done the more skill you develop so that also helps that being said most of the um principles that you learn in ds alpha for example like we would solve a lot of problem on network flow max flow all of these uh were not utilized in in the dev work but like the process to get there the process to understand all of these principles they helped because it got me to a position where i could write bug free code i could understand code quickly uh because i had just seen so much obfuscated code in the past uh sure uh so there is a question that how to deal with repetitive or the work which we don't like in project i think you were fortunate enough to work on projects that were making an impact and probably like it but many people are not at that situation so how can they deal with that and learn alongside it right so yeah that is again another another problem with a lot of work i mean and that happens with all kinds of organization even if uh even if you are uh studying at let's say uh or you're working at let's say amazon it is possible like there are certain teams that have very repetitive work which might not give you enough opportunities to learn i would say even in those cases if your work is repetitive the good thing is like your work isn't very challenging you can finish your work quickly and then focus the rest of your time to figure out what are the things you can do to upskill yourself right so um as i said like learning i mean when we talk about for example high level design not everybody gets to design companies not everybody gets to architect these uh high traffic systems if there are a hundred thousand developers then probably a hundred of them get that opportunity that being said if you understand that that makes your transition into an sd2 or sd3 or an architect faster than everybody else okay so there have been some people are asking what are some good books how to develop that growth mindset do you have any book recommendations for that actually a bunch of books somebody actually in the chat had posted the uh 80 20 thing i actually on the growth mindset i have never read a book but it's been more through my own personal experiences talking to people that being said there are books like zero to one zero to one is actually a very strange choice because it talks more about startups but if you if you just read through the book you'll understand like how the psyche is around around growth most of the time how to how compounding works uh even if i'm growing by two percent three percent every day that compounds to become a huge number over a period of time so so i mean um i'll actually research and then maybe suggest books right now in my personal experience i did not have to read a book i just experienced that through people around me uh okay so there is a question that when to uh say that it is done with a company when to quit a company is there any particular situation that happens that just decide that nothing more is possible here so when to quit right so if you're in a job and you're thinking of quitting uh there are few things that you should you should consider right so uh usually why people should stick around for more time in a company is because if you keep switching very often um you don't get to learn enough because usually when you go and join a new company it takes you about a month or two to get used to how things happen in that company and for you to actually build something which has enough impact it takes you about a year but let's say you entered a company you saw that hey actually uh the culture is really bad usually if you're in a situation where there's a lot of politics and people who butter up their managers get promoted other people do not get promoted in spite of the contribution that they're making then it's probably not the right place for you you should look at moving out um if you're going and talking to your manager about these things and how to progress forward and the manager is dissing you you're not willing to cooperate good organizations do not have those uh those attributes they they look and at investing in every single employee they want to optimize for every single employee's growth if you are at a place where people are willing to invest in your growth then you should stay there because even though today you might be in a project where you're not getting to learn a lot it is possible when you talk to your manager and you express your concern the manager might be able to draw a path for you where you move to a project where you might get to learn a lot okay so there's a doubt from a person who probably is shifting from a startup to a m says that in a startup focus is on speed of coding and not much on code quality and now suppose he is trying to shift to an element see will it be a problem because in mncs there is a lot more focus on code so is that a hindrance or is that a problem now somebody is telling you to go and change that code you did some changes to quote some people came up with other suggestions then you change that as well and and there's just so many much back and forth happening on the code reviews which causes frustration but believe me it's just there for going to be there for about a month or two at max post that you'll you'll get into the habit of writing code that is structured and that is actually good for you i mean like understanding how to write code that is of very high quality that is good for you what is going to happen though is like depending on what team you end up at your mnc the amount of impact that you were able to make at a startup versus the mnc that might go down but again it's it's it's dependent it's dependent on like which company you are at which team you are at uh so any uh so there's a question on any advice to freshers on what to focus on early in the career and an addition from my side but not to focus as well early in the career today's session was primarily on things that you should focus on what you should focus on and what not to focus on uh for example bad thing to focus on is is uh hindi make which is just like how flashy a company is but doesn't really focus on getting people the right amount of learning for the fresher i mean i would always say you should optimize on learning maybe you join a company and you figure out that the company is not helping me learn a lot so then you talk to people around you figure out a path on how do you get to the learning path but the first two or three years of your career the first two or three years when you join a job there are formative years that's when you are experiencing software development in a real life production environment for the first time and that's when you you start forming opinions that's when you start i mean imagine you're a baby and then like you're learning how to walk how to run how to stand you want that the people who are teaching you those things are the best people and the company where you're getting to learn all of this is best and you're learning the right things right like you are optimizing for learning a lot of times what happens is you go into a safe company but in the first three years you don't end up learning enough and then you see that there is a batchmate of yours who also has three years of experience but that guy actually knows a lot more than i do and then then that's not a great state to be in sure so the next question is what were the most challenging situations or tasks that you faced and were able to resolve in your professional life at facebook or interview bit uh at interview bit uh it is it was actually just dealing with people internally as well as externally i mean all of what i am able to tell you today is my learning from the past and i wish somebody had told me all of this before all of this i had to try and do and fail and then learn right for example the entire thing about the framework of giving feedbacks i have been at the other side where i've given feedback to people harshly just because i mean when things don't happen you get angry right and then you shout at somebody or you give them a feedback and a very very rude tone and then you realize after introspecting that that maybe was not the right way of giving feedback how do you handle i mean machines are easy to handle humans are not humans have emotions humans have aspirations so managing people that that was one thing which was extremely challenging for me who was um in general even the growth mindset that people talk about i remember there was a phase of six months even within facebook when i couldn't focus on the right things i would be focused on short-term things for example let's say i am leading the reliability and latency team for messenger so there there were occasions when i was focusing on slightly short-term benefits and i would just over-optimize for that i would spend a lot more time that was required versus not focusing on something which may be required a month to be to do but would have much bigger impact uh maybe it would have reduced the error rate to one tenth of what it was so prioritizing the right thing is something again which it took me time to learn slowly i i developed that i remember an incident actually from my college days uh and from the competitive days and like i was reading through some of the messages so i was able to see what changes have come so in my community programming days there was this quarter called triple m who was a very very helpful porter that person would actually help out everybody who would approach them i remember when i was i was just getting started i uh i just like some of the other quarters had reached out to him for help and figuring out why my code was not working and triple m was again very busy man so he wouldn't he did not reply uh after a while i again followed up the person replied saying that he doesn't have time and i wrote a very very harsh and rude message to the person it's now that i realized that maybe i i mean there is a better way of handling people there's a better way of giving feedback there's a better way of managing expectations i mean person was doing me a favor why should i be rude or harsh to the person so these are things that you learn with time my major learnings is handling people and uh prioritizing the right things long-term things other than short-term things uh so a question is what is the benefit of staying in a company for long period even when you are not getting much hikes are there any benefits to stay and what are the disadvantages of switching companies often if you switch companies often then you uh usually like let's say if somebody comes and interviews that interview bit i ask them what is the impact that they have made in the previous organizations the if you switch too often you'll never have a good answer to that question because you haven't stayed at a company long enough to change a lot of things you cannot say that hey actually i i worked at let's say growers for a while and i was able to increase their order volume by 20 or i was able to increase the number of people visiting the site by 10 by the changes that i did or i made the site faster by by 20 right you'll never be able to say that because you've never spent enough time uh understanding what is happening within and growth is just an example guys please do not quote me there i just took a random example so you never spend enough time within grocers to understand how things are working there and change things for the better but if you spend enough time then you're able to create these impacts and then you're able to talk about them when you go outside right it is okay if you're not getting hike initially but if you know a lot more than uh somebody else who might be at a higher salary uh then salaries would auto adjust themselves as i said like capability is the best job guarantee your current position is not there are ceos that keep getting fired here and there the ctos that keep getting fired here and there if they know the right things if if they are actually the best capable people out there then they get rehired otherwise they go out of job you don't want to be the person who goes out of job uh so question is how often should you ask feedback from your managers is there i mean like whenever you want or anything like that so i usually had the framework of i had set a one-on-one with my manager to happen a formal one-on-one every two weeks so every two weeks i had reserved this 30 minute slot on the my managers calendar where i would make sure that i talked to my manager for 30 minutes and the theme of that was talk to me about things that i'm doing well talk to me about things where i need improvement and again like restressing on the fact look i want to move to the next level what should i be doing what am i doing wrong what am i doing right tell me uh what else should i be doing so the whole reason why you want to do this is because you never want last minute surprises you might believe that i am performing really well you do not want that at the end of the year or in six months whatever is the frequency of review your manager comes and says hey actually you were a bad performer you don't want that happening you want your reviews to be as surprise less as possible whatever the review you knew it was coming because you've been talking about that for the last i mean every two weeks anyhow uh okay so let us take the last question for today before we end so do you suggest a depth first methodology to learn basically go into depth of each topic system design a programming language even data structures and algorithms or a breadth first approach is better i mean like have a high level overview of multiple topics but being master of none uh actually they're both kinds of engineers and and both end up doing well there are people who specialize in something in the sense that there are some people who become let's say a data engineer or a systems engineer or if well even within front engine like specific on on the certain tech stack and at the same time there are engineers who you would call as generalist both are in demand both are good positions to be in but do whatever you're doing either depth first search your breath first really well i mean it's don't go half-hearted at any of those even within breadth first search there's one caveat make sure you know enough do not i mean there's a phrase in in uh in general when explaining things which is called hand waving uh hand waving means that you know of certain uh terms certain fancy terms and whenever somebody asks you a question you use those fancy terms to explain without really understanding what is happening beneath so if you know less that is okay but whatever you know you should have very solid knowledge on it always question what is happening and never have superficial knowledge where you're just hand waving even within breakfast you need to manage that too so both approaches are fine as long as you're not doing hand waving in any of those approaches sure thanks a lot for taking out your time today uh i know it's a weekend and still you took our time thanks a lot so thank you guys for uh listening to us we will be posting the books and the other resources in that comment soon and yeah have a good night and enjoy bye good night thank you so much thank you so much guys for for being patient with me and bearing with me through this session definitely uh the advices that you gave today would definitely help me in my career as well and hopefully to the listeners who all saw this video thanks again very quickly introducing what we're going to cover today right so today we're going to talk about sorting and why is sorting important i mean sorting is essentially nothing but arranging data that you have in a particular order right for example if i have a few numbers i could say i want to arrange them in in an increasing order or if i have people let's say i want to arrange them in in the decreasing order of their height or increasing order of their height etcetera the ordering because you are able to order something helps you in a lot of things for example sorting might then help you do binary search on that data if you want to look for something or if i give you queries around hey tell me how many numbers are bigger than a specific number that also i mean if the array is sorted you can just look for the index of the element first element bigger and then you know how many numbers are bigger etcetera so sorting helps in those contexts if it is ordered in fact most nosql dbs they actually try to maintain data in a sorted form sorted set is is what it is called because it makes searching for data looking for data doing bunch of analysis on data easier and easier right so today we're gonna just to elaborate we're not going to talk about searching searching i'm going to talk more about sorting sorting is arranging data in a particular order right so for example if i let's say give you five numbers i give you numbers let's say five ten three two and eight these are numbers in no particular order right now if i say arrange these numbers in an increasing order where all i mean the smallest number comes at the front of the list and then so forth that part is called sorting so i mean if you sort this then you'll have 2 3 5 8 and 10. it's an arrangement of the given numbers so that they are in some particular form or order as i said like the reason why it is important is because it helps you do a bunch of different kind of operations on the data fairly quickly if what you have is sorted and i gave the example of nosql databases where they maintain data in sorted sets because it lets them do a bunch of different kind of queries in a sorted form in fact we will talk about some form of mapreduce when we go to a system design modules there also you'll see like a lot of things are generated in sorted forms because it allows for for certain more operations to happen later on does everybody understand like what sorting is so maybe like the way i would explain sorting is taking a just like in binary search i took the real world example of searching in a dictionary what we normally do in real life i'm again going to be taking the example a real life example of what we might have done in in our lives before right all of us went to school and in school we were made to stand in increasing order of our heights now let's take that example which is i have a class full of people and i want to arrange them in increasing order of their height right now assume they are standing in some random order what are the different ways in which i can actually arrange them in increasing order of their height and i'm going to take various sort of approaches i would have taken and then i would sort of map it to what that approach is in real life so approach one approach one could be that i ask everybody to come one by one and i mean let's say if i have a few people already standing in the line let's say i have a few people that have already arranged in the line and let's say there is this new guy with this height that comes in fact it is better to imagine i mean maybe i can write the height of each of those individuals let me just write the height so imagine i had somebody with height 1 5 12 and 27 already in the line somebody with height 7 comes one thing which i can do is i can find the right position for this person which is between 5 and 12 and i insert 7 there which means then i'll have 1 5 7 here and then 12 and 27 i'll push one space back right so 12 comes here 27 comes here right and then as people keep coming let's say there is a person called 32 i'll figure out where 32 should lie here i'll figure out 32 should come here i'll insert 32 here everything up after 32 would be pushed one space back to make space for 32 here there is nothing this is called insertion sort this technique where i get numbers i figure out what is the right location for them i can do that through binary search or i can do that through a linear scan either is fine once i find out what their location should be i shift all of the other numbers one space to their right and then insert this number new number at the new location now that is called insertion sort if i have to write the approach for this or the steps for this basically assume that i am maintaining my sorted array in let's say sorted array list that's a sorted list which is initially empty and imagine i keep getting a few numbers right what i do is i start from the end of this list for example here if i had 1 5 12 and 27 and i wanted to insert 7 i'll start from the end is 7 already bigger than 27 it is not so what i would do is i'll shift 27 one space to its right so imagine this was the array i have one space left here so i'll shift 27 to its right so 27 comes here then i go and again check 12 is 12 i mean is 7 bigger than 12 no it is not so i'll shift 12 to 1 space to its right 12 comes here then i check the next number which is 5 is 7 bigger than 5 yes that means this is the location of 7 and i insert it here that is i keep doing this with every new number that i encounter and that makes for what is known as insertion sort what is the best case complexity here best case time complexity here and what is worst case time complexity here best case for sorting order one would be the time complexity of inserting a new element best case right because you you start with seven you'll find that i mean let's say the new element that we are inserting in this new array let's say that is best cases i look at the first element and i find that 32 is bigger than that and therefore 32 just gets inserted here it is for the addition of the last like the new element order one is the best thing that you can do but you will have to add n such elements so therefore if you do order one for n elements you will end up with order n best case complexity so in the best case insertion sort will take order n time what is the worst case when do we get the worst case what is the worst case and when in what kind of data would we get worst case if the array was reverse sorted which means if let's say i was giving you numbers i first give you number five you insert five then i give you four you insert four here right because you'll have to shift five five one then i'll give you three you'll figure out that actually three is smaller so you'll shift five here and you'll shift four here and then three comes here then i give you two you'll again like shift five here you'll shift four here you'll shift three here and then two will come here and then again you'll do one more shift and to get one in if i one is the next number right this ends up taking i mean for the first number you take one step for the second number you take two steps for the third number you take three and for the fourth number four and five and six and so forth this becomes almost order of n square so worst case this might take order of n square when when the numbers are sorted in decreasing order a very interesting question which is does the time complexity affect if we take linked list there are two parts here right like one is i mean there are two things that we're looking for one is what is the right index where this new number should go and the second is shifting shifting greater numbers to make space one place right right so your linked list will save you on this time so this time will become zero however finding this one in a linked list because you can't really jump to a random location you'll have to do a linear scan to figure out where the number should occur right so you that might still end up taking order of n square because searching for the right index the step number one that might end up taking order n you can't apply binary search in linked list because you can't just jump to a random location in the list right now the way i explained insertion sort was that you were getting a stream of numbers and then you're sort of sorting it by putting them in the right location now whatever i said that can also be applied to an existing array as well let me explain right now the way i detailed insertion sort is by saying that you know what like five i am getting five then i'm getting four then i'm getting three then two then one imagine i was already given an array right so imagine i had the array as let's say 5 8 3 2 18 hypothetically right and i asked you to sort this array in place without using extra memory i do not want to use any extra memory can you sort this array without using extra memory insertion sort so i don't again have the flexibility of creating a new array i am doing this in place how do we do that in place even when you're doing in place imagine i start from five right so first i'll start with five i'll say i only have to sort this five is the new number that i've gotten right so i have one place five is a new number i've gotten obviously it will go at this position so five comes here then i go to the second number and i say let's put this in a temporary variable temp is equal to eight now eight is the new number i'm trying to insert in the first two locations right so first i'll compare with five is eight already bigger than five yes it is so it will come here then i look at sorting the first three numbers i pick three so i delete three from here imagine and it is this 3 is the new number to be inserted so first i check with 8 is 3 bigger than 8 no it is not so 8 will come here is 3 bigger than 5 no it does not so 5 will come here and then 3 gets inserted here so now if you look i mean by now i have the first three numbers sorted now i'll take this number 2 which is i'm trying to sort the first 4 numbers i'll take the new number 2 and imagine that 2 is the new number that i was getting so i put this in a temporary variable and do the same comparison is 8 no so 8 comes here is 2 bigger than 5 no so 5 comes here is 2 bigger than 3 no so 3 comes here and then 2 comes here and then finally 18 is bigger than 8. so 18 will directly come here does that make sense so same approach all i'm doing is i'm saving on the additional space if an array is given to me already the worst case time complexity is still the same nothing has changed in the approach i'm just using the same space that was there in the arrays instead of creating a new array okay so if we apply binary search for position it will contain more computations like finding plus swapping yes if you do apply bind research you will first take login time to find the right location and then in worst case order n extra time to create the space i mean right shifting all of the elements to create space for this other element right so it will end up taking n plus log n every single step instead of just n every single step so this log n is additional overall time complexity will still remain n square because you'll do this n time so instead of n into n you'll get n into n plus log n which is basically n square plus n log n which is still order of n square but why do that i mean why do this additional operation why not just start from the end you have to shift the bigger elements one step to the right anyway just start from the end shift the elements to the right and then like fit the element wherever you find the first place all right everything clear till now so that is one way in which you would sort let's say your classmates right the second approach that i have is let's say i have an array right like let's say the same array i had in fact let me go with the original 5 10 3 to 8 so 5 10 3 8 and i put this in an array now what i know is that in the sorted array the smallest number has to come at the beginning of the eye do we all agree with that smallest number has to come at the beginning of the array right so one thing that i can do which is not very optimal but still works so this every single time i look at what is the minimum in my given array for example if i run this loop i'll figure out that 2 is the minimum i say ok great if 2 is the minimum let me push 2 to the beginning of the array so 2 comes here and then i can just swap it with five so five comes at the place of two so when i do this two comes here five comes here now what i know is that now two is at the right position i only have to sort the remaining four elements and i repeat the process i for the remaining four elements i again look for the minimum find three so i swap ten with three and then i sort the last three elements and then again like i look for the minimum five i put five here and then so forth right the only downside of this approach why this approach works the only downside is it is order of n square no matter what the input so the best case worst case everything is order of n square the good thing with insertion sort was that there is a case where the best case was order n so therefore the average performance could have been better if we do this it is always order of n square i mean basically the steps were find minimum two is put in start of array and then start plus plus that was the approach if the array is already sorted even then to find the minimum in the array you'll have to look at all n elements so every single time finding the element is taking your order n right so that approach is a precursor to bubble sort so while this approach works the question is can we do something so that if the array is already sorted then we don't have to go through all of the elements all over again right like every single time finding the minimum takes me a lot of time how do we decide when to break check whether the array is already sorted or not let me maybe give some other case right so insertion sort will still be order n if let's say only one element was not in its right position every other element was in the right position for example if the array was let's say one two three four zero the array is just very simply some random elements bubble sort is a variation of exactly this bubble sort is as the name suggests it is like bubbling something to the top right so what you do is you compare all adjacent elements one by one and wherever you have a pair of numbers so what you do is for example let's say people are standing and in some random order in the line right so for example i have people standing as 5 10 3 to 8. let me just write it like this 5 10 3 2 8. my objective is somehow bubble this the smallest number 2 to the top so what i do is i say the last person standing in the line hey you compare yourself against the next person to you you obviously know how to compare yourself against the next person you can check your height versus the other person's height obviously if you're standing behind and you're smaller then you should swap yourself right so i say eight look at 2 if you're smaller than 2 then swap yourself it says i'm not smaller great then i said 2 look at the next person ahead of you if you're smaller than that then swap and i do see like 2 or 2 is smaller than 3 so i swap so 3 comes here 2 comes here then i say 2 swap yourself against the next person if the next person is smaller i figure out 2 is actually smaller than 10 sure i mean should get swapped so 2 comes here 10 comes here and then i again say 2 again compare yourself against 5 if you're smaller swap yourself so 2 again gets compared with 5 5 comes here 2 comes here so what has happened in this one order n loop the smallest number has bubbled itself to the top of the array this is why i mean because the smallest element is bubbling to the top it is called bubble sort even this approach in the worst case will take order n square there is one difference here though if there are no swaps that happen all throughout in this order n loop then we just stop there which means if the array was already sorted then we would not do the next iteration we'll keep doing the next iteration as long as there is swap happening so let me elaborate again what happens is imagine you are standing in the line i start from the last person i say compare yourself against your neighbor you compared yourself against the neighbor if you are smaller then you swap yourself and then you do that till the start of the array one thing which is guaranteed in this loop whatever is the smallest number will bubble up to the top of the array then you're left with sorting only the remaining part of the array and you also know if there is any iteration where i went from the last person to the first person there was no swap happening between the neighbors then i know that elements are already in the increasing order i can just stop i do the same process again now two i don't care about i already know two is in the right position for the remaining elements so i again start from eight i say eight are you bigger than three eight will say yes i am and i said three are you bigger than ten no i'm not so we'll swap three comes here 10 comes here three are you bigger than five you're not so sure i mean then let's again swap so three comes here five comes here again if you see three has bubbled up to the top which was the next smallest element and then you're left with sorting only the last three elements any iteration where you don't have any swaps your array is already sorted you can just stop since we had one or more swaps in the first traversal we'll start again from eight but will not go till two two will be ignored i mean the first element is already sorted so we'll be you know we'll stop here now that in the second iteration we know that the first two elements are fixed we'll start again from eight but we will stop at after three i mean we'll not look at three and two anymore because we know that they are in the right position every single iteration what is happening is the smallest element is bubbling to the top and any single iteration i know that there is no swap that has happened i can just break and therefore i do have a best case complexity which is if the array was already sorted i will do an order and iteration to figure out are there any swaps but post that order any iteration i can just break or if i reach a stage where intermediary stage where let's say i did these and then the remaining numbers were already sorted then also i'll just break right so i'm not really spending time sorting if the array is already sorted does that make sense let me actually write the pseudo code for this what i'm going to do is i'm going to start so here is my inner loop right so i'm going to i'm going to start from the last element let's say there is a j that starts from n minus 1 goes to imagine i'm doing a loop of i from 0 to whatever i'll tell you what 0 to whatever is it goes to i imagine that like numbers still i are sorted right now nothing is sorted so n minus 1 to i what i do is here i compare a of j with a of j minus 1. now i know that in the right order a of j should be bigger so if it is smaller if there are two numbers where the second number is smaller then obviously they should be swapped the second number if it is smaller if this is smaller then they should be swap because they are not in the right order so i just say swap a of j comma a of j minus 1 right by the end of this a of i will have the smallest element anyhow i is starting from 0 af i will have smallest element anyhow i also keep track of one variable here has there any swap that has happened let's say there is a flag which is initially zero i just whenever there is a swap that happens i make flag as one if at the end of it if i see that flag is zero then i just break which means this element was already sorted there is no need to look at other elements and then i goes from 0 to n minus 1 yeah sorry this is i plus 1 correct so again like what is happening in the algorithm is the smallest element is bubbling to the top and you're just taking in the process making sure that if the remaining elements are in the right place there was no swap then the element is all i mean array is already sorted so let's just break yeah i mean actually we don't need the n minus 1 when we come to n minus 1 i plus 1 would anyhow this j loop will not run so i can just do n minus 2. again let's let's look at what is the best and worst case complexity of this algorithm best case is order n which is my array was already sorted or almost sorted and then i mean i do the situation flag becomes 0 i break and the worst cases when it is reverse sorted so i every single time i have to do all a lot of these swaps and that is actually order of n square all right so this is by the way called bubble sort find the smallest element move it to the beginning this is called selection sort in selection sort as well you could be it's what we were discussing where we were selecting the smallest element and moving it to the beginning of the array that is selection sort the reason why we are discussing this is these are intuitive ways of how we think about sorting and the technique can be can come into use later on let's do a dry run with with bubble sort just to see the best case right so imagine i asked you to sort this array one two three four five imagine this was my input correct my nikkei selection sort is sort of an led algorithm because what you're doing is you're saying that i know the smallest element should come at the beginning so let's find the smallest element you put it in the beginning and then you sort the remaining array let me however show like how the bubble sort is still best case order n i mean selection sort by the way we can also make order n in one case i'll also go over that selection sort this slight variation and it can become best case order n let's first look at how it becomes order n best case in bubble sort imagine this was your input right you start with i as zero i is zero j your flag is also zero j basically goes from so you have your index one two three four j will start with four and it will go till one four till one and what do you do every single time you just compare a of j with a of j minus 1. so you hear you check is 5 less than 4 the answer will be no so then you move on to the next j so from 4 you will go to 3 from 4 you will go to 3. then you compare 4 with 3 is 4 less than 3 no then you'll compare three with the previous element which is three less than two no it's two less than one no so at no point this if condition gets executed so there is no swap and therefore flag never becomes equal to one so when this loop finishes when the j loop finishes you come to the point where flag is still zero and therefore you break so just after the first iteration with i zero you end up breaking because you figured out there was no swap involved in my error so my arrow is already sorted why should i look at things again so that's why you get the best cases order n worst case is obviously n square now let's look at what is the case or like how do we make sure that even my selection sort which is like very greedy like can i modify it somehow so that that also becomes or best case order n let's see let's take some random input right so i had five three eight four six now the way selection sort works is you go from the beginning you look at this you try to find the minimum element in the array this is the the approach just before bubble sort that i had talked about you try to find out the minimum element in the array in this case i find three as a minimum element and then for this i take an order n loop right in order n i find minimum of the array now if in this iteration only i would have figured out that the array is sorted in this order n if i figured out that the array is sorted which is all of a i is less than a i plus one then my work is done however if it is not then the smallest number that i found which is three i try to swap it with the previous element basically i i try to put it here and shift all of the remaining numbers one step to the right which means the array now becomes three here i have five eight four six in fact let me just change the array a little bit so that it becomes slightly better imagine if the array was four five six eight when i do the swap then the array becomes or when i push it here then it becomes three comes to the beginning and then i have 4 5 6 8. now again i know that at this point of time 3 is at the right position i still need to sort the remaining array i'll again have to do an order of n minus 1 loop this this and this to figure out the minimum number in this case it is 4 as the minimum number but by the way in this order n minus 1 loop i figured out the array is already sorted so i can therefore stop my process the key thing to do here is when you find the minimum element you don't just swap but you shift the prefix of the array one step to the right create space for this new element and then you put it in the right place if you do that then i mean the selection sort also becomes best case order n one thing is i mean in most cases you will neither be using bubble sort or a selection sort or insertion sort actually insertion start may be in certain cases but most cases you'll not be using these these are algorithms that that are good to think about the approach that we utilized here this might come into use later on in some of the other kind of context and some of the other kind of problems but the sorting algorithm that is currently in use in most of the libraries that you use are either merge sort or quick sort quick sort as being the most popular one because it has better average performance does not use additional memory but those are the ones because they sort of perform in order of n log n time all of these are worst case order of n square average case is also order of n square almost java 8 array.sort also uses quicksort but like bubble sort insertions or three algorithms that i talked about they're good to know from their approach standpoint because there are some problems that might utilize this approach these are not necessarily the sorting algorithms you will use in day to day sorting algorithms that you will use i'll talk about that in a few moments but just so that i again complete my discussion on selection sort let me write the pseudo code for selection sort sudo code is very simple right now if i have to sort imagine when i is 0 i need to sort everything from 0 to n right so what i do is i take this will go to some number and figure out what i'll take the loop from i to n i'll figure out the minimum in fact let me actually also track its index i can just keep it as a of i and index is equal to i and this loop can run from i plus 1. so if let's say a of j is less than min 1 then minimum is equal to a of j index is equal to j here one of the other things which i also track is if a of j is greater than a of j plus one then there's a flag that i set to let's say one let's say there's a flag here which is also zero and once i have found my minimum then all i need to do is all of the other numbers they are shifting one space to the right so i again once i have found the minimum i will take a loop of j is equal to and then at the end you have a of i is equal to minimum that is one way of shifting basically what i'm doing is if i have an array let's say i have 5 six three two eight i'm going through once to figure out what is the minimum once i find the minimum i bring minimum to the front which is two comes here and then five six three i shift one space to the right and then i try only sorting this piece where every single time i have flag to check is this piece already sorted or not if if at all at any point of time i find that there is a section of array that has already sorted then i just break out and and i'm done here i mean i could very well also have done instead of doing all of this i could have done swap a of i comma a of index i could have done this as well as long as i'm checking that for the remaining array is the array sorted or not if the array is sorted then i just break that is the only optimization that i put in nothing else now i'm going to be covering a few other sorting algorithms and then we'll do a few problems on these count sort is the easiest one count shortest when the elements that you are sorting they are limited in range limited in range meaning for example i tell you hey you have characters a to z you have a lot of characters and you need to sort them or you only have numbers 0 and 1 or you only have numbers from 1 to 20. then what you do is instead of counting or basically maintaining like numbers themselves you just count how many numbers for example i gave you an array of zeros and ones right so bunch of zero one zero one one one zero etcetera and i told you to sort this array one very simple way would be i calculate the frequency of zero and frequency of one which is basically exactly what count sort means right like you're maintaining the count of the numbers themselves so you you say like i'll count how many times 0 came let's say 0 came 10 number of times and i'll count how many number of times one came let's say it came five number of times then i know my sorted array my sorted array is zero zero zero zero zero ten times and then one one one one one five times so one very common application of this is if i give you two strings and i ask you are these strings anagrams of each other anagram says like two strings are anagrams if they are just some or the other permutation of the same string for example if i give you a string banana and i give you another string let's say this is not really a word but i give you these two strings right and i ask you are these anagrams of each other your answer will be yes because they have the same count of n there are two n's here there are two n's here they have same count of a they have three a's here there are three a's here and they have same count of b you know that you only have 26 different characters so in a 26 array array of size 26 you can maintain the counts of number of a's number of b's number of c's and so forth and you can just compare the counts right so count sort is very simple if you have limited number of numbers if your range is very limited you maintain the count of every single number you encounter and then like you just print those numbers those main number of times you go from start to beginning so we are going to maintain a new array for zero and one however zero and one are just two two numbers two variables so it is still order one space if you only have let's say 20 numbers then it's just order of 20 space which is not order n like it is not dependent on the number of numbers that you have in total and let me maybe give you an example right and then i'll write code for it that will make it clearer very simple imagine i gave you a string of characters a string of characters and i just asked you to sort that string of characters for example let's say the string is congratulations let's say that is a string and then there were a bunch of bunch more characters as well but like let's just say that this is the thing there could be less of thousands and thousands of characters here thousands hundreds of thousands of characters now one conventional way of sorting is like doing the bubble sort or the selection sword etc right if it's a selection sort would be you figure out which is the smallest character which is a you shift a to the front however i mean if there are a lot of characters that will take a lot of time so what i say is hey by the way i know that the kind of letters could only be from a to z correct i have a b c d e f till z correct there are only 26 characters possible 26 different characters possible so if i somehow maintain the character count right i have only 26 characters if i have an array which has the count of what are the number of a's here what are the number of b's here c here and so forth for example when i encounter c i say let's increase the count of character c by one so c's count becomes one and i mean this is this could just be an array right because any character can be mapped from a number from 0 to 26. so i just maintain an array of size 26 which is all initialized to 0 to begin with when i encounter c i increase the count of c by one then encounter o let's say os somewhere here i increase the count of o by one when i encounter n and increase the count of n by one with r i'll again increase the count of r by one a a will become one let's say when i encounter a again here a's count will become two so that way i mean i'm just maintaining count of every character right like and if i have to write code for this i would just do very simple i would say that you know what like i have a array of size 26 which is initialized to zero this is c plus plus format but like java etc it will be similar and then i just say you know what like let's assume that the character is ch and i go over this string str and i just say that ar ch minus a which will now give me a number from 0 to 26 plus plus at the end of it i'll have frequency count of every character and then like sorting is very simple i just go character by character right so i just go from for i is 0 to 26 i look at the count of the current character like for example when i is 0 then i'm looking at the count of a so what i do is i take a loop from 0 to arr of i whatever is the count and i print a plus i those many number of times so what will happen is if the count of a was 2 then this will print a twice then let's say if the count of b was one then it'll print b if let's say the count of c was three then we'll prep c three times and so forth so all i'm doing is i'm just counting the numbers frequency of the numbers and then i'm just printing in them those main number of times going in the order of numbers does that make some sense count short how is it working as long as the range is limited for example let's say if if you have numbers from minus 20 to 20 even then you can use the array right because you can just say that every single number num corresponds to the index num plus 20. so when you encounter num you just say you know error of num plus 20 plus plus and when you print then like for arr of i is count you print i minus 20. in general if you see for doing this if you have a range of numbers let's say the range is r count sort takes order of r memory right if the range from min to max of the array if the range max minus min if this is r then it takes you order of r memory right because you need those very number of counts variable right if r is small small ish for example let's say if r is thousand or ten thousand or hundred thousand or one million if let's say r is up to one million then you can use count sort because you can maintain the counts and therefore like it will still run however let's say if the numbers were not limited if there could be any integer then you can't use count short count is only applicable when the numbers are limited in the range as i showed with counting characters in a string because characters are limited characters can only have 26 different values so it is not done in place in the sense that you're still counting the number of a's number of b's and c's and then you can fill it in the same array for example if you said tell me here instead of printing a plus i i can just say you know what let's have an index variable which is zero and i have let's say my original string was str i can just say you know what str of index plus plus is equal to i plus a i can fill it in the same array instead of printing but i mean you'll still have to maintain counts etc merge sort is if imagine you had to sort a deck of cards one possible way which is by the way also called divide and conquer could be that i break down this deck of card to half deck of card and half deck of card so i divide into two parts right like half goes let's say to the left half goes to the right i sort those individually right so half deck of cards i sort them somehow by some magic and right side also i thought somehow by some magic so now i have two sorted deck of cards right i have two sorted deck of cards now the problem becomes if i have two sorted deck of cards can i merge them so that they still remain sorted imagine let me give you an example right so let's say i have an array two three five let's say i have another array one six eight if i was given these two arrays can i merge them into another array which is completely sorted is that possible or not if that is possible then this could become another algorithm which is like whenever i need to sort an array i can divide into two parts recursively sort them and then i can merge them so merge becomes the important step the question is i have given you a problem you have two arrays not necessarily of the same length let's say this is of size a this is of size b can you create another array of size a plus b where all of the elements come from a or b and they are all sorted is the question player like you have some a number of arrays in array a you have b number of elements in array b array a and b are individually sorted so a is a sorted array b is also a sorted array you have to merge them into another sorted array how would you do that basically if i have been given two numbers let's say i have an array a two three five and i have an array b which is let's say one four eight and i have to create a sorted array right which is of size three plus three which is six one two three four five six correct this is the eventual sorted ad i have to contain or create one thing is the first element in the sorted array is going to be the completely minimum of all everything in the array right so given array a is sorted minimum from array a is on position number zero correct minimum from array b is also on position number zero so therefore whichever is the minimum of these two i don't need to look at any other element whichever is the minimum of these two is going to be the first element in the sorted array is that something we all agree with and what is the minimum of these two minimum of these two is one so one comes here now if i have inserted one here and it is as good as saying that now i remove one from b it is the same thing right so what i just do is how do i remove one from b i just change this pointer to now point at this number four this is as good as saying that i'm now merging two arrays one array which is a and one array which is b but b is starting from this point onwards and i again do the same thing what is the next number that should come here it should be the minimum of numbers here and minimum of numbers here what is the minimum of numbers here array at this pointer what is the minimum of numbers here the array at this point whichever is smaller which is 2 comes here and this pointer moves one step forward so in short the approach becomes that you have two pointers let's say there's a pointer one which is for array a there's a pointer two which is for array b and you just say the following while pointer one is less than whatever is the size of a and pointer two is less than size of b you do the following you figure out which one is smaller you just check if a of pointer one is smaller than equal to b of pointer two then simple this is what goes in the sorted array so let's say sorted off let's keep an index a of pointer one you increment the pointer one plus plus because now pointer one has been assigned here else you put pointer two element here so sorted off again index plus plus is equal to b pointer two pointer 2 plus plus the only thing is when i'm done with this while loop it is possible it is possible that all of the smaller elements are in one of the edit imagine like this array was 1 2 3 here and there were let's say 4 5 six here my pointer one will end up going here and i'll end up breaking out where i've only filled in one two three in the sorted array four five six is yet to be filled so i'll have to check for that which is at the end of this while loop if whichever pointer is is not done so i just check while pointer 1 is less than size a i just keep adding sorted of index plus plus is equal to a of pointer one plus plus and very similarly i do the same thing with pointer two while pointer two is less than size of b same thing sorted b of pointer to plus plus right that will cause the merge to happen does this make sense right now if that can happen which means now if merging can happen and what is the time complexity of this merge imagine i have two arrays of size n and n h m plus n n plus n right like so it takes me order n time to merge if in fact the array a was of size m this was of size n it takes me order of m plus n time right that means if i have a order n array to be sorted if i divide it into two parts i say that sort first part separately sort the second part separately once they are sorted then merging them will take me order of n by 2 plus n by 2 time which is order n time so merging them will take me order n time now how do i sort the first half of the array i can do the same thing with the first half as well i can say that even to sort the first half again break it down into two parts and then sort the first half or the second half merge it with the end condition being that once i have an area of only size one it is already sorted how about i modify this and i say that i have three arrays that need to be merged right imagine i have a 2 5 10. imagine there is another array 1 8 9. and imagine there is another array 3 4 12. let's say there were three arrays right how would you merge these three arrays into one array which has all elements are sorted we can do two at a time but we don't necessarily need to right like we look at this right what is the first element going to be in the merged array it is the smallest of all where does the smallest come from it is either the first element from here or the first element from here or the first element from here whichever is the minimum from here that becomes your smallest so i can have three pointers pointer one pointing to the zeroth element pointer two here pointer three here whichever is the smallest of these three which in this case is one one comes here and then all i do is i move this pointer one step to the right and i again repeat the same thing whichever is the smallest of these three which is two two comes here and then two's pointer moves one step to the right now again five eight three whichever is the smallest three is the smallest three comes here and 3's pointer moves to the right 5 8 4 4 is the smallest so 4 comes here and its pointer moves to the right 5 8 12 5 is the smallest so 5 comes here and 5's pointer moves to the right and then so forth right in the case of merge order there is only two arrays an extension of the previous question then instead of two if there were three arrays how do you go about merging three arrays i mean you can merge two arrows at a time you can merge these two at a time and then you end up merging these two but you'll end up using more memory because to merge these two you'll need an additional array of size six then you'll create an array of size nine what i'm doing is i'm just directly creating an area of size nine so that i reduce the amount of memory required to maintain that intermediate rearray also i reduce a step okay all right coming back to the merge sort how does merge sort work as the name suggests it's divide and conquer which is basically now that i know that i have the superpower of taking two sorted arrays and merging them what i can do is i given an array a i sort the first half so sort a to zero to n by 2 sort a of n by 2 plus 1 to n and then merge these guys that can become my approach and this how do you sort the first half this also can happen in the same way where you again divide into two parts 0 to n by 4 and then n by 4 to n by 2 and again then you merge et cetera right and if i have to write code for this it becomes fairly simple which is let's say if the array if the question was how do you sort array a from index i to index j if if obviously like the size of the array is already 1 which means if j is equal to i let's just put that then your array is already sorted so you can just directly return if not then what you do is you basically sort the first half which is you say i'll go from a of i to mid where my mid is i plus j by 2 then i'll sort a from mid plus 1 to j and once these two guys are sorted then i will need a temp array where i'll merge the array from i to mid and mid plus 1 to j and then i'll make sure that a of i to j becomes equal to 10. i'll just do that but basically i'm just applying recursion here and what i'm saying is if you want me to solve by the way let's say there is there are four numbers right five three two six let's say those were the four numbers i say that first sort the first half so let me call the function to solve these two numbers five and three somebody sort this and then give it to me and then sort the second half separately so somebody sort two and six and give it to me and once i have them sorted then i will actually merge them right now to sort five and three i again do the same thing i split it half i say somebody sought five for me and somebody shot three for me here also and somebody saw two for me and then six for me once they are sorted then i'll merge five is sorted three sorted how do i merge in my merge step the same way we have seen we have two arrays we have to merge when we merge this will become three five and that is what i replace my original array with so this array becomes three and five very similarly 2 6 remains 2 6 and then once i have 3 5 and 2 6 then i merge them to find 2 comes first then comes 3 then comes 5 then comes 6 and this becomes my actual sorted array which i replace this with just out of curiosity why do we divide them into equal halves although in the end we move two single elements and merge them in sorted order can't we take pairs in the array and do the same way of merging let's say i have more numbers right so imagine i had 5 6 8 1 2 13 15 12 3 how many do we have we have four and let's imagine i remove 12 from here question is if we have to sort any way why don't we take pairs by pairs right so let's let's just take pair 5 6 8 1 2 13 15 3 and let's just first sort them so we we end up sorting them and for example we end up finding that this is 5 6 this becomes 1 8 this is 2 13 and this becomes 3 15 right now the problem is like we've done pair by sorting but the array is still not sorted then we will have to do sorting of four four elements each right how do we do that we say that you know what like there are first four elements here the first half is sorted the second half is also sorted let's merge somehow which again i'll take another array and then i'll merge etc so this will get sorted then i'll do again the same thing which is i take four elements half is sorted half is sorted and i'll do the same thing and then finally i'll look at all of the eight elements so you're going just in the reverse order what i just said you're just going in the reverse order which is also correct it's just a harder to code because the previous approach can be coded using recursion which i'll just show uh in your approach what you're doing is you're building bottom up right like you're sort of saying that let's first sort all pair of elements once they are sorted then let's look at all four size elements great once they are done then let's look at all 88 size chunks once they are done then look at all 16 size chunks and then 32 size and then 64 and so forth right then finally i'll have the entire array sorted which works it's just harder to quote what i said was the other way down that instead of going from 1 to 2 to 4 to 8 and so forth let's start from n let's divide that into n by 2 parts then n by 4 then n by eight and i'll finally reach the one part anyway and then my recursion function will keep returning and i'll have the eventual answer so if you look here my recursive function this will do the same thing my recursive function here will also do the same thing let me also just write it as merge step so what is happening is if i have an n sized array i'm dividing it into two arrays of size n by two each and by two each i'm sorting it using the same methodology which is this n by two will create arrays of size and by four and by four here also again same n by four and by four these will create arrays of size n by eight n by eight again n by eight n by eight same thing and this n by 16 and by 16 and so forth how many levels will you have here i mean we go from n to n by 2 and by 2 and by 4 and by 8 4 to n by 8 and by 8 to n by 16. how many levels log n levels right so in every level n is becoming half of what it was as we have seen the same pattern in binary search etc etc i mean as you go if n is becoming half what it was it takes you log n steps to finally come to one at every step what is happening i at every step basically i have n by two n by two sorted array i'm merging them which takes me order n time this takes me order n time n by two plus n by two i order n what happens on this level these two guys merge and takes it takes them n by four plus n by four which is n by two time these two guys merge and it takes them n by two times if you add them up it will take you order end time on this level as well very similarly on the other level as well where you have n by eight there are eight instances of n by eight it will again take you order n time so the total time taken on every level it takes to order n time there are login levels the total time taken is n log n that is an intuitive way to understand i can also explain the mathematical way of explaining this but the intuitive way of understanding the time complexity of merge sort is that on every level you're doing one merge the merge is order n number of levels is log n and therefore in fact if you look at irvine's approach if you were to implement it in every iteration what you're doing is you're first creating pairs and you're merging the pairs takes you order end time then you're looking at all four four blocks right like blocks of four each in one order n operation you'll have sorted blocks of four each then in again one order n operation you would have sorted blocks of eight eight each and you'll keep doing that till you cover the entire array so the number of steps to cover the entire array would be log n and every single iteration is an order n iteration so it takes you in order of n log n i can explain the math behind it as well is it n log n in every case best case is sure i mean you can probably put an optimization that the array is already sorted if a half is already sorted you don't need to do all of the splitting etc so best case you can still make order n but yes worst case is order n log n worst case it takes you order n log and you can put a check to make sure that you're not doing the entire splitting etc if the array is already sorted all right what is the space complexity of merge sort so if you look at the implementation here we are allocating this additional memory temp to calculate this merged part right why because when we are merging to sorted arrays we need this temporary space where we put in the result which is not a part of the original array this is additional space if i have to look at this tree in this n by two part i would have taken a temp array which was of size n by two here i would have taken a temp array which was of size n by two in fact let's look at total space allocation right so this n by two will make a call to n by four eight etcetera etcetera so this this is a login stack memory space plus in each of these so imagine i was sorting this array of size n this will end up calling for n by two this will end up calling for n by n by 8 and so forth in each of this i would have a temp array allocated which will be freed as long as i mean i fill it back right so this temp array here is of size n by 4 as soon as i am done then this will be freed then i come back here here it will be of size additional size of n by 2 as soon as i am done it will be freed and then i will come back here and i will have a temp area additional size n so maximum space that i end up using additional is i have log n stack of recursion plus i have this additional order n size array that i might have used which is my temp array so order n extra space is what we end up using apart from the array space so space complexity becomes order n time complexity becomes order of n log n there's one more way to by the way calculate time complexity i mean if you assume that the time taken for sorting an array of size n is tn then tn is nothing but i'm saying first sort array first half of the array then sort second half of the array which is also size n by two and then merge them which is it takes you some n time let's say let's say it takes you one time this is basically saying two times t n by two plus n right if you break it down further your n by 2 is 2 times t n by 4 plus n by 2 which is the same as 4 times t n by 4 plus 2 n which you'll see will finally come to two to the power i t times n by two power i plus n into i i mean this is just a little mathematical therefore i explain the intuitive way first which i mean if you want this to become equal to one i becomes log n so you have n into t times 1 plus n into log n which is n log n this is what how masters theorem actually works i'm just elaborating that expanding the that equation even if you don't know about masters theorem that is fine as long as you understand the intuition of why it is n log n because in the recursion tree there are login levels on every level i'm using order n time so time complexity becomes order of n log n space complexity becomes order of n is there any way without using the extra space uh so actually merging two sorted arrays without using extra space in order n is not possible that becomes the the blocker right so if you can merge the array in place without using extra memory then your problem would have been sorted but the problem is like merging without extra memory is is the issue all right does this make sense merge sort space complexity time complexity all of that all right today we'll be talking about quick sort and today we'll be solving a lot more problems actually by the way i just wanted to maybe also share one news with all of you today was the first case when one of the fellow students at scalar has gotten an offer as a cto at one of the energy companies which is a fairly big company now right and that reason why i'm sharing this with all of you is to show you that look i mean learning matters i mean and then like again i can't disclose the exact salary of the person but it is it is in a few crs we are not talking about likes right so the thing that matters at the end of i mean that is basically the north star for all of us he is he's 30 something but like we all should focus on the learning aspect as long as we do that eventually all of us will succeed will go and build really really great things in the future he is part of skiller academy and not scalar plus and i can't disclose the name of the company and i'll show i'm sure like that news will come out later on it will be shared with all of the community as well once he joins is still sort of confidential but just letting you guys know i mean look it is important that all of us focus on learning as long as we do that i mean obviously like what you find later on is is going to be a function of what you know at present plus like some bit of experience i mean so again just to also elaborate this person is not somebody who is very young as i said like he's 30 plus already has more than 78 years of experience actually has more than 10 years of experience but as long as you keep learning the right things you'll move keep moving forward right and that is all of us should just aspire to become one person better every day that being said back to back to what is the agenda for today today we're going to actually talk about one sorting algorithm which is actually used in most libraries that you be it in java or python or c plus plus the sort function that you use they all use a different algorithm which we will talk about today but instead of talking about the algorithm which is i believe not the right way to introduce a concept what i'm going to do is i'm going to give you a problem a real life problem that you may take an attempt at solving and then we'll use that to maybe introduce the approach so imagine this imagine you have a bunch of nuts and bolts let me just you have nuts and bolt right so nuts basically look something like this and then you have bolt that is basically a circle that fits into the nut the nuts and bolts and usually they are created in pairs right so you have a nut of a size and then the bolt actually clearly fits if the nut and bolt are the same size then they fit now imagine you have a lot of nuts and lots of bolts and you are given that every single nut is of unique size it is every single nut and bolt are of different sizes so none of them have the same size and you're also given that every nut has a corresponding bolt one factor is given is every nut has corresponding bolt which means they both fit each other two is no two nuts have same size so they're all different sizes however it is very hard for you to just visually differentiate which one is bigger or which one is smaller so what do you do what you do is like if you pick a nut and you pick two bolts if the bolt is loose then you know that the bolt is bigger if the bolt is not going in then you know that the bolt is actually smaller now the problem is given that info can you sort all of the nuts and bolts in increasing order of their size with the right nut and bolt paired up currently they are all just in this array you have a table full of nuts and bolts you don't know which one is paired up with which one right one is how can you arrange that and two is how can you do it as fast as possible let me explain again right so imagine this let's say i had only two nuts imagine i had this nut another nut and i had another bolt and then another bolt right now what i can do is i can pick let's say this particular one and i pick this one and let's say i try to match them they are following things that can happen one is these guys clearly fit in that case i know that this nut is to be paired with let's let's just call it bolt one bolt two this is not one not two if they fit then i know these guys are in the pair they are they belong together and then i can just compare the other bolt if it is smaller than this particular nut then it goes before this nut right if it is smaller otherwise if it is bigger it goes after and then we i definitely know that the pair for this this bolt is this nut right so i just put these two guys together either after or before depending on how it compares with this current nut so if i have to define the problem formally you can pick a random nut an x and you can pick a random bolt if you pick these two guys you will get either of the following result either you will get nx is equal to b y which means both of these guys belong together or you will get to know that by the way this nut is smaller than bolt or you will get to know that nut is bigger than bolt these are the three results you can get you cannot compare nut with nut so for example i cannot get nx and ny and compare these guys i can't similarly i can't compare bolt with bolt this i can't do this i can't do however i can take a random nut in a random bolt and i can compare them does that make sense now it does right now i mean the question is how do i sort these guys how do i sort these guys when i can't really compare a nut with a nut and a bolt with a bolt the bolt size is not given to you i mean think of it like this right you have a table which is full of these nuts and bolts and there's only minor variation in the size what you should end up with for example in this case imagine that these guys were equal n1 and b2 was equal so i would put n1 and b2 together and assume that b1 was smaller than n1 so i would put n2 and b1 before this and i will return this list n2b1 as the first entry and one b2 as the second entry right so if you just compare with the bold with a nut you do get the relation whether a nut is bigger than a bolt or not so imagine if this nut was paired with another bolt b z then you know that b z is actually smaller than b by so you can compare the pairs by picking nut from one pair bolt from another pair there is no size given the only way is you just pick a random nut and bolt and then compare whether one is smaller than the other or not let's actually look at how do we do that right so one is if i pick any random nut let's say any i mean if you given let's say n different nuts let's say i pick some random nut let's call that nut n n one like what i can do is now i have a bunch of bolts i have b1 b2 b3 b4 b5 till bn i can compare each of those bolts with this n1 and i'll basically get three kinds of bolts there will be one heap of bolts which are lesser right so there's one heap of bolts which are smaller than n1 there is one heap of bolt that we will get let's call this bolt bigger which is bigger than n1 and there is exactly one bolt that i will get which will be equal to this nut correct if i compare all of the bolts with this nut i'll get three sets one bolt which is equal and then a set of bolts that are smaller and set up both that are bigger how these guys compare amongst each other that i don't know but essentially i i do know which bolts are smaller than this nut which bolts are bigger than this nut that you guys all agree with so if i pick any random nut i can distribute all of these bolts this way and very similarly now that i know that this bolt is the same as this nut so i can pick all of the nuts which were n 2 m 3 n 4 n 5 n 6 and 7 and 8 till n n and i can say let me compare all all of these nuts with this bolt right i'll get some nuts that are smaller so i'll basically have some of these guys if i compare with this bolt i'll get some nuts here let me take a different color some nuts here which are smaller some nuts which are bigger the equal one is already here so you will not find anybody who is equal so what we have done is we first started with one nut right and then we used that to break all of the bolts in three parts one bolt which is equal a lot of bolts that are smaller a lot of bulls that are bigger and then once you found the equal bolt we use that bolt to actually split the nuts remaining nuts into two parts smaller nuts and bigger nuts now what i know is all of the bolts smaller bolts will have their corresponding nut somewhere here i mean basically now i have three sets right i have a set of nuts and bolts which are smaller and they are guaranteed to be present in pairs here same guarantees holds here then i have one pair which is n1 b1 and then i have set of nuts and bolt that are bigger now i can actually recursively solve sort this set separately and i can sort this set separately but my problem has now reduced to sorting smaller set of nuts and bolts and if if obviously if this had only had one element then i know that this they are already sorted i don't need to touch them this is exactly how quick sort work i'll introduce it very very shortly but let me take a few examples just to show how is this working and that will give you a sense of like or sort of some intuition behind how quick sort works so imagine i was given some random let's say n1 n2 n3 n4 n5 nuts and let's say i had random five bolts as well what i'm going to do is i'm going to mark let's say hypothetically what the process is going to be like so what i'll do is i'll in step one i'll pick this nut and i'll say let's compare it with all of these five bolts and we'll find some bolts that are bigger some bolts that are equal imagine hypothetically let's say n1 was equal to b3 and imagine that b2 and b4 were smaller bolts and we found out let's say that b1 and b5 are bigger bolts very similarly then what i did was that i picked b3 and i started comparing b3 with with all of these guys n2 n3 n4 and n5 and i would come to know whether they are bigger than b3 or smaller than b3 all of the bolts again let's say hypothetically n2 and n3 were smaller and let's say n4 and n5 were bigger now the problem becomes that i i know that n1 b3 whenever i sort is going to be the third element in the set i have two elements before i don't know their order but those two elements have basically b2 b4 n2 and 4 as two pairs and i have two elements after which is b1 b5 and for n5 that are yet to be sorted that is after right however this portion is fixed i don't need to change this portion it is in the right position it is where it should be i do not need to change this position this is already in its correct position so then what i do is i recursively sort the first half and then once this is sorted then i will go to the second half how do i sort the first half i again do the same thing i say let's pick a random nut let's say i pick n2 as the random nut and i compare b2 and b4 with it oh sorry this should be this should be m3 so b2 b4 n2 n3 b1 b5 and 4n5 right okay so then i let's say pick n2 as the as the one not right and i compare b2 and b4 with it i know that i don't need to compare b1 and b5 they're definitely bigger i'll deal with them separately i'm only concerned with sorting these two pairs so i compare b2 and b4 and hypothetically let's say i find that n2 is the same as b4 so i find these guys are equal and hypothetically let's say i find that b2 was bigger i know that b2 will be paired up with n3 so i put it as it is these guys are sorted now then i have n1 b3 and i do a very similar process here as well i pick any one of these guys let's say i pick n4 and hypothetically let's say n4 pairs up with b1 and i find that b5 is smaller so therefore b5 will come here the pair of b5 is n5 that will come here so this becomes your sorted array totally now this process where i actually picked one element and i started comparing all of the remaining elements with it is called choosing a pivot so while this is a more complicated case let me take an example of sorting an array of integers and i'll show you with that imagine let's say my array was 5 2 1 eight six and one of b3 is largest that means this set does not exist the set is empty but the remaining set is still smaller set than what you began with it has now n minus one bolt and n minus one nuts so you still have a smaller problem to solve so in every step you're reducing the size of the problem so that is actually your worst case where you will end up taking n square time but still i mean that still gets you to your answer so at each step one of the pair comes at its right place let me let me just elaborate that with this array as well so in the quick sort process what you do is you pick one element any random element to be the pivot for example i say that i want to pick five as the pivot so what you do is the first part is you count how many numbers are smaller than five right so you basically let's have two is smaller one is smaller eight essays are not smaller that means the right position of five is the third position because there are two numbers smaller so what you do is you put five here one probably comes here so your array is basically one two five eight six and then once you have put five in the right position then you compare all of the remaining elements what you want is all of the smaller elements are on the left side all of the bigger elements are on the right side which in this case has automatically happened but in case it wasn't what you would do is you would start from here and you would start another pointer from here the first number that you find on the right side which is actually smaller than 5 you'll stop there you'll try to find the first number from on the left side which is actually bigger than 5 you'll stop there and then you swap those two guys so in order n you'll be able to get to a place where all smaller numbers are on the left side all bigger numbers are on the right side and then the problem becomes that 5 is in the right position now as long as i can sort the left side of the array and right side of the array separately my entire array will be sorted and that i can again do recursively so in every step when i choose a pivot one number will come at the right position and it will divide the remaining array into two parts two smaller subsets that need to be sorted do we have to take pivot as the middle to make the swap easier i mean so if the thing is when you're choosing the pivot you don't know which one is the middle element i mean you basically start with choosing a random number as the pivot in the array that you have to sort if you are unlucky then it would turn out to be one of the numbers which is either the highest number in the area or the smallest number in the array if you are i mean if it is just very very random chances are you will find a pivot somewhere towards the middle i mean let me actually go step by step does the nuts and bolt approach make some sense basically picking one nut comparing all of the bolts with it to divide them into smaller heap bigger heap equal to and using the equal to bolt to divide the remaining nuts into a smaller heap bigger heap equal to and i know that this equal to part is in the right position now i need to sort the smaller heap of nuts and bolts separately bigger heap of nuts and bolts separately let me take another example of this actually uh here there wasn't swap let's see what kind of thing we can do where we would need a swap imagine i still have five as the first element let's say there is six eight one and two hypothetically let's say this was the array and again we chose five to be the pivot if five is the pivot the first step let's count the number of numbers smaller than five one and two so that means five should come at position number three in the end so five should come here so what do i do the quickest way is i just swap right so i just bring five here i bring back eight here so five comes here it comes here i remove the circle now i know five is the pivot what i want is all smaller numbers should be on the left all bigger numbers should be on the right right now it is the opposite so what do i do i say that i'll start with a pointer on the left side let's call it start pointer i'll also start with a pointer on the right side let's call it the end pointer or maybe we can just call it left and right both are also okay left and right i compare the first number and i see whether it is in this right half or not in the correct half or not right so 2 is smaller than 5 it should have been in the left half so it is not in the correct half so i make my right pointer weight here my right pointer is currently pointing at 2. very similarly i start a loop on left to find the first number which is not in the correct half in this case the first number that i find which is 8 is not in the correct half because 8 is bigger than 5 it should have been on the right half and then the first place wherever left and right is i just swap them so essentially 2 comes here 8 comes here and i now know that these two guys are in the right half so then i again start moving my left till i find the next number which is not in the right half which is six so my left will will wait at six very similarly i start moving right to find the next number which is not in the right half which would be one and i'll just wait at one and then end up swapping one and six so one comes here six comes here so your right pointer will move from this position to this position and your left pointer will move from this position to this position if you add these guys up you'll get total sum as n minus 1 n being the size of the array this will help you shift all smaller elements to the left of the array bigger elements to the right of the array so if i have to write the steps of quick sort one is choose any number randomly as pivot and then once you have chosen a pivot put pivot in the right position for calculating the right person you'll have to count numbers smaller than pivot so this is one order n iteration third thing that you do is using left and right pointer shift smaller numbers in left half bigger numbers and right so the fourth step is sort left part and right part separately can be optimized by choosing the correct pivot the most optimal pivot is your median basically a number which can divide the array into two equal parts that is the best pivot right because then you're left with smaller arrays to sort it is obviously faster to sort smaller arrays however the problem is like it is very hard to know what is the median of the array why do you want to spend a lot of time finding out the median so what quicksort says is as long as you your pivot choice is completely random if it is completely random then i mean you're still fine average time time complexity will will still become n log n all right what is the approach behind quicksort quicksort is essentially choose a pivot divide the array into smaller numbers bigger numbers sort the smaller numbers separately sort the bigger numbers separately your array will automatically be sorted divide and conquer most of the library functions that you use they use quick sort and they choose pivot randomly i'll explain like why randomly still works here the one thing which you'll notice is in this entire process we have not used any additional memory we did the swapping etc in place so we have not created a duplicate array all of this is happening inside the same array that is important because while merge sort also is order of n login which we will see with quick sort merge sort uses additional space or it requires this separate array where you merge the two arrays which is additional memory required so one of the reasons why merge sort is not used extensively but quicksort is used extensively is because quicksort does not use additional space the worst case of quicksort is still really bad uh collections you also use quicksort now since we don't have random access how does it work for example if you use what you're saying is let's say if we have been implemented the list with a linked list then how would the the quick sort sort of work there because here i mean if you see in the quick sort you're not really doing random access all of your access is still sequential right for example let us go step by step we say let's choose any number randomly as pivot i can take a loop till the number because i will still anyhow have to take an order n loop throughout the entire list to count the number of numbers smaller so that i know what is the right position i'll have to do that anyway so i take a linear loop to get to the number that's fine i take a linear loop to find out the right position and again i do the same thing i anyhow have to split the numbers into left and right pointer i can take a linear loop for that so in all of this case if you see we i'm not doing any random access i'm actually going step by step in a linear loop let's do what is the time complexity analysis what is let's do what is best case what is worst case and what is average case what is the best case with quicksort what is the best pivot you can choose assuming that the array is not already sorted what is the best pivot you can choose median let's say you were very lucky and you were choosing the middle element all of the time what would happen is if you were given an array of size n you would put the median in the right place so median would be in the right place and then you will have an n by two size array here and by two size array here you'll need to sort these separately so what happens is exactly like merge sort you start with an array of size n this reduces to sorting array of size n by two twice one on the left side one on the right side that becomes i mean basically time to sort an array of size n is the same as 2 times t n by 2 plus order of n for for merging and this basically comes to order of n log n so if you are choosing the median as the pivot all of the time then you end up sorting it in order of n log n if you are choosing the median as the pivot every time and and by the way this is uh probably not the best case best cases in the arrays already sorted best case meaning that if you're given an array and then your median is the best right so you end up sorting in order of n log n what is the worst case i mean what is the worst kind of pivot you can choose one end when your pivot is actually on one of the ends so what happens is in one step in order of n what you would do is you'll end up choosing a pivot that is on one end so your pivot is here and you'll find all of the other remaining n minus 1 elements are on one side which means that in one order n loop you have only fixed the position of one element and you still have n minus one numbers to be sorted and if you keep doing that again and again if you're extremely unlucky your time to sort will become n plus n minus 1 plus n minus 2 plus n minus 3 plus n minus 4 which is order of n square so your worst case becomes order of n square if you are very very unlucky that you are choosing the extremes as your median all of the time does this make sense why is the best case order of n log n why is the worst case order of n square just in terms of how we choose the pivot if we are really really good with choosing the pivot then we end up choosing the median as the pivot that means it divides the array into two equal halves which is exactly the kind of thing that we did in merge sort right like you start with an area of size and you end up with two equal halves of size n by two and by two each which you have to sort which again will split further into n by four and by four if you again choose median this tree will have log n number of levels on every level you're doing order n operation so your becomes the best case if you're choosing the best pivot then it becomes n into log n if you are choosing the median as a pivot then you'll have order of n log in complexity that is clear to everybody right okay what is the worst case worst case is when you're choosing one of the pivot your time to solve or sort n sized array is in order n you ever able to fix the position of one element the other n minus 1 still need to be sorted and if i just expand on what t n minus 1 would look like it would be n minus 1 plus t n minus 2 which is what n plus n minus 1 plus what is t n minus 2 n minus 2 plus t n minus 3 which if you keep adding up will become n square i was not talking about the best case case really i was talking about given an array if let's say i had flexibility on what i choose as the median so what kind of pivot what kind of pivot will give me the best complexity what kind of pivot will give me the worst complexity that was what i was looking at right so what is the average case complexity one algorithm that i wanted to address which is called bucket sort if you guys remember we did something called a count short right which is when the elements were in limited range we would just count the frequency of elements and that would help us sort bucket sort is a slight variant of that variant being that if i can categorize numbers into buckets where i know that buckets are sorted in some fashion then the sorting problem becomes easier for me latex sort of is exactly bucket sort for example hypothetically let's say you had a lot of numbers so let's say i had 456 923 let's say i had 150 let's add 268 and let's say i had 12 and maybe i also have 950. now imagine i've also create 10 buckets 10 buckets bucket zero one two three four five six seven eight nine which is for the the most significant digit of the number let's say the hundredth place of the number assuming that a lot of the numbers are smaller than thousand they can be one million ten million as well so then we'll choose the most significant bit and we'll keep it the same position for all numbers if i do that then i know that 423 will go in the fourth bucket most significant digit is four more significant digit here assuming all of for all of them the most significant digit that we're looking at at is the third digit from the back so 923 will go in the nine bucket 150 will go in the 1 bucket 268 will go in the 2 bucket 0 1 2 will go in 0 bucket 950 will go in the 9 bucket what i know is now if i start going bucket by bucket and i have sorted the numbers within a bucket if i have sorted the numbers within a bucket and if i just start picking numbers from here and appending them then i end up getting the entire array sorted why because i definitely know that any number that is starting with 0 is definitely going to be smaller than any number starting with one so dividing them into buckets and then sorting the buckets within themselves i mean sorting the numbers within a single bucket that helps me reduce the complexity to some extent and i'll show you an example of that to a major degree which is what is called as radix sort but the idea is if i can break them into buckets where buckets already have some ordering defined then i can my job becomes just simply appending the numbers in the buckets and that might give me a sorted array and i'll give you a few examples to sort of talk about what bucket sorting is and we'll do one problem on bucket sorting as well which is a hard problem but we'll do that what kind of data streams are can i use for buckets think of them as for example vector of vector of int so for example your v of 0 is a vector of numbers v of 1 is also a vector of numbers and and so forth so the concept about sort is very simple if you can split numbers into buckets where buckets themselves are ordered in some fashion then i can sort numbers within the buckets and then i merge them that gives me a sorted answer if numbers are not in the same order how do we put them in bucket so even here if you see like 12 was not of the same order i just added another zero to get it to the same orders so imagine i have numbers as 950 1 12 923 256. i'll just add 0 to make sure they're all of same length how do we keep the value sorted in one bucket i mean within the bucket i mean just use quick sort or whatever kind of sorting you want to use there insertion sort quick sort whatever you want to use let's take an example i mean bucket sort alone isn't enough bucket sort paired up with a few observations is actually very powerful so one observation that leads to sorting algorithm is called radix sort the way the addict sort works imagine again you have a bunch of numbers to sort right again i'll pick the same thing which is let's say i have 923 950 let's say i have 12 i let's add the number one that's a number 100 let's say i have 150 so i have 650 and 688 hypothetically let's have a bunch of these numbers so what radic sort says is look i mean at the end if i was at the end let's make all of these guys equal length so add zeros wherever applicable if all of these numbers are of equal length then at the end most significant bit this bit is the most important bit obviously if the most significant bit of one number is uh smaller than the other number then the overall number is definitely smaller it is only a problem when they both are equal then i will look at other digits so i know that so what i want to do is i want to start sorting digit by digit with most significant digit being the last place where i start because i know this is the final step so what radix sort does is it says let's start with the least significant digit let's first start based on this and what do i do i basically create again 10 buckets corresponding to 0 1 2 3 4 5 6 7 8 9. i will first look at the last digit based on that 923 goes here 950 goes to 0 0 1 2 goes to 2 0 0 1 goes here 100 goes to 0 150 goes to 0 650 also goes to 0 6 88 was here and then i append these guys right what will happen once i have done this step all of the numbers will be sorted by their last digit so i get 950 100 150 650 0 0 1 0 1 2 9 23 and 6 88 i sorted numbers based on their last digit now let's look at the next digit i repeat the same process again but with the next digit now i'm going to erase all of these guys from here we are now going to look at the second digit i say that now let's look at these numbers again one by one but the second digit is what we are looking at so 950 goes at five hundred goes at zero 150 goes again at five 650 also goes at five zero zero one goes at zero zero one two goes at one nine twenty 23 913 goes to 2 and 6 88 goes to 8. i'll again append these guys what this would make sure is now everything is sorted based on the last two digits so i append and when i append i basically get 100 zero zero one zero one two nine twenty three nine fifty one fifty six fifty and six eighty eight and now the last step is the magic step which is where i look at the most significant bit so i raise all of this again i look at the most significant bit and i bucketize these guys based on the most significant bit so 100 comes here 0 0 1 comes here 0 1 2 comes here 9 23 950 150 650 and 688 now once i append them all of the numbers should be sorted which you would see 001 0 1 2 100 150 650 688 923 950. now this final array that we've gotten this is sorted what has happened we can take msb directly the only problem is then within the bucket if you have multiple numbers and think of like when you have a million numbers right you only have 10 buckets based on msp that means every bucket on average will have 100 000 numbers and if you go to solve or sort of sort each of those buckets separately it will take you a lot of time but here i can sort the entire array by doing this function the number of digits number of time so imagine all of the numbers had five digits i'll do this operation five number of times and my entire array would be sorted in every for every single digit for every single digit i am putting them in buckets 10 buckets and then i am appending them which is an order n operation right so my total amount of time taken is order n into max number of digits space is assuming that we are taking a vector of vector the total space taken by vector of vector combined across all of this is order of n so i'm using an order an n extra space at the order of 10 plus n this is order n do we need to compare an element with the existing elements present in the bracket no right now because the moment you start doing that then your complexity increases currently it is just very dumb way of appending to existing numbers in the bucket why can't we take msb to lsb i mean when we start with msb in the first step we would definitely have put the bigger numbers to the first half of the array the smaller numbers to the second half of the error that i completely agree with in fact numbers would be sorted based on their first digit but as you go to the second digit within these numbers if the sorting is happening in the right way or not because you will have let's say you look at second digit at zero right now some of those zero numbers will come from the numbers that had the first digit as nine some of those zero numbers will come with some numbers where the first digit was six for example let's let's look at this example itself right if i started from msb then what would have happened let me erase this my first two numbers will go in the nine bucket 923 950 0 1 2 0 0 1 1 0 0 150 650 and 6 88 which is great now if i append them then i get this this is almost sorted the problem is when i move to the next digit it's then that it becomes a problem because 0 1 2 will come here 0 0 1 will come here now 1 0 0 will also come here however i know that 1 0 0 should only come after 0 1 2 when i will merge then i wouldn't know how to maintain this ordering i mean i'm using digits here you can do the same thing with bits they will only have 2 buckets zero and one here i have ten buckets you'll only have two buckets when you're dealing with bits when you go from lsb to msb that means msb takes higher priority because it is the last deciding factor when you go from msdb to lsb then lsb starts taking higher priority so time complexity is n into number of digits if d is the number of digits that is your time complexity usually the number of digits is the same order as log n it's actually log n to the base 10 and being the maximum number in the array number in array so i mean um usually radic sort is a good number to know and good approach to know because this can be applied at multiple places that being said again like not very commonly used because n login you can just directly use your sort function why would you go and take the pain of implementing radix sort but it has very similar time complexity if all of what we have discussed till now that makes sense i'll give you one problem which will actually make the bucket shot even clearer the reason why we have bucket salt explain the time complexity again so if you look here what do we what are we doing we are taking digit by digit right so first we look at the last digit and for that digit what do we do we put them in these ten buckets right so basically what happens is what is the last digit of any number let's say i i go i basically i do this right i say i goes from zero to n and we calculate the last digit digit is equal to array of i mod 10 that is your last digit and then you put it in that the same bucket so for example let's say if you have bucket array you say bucket of digit dot add ai right you do that all of this is order n process for the last digit correct and then eventually i'll put i'll basically look at numbers in every bucket and i'll keep appending them in another array all of this is order n process i'll have to do this for every digit correct so if all numbers have let's say 5 digits then my complexity would be n into 5 because for every digit i'll do an order n operation if every number has d digit and it becomes order of n into d how n log n is similar to n into d so n into d makes sense right order of the algorithm is n into d that makes sense correct okay now what is d what is it like given a number x what is the number of digits that x would have how do you find that basically how do you find number of digits you basically divide x by 10 you check if it is zero yet then you again divide it by 10 further which is 10 part 2 then you divide x by 10 part 3 x by 10 by 4 number 5 and so forth right when x by 10 to the power i is 0 which is like now 10 by i has become bigger then that is where you have the number of digits okay if i just put it like this i mean basically if x has i digits then x is approximately equal to 10 raised to i approximately which means if i take log 10 on both sides then i basically get i is equal to log of x that you agree so if if there is a number x then x has basically log base 10 x number of digits so therefore i'd say like whatever is the highest number in the array then d is basically log of that highest number so your d is almost the same as n log x x being the highest number so bucket sort is more generic right like bucket sort just says hey look my fundamental is you can create any sort of bucket you want you can create a bucket of all numbers from 1 to 100 all numbers from 100 to 1000 all numbers from 2000 to 3000 could create any bucket that you want as long as it covers all range you put numbers in the bucket where you know that every number in bucket one is going to be smaller than every number in bucket two so you just bucketize these numbers you sort them separately and then you append that becomes bucket sort it is very generic radix sort is using bucket sort in one way why this type of bucketing works going for all positions instead of just msb or lsb let's say if you just go for msb there wherever two numbers have different msb most significant digit there i mean you probably can only do with most significant digits the problem is there will be a few numbers that will have the same most significant digit in fact there are only 10 possible most significant digits right so if you have let's say thousand numbers then on average you will have 100 numbers in every bucket right for example here as well i had 950 and 923 they'll all go to the nine bucket now how to actually decide the ordering between these in fact if you have a lot of numbers in the bucket then how do you figure out the ordering between those that is not clear so therefore you can't decide only based on most significant digit you'll need to somehow sort these guys within the who have the most significant bit as nine as well right internally you'll need to sort them so there are two ways one is like you just say i'll bucket eyes based on the most significant digit and i will sort each bucket right so what happens is if i had n numbers then on average each of the buckets will have n by 10 numbers to sort them i'll take n by 10 log n by 10 and i'll have 10 such buckets so i'll finally multiply by 10 this will give me n log n by 10 which is the same as n log n so i end up reaching the same algorithm which i have anyhow done before this does not seem to be an improvement so therefore i said like can i improve further on it and and there we said maybe if instead of saying that we'll sort the numbers in the same bucket if we could do bucket shot multiple times in a way where at the end of it all of them would have been sorted then that would be nice so i say you know what like for the sorting based on the most significant bit one thing is if i can somehow reach a state where numbers with the same most significant bit they are already sorted in some way that would be awesome but to sort the numbers with the same most significant bit for example if you remove the most significant bit you'll need to sort them by the remaining bits there also if you just again break it down recursively you'll reach the same state like you'll first have to sort based on the least significant bit then the least significant and most significant together and then the last three to get together last four together and so forth uh in radix you have log base 10 of not the number of elements i mean in n log n n is number of elements this is log base 10 x which is the highest element in the array this is not the number of elements this is highest element in array two different things but yeah i mean um in in cases of log n if you have let's say 1 million entries 10 6 entries or 10 plus 7 entries the login is typically 20 22 24. in the case of numbers the number of digit is probably still eight or nine so it can perform twice as faster if max is less than and go for radix or that that i wouldn't say if your log of 10 max is less than in fact significantly less than log n then go for static sort okay in case of integer we could use radix that's why i said like if your log of max is less than log of n you could use products that might run just slightly faster even if you go with bits yes you will eventually end up sorting just that the number of iterations will be more all right let's move to the next problem imagine you're given a bunch of numbers which are not sorted by the way let's say you have 5 8 3 1 6 some numbers right and then you've been given this array that you cannot modify so this is a constant array cannot be modified now what you need is that if this array was sorted let's say if this array was sorted the numbers would be 1 3 5 6 8. actually let me change the numbers a little bit let's say this number was 7 right if this number was 7 then the numbers would be 1 3 6 7 eight and then in the sorted array if you were to look at adjacent difference the difference here is two difference here is three difference here is one and difference here is one there you have to find out what is the maximum gap between the numbers when the array are sorted in this case the maximum gap is three so you say the answer is three so given an array how do you find this maximum gap if the given array is constant and obviously one answer is you make a copy of this array you sort the array and you look at the adjacent differences and you take the maximum of that which becomes time complexity order of n log n space complexity ordered off n can you do something better than this i'll repeat the question once more you are given an unsorted array the array is not sorted what you have to find is if the array was sorted and if you looked at the adjacent numbers differences what is the maximum difference you can find what is the max gap you can find hey folks i welcome you all to scalar academy's youtube channel so if you want to be a good programmer then you need to have a good mathematical aptitude or in other words you need to have mathematical way of thinking to solve the coding problems which you face so understand the importance of this we have brought you this tutorial on mathematics for programming now before we start off i'd like to request you guys to subscribe to our channel and also hit the bell icon so that you do not miss out on our upcoming videos so on that note let's get started hello so we are back with the live class today's topic is factorization these classes are for people who want to become better programmers right at better ideas and algorithms so please make sure that you subscribe to the channel and press the bell icon to get notifications right about any new videos as always uh there will also be a practice set available to you this practice set will have a few problems so that you can apply whatever you learn in today's class right actually applying actually practicing the problems will help solidify the concepts all right so we are going to cover factorization today now factorization is a topic of mathematics all right and as computer programmers or you will need to have a decent understanding of mathematics in fact i mean in all sciences and computer science is a science right the stronger you are at maths the easier your life will be now programmers i mean you don't have to be very good at mathematics but there are certain areas that you need to focus on to be a good programmer now these topics are like discrete math probabilities statistics combinatorics linear algebra modular arithmetic number theory graph theory right so it is still a very large section of topics that uh you will need to be a very good programmer so we we're going to start with that and today's topic is from number theory and the topic is factorization all right so let us begin all right cool so before we begin let us start with a question directly right let us say that you have been given you have been given a number n all right and this is an integer this is an integer in fact this is a positive integer right your task is to find all the factors all the factors of this number right so for example let us suppose that you have a number like 16 perhaps right so can someone tell me all the factors of 60 what all numbers is 60 divisible by so when we're talking about factors we are talking about the positive numbers right the positive integers that divide 60 right and do not leave a remainder so what numbers are those so firstly we have 1 right then does 2 divide 16 yes it does so we have 2 similarly 3 divides 60 4 also divides 60 5 does 6 does 7 does not really divide 16 right now 8 also does not divide 60 neither does 9 10 does 10 definitely divides 60 after that what numbers we have so we have 12 right then we have 15 then we have 20 right what more we have 30 and 60 right so these are all the different factors of 60 right cool now before we before we dive further into this problem let us try to draw some observations let us try to draw some observations and see if there is some pattern to what the factors of a particular number are right so first of all you will notice that one and the number itself they are always factors of this number yes do you agree well one divides every single number and if you have a number let us say n then that number will divide itself right so that has to be a factor what else do we notice over here is there any other pattern that we notice over here yes so we notice one more thing so the first thing is that one and n are divisors divisors of n the second thing that we notice is that that factors come in pairs factors come in pairs what do i mean by that i mean that given any factor given any factor there is a corresponding factor right so if i pair 1 with 60 then i will get 60 right 1 times 60 equals to 60 similarly if i play 2 with 13 then i once again get 60 so 2 times 30 is 60 similarly 3 times 20 is 60 4 times 15 is 60 5 times 5 times 12 is 60 6 times 10 is 60 right and then if i continue if i continue from here on you will see that i will just repeat these things right so i will just repeat these things i will say 10 times 6 is 60 right so 10 and 6 have been repeated similarly i will next say 12 times 5 is 60. so after all this the numbers are being repeated is that clear the factors will always always come in pairs right that is the main observation that we draw from all right now given that we have these observations could we write a program could we write a function let us say find factors find factors right that takes an integer n and it let's suppose print out brings out all the factors of it so let us in fact call this instead of find n let us call this print factors this function exception n and it is supposed to print out all the different factors of n right so what approach do we see over here what approach do we see over here so one way one way to do this would be the naive right the very very simple way the first way would be to look to go through all the numbers go through all the possible possible divisors right so to go through all the possible devices we will need a few more observations right let us let us quickly see what those observations are so the first observation was that one and n are divisors of n there is one hidden observation over here right let me mark this as the third observation and that observation is there are no divisors that are less than one and there are no devices that are greater than n right so the divisors so one is the smallest divisor and n is the largest divisor yes does that make sense so when i am trying to find the devices of a particular number i only have to go from 1 all the way to n right because i cannot have divisors that are greater than it does that make sense is that part here right perfect so how do we write this program then this is a very simple for loop so we will say for i goes from one right all the way till n all the way to n and we'll increment i so we'll go through all the different numbers what we will do inside this we will check if n mod i equals to equals to 0 right so everyone is familiar with this mod operation right this is the remainder operation this says that when we divide n by i then what is the remainder is that remainder 0 if that remainder is 0 then i must be a factor right i must be a factor then what do we do we simply print i right so this is our code for factorization right cool now this is the first option this is the first approach this is very naive we can do much better than this but why is this knife so let us analyze the time complexity of this particular program so how much time does this take if i have a number n then what is the time complexity of this particular program well this is a simple for loop right we are going from 1 all the way to n so this is linear this is linear in fact this takes order of n time right cool can we do better can we do better well certainly we can certainly we can so the first thing that you will notice over here is that whenever you are looking at these numbers whenever you are looking at these numbers we know that the largest factor is the number itself right the largest factor is the number itself but what is the second largest factor how big can the second largest factor be so i know that the largest factor largest factor is in itself right what about the second largest factor second largest that must be less than or equal to n by two right that factor must be less than or equal to n by two why because if it is greater than n by 2 if it is greater than n by 2 then its corresponding pair right device is always coming clear right factors always coming there its corresponding pair will not be an integer 2 is the smallest integer that might divide this number apart from 1 right so we know that the second largest has to be less than or equal to n by 2 so one thing one thing that we can do over here right away is instead of having this loop from 1 to n right instead of having this loop from 1 to n we can modify this we can modify this so let me just modify this over here i will say i is less than or equal to n by 2 right and notice that this is integer division over here integer division right so in this loop i will print all the all these divisors but now i do not print n right i have missed n so i will have to add another statement over here which will simply say print is that clear because now our loop is going from 1 all the way to n by 2 so i will not print out n in this loop i'll have to print it separately yes so how much time did we save just now we made our program twice as fast right that that's very nice right we certainly make a made up program twice as fast the asymptotically it is still linear right it is still order of n time but practically it is twice as fast right perfect all right so can we extend this can we extend this observation further what about the third largest factor what about the third large factor how large can that be well if the number is divisible by 3 then the third largest factor can be up till n by 3 right does that make sense so the third larger factor has to be at max it has to be less than or equal to n by three similarly the fourth largest factor has to be less than or equal to n by four right and so on so we see this pattern over here is that clear cool now the question is we could use this particular observation to reduce the time complexity by half how do we utilize all these observations how do we really utilize all these observations so to do this let us make one more observation right let us let us actually go back to this observation that we had previously let us look at this thing once again okay so let us say that instead of going from 1 all the way to 60 right instead of going from 1 all the way to 60 we only go till this midway point right you clearly see that there this there is this midway point over here after this midway point so this is the midpoint after this midpoint the numbers will repeat yes six into ten repeats as ten into six five in twelve will be repeated as 12 into 5 and so on right so we only need to go till this particular point we only need to consider this half we do not need to consider the other half all right so if we are considering this half then we have to go from 1 all the way till what number we have to go from 1 all the way to this number how do we find what this number is how do we find what this number is so basically we are looking for a number i right we are looking for a number right such that i times something else first of all this should be equal to n right because they are numbers they are they are factors right so i times something should be equal to n secondly i am looking for a number such that i is less than or equal to this something right because so basically i am i'm going to the six because the pair of six or the the number which is paid with six is greater than six right ten is greater than six if i go any higher if i go any higher then the numbers will swap ten will now become i mean the first number will become greater than six now right so we are looking for a number over here that follows this property okay so if this is x then what can i say from here i can say that x equals to n divided by i right so i can put the value of x over here i will get i is less than equal to n divided by i what can i get from this i can move this i to the left hand side right so i will get i square is less than or equal to n and what does this tell me this tells me that these numbers this tells me that these numbers they must be less than or equal to so i must be less than or equal to square root of n is this part 2 is this derivation clear this is very simple a lot of you might already know this but it is important where from i mean from where this is derived right this this square root sign this this is not magic all right so once again we are saying that we are looking for a number i we are looking for a factor n such that its paired factor such that its period factor when we multiply them we get n right they are factors now we are also saying that okay we are only going to make sure we are going to make sure that this factor must be less than equal to its pair right this factor must be less than equal to h square because if it is greater than square then we are just repeating ourselves right because 2 times 3 is the same as 3 times 2 so we only need to make sure that this number is smaller than this number otherwise we will be repeating ourselves so we put this in the equation we say i is less than equal to n by i which means that i square is less than or equal to n which means that i is less than equal to square root of n so what did we get from here so now we can improve our program we can now say that we have a for loop for i equals to 1 i less than square root of n square root of n and i plus plus i less than equal to square root of n i plus x all right now i will check if in fact n is divisible by i so what should i print over here if n is divisible by i i should print i right i should print i but is that all is that all no because i also have to print the other pair right remember we are only going for to half the pairs down so we also have to print the other place so i will also print n divided by i right n divided by i right and that will complete the that will complete the list of factors is this part here yes perfect right now first of all there is a mistake in this program there is a mistake in this program a very subtle mistake can someone point that out yes exactly exactly so over here let me just uh point it out so over here lucky says that hey this is the mistake right what happens when i is actually equal to n by i which means that when n is a perfect square when n is a perfect square you will be printing this number two times right that is not very good you will be printing this two times that is not valid so how can we fix this right so is first of all is everyone clear if n is 9 n equals to 9 what we will see we will see i equals to 1 we will print 1 comma 9 right i equals to 2 we will not print anything i equals to 3 we will print 3 comma 3 right so vc that we printed 3 2 times that is not a good thing to do right so we need to resolve this we need to resolve this and we see that this only occurs when n is a perfect square right otherwise this this issue cannot occur right so how do we how do we resolve this we simply say that i goes till less than square root of m right i go still less than square root of n and after this we will specially check after this loop is over after this loop is over we will check if so after this loop what will be the value of i it will be exactly square root of m if it exists right so we will say if n mod i equals to equals to 0 then print it just once right print it just once because it is a square root so just print i wait notice that we are not printing the pair over here is that here cool so this will give us the correct answer now the question is how much time did we say what is the time complexity what is the time complexity of this particular code yes so who can tell me that well this is very simple right just like the previous case we have a simple for loop and this for loop now goes from 1 all the way to square root of n so the time complexity is supposed to be order of square root of n right simple is that clear there is one more thing over here that if you were actually using a function to calculate the square root of n you would not do this again and again right you will actually say s q r t or square root equals to you will calculate the square root of n outside square root of n outside and then you will just use that variable right so that whenever you whenever you hit this condition you don't have to calculate it again and again and again okay so this will give us the correct code and the complexity will be order of square root of n now that is a huge improvement right that is a huge improvement going from order of n to order of square root n this is huge this is massive imagine that you had a number which was let's say 100 trillion right 100 trillion if you hundred trillion is how much 100 trillion is how much it is 10 to the power 14 right if you were to check this number if you were to check a number of this order of magnitude on your computer it will take a lot of time right how much time will it take it will take around 10 to the power 5 seconds right or you can say it will take around 30 hours it will take around 30 hours of time whereas with this particular algorithm how much time will it take it will take us 10 to the power 7 operations so this is 10 to the power 7 square root of 10 to the power 14 is 10 7 so it will just take how much time it will take 0.01 seconds right that is that is amazing we went from a program that took 30 hours to a program that took that i mean ran in 100th of a second all right cool so this is how we would factorize a particular number okay so i hope this is clear to everyone now let us move on to a question right to a question related question okay suppose that we have a hundred doors right and all these doors are closed all are closed so we have basically dole number one over here row two row three door four all the way till ninety eight ninety nine hundred right we have all these different doors and initially all of them are closed so let me say that these are closed okay now we are going to play again we are going to play a game this game will have 100 steps because we have 100 doors we will have 100 steps so the first step in the first step what will we do we will toggle toggle all the doors right so you understand what toggle means right toggle means that if it is open you close it on the other hand if it is closed you open it toggle basically means to flip it cool so we will say that in the first step we will toggle all the rows in the second step we will toggle all the doors all the even rows basically we will toggle every second over every second door right in the third step we will toggle every third row and so on and so forth right we'll continue like this forever in the hundreds that we will toggle so there will be just 100 right we will toggle the 100 door right so this is what we are going to do is this part here so first of all what happens after the first so what happens after the fourth step initially all of them are closed after the first step all of them will be open right then what will happen after the second step we will toggle this every second door once again so this door will become closed this door will become closed this door will become closed this door will become closed right in the third step we will once again toggle every third one so this third door will become closed there was a sixth door over here right it was initially closed so we will open it up right and so on and so forth does that make sense so we are doing this thing that is the game we are playing the question is that after we are done with this game after 100 steps which doors remain open all right is the question clear yes after the third step we will toggle every fourth so in the fourth step we will toggle every fourth row in the ii step we will toggle every ith due right and the question is after all these 100 steps which doors will remain open okay all right so i mean this 100 is a very very large number right so let us actually let us actually reduce the problem so whenever you have a difficult problem you try to you try to check that problem one smaller numbers right so let us say that we only have ten rows okay we only have 10 rows one two three four five six seven eight nine ten initially all of them are closed okay what happens after the first step so this is the zeroth step this is step zero step one step two step three step four five six seven eight nine ten right what happens after the first step after the first step every door is open right after the second step what happens after the second step what happens so after the second step one is open two is closed three is open four is closed five is open six is what happens in the third step in the third step one we did not change it two we do not change it three was open right three was open so we will close it four we do not touch it five we do not touch it six was closed so we will open it seven we do not touch uh seven remains as it is eight we do not touch nine was open so we will close it then we do not touch yes okay we move on so in the fourth step we will keep one we will not touch this we will not touch this this was close so we will open it we will not touch this we will not touch this we will not press this this was closed so we will open it we will not touch this and we will not touch this and so on and so forth so can someone see what is happening over here can someone see what is happening over here basically what happens in the ith step what happens in the i-8 step exactly so srinivas has the right idea over here srinivas says that in the i-8 step all the doors all the tools that are divisible by i divisible by i get toggled right that is the problem over here now the question is now the question is let us suppose that i am talking about the nth store right let us suppose that i am talking about the nth for which all numbers for which all steps which all steps will toggle this door we'll toggle this door right so is the question here if in the i-8 step i toggle every ith door then given a door number right given that i am saying that okay let's talk about the 20th rule right let's talk about the 20th row then in which all steps will this 20th door be topped in which all steps will this 28 program all the factors of it exactly right all the factors of n yes so basically 28 will be toggled in the first step in the second step fourth step fifth step 10th and 28th step is that clear yes because these are all the factors of 20. so how many times how many times will this door be toggled how many times will this one be topped well we see we we already know that that factors factors come in pairs come in pairs right which means that if there is a step number one on which this is token there is also a step number 20 on which there is toggle right similarly for step number two we have step number ten for step number four we have step number five right so we know we know that the nth door the nth door will be always toggle will always be toggled and even number of times even number of times right because why why is this true because the factors will come in pairs right so every door is going to be toggled and even number of times is that correct is that correct well not so fast not so fast is there any particular number which has an odd number of factors right what happens so you have this peers coming up you have these pairs coming up what if there is a middle value what if n is a perfect square in that case this value root n it doesn't have appear right root n is going to pair with itself so it will not have a pin so basically if the nth door next door so if n is a perfect square right if n is a perfect square if n is perfect square then nth door will be toggled in odd number of times right in all of the cases it will be toggling even number of times is that you yes all right so what happens if you toggle a door even number of times initially it was closed then it became open then it became close then it became moved if we do this an even number of times what will the end state be it will be closed right because we started with closed we toggled it even number of times so eventually it will be closed on the other hand when n is a perfect square we will toggle it odd number of times so what will be the final state we started with close we move to open we move to close since we will do this odd number of times the final state will be open right so which our roles will be open now we know the answer which all roles will be open all the doors whose numbers numbers are perfect squares perfect squares right and all in all the dose from 1 to 100 which all those are those which all those are those so that is 1 then 4 9 16 25 36 then what do we have 49 64 81 and 100 right exactly 10 those will remain open on all these are the does that will remain is that clear no no if n is playing the answer will be even so this is a question over here vishwaji says that if n is prime n is prime then how many factors does it have well for any prime number it has two factors right one and in itself so for prime members it will be even not odd only for perfect squares only for perfect squares perfect squares will be have odd number of factors or number of factors all right cool okay so what did we learn from this particular problem this was not a very difficult problem right this also does not involve a lot of programming we did not do anything fancy we did not do any fancy match over here all we did was we sat down we made some observations right we made some observations we looked at the problem we tried it the smaller number instead of going to directly 100 we tried it at this point so that is something that you have to keep in mind right whenever you are facing a problem whenever you're facing an algorithmic problem or any problem in life please your first step should not be to come up with a solution that is a very very wrong way of doing things the first step should be to make observations make observations once you do this once you do this only then you will be able to find a solution find a solution if you do not make observations you will never be able to find a solution all right so please do not skip this step okay cool so that was a nice little exercise let us go back to what we were doing earlier right so first of all what we did was we found all the factors found all the factors of n right that is the first thing now while we were doing this we kept talking about something right we kept talking about prime numbers we kept talking about prime numbers so can first of all can someone quickly tell me what a prime number is so what is the definition of a prime number what is the definition of a prime number a prime number so first of all it has to be a positive and it has to be an integer it has to be a positive integer secondly it must have exactly exactly two divisors right it must have exactly two devices there is a lot of people think that this is the definition of prime number right a lot of people think that a prime number is a number which is divisible which is divisible by one and itself right by one in itself if this was the definition of prime numbers then one would be a prime number right then one would be a prime number because hey one is divisible by one and one is divisible by itself but one is not a prime number all right is that here so this is not the correct definition this is very close but this is not the correct definition the correct definition is is that it must have exactly two devices exactly two distinct devices right so can someone very quickly tell me what all the of what the prime numbers are a few prime numbers from the start so is is 0 prime is 0 no it is not is 1 prime no it is not is 2 prime yes 2 is prime who is the smallest prime number then 3 is prime 4 is not prime 5 is prime 6 is not prime 7 is prime 8 is not prime 9 is not prime 10 is not prime 11 is prime and so on right how many prime numbers are there how many prime numbers are there 100 200 500 1000 million billion how many numbers are there there are infinitely many prime numbers infinitely many prime numbers right everyone knows this oh there's a very simple proof for this as well all right okay so now that we know the definition of a prime number some people are saying four prime numbers are there that's nice suppose now that we know the definition of prime numbers can we write a program can we check if a number is prime right so we know that the definition of prime number is a number which has exactly two divisors and it is a positive integer so given a number can we check if it is prime so is prime right it is going to return a boolean and it is going to take an integer yes so how can we write this program so very simple right very simple we can say that count is 0 right we can write a loop for i equals to 1 i less than equal to n i plus plus right and we can check if n mod i equals to equal to zero then we will do count plus plus right and finally we will return what if it is if the count is exactly equal to 2 then it is prime otherwise it is not prime yes right cool what is the time complexity of this program what is the time permission of this program this program runs in order of end time we already know that we can optimize this a lot right we already know that we can operate so surat says why boolean so this is prime will return true or false right it will return true or false true if it if the number is playing false if it is not right which is why we are written in a boolean is asking sir just confirming is this code java right so uh this is this might not exactly be java for example in java you will have to put a semicolon over here right uh i'm not sure if you write bool or boolean java i kind of forgot but the rest of it pretty much looks like java right pretty much looks like jump if we add these semicolons this will also work in c plus plus almost exactly the same way right however when we are doing these classes we will not be following any particular programming language if you have any questions of a particular programming language that let's say if you want to ask okay how will i do this in trust or how will i do this in haskell or how will i do this in let's say python right so you feel free to ask that okay feel free to ask that i will be able to give you an answer for most common programming languages however we will not be focusing on the programming language in this particular class right we will be focusing on the sudoku we will be focusing on the intuition okay cool okay all right so we see that this is linear in time but we already know that we can improve this a lot right so how can we improve this instead of going from one to n we can go from we can so if one is a factor right if n is a factor right and prime numbers have exactly two factors what does this mean what does this mean this means that if n is prime if n is in fact prime then it must not have any factor not have any factor between 2 all the way to n minus 1 yes is that here it must not have any factor between 2 all the way n minus 1 in fact it must not have any factor between 2 or the weight is n by 2. in fact we can even generalize this and we can say that a prime number does not have any factors between 2 between 2 all the way to square root of n right because we see that the the factors will come in pairs if the factors will come in pairs is that clear so we can improve this code a lot we can improve this code a lot we can say boolean is prime is prime right we have an integer n and we will say so now we don't need that count anymore right because we are just checking if there is a prime factor or not if there is a factor or not so we can say for i goes from 2 all the way till square root of n i plus plus right if there is any factor if n mod i equals to equal to 0 if we did find a factor then what can we say if we did find a factor then what can you say hey we found the factors so it must not be prime if you found a factor between 2 and square root it cannot be so we'll just return false return false over here right and after this loop is done after this loop is done we will return true because if we did not find any factors except for one and n then the number must be prime is this clear and the time complexity of this code is the time complexity of this code is order of square root of n right perfect so we know that we can check if a number is prime in order of n time as well now one question it's not i mean we are not going to teach that today in the class but one very common question is is this the fastest we can do is this the fastest we can do and the answer is no the answer is no in fact primarily testing primarily testing this is in p right this is in p p stands for the polynomial time involves right i'm not sure if you have heard of p versus np right but primarily testing is in p that means that we can check for primarily in log in time in order of login all right we will not be going over this particular algorithm today so there are several volumes one of the most famous famous ones is the aks primarily test right okay but primarily can be checked in order of log n it is in p right and no no this is this is different from c of whereas sentences right this is this is different from the civil war this is a different thing okay so if someone asks you how much time does it take to check if a number is prime the answer is login right you can you can test primarily in polynomial okay cool because says uh what if n equals to 5 so because has a question over here let us look at this code and see what happens when n equals to 5 does this code work correctly right so let us try that so what happens so first of all if we say i equals to 2 right so we will first come over here we will set i equal to 2 then we will move on to the condition we will move on to this condition right that is how our forward works we initialize we check the condition we go inside the block we increment and we check the condition again right so we will check this condition well what is the square root of 5 the square root of 5 is well square root of 5 is 2 point something right let us suppose that we are doing integer things over here so we will say that okay this this is 2 is less than equal to 2.5 right less than equal to 2 point something so we will go inside we will go inside we will check is n divisible by 2 is 5 divisible by 2 no it is not right so we will continue we will continue we will increment i i will now become 3 now once again we will check is 3 less than equal to square root of n no 3 is not less than or equal to square root of 1 right 3 is greater than square root of 2 so we will exit this rule and we will return true so we will say that yes 5 is prime which is correct okay okay so this is another question santosh says that okay what if 2 what if we check with n equals to 2 right what happens when n equal to 2 won't this program return false let us see right so when n goes to 2 we start right we start with i equals to 2 then we move on to the condition you move on to the condition we check if i if 2 is less than equal to square root of 2 is this true is 2 less than equal to square root of 2 no it is not true right this is not true so it will directly come outside the loop okay it will directly jump outside the room it will not go in the loop and we will return true so even for truth will return to is that yes yes but this program is not hundred percent correct this program is not hundred percent can you tell me one value for which this program will fail exactly so i use have the right idea over here what if n equals to 1 or what if n equals to 0 or what if n goes to minus 100 right for all the numbers that are less than 2 so all the numbers that are less than 2 we will never go inside this loop so it will automatically return true right so we need to improve on this program we need to improve on this program we need to add a check over here so let me just insert some space let me just insert some space so we will very quickly let me just clear up the mess this was square root of n so we will add a check over here we will check if n is less than or equal to 1 then we simply return false we simply return false right is this clear no this is not a base case base case happens when you are in a recursion right base case we talk about base cases when we are in a recursion this is a edge case this is a boundary condition okay so it's almost the same but it is it is better if we follow the correct nomenclature okay base case is when we talk about recursion currently we are talking about edge cases or boundary condition all right yes we can we can also say that this is less than equal to less than 2 we can instead of saying less than equal to 1 we can also say less than 2 that is perfectly fine all right ok let us continue so now we know how to check if a number is five now a very common question comes from uh let me just check how we are doing one time all right so a very common question comes up now which is called if you had to find all the primes all the primes till n right so i give you a very very large number n let us say 1 million right and i ask you find out all the primes till 1 million right how will we do that is the question clear we have to find all the prime still one million or some number n so one way of doing that is to very simply go through all the numbers and check if they are prime right so we can simply do for i equals to 1 i less than equal to n i plus plus right and we will say if is prime if s prime was i right so this frame is the function that we have quoted earlier this this prime is the function that we have coded earlier we will simply print i simple enough yes how much time will this algorithm take how much time does this take well this is prime function this takes order of square root of i right this takes order of square root of i and we are doing this thing we are doing this thing n times right we are doing this thing n times so how much time does it take it definitely takes it is bounded by this upper bounded by so the time complexity of this program is upper bounded by order of n times square root of n right n times square root of n it is a little lesser than that but as importantly this this is what the type bound is okay who can we do better now the question is can we do better this was the simple approach we had the program we had this function this prime that we have already coded right and we simply say okay let us go through all the numbers and let us check them so this will take this much time the question is can we do better all right cool so the answer to this is yes right in general yes there is something called civil wars receivable algorithms right and there's a lot of different civil wars so one of the most females that you will come across is the sieve of eratos venus right the sieve of eratosthenes and this is how you pronounce the name you say era toss thinness okay eratosthenes so this thief alcohol can achieve much better time complexity all right now let us continue this particular thing in tomorrow's class [Music] all right we are going to keep the today's class simple enough because you will have a lot of practice problems that you can go and try we will talk about this simple problem tomorrow and this is a very elegant one this is a very nice algorithm it is also very simple to put right so it only has like five to six lines of code and that gives you a very powerful algorithm that that checks that finds all the numbers all the prime numbers up to a given number all right cool so one thing that ankush is pointing out over here or not just where did that comment go interesting hmm that comment just vanished yes so ankush is pointing out over here that in this particular program that you wrote right in this particular program that you do you write this loop as i equals to 2 or the middle square root of n we can rewrite this in this manner as well right so i am just pointing it out over here as ankur said that these two loops are equivalent i equals to 2 i is less than equal to square root of n i plus plus this loop is the exact same as this loop for i equals to 2 i times i is less than equal to n i plus plus okay so instead of calculating instead of calculating the square root of n and then comparing it with i we square i and then we compare it with n right it will work exactly the same and this is one more way more way that you can do it if you if you want to do it this way then you will have to pre-calculate the square root of n right you will say square root of n equals so you will use some sort of a math library you will say math dot square root of n and things like that so if you do not want to do that you can simply use i into y all right brit says but don't we have to check for overflow will not really bridge because i into i will not overflow right if i into i overflows then l itself should overflow does that make sense we are not really considering the overflow case over here we're talking about not two big numbers okay we are talking about numbers that just fit in the integers now if n fits in the if n fits in your memory if n fits in let's say a 64-bit integer then i into y will also fit in 64-bit all right srivas says sir how to deal with very very big numbers well there are a lot of different ways that you can tackle big numbers one very common approach is to use a big integer library right big integer library right but usually uh this is not a very good approach right first of all the question is why why would you need to deal with big numbers right if you are implementing let us suppose some sort of an rsl model and you want to check if a number is prime one then you might have other ways of generating large prime numbers right in practice we don't really have to deal with very we don't have to check very large prime numbers with something like a c with something like a c we don't do that okay so let us end the class once again please subscribe to the channel hit the bell icon so that you can be notified of the videos and in the next class itself we will be going over prime members once again and we will be going over a lot of different things so we have to cover gcd so greatest common divisor euclid's algorithm for that we have to cover model arithmetic in a lot of different topics all right so please make sure that you subscribe to this channel hit the bell icon and please please go and practice the problems hello everyone so uh in the last class prague has taught you uh about how to check whether a number is prime or not okay so is everyone clear that if given a number n can you all check whether the number is prime or not now once you know that other number is prime or not now let's try to modify the problem a bit okay so instead of getting a direct problem of checking whether a given number is prime or not let's say that you have to print first n prime numbers okay given a number n you have to print the first n prime numbers or another question could be that you have to print all the prime numbers less than another question would be that you have to print all the prime numbers in the range from n to r okay so these are the three types of questions which we are going to solve optimally in today's class okay now if you all remember if when you have to check whether a given number is prime or not what is the time complexity of that operation you are going to run a loop that starts from 2 goes till square root n right and with every number in in this range you try to divide n and you see whether n is divisible by that number or not if n is divisible by none of the numbers then you can see that you can say that the n is right so the time complexity of this operation is order square root n right now if you have to check if you have to print the first n prime numbers what will be the time complexity of this approach if you have to print first and prime numbers you will be checking for all the possible numbers right you will run a loop for all ah numbers from 1 to n and then you will run another rule maybe you will have to increase the size of the first loop because first n prime numbers might exceed n as well right so the time complexity of this is going to be n root n right for each and every number you will be checking uh you will be running a square root and check right similarly if you have to print all the prime numbers which are less than n again uh the same time complexity will be there n root n if you have to print all the prime numbers in the range from l to r then again size of range multiplied by square root n so all these types of questions can be solved in this time complexity and interest by root n using a very easy check prime algorithm that we have learned in the previous class okay can we do it optimally can we do something to make all these problems easy for the computer now there is a very very well researched algorithm with very famous algorithm which many of you are already writing in the comments it's called the siege algorithm right so in today's class we are going to learn about the saves algorithm okay do you guys understand what is a sieve what is the literal meaning of a sieve if you just translate see in the what is that it is nothing but a channel right this is chai hairpin so it has a net very fine net and a handle right this is a sieve right and printing all the prime numbers using a seed is going to be exactly same as how you filter your tea okay we will see how so you have a utensil right in this utensil you have the cooked chai right and then you pour it on the seeds and then after this you have your tea mug right so at this point this complete mixture is called chai right at this point you say that everything which is there in the utensil is my child but when it is filtered then whatever the seeds is going to function in an exact same way we have to figure out what are the prime numbers we will say that all the numbers are prime right so we will take uh all the numbers and we will say that all of them are prime then we will pass them through a series after passing them through through the seeds we will see that only the actual prime numbers are remaining all the composite numbers will be filtered out by the seeds okay let us see how it is going to work so first of all let us write down all the numbers which on which will be running the saves okay so we have all these numbers initially just like the t i'm saying that all of them are prime okay all the numbers are prime now for one we are very sure that one is not a prime right is is everyone clear with this thing that one is not a prime right why is one not a prime because the prime number has to have exactly two divisors one has got only and exactly one degree so one is not a prime so we can directly remove one okay now whatever is the first number which is present in this uh in the list of all these numbers which is available in the list we will say that this number is a prime number okay so what is the first available number here the first available number is 2. so i am saying that 2 is a prime number so we will filter out 2 2 comes out of the seats okay so we have poured all the numbers uh here till 40 and now 2 has fought who has been successfully he has crossed the 6 okay one has stuck here now if 2 is a prime number can i say that all the multiples of 2 will never be a prime number right because all the multiple software will definitely have one as a divisor themselves as the divisor and also 2 as a divisor so they are not satisfying the criteria of being a prime number does this thing make sense to everyone does this thing sounds obvious to everyone that any multiple of 2 can never be a prime number right so if any multiple of 2 can never be a prime number so what can we do filter them out cut them so i will just cut all the multiples of two which are present in this list so 4 is gone 6 is gone it is gone 10 is gone right so all these multiples are removed from this list these all have been filtered out and thrown away what is the next available number which is there in receives what is the next number that i can see the next number is 3 so i can say that okay 3 is also a prime number let's add 3 as well okay once i am declaring that 3 is a prime number can i say that any multiple of 3 does not stand a chance for being a prime number any multiple of 3 is always and always going to be a composite number right so let us filter them out let us remove them from the list so let us remove all the multiples of 3 6 has already been removed then we remove 9 12 has already been removed we remove 15 18 is already gone right and then 21 24 is gone 27 and then 33 36 is already one then 39 okay now which number is the next available number in this list the next available number is 5 right so i can say that 5 is also a prime number okay so out of all these numbers we have till now filtered out three numbers which are prime numbers right so now 5 has come so any multiple of 5 will never be a prime number so all the multiples of 5 will also be removed so currently i can see that all the multiples of 5 have already been removed 10 is gone 15 is gone 20 is already gone 25 is remaining so we will remove 25 as well and then 35 okay then what is the next available number in this list the next available number here is 7 so 7 becomes the next prime number okay and all the multiples of 7 will also be removed so now uh 14 is gone 21 is gone 28 is gone all the multiples of seven have already been removed okay what is the next available number that we have now we have 11 so 11 becomes the next prime number and all the multiples of 11 again have already been removed then we have 13 then we have 17 then we have 19 then we have 23 then we have 29 then we have 31 37 and that's it so now you can see that we have got all the prime numbers in the range from 1 to 40. these are all the prime numbers all the prime numbers which are less than 40 are now with us is the idea of the algorithm make sense to everyone is the idea clear how the alloy is going to work initially we said that all the numbers are prime numbers assume that all of them are prime numbers pass them through the sieves what does the sieve do for us see if takes see the sieves algorithm takes the first available number and uh and declares it a prime number so we declared that 2 is a prime number since 2 is prime number none of its multiple can be a prime number cut them out remove them then take whichever is the next available number call it a prime number remove all the multiples of this number as well okay now let's try to see how can we write the code for this okay the code is going to be very very uh small very very easy right so what we are doing here is initially initially what we are doing is we said that let us first take all the numbers so if let's say we have to print all the prime numbers in the range n so then we take an array prime of size n plus 1 because if if n is 40 and indices are going to start from 0 so i also need 40 as as an index index so i will take the size as n plus one okay and i will say that all of them are prime okay so this this primary what what does it hold this primary for every index it holds true or false based on whether the number is prime or not right so currently i am saying that this is if this is my array okay currently i am saying that all of them are prime so have true for each and every index okay then what we will do is we will first declare some of the well already known values right so we know that 0 is not a prime so we can say that prime of 0 is false so this will be turned false and we also know that prime of one is also for one is also not a prime right so one will also be converted to false now starting from 2 to n we have to check each and every number whether they are prime or not so how how did we do this uh in this algorithm we selected whichever is the first uh true value basically the first available means the first true value which is currently declared as a prime number right so we will run a loop which will start from 2 and this slope will go till i uh sorry till n and will be incrementing the value of i one by one and then we have to check whether this value has been removed or not so if it has not been removed then we will always be having a true value okay so we will just check if this number at index i if it is true if this number is currently a prime or not what is the first available prime number that we have here right if it is a prime number this means that none of its multiple can be a prime number so for all its multiple make them false so if 2 is true 4 6 8 10 all these numbers should be turned to false so i will just run a loop star uh let's take a different value variable so now what we have to do for i we have to uh make 2i 3i i all these numbers as false right so we'll quickly run a loop starting from 2 and we'll see till where we have to run this loop and then do this we'll say prime of i into j right so i is already there this is our j right this has to be false so we till till what value we have to increase j we don't know right we don't know that so we actually don't know till when we should be incrementing it but what we know is that this product this three i four or j i this can never be greater than the maximum value that we have so this product can never be greater than n this always has to be less than or equal to n right so here what we will have is j into i is less than or equal to n okay because if if you see in this list when when you start when you select i is equal to 2 then from where to where your j ranges j starts from 2 so if j is equal to 2 you cut 4 then j becomes three you cut six j becomes four you cut eight and you will go till 40 right so j becomes 20 you don't want to increase j such that you are targeting you are trying to cut a number which is greater than 40. so always we are keeping i into j less than or equal to n okay cool uh now let us see let us try to uh quickly see what happens when we are actually cutting the numbers right so uh when when my i takes a value 11 okay when i'm taking when i'm taking a value 11 uh in this case when we selected 11 what was the first number that we tried to cut the first number that we tried to cut was 11 into 2 which is 22 right so if i is 11 we are going to check it for value of j is equal to 2 right which will give us 22 then we will try to cut 33 then we will try to cut 44 then we'll try to cut 55 and so on then j will become 11 and we'll cut 121 and so on right now i have a question when i'm trying to cut all these numbers for the value of i equals to 11 can i say that 22 33 44 55 all these numbers would have already been cut because before before i takes the value 11 i will also take the value 2 when i take the value 2 22 would have been cut by that right so you must have observed in this case also that when we reach to 11 all the multiples of 11 were already cut right when we raised to 5 what was the first number that we cut 10 was already gone using 2 15 was already gone using three 20 was already gone using two what was the first number that we cut using five it was 25 if i if i start from 11 then we can see that none of the multiple of 11 is available here which has not been cut all the numbers have been already cut right why why that happen because before taking a value 11 i must have taken all the values which are less than 11 so all those values have already been cut so 22 has been cut by 2 33 has been cut by 3 44 has already been cut by 255 has been cut by 5 and so on right so what should be the first value from where we should be starting the second loop from here we should start the second loop this has to start from j is equal to i right because when when we were trying to cut the numbers from five we saw that the first number that we are getting is 25 similarly for 11 the first number which will be available there is going to be 121. all the other numbers must have been there by the smaller values of phi so we don't need to start from 2 we can start j from i okay now if if we are starting j from i what is the maximum value that i can take do we need to run the first loop till n okay let us let us try to again try to analyze the second loop and that will give you the answer whether we should be running the first loop till n or not should it start should it go till n by two so what is the maximum value that we have to get the maximum value that we have to cut is here 40 right okay and whenever you are starting to cut you are always starting from the i value that which means that the first value that you are cutting is i square right for two you are cutting the first value that is being cut is four right for uh for three the first value that you are cutting is nine for five the first value that you are cutting is 25 for 6 the first value that you will be cutting is for 6 you will and you won't cut any value for 7 what will be the first value that you will be cutting for 7 the first value should be 49 7 into 7 is 49 is 49 in this range no 49 is out of this range so what should be the maximum value the maximum value till which we can go is i square so i can never go beyond square root n right because the first number that you are cutting here uh like like this this number which is the last number would have been cut when i becomes square root n right so this n can be turned to square root n right so either you can say i is less than equal to square root n but if you are using this function square root n this is an expensive operation of finding finding a square root of a number is actually expensive operation it will take at least log n time so what you can do is you can replace this by i into i less than equal to n so now you are doing that in order one operation this is going to take log and time at least if you are printing the integer part right using binary search okay so now let us come to the time complexity okay this loop the first loop is running from 2 to square root of n let us let us actually remove all the optimizations that we have done we will try to calculate a very relaxed upper bound okay so tell me one thing when the value of i is equal to 2 how many times does the inner loop run if let us say that this is starts from 2 if we are considering the previous loop the the totally unoptimized loop which was starting from 2 and going till n and this loop is also going till n we are considering the most unoptimized version now tell me if value of i is equal to 2 how many times are we going to run this through this loop will start from 2 go till n by 2 right we will be cutting exactly n by 2 numbers for i is equal to 3 how many times is the inner loop going to run the inner loop is going to run for n by 3 times for i equals to 4 how many times is the inner loop going to run for i equals to 4 is it going to is it going to run for n by 4 times for i equals to 4 so see what happens is when when i takes a value 2 then i takes a value to we cut 4 we say that now 4 is not a prime because 4 is a multiple of 2 and before running this loop we are always checking whether i is prime or not is 4 a prime no 4 is not a prime so this loop the inner loop is going to run how many times exactly zero times this if case is going to fail for four right for five it is going to turn for n by five times for six this is going to run for again zero time six is not a prime for seven this is going to run for n by seven times right so can you see a pattern here if we have to add all these time complexities what will what will we get will be getting n by two plus n by three plus n by five plus n by 7 and so on what are these if you take n common from here you get 1 by 2 plus 1 by 3 plus 1 by 5 plus 1 by 7 plus 1 by 11 plus 1 by 13 and so on what are all these these are nothing but sum of reciprocals of prime numbers right first n prime numbers basically correct so i can say this this is equal to i equals to 1 to n 1 by all the prime numbers the first n prime numbers or maybe all the prime numbers which are less than n right all the prime numbers which are less than this is the time complexity now if if you are really really good at mathematics you will be able to you you will be knowing that this whole sum can be approximated to log of log of n okay so this is the overall time complexity of seeds algorithm okay so if you are really good or if you are interested in mathematics you can read about the martin's theorem which proves this thing okay that sum of reciprocal of first n prime numbers is same as log of log of n so the overall time complexity can be approximated as order of n into log of log of n okay uh okay i will quickly brief over the time complexity part once again okay so if we we are just checking for every value of i how many times is the inner loop going to run okay so i said that if i is equal to two how many times is the inner loop going to run in a loop is going to start from two we are com we are assuming the most unoptimized version we are removing all the optimizations that we have done so in a loop will start from two and it will run for n by two times right if you are starting from two and you have to go till 40 you will be running 20 times right you will cut 20 numbers in this loop similarly for i equals to 3 you will be running the inner loop for n by 3 times for i equals to 4 now this is a very important thing that before running the inner group you always check whether this number is prime or not 4 is not a prime so for four the inner loop will never run for i equals to five uh the the loop runs for n by two uh n by five then for six again since since six is composite loop does not run then for i equals to seven blue prints for i n by seven and so on so if you add all of them right because then you have to calculate the time complexity you will be adding how many times uh the inner loop is running in total right and that will be the overall time complexity so if you add all of them you get the series here if you take n common then you get something which is nothing but the sum of reciprocal of all the prime numbers and if you apply martin's theorem if you are aware about the mertens theorem you will be knowing that sum of reciprocal of all the prime numbers can be approximated as log of log of n so that is why the time complexity of steve's algorithm is order of n log of log of n okay now this is the most relaxed uh time complexity that we have achieved because we removed all the optimizations right the optimization that uh says that the first loop should run only till square root of time this loop should start from i we have removed all of them and then we have calculated so whatever if you do any optimization here your elbow is definitely going to be better than this time complexity okay the question is will this work for a range whose first element is not a prime number this is only going to work if you are starting it from 2 if you are starting from any random number this algorithm is never going to work right because you have to make sure that all the composite numbers are cut so if let's say you are start if you are trying to find the numbers in the range from 40 to 100 right so you have these numbers and now if you start cutting the numbers uh from from 40 you're you're trying to cut the multiples of 40. this is not what seeds is suggesting see if is saying give me the first prime number what is the first prime number first prime number is two cut all the multiples of the first prime number not the first prime number in this range the first prime number overall right so you will always be starting or this algorithm will only work if you are starting cutting the numbers from two however if you have to find the numbers in a range what what you can do is you can pre-compute all the prime numbers so what you can do is if you have what what would be the maximum value of range then starting from 2 to that range you can pre-compute all the prime numbers okay once you have all the prime numbers in this range now what you can do is you can this this array is going to be sorted and so you can apply binary search and you can find all the positions of the uh lx prime number and rf prime number and print all the values okay cool you see is the same's algorithm clear to everyone including the idea the intuition and the code is everything clear to everyone great now now what we'll do is we'll try to see a problem okay so we we still have uh 30 minutes so we'll try to solve a very very good problem which is a very commonly asked problem in a very generic problem okay the problem says that given a number return the prime factorization of this number what is prime factorization so is everyone here clear with the theme that any composite number can be written as the multiple of all prime numbers not all prime numbers but a multiple of prime numbers is even clear with this thing if if i give you n is equal to 24 what would be what would be the prime factorization of 24 24 can be written as 2 into 2 into 2 into 3 basically 8 3's are 24 right so 8 is nothing but 2 raised to power 3 so 24 can be written as this so the prime factorization of 24 would be 2 2 2 and 3. this is what you have to written okay is the problem clear to everyone if if the value of n let's say is 10 you will be returning 2 into 5 okay if if the value of n let's say is 42 then we have 2 3 and 7. okay is the problem clear to everyone given a number n you have to return the prime factorization of n prime factorization means you have to uh represent that number in terms of only prime numbers and that is possible for each and every number right because any number either will be a a prime number or a composite number if it is a composite number you can further divide it into prime numbers right for example if n is 24 you can write it as 2 to 2 into 3. uh there can be many ways can there be many ways one just try to think and figure out can there be many ways if you are if you are breaking down the number into prime numbers not composite number none of the numbers in the returned array should be a composite number okay what can be what is the first thing that comes to the mind so if let's say i'm given 24 and i have to so we we must all must have done this in schools right we all have done the prime factorization of the number in school in the elementary mathematics site this was i think in sixth class maybe or fifth class when we learned about the prime numbers right so how did how did we use to do it at that time so if i am given 24 what will i try to do i will pick what is the smallest number with which i can divide it right so the smallest number that i can figure out is 2 so i will try to divide 24 with 2 i get 12 okay and this 2 gets added to my answer now i have got 12 and i know uh that again i have to the exact same thing find the smallest number with which i can divide this and that number obviously should be greater than 1 right so again here also the smallest number that i can think of is 2 so i divide it with 2 i get 6 again i can divide it with 2 so i get 3 now 3 the smallest number that can divide 3 bigger than 1 is 3 so i get finally 1 all these numbers are definitely going to be a prime number because we are always selecting the smallest number right if that smallest number is not a prime number then there must be a number which is smaller than this that can divide this number does this make sense to everyone what i am trying to say is if there is a number x which is the smallest number which is dividing uh 24 and x is not a prime number if it is not a prime number then it must be a composite number and then it can be broken down into two prime numbers at least right so 24 will also be divisible by these two so that means x was not the smallest number that can divide it there are smaller number than x which can divide 24. so using this proof by contradiction i can always say that the smallest number which is able to divide any number is going to be a prime number okay now how to code this thing i'm just going to code the same approach that we used in our fifth sixth class mathematics right so to do this first we can initialize uh an answer array or maybe a prime factor array and what what we are going to do is so here in this case i i just use my mind and and saw that this is divisible by 2 but for computer we will have to check with every number starting from 2 right what is the first number that divides 24 and then keep dividing it by that number till it is divisible right so i will start from 2 and i will say that this has to go till somewhere and then i plus plus and then i will say while this is divisible if it is not divisible then it will not go inside the loop but if it is divisible first of all add this i to the answer so we'll do prime fact dot at i okay add this to the answer and then divide divide n so n will become n by i okay so what we are doing in this case is n is initially 24 right we are starting from i and we are and the first value of i is true so we are checking if it is divisible if it is divisible then keep dividing it till it is divisible so we divide it make it 12 n becomes 12 then the loop still checks that this is still divisible by 2 so keep dividing it keep dividing it and also keep adding it to the answer so the answer will have 2 then in the next step again 2 and then again 2 then you have 3 so this is this will break out because now n mod three is not divisible sorry n mod two is not divisible n has now become three right three model is not equal to zero so we will increment the value of i so i now becomes three so then we will check and mod 3 is now divisible so we'll add 3 to this and we'll divide and further so now n becomes 1 okay so the question is till then this loop should run what should be the breaking condition here what can be the maximum number that i can take the maximum number that i can take is we may use set instead of array no you cannot take side because set will guarantee that the occurrence of every number will be limited to exactly once whereas we need three twos if you are taking a set you will have exactly one two right so set is not useful in this case you will have to take a list array list or array which supports multiple operands of same character right right so what what should be the maximum value that i can take the maximum value that i can take obviously is going to be square root of n right so the i that we are going to increment is going to be till square root of n okay now uh this code is going to print all the prime factors for us i can see that there are two mistakes in this code two very big mistakes can you guys quickly figure out them this code has two blenders and one of them is the most most commonly done mistake while writing a code even when people write the most simplest of the codes they make this type of mistakes can you quickly figure that out it doesn't work for zero and one yes so this is guaranteed in the input that n will always be greater than one because even the question who is the person who is asking the question knows that zero and one will not be uh are not eligible for this question okay right so i can see that one of the mistake has been pointed out uh the other mistake no one is able to guess let us see let us see what we are doing uh let us quickly reiterate over the code we are saying that i is starting from 2 i should go what is the maximum limit that i is taking it is taking square root of n so here instead of this i would be writing what actually square root of n or maybe to keep it optimized let us have i into i less than equal to n right this is the more optimized version of this same thing okay so what we are doing here is we are initializing i we are checking that i should not go more than square root of n and inside this loop what we are doing is we are changing the value of n correct n is changed inside this loop n is also there in the breaking condition so initially we started this loop with an assumption that n is going to be 24 so the maximum value that i can take is going to be root 24 in the next iteration you changed n to 12 so this loop here now this this condition is not going to hold true because n has been changed this is the most common mistake that i have seen students doing while writing most easiest of the books if you are changing a value inside the loop you should never be taking it in the breaking condition so always do one thing assign some variable this value and then use it here okay otherwise you will see your code behaving in very unexpected way and you will not be able to realize what is going on wrong there okay so assign the value and then keep it inside the loop this is my mistake what is this other mistake the other mistake most of you have already pointed out which is if if if the number is already prime right if the number is already prime uh or maybe number is uh having uh the number is having a prime factor which is greater than square root of n right if a number is having a prime factor which is greater than square root of n for example let us talk about 404 okay so for 404 how will this loop run we'll start from 2 we check that 404 is divisible by 2 we divide it okay then we again check that this is again divisible by 2 we divide it now this is not so we have added 2 and 2 in the array now this is not divisible by 2 then this is not divisible by 3 and what would be what would be the maximum value of that i will be taking in case of 404 the maximum value that i can take is going to be 20 right because the square of 21 is going to be greater than 404 right so the maximum value of i is going to be 20 but we can see that for all these values of i the prime factorization of 404 is not complete right so what we can say in this case right because this this is not complete 101 would also have been there correct so this is another mistake in this code how to how to fix that mistake can i say can i say that even after removing all the uh possible prime factors from that number if i have got a number which is greater than one that number must be a prime number can i say this so to just to actually fix this code can i just add another if condition it says that if if this number is still not reduced to 1 that means that this number has to be a prime number so directly add this remaining number as well so what we will do here is if n greater than 1 then prime factor dot add and we'll add this line here itself after the for loop completes so if this number has not been reduced to 1 we will add 101 as well and we will get the correct answer does this make sense to everyone so this is uh about prime factorization what is going to be the time complexity here what is the time complexity of this code so calculating the time complexity is pretty easy here right if the first loop runs for how many times the first loop runs for root n time okay then the second loop runs for the second loop is going to run for how many times we are dividing the number uh and by i every time in every iteration so how many times the second loop is going to run the second loop is going to run for login time so what should be time complexity is it going to be root n into log n is the time complexity going to be root n into log n no right this is wrong this is not going to be root n multiplied by log n okay why we we can we can quickly see that this loop runs for root n times and here we are dividing the number by i every time in the worst case the value of i is going to be 2 so in the worst case if you are dividing n by i how many times can you divide it if if given a number how many times can you divide that by 2 this is given by log right this is given by log of 16 law whatever is the value of log of 16 you can divide 16 that many times by 2 right but this is incorrect y so let us try to analyze what is going on here so if if we have a value if we have a value let's say let's take 16 itself okay so in the first iteration when the value of i is equal to 2 we check that this is divisible and we divide it so we get it then again we divide it by 2 we get 4 again we divided by 2 we get 2 again we divided by 2 we get 1 okay now after we have divided completely with 2 for the next value of i which is equal to 3 how many times is the inner loop going to run for three how many times is the inner loop going to zero times right inner loop is not going to end because this has already been reduced to one okay if this has already been reduced to one now this inner loop will never run again if this inner loop is not going to run again for three number of iterations are going to be zero for four the number of iterations are going to be zero right so what is the total number of times including all eyes the inner loop is running for all the eyes the inner loop is going to run for log n time this is not for each and every i this is for all the eyes combined for 2 it runs for log base 2 and then for 3 it runs for log base 3 and if n is there right so if let us talk about any other number so if i talk about 24 2 can reduce it to 12 then 2 can reduce it to 6 then 2 can reduce it to 3 now 3 is not going to have log base 3 24 these many steps because 3 is going to reduce this number which has already been reduced by 2 right so the total number of steps including all the i's combined is going to be log of n so this is going to be log of n plus square root of n which is nothing but square root of n so the time complexity of this algorithm is going to be exactly square root of n not root n login okay guys in mathematics there are multiple topics which are very very important uh for for for programming point of view or both the interview point of uh point of view as well right so there is modular mathematics that that you must learn and you must solve multiple problems on this okay then there is gcd the lcn and hcf problems okay gcd is also very very important concept okay then of course you you definitely have the prime numbers uh and in the prime numbers you you can also optimize this approach that we have discussed right you can optimize this approach using a concept called the smallest prime factor of a number which is called the spf which we haven't discussed in the class but this is also very important concept okay so after the class please go through this what is spf and how you can actually optimize this algorithm using the smallest prime factor okay and then in the modular mathematics there is also format theorem which is very important just google all these concepts uh and go through all of them try to solve problem based on all of them okay they all are very very important they will help you in problem solving as well as in interviews okay cool so uh this is it for today's class if you like the video if you like uh if you understood everything please like please share it with your friends uh please tell us in comment which all topics you would want us to discuss next okay tomorrow's class is going to be on bit manipulation so if possible before joining the class if you can go through how numbers are represented or what what are the basic bit operations then the class will go very smoothly right so next class is going to be on bit manipulation so just read about some bit wise operators like or and or left shape right shift etcetera just read about them and if you found this video useful you can just like it and share it with your friends okay why do we use arrays so extensively everywhere the reason for that is because areas provides us random access in order one time complexity right and this is the biggest advantage of it in most of our use cases we want to access random index in the most optimal way that is why we use searches but this random access of any index this also comes with a cost right do you guys know how an array is able to provide order one random access so array is able to provide order one dynamic axis because all the elements of an array are stored in contagious memory location which means that let us say if i have an array of size 4 and first element of there is let's say stored somewhere here that means that the next element will be stored next to it the third element here and the fourth element next to it so all the four elements are going to be stored next to each other in the correct sequence as well and we are only going to have the address of the first element of the and using that since you know the size of the data set using that you can find the in the address of any index in order one time and then you can access that value this is how array provides us order one random and axis but for this to happen it also needs to know what is the size of the array beforehand before you create the array you need to know what is going to be the size because only then these many slots will be allotted these many slots will be reserved for this array and then you can use them to insert or access the values in the area right so you need to call out the size before you are creating there and that is the reason why whenever you create an array you have to declare this size you cannot create an array without telling the size of the array now how how is it a disadvantage so the disadvantage which lies here is that whenever you are creating an array you need to have a very good idea about how many elements are going to be there in the area because if the size that you have you have given here if that size is very large than your actual data set which means that you have created an array of larger size but you have very few elements to fill in there then that means you are going to waste memory right because if you have let's say create an array of of of these many slots but you have only filled uh let's say two elements inside the array since all these slots have been reserved for this array they cannot be used by any other thing right so if you are not filling them that means that this memory is wasted on the other hand if the number of slots that you have created the size of the area that you have if it is smaller than the size of your data set then you can definitely not insert all the data that you have for example in this area of size 4 if you want to insert so let's say we have this area of size 4 here and you have filled this complete array all these slots are occupied now if i want to insert a fifth element inside this array is that possible can we extend the size of the array no right that is absolutely not possible because these slots which are next to the zeroth or the last row they might already have been taken they might not be free and this is not how you can simply explain the area right maybe we cannot do this in in a normal area but we can do this in a vector or in an arraylist you even if an arraylist is filled even if a vector is filled you can still insert values inside internally vector or an array list is also having an array a normal array only and when that array gets filled the best that we can do is declare a new array discard this array declare a new array of a larger size right so if you declare a new area of larger size which means that another set of contiguous memory locations will be allotted to that array and then you can copy all these values from your original array to this array all these values are now in in this new array and then in the subsequent slots you can insert the new values right so if you had this area of size 4 uh if it gets if it gets filled in a vector or in an array list the new array will be created of larger size these values will be copied and then the new values that you need to insert they will be inserted in the subsequent stops and then this array will be discarded and once this new array gets filled the same thing will repeat again another new area of larger size will be created all these values will be copied and then the new values will be added in the empty slots so whether you are using a normal array or a vector or an list it totally does not matter because both of them are working in the exact same way using contiguous slots in the memory and whenever you try to book continuous slots whenever you are trying to reserve these container slots there are a lot of chances of wasting the memory it is definitely our the best suited data structure if we require fast random access but if we do not require fast random access in that case we can optimize for the memory we can save some space and we can save us ourselves from wasting extra space by using a data structure which is one of the most important data structure with respect to the interviews especially if you are if you want to prepare for companies like amazon microsoft or adobe and this data structure is known as the link list so we are going to study linked list in today's class we are going to see link is from scratch how it is stored how it functions and we are also going to solve a lot of interesting problems on linked list okay so now let's see how using a linked list can actually save space for us right and always remember that use when whenever we are using linked lists we are not going for we do not aim for having a fast random access and that thing is totally lost but we are going to save some space right and let us see how we are going to save space for it so in an area this space was being lost because we were trying to reserve a chunk of of memory location next to each other for the error and if that is not being used then all that memory is wasted right but in a linked list what we are going to do is first of all we do not reserve these spaces in chunks right we are going to reserve once one slot at a time for one data right so for example if you want to insert four in your linked list then when you want to insert four when you want when you actually create a node in your linked list only then are you going to reserve this slot or insert four in in this slot right and let's say that we want to insert five then only when you want to insert this number only then you are going to do this and these slots do not need to be next to each other they do not need to be con they do not need to be in contiguous slots they can be anywhere right for example if you want to insert 7 this 7 can be somewhere here as well and these slots also need not be in the same sequence they again the sequence can also be completely out of order for example if now you want to insert three this three can also be somewhere here okay so all these slots are arranged randomly wherever you find a slot in the memory you can insert these numbers but now the question is that if they are stored in any slot in any random location then how do we preserve the order in which we have inserted the elements how do we iterate over these elements in the exact same order to preserve the order we need to have something known as the links every element should also have the information about what is going to be the next element so element definitely cannot have the information but every node should have the information and that is the reason why the class the list node class that you are going to have is going to not only have this data but also a link to the next point okay so the node class that we are going to have it's going to have some data and this data can be anything this can be integer float double string character array hash map anything but for simplicity we are taking integer right now right so it's going to have a data which are these values in our case and it should also have a reference to the next node okay so this difference we are generally going to represent with the name next okay so this means that all these nodes which we have stored in the memory they are not only going to have this data but along with this data they also have this reference which means this stores the next pointer 5 stores the next pointer to 7 and 7 stores the next pointer to 3. so whenever you need to iterate over this list you should have the address of the first element and if you have the address of the first element you know what is the next you know what is the next of that you know what is the next of that and so on this is the reason why you you if you might have seen like i'm sure all of you must have seen a representation of a linked list right and it is represented something like this so all these squares which are created in a linked list these are nothing but they all represent the node and inside these you just insert the value which is there in the nodes these arrow pointers represent the next pointer which means that after 4 you are going to get 5 after 5 we are going to get 7 and so on for 1 since this is the last node of this linked list there is nothing after this right which means that the next pointer of one next pointer of this node is going to point to nothing it's going to point to null right and we are going to represent null like the earth symbol one very important thing to keep in mind guys which will also be used in a lot of problems that will be solving that in a linked list we can only iterate from left to right direction right because every node is holding the information about what is next to it in a normal linked list you don't have information about what is previous to it you only have the information about which node is next to it which means that you can only iterate a linked list from left to right correct so if if that is the case that you can only iterate the link list from left to right and if you want to i create over the complete linked list what is the minimum information that we need to have for that the minimum information that you need to have if you want to iterate over the complete link list is the reference or the address of the first node okay so having the first node is essential because if you do not have the information about the first node let's say you only have this node then you cannot go back and visit these nodes right so it's it's like these nodes do not exist for for you you can only move from here to the right side okay and this is the reason in all the questions that you will be solving uh whenever you have given that you are given a linked list that means that you will always be given the reference or the address to the first block of the link list and this first block is generally known as the head this is known as the head of the linked list cool so if that is clear let's maybe quickly solve a problem so the problem says that you are given a linked list and whenever we say that given a linked list you will only be given the head pointer right and because all the complete link list is linked from that head pointer so that is why you will always only be given the headphones okay so you are given a link list uh you need to find out what is the length of the linked list okay is the problem clear guys the values inside the linked list can repeat also the linked list is not in sorted order okay you need to find what is the length of this link so length of this linked list is going to be five we will quickly see how to find the length of the link this because there are few important points that we need to notice here first of all we are given uh the head of the linkage right we are given this the reference to this node and we also know that there is exactly one node in this complete linked list whose next is equal to null right there is exactly one node whose next is null and this node is definitely going to be the last node of the linked list so what we have to do here is we just need to iterate we just need to go next and next starting from the head pointer till we reach a node whose next is equal to null right so till our node becomes null we can keep counting all the nodes so let's say that the length is initialized with zero and then we can say while your head not equals to null till it is not equals to null we can keep incrementing the length and we can keep going to next is this code clear to everyone simple but there is something wrong in this code case so what we are doing here is let let us say that this is the linked list which is given to us right and the initial head was pointing here what we did was we started with l equals to zero head is currently pointing here and then we say if head is not equal to null increment l length keeps increasing and with that our head pointer is also moving and this is going to stop whenever head pointer reaches null so when you are done with this whole thing when you are done with this function the position of your head pointer is this null node now since you have changed the position of the head pointer can you again iterate over the list if it is required that you need to iterate over the list again is that possible now no right we have lost the list right we have effectively lost our link list that is why you have to make sure that whenever you have to iterate over the linked list you do not change the head pointer you will have to fix your head pointer here then you can take some temporary variable with a meaningful name and you can iterate that temporary variable instead of your head pointer okay your head will remain steady does that make sense to everyone okay so now before we start solving the problems uh let us first see some some of the basic operations like insert or or delete in a link list right okay this actually the time complexity of insertion in a linked list is going to depend on where you want to insert the values right uh so we are going to consider three cases here first is going to be insert or late from the top or from the first position or from the front and then from the back and at any kid's position so when you're inserting anything and you want to insert at the front so for example you are given this linked list okay and when we say given the link is that means that you are already given the head of the link is right so when you want to insert an element in this linked list at a different which means that you are going to update the head right inserting at front means your linked list is going to have a new head after the insertion right so for example if you want to insert 2 how are we going to do that first of all we need to create a node with this value once you call this constructor once you create this node we are going to have a node with value 2 and next pointing to null okay so we have this node after this line and then what we need to do is we need to connect this pointer this the next of two one for which we can say newnode.next is equals to the current head once this is done this pointer is removed from here and 2 is now pointing to 1 and now to make sure that 2 is a part of the linked list and 2 is also like it is possible to traverse 2 in this link this we need to update the head right so what we are going to do is we will say that now the new head should point to the new node that we have created and that is it which means that now this head will move from one and now it's going to start pointing to so we have created a node on we have inserted a node in the front of the linked list what is going to be the time complexity here guys time complexity of this operation is order one because we haven't done any traversal we have just created a node and insert it just change the pointer and center it in this right similarly when you have to insert in the back what do you guys think should be the time complexity in that case if you want to insert in the back right so in a normal english you are only given the head pointer of of the linked list which means that if you have to insert anything at the back you need to traverse till you find the null node and then you insert your new node there or or what you can do is you can maintain a tail point very similar to how we have a head pointer you can also maintain a tail pointer right with every insertion we can keep up updating the value of the tail pointer and the scale pointer should always point to the last valued node in the linked list if we have such a pointer inside our linked list then what is going to be the time complexity of inserting it back because now if you have such a pointer then then again you only need to create a new node first of all right so if again you want to insert two you will first be creating a new node two with its next equals null using the exact same line here and then what you need to do is you can simply say that tails next should now point to the new node so this 5 is now going to point to 2 and 2 is already pointing to null so that is it and now we just need to update the tail so we will say that the tail should now be equal to new node so the tail will be updated and will be moved from this node to the new node that we have created what is the time complexity of this operation okay again it's order one okay now if you have to insert element at any random kth position in that case what is going to be the time complexity is going to be to be order n right because in the worst case you might need to traverse the complete list till the last but one node in that case you you the time complexity becomes order right now one thing to notice here is that if you have to insert element at any kth position right for example if this is 0 1 2 3 if these are the positions and if you have to insert an element in the third position which means between 3 and 4 here in that case you need the pointer of this node right you need the reference of this node because only then you will be insert anything after this so whenever you need to insert an element in the kth position you need the reference to the k minus one in node right they denote node which is present just after the required node so in this case what we are going to do is we again create let us say we want to insert 12 in this case so we create a node 12 and then we say so we we should be having if you want to insert it at the k position we should be having the k minus 1 node here and then we'll say that 12 next should point to whatever is the next of this node which means that 12 next should be made pointing to this node and then we will say that the k minus 1's node next should point to 12. so this will point here and this node is this link is broken and 12 is inserted in between and the time complexity as we have discussed is going to be order n in the worst case okay cool now very similar to insertion we can also delete the nodes from the front from the back and from any random care position right what is going to be the time complexity of deleting the first node from a linked list deleting the first node from a link list is nothing but just updating the head pointer that's it right because we know that anything which is before the head pointer is obviously not a part of the linked list right so if here is our head pointer currently and if we want to delete this node then if we just move our head pointer by by one position and we say that now the head is updated to this node and that's it right your node is deleted now if you're using cc plus then you can actually delete this node or you can free this node right delete this or free in cc so if you're using java you don't need to do anything because the garbage collection collector is there and it's going to do its job right so you just need to increment the head point time complexity is just order one because you are just updating the head pointer what about deleting from the back if i have to delete anything from the back can that also be done in order one we already have the tail pointer maintained with us right so we just need to delete whatever is present in the tail pointer can we do that guys in order one time so right if if we have this real pointer maintained here we can definitely just say that whatever is the state pointer this change into null as soon as we do this this starts pointing to null and this tail pointer the node which was pointed by tail is deleted but after we have done this now can we do another deletion from back in order one time no right we cannot update the tail pointer why because as we have discussed earlier you cannot go back in a linked list you cannot travel from right to left in a linked list so you cannot update the tail pointer while deleting a node that is how you can do first deletion in order one you just need to convert this tail to null but after that you won't be having any tail pointer maintained to the last node of the link is so after that you won't be able to do it so the time complexity here is going to be order n because then after you have done the first deletion you will have to iterate over the complete list and you will have to reach the last pointer to delete it is that clear to everyone same is the case for for the kth position as well in this case you will definitely have to travel till the k minus one position right and once you reach the node just previous to the kth node right so for example in this case let's say we wanted to delete this node if you want to delete this node then you need to you you need to reach the node which is just previous to this and then you will simply change the pointer here you will say that the next of this node should point to next of next and that's it again the time complexity is going to be order n because in the worst case you might need to traverse to the complete list cool so let's let's solve a problem which is again a very very frequently asked problem has been asked in amazon and microsoft multiple times the problem says that you are given a linked list you have to find the mid node of the linked list node which is present at the middle position okay so for example if this is your linked list so in this case the node which is present in the middle is this node so the answer is going to be 7 okay if there are even number of nodes in your linked list then you can return the uh first node of the second half which means that if this is the linked list then you can return this node okay you can find the length of the linked list we know how to do that if the length comes out to be l then the middle is going to be at the position l by 2. so you can start another iteration from the head and you will only travel traverse still till l by two distance and you will be getting the midpoint okay that is one approach another approach as suggested by many of you is by using two pointers right using a fast pointer and a slow pointer now guys a lot of problems in linked list will be solved using two pointers uh i traveling in multiple different ways uh that is why we will quickly see this approach and we'll try to understand the intuition behind this okay so as many of you have said that we can consider a fast pointer and a slow pointer when the first pointer reaches the end this low pointer will be at the middle point right so the intuition behind this is very similar to what would happen in a race of two parts let us say we have two cars and we are having a race between these two cars okay and both are starting at the same time from the same from the same position and both have to reach at this point now one of the car is moving with a speed x the other is moving with speed double that of the other car so when this car the moment this car reaches the end point where do you guys think would be this car the moment the car with 2x speed reaches the end line what would be the position of the other car the other car is going to be at the center of the road right exact center by because this car has a speed double that of the other car so the amount of distance traveled is also going to be double in the same amount of time which means that if it has traveled this l length then the other car must have traveled l by 2 length so if this works in in physics this is also going to work in our linked list so in a linked list what we can do is instead of having two paths we can have two pointers white raters right and one of the iterators both again both of them are going to start from the same point at the same time right one is slow the other is fast and the first one is going to move with the speed double that of the slow pointer just just like the cars which means that the slow pointer if it is moving with one step at a time the fast pointer moves two steps at a time so after the first iteration slow pointers moves from here to uh to the next position fast pointed moves from here to this position again the slow pointer moves from here to this position and the fast pointer moves from here to this position okay now fast pointer does not have any uh further nodes to travel so this means that this has reached the end and if this pointer has reached the end it has covered uh the complete distance that means that the slow point must be at the half distance right it must be pointing to the middle element okay so what we have done here is we have we are just moving two pointers starting from the head slow pointer moving one node at a time fast pointer moving two nodes at a time the moment fast pointer does not have any other node to move on the moment fast point is next is null or next dot next is null we stop there and at that moment wherever the slow point is going to point that is going to be the middle element if you like the video please do not forget to like comment and share this video with all your friends also subscribe to our channel to get notified about the new upcoming videos okay so today we are going to cover stacks so let me give you first a little introduction about stack so first of all uh the stack is very much important it's the most favorite topic of the interviewers the well versed with this topic like first go through the basics understand it because they're very straightforward and then attempt as many questions as you can there are some you know uh standard problems that you should definitely attempt that was the just about starts now let's get started cool so uh stack is very much similar to the stack of objects you see around yourself so be it stack of plates stack of books so stack off plate stack of books then stack off let's say bowels so you see it and use it every day right so let me draw the stack of plates so this is how a stack of plates look like now from the stack of plate you can insert a plate only from this end that is top right you can only insert a plate on top and you can only remove a plate from top you cannot insert or remove a plate from in between because that will disturb all the plates right so you cannot do that you can only remove and insert a plate only from top so that's essentially the idea behind staff that we can only insert an item from top and we can only remove an item from top okay so conceptually or logically you can think of a stack like this where one end is open and three ends are closed so from only this end we are going to perform operations that is to remove an item and to insert an item as i was saying that we can only insert an element from one end and remove an element from that end only and therefore stack is known as the lifo data structure that is the last as you can see the stack of plates over here so this plate which was inserted at the variant will be the first one to come out that is last in first out okay cool so first what we are going to do we are going to understand stack as an abstract data structure that is adt abstract data structure what do we mean by abstract data structure in which the implementation details are hidden but the operations are given to us okay so let me write it over here that implementation hidden okay it's it's not there it's not given but only the operations are there only the operations are there with which using which we can use the stack okay so uh for example you can see the fan on top of you right so you you can you don't know how it's working internally all you care about it's operation as in you put on down the switch and it turns on and you put off the switch and it turns off that's what you care about so that's an abstract cool so we are given the let us understand the basic operations that are available with stack okay so there are four basic operations the first one i'm sure you guys if you know about stack you must know about all these operations so that is push function and then second is pop the third is top and the fourth is is empty okay so the push operation actually helps us to push an element on the top of stack so this pushes an element on top of stack then here we have pop so pop removes an element from top of stack then we have top so it returns the element present on top of stack so whatever element is present on top of stack it just simply returns it okay so don't worry we are going to see an example over here is empty is the function that tells us if the stack is empty so if the stack is empty it returns true else it returns false okay so these are the four operations that is push pop talk and is empty push pushes the element on top of stack pop removes an element from top of stack top tells what is on top of stack and is empty returns true if stack is empty as it returns false remember that pop simply removes an element and top does not remove an element it simply tells what is present on top of stack is it clear now okay so basically by performing a question you will have to use in c plus let's say uh you you can use stl right in stl you have stack so in c plus you declare a stack like this you can use a stack like this and on this object basically you can call all these functions so push x then s dot pop and so on likewise in java you have collections using which you can use stack so by attempting a question you don't have to implement a stack of your own until and unless told okay so but in a while we are also going to see how to implement a stack we are going to actually implement these operations okay cool okay so let's actually see a dry iron of these functions so here this is a stack and uh these are the operations that i would want to perform push to push one push minus one push five then pop pop is empty top so let's perform these functions okay so it's push two so what we'll do from where we'll put it we'll put it from here so basically 2 will come over here then it's push 1 so 1 will come over here then minus 1 minus 1 will come over here then there is 5 5 will come over here then we are popping so 5 will be gone right 5 will be gone so we have removed 5 now again pop is there so minus 1 1 will be gone so we have removed -1 okay then we are checking is the stack empty what will it return what will this return it will return false because the stack is not empty right the stack is not empty okay so now there is our top so what will be the uh top function return it will return whatever is present on top of stack so basically top is pointing over here so whatever is on top of stack it will return that so it will return one right it will return one so that was a simple dry run of the of how can we use these operations okay how these operations work now let us come to the applications of stack which are very important applications of stack so some of the applications are undo redo undo redo then we have arithmetic arithmetic expression evaluation right then we have a recursion so these are some of the then we have string reversal and so on so these are some of the applications of stack which are very important and you must know so try to uh figure out that how how a stack can be used in these operations you know that's an activity for you that do try to search that how we can perform an undo redo so this is actually present in your browser right so whenever you uh go to any page from any page and want to come back so basically you store for example let me give you an example so you you are at link let's say 1 then you go to link 2 then you go to link 3 and you want to come back to link two so what you can do you can actually maintain a stack of them so like first you are on link one you can put it on a stack link one then you are going to link two so put it on top of stack then you are going to link 3 then put it on top of stack now you want to come back to link 2 so what you can do you can simply remove this and now you are back to link to does that make sense so likewise you can also have a redo stack okay so that's that's an activity for you that how you can perform a redo operation okay so likewise try to figure out and uh we have arthritic expression evaluation so i think you all must be very much familiar with this that is you know converting to infix to prefix or post fix then evaluating the postfix notation so that's where you can use stats okay and then you have recursion stack is a core of recursion so you make function calls and when you come back so that basically those function calls get stored on top of stack okay likewise string reversal okay so there's another application that you may be using in your daily life you must have seen this in shorts app right so what happens in this you are on this screen okay and so here i am actually at my feed i am at my feed okay and i am uh watching this news so i can only uh see another news if i remove it if i remove this so can you see that how this is this is an implementation of stack right guys now let's talk about the implementation of stack so uh could you guys tell me how can we implement a stack so using arrays second is using linked list okay so how can we implement a stack using arrays so basically let's see so we can have an array so size of the array is so r is a in a and size of the array is 7 okay so what we can do so let's say i want to push 2 push 3 push minus 1 pop push 7 pop let's see how can we implement these operations using stack okay so what we can do basically we can actually uh you know enforce that one end of the stack will be there to perform all the operation so you can imagine it like we are pushing the elements from here and removing the elements from here so let's say i want to push 2 so 2 comes over here now you can also maintain our top variable which is right now pointing over here that means what is on top of stack 2 is on top of stack then we have push 3 so what we can do we can simply increment this top variable and push three in here then push minus one so we can simply increment this top variable and push minus one now how to pop it how can we pop it top minus minus so basically we are now at uh index one and we have uh so basically minus one is gone okay then uh vri so this was done then we are at seven so again we can increment the value of top and seven comes over here now again pops coming so we can come over here and this is gone so basically that's how we can operate a stack using arrays okay and now can someone tell me the problem of stacks so problems of stack are which are very important if let's say an interviewer asks you to implement a stack using arrays or link list so if i talk about arrays then we have problems overflow and underflow let's say i want to push 1 4 0 5 6 these are the items that i would want to push so one comes over here then 4 comes over here then 0 comes then 5 comes then 6 comes and now i would also want to insert let's say -1 so as you can see as i move my pointer forward there is no space because array has a fixed space right so i cannot insert any more element and that leads to the condition of overflow okay and that's it's very important so if interviewer has asked you if he's basically maybe judging you that will you cover these cases or not okay so this is the thing so how can you handle it so basically here you have mentioned a size right you can keep a check that if size so if top is equal to the size minus one so in that case that's an overflow you cannot insert any more elements so that's a drawback of arrays and to overcome that basically you can use something known as dynamic arrays okay you can use something known as dynamic arrays okay now let's say i want to pop i'm calling pop seven times okay so basically this is gone this is gone third time fourth time fifth time sixth time and seventh time and now i am again calling so now what will happen will i be able to pop any more element no i will not be able to pop any more element because the stack is empty so if i attempt to do so that will lead to under flow condition that will lead to underflow condition so how can you make it all right basically you can put a check that if a top so if top is equal to let's say minus 1 then print under flow and simply return so that's how you can manage underflow and overflow condition does that make sense guys underflow is when you are trying to pop an element when there doesn't exist when you are popping an element when there is no element so how will you be able to pop will you be able to pop no right so that's the case of underflow so you can manage the case of underflow by checking that if top is equal to minus 1 that means you have no element so you simply print underflow and return so let's talk about linked list so in linked list what you can do is so you have nodes in linked list where this is the data part and this is the address part so basically the nodes of the linked list can be present anywhere in the memory right on live carrying you don't have everything in a contiguous manner everything is scattered every node is scattered in linked list basically if you have this as a memory so if let's say one node is present over here another node can be present over here okay third node can be present over here so basically this address field actually links node so basically this will be linked to let's say this then this is getting linked to this and so on that's how we store data in linked list so basically uh let's say or you have two and one right now then you want to insert you want to push let's say 7 so how you can do right now top is here so at what position if you so you are actually remember you are actually implementing stack using linked list where would you want to insert this node this is your linked list this is what you are building this is the temp node current node that you new node that you are going to insert into your linked list so where will you insert it that we can actually put it it on top of head so now we can actually make this its next pointer point over here so this is how our stack would look like now top will be over here okay so you can in case of a linked list you can imagine a stack like this that like this it's growing right like this is it's throwing and when you want to pop an element so basically you can actually shift this top to the next position and this will be so basically you can free up this space okay so that's how you can implement a stack using linked list now with linked list the cons is of space a lot of space is used in linked list okay so basically uh you are storing pointers as well that will take a lot of space and pros of both stack and cons is that you will be able to perform push and pop operation in just order of one time complexity okay in just order of one time complexity okay cool let's get to the question okay so the first question that we have is very much famous question and very much asked question it's a valid parenthesis okay valid parenthesis so the question says that you are given brackets the round brackets okay and you have to tell whether the parent pieces are balanced or not let's say uh you are you know uh building this compiler in which you will be writing your code right so basically you will be uh you want your compiler to check verify our code so in that case you will definitely want how can we check if the bracket are valid or not so how can we do that let's see first of all let me give you some examples let me write down the examples okay so what do you say about the very first parenthesis what do you say about the very first parenthesis are these set balanced is it balanced yes it is balanced because a corresponding opening bracket has the corresponding closing bracket so yes it's balanced then if i talk about this is it balanced no it's not because this is complete they are balanced but here this opening parenthesis is lacking a closing parenthesis or you can also say that this parenthesis is lacking a closing parenthesis so this is not balanced this is not balanced likewise for this so this is lacking an opening bracket or you can also say that this is lacking an opening bracket so this is also not balanced okay so you have to basically tell are the parentheses balanced or not let's say we want to attempt this question without can anyone think of something okay so let me first actually put some observations let's do the question step by step okay let's do the question step by step so observations are the first observation is that can an opening bracket make a string invalid as in let's say i'm traversing the string and i find an opening bracket so can that opening bracket make the string invalid well it depends upon the future it depends upon the future that if i have this opening bracket maybe in future i'll i'll find a closing bracket and that will be valid or let's say i don't find the corresponding closing bracket in that case it will be invalid so it totally depends it totally depends if i get an opening bracket okay now if i talk about a closing bracket so what about what about a closing bracket can a closing bracket be a problem to us if we encounter it well so if till now for a closing bracket there was no opening bracket in that case yes it is a problem because even if we move any further the string that is given to us will not be valid in any case right in any case so so basically let's actually so okay let's let's take look at it uh look at it like this so i have something like this so what will happen let it be like this so i'm at here i will maintain what i can do i can maintain a left and right count which can be initialized to zero now i am at an opening bracket so that means left actually tells the opening bracket and right tells the count of a closing bracket so i found an opening bracket this becomes one and uh so let this be the thing let this be the bracket now i am here now i am here so what i can do i can simply decrement the value of this and that will tell us that we have we actually found a match for an opening bracket we actually found a match for an opening bracket so we can actually set this to zero right now let's say i have a string like this what will happen what will happen that i am here left and right so basically i have left one then i have a closing bracket so initially both are 0 so now this is a closing bracket so is left greater than 0 yes it is that means there is an opening bracket so we can simply decrement it telling that we have found a match now next we go to the next character this is a closing bracket okay so what's the value of left it's 0 that means there's no opening bracket in that case we will simply return that it's invalid because at this point there is no use to move any forward because this closing bracket does not have a matching opening bracket so we can simply return from here does that make sense to everyone okay so whosoever is saying that can we count the number of opening bracket and the closing bracket guys we cannot simply count the number of closing bracket or opening bracket okay let's take an example of that let's say i have this as a string so now left is equal to 2 right is equal to 2 but are they valid are they valid no they are not valid because they are not placed in the correct order therefore this is not a right approach is that cool the time complexity of the approach is what what's the time complexity of the approach so if we have this case here the number of opening blacks closing brackets are two number of opening brackets are two so are they valid no they are not valid so this is wrong this way is wrong so what's the time complexity guys time complexity is just order of length of the string because we are iterating the string just once and what's the space complexity just order of one we have not used any space okay we have not used any space now let me make a question little trickier now let's say i have brackets these these and these so this is an extension of the question extension a question come now i am saying that i have these three sets of parenthesis now i have to tell basically uh my string can contain d6 so i have to tell if those are valid or not let's take an example examples can be this this this then we have this so this will be uh given to you now you have to tell are they valid or not now can you how can you do it how can you do it so whenever in the interview you're you're telling the interviewer that uh okay we can use that for this but she or he already knows right you have to get to it like how what's the intuition so that's is uh very important okay uh some of you are saying that we can use three variables uh so that that will be wrong because then you won't be able to actually find the order you cannot judge the order by taking the that many variables so first of all i am sure that you guys understand that it cannot happen by taking just the left count and the right count because if okay so first of all let's take the example of this now here left is one left is one okay and now i find an uh closing bracket but here they are not same right so this will not work having left and right is a bad idea now taking three variables so here i have this string so if i take three variables uh let's say round or let me write first bracket second bracket third bracket now here the first type so this is type one type two type three first bracket left right is connect right then left right first left is one okay third the left is one okay first right so we have found a right bracket and this manages to be zero then we have third car right so this becomes zero but is this valid no it's not valid because the order is different order doesn't match so therefore that's a bad choice does that make sense you should have a clear idea that why your question is why your approach is wrong you should take as many as like if you are stuck you are not able to think take examples and try to generalize it so you guys are clear with it so let's move forward now let's actually build some intuition of this so one thing is that let's consider these bracket one thing is that if so since okay so this is invalid right this is invalid this is also invalid right this is also invalid this is valid this is valid they have right set of pairs now this is also this is what this is what this is also valid okay this is also as you can see that this is also valid so if i talk about this string then it's a property of the valid parenthesis that if the complete parenthesis are balanced then their their sub parenthesis will also be balanced as you can see that this is balanced this is also balanced this is also balanced so we are not considering all the substrings right we cannot consider anything like this or something we have to choose the right set but what it means is that whatever the parentheses are inside it they will be balanced anyhow so this is its corresponding pair then we have this it's correct then it's correct then this is there so does that make sense that inside of it parentheses are balanced now so an opening bracket does not bother us right an opening bracket does not bother us because in future we may find a closing bracket for it right but let's suppose i am at this closing bracket let's suppose i am done with everything and i am at this closing bracket now for this closing bracket this is an opening bracket this is an opening bracket does these brackets are of any use to me no they are not can i get rid of them then that would be great right so i if i can get rid of them because they are valid in itself right as i told you by this property so since they're valid if i can get rid of them then i can actually find out if this bracket has a matching opening bracket okay so let's actually see a dry run of this using stack because stack is the data structure that helps us find just look at just the past okay just the past so how and what we can do we are at this bracket this is our opening bracket we are seeing about it in future so push it on to the stack then this is an opening bracket you'll see about it in future put it on top of stack again an opening bracket put it on top of stack this is a closing bracket was there an opening bracket for this yes where can i see i can see it on top of stack if there is a corresponding match for this or closing bracket then i can simply pop it off next time here this is a closing bracket does this have a match and see how nicely we have removed between whatever was presented that is here we have removed it we have removed it and now we are actually comparing this where can we find it on top of stack so yes it has a match remove it so now we are here now we are here put it so this is our closing bracket yes match found so remove it remove it from top of stack then we have an opening bracket push it on top of stack okay then we have a closing bracket is the corresponding opening bracket present yes it is present remove it from top of stack now we are at the last bracket is the corresponding opening bracket present see here how we have gotten rid of all of this right so basically yes it's present from where we can find on top of stack just remove it what's the condition we have to check for validity but if the stack is empty then return true right if the stack is empty return true but if the stack is not empty so we have to return false that still even after iterating the string let's say we have completely iterated the string even if the stack is not empty so we will have to return false right because there are still left some unmatched opening brackets so at any time let's say uh you have something like this so at any time you don't find so okay let's let's do a dry run of this as well so this is an opening bracket move ahead opening bracket move ahead closing bracket but no corresponding match simply return from here simply return from here okay so now let's move on to the next question but before that let's talk about the time complexity the time complexity of this approach is just order of n because we are going to each and every bracket not more than twice how once while pushing it and another time while popping it so that's only 2 into n which makes it order of n right that makes it order of n and the space complexity is order of n because in the worst case we may end up pushing all the brackets in the stack when let's say the string was something like this in that case you will end up pushing all the brackets in the stack so the space complexity is order of n okay so i hope that's clear and we'll quickly move on to our next question so intuition is that how can we you know previously clear up something to get just the uh you know so here as i talked about that step by step he made the intuition like sorry i just removed it so as i was talking about that inside of it will also be uh you know balance so if we can remove it i will just be able to look at here that's what i want to do so we can simply remove it and that is possible using stack okay so let's move forward quickly cool so question two and this is very very famous question which is of next greater element okay so question is that let's suppose you are given an element you are given the elements in an array let's suppose 10 13 22 7 for each of these elements you have to tell that what is the next greater element to its right just the next greater element to its right so what's the next greater element to the right of 10 it's 13 okay it's 13 the next theater element for 13 it's 22 the next is there any next greater element for 22 no it's not so we can put minus 1 over here we can put -1 over here then we have 7 so next creator of 7 to right of it it's minus 1 nothing is there nothing is there okay so let me take this was example 1 let me take another example as well so we have 10 7 4 2 9 10 11 3 2 okay so what's the next right to the right of 10 it's it's uh 11 right just greater element on the right of 10 it's 11. just create an element on the right of 7 it's 9 it's 9 just later element to the right of four nine again to the right of two nine just to the right of nine it's ten just to the right of ten eleven just to the right of eleven nothing to the right of three nothing to the right of two nothing chicken okay cool see if you are implementing any question you can use stl in c plus plus or collections in java you don't have to implement push pop functions on your own that's just for the sake of lift if let's say your interviewer asks you that's it okay that's it cool so if the question is clear please tell me that how can we attempt it at least give me the brute force approach at least give me the brute force approach so you will agree with me that brute force is nothing so brute force is using two loops so you can basically you know let me actually write the code for it as well so the brute force look like that you can have an answer variable answer array then you can iterate through all the elements from 0 to n minus 1 then for those elements you can again iterate from so okay first you can initialize your result to minus 1 if let's say you don't find any element so you can do for j that goes from i plus 1 to n minus 1 you can check if a of a of i is so a of i is less than a of j then simply put answer i is equal to a j tk and break from here take a break from here because you just have to find just the larger element you don't have to iterate any further okay now what do you have to do actually this should be resolved and out of this for loop you can set answer i is equal to result does that make sense this is just the brute force approach okay cool let's go ahead so the time complexity of this approach is order of n square since there are two nested for loops and the space complexity would be order of n which we can ignore because that will be just to store the so basically this is just so we can actually you know make it order of one only because we anyway have to take an answer alright answer array we anyway have to take because that's how we are going to return the answer so the space complexity for this we can assume to be order of 1 right cool now let's talk about the optimized approach and let's build some intuition for that let's see some observation the first observation is that let's suppose the array elements are 12 10 9 8 7 okay 0 1 2 3 4 if let's suppose these were the elements what is going to be the answer for them what's going to be the answer for 12 minus 1 nothing is on right for this minus 1 for this minus 1 minus 1 minus 1 does that make sense the answer for all of them will be -1 now let's talk about another example let's say we have 5 4 3 2 and 10. now can someone tell me what is going to be the answer for 5 now for 5 it's going to be 10 for 4 it's going to be 10 3 10 2 10 10 minus 1 does that make sense guys cool so the thing is that as you can see when the sequence was in decreasing order we got -1 for them and here we also had a sequence in decreasing order but once we got an element which was greater than them so this element was greater than these elements so the answer for them became 10 the answer for then became 10. look at it like this so let's suppose i have 5 4 3 2 10 so i start from here this is 5 then this is 4 this is 3 this is 2 now 10 came so once the number came which was out of order and greater than them so answer for them became 10. the answer for them became 10 let's look at one more example we have 9 6 5 4 8 so this is 9 this is 6 this is 5 4 then 8 came so eight is eight to whichever element it is greater it will become the answer to them that is here so this is nine this is six this is five this is four this is eight so it will become the answer for six five and four okay so can so basically now once we have got the answer for them can i just ignore this and start by finding the answer for these now does that make sense does that make sense okay giving you some intuition that here we are also ignoring whatever was redundant from the past the idea here is that we have a monotonic sequence we have a monotonic sequence over here monotonic sequences when we have a decreasing or increasing sequence so my point is that i had a decreasing sequence once i find an element out of order so all the elements which are smaller to this this will be the answer for them this will be the answer for them again now so basically uh let's have elements 11 4 3 2 10 12 so i have 11 then i have 4 then i have 3 2 11 4 3 2 now 10 comes now 10 comes so 10 is greater than these numbers so answer for these will be 10 answer for these will be 10. now since we have got the answer for them we can actually remove this we can actually remove this and now it will be it will become such a sequence it will become such a sequence now 12 comes so this will come over here now whatever is smaller than answer to them 12 will become the answer so 12 will come over here and 12 will come over here now only so we have got the answer for them so we will remove it and now we are just left with the 12 we have completely iterated the array and minus 1 minus 1 okay so since we are ignoring whatever is redundant to us previously and since this is a monotonic sequence therefore stack will help us over here so let's see how let's see the dry run using stack so intuition was that we had to look at the just passed just passed removing this just so whatever whatever answer we had got we will just ignore them and now we'll start again from some monotonic sequence like we did over here over above right okay so now let us go through the dry run using stack then again if you guys will have some doubt we will come to those okay so i have 11 put it onto the stack so 11 has been put onto the stack then we have four put it on to the stack then we have three put it on top of stack then we have two put it on top of stack then we have 10 now this you can see that this is a decreasing order this is a decreasing order now we found an element out of order so to whatever elements 10 is greater the answer for them will become the answer for them will become 10 so is 2 so is 10 greater than 2 yes so we found the answer for 2 answer for 2 is 10 remove it is 10 greater than 3 yes we found the answer for 3 the answer for 3 becomes 10 remove it now is 10 greater than 4 yes so we found the answer for 4 the answer for 4 becomes 10 and simply remove it now is 10 greater than 11 no so simply push 10 in onto the top of stack and move ahead and move ahead now we are at 12 so on top of stack there is 10 10 is lesser than 20 so answer for 10 will become 12 right answer for 10 will become 10 now uh so we are at 2 is 12 greater than 11 yes so answer for 11 becomes 12 okay so now nothing is there simply insert 12 on top of stack now move ahead so we are done we are left with no more elements so whatever is present on top of stack the answer for them will become minus 1. so in this case answer for 12 is minus 1 guys does that make sense so i'm sure saying that then in this solution we need to also store index and stack and so that's what we are going to do we actually need to store indexes on top of star because we actually are trying to find the answer for the previous elements that we are done with so let me quickly show you a dry run of how we can do this using indexes okay so we are having the stack we will place zero over here then we will place one right then we will place two then we will place three so basically still the array is in decreasing order now we found 10 so uh this 10 is greater than what is present on top of stack so basically answer for uh this so we will write it like this we will write it like this s dot dot okay because this is the index so a of 3 is nothing but 2 so 10 is greater than 2 answer for this has become 10 then likewise answer for this will become 10 element at index 1 is 4 which is lesser than 10 answer for this becomes 10 now 11 is not smaller than 10 so we will simply push the index of 10 which is 4 then we are here now this is 12 12 is greater than a of s dot top so we will simply put mark the answer of a of 4 as 1 so this is 5 again so as we remove it then uh a of 0 is lesser than 12 answer for a of 0 that is 11 will be 12 and now whatever is on a stack whatever is present in staff you will simply mark their answer as negative 1 so you will put minus 1 here and the time complexity of this approach is order of n since we are putting an element and removing an element just twice so again order of 2 into n which is nothing but n and space complexity in the worst case can be when let's say the complete array is in decreasing order it it will be order of n so does that make sense to everyone okay guys so we have actually placed uh the link to the questions for the next questions okay so hope you guys try it and uh guys this was it i hope you enjoyed it and if you enjoyed it please like and subscribe and share this with your friends as well okay cool please try them see ya bye bye hello everyone welcome to scala recommends youtube channel my cell phone see in this tutorial we will be talking about dbms dbms is very important concept in perspective of interviews whether you are obtaining for any product based company or service based company having a knowledge of a dbms on the concepts of bbms is very important okay it will definitely add an a big advantage to you in an interview so in this tutorial i will be starting right from the basic so you can watch this without any fear if you are an unknown cs student you can watch this okay so like at the end of the video i'm pretty much sure that you will have a good understanding on how databases works how or what is that database and what will you offer databases and some important concepts as well before starting we have a few formalities to complete first one so if you are using channel for the first time please don't forget to subscribe if you like the content please hit that like button up and if you have any questions or if you have any video request that you would like to hear from scalar academy please let us know in the comment section now let's start with our introduction of and database management system so before starting that before discussing what is dbms let's try to uh divide this our world and target database management system and we'll see what it uh one each module let's say okay so let's take this data so what is that what is the data what is the data so i can say that i can say that any fact that you would like to store or preserve for future references is called a data right now what is a a database how can we say that so a database is a collection of collection of a related data related a data so let's say you are storing the uh details of college students okay in that particular let's say i'm storing my details let's say omc my role number my uh address okay let's say bangalore so this particular thing would be my data okay so if i store if i store all my college student details in one particular place that will be called as a database okay make sense now let's go to our next one so management system a database management a system so now let's see let's understand so i haven't five five thousand data residing in my uh database okay now i had a few things like so uh one student left my college he joined another college so i need to delete that particular student data in my college database right so i delete now now so uh i have to update one student mobile number or email id whatever it has okay so it have already that student data has been in my database now i wanted to update that data okay so i simply i need to modify my existing our data now uh one student joined in my college okay join in my college so i need to insert his data his or her data into my database so insult so all this can all these things kind of things i can say that i'm managing my data managing my databases so how how can we manage there are some database management systems that helps us to manage your a databases okay so such kind of things will be called as an database management system so how can you say that so nowadays like all the databases has been computerized so to perform the operations like a modified delayed insert kind of things we need some uh systems of office which helps us to perform that such kind of operations so those uh that kind of softwares will be called as a database management systems okay make sense so we are done with the data we are done with that db you are done with a dbms as well now on top of all these things there is one thing okay what is that so the combination of database plus a database management systems is called database per systems okay so the combination of a database and a database management system is called database systems now you might have in doubt how we are storing our data in the databases how many types like okay so yeah there were different data type databases or exist but uh nowadays a people are using are two things are mostly so one is a dbr types okay so a relational database relational a database okay so what is a relational databases so a relational database uh like um if i want to say it in simpler manner the data has been stored in the form of tables okay so when i say tables we are having a columns and rows okay we are storing our data in the form of columns and rules okay let's see let's see so suppose i am storing the student database like student details in an our database now tell me what are all i can a store so let's say uh attributes of a student so what i can have but for a particular student i can have an name then a role number and then uh address of a student then a mobile number email id parent names go on so i will have this kind of things for a particular student so this comma for every student so these things will be called as an attributes or properties of a a student okay so i'm going to i'm considering these are tributes as my column names as my column and names now uh so let's let's run one table okay we'll then we'll see how we are storing that thing so let's say now i have my attribute names as our name our role number or let's say mobile number now i'm storing the student data okay so let's say first one roll number 500 so mobile number something one two three four five six seven eight okay now again so this thing this particular will be called as an one record okay then i have another student thing so let's say ready okay his role number is 501 and let's say mobile number is uh all zeros okay so this is data so again i can call this as a record okay one record so these can be called as a records or i can call them as a tuples as well and these are all the attributes so the data if we store our data in in the form of this table then we are calling it as a relational databases okay relational database now uh there is an another famous database uh exist so what does it now no sequel a database so what is this no sequel database okay so we'll come to that what is a sequel in later part okay now as of now let's discuss what is unknown sequel so uh here let's say so i have uh there will be something like schema so what does it a schema means so it represents how you are storing your data and like let's say in simpler matter you can say that it's a format okay so you you will be defining okay so when i say a student table okay so this is a student table then i am stating that you need to have a name you need to have a role number you need to have a mobile mobile number so if you if any of the student won't have any of this column or attribute just don't uh don't store this uh data in a table so in that cases what happens we are losing one particular record right we are losing our one particular record then is there any point of storing uh all the student names uh uh like eliminating few student names no right no there is no point so to overcome that bigger problem we have a nosql database so uh what is a bigger difference between this relational database and no sql database means now you don't have any particular schema or format how to store a data okay so whatever the data comes from when um user or database admin it will store that it won't ask any question like so you are not giving mobile number of a particular student but you have given email of a student as well it it won't uh raise any kind of questions it will just store whatever you give okay here in these cases we are not eliminating any data so but we does it in relational databases so that's the main major difference between the nosql and and coming to application of for these are databases so it's quite obvious so everyone knows about it so nowadays are everywhere everywhere databases are being used so hospitals let's take hospitals so in hospitals we are storing our all the patient records and we are keep tracking of uh monitoring the particular student with his uh medical reports right so in colleges or uh like educational sector in educational sector we are storing the student details right in every college that happens there is no separate uh introduction or how we are storing that data so in every college they call college management used to store our details like uh amount of people have paid amount of cgpa you have what are all the companies you have secured kind of stuff right and coming to another let's say online shopping so we are storing the vendor details like whoever all the products are so products are selling and who are all the buying like let's say i have ordered one a particular laptop today okay i have ordered one particular laptop so the data uh the details associated with this my order are seller details buyer details like amount i have paid transaction id so amount delivery date who delivered my particular order my address my mobile number all this data has been stored in the database okay so yeah like this you can consider any application so nowadays our databases are became very vast so without without using our databases uh like all industries or any sector is not running okay beat industries or like manufacturing units in manufacturing units as well they are keeping track of what are all the like products they have built or manufactured in this particular date who are uh who are all in uh involved in that particular manufacturing right so an increase and exist to keep track of for employee uh working this kind of stuff right so these are all a few database applications but i request you to think of in your own manner try to write your own applications okay so what is before dbs like now i am teaching like now we are learning about dbs now before dbs what they exist there exists like simpler file systems so they are storing our data in our laptops only like file systems so uh if i say what are all the difference between a file systems and a database that's a file system versus a databases right so if there is some problem that's why we have moved on to the new thing yes so that's our responsibility to know why we have moved why we are moving towards a new thing why we are adapting new culture it's a very similar for anything if there is a something and we are learning something new we have to know the problem that were occurred with the existing system okay now i can say that first thing would be data redundancy so what is a data redundancy so redundancy means uh a storing or keeping an a multiple records okay let's say duplicates okay are duplicates so in file system we used to store our duplicate values as well but when coming to dbs there isn't some concept like normalization so with that of principle we are uh we are eliminating the redundancy means we are eliminating the no duplicates okay we are eliminating the duplicates so obviously let's say there are 100 records in a particular college okay college now uh suppose i am storing it duplicates values as well it became it became 200. now obviously my says my space has been uh became a project right so instead of consuming 100 uh let's say each record is consuming 1 mb okay now instead of consuming 100 mb it has now consuming 200 ml there is a lot of a space wastage so again apart from space wastage as well there is something like confusion we are often uh get confused so what to consider right so in that cases our dbs are very good at it managing that kind of stuff so in dbs no redundancy okay and next thing security so obvious that in file systems we don't provide any security so anyone can access if they are login to login into my system right so in that cases we are not providing there is no security for our data but when coming to a databases we do have in concept like a constraints we provide a constraints for our dbs okay so without uh like with that content allows okay it won't allow people who don't have that particular kind of permissions or we are not able to send or receive data as well okay now data consistency so let's suppose i will take an example so there is a one particular student a student is enrolled in a six courses right for every semester student should enroll in six courses now now so obvious that obviously so uh student record will contain uh like that particular student record will contain in every course okay let's say suppose i wanted to a modified or update is one of its attribute let's say email id okay i wanted to update his email id so i went and updated his email id in one particular course now tell me what about all uh reminding courses like about five courses what happens it won't get updated we need to go manual and we need to update that so that i can say that data is in inconsistence right so the data so once i updated it is not updating all the things right so in that cases of file systems get failed but in dbs in dbs it is a really successful thing that's up that is a one thing that really fascinated people towards a databases okay now yeah so we discussed it so far we discussed a few advantages of dbs but now let's see disadvantages of the this advantages of a deep now first thing obvious i think that maintaining and uh the cost like maintenance cost off and db is a little higher than maintaining cost of file systems okay that is a one thing okay and second thing uh one thing that i so those whoever have any knowledge on how to interact with the computer like databases using programming can only use databases right so those whoever have a knowledge on dbms or any language which users are like which comes under dbms like sql or anything can interact with the dbs otherwise they can't so that is that which is the one of the biggest but in file systems anyone can those who ever have knowledge on computers as they can interact with the file systems on the data so uh like can i can say that uh a knowledge of computer or a dbms must and there is also like car it's a little uh complex to understand the those core like uh schemas and how we are getting the data how we are how to write it queries and all so obviously these are this all stuff makes and person to get confused a little better okay now let's talk about architecture of dbms so basically the architecture of dbms uh will depends upon the system which you are running your uh database which terms of queries okay so let's say we'll talk about first we'll talk about a standalone missions okay standalone systems so what is it a standalone system so basically so uh you have in uh let's say you are using your file system as your database okay so you are writing a user okay you are a user and uh you have a file system like say you can that file system you are using as a db now where is this a query is being processed that is been processed within your system right within your system so you are not using any connections so you are just going so like networked connections okay so you are not using any of those kind of things so because just because you are using the database which is inside your system now there are another kind of a system let's say client server architectures where like you are in a distributed environment or you are using some servers right from like where uh let's say your office is in hyderabad okay so but you are trying to access that dbs or which are residing in like some places like u.s europe australia kind of stuff right so it might happens so this this is another structure so here you will have some client server let's say client here and your server resides at another place so you are making an request to server okay so there are the two kind of systems you might have and now are other like there are three types of octages are there in dbms okay what are they first one is a single tie architecture so a single tier architecture means ah so this is the example of so yeah single systems standalone system is the best example for single data architecture so where are your both like a client and uh server residing in same system and which you are you are not using or you are not connected to any kind of networked connections okay or not using any server so you are just using a server which is residing in your own local system now second one is a two-tier architecture what is this two-tier architecture means let's say we have a client okay let's say client or user and you will uh you will have one let's say we will have some a dbms application or calling this as an our client and your database has been residing in server but you are calling as a dbs so database system so how this process happens so basically as a user you will make an one very simple query by using a database application of software whatever it might be and that uh like dbms application software it will try to get connected to the server so through the some uh network uh networks like uh so it might be the network interface might be uh any uh let's assume jdbc or odbc interfaces okay so by using that you are trying to access the data from db systems okay so this is the two-tier architecture now we'll talk about that three-tier architecture so what is this data architecture so it's the same as a two direct architecture only but the only difference is let's say this is your client user is i'm having a db mesh application so let's say a client a dbms application okay now this client user client application will get connected to server dbms application okay so by using this server uh dbms application you can access the data from database systems make sense so again you are using any connect inter network interfaces here as we discussed earlier in two directions same as that okay so here your client database application don't have a direct connection to your database systems so you will send and process a request to the server database application then your service database application will process that thing from the database systems then that will get uh then again so service database application will give you that results to your client architecture okay so this is about the architecture of dbms and again there is an another architecture called a three level database architecture let's see dbms a three level architecture it's very very important question okay you might get a lot of questions based on this question topic okay so again this topic is being called as an use reviews of databases as well okay so basically then we uh the database uh architecture has been divided into three parts okay three parts so first part is being called as an external level again this can be called as a view level as well okay here you will have uh different users so let's say user one user two user three and everyone has their own view right like you can be like your gui a graphical user interface now this is the first level now we will have an another level so which is called as a conceptual level or logical level so uh where where you were uh so it won't tell anything apart from uh like the data you have to store the data in database something like this like there will be something like schema and okay so it it helps to design like it stores that schema and it decides how to store that particular data okay and also it will say some it will hold some constraints to how to access that data who can access that data kind of stuff okay so this conceptual level holds then like connects with another level called internal level or a physical level so in this particular level the original data has been stored in and memory okay so till now till this level you are not are giving any memory or space to store your data okay so but in this physical level you are storing your data okay by using some let's say you are storing allocating some kbs or mps or gbs or tvs of data here okay so this is where your actual db stores data stores and this uh this is where you are telling how to store a data like okay in which format of which uh type or data types you are telling like what data let's say so i am storing the name of the students so then you have to store it in a form of a backer like string when you are like when i say it's an age you have to store in a data sorry interior okay now also you guys are so let's say i'm storing a student table now what it contains name a role number an address and mobile number kind of things right so it will this particular level will tell you so these are all the things that you need to store okay but when coming to this particular level offer this okay so here or let's assume here all the table has been created with the columns here all your rows will be appended to that thing okay here what what in this particular external level people can do now here a user can a user can access the tries to get the data from the internal level okay so in this particular thing data can be used in the form of either gui okay or any like a query languages like if someone is uh really uh if someone is a good programmer he might write and queries and he can visualize the things over there as well and even if it is not encoder there will be some guys he can interact with that juvia is using um sorry he can interact with db with by using that gus as well so this is the overview of and how the database um three level architecture works and now if you could observe here you can relate it to a few things like so please pause the video not think okay so basically uh this and that dbs the uh to store this much of huge data our uh databases uses uh data structures like complex data structures okay complex data structures so but to make it is this like to make is easy to use okay so all these complex things has been hidden okay hidden okay so this particular concept is called as a data abstraction so what does this data abstraction means hiding the unwanted or unnecessary or complex things behind the screens and showing whatever required to the particular user is called as a data abstraction the best example would be atm so we will go to atm okay so we just insert our car we'll enter our pin and we'll uh so we'll enter whatever amount we want and we'll take that amount we'll come back that's it right so we never thought or we never want to know how that system is being processed after entering my pin right what is the processing it is going to somewhere okay so i don't really don't care about all such kind of things and what i what i know is that so that's what i want so here the things that are hidden from us is making that a call to the server and calculating the amount that you wanted to and the mission that is running so all these were really unwanted unnecessary for me i just want only money that's what i'm getting so this is called data abstraction okay the next concept is a data schema database schema so we really talked about this terminology earlier as well but let me define how these things works okay in a clear picture so let's say we have a student table so we will have attributes like a name a role number address mobile num email and all so what this schema tells now we have to store this kind of data i have to store the data you have to store the data in this particular format in a table okay so that is called a schema okay now there is another thing called instance what is this instance so instance in the sense let's say so uh by the end of the today or let's say there were 100 records in my table okay now i can say that what is the instance in that if i ask you what is the intense i will say 100 so because there are 100 records exist in my database so i can say that instance of a particular db is 100 so what is that instance means now so a particularly a particular time whatever the time you want so how many data has data records or been exist in our database but it's called insta so a tomorrow a day two so there were a hundred more uses has been added but hundred more uh records has been added to your database then your instance will become 200 right so this is how database schema and database data instance has been defined so now let's talk about dbms languages so basically dms languages are used to perform a read update a store kind of operations in a database so there were a lot of uh languages exist to perform such kind of operation so one such language is s sequence so formally known as sql so uh it might be called as a structured query language okay structured query language and if you are really interested to learn this sequel so which is used by most of the companies please do check out the um playlist which was about by other faculties or instructors in this particular youtube channel now now let's talk about the types of dbms languages okay so types of a dbms language so again this these are all the very very important concepts in terms of players interviews okay now first thing is ddn okay data definition language so our ddl is used to specify the database schema okay so it is used for creating the tables schemas uh indexes constraints etc okay so let us see what kind of operations that we can perform using ddl okay first one create so create can be uh might be used for either creating the databases or tables okay next one is alter so alter means altering the existing tables okay or altering the structure of a databases as well and another one a drop so a drop means uh deleting or dropping the existing uh instances of a database so when i say instances might be tables as well and uh next one is uh truncate and a truncate again it uh it's it is called um to delay like target is used to delete that tables in and database okay and next one is a rename um so again so rename is i used to do either rename the tables okay or database instances we can call it as a database instances and our last one comment so comment is used to comment the databases okay that's it and now rbcl okay dcl so data control language so uh which is used to control the access of a particular data which were there in controlling the access often databases as well okay so in this we do have a two commands one is grant another one is a revoked so grant is used to grant the permissions revoke is used to revoke the permission which you have given already and next one is a dml data manipulation language so this database my sorry data manipulation language is used for accessing as well as manipulating the data but already present in that database okay now what are all the options is a read so a read is uh you can read that data from a database using the select command and next one is insert so insert the insert command is used to insert the data into an a database next one update so update so updating correct it is used to update the data which is already existing in a database or table okay now a delete a delete is used to delete the data which is a present in an table okay now all these like these are all not the separate uh languages all this work comes under sql only now another last one is uh pcl so transaction control language so in this we do have a two commands one is commit next one is a rollback so basically we perform lot of transactions like the transaction might be let's say uh their existing table you are manipulating that a table okay or manipulating the data which is residing in that particular table using the dml commands okay so since you are changing the database which is already stored in data base so we have to commit the changes so commit means it will it will commit will help us to preserve the changes for a longer time okay now what does that roll back to so let's say yeah we have changed something and uh we have committed that okay uh sorry we have changed something okay we haven't committed that and um those are so after changing your your app or whatever your application is not performing well so now at that time you can do simply roll back so it will take you to previous changes okay so in that way these dcf commands will help us to do it in a better way data model is a logical structure of db it describes the design of db to reflect the entities attributes a relationship among the data and constraints when i say entities so entities might be in our tables right so i can clearly say that entities and real world existing thing it's a similar to the object in an object-oriented programming language that everyone is often familiar with and in this particular data models there are different types now we'll talk about them so there was first model is object based logical model again in this logical model we do have two types first one is er model which is a very very very very important in terms of for both placements and the next one the next one will be object oriented a data model okay now the second thing will be record based logical model so again this has been divided into three things first one is a relationship relational model next one is hierarchical model and third one is a network model and there is an another type which is an physical data model so basically here this particular model uh describes the database of a levels like uh conceptual level and a view level okay so uh even the code based thing does the same both conceptual and uh view level but uh here the difference is this a particular record based logical model describes the data uh with the records of fields and the attributes okay so unlike object based logical model and when coming to physical data model it is um it describes about the data which has been stored at the lower level of the data abstraction okay let's say it's a physical level okay so among all these data models the one which is very famous and uh very widely uh very used okay so this one er model okay so apart from the uh this particular er model most of the things were not being used nowadays so now let's talk about that er model only so er model a stands for entity relationship model so earlier i said that when i say entity it might be a table and in oops terminology it is been called as an object how can we define and real world existing object or thing okay so the examples would be like a person employee a car book a pen etc okay now this er model is used to represent the uh like design the database architecture using the um diagrammatic picture okay let's say when i say tag grammatic picture it contains everything like our tables and attributes are links to the data tables and the constraints okay so like whenever we see that particular er model of a database we will get an overview okay what's going to be in particular database and how these particular queries have been running okay everything everything okay now we'll talk about those er diagram yeah diagram and what does it contains okay so basically let's say so components of for er diagram components of er diagram so our components has been divided into three things first one is dd so we all know that what is an entity uh in this particular entity would you have a weak entity so what does this a weekend it means let's say you have an a bank account okay let's say bank table so the attributes for this particular table will be bank name and a bank a branch branch ifsc code so here this this is bank is a table name we often call as an entity and these were these things were attributes okay now there is an another entity called bank account right bank account so it also has a few attributes like account holder name account number and uh amount that is residing in that particular account and mobile number email id right so there's all the attributes of this particular bank account now can you tell me is there uh is that particular bank account exists without a bank so it is not possible right how can a bank account exist without a bank so can i can i say that bank account is a purely depended on bank this is a dependent so without the uh bank entity we can't have and like we don't have that particular bank account entity look i in that situation i can say that this is an a weak entity now we'll talk about another component called attributes attributes so the first attribute is a key so a key is an unique attribute which is used to identify the record uniquely let's say what is an uniquely means so um in india there are a lot of people okay so let's approximately there will be 120 crore okay let's assume so if i consider okay let's um so let's assume everyone has their own other card okay so the other card number is very unique right so if i say uh this particular other card number if i give that particular other card number i am pretty much sure that there is no duplicate exist means uh one particular for for one particular other number there will be no two persons were linked so in that case i can say that a person let's say person entity which has an attributes like name other number address a mobile number and email okay now by giving this particular other id okay other id i can i can get this particular uniquely that person uniquely right so even this email as well so i can say that email is also very unique so by giving this email id by searching by searching with this email id i will also get an person uniquely so this is about a key now let's see next key composite attribute so what is a composite attribute let's say um there isn't record calls to entity call student for this particular student there are some attributes like name id id industrial number and address so can i can i say that this particular also address this particular address might have under a few other attributes like pin code state a city street name in that cases we will be calling this as an composite attribute this particular address is being called as a composite attribute okay the third one is a multivalued attribute what does this multivalued attribute means let's say uh there is a student again okay not a student let's take employee this time to employ so am i guaranteed that like empty entity okay this is entity so uh employee has that um mobile number attribute is there any guarantee that every employee has their only one particular uh mobile number no right nowadays zero it tell ideas everyone is holding two or more mobile numbers right so i in that particular situation i can say that this particular mobile number is a multivalued attribute okay multivalued attribute now the last but not least the first fourth one is a derived attribute a derived attribute so what is this a derived attribute means let's say um a student entity has an attributes like name dvob means a data one again it's an ear okay and each address so i can i say that okay without uh can i say that ages purely depend upon baby how they will be how so without knowing the year of um like when he like when when he came on to the earth like here can we say can we find out the age of that particular person unknown big no right so if i say he he born on 1999 so in that case i can say that it said 22 now currently so when i say if he born on uh 1995 then he his age might be and something similar to 27 or 26 right so in that cases i can say that this particular age is purely dependent upon dob so i can again say that it's a derived attribute so since it is deriving from the dob like date of birth okay so this is about attributes commotive and now we'll talk about our component uh called relationships so in these relationships again we do have four types first one is a one to one relationship so what does this one to one relationship means okay so let's say uh every person can i say that every person uh will have only only one passport or one other card or one pawn card yes right there the possibility is only one so every person has only one passport one password has been uh can be assigned to only one person okay so in that case i can say that it's a one-to-one relationship now the second one is one to many one to a many uh relationship so what can be the things let's let's say taken customer entity customer entity so customer has placed an order based on order now tell me if customer can place many orders yes there might be possibility now is there any possibility of a many uh orders can be placed by many uh one single particular customer no so i can say that it's an one to one customer so one too many relationship now third one uh many to one so how let's say i have an entity called student so can i say that many students many students can study in one college one particular college and also one college can one college can accommodate many students right that is also a possible keys now the last one is many too many relationship what is this a many-to-many relationship so can i say that can i say that many students many students can be assigned to can be assigned to a many projects yes right and also i can say that vice versa so many students can be assigned to many projects many projects can be assigned to many students okay so this is about the components of an er diagram this is what most of the times it includes okay so now let's discuss another topic in a dbms so the topic whose name is uh dbms generalization what does this mean so it means that uh let's say we can define a generalization something like this generalization is a process of generalization easy process of in which common attributes in an two hour mode like more than one okay now more than one entity can lead to a creating an a new entity okay let's see one example okay so suppose we have and our two entities okay one as a teacher okay so the uh attributes of this teacher particular teacher will be in name and address and salary let's take another entity called a student college student so the uh attributes for this particular student will be name address um it's a marks here what are the common attributes in both of these entities so this this is and this so this one this one this one this so can this be lead to a new entity to think think okay so uh i can say that uh all teachers are people and all students are also people right so can i can i say that so will this our teacher and a student entities will lead to having and a people entity okay people easy okay so the relationship is easy and yeah we will be having this and we will be having this so i can say that every people have the name attribute and address attribute but on top of that a teacher might have a salary a student might have a marks so when you are talking about generalization you need to consider these things from the bottom to the top okay so teacher is a people the student is a people so people have the attributes like a name and address a student have ah they are table set marks and teacher might have attributes like a salary right so what we have done here we have created a new relation and reduced the repetition redundancy of and now table attributes right so and uh one thing here is we are considering it top bottom to top and uh from the bottom entities we are creating the new top level entity and uh there is something like um that whatever the new entity that has been created as of now from the by using the bottom two entities if required okay if required while creating another top level entity that new level entity has to be mingled up with these two entities as well okay so on that note let's see another attack so dbm is a specialization in simpler words i can say that in simpler words i can say that opposite to a generalization yes so what we have done in generalization by considering the top uh bottom level entities two entities we have created the top level entity right but in specialization by considering the top level entities we will be we will be creating or deriving new bottom or low level entities let's see how okay so basically every employee will have a name a salary employee id now can i can i say that so uh can we how can we divide this into a different particular in entities okay so can i say that so employees might be let's say consider and software company okay so employee might be an um software developer employer might be in software uh software engineer in test so employer might be an hr right so let's uh let's try to divide this particular employee top level employee entity into an um few uh low level entities okay let's see how we are doing this so we'll have a employee entity here and what are the common things for all the employees a name a salary and an employee id okay every employee will have that but on top of that we will be having some use a relationship okay so from here we will be having a developer so uh like welcome into let's make it very simple okay so the attributes for will be a boolean type let's consider boolean type we will give you some programming language we will be taking just whether he knows that particular language or not that's it okay c plus place uh java okay so python she shop okay kind of now let's consider another case so a tester okay so what will be the qualities of a digital so you might be able to uh pretend test cases like manual testing manual testing and automated testing which were like a script based interesting okay and integration testings as well okay now when i say a cloud engineer sre or something so cloud engineer now he must be able to know all the terminals of oops like the oops and he might be good at cloud like either aws and a cicad pipelines and all right so this is how we have uh divided our particular employee entity into a multiple sub uh sub entities right so again so this has to be uh started from top to bottom okay top to bottom in case of generalization it's a bottom two top now we'll see another thing called our dbms aggregation what does this mean so aggregation is a process of uh in which a single okay uh like process of uh in which a single entity is not able to make sense in an relationship okay so the relationship of a two entities is being uh combined to an another new entity okay let's see let's see okay let's take an example so basically uh let's take an again id company so every employee works on one project so again project is and one entity employees and one date because they are independent voters okay so project might have a project id a project name and a product owner okay so employees will have again employee name employee id address kind of stuff okay now this is an one entity like one particular block let's consider block okay now can i say that uh for every employee there will be one manager for every product project as well there will be manager right so in that case can i say that so if i directly write an relationship between employee and manager we might miss an relationship between a project and employee so can i say that now if i draw this here manager manages right so if i write something like this then it works right so manager works on this entire block okay he sometimes works with uh he is responsible for employees and he is responsible for one project as well so this is called aggregation okay earlier we have i have discussed what is a key so key is an um unique attribute okay so which uniquely identifies an entire tuple or recording and database okay we do have a different types of keys existing and a dbms okay now we'll talk about them within one example lucky so let's say you have an um like two tables with the attributes of like this okay so student table so you have a student name and role number uh other id other number a mail id address and you do have another table called a course okay so if this has a course name so usually students enroll in that particular course right like dbms who is mathematics operating system something like that so then a course id uh then a faculty name who is teaching that particular course currently okay now done now tell me now tell me so in this particular student table what are all the unique things let's say so can i say roll number is my uni why so so let's say so there were 5 000 students enrolled in one particular college so if i say roll number if i pick up any roll number is there any chance of getting that same roll number for and now another student and no there is no chance right so if i if i give any particular role number that must be unique so if i give particular role number he might he can tell me the student details so reason unique and what about this other this is an international unique thing right so that's uh there will be no two persons with the same other number so it is also in unique so what about email it's an universal um unique right so now what about name there might be possible right there exist and uh two name okay there are their existence to two students with the same name right and address as well okay so let's say uh there were a brothers and sisters okay so they are from same family okay they are studying in same college so they then their parent address and mother names would be same right so in that case i am not saying that address and student names are not going to be unique so all these attributes okay what are all i can i have seen i said like top all these were uniquely identified all these were candidate keys candidate keys okay now upon so we don't need a three three things right three keys to identify and i am pretty much sure that any of these three things will work for me okay so in that case uh so uh since that table is an old student related so i can pick up an roll number which uh which does my task very simple manner so i'll pick up a roll number as my unique column then i will call this as a primary key okay so among all the candidate keys available right there okay i will pick up one key okay so uh to add a to identify an um entire recorder row uniquely so that particular key has been called as a primary key now what about other two keys that exist in and candidate keys like other and the email will be called as an alternate keys okay alternate keys make sense now we'll talk about a super key okay so now tell me now tell me so i'm pretty much sure that all only with a roll number i can get and now i can add an entire record but now tell me so can i get an um student name so can i get in now one particular student by giving in a student name as my search key no right so there might be a multiple students with the same name so if i add if i add a role number to that particular name that will make my job a little bit easier can i say that yes so in that case i can say that by combining the student name plus a student a role number it will be more powerful okay so this combination is being called as a super key even a long only student a role number will also get my job done it is awesome it might be also in super key but no i can't say it's in super game but it's an um candidate key right so i can simply say that a super key is a okay super key is a uh superset of a candidate key okay make sense so the definition of an super key will be looks like this a super key is a set of one or more columns which uniquely identifies the entire recorder okay now uh the last key that exist is a foreign key which is very very important foreign now tell me now tell me in the beginning i have said student enrolls in a particular course so i have to store that particular course details in student for particular student right so i will have an another course id in here so why so so here by having an course id i can uniquely identify the entire course details right so it means that it will act as a primary key in a course table so by having in reference of course id from the student table i can like i can get an entire course details in a course table right so that so it means that it will acts as an foreign key in my student table so what is this foreign key definition goes something like this uh a foreign keys or the a column of a table that points to the primary key of an another table okay points to the primary key of another table so they act as an cross reference between the two tables okay sorry cross reference so uh this particular in this particular course table the primary key is being pointed to our same as an in this particular student table so that's all about the keys so now let's discuss about normalization normalization so what is a normalization so basically a normalization is a process of organizing the data in database okay to avoid a data redundancy and some anomalies so what is a data redundancy so data redundancy means uh simply you can call it duplicates okay so what is anomalies anomalies are problems okay that were arranged during the data insertion in and table or while like in database okay so let's see so let me write the definition of a dark following okay a normalization easy process of organizing the data in a database to a wide data redundancy comma anomalies so this particular data redundancy means uh storing duplicates or means a duplicate value okay anomalies means uh you can simply call them as a problems so hope you still might be in a confusion let's see what does this okay so let's take an example table okay where you will be having uh employee id employee name and uh employee address sorry employee address uh this is not address this is uh let's consider this is a department like where he belongs to okay where he uh belongs to and the uh department id okay department id code so let's assume this is our database and we do have some our records in it okay let's say when i say records it might be let's say employee one or one our name is one c okay so employee department is let's say we do have depend names like agudavari okay so and department id let's say department id is rd rd101 okay d101 and we now have another uh record let's say r80 he belongs to krishna department and department id goes something like this okay now we do have another thing so a one c sorry one c and uh he belongs to a spider master or avengers whatever you mean call okay and also a bomb sees like one not one this person is again belongs to another team let's say krishna okay he belongs to krishna team also now let's see now let's see what are all the anomalies we might get okay so first one tell me so uh let's assume here uh one c is like one not one one r one okay now there is a are two records associated with one not one employee now i wanted to update the address of a once okay i wanted to update the address off and now update the address of one not one employee now how many times i need to update at two times now let's suppose i forgot okay i forgot to update for two times i have updated only for one time okay i have updated this guy okay so like so i have made it as a bangalore and still he belongs to a mumbai now tell me is this a problem this might be a problem right so this kind of problems is called as an um update anomalies okay update announcements now let's discuss about a delayed anonymous a delete now let's say suppose i i am trying to delete the department okay so like we have in uh spiderman department with the department 103 we are trying to remove that entire department like means i decompose that particular uh department okay now so if i delete this particular department this entire record will get deleted there might be a chances so what is happening we are losing one person do you think that yes so that is called a delay term now what is an insert anomaly so let's say let's say so this particular department id is a primary key okay this is a primary key now i'm in new joining okay so i joined in a company uh like two days back so still i was i am in an um training phase only uh no department is being allocated for me okay now some people is trying to update my database to get an id card for me okay so now tell me do i have a department id currently and no because i'm not belong to i am not assigned to any department right so whatever the date i have is this particular employee id let's say 104 and a name let's say psi okay so i don't have department uh employee department and the department id as well so it won't take the re this record right you record this code sorry we recorded uh it won't take this particular record so what happens okay so it won't take that record so we lost the one particular employee name so that kind of a problem is called as an insert analogy okay inside allow me means that during the insertions like insertion into the a db so our delayed environments means uh while deleting the uh data from a db update means while updating the data which is present in database okay now this is about uh normalization and anomalies so how we are going to solve this kind of problems is called as an normalization okay so we do have different types of uh normalizations so those were our classifications okay we might call it as a classifications as well so first one one nf two enough so first normal form first normal form a second normal form uh 3nf and bc enough and we do have a 4nf and 5nf but but this were not necessary okay not necessary what does it mean not necessary so whenever we achieve this bcnf for a particular table in database then we can say that there there will be no data redundancy there will be a no anomalies okay so we can say that that particular table is all set okay so we don't require these things okay so that is the reason why uh in interviews also in most of the interviews they don't track this foreign 500 topics okay they will end up at busy enough okay not even bc and yeah so in some cases they will ask you bc enough otherwise they will just ask you to define this what is um one and f two and one three enough but when i say uh like when they ask you to define it's your responsibility to take in one example and then you need to explain it because uh in an interview mostly interviewers are not interested in hearing the standard textbook definitions they want something like more than definition like let's say concept okay what you have understood from that particular point okay that is what they want okay that is what they are expecting from you as well okay now let's see what is a one enough okay let's start with one nf okay let's say we have a table like this uh student id student name and student mobile number okay student mobile number so what is the data it has our student id is 101 102 okay so now uh mobile numbers are this guy has a two mobile number okay so i'm writing only five digits okay so consider in real case okay uh so another thing another mobile number is this and this guy has this and this guy has this okay these are all the mobile numbers they are holding now tell me so the formula of like what is the principality of one another is uh an attribute often table cannot hold a multiple values okay it should hold only atomic values atomic values in the sense it has to contain only one value under one particular attribute let's see so in our case under student uh mobile we are holding at two values right so this is not the one nf principle so we need to convert this table into the one nf right so we need to convert this table to the one and f so here what we can do now we can simply flat this uh one entire table so when i say flat let's say what we can do now um okay so what we can do uh let's say one not one one c one this one is one and i can make this one three four two five with another new record okay so same id is same student name is one c but mobile number is uh one three four two five so now there is no problems in this a one not two one one or three if suppose if suppose again one or two has uh two or three mobile numbers let's say two more three mobile numbers okay three mobile numbers okay so now again this with this particular student id we do have a we might have a three records okay in our flattened in our one nf converted okay so something like this so here we will have first number here we do have a second number here we do have a throttle mobile okay so this is what top of first nf a first normal form okay now let's talk about a second normal form so let's first discuss the principles of um second normal form so here the principles are fasting our table must be in one enough okay so whatever so whenever we are trying to convert one particular table into an two nf that table must be in a one and a half okay it must has to satisfy that principality of one enough then second thing is are no non-prime attributes so non-prime attributes in the sense of non-primary key attributes okay is a dependent on dependent on the proper subset of candidate key step candidate keys okay let's see with one example okay i'm sure by seeing these definitions you are not going to learn anything apart from marking up those definitions let's see okay now let's see so would you have a table something like this okay so a student id a student name and a student each okay so student id is of one one uh so let's say 11 1 it's not a student name let's consider it's in uh course okay which a student has been enrolled okay so 101 student id is enrolled in let's say dbms subject and his age is 21. now again one not one student might be enrolled in other courses as well so what is that it's a voice like operating system so again his age is 21. so uh we do have another with our student without id 120 okay so he is also enrolled in uh computer networks he says is 22. okay now another guy with 120 sim and he enrolled in an um machine learning subject with age is 22 okay so this is the data we have in our table okay now it's our job is to convert it into the to end okay now now let's say can i say that this particular table is in one nf yes so for every attribute it is containing only one value so that i can say that it is in one end now now we need to follow the second principle of this guy okay um so the here tell me what are all the candidate keys here candidate keys only student id right so the keys which are um helpful us to identify the record uniquely that is only this student id so what we can say what we can do so here our primary key is prime key is student id okay primary key is a student id now now what they are saying so they are trying us to every non-prime key attribute has to be dependent on primary key that is what they are trying to say okay let's see so what we are trying so can i say that this course is dependent um depend upon this particular student id so if i give you particular student id can i say all the uh courses that he go uh that he enrolled in particular semester yes i can say that now tell me if i give you particular uh student id can i say that now so can um can i get the age of that particular student yes that might be the case so it's your table has been simplified something like this okay so let me draw here only okay so what i'm trying to do now so first i will have a two different tables one is a student age to age a age table so where i will be having uh uh details of all the ages of a particular student id okay let's say here this guy triple one uh student id with triple one having an age of twenty one okay now again two triple one twenty one yes we do have that now again one twenty twenty two each so one twenty and twenty two 8 again 120 22 each now whenever uh i want uh age of particular student okay now i can simply give you the student id you will give you media so you can give me the student age that's okay fine now what about this course table so i will leave you that course as it is because because so if we wanted to make it as how can we make it so we can make it like this but we are violating the principality of one and f hope you have remembered that definition of uh to enough right so that table must be in a one nf and also that has to be in in uh like all the nine non-primary attributes must be associated with the prime caretaker so i will leave that course table i will leave that course table as it is okay something so let's say one one one one one one twenty one twenty first guy is enrolled in dbms and then os then c and then number okay so whenever i want this particular uh student age i will simply make a call to this guy okay done this is what to enf okay so it's very important to know the examples okay at least if you are in an interview you have to say these kind of things okay so not even like simply drawing all the stuff even let's assume you can say something like this let's assume so we have uh one table with the attributes like student id student name under student teach so here the principles of a second uh to enough is uh the table has two must be in one and f and it all the prime non prime key attributes must be dependent on the primary then you can divide those things into a multiple tables that's it okay now we'll talk about three and three enough so what is this r3 enough means let's see so i can say that it has to be in table must have been to enough okay table must be into enough that is for sure now now apart from that apart from that so uh there will um like let's say uh transitive functional dependency of a non prime attribute on any super key should be removed okay so yeah it doesn't make sense to you uh i will we'll take one example and we'll see what it is actually okay let's see we have a table of employee this time let's change the table system okay let's say employee so employee id employee name and i employee address now let's consider address okay so pin code okay so pin code or chip code whatever you might call okay and then i am storing this date then employ city then employee district okay so it has some data let's assume we have all the data now what i'm trying to say now what i'm trying to say now so this if i give employee id i can get this entire row uniquely is there any key something like that and no so here candidate key and primary key is employee id employee id now now is there any possibility of decomposing this table again so think think uh yes i can say one thing so now let's forgot this entire table now let's assume we have this only div you have this table now can i say that can i say that this if i give this enter pin code or zip code whatever it might be so can i get the entire row in this particular table in this particular table yes right under pin code and zip code or pin code or zip code is very unique okay it must not be given to another state like another districts or another places or another uh legislators right so what i'm trying to say so i will i will decompose that entire table into two tables so i will have employee id employee name and employee pin code okay i will have something like this now i will make this pin code connected to another table called address table address table where i will be storing all the um all the pin codes okay let's see i will have a pin code then state then city then district okay now whenever so i will give all the pin codes here of particular employee now whenever i search with this pin code i will get a entire state and city and district details that works that works right so this is about the three enough now um now we'll talk about the bcnf okay now we'll talk about the bcnf so the full form for bcnf was voice a code a normal form kept voice code normal form so again the conditions like our principles of this particular will be so it has to be in a three and a for sure the table must be in three enough and a second thing so like i can say that bcnf it's a little stricter than a 3nf okay so a table complies with bc enough if it is in if it is an in sorry if it is in three enough and for every functional dependency okay let's say x to y x should be super key of a table what does it mean let's say uh suppose let's take one example uh there is a company where our employees works in multiple departments okay employees works in a multiple departments let's see so employee employee id employee nationality employee department and department id department id and a number of people in department particular department okay now i will say so employee id is one zero so one zero one an employee nationality is indian here department he works for uh department id let's say 101 and in particular godavari there were 250 people were working let's suppose okay and you do have uh so again this uh one at one guy so one double zero one guy also works in another department let's see how again he is an indian so he's uh another department is krishna department id is one or two and in that particular department let's have 100 people are there and there is a guy with uh one zero zero again he works for two different uh departments and his nationality is uh america uh again he works in both godawari so this is the table that we have okay now let's try to identify okay so let's try to identify so can i say that uh like how can i say this entire like uh employee functionalities depended on this employee nationality is dependent on this employee one thing yes now i can say that employee id gives you employee nationality now what is the other case so can i say that can i say that employee uh like these things so yeah uh department id and number of members in a particular department is dependent upon the this particular department yes employee department yes so i can say that employee department is equal to employee department id and a number of employees okay now how we are going to take this into the bcnf okay so we can break this entire table into three tables okay let's see how so first table let's say nationality nationality a table so in that i do store employee id and employee nationality okay so zero zero one is an indian and this guy one double zero two is an american that's it for this a particular table now i will have an another table okay so where uh department table okay department table let's say i will have a department department id department of people like number of employees okay so first department we do have godavari and the id is a one zero zero one and number of people and then we do have a krishna and it is a one zero two and we do have a hundred employees in that okay that's it now we have another a table uh which is currently mapping to that particular uh both tables right let's say let's see so now i will in this particular table i will have only the primary things okay primary case primary attributes let's say what is the primary attribute in a table one it's an employee id now what is a primary attribute and second table it's an employee department so now i can say that one not one belongs to go the worry again one not one also belongs to krishna and one not two belongs to godawari and oh this guy belongs to krishna done so whenever i need entire department details i will go to krishna i will get that whenever i need an uh national deaf and particular employee i will go to nationality table and i will get the nationality okay so uh that's all about normalization okay so i highly recommend you to think on your own okay like try to frame okay take a couple of examples and try to divide those things what kind of problems that you are going to get okay now let's talk about um transaction management in dbms so what is the time what is that transaction a management in dbms what is a transaction what is a transaction it can i say a transaction easy a transaction easy a set of logical operations a transaction is a set of logical operations i know you might be in a little bit confused but let's see one example okay so let's say uh you are sending some amount okay you are transferring some amount from your bank account to your friend bank account okay so now tell me what are all the operations that are being coming in this process like right from the sending to uh are like receiving in from your in your friend account let's say can i say that fast whatever so you need to read what what is the amount that currently is being in your account let's say r is for a read w is for right first you need to extract the amount which you which is print in your account then then i'm assuming that your amount is been in this year okay your current account or current amount okay now let's say in yeah okay so in your current bank account you have a thousand rupees okay now you are sending 500 to your a friend okay let's say so what you need to do you need to minus a 500 from this thousand right so and now what you need to do you need to write this whatever the amount let's see thousand minus 500 it's a 500 you need to write that amount to your bank right so right okay so now we are successfully so till now your job is done okay your job is done your job is done now now what has to happen so basically after the amount has been detected from your account it has to process that amount to your friend account let's say so again so i will be getting this money from these two uh your friend and being it is being stored in b now whatever the amount i am sending it has to update that data in your friend data like friend account right so b plus 500 done now i need to write this data to my account that's it so can i say that what these are all the transaction that has been involved in this particular uh entire transaction right all the operations that are being involved in this entire transaction right so let's let's simplify this like let's give some over what we have done so first we have uh radio current account right undetected amount from your account and we have updated the amount in your current like in your current account right then we have initiated um amount to your friend and we rate the amount of your friend and we have updated the amount present in his bank then we have committed that changes like whatever the amount that has been updated we will be updating that in database as well okay so these are all the transaction operations now let's see what happens you might have a question like a transaction fails in between operation okay you might have this question right so let's see what happens so uh let's suppose you are using some uh android application or you are using some online application to send money to your bank okay so sorry come to your friend now let's say you are a sender and you are at a friend at the receiver state now you have initiated your transaction okay so from your bank it has to go to receiver now amount is got detected from my account but but it is failed to update to my affront like fail to send that amount whatever that is being detected from my account to my friend so what happens so like in general in general everyone must have used applications right so it will say your money uh will like your money will get back to you get back to your account within one hour like one hour or two hours right so it has to be now now let's say this is the failure case right this is the failure case if it is has been a success case like this so detected and success success success so can i say that whatever the amount of money that has been detected from my bank will get reflected in my friends bank yes can i say that now what is being happening what is being happening so can i say that if transaction is got failed okay transaction failed i am roll back my changes to the okay previous changes previous changes like before initiating that particular transaction now if like success case right so i'm committing my committing uh changes at both ends okay so whenever that particular transaction like operations all operations in a particular transaction are good then i will commit my changes at the both ends at receiver and server like center it so if everything if something went wrong okay and a transaction got failed then what i will do immediately i will roll back my changes to the previous changes okay whatever the state uh has been there before that before initiating that transaction okay i hope you had some good knowledge on these transactions now we'll talk about another important question on transactions in an interview so acid properties acid properties so what is acid properties so a stands for atomicity c stands for consistency i stands for isolation d stands for durability we'll talk about them each okay we'll talk about them each so what is it let's discuss start from this uh atomicity so what is our targeting so let's say uh your hand account b account a and account b okay in account a you have 500 rupees and in account b you have 1000 rupees now what you are doing you are transferring 100 rupees to account b okay this here so means so we will detect your money okay and it has to update here so it's in success case right so now let's suppose it got failed here okay suppose it got failure means amount got detected here and uh changes were not updated like money didn't receive that particular whatever you have sent okay now in that case what you need to do so you need to be come to previous state right so roll back so what does this atomicity says now either either either your a transaction should be successful if it is successful you need to commit okay what we have discussed earlier if it is failure you have to roll back to previous changes okay so you should not be in a middle case okay where let's say where uh money got detected from you okay and uh money didn't updated in your friends account okay you should not be in that particular state right so who wants to be like that right no one so either it has to update currently or it has to not to update everything okay so that is the that is what the principal principle of atomicity now will talk about consistency consistency now let's say again you have an account okay account a okay there were two accounts account b and account c okay you have a thousand rupees in your bank okay you are trying to send a thousand rupees to here thousand rupees to here no sorry hundred rupees sorry 100 rupees to here and here now you have initiated a transaction like concurrently both are running a concurrently okay concurrently means both are running at the same time same time now tell me so it has initiated transaction so b is assuming that so after after uh withdrawing that particular money like money got detected from the ace account then it should update then it will update us online again c will also do that same right so because well whatever the like before while initiating this particular transaction account as thousand rupees so it feels that i'm the only one who is doing this particular transaction then it will update this thousand to nine hundred hope you got this now tell me is this the right way to do so no okay so in this particular case we can say that this is an inconsistent okay so actually our database has to update 800 but we have 900 so in real time we enjoy the most but that should not be the case while designing the software like at least as a software developer if i do like that entire like um a bank bank will come to my company and will drive screw yours right so that should not be the case now now what is isolation so what is the solution this is the solution for this consistency okay let's see so it it says that at every time okay whatever that time so only one transaction has to be executed okay so we have seen some problem with while uh here here right so here we have initiated two transactions so we have seen some inconsistency problems so for that we are saying that solution might be isolation so it means that so at whatever the time you have to initiate only one single transaction at a time okay like you can say that single transaction at a time now what is the last one a durability so we do perform lot of transactions right we do perform lot of transactions on our banks so at the end of the day at the end of the day whatever a transactions i've made all those things will get reflected on my bank account right balance bank balance right so whatever so let's say i have seen 2 000 then i have received a thousand then i have again sent two thousand i have received five thousand so whatever happens uh like my bank account balance has to be reflected and it has to be preserved for longer okay so whatever changes or transactions i do are those reflected changes expected things has to be preserved for forever okay preserved forever great hope you got guys had an uh good uh understanding of rc property it's very very important to understand okay so if you have not understood please try to have and look over again okay now we will see the states often transactions states of transactions so transactions okay so what is that trains uh transaction states okay so first so whenever you start an transaction it has to be inactivate okay now now let's say so we have started in transaction okay you do some reasons it got filled okay then what you will say but must be go to failures failure state okay fail your state now there is no problems you have performed enough read and write operations okay then it has to be committed that then it has to be committed now now okay let's say so after committing your changes okay so like amount has been detected from your bank okay but your friend didn't receive that amount then it might be failure case so yeah again it might be a fail failure now so what is the other case so after committing let's suppose okay let's uh so sorry it's partially committed so let's suppose your transaction is successful okay your friend also got his money god got your money in his bank account then we can commit we can say commit you can say commit now now so if it is fails if it is fails we need to roll back to our previous changes right so after roll back we do abort okay if we do abort it will get roll back okay so whatever happens at the end of the day we'll terminate our like will uh will finish or terminate right or transaction that's it so these are all the states often one particular transaction now let's talk about a deadlock in dbms deadlocks so again deadlock is been a very important topic and which is asked in like every product based companies if i say and also the the same code as contact uh sorry the same topic is being reflected in os as well operating system okay now let's see what is this a deadlock means so a deadlock is a condition okay a deadlock is a condition where in uh two or more uh processors are waiting for each other to execute okay but none of the tasks are willing to share their resources let's say we have a process one okay which is are doing some tasks okay and it is a using a resource called r1 okay resource one okay now so again there is a process called to process to and which is using our resource to okay resource to now now here the problem is so to complete process 1 okay to finish the process one task it need it need r2 okay it need r2 but but the problem here is r2 is currently used by r1 sorry p1 p2 sorry p2 okay but to come the problem for to complete the p2 task p2 requires r1 which is being currently hold by p1 so p1 is not interested to lose is r2 okay it needs that and also it is waiting for r1 as well and p1 is not interested in uh giving r1 and it is waiting for r2 so can i say that it is being full pack like traffic jam okay so this kind of situation is being called as a deadlock okay so hope uh like you got an enough idea okay let's say i will put these points here okay so the point one is p1 holes r1 and waiting for r2 okay p2 holds r2 waiting for r1 okay so this is not going to happen right because either of the processors are not giving up okay so to say like uh so to say when these kind of situations may occur so we have an conditions which were been called as a kaufman conditions there were four conditions okay if uh like four conditions or get satisfied then we can say that deadlock may occur okay so the first one is mutual exclusion mutual exclusion what does this mean let's say so there are no like one or more than one resource are not being shareable okay so let's say there is a resource which is b which has to be allocated to only one person okay so which is not shareable okay then we can say that it might get into an uh deadlock condition just because risk it can serve only one process a data right okay one or more resources are not shareable this is the first one now what is the second one the second one is hold and bait obviously we know that right so it is holding something and it is waiting for something right and other one other one is also holding something and waiting for something okay so in that cases we can say that it might enter into deadlock condition now what is that one so the third one is no preemption or non-preemption kind of stuff okay so what is this unknown so let's say there is one process which is being executing his task like come doing his task now you wanted to do your tasks okay so currently p1 is doing his stuff and you even at the same time you are you have some adjective and you wanted to do your task as well so in that case is you have to wait you can't drag that p1 you can't say like hey i have to go i have to do i have so much at work you can't say like that you have to wait till p1 completes it starts okay there is no middleweight it has to complete and then only you can go and do your task okay so in that situations i can say that it might endure in deadlock situation now last but not least a circular rate so as you can see in our particular diagram so yeah here this is in circular way right so it is p1 is waiting for our holding r1 and and uh our p2 like process one process two is of waiting for p r1 and it is holding r2 and r2 is uh like p1 is waiting for r2 so this is a circular condition so now no one is gonna execute it okay it will be going in infinite that so in that in that situation as well i can say that it might enter into a deadlock situation now think what are all the handling like deadlock handling conditions deadlock handling methods so first one so the one which i love the most and nowadays which is being very used okay so just avoid like whatever like ignore the problem you can simply say ignore the problem so problem in the sense deadlock so what are you saying so you got some deadlock issue and you are saying just ignore that like how how this is going to bend one handling condition no i can say that this is not a condition but but why i'm saying this okay let's see let's understand so basically let's consider let's consider okay so you got a deadlock situation and your system got hanged okay your system got handled so i can say that to resolve that particular deadlock issue resolve issue like deadlock situation it will take 10 minutes of time okay i can say that in 10 minutes of time and even it will be a little more costly as well okay now uh so how much of time do you require to reboot your system can i say can i say or not more than two minutes or three minutes so which one do you prefer now as i so i will prefer this one right which is a time so it it does my it finishes my task within some little time okay so like two or three minutes so that i can continue with my work so that is why i ignore the problem so this is not a bad solution this is been used in windows under unique systems unix systems okay this is not a bad solution now the second one is uh deadlock avoidance so what does it mean what does it mean so let's uh let's get all the requests okay from like whatever you want to process okay now if there any chance by any chance if you get in deadlock occurrence okay so if you if you have observed that there is one deadlock situation has been occurred now stop there stop there and check all the processes okay so what whatever the condition like whatever the process that caused that our deadlock situation then go take that out okay take that out just leave it that's it okay just leave it so what i'm trying to say now so let's assume this is your system or cpu okay so collect all the requesters okay now if any deadlock situation has been arrived okay then stop then stop and take each request at a time uncheck for deadlock condition okay so if if and by chance if you found any request that is causing deadlock okay just avoid that particular request avoid that particular list request then do continue with your uh process other processes okay so there is one famous algorithm which does all these tasks that is called a banker's algorithm now let's move on to next handling condition next handling condition so that is a deadlock prevention ah no no before going to deadlock prevention let's discuss deadlock detection and recovery okay so it is again same collect all the requests okay process everything and if you found any like if if you want any uh particular request costly deadlock okay then take out that particular request okay then try to recover that like whatever the request that cause did it lock try to resolve that okay then that works okay so now uh last one a deadlock prevention deadlock prevention what does it mean let's say so now again we'll come to come back to our kaufman conditions okay okay we'll try to have one solution per at least uh like for every kaufman condition okay first one is uh mutual exclusion so uh like what is the problem that we have got so we got that uh we don't have any shareable things every resource can share only one particular process so now what i what we can suggest so we can suggest to make processes as such make resources as shareable that's it which can serve up one or more processes are data okay then that will help resolve our issue now the next one is hold on await now so it is like what is this uh problem is causing like let's say if we saw that in root cause so it is holding something and it is waiting for something which means before it started you don't know what exactly it required if it is that uh if we if that particular request knows what it what all the resources it required it should have asked earlier right so before starting that particular process it should have asked everything and after getting everything if it started then it won't enter into that particular deadlock situation right so what i am suggesting now before starting process request collect all are required um resources and then enter into execution that's it then there is no waiting right then there is no waiting okay so this might be one kind of solution now what is that next one so next one is preemption what is this preemption so let's say we have went on p1 okay first p1 now it identified that it requires some kind of resource okay so whenever it says yes i need request to complete this task then take out that process outside and continue with next processes that's as simple as that right so then collect all the required resources then again process it after the next one it makes our job easier right now last one circular weight so this is little interesting let's say we have a p1 and it is holding r1 okay and it is waiting for r2 which is been allocated to p2 okay now p 2 is waiting for r 3 which is b again you assign it to p 3 now p t is p 3 is waiting for r 1 ok so now can i say can i say if i able to cancel this particular call from me okay now can i say that i'm not going to enter in a circular weight yes now what is that condition okay what is that condition so if you observe that thing uh slightly that is done because let's say if i'm so if i say if i have a condition okay so if a resource is if your resource is less than your process request let's say here process request is p3 and the request like resource that you are requesting for is r1 which is a smaller than right so it it means that r1 is currently holding by someone okay so whenever such kind of request has been made by any process just say i don't give okay just say i don't give so in that cases i we won't end up in a circular rate right so that is the case so hopefully you have learned a lot from this and that tutorial if you are visiting channel for the first time don't forget to subscribe if you like the content please hit that like button up if you are if you have any questions or video requests that you would like to hear from scalar please let us know in the comment section catch up in a next video hey folks i welcome you all to scalar academy's youtube channel and this is the first video in the sequel tutorial series now before i start off with today's session i'd request you folks to subscribe to our channel and also hit the bell icon so that you do not miss out on the notifications so on that note in this session we'll start with understanding what exactly is sequel and then we will go ahead and create our first database and table so before we do all of that let's understand what a sequel so simply put sql stands for structured query language well that is just the extension of this term sequel but what we actually do with sql well with the help of sql you can communicate with databases okay that's fine but what is the database well whenever you have to store data and if you have to store that data in an organized form you will need a database so simply put with the help of a database you can store your data in an organized form so let's understand the example of database and tables with a simple example so i have got this t set with me i hope you guys can see this properly so in this t set what you can consider is this entire thing to be your database and in this entire thing what you're doing is you are organizing your data in a proper structured way so this entire set you can consider to be a database and these cups which are present inside it you can consider to be your tables and if i'd have to simplify it what i can say is let's say if you are studying in a college then your entire college or all of the information about your college would be stored in your database and in your college database you can have multiple tables so you can have one table for student information another table for the faculty information another table for the department information and this is how you store data in tables and those tables are properly organized in your database but there's a cache over here if you'd have to work with the data which is present in these tables or which is present in this database then you need this language called as sql because without the help of sql you cannot extract data from these tables and this is where my friends the knowledge of sql comes in so with the help of sql you can properly either maybe insert data into this table extract data from this table or even manipulate the tables which are present inside this so but we understand what exactly a sql let's go ahead and create a first database and our first table using my sequel server so i've opened up my sql workbench over here now before i go ahead and create the database let's again understand what does my sql and also what is my sql workbench so mysql is a database management system so we know what exactly is a database and again to work with these databases what i need is a database management system and that is exactly what a dbms means and we have different types of dbms so we've got mysql we've got microsoft sql server we've got the oracle sql and are these right now the dbms which we are using is my sequel and if i do want to use the gui tool of this that is what is known as mysql workbench so as you can read over here mysql workbench is the official graphical user interface tool for my sequel and now let me go ahead and open my local instance so this what you see over here local instance and i have to type in my password so user by default would be root and then whatever password you had given just go ahead and type in that and i have opened up my window so over here let me go ahead and create my first database so to create a database this would be the syntax let me increase the size of it so that you can properly see it so here i'll write down create a database and after this i would have to given the name of this database so this create database so what you see are the keywords so create a database this is the syntax which you would have to use after this just given the name of the database let's say i given the name of this database as college after this let me just put in a semicolon and let me select all of this and this thunder symbol which you see just click on that now when you click on that here you would see that create database college and here you would see in response one row has been affected this would basically mean that i have successfully created my database called as college now after i've created this database if i have to go ahead and create some tables in this database i would have to use this database so for this i will write down use and then given the name of the database so the name of the databases college so i'll just write down use college again i will hit on this symbol again you will see that use college response zero rows has been affected again this would basically mean that i have successfully selected this particular database now i have selected the database this is my opportunity to create a table inside this database so inside this college database i would want to create a table called as student and to create the student table this would be the syntax so i shall write down create table so by default this is what you'd have to write create table and this is the syntax to create a table in your sql server table or sql server database so i'll try down create table and then i'll go ahead and given a name to this so i'll just write down student so this would be the name of my table after this i will given these round braces and inside these round braces what i'd want to do is i will given the column names and also the type of the column name so first well if you're a student at a college you will have a student id so for that student id i just represent that as s id and then i will give this a data type so let's say the data type for this is int then going ahead i would need the first name and the last name of this student so here i'll just have s first name and the type of this would be variable character or var and over here let me just given so let's say the first name the maximum length of the first name could be 25 characters then after this the student would also have a last name and if the student has a last name i would create a new column for this and i shall call that column as let me just write down last name over here again i will give this a data type so for this again the data type would be wirecat again the length of this i will set it to be equal to 25 so here 25 basically means that the length of the first name and the last name could be anywhere between 0 to 25 but cannot exceed 25 characters and now so i've created columns for the student id student name the student last name i would also need another column for student marks so here i'll write down s marks again let me put it to be integer so this is also set over here now i have given over here four columns and also since everything is set i will end this command with a semicolon so what i've basically done over here is i've created a table called as student and the student column or the student table has four columns the four column as student id and the data type of student id is integer then we have first name and this is a variable length character which would basically mean you can give strings over here and over here again i have last name where again you'll give a string and then you have the marks where it is of integer type and you end this entire thing with a semicolon now let me select this entire thing and let me hit on this and here if you look at this you will see create table student zero rows affected this again would mean that i was successfully able to create this table called as student now let me delete this entire thing and if i would want to see the table what is present in this table or what records are present in this table i have a command called as select or i have the statement called as select so here i shall write down select star from and i would have to given the table name so the table name is student so select star from student would mean that i am selecting everything or all of the records in all of the columns which are present in the student table so let me select this let me hit over here and as you see i was successfully able to create this student table which had all of these columns so here i've got the sid which is the student id then i've got the first name the last name and s marks so folks this is how we can create a database and a table using sql so folks this would be the end of this video in the next video we'll see how to insert data items or records into a table now before i end the session again i'd request you folks if you find this session to be informative do not forget to hit the like button and also do subscribe to our youtube channel so thank you and let's meet in the next one hey folks i welcome you all to scala academy's youtube channel and this is the video number two in the sequel tutorial series in the first video we understood what exactly a sequel and after that we went ahead and created our first database and our first table and in the second video we'll see how to insert data into our sql table so will not at all waste time and open my sequel and go ahead and insert records into the table so i've opened up my sql workbench over here let me go ahead and connect to my local instance and over here again i would have to given my password and i have opened up my sql workbench and over here in the first tutorial or in the first video if you remember we had created a table called as student and that student table was part of the college database so my first task would be to use the database so for that purpose i'd have to write down use database let me also just go ahead and increase the size of the text so that you can see this properly so here i shall write down juice college and let me execute this so we have successfully executed this now we have opened our desired database so the name of the database is college and in this college database we had created a table called as student now let me also go ahead and open that table or maybe just select all of the records which are currently there in that so for that we had used something called as select star from student so what this basically means is i have a table called as student and from the student table i am selecting all of the columns and all of the records and that is what the star means over here let me again hit on this thunder symbol and as you see over here these are the columns present so i have this column called as sid then i have another column called as s first name after that i have a column called as s last name and then going ahead i have a column called as as marks but you see that this entire table is empty because we have not yet inserted any data items into this table so this is what this entire video is about and in this video we will see how to insert records so let me just go ahead and do that let me decrease the size of this here let me just remove this out and let me see if i can drag this down properly seems like i cannot do that so instead what i'll do is i'll just write down the command to insert data items so what i'll do is i will write down insert into so here you have to properly remember the syntax insert into other keywords this is what you will give after this you will given the name of the table and what is the name of the table the name of the table is student so you shall basically write insert into student then you will have to given another keyword which is values after that you have to given two round braces and inside these you can given the values so the first value is student id so let's say the first student id is 1 0 1 then i would have to given the first name of the student so let's say the first name of the student and also if you remember the first video properly you would know that the first name last name are basically var car type columns and over here i can given string data type and whenever i'd have to given a string i will enclose that in double quotes over here so first name so let's see the name of the first student is i will write down annie and i would have to given the last name as well so let's say the last name of this person is cleopatra so student id is 101 first name azani last name is cleopatra and i'd have to give in marks as well so let's just say annie cleopatra has scored around 87 marks now i will put in a semicolon over here and i'll select this entire thing and i will hit this thunder symbol and we have successfully inserted this into our table now just to verify this what i'll do is i'll delete this entire thing and i shall again write down select star from student and now if i hit this thunder symbol you will see that i have inserted these values so we've inserted the first student or the details of the four students so sid is 101 first name is annie last name is cleopatra and this person has code 87 marks now similarly if i would want to insert the details of the second student i'll do the same thing so let me just write down insert into then i need to given the name of the table which would basically be student and i will given the keyword values again given this round braces over here now let's say the next student id is 102. now the name of this person is let me just write down john and the last name would be smith so let me just write this down properly so this person's entire name is john smith and john smith has scored let's say 56 marks and let me end this syntax with a semicolon now i'll select this entire thing i'll click on this and we have again inserted this now just to verify i'll delete this again i will use the select statement so i'll write down select star from and i would have to given the name of the table again so the name of the table is student let me write down student over here let me end this with a semicolon and i'll execute this so right now you would see that i have also inserted the second record where the student id is 102 student first name is john class nemo smith and this person has spot 56 marks so folks this is pretty much it for this video where we have learned how to insert records into a table so on that note i will sign off and before we actually end this video i request you folks that if you found this session insightful do like the video and also subscribe to our channel so thank you very much and let's meet in the next one hey folks i welcome you all to scalar academy's youtube channel and this is the third video in the sql tutorial series and in the previous two videos we learned how to create a table and also how to insert records into our table and in this particular session we will see how to work with the where clause and filter out records on the basis of the spare clocks so before i actually head to the coding i request you guys to like this video and also subscribe to our channel so on that note let me open up my sequel workbench so i've opened up my sequel workbench over here let me go ahead and select my local instance and also put in the password so the password i am typing it over here let me hit enter and we have successfully opened up our local instance and i would again open up the student table which we had created in the previous video now if you would want to know how to actually create a table and insert records into a table you can follow the first two videos and you will find the link for these two videos in the description below so if you don't really know how to create a table and all sort of insert records i'd request you guys to watch those videos first and come back over here now let me go ahead and open up my student table and before that i'd actually have to select my database so the student table i had created in a database called as college so sure now before i write this let me also increase the size of this so that you can see this properly so here i shall write down use and then i shall given the database name so the name of the databases college after this i'll just give it a semicolon let me select this and select this thunder symbol and we have executed this now that we have selected our database so in this college database i have a table called as student let me go ahead and open up all of the records which are present over there so here i shall write select star from then i need to given the name of the table so the name of the table is student now let me select this again and as you see i have opened up the student table and in the student table i've got all of these columns student id first name last name marks and gender now in this video we are supposed to work with the where clause and with the help of their clause we can filter out records on the basis of a condition so let's say from this entire table i would want to extract only those records where the gender is equal to male let me go ahead and write down the command for that so i'll start off by writing select star from and after this i need to given the table name which would be equal to student so till here what we're doing is we're just using the select query after this we will give in the where clause so here i shall write down where and as you see even the color of this where clause has turned to blue because this is a keyword so i'm writing select star from student where after this i need to given the condition and the condition is s underscore gender this needs to be equal to male so from this entire table what i'm doing is i'm extracting only those records where the gender of the student is equal to mail let me select this entire thing let me press this and now if you see i have extracted only those records where the gender is male similarly let's say from this entire table i'd want to extract only those records where student id is equal to or greater than 103 so this where you see so this is actually a numerical entity and the id start from 101 go up till 105 what i want is i want to extract all of those students whose student id is equal to a greater than 103 so here i shall write select let me write this properly so select star from student and after this i again given the where clause and after the where clause are given the condition so the condition needs to be s id is equal to or greater than 103 let me actually change this and make this greater than or equal to 103. let me select this entire thing and let me run this now as you see the s id over here it starts from 103 and goes up till 106. now let's say if i want the student ids from 104 or basically upwards of 103 then i shall remove this equal to symbol from over here now if i run this you shall see that i've extracted only those records where the student id is greater than 103 and that is why i have 104 105 and 106. now after this let's say if i want to extract records on the pieces of multiple conditions so here i can use the and operator as well as the or operator with the help of and operator i'll be basically extracting those records where both of the conditions are satisfied so for that let me show you the entire table for you guys again so i shall again write down select star from student now from this what i want to do is i do want to extract those students where the gender is male and mark scored by the student is less than 50. so if we see from this entire table we see that there is only one particular record where the gender is male and mark squad is less than 50 which is basically this student and the name of the student is matt cooper so for this what i want to do is i'll again start off with the same thing so we shall have select star from student after this i shall given the where clause and i will follow it up by giving both the conditions so let me given the first condition select star from student where the first condition needs to be gender so i shall write s gender is equal to let me write down male over here after this i shall integrate it or combine it with the second condition using the and operator so this what you see is known as the and operator and with the help of this i can combine two conditions together select star from student where s gender is equal to male and the second condition needs to be s marks let me write this properly so s marks needs to be less than 50. now i shall select this entire thing and i shall execute this so as you see over here there is only one student and the student is matt cooper and as you see matt cooper his gender is male and his marks are less than 32. now after this i would go ahead and show you the entire table again so let me write down select star from student and these are all of the records over here now again let me show you another command with the help of the and operator so here now let's say i don't want all of those records where the gender is female and marks are greater than 50. so let me also write a command for that so here i shall write select star from student where after this i need to write down and to give the first condition and this time the condition would be s gender is equal to female i'll follow it up with the and operator and then given the second condition so the second condition is s marks greater than 50. now let me execute this i'd have to write from over here select star from student now let me execute this and as you see again there is only one student and the name of the student is any cleopatra whose gender is female and who has scored 87 marks now we'll go ahead and work with the or operator now before i do that let me again show you the entire table so i should again write down select star from student i'll execute this and from this let's say i don't want all of those records where either the student id has to be less than 104 or the marks of the students are greater than 50. so what i'm doing is i'm basically giving in two conditions over here the first condition is the s id needs to be less than 104 and the marks needs to be greater than 50. so by that condition seems like we'll be extracting all of that so what i'll do is since i want both the cases so i shall maybe put in the gender condition so either uh what i'll do is so the s id has to be less than 104 and maybe the i'll put the gender as equal to female let me just write that down so select star from i shall write select star from student where the first condition needs to be s underscore id is less than 104 after this i shall write down i'm giving an or operator over here and i am combining this or operator with the next condition so the next condition would be s underscore gender is equal to female and let me go ahead and execute this so here what is happening is if either of these conditions is satisfied we'll get the result so what we'll get is so we've got six records over here and with the help of this condition so this says if student id is less than 104 which would mean that we'll get the top three records over here and along with that since we're also giving in the second condition which is as gender is female now here even though the student id is 106 which is greater than 104 but as you see the gender is female and that is why we'll also get this particular record so let me select this entire thing let me run this and as i've told you guys from the entire table i have extracted those records where the student id is either less than 104 or the student gender is equal to female so folks this is how we can work with the where clause and filter out records on the basis of this so thank you very much for attending this session and again if you found this session insightful please do like this video and also subscribe to our channel and we'll meet in the next one thank you hey folks i welcome you guys back to scala academy's youtube channel and in this particular session in those sql tutorial series we shall work with the update query so till now we've seen how to create a table how to insert records into the table now with the help of the update query we shall see how to modify the records which are already stored in our table so what we'll do is we'll directly open up my sql workbench and start working with the update query so i've opened up my sql workbench over here again i will click on local instance and let me go ahead and given the password and we have our mysql workbench right over here now my task would be to select the database and open up the table so the database which we were using was college so here i shall write down use college let me select this and i will click on this button so i've selected the database now what i'll do is i'll go ahead and use the table which is present inside this so the name of the table is student so to look at all of the records which are present in the table i shall just write down select star from student now again i will click on this and as you see these are different columns which are present and these are all of the records so as of now it seems that we've got six students and uh we've got their names we've got the marks and we've got the gender respectively in this table now what i'd want to do is let's say if the marks which and cleopatra has scored it's actually 97 and not 87 there has been a mistake while storing the data what i want to do is actually change that and for that purpose i can use the update query so sure this is how i would change the marks which are stored as 87 i would want to change that to 97 so let me just write down update so this is how i'll start i will start off by writing the keyword update then i shall given the name of the table so the name of the table is student so update student after this i shall again use the keyword sit and i would have to set s marks to be equal to 97 where the first name is equal to and so here i shall select where s underscore first underscore name is equal to and so what i'm doing is i am changing the value of marks from 87 to 97 where the first name is equal to and let me select this entire thing i'll run this properly so seems like we have an error over here you are using safe update mode so normally what happens is if we are trying to update something and by default in your my sequel server if it is in safe mode you cannot update it so we'd have to turn off the safe mode so to turn off the safe mode this is the command which i'd have to use so i have to use set sequence save updates is equal to zero now i'll select this let me run this now so as you see this has been properly executed now again i'll select this update query and i will select this now this has been successfully executed so now that i've made the changes let me go back and open up my table so here i shall write down select star from students and let me run this and let me see what would be the result that i get so i'll select this again so this has to be student if i'm not wrong and not students and i'll click on run so as you see initially the marks which and cleopatra has scored were 87 with the help of the update query i was able to update it or change it from 87 to 97. similarly we've got another student over here so we've got david leon and his scored 92 so but it seems that this again is incorrect and david leon had in fact scored 62 and not 92. so let me also change that so what i'll do is i'll write down update then i shall given the name of the table which is student so update student then i'll write set and after this i'd have to given the name of the column so the name of the column would be s marks update student set s marks is equal to 62 where now in the where clause i'll actually use the s id instead of s first name so here this person's name is david leon and his s id is one zero three so here i shall write where s i d is equal to 103 now i'll select this entire thing and let me run this so again i've executed this now let me go ahead and select my table so select star from student and let me run this and as you see over here initially mark scored by david leon 192 with the help of the update query i was able to change it to 62. so folks this is where we learned how to work with the update query and if you do want to learn about the other basic things in sql such as how to create a table how to create a database or maybe how to insert records into the table you can watch our previous videos and you'll find the links for the same in the description below so now before i end this class i request you folks to like the video and also subscribe to our channel thank you very much and let's meet in the next one hi everyone my name is devi and in today's video i will be discussing joins in sql i'll be discussing the different types of joins that we have in sql and i'll also show you how you can run those join queries in mysql but before moving on with the video i would request you to kindly like this video and subscribe to our channel all right so starting off first we have a brief introduction of join statements as you can see join statements in sql are used to combine data or join columns from two or more given tables on the basis of a common field between them suppose you have two or more different tables and you want a single table consisting of different columns say one column from one table another column from another table and so on in that case you could take help of join statements in sql and obtain a single table with different columns from the different tables then we have different types of joins in sql but in this video we'll be covering inner join left join right join full join and self join as well so to begin with first let's take an example as you can see on the screen we have two different types of table the first table is the student table which contains four different columns roll number name address and age then we have the second table which is the course table the course table contains three different columns as you can see serial number course id and roll number so the first join that we have is the inner join now the inner join or join keyword is mainly used to select all rows from the given tables for as long as the condition remains satisfied now the resultant table that you get is formed by combining all rows from both the tables where value of the common field will be the same so as you can see the syntax for inner join is given right here it goes like select table 1 column 1 table 2 column 1 from table 1 inner join table 2 on table 1 matching column equals table 2 marching column now here table 1 refers to the first table table 2 refers to the second table whereas marching column refers to the common field between the two given tables now for the given tables the inner join query would be select course course id student name student age from student inner join course on student role number equals course row number now what this inner join query does is that it gives you a single table which contains the three columns course id name and age and these columns are taken from the two tables student table and the course table and also this is done on the basis of the given condition that the role numbers must be matching here you can see the output of the resultant table on the screen there's the course id name and h moving on the second type of join that we have is the left join the left join which is also known as the left outer join returns all the rows of the table on the left side of the join and matching rows for the table on the right side of the join the resultant table that you get displays no value for those rows which have no matching rows on the right side you can see the syntax for left join here select table 1 column 1 table 2 column 1 from table 1 left join table 2 on table 1 matching column equals table 2 matching column now for the given set of tables the left join query would be select course course id student name from student left join course on student role number equals course role number what you get from this left join query is a set of these two columns which is course id and name and this is given in the form of a single table by joining the student and the course table on the basis of the given condition you can see the output of the resultant table on your screen we have the course ids and the names and these data is associated with the same set of row numbers okay so the next type of join that we have is the right job right join which is also known as the right outer join is quite similar to the left join but the only difference between the two is that the right join returns all the rows of the table on the right side of the join and matching rows for the table on the left side of the john resultant table that you get displays null values for those rows which have no matching data on the right side as you can see we have the syntax for right join right here select table 1 column 1 table 2 column 1 from table 1 right join table 2 on table 1 margin column equals table 2 margin column for the given set of tables the right join query would be select course course id student name from student right join course on student role number equals course role number what you get from this right join query is a single table which contains the columns course id and name and this is done by joining the two tables student and course table on basis of the given condition in the query you can see the output or the resultant table here here we have the course ids and the names and also we have null values in the course id column wherever there is no matching set of data so the fourth type of join that we have is the full join now the full join is nothing but a combination of both left join and right join the output table that you get from full join contains all rows from both the tables and also the resultant table contains null values for the rows which have no matching set of data in any of the tables here you can see the syntax for full join it goes like select table 1 column 1 table 2 column 1 from table 1 full join table 2 on table 1 matching column equals table 2 margin column now for the given set of tables the full join query would be select course course id student name from student full join course on student role number equals course role number now what you get from this full join query is the output or the resultant table which you can see on your screen here we have all the course ids listed on the left side and all the names listed on the right side of the table and also you can see the null values wherever there is no marginal set of data available now the last type of join that we have is the self join the self join statement as the name suggests is used to join a table to itself each row of the table is joined with itself as well as all the other rows available based on some given conditions the syntax for self join is select a column 1 b column 2 from table name a table name b where given condition here the table name refers to the name of the table that you are joining and the given condition is the conditions based on which the rows are selected all right so for the given set of tables the self join query would be select a row number b name from student a student b where a row number is less than b roll number now the output that you get from this self-joint query looks something like this here you have the set of row numbers and on the right hand side of the table you have the set of names this table is obtained on the basis of the given condition that you have here in the query so now i'll show you how you can run these join queries in my sequel here on the screen you can see the my sequel workbench so let us see how we can run those queries so on the left side of the screen you can see the list of schemas now i have already created a schema or a database that we are going to work with today here you can see the database that i have created user underscore db1 and i'll also show you the tables that i have created here's the student table i'll show you the student table right here you can see roll number name address and age it has all these four columns i've also created another table which is the course table you can see the course table right here serial number course ids role numbers all of the data is present right here so now let us begin first you can see here's the workspace here's the area wherein you can write your queries first let us see all the default databases that we have this is the query you use for seeing all the default or existing databases as you can see we have these default databases and the database that i have created user underscore db1 so today we will be working with this database and okay so the first query that we are going to run would be the query for inner join so let me just quickly type in the query select course course id then we have student name from student in a join course we have own student role number equals course roll number all right so now i'm quickly going to run this query and see what we get as you can see we have the resultant of the output table here we have the course id and the names okay so moving on the next query would be the query for left join i'll just quickly type in the left join query we have select course course id then we have student name from student left join course on student role number equals course role number okay so here's the query for left join now i'll run this query okay so now you can see we have the output right here we have the table which has course id and the name also we have null values wherever there's no matching set of data so moving on the third query that we are going to run is for write join i'll just quickly type in the query select course course id we have student name from student write join course on student role number equals course real number okay so here's the query for right join i'll just quickly run this query as you can see we have the output of the resultant table right here we have the course ids and the names and null values for wherever there is no matching set of data so now coming to the full join query let me just tell you that the full join keyword is not supported by mysql so what you can do in this case is you can use a combination of left join union and right join keywords all at once i'll just show you how you can do it first you need to type in the query for left join this is just the same query that we have run previously student name from student left join course on student role number equals course row number so here we are done with the left join query then you need to type in the keyword union followed by the query for right join course id we have student name from student write join course on student role number equals course roll number now we are done writing the query now i'll just run this query and see what we get here you can see we have the resultant of the output table with the course ids and the names and null values for wherever there is no matching set of data okay so the last query that we have for today is the self joined query select a row number b name from student a student b where a roll number is less than b roll number okay so here we have the resultant table or the output table with all the roll numbers and the names based on the given condition in the query so i hope you are clear with the concept of joins in sql in this video i have discussed with you the brief definition of join statements i have shown you how you can run all the join queries in my sequel i hope now you're clear with the concept if you like this video please don't forget to hit the like button and also subscribe to our channel thank you hi everyone i am naman bhalla and today uh in this video we are going to discuss about sql queries and uh some of the common type of questions that appear in regarding to sql and basics dba based knowledge that is required if you want to be good in dbm so uh the topic for today is secret interview questions and concepts okay uh so today we are going to first start with a basic coverage of different concepts that you need to know before you even start diving into doing sql queries you must know that okay how data is arranged how to arrange data how to structure your database in a good way such that it is very fast on the queries that you have to do and all other things okay uh great so let us first begin with what even data is and why is data important okay the efficiency of any company any business depends upon the data it has okay i'm like the user data that you have or you have the data about how people are behaving and that information is very relevant for you to make business decisions okay so data is of prime importance and at the core of a company's functionality okay now how will you arrange data to arrange data you need some kind of system right what can be those systems one very basic way to arrange the data can be hey that let me just actually create a file and suppose i have a data and my data is something about let us say that we are developing database for a system okay for a university so what will be my data like let us say that i am a university so my data can be like something about students right my i can have some data about students i also can have some data about my faculty right or my employees let us say for now let us keep it short and let us say that we have only data about these two things now how might i save it one way to save it is very rudimentary way that hey let me actually create a lot of files on my machine and then in those machines let me store the data so let us say that there is a file something like students.txt and let us say that there is another file that is employees.txt and then suppose you have multiple students let us say that there is a student who has a role number one and his name is obey and suppose he has a patch let us say that we are storing these three information we store it something like one obey and let us say it is 2016. so that is a very fine way to store data there is nothing wrong with it right but is it a good way to store data that depends and that depends upon what kind of data that you have right so that is where the concept of a database management system comes that hey how will you even store the data what optimizations will you do so that the storing data is relevant to you because you don't just store data you also use it right so you have to do some queries upon it you have to also fetch the data back again to make some business decisions or resolve some queries right so there are two important decisions that you need to do the very first decision is storing the data and the second thing is querying that data right without these two operations our database management system is irrelevant to you okay so a dbms is nothing but a system software that allows you to store the data and query the data along with providing a lot of security constraints and other things which we will tell as we go into this video okay so those are the primary two things that we uh need to maintain with us okay so that is what our dbms comes from how can we structure a tpms one way to structure i mean like how will a dbms in inside itself structure itself right so the one way can be like even a dbs miss maintains a file that is a fine way to structure that might be something like it is maintaining documents okay can there be any better way to structure your data inside a database management system what do you store the data about in your computer you store the data about some things right you store the data about something like here you were storing the data about students you were storing the data about employees suppose there is also uh users you have some let us say that probable students or people who are who have applied to you so there might be something like applicants which you are storing the data about okay so if you are storing the data about something and for each student you are for each thing that you are storing data about you are storing some things about that right so these things that are called as entities so entities are nothing but about what or about whom are you storing data okay and about whom you are storing data and what data are you studying right you are also storing some kind of data about things like for example for students you are storing the role number you are storing the name and you are storing the batch id that depends upon the business decision as to what you want to store so there are two things the very first thing is the things that you are storing the data about which as i told is called as entities and then there is attributes or fields what data about entities are you storing now let us consider our real world use case is data in cellos no there is always a connection between one data and other data right so for example for a student let us say in a university you might also need to maintain that which courses have been enrolled by a student so somehow you also need to maintain a course enrollment data set right so let us say that another kind of entity can be course enrollment for course enrollment you might what do you need to store you might need to know that what is the course number and also you might need to store that what is this who is the student who has enrolled for that course so let us say the two things that you need for a course enrollment is nothing but a course represented by an id and also a student which is probably represented by a roll number okay now suppose these are the three data sets that your university has if we see here that hey we were maintaining the student role number here as well as we were maintaining the student role number in the data set for this student we were maintaining that role number here so data set is not in zeros our data at what particular location has some kind of reference to data at other role other particular entity right okay this is known as relations between data so now we observe one pattern in it that hey we are maintaining data about something and we are also because we have been we have maintained data about different things then we somehow need to maintain uh relations between them so a database management system which stores data in the form of entities and the relations between them can be known as a rdbms or relational database management system okay what kind of rdbms's exist there are many there are different varieties of rd members that exist in the open source industry and are used very widely by different companies some of the popular examples can be my sequel and another popular one can be post basic with okay now in these two terms you would have noticed one thing repeating right you would have noticed one thing that was repeating was secret what is this sequel this sequel stands for structured query language this can be considered as a default language but i'm like it's not actually default but it's one of the most popular languages to to query upon the data that you had stored because as we recalled earlier whatever data that you have stored has also also needs to be fetched right i'm like if data is just stored it's of no importance to us it's just increasing your storage i'm like it might be relevant to us in the future but anyways at one time we do need to assess it and that is why we are storing it okay cool so now sql as we told is the basically is the most important language that is used to fetch upon fetch data from the relation to rdbms systems now let us see how sql works okay so the very first important thing that we see from sql word itself is a query what is a query a query is nothing but a statement that you execute to fetch the data from an rdbms what is one important thing about computers one important thing about computers is they do what you tell them to do right but they also require that you should be very well defined you can't you can't just say random things to it and it will and expect that it will fetch you the exact results that you wanted right so you need to be very well defined so you need to know that how do i write queries in sql right otherwise you won't get the data that you actually intended to get from the sql query so the prime focus for the today's session will be how do we write sql queries what are the important constructs that we need to know while we write a sql query most of the sql functions in different dbms's are almost same so that is why we are going to abstract away from one particular technology of our dbms we are going to structure about common f sections that we have in our dbms management system and then you can run those over any kind of system that exists okay so the very first type of query the very first important function or important feature to do a query is the select statement this select statement is the most important thing that you need to know to run any query what is select i mean if you just go by the definition of the word select means selecting something or choosing something from the data that you have right so that is the whole function of a select statement so very simple select statement can be that hey suppose you have a student table and you are maintaining three things about a student let us say that he has an id he has a first name he has a last name okay and you need to know that hey who is the student who has an id of 1 suppose that is the thing that you need to know and there are multiple students let us say the student with id 1 has a first name of a and a last name of b then there is a student with id 2 who has a first name x and last name y and you need to know that what is the first name and last name of the student who has id of 1 so you basically need to know a and b how will you use the select statement to write this it's very simple you will say select what is this this is first name so i need to select the first name but do i also need to select i also need to select the last name so select first name or my last name where do i need to fetch from right so suppose someone asked you that hey you need to get this thing i just tell you that hey you need to get a uh suppose a biscuit where will you get that from you you will ask me that where should i get that from right so that information is relevant so the next thing is from where do where should the query language get the data from so suppose it gets from a particular table the name of the table is student so select first name comma last name from student table okay if you write just this query what will you get i mean suppose you're a computer and someone tells you that hey you have to just get first name and last name from the student table you don't know i'm like you go to the student table and you try to see that which first name and last name i need to get you see there are a lot of first names and last name so best way is that you bring all of them right if you just write this query what will it return it will return the whole table as it is it will get the first name and last name of all the students so basically what you will get will be a b and x y why did you return this because you didn't specify which first name and last name do i do should the sql get right okay so let us be a more precise let us say that hey you have to select first name and last name from student of the person who had the id one so you need to know that hey the id should be one at that place so you can write where where id is equal to one and finally you can terminate the statement with a semicolon okay so what will this return this sql query will return you a and b and why will it return this is because of three statements that we just saw here of sql that is select that is from and that is where these are the keywords in the sql query language great so i think this basic idea about a select statement is clear now now let us discuss about a sub query i'm like we will be discussing multiple of these rare clauses from in depth but let us first discuss the basic high level concepts before we delve into details let us discuss what a sub query is now let us say that you need to give degree to some students you are a university you need to give degree to students right the students who are just going to pass in this particular year okay now how will you give degree to those students suppose you have two two tables the one table that you have is a student's table okay in this students table you have an id you have the name of the student let us say and let us say that you have patch okay suppose this is a simple student table that you have and you need to give degrees to the students who are going to pass in patch 2020 let us say so then someone comes to you that hey some of those people who had the batch of 2020 are actually not going to get the degrees because they failed in some co-horses then you ask that okay where should i know that who which students failed so that person tells you that hey there is also a table that is failed students in those field students table you have ids of the students who have failed okay so now you need to give degree to those students who have the batch of 2020 but have not failed so somehow you now need to choose what is here to give the result of your final query how will you do that to know which are these students who had failed you need to select all the items of students from here right so somehow you need to select ids from failed students okay but but the task that is given to you is not to fetch the ideas of failed students the task that is given to you is to tell who are the students who are going to get the degree who are the students who are going to get the degree those are the students who actually have the patch who actually have uh the patch of 2020 in the students table so also you know that you need to do this that hey select id from students where patch is equal to 2020 okay so now you need to select those ids from this student's table where the patch was 2020 but you don't need to select those ids that were present here right so what will you do one very simple way i'm like one thing we will come to that in later section of this video there is also one statement which can do it in one line but let us say you can say that where batch is equal to 2020 and id should not be an id not in and where should the id not be the id should not be in the result of query of this particular thing right so id not in select id from field students right so here we saw that hey we used one select statement inside another select statements right this is also known as a sub query or a nested statement by the way this not in is a keyword in sql where you can select those things that are not present in a in the result of a particular table as well okay but now let us say that you ask me a question that hey how does sql know that these and these are the same thing right i mean like how will it know that i mean there should be a basic thing that whatever data is here should be whatever the data was present and what what was uh electricity from the earlier query right so that is a constraint that sql ask you i mean that is your responsibility to maintain that the data type of the data that is taken from here is equivalent to the data that is here okay so that is what a nested statement is okay now what kind of nested statements can be there can be two kinds of nested statement first can be correlated what is a correlated nested statement means what is a relation with two things means relation between two things means that hey one of those things cannot exist without the other thing right so a code related sub query is a query in which none of the i mean like in which this sub query this is the sub query right sub query is not independent not independent but needs the mean query to execute itself so it can't exist independent of each other so if there is a code related sub query then what can be a different kind of subquery the second kind of sub query can be non-correlated sub query in which the main query for example in this particular query this was the main query and this was a sub query where mean and sub queries are both independent okay what do you guys think was the above sub query was it a correlated or was it non-correlated as we can clearly see that in the above example the select id from failed students can exist without even the main query existing right so it is definitely an independent or a non-correlated sub query okay okay so now we have discussed select but now you also see that we were doing where right we we wanted to do we wanted to check about we wanted to do some kind of assertions that hey i need to know data about those things i need to know the data where a particular where a particular thing is maintained right so let us discuss the common clauses this where is known as applause okay so i mean like what is the clause uh i'm like in normal term in a normal real day life you might have term thought about clauses in your agreements or contexts right those are the things that you need to check those are the things that you need to ensure so there is also a close so let us discuss sequel clauses okay one of the clauses that we have already discussed is real there are uh three other main important clauses those clauses are grouped by having and order by one of the best parts about the sql query language is that hey each of the words each of the words in the language are actually very i mean it's self descripted right because you know i'm like you just see the word and you kind of get an intuition that okay what might this thing be doing what can the weird thing be doing where clause just allows you to filter to filter the records based upon some conditions okay for example what were the conditions what were the conditions in the original query that we had written in the original query that we had written the condition was that id should be equal to 1 let us say let us say that our data had multiple students and those students let us redraw a student table in the students table we again are having id we are having a name and let us say we are having patch okay and let us say that there is an id 1 2 3 8 9 11 12 okay the name is a b c d e f g and patches 20 20 20 21 20 20 and 20 22 okay so now i ask you that hey you only need to give me the students who have the first condition is who are going to pass a 2020 that is who have their bachelor's 2020 and the second thing i also ask you that their ids should be less than 10 okay so then what will your wear close have your where close will have two things what are those things going to be your way of loss will have first will be batch is equal to 2020 and what is the second thing the second thing that your workflows will have id is less than or equal to 10. so this is a simple where clause and aware clause can have multiple things multiple assertions that need to be maintained and those assertions can be grouped with and and if there is and what do we think that other statement might be i'm like just similar to and suppose if like if we have done programming there is and and then there is a or as well right so suppose i had instead of writing and i had written or what would the result of this query be this query will result into all those students who either had a batch of 2020 or had an id less than or equal to 10. so the query will return this the query will fill the query return this or not the query will return this why because the id is less than equal to 10 so this will be written this will be returned because this is also satisfied this is also satisfied this will be returned because id is less than equal to 10 this will be returned this will be returned because batch is 2020 but this won't be returned because neither is batch 2020 or i did this okay great so that is where clause now let us discuss the order by clause before we discuss group by and having because they are interrelated first let us discuss the order by them what do we mean by an order what do we mean by an order order is nothing but an arrangement of things in the way you want them to be arranged right consider order by something similar to sort sorting okay now i ask you that hey please return me the list of all the students okay i just tell you this thing that hey please return the list of all the students you go you fetch all these students and you return it to me but in which order will you return did i ever tell you that no right so there might be a thing that you ask that hey hi in which order should i return it so for example let us take a normal use case suppose there are a lot of things in a restaurant a lot of things in a restaurant menu and those things are grouped by being a starter or being the main course or being a desert okay suppose a starter is represented by a one a main course is represented by a two and a desert is represented by a three okay now one person asks you that hey he has maintained a in a db table in a db table he has maintained one starter one main course and uh one desert okay suppose he has maintained a tv table which is something like what will i eat what to eat okay okay so which is food id it also has food name okay and also it also has food type okay so food id can be something i mean like suppose you are representing breads by something you are representing some kind of pastries by something like that let us say there is a food id which is 201 which can have a name of pastry which lettuce is a desert right so let us name it three then there can be something here selected one and there are multiple things here selected as main code so there can be two things let us say that he has rice and he has some kind of meal or something okay so then there are 100 or 120 and then there is one starter that he selected okay let us say it is xyz and it has 300 okay and this is a starter so this is one in which order will the person like to eat the person will like to eat in the order that he will have like to have i mean like he will have the main wheel in between and then the desert right okay so you need to so you just go to the db table and you say that okay return all the means that the person had selected and what to eat if you return the meals in the order that exists in the table then you will actually disappoint the person like anything right so you need to return those meals in the order of what type of food they are so you should return meal here then you should return main course and then you should return the dessert right so you need to order the means that you bring by food type so how will you do this thing so you will say select food let us say you select the food id where should you select those food ideas from you will select those food ideas from what to eat but to eat okay but in what order will you select those you will select those in order of food type so you will say order by food type okay so then your sql query will return this thing first then one of those two things i'm like it can return any of those two because they have the same food type and then it will return finally the decimal okay so this is the order by clause now let us discuss the other two things having and group by okay what is having and to pay i mean like what is the intuition that you guys get that okay what might having represent okay so let us first think of group by but let us first think of group by group by is a thing that is used by aggregate functions okay i should talk about group here look by is a statement is a clause that is mostly associated with aggregate functions okay so what does this mean aggregate function means that okay those functions who reso who actually a computer upon a large amount of data and then return a result so there can be two kind of functions right one kind of function computes upon a single argument and then returns a value so those are known as scalar functions which will come to in depth again and then there is an aggregate function okay suppose aggregate function the examples of aggregate functions can be sum can be average and those okay so let us discuss about a simple thing so let us say that you are using a having clause so you want to know that you have to return those students uh i mean like who lived in india and the student id was greater than five okay so you need to return count of those so what you will write so you can say that select count of student id comma country so i mean like let us say that we had a db table in a db table with every student with every student i was also maintaining his country let us say in this student table i had a country country of first person was india then this was usa this might also be usa this can be uk this can be india and this can be india and this can be india okay so you need to know that which are the people who have a country of india so that is the very first thing to know that okay so let us say that we need to know who are the students who don't have country india let's say we do the reverse we need to know who are the students that don't have country as india okay then you get the students which which will be the students that you will get who don't have country as india you will get this you will get this you will get this that's it okay but now you need to order them in some way someone tells you that hey once you have filtered those students who don't have country india please group all the students that had a country together right so group all the students who at country usa together then group all the students who are countries uk together and so on okay so how will you do that you will say that select count of student id comma country from students okay where what should be the thing the thing should be that country is not equal to i n because i n is representing india okay chicken now you get all the students now you need to group them by countries right you need to group the countries that had usa together okay so group by group by country okay so so all the students that have the same country are now together that's it suppose you return this what will this return now what a group represents a group basically creates a single group of people who had the same value here okay so let us specify this particular query one by one okay in this statement the very first thing is select from students where country is not equal to india this thing will give you two three and eight so you get these three things okay then the next thing that you do you are grouping them by country so then you get two groups right there are two students that had usa and one student that had uk so now you will get two groups which are 2b and usa and 3 c and usa and the final one was 8 d and uk okay so these two students were in the very first group and this student was in the third group okay now you have grouped them by country now what do you need to return you also need to return the count of student id basically how many different student ids were there where in each groups so because count is a count is a aggregate function it works upon a different thing it works upon a set of inputs and returns the number of inputs that are there so what will be here it will be two but will be here it will be one so what will it return it will return to usa and one student from uk so writing this query helps you to find the number of students from each country where the country is not india okay i hope that is clear now let us discuss having now let us discuss having suppose i have written this query okay and then i tell you that please please return only those countries please return only those countries where the number of students were greater than one okay so you need to return only usa and not uk okay so having allows you to do filter on aggregate queries filter on aggregate functions so you can say that we are having the count of student id so you can here write having count of student id account of student id or let us say id which is greater than one so if you write this thing you are only going to get usa so the difference between where where is just a filter upon a normal attribute value whereas having is a filter upon an aggregate function the value returned by an aggregate function and so the question is why we use having instead of where clause in group by clause so having actually used two because c once you have done group by in function then you are need then you need to do some kind of query about this these groups right so consider this as different that you have done a grouping here you have done a grouping and then out of those groups you are selecting particular groups that had something is this okay so that is why you need to do a having okay great now we had actually when i was discussing this particular thing that he let us say that we had to select the students who we were giving degree to okay then i tell you that hey we also don't need to select the students who actually fail i told you that here we will run one query and then we will run a sub query and the basically whatever the value was not in the second sub query we will put in the not in clause and then give right this thing can be done in one query in sequence so let us discuss three functions which are union minus and intercept okay by the way i'm like uh if you have studied sec theory if you have studied set theory these clauses seem very similar to what we discussed in set theory right is there any kind of relation between set theory and why these terms are like that yes there is the reason for that is because the relation rdbms system when they were actually originally the paper of rdms actually is representing all these things with notations of set theory so an rdbms is nothing but a implementation of set theory that okay how you will be doing operations upon data in terms of how you do operations upon set okay so each table is actually a set and not a order table so that is why there is no guarantee as to how the data will be arranged in the table it might happen that this data is somewhere here or this data is somewhere here because these are sets and not tables okay now let us discuss union minus and intersect what is union in a set what is union in a set in a set let us say that we have two sets a and b in one set we have three things one two three we have four things here four two one and five what is union of a and b by the way union in set function is represented by u sign so what is au b this is nothing but one two three four and five basically union is the combination of all the values that is present in any of those two sets right if you also notice here that hey one was present here as well but one was present here as well right but in a union b we got one only once so a union removes duplicates returns duplicate only once but what if you want to return if one is present here and here as well you need to return it twice what if you want to return 1 1 2 2 3 4 and 5. for this thing there is a union all in sql okay union all keeps all the duplicates okay so what the union statement basically does is union statements returns all the values that are present in any of the sets present in any of the sets okay now what is minus so i tell you that hey i have some things here i have some things in this particular system which is let us say a b c d and e these are some things here i tell you that you need to return you need to return everything that is here everything that is here but it should not be here okay so what will you return i mean like suppose let us say that you have five things and two things you need to return every of those five but those two but not those two so you do five minus two right in math you do a 5 minus 2 similarly in sets you can do a set a minus set suppose this is represented by set a this is represented by set b if you do set a minus set b you will get all those queries that are here i mean they should be here but they should not be here suppose there was an f here as well so what are the queries that are here these are a b c d and e okay and what is the second thing the second thing is this should not be here so out of these things what are the things that are here so they are b so b will be removed what that is a so a will be removed this is f but f is not here so we are fine and the final return from here will be c d now do you guys think that we could have actually directly used this minus statement in the previous question what would we have done instead of writing we are not in we could have just done minus here right so if we were doing here we could have just done minus here and we would be fine correct great so that is a minus query and then what is intersect intersect is also a set function and intersect between a set a and a set b is represented by an inverted u sign and it says it returns values present in both set a and set b so let us say that set a had the values 1 2 3 4 5 and 6 and set b had the values 2 comma 4 comma 6 comma 8. now if you do a intersection it will return those values that are present in both of those sets right so it will return something that are present here as well as here so those are things like 2 4 and 6 right great now let us actually i mean like now we understand that okay what are these commands doing but how will we actually write them in sql how will we write how will we use them in a sql query in these sql queries these statements are between two select statements so how will it be represented so one way can be that hey select name from students minus select name from failed students what will this query do this query will return all those students the names of all those students that are students but are not failed students now i tell you that you need to return everyone who is a member of my university so suppose my university can have students and he can have employees okay and it can also have other things but let us say that for now these are the only two things and you need to return everyone who is member of the university community so now you need to represent a union of those two things right either that person can be a student or that person can be an employee so what will you do you will do select name from students union select name from employees okay now there can be one thing that hey i need to select those students i need to select those students who are actually let us say living in a particular city who are living in delhi okay let us say how will we do that so we will say select name from students okay those are all the students right and then i have a different table let us say my database was arranged like this that i had a students table and i also had a delhi students table okay so i need to select all those students that are first of all students and the second thing that yeah they are also delhi students right so i will do an intersect i will intersect with select name from delhi students so this will return me all the the list of people who are present in this set as well as this set okay as i discussed earlier these terms are actually related to set theory and an rdbms is more of like sets and not of more like arrays okay or what is your table okay so these are sets this is set one this is set to and this is a set operation of intersect okay so there is a query that is it minus or except this is a minus okay uh this depends upon different database management systems as well okay i mean like depending upon different dbms system which are implementing these concepts might be known by default names but mostly these are known by the common terminology of union union all intersect and minus okay great now let us discuss one of the most important topics that are there in database management systems that is joints what is a join basically now as we discussed earlier that he data doesn't doesn't appear in cellos right some of the data might be here also some information about that student might be in some other table similarly and so on right let us say that we are maintaining data about an organization okay let us say that we are maintaining data about an organization so in the organization table in the organization data set we have first thing we have employee table and the second thing that we have is let us say employee salary stable okay okay so now the thing is that i need to know the salary of a particular employee okay i need to know the salaries of particular employee or i need to return to you someone comes to you that hey please return me let us say that this employee uh table is storing id he's showing the first name he is storing the last name and let us say that he is like uh i'm like he's storing the rule so these are the four informations that are maintained in an employee table and let us say the employee salaries is nothing but an id and there is a salary okay now someone comes to you that hey please give me please give me the list of all the employees along with their salaries so now what you need to do is you need to return some data from here along with some data from here right so you need to return a group of things so suppose there was an id one the first name was a the second name was b his role was let us say uh i'm like he is a ceo and then the salary of id one is let us say ten thousand some units okay then there is an id two first name is a two people can have the same first name right the last name can be c and then say his role is a vp the salary of vp is something like let us say 8 000 and so on and what you need to return you need to return 1 a b c u and ten thousand two a c v p and eight thousand so now you see that hey to return my answer i need to actually fetch two tables i need to fetch data from two tables okay but how will you how will you ensure that this data this data corresponds to this data and this particular row this particular record corresponds to this particular report how did you come to know that you came to know that based upon the id here and id here you joined or basically you selected those like you combined by the id where this id matched you combine those right this is the use of joints it allows you to fetch data from two different sources from two different tables based upon something that matches okay so now how is this happening let us discuss different type of joints when this will become clear so the very first join and the most important join is the inner join inner join allows you to basically join based upon a particular column and the data should be present in both of those things so suppose suppose there was a id 3 and he had a salary of 6000 but you don't see any employee with id 3 here so what is the what is even the use of returning this data right so i mean like if still the same person asked you to return all the employees along with their salaries you only need to return this correct because you don't know if this three person is here and let us say that there was an id5 and his first name was b his last name was e and he was also a vp but you don't have his salary information so you don't have his salary information there is no seller information available here so you only need to return those data whose information is available here as well as here right so this is the concept of an inner join okay so let us discuss that how this inner join is going to work so this is going to i'm like the normal function how do you write is that select star from first table by the way what is this select star doing this select star does nothing but returns all columns of the table all columns okay not the rows chicken so we select star from table a and then when we have selected everything so basically i have selected everything from this table then i also need to select everything from the employee sellers table right so then i will also select star from table b okay but i need to join them i need to join this with the second thing right how will i join this i will see that he id here matches the id here right so what i can do is rather than doing this so i say select star from table a i select everything from the first table and i join and i join with what i join with table p that's it this is equivalent to select star from table a inner join table b so riding inner join is normally in most of the db dbms is not mandatory okay so when you have done this you get the result of this based upon these two tables why how it automatically selects that what should i group by it sees that hey there was an id column here there was an id column here as well as there was an id column here because both of those columns had the same name so it makes sense to i'm like it makes sense to choose that as the common name and then group by that okay and then join by that so that is the inner join that is the most common join that is used the second type of join is left join this is a left outer join but let us call it left what it says is select everything from left side select everything from left side and if corresponding values are not there on the right side fill those values with null let us take the above case so suppose instead of doing an inner join instead of doing an inner join where the value was present in the left side as well as in the right side i was doing the left join up on this table so what would i be returning so i will definitely be returning everything which was from the left side so i will be returning 1 i will be returning 2 i will be returning 5 but there is no corresponding data for row 5 on the right side so for those particular things for all those values of this thing i will put null and null in the salary so what will i be returning i will be returning 1 who has a first name of a b ceo and his salaries of let us say 10 000 i will be returning 2 a c v p where the salary of 8 000 i will also be returning this because this is the left join so i will be returning 5 d e v p but i don't have any information about this so i will replace this by null so this is the left turn as there is a left join so obviously the opposite also has to be true so the opposite is right join what this right join means this right join means select everything from the right side now you have to do the first selection on everything that is on the right side now if the corresponding data if the corresponding data of the similar column is not available on the left side fill the left side with null okay fill the left side with that if corresponding data is not available on the left side fill the left side with that so what will it return it will return one it will return two it will return three for one and two there is the data on the left side but not for three so what i will be returning will be one two and three are the ids for one i know the first name i know the last name i know the uh rule so this is ceo and i also know his salary okay for two for two i also know everything so i know that his name is a uh his surname is c it is a vp and it is 8 000 but there is a person 3 whose first name and last name i don't know so what will i return i will return 0 sorry i will return null null null and 6 000. this is a route right join okay so we have done left join we have done right showing but can be other thing the other thing can be if there is select everything from the left side select everything from the right side if left side has corresponding data in right side obviously to the joint but if there is no data on the right side fill with null similarly if there is something on the right side which doesn't have a corresponding data on the left side fill that with null so it's a combination of left join plus right join and what will it return it will return uh or and i'm like it's known as the full join as well full join select everything join if a match else fill left side or right side by null depending upon the situation so let us see what will be the full join output for this particular table i will be returning everything from the left side right so i will be returning 1 i will be returning 2 i will be returning 5 so it will definitely be returning at least these three things ok but i will also be returning 3 so i will also be returning 3 because it is present on the right side but it is not present on the left side so i will also be representing this thing so if you see this is the output of left this is the output of right what is the output of a full join output of a full join is nothing but union of left and right right so basically what will be the output of a full joint it will be one a b ceo who has the sld of 10 000 and there is 2 a c vp was a celebrity of 8 000 then there will also be five whose name is d e then he's a vp but i don't know his salary but i am also doing the right join so i will also be returning this so it will be three null null null and i know his salary six of them so this will be the output of a full join now there is one more thing that i mean like uh that is also there that is a cross join so let us say that we have two sets basically each select query is nothing but a set right so we have a set a and we have a set b uh and there are multiple values here let us say they are a these are different rows right so these are a b c b these are let us say f g and h okay if we have two things if we have two different sets and you have to make a cartesian product cartesian product or a cross product cartesian or cross product okay what this means is that hey combine all the values from the left side with all the values of right side so basically what will that be the final output there will be this one row this one wrote these so there are three rows similarly there are three rows from here there are three rows from here and similarly zero so the final d if there are four values in the left side and three values in the right side how many values will be there in the final set of the cross join if it is a cross join and one side has four values and the right side has c values the final values will be nothing but four multiplied by three why because each row on the left side is going to produce three rows because it is going to be combined with every value on the right side and does produce three rows each of those so we will be getting 4 into 3 which is 12 as the final table okay ah so there's a question that what if there are more than two tables if there are more than two tables you can use just parenthesis to say in which order do you need to find the outcome okay and all these functions are actually commutative i mean like union and intersection functions are commutative so any of those order works suppose you have to do intersection of three sets okay so then you can do select star from a then you can do union select star from let us say b now whatever all these values we got from here then we need to do intersect select star from c so we can put this in parenthesis so that this is executed first then an intersection with this thing will be executed and there will be an outer parenthesis as well so we can group those statements together as you contact okay great now we have been discussing a lot a lot different kind of i mean like uh joins but what are we actually working on we are actually working upon the data we are actually working upon getting the data suppose you have the data what is your main idea like you want to get that data as fast as you want to right i mean like you you want that hey please get me the data as soon as you can okay so you need to ensure that my queries queries should run fast how will you make the queries run fast uh i think you everyone must have heard about erase right everyone must have heard about arrays and you guys would have also heard about hash maps what is the difference between searching a value in an array and searching and searching a value in a hashmap searching in an array is a linear time operation where searching i mean like if the array is not sorted but and searching in a hash map is probabilistic order of one right okay so what we observed from here was that hey in a hash map we use some kind of a different space or some other optimization or some other conversions to improve our search time complexity right yeah so if we want to optimize if we want to speed up our queries we can probably use some other memory if we can use some memory to speed up our queries okay using some memories some memory to speed up queries is known as indexing okay now let us say that you know that hey a lot of times a lot of times i need i need to find i need to find all those students who had a score who had total score greater than 80 who had total score greater than 80. so suppose you have a table uh suppose you have a student table in which there is an id there is a name and there is a total score again recall that hey sql is not a array sql is a set okay and there is no order in a set a set can be returned in any random order so suppose there is an id student here who has a name a and whose score is 60 then there can be 2 whose name is b whose score is 10 and there is a 3 whose score is 90 and it is his name is c then there is four whose also name is e it can happen that two people have the same name then it's also 80 then there is five whose name is l let us say and uh his score is five okay now always there are a lot of queries that come that okay each query you have is that hey find all the users find all the users or find total number of users who had some or who had score greater than equal to x if it was an array i mean like if suppose this was the final data set that you had if this was the final data set that you had and you knew that you are getting a lot of function calls just finding score greater than equal to x would you like this data to be arranged in some kind of order would you like this data to be arranged in some kind of order you would like that hey this data if this data is sorted by the total score right if this data is sorted by total score then you can answer each of these queries using binary search in order of login right so you need to do some kind of post processing okay and also you need to know what are the common operations that your database has so what are the common queries that your database has so this is known as a database indexing what is an index first of all an index is nothing but a data structure to study which is a data structure that actually does that is not the scope of today's lecture but if you want to study that you can you should definitely see about that b3 and b plus trees uh what are these so this is how indexes are actually uh i mean like most of the times implemented so an index is nothing but a data structure that provides quick lookup okay because you need to arrange the data i mean like hash table is also nothing but a data set right so quick lookup based upon a query based upon queries in a column or a set of columns what do i mean by set of columns five set of columns okay sometimes it can happen that hey suppose a lot of times that you have queries that that are actually not just based upon a particular column but are based upon a conjunction of multiple columns right that all these students who have a name beginning with let us say b name beginning with b and who had a score of less than equal to 80 okay so then you probably need an index upon two columns which can be named and the second thing can be total score so how to choose which will be the columns that you will index upon that that depends upon what your application is showing what data is your application assessing a lot of times if you see that a particular data is being assessed a lot of times it makes total sense to add an index over those particular columns how will you create an index by the way to create an index in sql you run this so you run a statement like this create so by the way i'm like if you ever have to create something in sql you use the create statement if you have to create a table you use this you have to create a database you use this and this time you have to create an index so you do create index you can also name the index okay i mean you can call the name of index something that you want to do so let us say that i call this index name score so i create an index whose name is name score then i also specif i also need to specify what are the columns that i am creating that index upon so i am creating that index upon columns that are name and total score but these columns can be present on a large number of tables right these columns can be present in a lot of tables how to decide that which is the table i'm talking about so i also need to mention the table so i will say on students name and total score so if i run this particular query it will create an index upon these two things what is the disadvantage of an index though the disadvantage of an index is that he it needs extra space but that is fine and extra space is not a big issue but it can slow down rights so let us let us say that okay you i'm like let us say we don't know about b trees or b plus trees but you had to actually you had to actually implement an index yourself okay if you had to implement an index yourself on this particular thing you can say that okay i will always maintain this table in sorted order of table score and then if insertions happen on this particular table what will be the time taken to insert it will be linear right so i'm like because you always need to ensure that the table is sorted so then you can't do it in i'm like in order of one or in constant time so indexes can slow down rights because they need to process the new data that it achieved okay that is an issue with indexes but otherwise they are actually always beneficial okay now what kind of indexes can be there the indexes can be of two types i mean there can there are two ways in which you can classify indexes the very first way in which we can classify indexes is unique and non-unique index what is unique index is unique index basically maintains unique index basically meant allows you to maintain that if a particular data is there is if there is a duplicate in a particular column or in a particular set of columns of the data suppose you have a data in which you want to always ensure in which you always want to ensure that no two people no two students have the same name no two students have the same name how can you do that to do this thing you can create a unique index on name column of students right so what will happen is that at any rate whenever a write happens whenever a write happens it will check the index if if a constraint that was set in any of the index is being broken or not okay if we had not indexed this thing checking this would have been a higher would have been a more complex operation or a more uh computationally expensive operation but as we have maintained an index over that particular column it immediately allows me to check that if that constraint of uniqueness is being meant is being broken or not okay so unique indexes are are there to to ensure some constraints in there then what is the definition i'm like why is there a need of non-unique indexes non-unique indexes exist to speed up the query so while unique indexes the main purpose of unique index index is to maintain the constraints or data integrity right they need to ensure that the data integrity is maintained but the function of non-unique indexes is only to speed up the queries okay and that is the biggest advantage that non-unique indexes have okay now there is also one another way in which we can classify the indexes this way is known as clustered and known clustered indexes okay the very first thing that i told you was that hey database a relational database is not a table but it's a set okay so that means there is no definite order in which the data would actually be stored in memory right it could it could be stored in any way okay now if i tell you that my query my query is always to select people in order of the roll numbers if i say that i have a student table again okay i have their role number and let us say that i have their name and i tell you that my queries are always going to be selecting students in the order of their role numbers but as the databases are set so the role numbers can be arranged in any order so 3 can be here 2 can be here 4 can be here and like this name is a name is b name is d let us say name is c okay so data can be arranged in this order but i tell you my queries fetch students always in order of role numbers now what would you like to have i'm like will there be something that makes immediate sense that hey if my queries are always fetching data in the order of roll numbers should i arrange my data in the order of row numbers if i have arranged my data in the memory in or in the in the order of roll numbers it will speed up my queries right because then i need to just iterate over the data and i'm done okay so what clustered indexes allow you clustered indexes they change the way data is stored in the database as per the index so if i create if i create a clustered index based upon roll number what will it basically do inside the memory inside the storage where the data is actually stored this will change to one two three four and one has c two has p three has a and four has d so now if my queries are always in the order of roll numbers they will become very fast okay so that is what clustered indexes are but what are non-clustered indexes non-clustered indexes maintain a separate data structure to optimize queries let us just see only this definition of clustered indexes if clustered indexes change the way in which data is stored in the memory can i have more than one clustered index no right because if i have more than one clustered index then i need to store the data inside the memory as per the conditions of two indexes which is not possible right because there can be only one way in which i can depict i can dictate the order the data has to be stored in the storage right okay so one issue with the or basically one uh thing with the clustered indexes is the very first thing is that there can be only one clustered index one clustered index while there can be multiple non-clustered indexes okay the second difference between clustered and non-clustered index can be that here the clustered index changes the order clustered index affects how data is stored in memory y non-clustered indexes don't okay okay okay let us say that we have these two things if we have a clustered index upon a particular column and also if we have a non-custom index upon a particular column which of those do you think will be faster if we have a clustered index basically because clustered index is actually directly affecting the data set right and it is storing the data in the way you are assessing also you have a non-cluster data set which of those do you think will be speeding of the queries more obviously the clustered index will have even faster queries right clustered indexes have faster performance with respect to non-trusted okay because in a known clustered index you actually first talk with a different data structure and then that data structure depicts that okay now fetch this data and now fetch this data whereas in a clustered index the data itself is stored in that manner and thus it helps you to speed up those queries okay great now let us actually talk about something called as views what are views what a view is let us say that i need to have one source of truth okay so i say that there is always one source of truth and a lot of times i'm storing data about students again let us say and i am also storing their gender i have students i have suppose i have their id i have their name i have their patch and i have their gender okay okay so let us just write few uh things okay 2020 gender can be male 2 which can be this is 20 20 gender can be female and three can be in let us say c this patch is 2018 who can be let us say again female and four can be d 2019 can be of me okay okay so this is the data that we have okay now what i tell you that there is one person there is one person in my university who ensures that uh who i am like whose job is to ensure to do data analysis upon the data of females okay suppose her job is that okay let me actually uh analyze the data of females do some operations with it try to find out some information from it okay how can i ensure that the purpose that the repeated task of that particular employee in my company whose task is only to just do multiple queries upon the data of females okay so this is students then one way can be that i create another female students table so one can be that i create another female students table and that female students table will be like this name patch gender and then there will be 2 p 20 20 female then there can be 3 c 20 18 and female that is one way in which you can do that do you guys realize that there is some issue with this there is some issue in which the data is being arranged here the issue with that is now if a new student gets added suppose there is a new student that gets added whose id is let us say 5 name is e batch is let's say 2019 and she is also a female now we don't just need to put the data here but we also need to put this data here okay and if by mistake if by mistake you forget to put this particular data at this side then the employee who's the employee whose job was to ensure the data i mean like to do some uh operations or analysis over the female data will go wrong okay so what would you ideally like to have you would ideally like to give the employee who is working on the female data a view a subset view over the student's data right that hey he can see what is the data of students but only that subset of the data of students where the gender was given right that makes sense how can we do that we can do that by creating a view so our view is nothing but a select statement is nothing but a select statement that that that gives an intuition of a different table an intuition of a different table while actually while in reality data is present only at one location let us see how this works like suppose we have this data only uh then what will a view do a view will actually let us say that this is it kind of like is a camera over that thing that okay it allows you to see this thing but with a filter it allows you to see this thing but with a filter so here this view is let us say that the female students is no longer a table but female students is a view this view behind the scene is just running a select query which is just selecting those students from the students table that have gender respect but the person but the employee whose task was to work upon female students can now use it as she would have instead used a female students table that is what a view does so view basic and now what would happen now if you ever do a right here now if you add a new thing you just need to add it here as soon as you add it here this view will automatically get updated because there is only one single source of truth okay awesome now let us discuss some of the op i mean like how can we do the weir clause okay i mean like we have a weird clause right that we have discussed one way in which we have used the where clause till now is using equal to's right using directly checking for equality or checking for less than equal to and all those things let us discuss something called as wild card patterns and other things that you can use in the virtues okay so where clause let us say pattern matching okay so in where cross pattern actually let us discuss different kind of things that can happen the very first thing is while record patterns suppose suppose your complaint comes to you a complaint comes to you about a person and the and the person who actually did the complaint didn't know the exact name of the person who did the crime okay and then what he tells you that i just know one thing that hey his name starts with k h that's the only thing that you know now you can't just do a db query you can you can't just do a sql query where name is equal to kx something like that right so you would like the name i mean like so you want to do a sql query where name starts with kh okay how can you write such query in sequence in sql you can have pattern like k percentage what k h percentage means if this means t h and followed by any sequence of vectors this can represent k h this can also represents k h e this can also represents k h a y and similarly right great so this is what a percentage or a wildcard pattern is so how will you use this file card pattern suppose the task that is given to you is find all students whose name begins with kh okay suppose this is what the data that is the question that is given to you and the data set is something like this this is the student table and in this student table you have an id you have the name and you have let us say um batch that's your suffice so there is a student with id one whose name is kikati and the batch is 2016 then there is student name number two whose name is let us say aman and whose batch is also 27 let's say 2017 then there is student 2 who is kayal let us say that might also happen then his batch is 2016. you need to find all the students and let us say that there is also one more who is name is kamal now what will this query do what will so we need to find all those students whose name starts with kh right whose name starts with kh so that means we need to return this we need to return this and that's it okay we don't need to return this because this starts with ka so what sql provides you the sequel provides you first the wildcard pattern and the second thing is a like statement is a like even so you can write thing like that hey select star from students where name see the in when we actually know the exact name we use the equal to sign right but now we don't know the exact name so instead of equal to sign we have to use like where name like and then i will say k h percentage i hope that is clear okay now rather than finding all the students whose name is kh i tell you that hey the question is changed but i need to find all those students in between their names suppose a and ama is coming suppose i need to find all the students that have a m a in their name anywhere in their name i mean like it might not be the starting characters it might not be the nd characters but can be a real world use case suppose uh suppose what do we say that okay uh i'm like an examination is going on and the in which letter finds a chit and then we click and then which later finds that  on that the name of the person was written it was ama now the english later wants to know who might be the students who might be the students who would have done whose chit that might be okay so now you need to find all those students that had ama in their name how can we do that to find all the students that had ama anywhere in the name we can write percentage ama percentage so what this percentage symbol is representing basically if we see from this particular thing and from this particular thing is any sequence of zero or more characters okay so this percentage ama will match amon this will also match number but this won't match a myth okay so what can we do we can just write a statement select start from students where uh here we wrote their name like this so here we can write where name like percentage ema now we had also discussed a thing like we are also discussing like in the very beginning of this video that if we want to remove a subset of the queries from my statement right so i had used a not keyword right i had used a not keyword what this not keyword allows you to do this not keyword allows you to omit or make those results present in something else present in something else so let us say that my just query just changed i somehow know that okay the person who had did this i mean uh the person who did this thing who's his name just doesn't have ama that's the only thing that i know okay then what can i am like how can i find all those students that had i how can i find all those students that didn't have ama in their name i have to find all those students that didn't have ama in their name i can just use this not keyword i can say select star from students fair name first we were doing their name live now we don't want the name to be like some things right so we can say we are named not like percentage a m a percentage so if we run this query uh if we run this query this will return amit but this won't return a month okay now we have discussed three things we have discussed percentage at multiple places we have also discussed not there is also a specific sign okay a wild card for a specific position that is nothing but the underscore sign okay what it says suppose i want you to find i want you to find all those people all those students the third character in whose name was let us say m okay so if i also want if i only want you to find all those students the third character whose name was m but anything else can be anything else okay so i want to i want to return naman and i want to say let us say that there is something called lamboth i need to return this as well i need to return this as well but i don't need to return amit okay suppose this is what i want to return okay so how can i do that i know that the first two characters can be anything the first two characters can be anything then there should be an m then there can be any number of remaining characters okay if i write percentage m percentage will this work no this won't work why will this not work because this will also return a myth because amit also satisfies percentage m and all this as percentage so what can i do i can say that the first two characters should be underscore so underscore matches any character any single character okay so first two characters should be underscore then there should be an m then there should be percentage what this means is that the first two characters so that numeric value that there should be a percentage then there should be an m that should be a percentage that is fixed so i can find all those students who had the third character as m by something like select star from students where name like slash underscore underscore m percentage okay now let us say let us get let us take talk of another question let us talk of a question where i had to return i had to return all those students all those students whose name had more than four characters i had to return all those students whose name had more than four characters how can you do that if the name has to have more than four characters we know that the first three characters can be anything the first four characters can be anything so we can just write that by underscore underscore underscore underscore that means the first four characters can be anything then it can be percentage i mean there can be any number of characters after this so a query to select all those students who had name greater than four characters can be something like select star from students where name like underscore underscore underscore underscore and percentage okay so that was in wild card pattern searching of strings in our database let us also talk about let us also talk about what kind of database i mean like what kind of operations can actually have can happen on a database because if you if you are using a database management system you need to know what are your requirements right what kind of data that you want to have okay or what kind of operations happen or what kind of requirements are there from the data set so that you can choose a database system that actually conforms to those requirements so there can be two kinds of database management systems that are commonly known the first type of database management systems are oltp and the second thing is olab so how to distinguish between these two you can distinguish between these two types of data sets using the word t and a okay what is t means t means transactional what is a means a means analytics let us try to understand the difference between oltp and olep so as you see from the name that oltp database is more for transactional things okay what do we mean by transactional things transactional thing is a large number of queries but each query is very small okay i mean like let us say let us say that very simple thing let us say that i just need to select all those i mean like i just need to increment the value of something by one or let us say that i just need to i still have the students table and i have their marks as well let us say so i have students tables i have their marks uh let us say the student table has something like this id common name comma marks okay so there is id 1 a initially his marks are 20 then 2 b 30 something like this okay so now my queries are things like hey my query something i like that he insert a value or update a value things like that these are very small operations but these these operations are happening a lot of times in those scenarios you need a transactional database management system so what their transaction management uh transactional database management system will be do uh will need to do it should have actually a very fast response time you will be very sad if just to create a like if just to submit a lie it takes a lot of time for the facebook's database system to actually store that like in the db and return you that okay you have liked that post okay okay let me actually just tell the full form of these things ol stands for online and p stands for processing so online transaction processing and online analytical processing okay so these are this this is the difference between oltp and olap okay so in an oltp database i need fast response time okay so my cpu requirements are not that much but i need to have need to be able to serve a lot of requests in very fast okay so normally oltp databases are actually distributed okay because you need to serve a lot of requests so a lot of pilot requests which are normally short so you should distribute your load whenever you actually have to have a lot of small queries the best way is that you distribute those things and have multiple different computers handle it rather than having a vertical scaling approach okay whereas consider you are a company consider you have a database of a lot of users being stored since long okay and then every two months or every one month at the end meeting you do a very big processing over those database you try to find all those users who had posted more than x messages or you find all those students who had actually attended more than five classes and then who had actually also solved more than call more than x contest and solve those okay so in online analytical processing these databases are useful for business analytics and intelligence smaller number of queries happen but each query is quite complex can be quite complex we will say okay because i mean one query might be just fetch you might be fetching from a lot of tables and doing a join between them and trying to find a lot of other things also in olap database management systems other things that are actually i mean like if you're doing a business intelligence visualization becomes very important right so visualization etc are common features okay so in this thing being distributed is one important aspect but in this thing having a large support for visualizations and other thing is a very is a more important task okay now let us actually talk about a very important thing in database design i'm like how will you even create a i mean like how did we decide that what tables do we need to create or what do we need to store in what table how did we decide that let us discuss this actually this is a very uh i mean like uh important topic as in in terms of database management systems in terms of understanding database management systems this is normalization normalization allows you to have good database design good database design in terms of what in terms of in terms of how we are arranging entities and relationships between them okay so normalization also allows you to reduce data redundancy okay let us say i had the student table okay in the student table now i'm also storing the address of everyone i'm also storing the address of everyone okay so let us say that student has id he has a name he has a city where he lives he has a pin code and these are the things that i need to store okay so let's say that this is the database so let us say that we have id one his name is a he lives in delhi and his pin code does not live in delhi because delhi has multiple pin codes let us say he lives in a city xyz that has only one pin code and let us say that the pin code is double one triple zero one then let us say that there is a student two whose name is b who it is he lives in city abc and the pin code is one double three double zero one then there's a student three who also lives in city i'm like whose name is c who also lives in city xyz and the name is double one triple zero one okay suppose after few days after a few days government decides that okay i will be changing we will be changing the pin code of the city xyz what can happen what can be an issue in my this database design in my this database schema design the issue can happen is that he suppose government says that the city with xyz will now have a pin code of one two seven two zero one suppose this is the pin code that the new pin code of xyz has to be now if this happens what you will have to do is you will have to go on this student table everywhere where one one zero zero zero one is there you have to change one to seven two zero one you have to change one to seven two zero one and all those things which is a very bad design right what can also happen is what can also happen is that suppose there was also another student c let us say g here lived in city xyz and head up in code of one one zero zero one but you somehow forgot to change this you somehow forgot to change this and that's a bad thing for you now your data at some places is storing the pin code one two seven two zero one for uh the city xyz but at some places it is showing double one triple zero one that means the data is not consistent what do we mean by that we mean irregularities in the same in the information so what would you ideally like this what would you ideally like to have you would ideally like to have is that hey all these cities i mean like the city and pin code because a city can be a city can be recognized just by the pin code right so i would ideally like to have is that somewhere i am maintaining the pin code and the city name if i am somewhere maintaining the pin code and the city name i will be i can ensure that these hidden these consistency issues are reduced to minimum right so what will be very good for me is that let me have a id name and pin code here or let us say instead of having one table storing this i can have a student table that only stores id that stores name and that's your city id right and i have another table which is city table that is storing city id city name and pin code now we have one a and let us say one here let also we have three c and one we have four d and one now we have two b and two let us say so we can say that the city id one has name x y z and has a pin code of double one triple zero one city id two has name abc and one double three double zero one so now if government decides to make the change you only need to make one change that is here and this thing will automatically conform to new changes that happened here right so this is the advantage that you get by making your designs of databases very good okay so these are known as normalized databases but how will you decide that there is a need to improve the database design let us discuss normal forms for that there are six normal forms actually but uh greater than three normal forms are not actually practically not actually used much so we will be discussing here 1nf 2nf because those are more prominent let us discuss what one nfcs a 1nf data a data a table or a database schema design is known to be satisfying one nf if there are no multi-valued attributes what do we mean by no multivalued attributes suppose you know you have a library management system and in other library management systems you store which books which books have been allocated to a particular student so you need to you have a table let us say a location table in which you have a student id and you have a books a list of books okay so suppose there is a student whose id is one and he had bought and he had linked rented let us say five books so those books had id101 1 2 0 1 3 1 20 and let us say 121 and let us say 180 okay so there can be a student 2 who has lent 3 books let us say 11 113 and 21 so on this database schema design in which any of the table can have more than one rows is i mean like in which any of the column can have multi-valued attributes because this attribute has multiple values this is not just a single value this is not just an atomic value so this does not satisfy one and f so how will we convert this data into one nf form how will we convert this data into one nfl we can construct we can change this data into one nf form by splitting this data by spreading this data like this student id and books and say 1 here's 1 0 1 1 1 2 0 1 1 3 1 1 2 1 and 1 180 similarly 2 has 11 2 has 1 1 3 and 2 has 21 okay this data this satisfies one and if this does not satisfy one nf okay so that is how you convert a data set that is not satisfying one and f into a dataset uh into a schematic and that satisfies one normal form let us discuss about second normal formats well two nf data i mean like the exact theoretical definition of this is that hey there should not be any column there should not be any column or a set of columns that can be uniquely identified that can be uniquely identified by anything other than by anything other than the primary key or the candidate keys i'm like what are the primary keys and what are the candidate keys we will discuss in a moment but let us talk here let us take care of this thing let us see let us see the example that we had here let us see the example we had here what was the primary key of this uh this step let us firstly define primary key as a row as a column value that has to be unique that has to be unique for any for any record in the in the table so for example if we see the id has to be unique i'm like no two students can have the same id that is the main source of distinguishing between any two datas any two records okay so what it says is that let us see this pin code and this city thing do we think here that pin code pin code actually doesn't need this id to be uniquely identified pin code can be uniquely identified if we just know the city but city is not the primary key right i'm like pin code can be identified by the cd but cd is not the primary that means there is a subset there is a subset of columns in my schema design that can be uniquely identified without even the primary key without even the primary key which is id so how can i convert this data set into how can you convert this data set into second normal form is what we just did here this but the conversion that we had done here was nothing but the conversion of a data set that is that does not comply with second normal form into a data set that complies with the second normal form let us actually let us actually uh take one more example let us actually take one more example in which we can do that okay suppose let us say that uh this is something actually present on also on the interview practice uh i'm like forum of this so what it says is that hey let us say we have a student's table we know the student id we know their name and we also know if he's a mister or visa mrs okay then we say that okay let us say that we have students we have id we have name we have gender and we say that what do what what is the salutation that we use for them okay so let us say that salutation can only be mr mess or let us say it can be doctor okay these are the three salutations that are allowed okay can we somehow know know these three things by some other thing i mean like let us say let us say that currently i am maintaining students like this one whose name is a whose gender is let us say for now we have only mr and miss okay we name it a and gender is a we have student b whose gender is female who have sent three christian is a whose name is b this salutation will always be mr this will be mr and this will be miss right but actually what we realize here is that he if they just know the gender we actually know the salutation so what happens what happens if i suddenly decide that or or i will call all the males not mr but suppose master i might call i might decide that then i would have to iterate over the students table i will have to iterate over the students table and update this and update this which is and that can lead to consistency issues so this is where i mean if these are the two columns if these are the two columns that can be uniquely identified by something other than the primary key we split these set of columns into a different table so we split this by only maintaining gender here so let us say that we are maintaining id name and we are making gender id okay so we are saying 1 2 3 she is a is b then gender is 1 2 1 then based upon gender id i can store the name i can also know the salutation so i can say that gender id1 is male and the salutation is mr and the gender id2 is female and the salutation is miss so this is how i convert our table of converter schema design that's not into the second normal form into something that is a second normal form compliant okay great now let us discuss uh one last thing before we actually uh enter today's lecture is something called as procedures okay something called this procedures in novel functions in normal functions when you would have i mean like a normal programming that we do in normal programming that we do we don't just write code sequentially right we don't write code sequentially but we actually make our schema design procedure right we say we have a function called print this we have a function called do specific task to ensure that our sequel from sql amino code uh that means our normal program is modular okay that that should look modular okay how can we do the same thing in sequence in sql we have something called procedures procedures are nothing but select statements they are also select statements that can be identified by a function call we can create procedures and each procedure is doing nothing but a select statement okay so each procedure is doing nothing but a select statement they are select statements that are identified by the name now these procedures can be something that also that also manipulated right they can actually change the data as well that whatever is in the uh data set at that particular location so suppose there can be a procedure or this can be update statements modification statements okay so example the one example for that can be suppose this was the thing that happened that hey you decided to call all means master okay suppose you decided to call all the maze master now what you will do you can just write you can write a procedure you can write a procedure which is called change salutation it can take in gender and it can take it new salutation right and then this recursively runs the sql query and then changes it okay now when we are actually discussing this let us actually type of let us actually discuss what kind of sql statements we had what kind of sequence statements that we had and let us actually parallelize its intuition with how you build a house when you are building a house what are the things that you need to do okay like when you are building a house first you need to decide that okay how will my house look like right how will my house look like so that is basically definition okay then the second thing can be who will live in the house right who will live in the house okay what can be the other things the other thing can be you put something in there right you actually uh put some value there or put some data here and all those things right so the other type of queries can be uh that hey you manipulate or you change the design that you say that okay i will put one more thing in the kitchen or i will do says these things okay so those can be uh what we say controlling it or uh we can say it as modifying it or manipulating it okay and what can be the fourth kind of thing the fourth kind of thing can be that hey you have manipulated you have queried you have uh i'm like you have defined the things you have queried you have manipulated you also say that for who is the control who is going to control the thing and who has what assesses so these are the four things that are actually uh i mean like in sql these are the four kind of statements that exist the very first kind of can be data definition language these statements these statements allow you to define how my data is going to look like that okay this is going to have something like this this is going to have something like these these statements are create and all the statements okay these can be create these can be drop these can be truncate i should not truncate truncate it's not actually a data definition language then the second thing can be query for querying in a database what are the statement that we had actually used one most prominent statement that we used for query in a sql database was select so that is a sql statement that is used for selection before query right and the third thing can be manipulation these manipulations can be inserted update and all those things right insert this do this and all those things okay what is one more important thing one more important thing is who actually has assess who actually has access to my table because data is very private so you can't give access to everyone right so you need to have some kind of control of who has access to the data so i mean like in a sequel the database administrator actually gives you a control that okay there is a user this who can actually create uh i mean who can actually write to this data or this user cannot write to the data but he can only read so these control statements can be grant and revoke so in a sequel all these streams can actually be segregated into these four things there can be a definition statement which can be creating dropping this can be querying which can be like select this can be manipulation inserting something or updating something and these can be controls these controls are allow i mean like these control statements are there so i'm like give some read writes read read writes or uh only write writes and all those things to the database management system okay so these are the four things that are there in this now let us actually discuss some i mean like some tricky kind of thing let us discuss one tricky question that is normally asked in a database uh interview and then the question is that hey you have to create a new table create a new table with structure with exact data structure of another table okay suppose there is a there is a table called students and you don't know that there is a table called students you don't know this okay so there is a table called student but you don't know what is inside this table so there is suppose id there is name there is two three more things but only you know that there is a table called students and you need to create a table called students copy which should have which should be having the exact same structure as the students table without knowing that how what is the structure of students but how can you do that so this is actually a very tricky question that is normally that's uh that can be asked so what this i mean like how can you do this thing anyone has any ideas here let us try to see let us try to see what a select statement was doing what a select statement was doing select statement actually returned me select statement actually returned me whatever the data was present in my table right so if i don't know students table at least i can run this select select query to get their data in that form right so i can still get select start from students okay but then what will i do now i at least know that what is in the data i'm like but i'm like what is the structure of students table but what should i do now i'm like what can i do i need to i need to store whatever was whatever was the structure that came from here into some other table right so sql allows you another keyword which is into i say i select star into student copy from now where am i selecting from i am selecting from students right okay what will this thing do what will this statement do if my statement is only this particular thing if my statement is only this particular thing what is it this going to do into is basically into does nothing but copy everything that was in the first table as it is to the next day okay so for example if students table had one two i mean like one a x y z two b a b c and three c d e f okay so this statement i'm like this is the students table this statement will actually just copy everything as it is into the students for the table okay but but i don't want the data i only want i only want this structure i only want this structure how will i do that i can say i mean because i have written a select statement then i can have a where cross right then i can have a weird box okay i will have a weird class but what to put in the where close what to put in the vehicles i need to put something in the where clause such that none of these rows none of these rows actually get carried forward here so what so i'm like the statement should be something that is always false right that is always false so that nothing from here gets carried forward here so what can that statement be i mean like one very hacky thing is where 3 is equal to 4 this statement can never be false right this this sorry this statement will never be true this is always false so select star when the select star thing gets the table structure it creates a new table stress student copy because you are putting into here so it creates a student copy but because the where clause was never satisfied because the variables were never satisfied we actually never put anything there okay but actually we could have done where zero or where false that would have also worked perfectly okay great now let us actually discuss some of the aggregate functions of the in sequence that are present in the sql because that that is something that people tend to miss out because i'm like otherwise you have to see the documentation let us quickly discuss that and then we will be ending the today session so let us discuss aggregate functions in sql okay so let us just list them list them down and let us see what those are the very first function can be average avg so this function this function takes in a list of values this function takes in a list of values and returns the numeric mean of them okay one more function that we had actually discussed in the beginning of the lecture in the in between the lecture was a count right count statement returns just the number of rows the number of rows or the number of records that are satisfying that particular statement so if i just do select count of star from students what will this do i'm saying the count statement just returns the number of records that satisfy my that that satisfy my select statement right so if i have select and i'm saying select everything from students so what is the count of everything this is nothing but number of students so one hacky way to get the number of records that you have is just select count star of student set that was perfectly fine okay let us discuss other functions that is min min also works upon a type of data then there is max because there is average then obviously there also has to be a sum there is first and last what are the first and last string by the way i mean like people tend to get confused by first and last what is the like how are they going to be decided they are going to be decided by the order by the order in which the rows are returned so the first will return the first element in the order in which select statement would have returned the values our null values counted yes i mean if the whole uh row is null null and ll but it is still present that will be counted because it because that record is still there unless you have maintained primary key constraint in which that case it will anyway fail right yeah so similarly the last the last fetch is the very last particular record for that particular element okay when we were in the middle of the lecture what we found about that what we found what did we observe about these aggregate functions these aggregate functions allow you to these aggregate functions allow you to group by i'm like they are used with group by and having right so these are the aggregate functions when you aggregate upon something when you are doing an aggregate so let us say i am going to take average of all means suppose the question that comes to you is that hey given a student table where student table is something like id name gender and score okay you have to return average of males and females respectively okay so the very i mean a very very easy question i mean a very easy version of this is that hey i just need to return the average of all the students in which case you can just do select average of score from students but now you have to select average of males and female in different groups how will you do that in that case you will have to group you will have to group those students by their gender right you will have to group the students by their gender so you will still have to select average of score from students but now all these students are not one group all these students are not one single group there are multiple groups and how are those groups being made those groups are being made by their gender okay select average of score from students group by gender okay so this is how the group by statement comes into effect i hope that is clear okay now let us actually discuss these are the these are the functions that are aggregate functions these are working upon a set of data there are also other functions i mean like many people feel that okay it's very difficult to i mean like it's normally a better choice to use a programming language along with i mean like sql otherwise it's difficult to write a lot of things but actually sql allows sql has inbuilt scalar functions so what are those scalar functions these take in one value and return one value so basically like in multiple programming languages suppose you have a capitalized function right suppose like in let us say in python you have a capitalized function actually let us write those functions in sql only so i should not confuse people so let us in seek well there is a function called new case if upper this function is nothing but this takes in a string this takes in a string and returns upper case version of the string similarly there can be lower case as well okay then there are multiple other functions there are concatenation of different strings then there are some mathematical functions which are actually useful these are rand for random then there are round one of the most important function that i've actually personally used in my i mean like uh in real life environment is the time stamp functions so i'm like if you are working with let us say uh data warehousing solutions like redshift and all those things timestamp timestamp sql functions are very actually useful so these can be like two timestamp then there can also be now function that returns the current date and time so one thing i mean like most people think that sql is just about the query language it's just about querying but it actually has a very strong set of inbuilt functions that are available directly that you can use and do a lot of tasks that you can actually probably do with only programming i mean like obviously you can't do a lot many of them but i'm like it's it's more than what normal people think to be okay okay one thing actually we missed out in the medium of the lecture was keys right we actually missed discussing them in detail so let's just throw a brief write on them and then we'll be ending it let us discuss primary keys and foreign keys and how to create those and foreign even before we discuss primary case let us actually just discuss a term called as candidate keys candidate keys are a set of column values which can uniquely identify every other value selector set of columns actually set set of columns which can uniquely identify every other identify every other value value in a record what do we mean by this so basically let us say let us take care of our students let us take care of i'm like let us take care of a student's table again for the last time so let us say that students has an id he has a name and let us say he has a marks okay and that's it well let us even given as a gender okay so let us say the student with id a has name a score 20 and gender m then id 62 he has name b he is school 30 and gender female yes he has name c 31 and me okay so suppose i just tell you the idea of the student if you just if i just tell you the idea of the student you can directly go and say that okay the student with that id had this name had that score and that made okay so i mean like if you just know the id if you just know the id you can know all these three things right let us only consider this table the current values in this table do you think in in this current value neem will also be uniquely able to identify all the other attributes if i tell you that please get me data where name is e please get me data where name is a will it be able to uniquely identify all the values yes in the current set it will be able to because there is only one person with one name so a has only one person b has only one c has only one so if i only know name i can directly get the score i can directly go to gender i directly get the agenda and directly get the id is gender enough is gender enough to get the data no gender is not enough to get all the other values of the data set because there are multiple people who have the gender mail but but have different name different id and different scores so the columns that is for this example name and id that can uniquely identify every other values are candidate keys so candidate keys can be a single column or a set of columns what is primary key then primary key is the key that the dbms uses to uniquely identify i record okay it can also be it can also be a single column or it can be group of columns okay so let us let us see let us see the student and books table that we had actually written about right above we had actually written a student table where what we had was that hey which student has rented which books so there we had a student id and book site and book id right so if student one had taken book 201 he had taken book 202 he had also taken book two zero three then student two has taken book one zero one he had also taken two zero two he had also taken let us say that there is two and three who has taken two zero three suppose these are the students and this is a table what do you think can be a primary key of this table can it be only student id can it be only student id no because there is no i mean if i just tell you student id you can't uniquely identify the value this student id is associated with this book id i mean like there is this thing this is also associated with this this is also associated with this so basically primary key can be set up can be the i mean it can be the set of columns whose value if you know you can uniquely identify a row you will definitely you are guaranteed to return a single row okay so for this particular table for this particular table the primary key will be student id comma book id both the columns together constitute the primary key and let us actually discuss how will we create our primary key i'm making a sequence statement how will we create a primary to create a primary key you can either do the very first way which you can do that is while creating table so while creating table you can do create table you tell the name of the table let us say that the name of the table is students you create table students in this table we are actually maintaining student id and book id let us talk about this thing let us say here we maintain the ids test okay so when we create a table we have to tell what is the name of the column and then we also have to tell what is the data type of that column so let us say that id is an integer okay and i'm like let us for now keep it as it is then we say that okay we are also storing a name name is nothing but a string right in sql a string is a vector it's a variable character of how many characters max let us say it's 255 so at max that can be 255 characters and then here we have let us say school which can also be an integer and let us say we finally have a great uh i mean let's say we don't have a gender for now okay then we have to decide the primary key so we can write primary key and in the parenthesis we set what that primary key is okay that is one way while we create the table we actually write what is the primary key going to be but sub suppose you had actually created the table and you forgot to add the primary key what will you do if you forget to do something that you had actually written while creating a data or while defining the data you can use the altered keyword altered keyword is used to alter keyword is used to alter the initial data definition that you had done so you can do alter table students where and you i'll first you see that i am now going to alter my table so that means i'm going to add something to it what i'm going to do i'm going to add primary key and that primary key is going to constitute only id that is how i use the alter keyword and get this particular thing done okay so that is about the primary case let us actually briefly discuss i'm like before we come to foreign keys let us actually briefly discuss the constraints okay so i also want that hey i tell you that there should not be any student whose name is empty okay i don't want any student whose name should be empty okay that means i want that student's name should definitely be present so sql provides us a list of constraints that we can use upon our data definition okay so one of those constraints can be unique then the other constraints can be not null then there are other constraints like that can check a particular value that okay unique constraint says that value in a column or a group of columns should never be duplicated okay not null says value should never be empty then one of the constraints that we have discussed is primary key that primary key by default says that it should be unique and it should be not null okay then there is also one more constraint that you can see we can say default so i tell that here if i somehow if i somehow miss to give the value of a particular column please set it to this value please set it to the default value okay then one thing can be check this check statement can actually verify that a value is satisfying a particular condition for example i can say that let us i mean suppose my i had also i also had a gender here i also had a gender here so i can say that it's a gender and it's in character okay then i can maintain a check that hey gender should be only mrf okay so this is what i'm like this is what we maintain my gender that okay i put a constraint that okay i can't i mean there's no predefined constraint so let me actually create my own constraint that hey the value of gender should only be m or f okay and the next there is also one more constraint which is the foreign key and let us discuss this foreign key constraint now okay so what is the foreign key when we actually were creating uh the i mean like the original thing i'm like when we actually created the employee table very uh in above what we actually done we had two tables right so the very first table that we had was employee data in which there was an employee id his department and let us say his title and all those things okay let us say we had one this table and the second table was let's say employee salary and this had employee id and this also had salary okay so if we have these two things does it make sense does it make sense that hey there is an employee but an entry corresponding to him is not present in the employee salary table is does that make even any sense no right because i mean like if there is an employee here whose department is let us say tech and his title is let us say cto then there can be another id two whose department is let us say program management and whose title is let us say hey i'm like let's say it's a general one it's program management one then there can be another person three who is also program manager let us say his title is pm2 and all those things and let us say there is four who is in tech and he is software engineer but let us say this is these are the rules that we have and corresponding to id1 i have a salary let us say two thousand it is saying that i have a 72 they have three thousand i have a salary five i six thousand and i have a salary three who is let us say four thousand and i have a salary for us let's say two thousand does this make any sense i'm like there is a there is a salary of an employee but that employee does not exist this does not make any sense right i mean like there should not be i mean there cannot there should not happen that hey in employee salary there is an id there is an id but that id is not present in employee right so we need to ensure that if if an employee salary is present here that employs id should also be present here as well right so we can add we can add a foreign key to the employee salary table but what should that foreign key reference to that foreign key should refer to the id column of the employee table okay so what can you do it can say i'm like how can we add this i can say that here when i create the employee salary table i say create table employee salary okay when i'm creating the table i need to have an id then i also this is an integer okay and i also need to have let us say the salary which is also an integer okay now i need to add a foreign what is the foreign key upon foreign key is upon this id right foreign key i add upon this id but what should this foreign key refer to what should this foreign key refer to this foreign key should refer to id in employee table right so i say foreign key id references this references uh employee id okay so this is how i create a foreign key if i forget to create foreign key i can just i'm like like we add primary key later we can do alter table foreign key sorry alter table uh employee salary alter table employee salary and then what i do i have to now add a foreign key right so i add a foreign key i add a foreign key upon which column i add a foreign key up on the id column and this references uh employee id okay so this is how i can add a foreign key later as well okay by the way i'm like any time when we have to do a modification to the data whenever we have to do any modification to the data we actually have to use this alter command this alter as we know is that data definition thing and this can actually i mean like alter the table alter the definition of the data this allows you to do that okay okay finally i think there is one more confusing thing that i actually saw someone in the comments what is the difference between drop delete and truncate what is the difference between these three things i mean these three things uh in english-wise mean the same thing right these three things make the same that okay you are deleting something perfectly okay but is there any difference between these things why why does sql has these three things like why okay so the difference between these three things is that hey delete is used to delete a row from a table delete is just opposite of select okay in select statement you select some set of tables to view but in delete in delete command you select a particular set of records to remove them from your sql table okay so i'm like what you can do is suppose you have to delete all those students i mean i suppose your university decides to remove all the students who had less than 40 marks so but less than 40 score so your university can do delete from students okay then you can use everything here where what you use in select statement so you can use everything here so you can select where let us say score is less than equal to 40. this will do what this will just remove every i mean like every data from the student table from the students table that had a score in which a student existed who had a score less than equal to 40 that is the delete command then there is also a truncate command what this strung command is used to do this deletes all the rows this deletes all the rows but table is still there but table and its definition constraints everything is there definitions constraints are still there and then the final thing is drop remove every existence of the table okay remove complete existence of the table so let us actually let us actually actually uh give you an intuition of this with a diagram okay suppose we had a table like this we in which we have an id in which we have a score okay let us say we have id1 uh whose score is 50 id2 score is 60 id3 whose score is 20 id4 score is 10 id5 whose score is 70. okay let us run three commands here let us run and this is id and this is size okay this is suppose a table and let us say the first command that we run is the delete delete from students where score is less than equal to 40 what will this return to this will change it to uh id and score and this has 150 because this is there 260 and 570 okay other things will get deleted you do truncate if you do truncate you are only remaining with id score no data is remaining okay nothing else is remaining and if you do drop if you draw draw do drop nothing is remaining i mean there is complete empty thing nothing is nothing is depending yes uh rahul uh where clause can be applied in delete that is what we have written here right yeah so let me actually give an example of how to write the truncate command to completely remove the students table you can do truncate table i will have to truncate all the data that is there in this so you can do truncate table students uh and to remove the students i'd like to to go into this thing that there's no existence of students table at all you can do drop table students okay so they do they completely remove the data or the second thing the drop table actually completely removes the whole existence that is there of that data okay yeah so that's all that i had from my side today uh i hope you liked the session it went for around two and a half hours so yeah thank you for being a very patient listener and uh okay uh and by the way guys i'm like we have actually a very uh i mean like all these things we have actually written into a well-defined article as well on the debugging platform so that is present on this particular link that i just pasted on the chat so please like if you want to practice all these sql statements so you can actually write those sql statements there and see if the code with the sequel code that you wrote was also good okay yeah awesome have a good night please stay safe and stay healthy