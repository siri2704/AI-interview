hello everyone and welcome back we were learning about relational databases and as a continuation of this chapter we are going to learn in this video about the relational model constraints what do you mean by constraints constraints are the restrictions or the limitations on data in the database constraints on databases can be divided into three categories the first one is inherent model based constraints or otherwise called as implicit constraints as the name itself suggests these constraints are inherent or already existing in the data model like for example duplicate tuples or rows are not allowed in a relation so this constraint already exists and we need not mentioned again explicitly the next category is schema based constraints or explicit constraints these constraints are defined directly in the schemas of the data model an example of a schema based constraint is i can have a constraint say age of the employee has to be between 22 to 65 years so here age is restricted to be between 22 and 65 and this constraint is defined directly in the relational schema we will learn more about this constraint later in this video the last category is application based constraints also called as semantic constraints these constraints cannot be directly defined in the schemas that is they are difficult to express within the data model and so they are expressed and enforced by the application programs another important category of constraints is the data dependencies which includes functional dependencies and multi-valued dependencies this category of constraints is used mainly for testing how good the design of the relational databases and it is used in normalization which we will be learning in the later chapters in this chapter we will be focusing mainly on the schema based constraints that includes domain constraints key constraints constraints on nulls entity integrity constraints and referential integrity constraints let us see each of these constraints in detail so the first constraint under schema based constraint is the domain constraints domain constraints specifies that within each tuple or within each row the value of each attribute has to be atomic or indivisible also this constraint checks the data type of the values of each attribute for example in this relation student if i have assigned the data type of the attribute age as int then we can't have any values in that column other than int data type that is the values of the attribute age is restricted to the data type int so this relation violates domain constraint because we have a value in this column which is not of int data type so this is about domain constraints the next type of constraint under schema based constraints are the key constraints we have already learned that a relation is a set of tuples or rows we know that theoretically relational model is based on set theory and since the elements in a set has to be unique the tuples in a relation also have to be unique that is you cannot have two same tuples with the same values for all the attributes now when we are talking about key constraints let us first see what a key is we have already seen what a key attribute is in our previous video so an attribute that can uniquely identify each tuple in a relation is called a key for example in this relation student name cannot be a key because we can have two or more persons with the same name neither can age or grade be the key because its values are not unique whereas roll number can be a key in this relation student because in a class no two students can share the same role number and hence with this attribute we can uniquely identify each tuple therefore roll number is the key in this relation student and a key in a relation is indicated or represented by an underline under the name of the key attribute now let us see what a super key is a super key is a set of attributes that can help in identifying each tuple in relation uniquely and a super key specifies that no two tuples can have the same value that is if roll number is the super key then we cannot have two tuples with the same value every relation has at least one super key by default and that super key is the set of all attributes so in this relation student all the attributes together make a super key that is all these attributes together helps in identifying the tuples uniquely so in every relation by default the set of all attributes make one super key let us identify the super keys in this relation i have represented super keys as sk we know that roll number helps in identifying each tuple uniquely so roll number is one of the super keys also no two students can have the same email id therefore email is a super key since roll number and email are super keys any set of attributes with these attributes will also be a super key that is the attribute name cannot identify each tuple uniquely but when it is combined with roll number it becomes a super key so any attributes that are combined with these super keys will also become a super key the next super key is roll number and h roll number and email name and email age and email also roll number name and age is one super key roll number name and email is one super key email name and age is a super key and we know by default a set of all attributes that is roll number name age and email is one super key just remember that super key is any set of attributes that helps us to identify each tuple uniquely so these are the super keys in this relation student a key satisfies two constraints or two conditions the first condition is two tuples cannot have identical values for all the attributes in the key that is in this relation student if this attribute roll number has to be a key then it cannot have two tuples with identical values the second condition that a key should satisfy is that it has to be a minimal super key that is the most minimum attribute to identify each tuple uniquely we have already identified the super keys in this relation and one of the conditions a key should satisfy is that it has to be a minimal super key therefore roll number or email can be a key in this relation student this first condition is for both keys and super keys and the second condition is only for keys now a relation schema can have more than one key in that case each of the key is called a candidate key again the definitions are similar a candidate key is a set of attributes that uniquely identify the tuples in a relation in this student relation we have two candidate keys one is roll number and the other candidate key is email we can have any number of candidate keys in a relation but we designate only one of the candidate keys as the primary key of that relation another constraint on attributes is constrains on null values this constraint specifies whether null values are permitted or not for example in this relation student if every tuple in the name attribute has to have a valid value and cannot be null then this attribute should be constrained to not null so when i specify this constraint to any of the attributes in the relation then the values of that attribute cannot be null the next constraint is entity integrity constraint this constraint specifies that or states that no primary key value can be null and why can't it be null because primary key helps us to identify each tuple in the relation uniquely and having a null value for primary key implies that we won't be able to identify some tuples uniquely like for example this null value won't help us to identify this tuple uniquely so therefore primary key value cannot be null and that is about entity integrity constraint the next type of constraint under schema based constraint is the referential integrity constraint the key constraints and the entity integrity constraints are specified on a single relation or a single table whereas the referential integrity constraint is specified between two relations or two tables referential integrity constraint states that a tuple in one relation that refers to another relation must refer to an existing tuple in that relation you will understand this definition better with the help of an example so here i've taken two relations one is the student relation with student id as the primary key and the department relation with department number as its primary key the d number of the student relation refers to the day number of the department relation so this is the parent table and this is the child table since this d number refers to the d number of the department relation the values over here in the child table should refer to the existing values in this parent table hope you understood the definition now referential integrity constraint states that a tuple in one relation that refers to another relation must refer to an existing tuple in that relation so the attribute of one relation that refers to the primary key of another relation is called the foreign key to understand referential integrity constraints better we need to know about foreign keys i've already defined a foreign key it is a set of attributes in a relation that refers to the primary key of another relation a foreign key must satisfy the following conditions the first one is it has to be of the same domain as the attribute it refers to we know that d number is the foreign key as it refers to the primary key of this relation so the domain of the foreign key should be same as the domain of the attribute it refers to so that is the first condition the second condition is value of foreign key or fk in a tuple either occurs as a value of the primary key that is t1 of fk is equal to t2 of pk here t1 and t2 represents the tuples so this means that the values of foreign k in each tuple must occur as a value of primary key i cannot have d number as 4 over here because there is no d number as 4 in the relation it refers to so the value of the foreign key either should be the same as the values it refers to or it can be null therefore the second condition value of foreign key in a tuple either occurs as a value of the primary key or is null this relation student is called the referencing relation because one of its attributes is referencing the attributes of another relation and this table or relation department is called the referenced relation because another relation refers to it hope you have understood about foreign key and the referential integrity constraints with this we come to the end of this video hope you have understood the different constraints in the relational data model this chapter focuses only on schema based constraints and you will understand these constraints better in the next videos thank you [Music] you