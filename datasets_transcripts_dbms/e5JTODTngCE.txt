[Music] hello everyone welcome to another video on database Management Systems we'll start today's session with functional dependency we'll try to understand what is functional dependency different types of functional dependencies and why do we need functional dependency functional dependency deals with the relationship between different attributes relation now we are dealing with the relationship between different attributes how different attributes are related to each other is defined by functional dependency a functional dependency between two attributes X and Y is represented like this x determines y or Y depends on X this is how you read it X is called the determinant Y is called the dependent Y is depending on X and X is uniquely determining y so this is the definition of functional dependency in this X and Y X uniquely determines Y X and Y and those are attributes let's consider a student entity and primary student ID uniquely determines all the other attributes in the table like name date of birth and Department of the student student table student we can uniquely determine all this in the student table by student ID name date of birth Department Let's see different types of functional dependencies there are three types of functional dependencies trivial non-trivial and completely non-trivial trivial and obvious a functional dependency between X and Y is Trivial if Y is the subset of x why is the subset of X and why attribute X represent attributes subset like for example this one consider this is X and this is y x is the combination of student ID and name student ID and name uniquely DET student ID and this is right but this Y is a subset of x x already and that's why it's trivial this is so obvious and it is Trivial functional dependency now let's learn non-rival functional dependency X tends to Y is non- Trivial if Y is not the subset of X which is exactly the opposite of trivial non-trivial is exactly the opposite of trivial this is the example this example is wrong it should be like this this is X and this is y now consider this as X and this as y y is not the subset of X Y is the superet of X so when Y is not subset of X this is called not trival functional dependency now coming to completely not trival functional dependency this is completely nonrival If X and Y have no common attributes like this given a student ID I can uniquely identify the student name if Y is the subset of X it is so obvious that X determines y and function dep this is very obvious if I have a list of attributes student ID and name this will uniquely determine student ID and this will uniquely determine name so if this is the case X will determine Y and that is one of the properties of functional dependency simple properties if x determines y then x z determines y z Z is representing some set of attributes because these two are same this can uniquely determine this so for any Z this is true if this is true if x determines Y and Y determine Z then X will determine Zed this is the transitive property x y y z and hence X determines Zed in all these cases X and Y are sets of attributes it can be either one attribute of an entity or multiple attributes of an entity now this is exactly opposite of this if x determines Y and X determines Zed if the same X is determining both Y and Zed then X will determine y z and now this is exactly opposite of this if you given this we can even divide them separate separately X determines Y and X determin Zed and then the last one if x determines Y and Y Z determines W I can always replace this y with X because Y is uniquely determined by X when y z is determining w x will also determine W given X determines y so functional dependencies types of functional dependencies and different properties of functional dependencies but why where is this functional dependency used and where I can make use of this properties functional dependencies are very crucial in the process of normalization each St normalization what is normalization it's a technique of organizing the attributes of a database to reduce redundancy if trying to place all the common attributes in all the tables if you're trying to place as much as data in a single table or or if you're trying to place all the common attributes in all the tables same records same data different tables and that's called redundancy ini normal con there used to be a lot of redundancy while designing the databases and that used to be a nightmare for database administrators and the people came up with the concept of normalization which heavily depends on functional dependencies normal in order to reduce the dependencies so given actual table let's see what is functional dependencies we are dependent on functional dependencies consider a table or entity books that attributes ISBN title author and price of the book now in this entity given an ISBN I can uniquely identify the title of the book author of the book and price of the book Ask X uniquely determines Y and Y is a set of attributes each ISBN uniquely determines the title author and price of the book so given a table or entity this is how we write functional dependencies now let's see in detail how to identify functional dependencies given some entities and attributes step number one list all the attributes obviously functional independency andain a relationship between the attributes so first step is listing all the attributes one example consider we have a table called book what attributes say ISBN title author year of publishing that book Library get different branches and the last one is copy number because we have to maintain the copy number step two determine the candidate Keys candidate keys and super key with no proper subset as super key ISBN is the candidate key because this uniquely identifies all the other attributes of the enti step three identify which attributes are uniquely determined by the candidate Keys candidate key is a Super Key with no proper subset as super key ISB is a candidate key and it uniquely determines all the other attributes in the table and it uniquely identifies other attributes in the entity if put a dependent attributes set we have to identify ISB number is there I can uniquely the book title in addition to title I can uniquely F the author year of publication and library branch but justb number number because same ISB number can have two different copy numbers copies so in addition to number we also need the library branch to uniquely identify the copy number okay X Branch e ISBN number in a book given an ISBN number I cannot uniquely identify the copy number because number two different BS anduk in addition to ISBN we also need library bch to uniquely identify the copy number so this is how we identify functional dependencies in an entity first we'll list all the attributes and then we'll determine the candidate key because this is one of the important attributes which uniquely identifies other attributes in the enti functional depend function depend because functional dependency is a crucial part in performing normalization now let's see now let's concentrate normalization with the help of functional dependency in order to minimize the redundency in the database rendy that's why we minimize the in the database and by removing all the anomalies and break the database to a consistent State important and that is anomalies now let's see what are anomalies and what are different types of anomalies database anomali insertion anomally deletion anomal and update anomal insertion anomal deletion anomaly and updation anomal one database then operations create update read and delete create at the insertion update is update read and delete in operations 90% of the time read so read is the most frequent operation problems and difficulties oper we have to be careful while inserting updating and deleting the record database if we are careful about these anomalies future read just will not have much problems now let's see in detail what are these three anomalies consider we have student entity attribut student ID student name course ID student student ID student name course ID instructor name and I want to store the information I can populate the information related to these two columns colum we cannot add just course information without assigning it to students this is a big problem if you are having a table called student like this and this is insertion anomaly student consider you have a record here you have student 81 student name is Rajesh course is 101 course name is computer science instructor name is d e l rajes student is enrolled with computer sence course which is Tau by D and for now consider that rajes is the only student who is enrolled at computer science course Andes colle of you'll be deleting this record record delete this you're also losing course information and also instructor information because this is the only record in which one one course ID and computer science course name is present and this is the example for deletion anomally if you delete a record of a student who is enrolled in a course you might also lose information about that course if it is recorded in the same row as the student cation and we'll be end up losing it that is dele anomaly last one update anomaly only we'll go back to the same example consider we have another row some student name X computer sence andaj student computer now consider the is leaving The Institute and consider the replacement for the is y so in order to update the instructor name for the computer science course you'll have to fetch all the records with course name as computer science and PR if a course's instructor name changes you need to update it in every row where that course appears if you miss an update inconsistencies will arise multiple places if we miss an update database will go into the inconsistent state but our goal is to bring database to a consistent state which means we have to avoid this update anomaly and this can be done by normalization before stepping into normalization let's understand the overv of ital and set first we will check if the table is in first normal form or not this is very basic condition that a table should satisfy we will con it into first normal form if at all if it is in first normal form then comes the next stage we will it into second if our table is present in second normal form next step is third normal formable thir normal form we will the table into third noral form then third noral form we'll finally check if our table is in bcnf or not bcnf called noral BN we try to convert it into bcnf it is already present in bcnf will and good so our goal should be to normalize it as much as possible starting from 1nf to bcnf up and I said we'll try to normalize it as much as possible so table first we'll check if it is in some normal form or not if not we'll be converting it to the normal form so PR step we have to do these two steps check if it is present in one NF El convert it into one so St in order to check if my table is in first normal form or not I need to know first what is first normal form first normal form which is also called 1 andf a table is in first normal form if it contains only Atomic attributes Atomic and previous indivisible like for example take this this table is not one this is not Atomic you have more than one values in this attribute Math Science and History this is not Atomic we can divide it we will have tables with only Atomic values contains multiple values in a single cell which is making it non-atomic so first normal form apply J we'll change this multivalued attribute to a single attribute student name Al so one and Al and in each row we are writing different courses maths Science and History same is the case here Bob key math and English so student any2 and student name Bob key will create two rows and store courses separately so now this table is presented 1 NF but what is the problem with this why should we move on to 2nf because this table is causing redundancy as we are repeating the student name different differentes but why should we repeat the student names that's why 1 NF is not an ideal normal form and we'll have to convert the table which is present in 1 NF to 2 NF second normal form it is also written as 2 NF a table is in second normal form if first condition is it should be in first normal form first normal form the attributes inside the table should be Atomic we'll check for the second condition second condition all non Keys non keys are all the keys which are not part of candidate keys different different candidate keys different candidate keys can be the combination of one or more attributes all those attributes put together a attributes non key attributes on top these non key attributes should be fully functionally dependent on the entire primary key function dependency all the non Keys should be fully functionally dependent dependent there should be no partial dependencies should not be partially dependent on primary key it should be fully dependent on primary key let's understand this better using an example consider this table employ project ID employee name project name Department name and Department location let's start with employe there are two rows here which means just using employee ID we cannot uniquely identify a row in the table let's check this project ID if we are given this combination can we uniqu identify a row in the table combin this one no combination so this combination of attributes employee and project ID is the primary key given an employeeid and project ID I can uniquely identify any Row in this table I hope you understand how we came up with this Prim key are Keys condition all these non keys keys should be fully functionally dependent on combination of employe ID and project ID let's identify the functional dependencies functional dependencies ID identifying the attributes identifying the candidate key and then listing down the functional dependencies Mark attributes step number one step number two already CH some we know the primary key now let's list down the functional dependencies given so this is understandable given an employ can uniquely identify employee name let's see that E1 key employee name is Alice E2 key employee name is Bob E3 ke employee name is Charlie this means employee name is dependent on employee ID alone without the help of project ID dep dep employe key e01 key the department name is HR if you see it's repeating here e02 key Department Tye is I this is repeating here same way Department location so employee ID is able to uniquely identify employee name Department name and Department location without the help of project ID and this is called partial dependency this is very very important we found a partial dependency in our table but definition there should be no partial dependencies now let's see how to remove it trans dependency this is the concept that will come in 3F we depc table and we want to remove it dep employee name Department name Department location are dependent alone on employe ID so V separate first tableti dependency columns second table project ID and project name rel1 when we have only these two columns in the second table we don't know this relationship and we are adding this extra column employee ID this employee ID in the second table is the foreign key which refers to the primary key of the first table and this is referring this employee name depends on employee ID and not on fully composite key which is employ project ID we broke it down into two tables so this is the main condition dep tables into 2 andf so after dividing we still have to check if these tables are in 2 andf or not given an employee ID I can uniquely identify all these attributes empy and all the non keys are fully functionally dependent on only the employee ID and that is the only primary key so this is in 2nf this is how we remove partial dependencies and convert a non 2f table to a 2f table second normal form depencies third normal form transitive dependencies second dep should remove themal dep we have to remove them let's see the definition of third normal form a table is in third normal form if it is in second normal form this is the first condition this means there should not be any partial dependencies and also the table should present in one NF extra condition all attributes are fully functionally dependent on the primary key and there should be no transitive dependencies trans dependencies dep if x implies Y and Y determines Z then X determines Z so this is the transitive dependency let's continue with the same example Department name and Department location Department location is only dependent on Department name Department name can this so Department name Department location dep but this department name is depending on employee ID so this is X this is y and this is z x y z x determines y employee determines Department name y determines Z Department name determines location and hence employee which is X determines the location set which means there is a translative dependency because Department name uniquely identifies Department location and because of this we have transitive dependencies to remove these transitive dependencies we have to further decompose the employee table employe table we have to further decompose decompos we separate out the department information we will separate out the department information from the employee information Rel let's keep the department name this is the foreign key and this is the primary so we decomposed employee table into two different tables Department table employee table and the project table already by doing this we remove the transitive dependencies and hence our tables are in 3 andf I hope this is clear now let's see the last one Boys called normal form which is bcnf let's start with the definition a table is in bcnf if it is in third normal form same 2 NF a 1 NF AA table 3 NF 2 prerequisite to become bcnf the table should be in third normal form extra condition for every functional dependency X determines y x should be a Super Key Super Key super key is the combination of attributes where super key should be uniquely able to identify any Row in the table let's take this example course ID course title department Department headed department phone number functional dependen course ID I can uniquely identify the course title I can uniquely identify the course title and Department name this course ID represents a course a course go title the and that course will belong to a department next given a department I will know who is that department head and what phone number they list from there and give a department head I know his phone number these are the functional dependencies here now what is the Super Key table given the super key I should be able to identify any Row in the table functional dependencies X Y now let's check x l if they are a super key or not super key course ID given a course ID am I able to uniquely identify any row can identify row in this table so course ID is a super gy so this functional dependency is satisfying ecnf now let's come to this department department so given a computer science now we'll have a confusion on what to return in this two row so given a department we are not able to uniquely identify the row in the table so this is not a Super Key this is failing here same as the case with the department head if I just give you Dr Lee you Dr Lee computer sence Department Andi so department head is not able to uniquely identify the complete R in the table so these two are failing super super department and department head are not super Keys department and department head problem let's try to separate the department information into a different table in order to convert this table to bcnf you need the two departments computer science and electrical engineering why the department Dr respectively number I have two in my department table here department is the primary key and this is the Super Key also and when department is a primary key all primary keys are candidate keys and all candidate keys are super Keys remember we discussed this previously so this table is in bcnf the course title and course ID course ID is the primary key and given a course I can uniquely identify any Row in this table just to have a relationship between these two tables we are having this foreign key Department the primary key the foreign key foreign key is pointing to the primary key of a different table so we have to first check if that is present in first normal form or not first normal form we'll check if it isn't 2 NF or not then 2 NF convert JC we'll check if it isn't 3 NF or not that 3 NF convert JC we'll check if it isn't bcnf or not always it might not be possible to normalize it until bcnf but we try to maximize the normalization procedure so normalization follow if you design the database we can avoid insertion anomaly update anomaly and deletion anomaly mod our database will be in a consistent State and we can avoid future problems hope the concept of normalization is clear that's it for today let's meet in the next video Until then stay tuned stay focused keep learning