Download the power point presentation (ppt) of the video using the link given in the description PL/SQL: Procedural language extension to SQL Now, why do we need PL/SQL? Basically, SQL is a query language It is not a typical procedural programming language like C or C++ So it (SQL) doesn't have facilities like functions, if-else, loops etc So in order to have those benefits of constructs like looping, decision making using if-else Or using functions, which are reusable blocks of code so to have all those benefits in SQL, this is a procedural language extension created by Oracle Usually a PL/SQL block has these (three) sections Declare is an optional section which begins with the keyword DECLARE You have to declare all the variables that you are going to use in your PL/SQL code like your C function, where you declare all the variables at the beginning. Then begin is the part where you write your actual code like if-else, loops etc. Usually you write SQL queries in this part then you have Exception block, again optional Whenever something bad happens in the earlier blocks, you can handle that in EXCEPTION block i.e What to do whenever something wrong happens (Exception Handling) and then finally you finish the code with END; So if you look at this sample program of printing the numbers from 1 to 5 I declare a variable i, of type number these types will be same as the data types available in SQL equal operator has changed a bit, it is := dbms_output.put_line is the statement which is equivalent to printf( ) in C language it will print the data (here i) on your oracle console after printing i, I am going to increment it using i := i+1 this is the way you write loops in PL/SQL a bit different than what we are used to in C language, but nevertheless, looping is now possible Now we will start with our first major components of PL/SQL i.e Procedures procedures are similar to blocks/functions in C IN means they will used as input OUT means they will be used to return the values so there is no return statement (like C) used but you can still get a value as output through OUT variables and there is one more possibility of IN OUT i.e a variable can be used for input as well as output If you do not specify a parameter as IN or OUT or IN OUT the default type is: IN write the procedure body in here and then say END procedure_name; Let us see an example: name of the procedure is: topperStudent as the purpose of this procedure is to find out the name of the student who has scored the highest marks I want topperName variable's type to be same as that of name column of student table so that way you don't need to worry about if it's varchar, text, int, float anything so let us start with the body of the procedure:  begin we will have to store the name into topperName variable there is a sub-query so first select the maximum marks from student then use those maximum marks as a constraint for marks and find out the name of the student and save that into topperName and finally print that value so for printing output we have dbms_output.put_line ( ) procedure created, really easy, right? now let us see how to run this procedure: getTopperStudent begin, followed by procedure name No parameters and then type end; run this, and we have got the result as John so let us check if John was actually the topper see that the maximum marks (100) scored by John so John is the topper (verified) so we created this procedure and we executed it Now, let us move on to Cursor A cursor is a temporary area created in the memory when we execute an SQL statement earlier we wanted to get the name of the topper student; now topper student could have been one so we could store that value into a variable called as topperName but what if we want to return multiple values from a procedure let us say, students from the mechanical department so that case there will be many students (for any dept) so in that case we don't need a normal variable. We need a cursor because cursor is basically an area in memory where SQL query results are stored and then you can access that area by using a pointer Cursor types: 1) Implicit 2) Explicit so basically what happens is; there are implicit cursors present even if you do not use them for e.g if you are using a query: Select * from students; So you get all the rows (of students table) in return as an output So how does the internal system of DBMS handle this? they use implicit cursors there are some useful attributes that are provided on these implicit cursors which we can use in our PL/SQL coding if the query returns at least one row, then this attribute returns true else it returns false %NOTFOUND is exactly opposite if your SQL query does not return any row then it is true, otherwise it is false and you can use %ROWCOUNT to see how many rows have been returned by your SQL query ok then, let us make use of this implicit cursor as you can see we have created a new procedure: updateFees and it needs a parameter called as newFee which is of type int then we have declared a variable: var_rows which is of type number we carry out a query, update student set fees = newFee so basically we increase everybody's fees to a newFee if SQL%FOUND, i.e this will be true (%FOUND) only when the query affects more than one row this will give us how many rows were affected by the update query and we will just print it; i.e the fees of these many (var_rows) students was updated else, if there is some problem, we will print: "Some issue..." alright, let us create this procedure. procedure created, and let us run it begin updateFees(45000); end; And everyone's fee has become 45000. so our procedure worked so this is how are use the implicit cursor properties: FOUND and ROWCOUNT Now we talk about explicit cursor you will need them when you are writing a  procedure or a function in which; you require to store multiple rows and iterate through those rows So this is a cursor example to show the average fees paid in every department I will explain the code to you so this is the general syntax; declare cursor followed by cursor_name it's always: is.  In case of procedure this could be is/as but in case of cursor it's always:  is so this is our SQL query where we are going to find average fees for every department then we declare a variable: rec1 so rec1 will store a row of type c1 and c1 is represented by this query now let us iterate through c1 using rec1 we have renamed this column (deptName) as department and we have renamed avg(fees) as Average_fees the output is correct as all our fees have been 45000 we did that in our previous example you see the point here; we used cursor when we wanted to access multiple rows we wanted to get multiple columns from multiple rows so we had to write a loop to iterate through rows using cursor this is how you use the cursor let us take another example you have to specify the query for the cursor then we are adding one more cursor now this is a parameterize cursor we have a parameter named as dept whose type is varchar we declare a variable rec1 which will be used to access rows of type c1 it will be rows of type this SQL query: select distinct deptName from department; rec2 will be used to access rows of type c2 which is: select name, marks from student natural join dept.... we just print deptName first: rec1.deptName and then we will put another loop inside the outer loop now c2 needs a parameter so we will use rec1.deptName as our parameter we are just going to print rec2.name and rec2.marks end inner loop, then print a blank line and end outer loop so we can see department wise list of students as output Now, let us try to write a procedure with cursor so this is a procedure which will display the details of all students from a given department so the department will be passed as parameter, dept of type varchar let us pass the department name you can see that for civil department there are two students: Usher and Bishop so this worked, pretty well. Now we go to functions functions are similar to procedures the only difference is that functions in PL/SQL always return a value whereas, a procedure may or may not return a value I will explain the syntax here create or replace function totalFees (name of the function) followed by a parameter list only one parameter, dept of type varchar this function returns a value of type int, which has to be specified then we begin with keyword: is that is where function starts its body first we define local variables we are going to use a variable: total of type int finally we begin the code of the function this is our SQL query so the value of this total variable will be returned so we have created the function. Now, in order to execute the function the syntax is: select function_name (paramater) followed by: from dual; so see the total fees as 2,25,000 for production department Triggers Triggers are stored routines (code) which get automatically executed whenever some specific event occurs for which the trigger was defined e.g you can write a trigger before an insert or before a delete operation on a table or after some insertion occurs, after some delete occurs on a table so usually triggers are written for DML: before/after a delete, insert or update or before/after create, alter or drop operations on tables either you have to specify BEFORE or AFTER INSERT/UPDATE/DELETE any one from these you have to specify in BEGIN block you write the code of the trigger Let us see some examples What we are trying to do is; We are checking for the email availability before inserting the information of a new student in the student table we have to make sure that email ids are unique so before inserting a new row we have to make sure that the email is available checkEmail is the name of the trigger if the count i.e rowcount value is not equal to zero, then there is a problem because that means, there is already an entry in the table where email = new email that you are trying to insert in the new row in that case we will raise an application error using you have to select error number as any value between      - 20001 to -21000 and you have to give some error message now when you run this code, a trigger will get created now let us test this trigger So let us try to insert an email which already exists: champa@gmail.com and as you can see an error has been fired CHECKEMAIL trigger, "Email Already Registered" so this clearly worked now let us see an example of AFTER DELETE trigger to remove all students of a department once the department is deleted so let's just see how this works triggerName: cleanStudents after DELETE on table department so we have created a local variable dept of type int whichever row got deleted we can get its content using this OLD variable see this trigger will get fired whenever you delete a row from a department so whatever was the content of that deleted row was, we can get it from this variable OLD so once that row gets deleted from the department table, all the corresponding students whose deptNo = OLD.deptNo should get deleted so trigger created there is only one student from department no 6,  i.e Hasher so let us delete department no 6 from department so department (6) is deleted let us run the join query again and hopefully Hasher is out of there alright so there is no Hasher here.  There is no student whose department no is 6 Package is a combination of procedures, functions,  cursors, triggers etc. A package has two things: 1) Package Specification (What it contains) 2) Package body or definition in the example it shall get clear this package only contains a procedure so this package specification tells us that: this is a package with name: student_marks it contains a procedure  by the name of: find_marks and that procedure requires one parameter i.e s_id whose type is equal to that of type of roll_no column of student table Let us run this. Package Created. Now once you have specified the package contents, you have to specify package body so package body created, so let us execute it. and to execute there is a simple command begin package_name.procedure_name (parameters); end; run this let us verify so the result was correct so this is how you create a package Now you must have heard about exceptions in other languages Exceptions are run-time errors Let us have a look at this PL/SQL block in the declare section I have created two variables: dept and name I am trying to input the value of dept (department number) from the user, instead of hard coding it. so this is the syntax so if you run this, that value will be required to be passed by user Now I will use this value in my query then I am going to print the name using dbms_output.put_line so system will raise the exception when no data is found that deptNo that we will be provided with, if there is no row forr that department automatically system will raise the exception: no_data_found so we are handling the system defined exception: no_data_found i.e print the message: "No such department" When others, this is a generic block so Exception is the block, first we start with NO_DATA_FOUND others is a general block. i.e all types of exceptions are handled in this so first we handle the specific exceptions and then we handle the generic exceptions So you might be having hard-time understanding what is this: NO_DATA_FOUND it's the name of the system defined exception. We did not define it, it is system defined but we know that it is thrown by the system whenever there is a query upon execution of which there is no data i.e this exception (no_data_found) was handled Now we talk about user defined exceptions in which case we will have to define an exception So if you look at this PL/SQL block, declare: two variables here: dept and name dept's type is same as deptNo column of department table and name variables's type is same as deptName column of department table and we have also defined an exception now that we are trying to create a user defined exception this is the name of my user-defined exception: ex_invalid_deptNo I have to declare it so I will get the value of dept first I will get the value of dept from user first if the value of dept is less thn or equal to zero, then raise (or fire) ex_invalid_deptNo exception which I have declared earlier We have to handle the exception now the exception which we are throwing earlier we are handling here by displaying a message: "Department number must be greater than zero!" WHEN no_data_found: this is system defined exception (we have studied it earlier) WHEN others: is a generic exception, you can handle it by displaying some generic message ('Error') Let us run this now. We are getting some value from the user Let us give some normal value In this case, we should get a proper value of the department name Let us have value which is valid but there is no department by that id e.g 56 so all the three exception blocks were covered Fine then, this is how you create a user-defined exception