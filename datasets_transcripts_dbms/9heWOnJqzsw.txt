hello everyone thank you for watching another video lecture about database in this lecture we are going to study relational databases relational databases are fundamental aspect of modern data management organizing information in structure tables or relations with attributes these attributes define data properties the schema represent the database design by instances refer to the actual store data based on mathematical principles like set theory and relational algebra relational databases uses keys like primary keys foreign keys candidate keys in order to ensure uniqueness and maintain relationships between tables relational query language such as SQL enable efficient data manipulation and retrieval utilizing operator like selection projection joining etc understanding these concepts is essential for designing and managing efficient database system let's get started we start with the foundation of this presentation the relational model or RM in short this is a method for organizing and managing data in a structured way how using tables it was pioneered by Edgar F code in 1969 and its core idea is simple yet powerful all data are stored as topples think of these as rows in a table and these toppers are grouped into some relations which are tables themselves this approach provides a systematic way to store retrieve and manipulate data forming the basis of modern database systems like SQL we introduce two key terms here one is relations and attributes relation is necessary a table that holds data and attributes as you can see here like ID name salary department name these are the columns of our table each column represent specific type of information like for example ID here names here departments here and salary here tables are building blocks of our database so we call these things are toppers or rows or even records once again relational model represent how data is stored in relational databases a relational database store data in the form of relations or you can say tables it means relational databases represented database as a collections of relations now let's dive into the properties of attributes each attribute has a domain and the domain is the set of permissible or possible values that a attribute can take like numbers strings etc attributes should be atomic it means they are indivisible you won't split a telephone number into smaller parts within a single column or even names or family names finally we have null values these null values represent missing or unknown data in other words a null value is neither an empty string for character or the date time data types or it's not zero for numerical data or types here we can see an example of relation the table has four attribute ID name department name and salary each attribute has a domain this is the domain for ID possible numbers that we can assign to ID possible name or possible department that we have here or salary that we have here name this name can get only these values department name can get values including possible department in a university for example let's formalize things the attributes are denoted as a1 a2 up to a n representing the columns of a table then we have relation schema this is a blueprint of a relation we write it as r a1 a2 up to a n listings all its attributes for example the instructor relation has attributes like ID name department name and salary this schema defines the structure of table before we even add data it's like the architectural plan for our database here is where we can connect the schema to actual data so a relation is a set of n topples where each tel is a row or record and each value a i a a1 a2 a3 belongs to the domain of the attribute that we have the relation instance this is the snapshot of data in the table at a given time you can say it's current value each tpple is a row or record like uh record for one instructor in a table we also define two metrics here degree and cardality degree is the number of columns in a relation and cardality is the number of rows or topples in a relation these terms help us describe the size and shape of our data here we can see an example the instructor relation notice that the order of row doesn't matter which one is first after doesn't matter whether Einstein is the first or another one is the first it doesn't matter the table has four attributes ID name department name and salary and we have here like 12 records so four attributes 12 record each row is a topper right this is we call it as a topper row or record This unordered nature simplifies storage and retrieval focusing on the data itself rather than its SQL why do we use relational model it's simple data in tables is intuitive it's offer structure independence meaning the structure can change without affecting applications it's easy to use for users and developers alike with strong query capabilities through language like SQL it provides data independence separating logical design from physical storage and it is scalable handling large data sets efficiently these benefits make it corner store of database system no system is perfect and the relational model has drawbacks complexity raises when managing large interconnected databases relationship and queries can get tricky isolated databases mean that data might not integrate easily across different system leading to silos while these are challenges they are often mitigated with good design and tools but it's worth noting these limitations let's get mathematical a relation can be represented as a triple TL T name H and E t name is the name of our table h is attributes A1 A2 A3 up to A N and E is records like for example here we say 2222 Einstein physic number this is one record this formal notation ties back to our example table showing how the relational model is both practical and theorically grounded in databases keys which ensure data uniqueness are very important first we have a super key it's a set of attribute that uniquely identifies each like for example ID or ID or name for the instructor table then we have candidate key this candidate key is a minimal super key meaning no subset of it can still uniquely identify topples so here we have ID is a candidate key because it's enough on its own while ID name includes an unnecessary extra attribute like name is not required because ID is exclusive building on keys the primary key is the chosen candidate key to uniquely identify topics like ID in case of instructors or username in case of emails then we have foreign key a foreign key links tables it's a primary key from one relation like department name in table department that appears in another one like for example in instructor table so we call referencing relation and reference relations the referencing relation that our example instructor use reference relation department to connect data ensuring consistency across table so when we want to connect instructor table and department table in this case our instructor table is referencing relation and our department table is referenced relation in here we can see a schema diagram for university database how many tables we have text table student table advisor department instructor and many tables for example a student table has ID name department name and total this ID is the primary key here right then we have added to the department department is here primary key here but in here it is foreign key because it's connecting two tables together now we explore how to query data relational query language come in two flavors procedural and nonprocedural in procedural it means stepbystep instructions and nonprocedural or declarative specify what you want not how then we have three pure languages these are relational algebra operations on relation and then we have topple relational calculus topple based logic and we have domain relational calculus which is domain based logic these form the theoretical basis for practical language like square in relational databases we work with several operators including selection projection union different joining cartisian product renaming etc the first one is selection operator this is used to filter rows based on a condition so we have a relation r here a b c d now we want to do the selection selection it says a is equal to b and d greater than d greater than five it means a and b should be equal and this should be this is end operator right so this one a and b are same equal and d is also greater than seven so this will come to here this one a and b are not equal so we not this one a and b are equal but d is not greater than seven so not here this one B beta and beta same and 10 is greater than five so this one will come to here it's a kind of filtering then we have projection operator this is selection of columns right so the project operation select specific columns for example we have relation R and we want to select so in here we have A B and C out of these three columns we want to get only a and c we show by pi in here we show the selection by sigma in here we show by pi so a and c it means we don't need b so a and c will be here and also because we have here repeated so we will consider this one only one one and one right this is how projection works then we have union of two relations this union operation combines topples from two relations for example here we have R and S right so R and S when we say union it means all of them or you can say or operator right so alpha and one will come here alpha and two because same it's common so it will come once only beta and one beta and three all together or you can say union it's a way to merge data from comfortable relations ensuring no repetition then we have set difference this set difference finds in R that are not in S and we show by minus so we say R minus S so whatever is in R but not in S so alpha 1 is here but not here so it will come to the result alpha 2 is here it's here so it will not come to here beta 1 is here not in here will come to here how about beta 3 beta 3 is in S not in R so it will not come to the R minus S the intersection operation finds topples common to R and S so this is uh similar to end or you can say intersection right so it means the record must be in both of them right so alpha one is not in here so it will not come here alpha 2 is in both of them so it will come to here beta 1 is in here but not in here so these two will not come to here intersection highlight share data defining our focus to what overlaps between relation then we have cartisian product this cartisian product combines every toppel in R with every topples in S creating a large table what it means we show by this multiplication sign or times so for every record in R all the recorder in S will be repeated so we have alpha here and in here alpha one and all the relations of the second one are repeated only for alpha 1 then we have beta_2 so beta_2 is here record of s table are repeated here so in here for for cartisian product sometimes we want to do R and S and we have a same column BB here right in this case we write R dob for this one and for this one we write S.B B alpha 1 and all together so alpha RP so alpha 1 is here all are here therefore this one all of this one you can see this is cartesian product the rename operation we show by row XE assign a new name X to a relation E right we have a relation R here and we want to rename E right so we say R multiply cartisian product of a copy of it but with the new name S so you can see here R A RB this is the previous one just we make a copy of R and we name it as S so S A and SB then we did cartisian product for each row of the table all the row of itself are again here right so just we copy paste R and we rename it as is S this is useful in queries to avoid confusion when using the same relation multiple times we can combine operators so for example here we say cartisian product of Rn is then out of that one we want to select the three course where a is equal to C so it means we will do first a cartisian product of RNS then out of this one whenever A and C is same we will take out so this one this one then this one then this one will come to here and because this is repeated so it's one time only this is one time and this is one time the natural join we show like this this uh bow tie something like this this operation we show the natural join merge R and S based on common attributes for each pair of toppels if they match on these shared columns combine them into a new toppel unlike cartisian product it only keeps matching pairs reducing redundancy this is a key operation for linking related data across tables so here is natural join in action r and S so we have A B C D and we have BD E here so these two are the same right this B and D are the same then we say R both S or natural join S right in here this operator match topples where B and D are equal for this natural join first we do the cartisian product then whenever RB and SB are the same and also RD and SD are the same we will take out selection then from the result we will select A RB C RD and E only one of them we should we avoid repeating so after doing the cartisian product we take out whenever RB and SB are the same so this is RB and this is SB this is D and D same so it will come here alpha 1 alpha A and alpha so these records came here then it was cartisian product right alpha 1 alpha a and gamma right etc we can go so this is the expansion part of the natural joint first you do cartisian product then out of the cartisian product we will select the records where r dob is equal to s do.b and r dot d is equal to sd then we will take out the columns of A R dot B C R dot D and E so in Excel you can do the natural join like this first of all you do cartisian product so this is our R and this is our S right so first of all we do cartisian product so out of the cartisian product result it will be something like this so for example a this is one table one for the first row you can see we have repeated all our table SB SD and E you can see here for the second one we do the same for the Y we do the same for A and for C then whenever B2 it means this one is equal to E2 this one we take out and also whenever this one is equal to this one then out of this one we will selected a column R dob C R dot D and E this is how natural join works once again I will do cartisian product then I will select the records when R dot B is equal to S.B and R dot D is equal to S.D then I will select columns A columns R.B column C column R dot D columns and E you can practice this one in Excel to better understand how it works back to query language a query takes table as input and also the output is a table beyond algebra we have aggregate operations like sum that total values average average of them max the highest value and mean the lowest value these extend relational capabilities letting us analyze data like calculating average salaries in the instructor table so here is a summary of what we studied so far we had selection operator the symbol was sigma and for example I want to take out the record in the instructor table where the salary is more than $85,000 then we had projection operator we show by pi and in here we select columns it means in instructor tables I'm interested in ID column and salary then we have cartisian product we show by times like cartesian of two tables that we have union it means for example you do projection of two columns in two tables name and student name in instructor and name in student then we had set different visual by minus and in here we are interested in columns that are available in the first one but not in the second one and in actual join we show by both high and in here we do the cartisian product we select the rows where the common attributes are equal we select the unique interested columns to conclude the relational model introduced by Edgar code revolutionalized data management with its structured table based approach through this presentation we have explored the relational model concepts like relations attributes schemas and instances and we have seen how keys like primary key and foreign key maintain integrity we have also delve into relational algebra with operations like selection projection natural join showing how to manipulate and query data effectively the model's advantage like simplicity scalability and query power make it a bedrock of modern databases despite challenges like complexity this foundation equips us to design and interact with database efficiently as a skill as relevant today as it was in 1969 thank you so much for your attention please feel free to ask me if you have any question by leaving a comment below this video and see you in the next lecture