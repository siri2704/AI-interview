so what is data is we have various kinds of definitions but then know coming to this course what I mean by data is we don't want the operating system to be very huge database management system so dbms is set of programs right it is actually so coming to computers these are nothing but the data which is stored on the computer and these are the set of programs which are used to manipulate it this particular entity has to participate in at least two and whenever you write it in the exam you should be able to know do that mapping informally you can think of it as a table so what is the relation it is simply a [Music] table uh this course mainly deals with uh you know these few things in order to understand this course you have to understand clearly about the meaning of these things first one is data so what is data is we have various kinds of definitions but then you know coming to this course what I mean by data is it could be any fact that can be recorded and stored right so data is any fact that can be recorded if you can record it that's just a data okay according to this course and if you want to see any examples about data um you may think of data as some text right your you know your facts can be written in terms of some text like names name is a fact isn't it or some numbers like your address phone number and all or it can be even some images right images means the pictures that we take right that could also be a data or it can be videos like you know right now you're watching right videos or there are various like speech so these are all data if they can be recorded then it is data and then from this we are going to Define database so a database is collection of related data which means if you if you take a collection of text or if you take a collection of numbers or if you take collection of images or if you take collection of videos they are all called as you know database so database you know according to this definition of this course see whatever terms these are they have various definitions you can find them in internet but coming to this course these are defined this way okay so database means it is actually a collection of all these uh related data right so it is collection collection of related data okay now uh you can you can you know traditionally the databases have been applied only for the data which are either text or you know numbers for example if you want to store something about a student right then you are going to store the name which is text and maybe his his and maybe his marks and maybe his address right and all these are going to be uh you know text and numbers or maybe if you if you want to reserve some ticket right online then how is that you're going to do it again the text and numbers are going to be used traditionally it has been numbers and uh you know text so there are various types of databases now one type of database will contain only text and numbers and it is also called as traditional database okay and and recently we know with the with videos being uploaded and downloaded at a very frequent Pace there has been a database created which is a database of you know videos or or they might even contain database of speech or they might contain database of songs or movies anything like that and that is called as multimedia database right multimedia will be present in that and you know uh recently you have seen this there has been lot of you there have been lot of these satellites and the satellites are going to take the images of Earth and they're going to send you back or even we have we have sent many rockets and which are going to take the space space fos right so they are all called as you know geographic information systems which will contain mainly images right so depending on what we are trying to do there are various types of and there are even you know real time dat databases so realtime databases means you know these These are generally used in the production right or if you have a store if you have a supermarket and now you know you are selling some Goods you want to keep track of how many how many items are remaining of each type so that you want to place some order if if the entire stock is over right they are all called as real time so there are various types of databases and uh you know sometimes we have other than databases you know if the database size is going to be very huge then uh it is called as data warehouse so data warehouse is also a kind of database H so what is the main difference between the database and data warehouses data warehouse is also a kind of database in which the data is going to be very huge and historical which means we are going to have data stored about a company for the past 100 years and then we'll want to see it or we want to store uh let us say the uh share the stock market the stock stock market rates and all and we want to predict the future by looking at the past for the past 100 years if you are looking at that huge data 100 years data right then it is going to be historical data and is going to be very huge in that case the database is also called as data warehouse right so these are the various examples of databases so are you following it data is just a fact which can be recorded and these are all the examples of data and database means it is a collection of data which is related right for example you know YouTube is having this multimedia database right or VI is having multimedia database right and NASA is having GIS right geographic information system database so which means they are going to have the data which is related to various things but then once you decide upon some database you have to put only the things which are related to the database right so every insertion and deletion will be uh only the only concerning the data which is related to what you have defined okay and then um once you have come up with the database you are going to store it on a computer mainly see earlier databases were managed manually then what is a database a book you can take it as database then how do do manipulate it using a pen right because it is it was man managed manually right and later now we are going to computerize everything so every database is currently present on the computer now whenever you have a computer and data present on this there should be some programs which should be defined isn't it you have to Define some programs right and those programs should typically be um able to do this so like it has to Define which means you have to define the data types the structures and data type means integer character string like that okay you have to define the data which are which you are going to place in that and then maybe you have to construct construct the database using the software right so constructing means uh how are you going to place the data on the hard disk or the storage device and then manipulate so manipulating means you know that adding and deleting data from the database so whenever you have this database now you need this software which should be able to define the database construct it and maybe manipulated right so for this reason we had to write some programs and know earlier operating system used to provide some some some sort of you know provision to do all this but what happened is putting this burden on the operating system is going to be very very you know uh constraint and in the sense we don't want the operating system to be very hug right because Boot time is going to be very high so we don't want to put this button on the operating system as well operating system is already managing many things right and and moreover if you give this responsibility operating system the problem is whenever you want to go to your database you are supposed to call the operating system and operating system whenever it is called it will it will switch the switch from user mode to Kernel mode which is very secured right and in most of the cases we don't need that much functionality we want the fastness right therefore users whoever are defining the database they just want to access the database very fast they don't want many services which are know given by operating system in that case a user will write his own programs which will be able to access his own database and everything will be running in the user mode right and the set of programs which will be doing all these things on the database which is defined is called as database management system so dbms is set of programs right it is actually a set of programs which are used to Define construct and manipulate the database that is what you can understand by dbms the term dbms so dbms is just software database is the data collection of data and data is any fact okay and what are the various types of dbms you have so there are various companies which are providing different types of databases we shall see all of them okay one by one when we go into the topic right and then uh once you take this database defined and the collection of program s which are going to act on that database see it is not that you have one particular database system which can access any data depending on the type of data the database system the database man management system also has to vary right therefore the collection of database and the database management system these two are generally combinedly called as database systems d BBS right so database is the collection of data and it is set of programs so the data plus the programs which are used to you know manipulate this data is collectively called as database systems so if you want to understand it you can take take think of it this way database you can think of it as a book one book and database management system you can think of it as a pen right in the real you know without computers right so coming to computers these are nothing but the data which is stored on the computers and these are the set of programs which are used to manipulate it and combinely they are called as database systems right okay uh whenever we design anything we have to first come up with the models for example I'll just tell you a correlation uh see before any civil engineer he constructs a house he's going to show you some model isn't it that is called as a blueprint sometimes that blueprint will be you know uh what they do is they will write the blueprint in the chart isn't it see uh before they do anything they'll design some chats uh if you have that subject of I don't know that subject name some we are supposed to have one engineering drawing subject I think right so in that subject you might have constructed some charts like top view side view and uh like that right so when you are going to have that you know so you are going to first uh the engineers they are going going to design some chart okay but then when they show you this uh you know the the model they are not going to present you with the chart because you might not understand the technical details like they'll be having some meters they'll say that it is the top view this is the you know front view like that you'll you'll not be able to understand it that is why what they do is they'll actually uh build a small diagram of the house I mean small model of the house isn't it so with with brick and stone they they'll just design and mimic a small model of the house right so like this they will show you actually how the house will look like like they'll put everything and they'll show you that right even though they are doing it on the chart and then finally the main project will be done right finally the house will be constructed therefore there are actually three levels of modeling done and this first level of modeling which na users like you and me if you don't have any knowledge about civil engineering if you have to understand it you'll never understand the charts right but if you if they show you the real model of the small model of the house uh then you'll understand it isn't it then it is this is called as high level view or or let's say conceptual view right and then they are going to use some charts right that is called as represent representational view or representational model and the final is implementation right similarly here in software also while we design the software Ware we have various models and like software this database also while it is being designed we it goes through various levels of modeling and the first level of model is high level modeling or conceptual modeling so this is mainly used I know in order to explain to the people who really don't know anything about how database is implemented for example let us say you are the database uh designer okay uh which means you want to provide the datab system as an engineer to some let us say some school and now the you know the head of the school has called you to design the project and you you'll be you'll be talking with the head of the school but then you should not talk about the SQL with him isn't it he'll never understand what SQL is and what is a record and what is a relation right so what is the best thing is you use some diagrams and then show him what you are trying to put in the database right so that kind of uh you know viewing is called as high level or conceptual view it will be mainly helpful when you're talking to people who don't understand anything about what you're doing right so it is similar to this you know house building model right so here the most uh what we do is we use some diagrams like you know we say we use some diagrams for entities for example uh we Model A student by an entity and the student might be having some attributes like his say his name right all those and maybe uh there there be relationships right like a student and course right a student attends the course attends is relationship between student entity and course entity like that if you draw the diagrams and if you try to explain it clearly then that is called as conceptual view right and the conceptual view the most popular conceptual modeling is uh you know ER modeling entity relationship modeling there are various model modelings available but then the most popular is entity relationship model and we have that in syllabus we are going to discuss about entity relationships later there are even enhanced entity relationships and then various other like youil and all but the we are going to follow entity relationship model right so what is the main advantage it will be very clear for a na person to understand it so before you design it it's better that you draw some diagrams and then show to the people who are interested in it so that they'll understand it the communication will be easy that's it right and later representational or implementation model is just like these charts right while building a house the charts which you are going to use that is nothing but the representational so these uh these models are used you know by the programmers right if you understand how the you know query runs SQL query runs or any query programming language runs then you're going to use this representation to represent the database right so this level of modeling generally we use relations relations means the tables we use use generally the tables at this level right so it is also called as you know relational model okay and later we are going to take the table and we are going to implement it right and when we are going to implement it we have to talk about how are we going to take the table and store it in the hard disk or the memory device right then at that point we have to deal about what is the structure of the record how are you going to store it right especially what is the data type and what is the structure and how are you going to place it and when you want to retrieve it how many bytes should you go in right for example uh if a table is represented like this see if an entty is represented like this in high level language then a table will be shown like this as a set of you know some rows and some columns but then you are not going to save uh like the entire table image in the memory right you are going to store it as a sequence of which means maybe if you go record wise you you will play the first record and then the second record and then the third record isn't it then in order to access the third record in the table you might have to skip these many bytes right it is called as accessing so how do you access a record everything that will be discussed by using this physical or lowlevel models right ER model has been used for past many years in order to represent this design this uh database uh maybe if you are comfortable with or if you have gone through this you know uml models at least once you can easily relate this in uml diagrams we have something called as class right so exactly like that we have in you know ER diagrams it is like this in software design no the way uml diagrams are going to play the role in database design ER diagrams are going to play the role of it and various things in you know ER diagrams are one is called as entity so here it's means entity relationship model right ER model means entity relationship model right and in this entity relationship model there are actually you know three things that you should know one is called as entity okay and the other is called as attributes and the other is called as relationships okay so why do we generally use this CR diagram just to write in terms of pictures what is the information we collected just like this software design first we are going to collect the requirements which means we go and talk to the people like what do they want and now they're going to say in words you know they're going to describe what they need then we are going to convert the that you know word description of their needs into this diagrams right and now now in the whenever they speak of something whenever they say their needs there are going to be nouns and the nouns are nothing but the things or the object for example they say person or car or or you know board whatever so every object is nothing but a entity so now when they talk about it when they speak about it when you collect the requirements the the nouns are going to be the uh entities right and then verbs verbs are going to be Rel relationship let us say a person owns a car right owns verb that is going to be a relationship right or a a employee works for a department works for that is going to be relationship right so now an entity is nothing but any object in your database is going to be an entity right and relationship is nothing but any verb which you are going to describe is going to be a relationship and what about attributes attributes are again nouns which describe the nouns for example a person if he is an entity then he's going to have attribute like this he's going to have a name he's going to have some as and you know he's going to have an address right phone number so all these are going to be the attributes right so now entity is nothing but you can think of it like a thing right a thing in our real world which is going to be recorded in our database right and that is what is called as entity and what is an attribute is attribute are nothing but the properties of the entities or in order to better describe the entity we are going to use attributes right so you can think of it as properties properties which are used to better describe these things right for example you can think of a entity as a person right and then how do we describe a person maybe using name right and is and address phone number all this okay and what is relationship is um you can think of relationship as Association among entities how are these things related that is called as relationship how is a car related to a person a person owns the car right or how is the department related to a employee a employee works for the Department right and this is called as relationship relationship is nothing but what is the association among these entities right so it is going to talk about Association right for example what is the association between employee and a department works for so works for is a relationship all right so we have all these three things uh which have to be discussed in detail in in case of year diagrams okay uh so coming to the CR diagrams the terminology is like this you know we are going to use set theory here in this sense uh we talk about entity type and entity attribute it is okay and relationship type and relationship okay now what is entity entity and entity type is we are going to talk about these two things generally entity type right and entity okay so what is entity type is the name or the heading or the schema schema is nothing but the heading for example if I say person person is entity type who is having attribute is name and let us say address okay now this entire thing is called as entity type entity type will describe the heading right it is also sometimes called as schema so schema is nothing but the uh description the heading right and what about the entity entity is nothing but a person who is going to be represented in this entity type itself for example let us say name age is you know 26 and name is some Raju right and let us say address is some address is given now this is called as entity so entity is actually an instance and entity type is the heading right now sometimes it is also called as intention and it is called as extension so if you want to think of it as a set theory right this entire set the name of the set is called as entity type and the elements in this set they are called as entities right and we are not going to change entity types but then we might add and delete some elements into the uh entity type right therefore entities they may get added or they may get you know deleted and at any time the number of elements or all the elements in any entity type is called as state state of the entity state of generally it is also called as if I put all all of them together state of the database got it so even though this is quite you know it is used but then generally people will call an entity type as an entity and entity as an entity type so they are going to use them as if there is no difference actually there is difference okay enti type means just the name and entity means the instance right so in some questions you might have to observe the difference and in general whenever you know uh we we we speak in you know during the explanation and sometimes use entity and sometimes use entity type there you don't get confused from the context it will be clear got it and the same things will apply even for relationship also right relationship type and the relationship itself so relationship means it is actually an instance and relationship type means what is its heading schema right so schema is nothing but the heading the uh you know how do you represent it okay and now in ER diagrams we don't use really entities we use entity types which means we don't really show you everything that is present in the database we don't uh we don't write a set diagram and then we don't put a point for every element present in it we are going to represent it in a shortcut just using the entity types therefore if you look at any ER diagram you are going to only see the schemas the headings right not how many elements are present in this and not any set diagrams we are going to make it you know keep it as simple as possible the main intention of this diagram is to help the communication between the technical designer of the database and the na user who doesn't know anything about database he is just going to say in words and you are supposed to capture those nouns verbs and you are supposed to put them in the diagram and a refinement has to go on and for the refinement to go on you have to you are supposed to show this diagram to again the users and they are going to say see this part has to be improved or you know this entity is going to have even more attributes or they might even say some constraints that you are again supposed to capture and then and again refine it all right so this this is actually a cycle this cycle goes on for some time okay so attributes are used to describe either entities or relationships even better which means they'll give you more description about what we are representing right for example the more attributes we have the better information we could get for example I'll let us say person you know name name is an attribute is maybe address phone number all these are attributes the more attributes we keep on adding to an entity the more information we get for that entity and know the better way we could describe it so attributes are actually going to increase the way we describe an entity and it is very useful in terms of you know queries okay later we shall see that why attributes are important but for now let's say attributes are useful right and they are going to be main use of it is describing something okay now what are the various types of attributes is there are various ways I'm going to classify attributes so let's classify all of them and and then we shall describe and then we shall discuss about what is the relationship between one classification and the other right so let's take the simple one assume that person is an entity right and now person will be having a name these are all the attributes right name is an attribute which will describe a person and maybe AG is an attribute right and it it will even better describe a person and maybe address is an attribute maybe phone number is also an attribute right now let's see uh what does it mean first one is we can classify attributes as simple attributes and composite attributes so simple and composite means you know simple means it cannot be divided further composite means it can even be divided further for example if you take name we can divide it further like you can say a person is having first name middle name last name right so even name can be divided into composed of three right first name middle name and last name got it uh now what do it mean a actually name is an attribute which is composed of many attributes right that is why it is called as composite attribute because it is composed of many attributes and these are called simple simple attributes means they cannot be divided further for it so they are no they cannot be divided further that is why they are called simple and sometimes what happens is even though we have an attribute an entity might not have any value for that attribute for example you might not have a middle name you might have just the first name and then last name but then in order to save your data into this uh particular entity what we are supposed to have is we have to fill the entire information right then what we do is null values we introduce null values to say either the value does not exist or the value is not applicable right so what is the main main difference between not applicable and uh you know does not continuous for example phone number phone number is applicable to you but you might not have a phone right which means it does not exist not applicable means you might not have any middle name at all that's why this field is not applicable for you either if it is not applicable for you or if it doesn't exist we are going to use uh you know null values okay uh so here the main difference between composite and simple is composite is a collection of simple attributes and simple attributes cannot be even further divided so name is a composite attribute which is a collection of first name middle name and last name and either first name or middle name or last name cannot be further divided okay and next one is single valued attribute versus multivalued attribute so single valued and multivalued means you know uh just take an example for know let us say phone number a phone number may be multivalued attribute the reason is some person might have more than one phone number he might be using more than one phone number maybe one is a deli number and other is Hyderabad number something like that right then what happens is if you have two phone numbers then the field that attribute may be defined as multivalued attribute which will take more than one value right so example is phone number or maybe some some people may be having two houses right then maybe he must be having two house addresses right therefore an address can also be a multivalued attribute what about is is cannot be a multivalued attribute isn't it at any point of time a person will have only one is right and for most of the celebrities it is going to be constant right all the time anyway is is a single value attribute whatever it is it has to be only one value you cannot say that I am 10 years old and I'm 100 years old right it it has to be either 10 or 100 so it cannot be multivalued so single valued means we are going to have only one value to such an we are going to assign only one value to such an attribute we'll never asend more than one values right multivalued means it can take more than one value at the same time right and what about stored stored and derived means we are going to store some information in our system and then others we do we don't store them whenever they are required we derive them right for example I can have date of birth right then uh depending on the date of birth I can actually derive age right therefore I need not store is I'll just store date of birth and whenever it is required depending on the present date and the date of birth I'll just derive the age right therefore in that way age can be you know a derived value attribute and date of birth can be a stored attribute all right so now if a if a attribute happens to be one of these categories it doesn't mean that it cannot be the other one for example uh you know no this uh let's take this name name is a composite attribute right as well as name is a single valued attribute because a person can have only one name he cannot have more than one names even though the name is containing many subp parts it doesn't mean that a person is having many names right so at any point of time he's going to have only one name that name itself is a combination of first name last name and middle name right therefore this is actually composite as well as single value attribute right and what about is a is single valued attribute you have only one value but it can be derived right therefore it is single valued as well as derived and what about address address may be a you know address may be either single valued attribute or multivalued attribute right so let us say address is multivalued attribute no in our system that that all depends on you the designer how you want it to be right and while designing it you can have it either to be single valued or multivalued let us say you defined it to be multivalued attribute then what happens to address address is a person can have more than one address right and moreover the address itself is a composite which means you know street name city name country pin code so address is actually composite and a person may have more than one addresses right then it is a collection of both multivalued as well as composite attributes right so such a attribute which is a collection of or a combination of multi no composite and multivalued it is called as complex complex attribute complex attribute means it is it is having many fields as well as the values are also many right so composite means a collection of sorry complex means a collection of composite and multivalued right so maybe you can even make this uh phone number also as complex so if the phone number is going to contain STD code and the telephone ID and a person if is if is going to have more than one phone number then it is multivalued as well as composite composite means containing of two attributes all right and date of birth date of birth is going to be single valued and it is stored attribute it cannot be deriv it has to be stored right so the main way see I want to categorize attribute to be either of composite or simple or like this or like this but then it doesn't mean that all these are mutually exclusive a single valued attribute can be simple attribute like that okay so anyway they are going to ask you you know by by specifying everything they'll specify everything and they'll ask you what type of attribute you know is best suitable for this and let us say they'll you know in the description in the verbal description they'll say this a person in our database let us say an employee an employee in our company uh can reside at any time in Two Flats uh one is in one city headquarters and other is in his Branch right now what should we Define the address field to be address attribute to be a composite complex multivalued single value like this right so if they even say that address is going to contain uh you know street name the street number and City pin code everything then you have to derive it this way see so let us say first thing is they are going to describe an employee is going to reside in two places right then what is the address address attribute going to be then the address attribute is going to be multivalued right or they will say you know an employee is going to have an address and address can consist of you know Street number pin code City Country everything then what is the address going to be address is going to be uh you know composite and then they'll say an employee is having two addresses and address is going to contain all these fields then what is address going to be it is going to be complex got it let's talk about relationships a relationship is nothing but uh you know Association among entities what is relationship between you know two entities that is going to be decided by the relationship right so how do we get whether we have to put a relationship or not again from the description right so in the requirement analysis phase we are going to get the verbal description in the description wherever you find a verb that is going to be translated as a relationship right let us say um you know while you have collected this uh uh requirements let us say that user said that an employee works for an uh in a department now employee is a uh entity and department is an entity and works for his relationship right let's take an example and see how it looks like um say this is the entity set and this is the department Set uh this is the employee entity okay and this is the department right employee entity type and Department entity type this is employee set and this is the department set now they said that in the verbal description let us say the know the requirement analysis is like this in the requirement analysis phase they clearly mentioned that every employee works for a department okay and a department can have many employees right and let us say one more constraint is new Department need not have any employee all right if this is what you have written down which means in your conversation with the users as a as a database designer when you are collecting the requirements you know you have joted them down and they said that every employee has to work for definitely one department and exactly one Department okay every employee works for exactly one Department which means he he cannot work for more than one Department exactly one department and a department can have many employees and a newly formed Department it need not have any employees right then how are you going to have the relationship so choose a meaningful name right so since I'm writing the employee here and I'm writing the department here right writing works for makes sense that's it that is the meaning of the name right so now an employee works for the Department if I would written Department here an employee here then what I'll write is a department employees an employee right so name you can choose it depending on the placement it it has to be meaningful that's it there is no hard and fast rule you can even have you know some name for here like a b c but it doesn't make sense you have to make the ER diagrams as as readable as possible whoever even the na user sees it he should be able to understand what you're trying to do okay now um let us say we have employees like this E1 E2 E3 E4 E5 E6 right let me represent using these dots these dots represent each dot represents an employee right and let us say we have various departments um D1 D2 D3 like this okay three departments now every relationship here in this relationship type this is relationship type this is employee type and this is the department type right so every every relationship in the relationship type is actually an association between employee and Department right so how is it if employee E1 works for Department D1 then we are going to join these two in this relationship type in this relationship got it therefore this relationship is a combination of you know one entity from here and other entity from here got it and what about this one let let us say employee E2 also works for Department D1 then employee E2 and Department D1 will be combined here right which means this relationship is actually a combination or Association of you know one entity from here and one from here let us assume that E3 is also working for Department D1 then one more relationship will be formed by taking one entity from here and one entity from here right in the same way if these are working for D2 then I'm combining them right so every relationship is formed by taking two entities understood this let us say he is also working for D2 itself now we are going to talk about some few things some few characteristics of the relationship so now works for is a relationship so one characteristic is degree so degree is nothing but in every relationship right how many entity sets are participating so one entity set is employee and other entity set is department so in this relationship we are having two entities participating right that is why this relationship is also called as binary relationship binary right and the degree is two so degree of this relationship is two right and there are various other things one is called as cardinality ratio cardinality ratio um see coming to this coal term it is not actually the same term as you know set theory coal actually cardinality is the number of elements in a set isn't it but here when I talk about ER diagrams the term cardinality ratio denotes what is the maximum number of relationships in which an can participate again cardinality ratio says what is the maximum number of relationships maximum number of relationships in which an entity can participate for example if you look at this even right he can participate only in one relationship and he's not participating in any of the relationship isn't it therefore what is the cardinality of employee the cality of employee is one is it it because every entity in employee is participating only in one relationship right and what about the cardinality of Department see this every department is participating in more than one relationship isn't it therefore whenever a you know the part the department one know one department or one entity participates in many relationships it is many right therefore we use M or n to know denote it therefore cardinality of employee is one and quinalty of department is n got it and one more thing is participation participation or existence participation or existence constraint so these two are called as structural constraints structural constraints okay now what is participation is um minimum so when cardinality says what is the maximum number of relationships a entity can participate this participation says what is the minimum number of you know uh relationships a entity can participate sometimes this participation is also called as minimum cardinality cardinality is nothing but maximum and sometimes when it is also referred to as minimum cardinality because it discuss about how many minimum relationships a entity can participate right now if you watch this in this one what is the minimum number of you know relationships in which each entity can participate each entity entity has to participate in at least one isn't it therefore minimum is [Music] one right and what about this one the minimum number of you know uh entities in which it can participate is actually zero the reason is if you look at this newly formed Department D3 it is not participating in any of the relationships therefore participation is zero are you understanding this so the degree of this relationship is two because in this relationship two entities are involved and then cardinality is the maximum number of you know relationships an entity can be present so the maximum number of relationships that depends on the you know type of verbal specification see how did we derive this we derived this everything from the verbal specification of the you know this requirement analysis they said that every employee has to participate in exactly one has to work for at least one and exactly one Department that is why the cardinality of E1 is one I mean this employee is one right and what about the cardinality of this one they said that a department can have many employees therefore the maximum number of relationship this this can participate is n got it and now what about the minimum that depends on whether they are participating at all or not right if you look at this we have a constraint saying that uh you know at least every depart every employee has to work for at least one department or he has to work for exactly one Department which means there should not exist any employee with who is not working with any Department right that is why it is also sometimes called as existence constraint which means the employee is having a constraint of existence he cannot exist if he shouldn't if he doesn't work for a department right so from that we got the existence you know constraint to be one here and what about this here I got zero because they said that a new Department need not have any employees right so from the verbal description you are supposed to draw everything right in the exam they might give you this entire verbal description and then they'll ask you what is the cardinality What is the participation or what is the degree of it now this is this is all about you know this entity type and entity set representation but coming to the ER diagrams we are not going to use these sets right we use completely different representations generally entities will be represented by rectangles and relationships will be represented by diamonds right so let us say this is the employee entity type and this is the department entity type and this is the works for works for relation right so one way to represent it is one one popular way or you know most of the cases we are going to represent it this way see we know that cardinality of employee is one right and the coordinate we know that okay so we we know these two things one you know coal of employee is one which means the maximum number of relationships in which an entity of employee participate is one and the maximum number of relationships in which a department can participate is n but when we are writing this we will not write one and N here we write n here and one here okay even though Department coal is one and employee cality is here it is n and it is one we are going to write n here and one here and we are not going to write anything here got it so this is how it is represented so what does it mean Department to employees is 1 is to n ratio the coity ratio from Department to employee is 1 is to 1 is to n what does it what does it mean Department to employee is one is to one to many function it means that one Department can have many employees one to many right and what about the participation the participation is department is not going to participate in a relationship which means it is it is not guaranteed that every department is going to participate in a relationship right why new departments need not have any employees but then every employee has to participate in a relationship because every employee should work for a department in that case we are going to write like this right so if it is total total participation we are going to use double lines and if it is partial participation we are going to use single lines what is partial if some of the entities are not participating in the relationship then it is called partial this is called total participation what is total participation if all the entities of this set are participating in the relationship then that is called total participation right and this representation is also called as cordal ratio single line double line single line double n representation of ER diagram it is it is quite popular and used used at many places and one more representation which is also popular is this one without using single line double line we use the minimum maximum representation the same ER diagram can be represented in other way like this so one side we are going to have employee and other side we are going to have Department entity and we are going to have a relationship right and this relationship is works for okay now we are going to have within brackets on either sides what is minimum and what is maximum right so on one side I'm going to have minimum and maximum minimum and maximum right so here see this what is the minimum participation of this minimum quality of employee every employee is going to participate in at least one relationship I already told you right see why because every employee is supposed to work for at least one Department that is what is given therefore minimum part minimum coordin cordal is 1 here right and what about the minimum cality of Department every Department is supposed to have you know we need not have any employee at all therefore minimum cordal is zero here right and what about the maximum quinalty here and every employee can work for any employee can work for only you know maximum of one Department therefore maximum number of relationships employee can participate is one what about Department a department can have many employees so maximum number of you know relationships a department can participate Isen right so this is called as minimum maximum representation minan Max representation got it and both are quite popular so in exam they might give you anything right and in you know this is easy to draw but it it can represent more information like you know sometimes what happens is this one can represent only partial or total and this one can represent if it is minimum how many is minimum for example let us say an employee has to work for minimum two departments right then we are we are going to represent two here got it so sometimes in minimum maximum representation we can even represent more information compared to this single line double line representation because if I have minimum you know coordin ratio as let us say two and maximum coordin ratio as n or uh let us say n right then what does it mean it means that this particular entity has to participate in at least two right now if I represent this in terms of single line double line representation even though the minimum number of you know participations is two it will still consider it as a total participation and it will just represent it using a double line so more information can be represented using minimum maximum you know representation compared to this single and double and representation but both are quite popular understood this is this is one type of relationship which is actually 1 to n so only confusing thing here is you know when you write this one this type of single and double L representation even though you know the maximum participation or the cordal of department is n right and the cality of employee is one while you write the numbers you write one here and N here because it looks logical that way see employee to department is many to one relationship isn't it many employees are related to one department or Department to employees one to many relationship therefore uh you know it will be easy for you to understand if you write that way even though this is the one who is participating in you know maximum one and maximum n while we write the numbers we write it this way so that it will be easy for anyone to read it and understand it got it um yeah these are the important points and degree is too right sometimes what happens is along with this entity types we even give the role name in every relationship every entity place a role for example this employee entity plays a role of employee and this department entity plays a role of employer isn't it department is employing an employee therefore or you can even give it a role name right so role names are not very useful in case of this kind of relationships sometimes we have recursive relationships which means a relationship will be defined on same set two times in that case the same set is going to act as two different roles in that case we are going to have role names let's see one more type of relationship possible among entities let us say there is again employee entity set this is employee entity type and this is employee entity set and there is Department entity type and Department entity set okay this is the department entity type and this is Department entity set now uh there are many employees here right and there are many departments here and from the verbal description of the uh you know requirements let us say you have inferred or you joted down this few requirements and they are like this every Department should have should have a manager okay and every uh should have a manager and only one manager should be there and only one employe manages a department right so what does it mean now for every Department one of the employee is going to act as a manager right and so therefore whenever you see this manages right the word manages the verb you'll understand that there has to be relationship and now this relationship is nothing but Association right so we are going to create a relationship and the name of the relationship is managers manages right so employee manages Department right so why did I write this manag as the name just it has to be readable and meaningful that's it you can come up with any name right but then come with meaningful names right and now there are various uh relationships and every relationship is nothing but a association between these two right so uh for every Department there has to be a manager right let us say there are four departments and for depart Department D1 Department D2 Department D3 Department D4 and for Department D1 it is being managed by employee E1 then this particular relationship is going to have you know association between this particular entity and this particular entity right so what is the meaning of it employee E1 manages Department D1 and employee E2 say is managing Department D2 right and some employee other right and now it is like this E1 E2 E3 E4 four departments are managed by four different employees and what let's say had one more constraint that any employee can manage only one one Department which means one employee only one employee manages a department and and an employee can manage only one Department right so if this is the case then no two employees are going to No One employee is never going to manage two departments right now let's see various factors here so what can you say about the degree of the relationship what about the degree how many entities are participating two entities so one question is what is the degree right degree is two then what about the cardinality cardinality is maximum number of relationships in which each entity can participate or in which an entity can participate so what is the maximum number of relationships in which this entity can participate only one right why because an employee I know uh an employee can manage only one Department therefore the maximum number of relationships one entity here can participate is one what about this one a department you know has to be managed by at least one and exactly one employee right that is what is said so a department has to be managed by at least one and exactly one employee and so the maximum cardinality is one so cardinality itself means the maximum number right so the cardinality here is one and the cardal here is one right this is the cardinality ratio fine and what about the participation or existence so participation or existence is the minimum number of relationships any entity can participate if you watch this there is no there is no hard and F rule that every employee has to manage a department right there can be employees who are not managers right in that case what happens there will be some uh some entities who will never never participate in any relationship therefore what is the minimum number of relationships an entity here can participate in a relationship zero right so minimum number of relationships and entity can participate is zero what about this one the minimum number of relationships and entity can participate and department and can participate um I told you that every department has to have an employee right a manager therefore if there is if there is a department there will definitely be a manager who is managing it otherwise such a department will not exist right that is called as existent constraint or you know participation so what is the participation here one it means that every Department should have a manager all right now let's see how to represent it in both the ways so one way is that single line double line This is employee and this is the manages and this is Department right so I told you how to write the coordin ratio so I'm I'm writing single L double line okay how to write the coity ratio whatever is the actual number you just reverse it and then you write it okay so what is it it actually one to one one to one so it doesn't matter write one here and one here it is a one to one relationship the reason is maximum coordin is one and one you got it and what about the minimum every employee need not participate you know in the relationship but every department has to participate in the relationship therefore total participation is here partial participation is here whenever participation is one it means that it is total participation whenever participation is zero it means it is partial participation right so here there is total participation and here there is partial participation and this is about one representation single and double and representation what about the minmax [Music] representation so minmax representation we need not use the lines at all I mean single line double line we can simply represent it this way so what is the minimum and maximum what is minimum participation of employee zero what is the maximum participation of employee one what is the minimum participation of Department one what is maximum participation one right so this is an example of one to one relationship right so um you know again I didn't write any any role about it right if you had to write a role what is the role of this this particular uh you know entity type in this relationship manager so you can even have within the bracket the role as employee as manager right and what about the department Department as may be managed right and this is manages so names have to be meaningful okay so questions possible on this will be they will either ask you to you know identify the diagram representing this in any of these forms or they will ask you what is the coordin of this senent right or they'll ask you this single and double L something about this diagrams will be possible right okay let's see one other type of relationship between two entities assume that we have this um again the same employee entity type and this is the employee entity set and this set contains all the entities related to employees on each element know it refers to one employee and let's say there is one more entity entity set and the entity type is uh project and this contains all the entities and each entity here represents a project right and according to the specification of the uh you know function this uh in re requirement analysis let us say you got the information that every employee is is supposed to work at least on one project and he can work on many projects as well as every project is supposed to have many employees and it is supposed to have at least one employee okay so again watch it listen to this every employee is supposed to have is supposed to work on at least one project and an employee can work on many projects similarly a project can have many employees and every project is supposed to have at least one employee right so at least and many at least and many both sides right and now let's define a relationship and you can choose a meaningful name let us say the name is since here I have written employee and there I have written project let me write employee works on project that looks meaningful right employee works on Project that's it and now I have to take each relationship and Associate it with one entity from here and another entity from here see in some sense you can even think of it like this there is one set and there is other set and you are actually taking a cross product of these two sets and a relationship is nothing but a subset of cross product just like in mathematics in set theory you might have seen it right what relationship if no relation What relation is a set a subset of cross product here also a relationship can be actually visualized the same way how you are taking this set and you are taking this set and you form all the cross products which means all the elements possible by cross producting this one and this one right cion product then you are going to get some set from that set you are going to take subset of it that is going to become relationship isn't it now let us say employee employees are like this E1 E2 E2 E3 E4 E5 E6 E7 E8 and the projects are like this P1 P2 P3 P4 P5 P6 something like this p7 p8 right and assume that the working relationships are like this you know project P1 is having employees E1 E2 E3 working on it and project P2 is having employees E2 E4 working on on it project P5 is having employee E5 working on it and project P6 is having uh P P4 is having employees you know E1 E5 E6 so on right let us say this is P3 and P4 okay now how are you going to relate them so there are four projects and these many employees is there any employee left out let us put E7 here and here right so according to the specifications they are saying that every project is supposed to have at least one employee at least one means you can have many many employees can be working on that project and moreover every employee is supposed to work on at least one project therefore all the employes have to be covered see this E1 E1 is at least present here E2 is here E3 is here E4 E5 E6 E7 E8 right so every employee is actually working at least on one project so the requirements are met right now uh let's see how the this one is modeled so P1 E1 is related to E1 E2 and E3 are related to P1 therefore E1 is related to P1 and again E2 is also related to P1 and again E3 is also related to P1 right so I'm forming each relationship using one entity from here and another entity from here right so you might think that why don't I put a line from here to here and then I know these three lines only to one point and then there but actually the relationship is formed by taking one entity from here and other entity from there you are not supposed to form by taking many entities from here from the same set and then one entity from the other side that is why every every entity relationship entity is formed by taking one entity from here and one entity from other side right and next one is see these questions are very simple but if you don't understand them clearly there's chance that you might make some mistake there are very simple to answer especially dbms only thing is the terminology should understand it and I know the representation so the things are very very simple you'll understand it okay now uh next one is P2 is actually related to E2 E4 and E8 so E2 is related to P2 right and then E4 is related to P2 and E8 E8 is related to P2 right and next E5 and E7 are related to P3 so E5 is related to P3 and again E7 is also related to P3 E7 let us say is related to P3 and what about E4 E1 E5 and E6 are related to P4 let us say P4 is here right and E1 E5 and E6 so E1 E5 sorry E5 and E6 yeah E6 is from here this is related to P5 right okay now that is how it looks like got it uh so what is the speciality of this type of relation is so one thing is let's talk about the degree degree is number of entities participating in each relationship how many entities are participating in each relationship two entities therefore degree of this is two right and what about the cardinality cardinality is maximum number of relationships in which each entity can participate so what about the cardinality of this side employe side how many relationships can each employee participate in many relationships right so cality of this one is n what about the cality of this how many relationships is each project participating in many therefore you can write m n here but instead of writing n and n maybe that might lead to a confusion saying that equal cardinality let's write n and m n and M anything which is not either zero or one or you know like this m means any number right generally n and M are used to indicate uh anything great than one so by writing n andm you can understand that it is greater than one what does it mean you know maximum N andm means they can participate in more than one relationships right and what about the participation so participation means total or partial participation so every every entity here is participating at least in one relationship therefore total participation right and what about the total participation here participation here here also every project is at least participate in one relationship total participation right now how can you represent it in both the representations if you say this is employee and this is works on and this is Project the relationship between these two see it is total participation total participation therefore double line and what what type of uh you know mapping is it cardinality m is to n right you can put M here and N here no problem not an issue either M here or M there anything both of them indicat is a many to many relationship right and in case of minimum and maximum representation min max representation it is the employee it is the project and it is Works what is minmax representation for this what about the minimum here minimum is um one and what about the maximum n and what about the minimum minimum is 1 here and maximum is m right you can write anything there okay so that is a representation of various things here and you can even sometimes in the exam they might give you role also in the brackets so don't get confused in brackets they can say you know employee as a some name as a project worker and that one as Employer something like this role will be given so anyway only these questions are possible on this right let's look at a different type of relationship and this type of relationship is actually between uh you know two entities and the entities are same so like recursion so that is why it is also called as recursive relationship I'll just show you what with an example let us say we have employee only and every employee according to the specifications I'm talking about it uh let us say the specifications are an employee is going to have a boss and that boss might have some boss right so every employee is supposed to report to at least one person and we can call them a subordinate and boss or supervisor and supervisor something and every employee is supposed to have let us say at least one supervisor right and uh you know if that is the case right so employee is going to have a supervisor and some employee at least one employee or some employees are not going to have supervisors generally they are the CEOs right and uh every company is going to have all the employees listed even a CEO is also an employee who doesn't report to anyone right now I want to you know represent this particular relationship the the interesting thing about this relationship is both the participating entities are actually belong to the actually they belong to the same entity type which means employee an employee is going to manage some other employee till now we have seen an employee managing a department or employee working on a project which means there are two types of entity types and the relationship is among these two types but for now from now we are going to discuss about this thing an employee is is actually managing some other employee right so it is interesting in that way so watch it even though it is only one entity type I'm going to write it two times don't get confused so if I write it only one time and then put the relationship between them it will be really confusing just to avoid confusion I'm just going to you know elaborate it but then when we when we represent it in the a diagram I'll again combine them right so even though I'm writing this set the same type entity type two times don't get confused it is actually only one entity type I'm writing the same entity type two types two times okay let us assume that employee employee right so this is actually only one entity type but I'm representing it two times right so one time I'm know this employee this particular set you know set or this particular employee type is going to have a role in this relationship and he is going to act as let us say supervisor supervisor means he is the boss right and the other side he is going to act as the other side employee said it is going to act as supervisory okay so it is like B boss and subordinate that is the way I'm I'm using the roles right so this side it is the boss and that side it is the subordinate and now the relationship is you can give any meaningful name let us say the relationship name is supervisors any name you can give supervisors which means this particular employee supervises that particular employees right now there are employees here and other side also there are employees there are employees here right assume that the specifications are like every employee reports to only one employee all right which means you are not going to have two bosses every employee can have only one employee and every employee except one or two or except few are going to have I know the bosses the supervisors right therefore you know you are if you are going to report to someone you'll be reporting to only one that is the meaning of it right so this particular employee is is going to supervise this particular employee right as well as the same employee might be supervising some other employee right and the same employee might be supervising some other employee like this and one one thing is maybe let's not put this one this might have a different meaning in the sense you know if it is even and if it is even you might think that E1 is no supervising E1 itself that is why E1 and E1 we didn't keep it now what is the meaning of it E1 is supervising E2 and E1 is supervising E3 therefore E2 reports to E1 and E3 reports to E1 employee number two reports to employee number one and employee number three reports to employee number one if you want employee number one also to report to someone right let us say somewhere there is E4 and employee number four employee number one reports to E4 or E4 super is E1 then how how is relationship here see this E2 and E3 they are reporting to E1 and E1 is actually reporting to E4 are you understanding this see E1 is supervising E2 and E3 E1 is supervising E2 and E3 and E4 is supervising E1 E4 is supervising E1 that is the hierarchy isn't it so somehow you can represent the relationship on two entity types which are actually the same right in that case it is called as recursive relationship this particular relationship is called as recursive relationship ship what is the degree of it how many entities are participating in every relationship two entities therefore the degree is obviously two degree of the relationship is actually two right the degree is two that is fine and uh what about the cardinality so cardinality of each side so cardinality will actually be derived from the specification that you know requirement analysis let us say from reement analysis the coordin ality you found out is an employee has to no it is not sure that or it is not always uh necessary that every employee has to you know manage someone right and moreover an employee in case if he is managing some employees he might he might manage one or more right then as supervisor how many relationships can each entity participate here as a supervisor an entity can participate in many relationships right therefore the cardinality is nothing but maximum participation so maximum participation is n are you getting this an employee here as a supervisor can participate in more than one relationship therefore the cardinality which is nothing but the maximum participation is going to be in now what about this one supervisory um you know an employee here has to be managed by only one supervisor right therefore it is one what is the meaning of it uh maximum you can be managed by only one boss you cannot be managed by more than one B so how did I get that from the specifications only all right and now next one is participation so participation says what is the minimum number of relationships and entity can participate in so if you're looking at a supervisor is it always guaranteed that every employee has to act as a supervisor not necessary right therefore the minimum which means from this side the participation can be zero I mean the minimum can be zero which means there can exist an employee who will never participate in any relationship which means an employee might never manage any other employee or might never supervise any other employee he's just a you know that bottom level employee right and what about the other one what about the minimum part minimum participation here I mean the participation here every employee it is not always necessary that every employee need to have a boss also right the reason is there might be CEO who is also an employee who might not have a boss who might not have a supervisor right therefore let us say zero so participation here is partial and the participation here is partial got it now how can we write this this is a relationship and the relationship is supervisors okay and on both the sides we are going to to have the same entity type and the entity type is employee right and one side it is going to act as supervisor this is the role on one side and the other side is going to act as supervis right and then what is relationship what type of relationship is it is it 1 to n or n to n like that right what about the cardinality see now we have seen that uh you know on the supervisor side so from supervisor to supervisor it is a one to many relationship right therefore here I'm going to write one and here I'm going to write n are you getting this it means that a supervisor can have many supervisors so it is one to many relationship right now if you want to write the same thing in minmax representation now how many minimum rep how many minimum relationships can super visor side participate in zero and how many maximum can supervisor participate in N what about this how many minimum can supervis he participate in zero and how many maximum can he participate in one right this is the min max representation I mean without these numbers this is minmax representation and with the you know lines it is a representation anyway no nowhere we are going to have total total participation that is why it is just single lines what it it might be no it is it is is actually a different case in the sense there is a difference in how we represent this one with the roles these are called as roles right the role is also represented it it is just a bit different from the ordinary binary relationships right anyway it is also a binary relationship and it is called recursive relationship even though it is called recursive it is still binary only right why because only two entities are participating in every relationship here okay fine at concept level we have already used the year diagrams see there are various models proposed even at conceptual level also but the year models are very popular and even we have ER models in syllabus that is the reason why we are focusing on ER models entity relationship and again this ER models have also been extended to Extended ER models like eer but we don't have that in syllabus so I'm not going to talk about it so let's go on to the next step see I told you that there are various levels right so one is conceptual level other is representational level and other is physical level right now conceptual level is mainly useful at the know requirement analysis phase you collect the requirement and then you draw these diagrams and you show the show to the users and once they say it's everything is fine I mean the way we communicate with the users we should not use any technical terms right so these ER diagrams are going to be very easy so conceptual level ER now let us say everything is okay at er level and you are understood the requirements completely which means they said that yes you know this is what we wanted the you know the users so as a database designer you have consulted with the end users and they said that yes everything is fine according to the your diagrams right now you should choose one of the uh representational model uh carefully the reason is once you choose this representational model to design the database see there are two things here one is database and other is is database management system database means the collection of data right now you are talking about how to represent the data once you represent the data then we are going to use software which will help us manipulate the data right therefore you have to choose exactly or you know you should you should not make any mistake in you know choosing which model you want to use once you choose the model depending on that you'll get the database management system this software uh which will act on this for example see now at relation at uh this representation level we are supposed to choose a model and depending on whatever model we use right we are going to assume that our data is modeled like this so your database will become whatever model you are using here right now depending on the type of datab Base you are going to use the software right the database management system and now every database management system every software cannot access every data possible depending on the model which you have used in the database you are supposed to choose the you know software and who is who will provide you software either you can write the software on your own right but is going to be very hectic that is why what people do is they'll just design the database and then they'll take the you know database management system available in the market generally are various open source database Management Systems available as well as there are commercial database Management Systems available like IBM provides you and TCS provides you and many services companies are also providing databases these days and even Oracle also provides you right so which one should you choose the model uh which data model should you choose it is always better that you choose a data model for which there are lots of database Management Systems available and the most popular database model used at representation level is relational model OKAY relational relational model it is the most popular database model used the reason why it is becoming more and more popular is because more and more vendors are manufacturing the database management or and providing this database management system the software itself you know initially it started with IBM so IBM you know if you use relational database here here IBM was providing system r or know various softwares are there but the earlier version was systemar now that system R software was the know database management system software which you could easily buy and second flexibility is you know after this IBM which has you know initially followed this relational database and provided the database management system later many companies started providing this database man this management system so the advantage you get is if your data is in relational model and if you have bought a software and if you are not happy with that software it will be very easy for you to just replace the software with the other software and everyone will follow the same standards there has been standardization in this area so what do I mean by standardization is I know let us say you are having a company and in this company you have trained some people you have trained them know investing a lot of money to to access the database management system and suddenly if you change the software again you might have to retrain your employees right but then the the good news about this relational database model is if you are using relational database modeling here relational database then relational database Management systems are available and all of them are now having the standardization in the sense you can learn SQL and all of them are written in such a way that they could interact with SQL which means they are all compatible with SQL so your users your employees need not be trained in order to understand the relational database management system itself they can be trained to understand SQL and in fact SQL is designed in such a way that even the first name of SQL is not you know this one it was SQL s c qu L initially it was called SQL right and you'll understand with the name itself what it really means so SQL is Structured English query language sometimes it is also called as simple English query qu means query language so what does it mean just in a English like language you can you can query your database right therefore it is that simple so all the relational database Management systems are now able to understand SQL therefore you need not worry about what type of rdbms you're using as long as you know SQL therefore train your employees in SQL and if you are comfortable with the particular rdbms software from some vendor go with this later if you feel that that feder is not giving you enough support or if he is charging too much for you you can easily know move your platform to some other rdbms without worrying about training part of your employees right so the popularity of you know relational database model is because of various factors it is not just this you know relational database model itself it is because of you know increasing uses see the more people use it the more facilities will be added and the standardization will be done right and if it you know if it continuously happens then what happens is we get more and more benefit being in the platform that sometimes it is also called as lock in people are now getting logged onto this a relational database if you come up with any new model let's say you invented any new new database model and even if you say that your database model is better compared to relational database model people will not move on to that because they have to have various options see I'll tell you this let us say Android is there right now let us say you have invented a new mobile phone the hardware and a new software right and then you said that it is better even compared to it is you know Android people might not go go for it because more and more app developers and more and more apps are available on the Android platform right similarly you know you can compare this rdbms as a kind of you know uh this Android and maybe sorry rdb as a kind of Android and rdbms as a kind of you know App Store now with these many apps available know people are just logged into this because it is very convenient to use it right even if you say that a new model is available and which is helpful they will not move on to that are you understanding this right so the popularity of relational database model is not just because of the model itself it is because of the availability the wide variety of rdbms software available and moreover SQL is becoming more and more powerful so initially SQL was proposed just to query the you know database okay about SQL we shall discuss in about it later but what I mean to say is the SQL itself is becoming more and more powerful since it's in know Evolution now if you look at it Evolution SQL is able to do everything you know that you could possibly imagine initially it was just a query language it has been developed so much that you can do everything and now everyone is every rbms is providing support to SQL and if you want to run rbms you should use relational database so it is a loop completely Loop right and the development is going on over and over for the past 30 years the most dominant database system or database know modeling available is uh this uh relational database other than this there are various uh models used maybe in 1960s and 1970s in 1960s and 1970s what happened was popularly know the in 1960s and '70s IBM used to have the machines the hardware and there were no big comp know competitors for IBM there was uh there were this company called as burrow and what used to happen is IBM used to invent some software I mean write some software for IBM machines and then this Burrows used to have the hardware and someone had to take the IBM code and then modify it in such a way that it used to run in this Burrows right and there are only these two machines now even the database was also initially used on IBM machines and it was developed by IBM itself and they were called as you know Legacy machines Legacy systems so Legacy means um we can think of it as historical which means very old so early before this uh you know relational database IBM on IBM machines and Barrow machines the databases used where the database models used were one is hierarchal database and other is uh you know Network database so these two database models were also popular hierarchical and network database and the problem with these two are there are I know now there are no service providers who are providing this software for this database modeling and so they are called Legacy so but then what happened is companies in 1960s and '70s they have already stored lot of data in this database model and therefore they are still continuously using it and now there are tools being developed in order to move that particular database model into this relational model so automated tools are available so that you know you can use them so and one more thing is since the data is very huge people are nowadays using this uh you know data mining algorithms and data warehousing so what is the difference between data warehousing and databases is in data warehousing you know we are going to have huge data in databases we generally have less data right and from 1960s if you are collecting the data the data is very huge right so in those systems even other models are popular but at present everything is relational database and in our syllabus we have relational database and even you know if you go for any interviews or anything on database companies they'll ask you about mainly about relational database only right so we shall Focus only on relational database right so later see we have we have various levels right so now we are we have already seen what is er model and now we are going to see what is relational model and later what we should do is after designing the uh data model in ER model we are supposed to we are supposed to convert it to relational model right uh so there are various ways to conver ER model to relational model we shall see it and then after relational model we should even discuss about the physical implementation how are we going to store this relational model into the uh you know this um this storage devices right so before going ahead we shall discuss all the terms which are present in this relational model understand this model well and then convert the your diagrams into relational model and then we shall discuss about how to query this relational model itself using various what are the languages available for that actually relational model is a theoretical or formal platform right and it is derived from set theory from set theory they derived relations and from relations they deriv relational this model and now they have even propose some formal languages like relational algebra and relational calculus okay see relational data base has been proposed along with this researchers in IBM they have also proposed some formal languages like um you know relational algebra and relational calculus so if you if your uh if your database is in relational this model relational database model then you can you can Implement relational algebra and relational calculus in order to query this right so popular databases relational database Management systems are using you know this relational model and they are providing an implementation of relational algebra and relational calculus which is called SQL these days right so in order to use this practically what is that you are supposed to do is you have to design it in ER model and then convert it to relational model and then you know install any relational database software management software and you can use this SQL right which is an implementation of relational algebra and relational calculus and you can use this SQL to query on the uh you know database through relational dbms right so what is the relationship between SQL and relational databases SQL runs on top of relational database management system and whatever query you give it to the relational database management system it is going to be converted into relational algebra and relational calculus and it will finally act on the relational database model itself we have to get used to this relational terminology before we get into the data model uh see there are various terms which will be new to you what I try to do is I'll try to put them in correspondence with some other terms so that it will be easy for you to remember but strictly speaking you should use only these terms in this relation model but to make it you know easy for you I mean what I found out is whenever I use these terms it will be difficult for it is it is generally difficult for students to uh you know immediately recollect what the concept is so what I try to do is I map them to some other terms but I shouldn't be doing that I do it because it will be easy for you right so you remember you try to remember these terms and I'll also give you alternate terms which I'll use and whenever you write it in the exam you should be able to you know do that mapping from the informal terms we are going to use and the formal terms the model is going to use informal terms I use because it will be easy for you to understand okay but formal terms or will be given in the exam okay just uh be careful with that let's see this so the first term in the relation you know this relational model is the term relation itself so relation you can think of it as a table informally formally even though it is a relation informally you can think of it as a table so what is the relation it is simply a table right now what will table have table is going to have um if you if you you know think of it like this table is going to have various rows and various columns isn't it rows and columns right therefore the simple term to you know remember relation is you can think of it as a table right and what about a tle a row is called a tle right so tle is nothing but one particular row what is the significance of a row is it actually represents if you remember that ER model every row in a relation model represents a entity in the entity or relationship in the uh you know that ER model right so if you talk about one row it will completely describe one entity let us say student entity if student is having name role number marks everything one row is going to give you complete information about the student therefore a tle is actually an entity in the ER model right so you can think of this tupple as a row so instead of using this relation and then tle names I will sometimes use table and row to make the things clear okay and an attribute is a column okay so this entire one column you can think of it as an attribute right so table is a relation and tle is a row and attribute is a column right and the domain is generally uh you know domain means a set of values let us say domain is set of names domain is generally a set of values right so so there are various domains possible and every attribute is going to be associated with a domain for example you know you can say that this particular attribute is a do is having domain integer so what does it mean all the values which can be present in this column should always be integers right so domain is associated with attribute itself right so in know simple word simple you know meaning of a domain is and uh you know the easier way to remember what a domain is you can think of it as set of values okay for example set of integers or set of names or set of characters anything so domain is generally a set of values and we generally assume that it is finite so domains you know if you think of it in in general sense domain should not be finite but when we when we think about it here in especially this model we say that a domain is or we assume that the domain is finite it has got some implications we shall see what is the what is the implication of this later and next one is relation schema so relation schema means the heading of the table right so generally every table will have a name let us say the name of the table is R right and every domain is also going to have a name right every attribute is going to have a name like A1 A2 A3 A4 let us say A5 right now we have how to rep represent this entire table heading is you can represent it this way R A1 A2 A3 A4 A5 right so this entire thing can be called as relation schema right so relation schema is nothing but heading of the table you can imagine it that way right and then each uh you know each attribute is going to have a domain right let us say D1 right D2 D3 D4 D5 let us say these are the domains associated with these attributes and sometimes two or more attributes can have the same domain right but then their their attribute names will be different maybe you can think of it this way right let us say uh we have phone number and maybe we have address and address is a door number now phone number and door number both are integers therefore two attrib can have the same domain but then they have different names right so now why the reason why this is actually called as a relation is there is there is a deep meaning in it actually it is all derived from mathematics especially the set theory it is all a formal notation okay so you can think of it this way see now A1 A1 is nothing but set of all A1 can take any values from D1 isn't it and A2 can take any values from D2 and A3 can take any values from D3 D3 all these are set of values and all these are attributes and in any particular row we are going to pick one value from this one value from this one value from this one value from this and one value from this in order to make it a tle right therefore you can imagine or you know any any row right or you can imagine first of all a cross product of all this cartisian product D1 D2 D3 D4 D5 if you take a cation product of all this what do you get an ordered pair which is containing one value from all of these isn't it now a relation which means a table Can Be Imagined as you know small R know represents a table which is having the heading capital r you can think of it as a subset of this are you following it any table is a subset of cartisan product and in mathematics any subset of a cross product or cartisan product is generally called a relation right that is why it is Meaningful that they are calling this table as a relation because it is actually a subset of cartisan product and who and how many elements are possible the number of elements that can be possible in this relation will be as big as the number of total elements possible isn't it then how many total elements can be possible that depends on the quality of each set right so let us say the cardinality is represented by like this right then how many elements will be possible how many rows will be possible in the worst case as many as you can think of it this way right if the cardinality of this one is 10 10 10 10 10 then 10 power 5 rows are possible with all these combinations and all those rows can be present in your table right but at practice even though we have lots of possibilities every possibility doesn't make a meaningful tle which means doesn't represent a meaningful let us say a student might not have all possible phone numbers isn't it therefore you know even though this one is going to give you very large number of tles In our relation we are going to have at any time only a finite number of tles and that is also called as state of the relation table State means what are the elements that we are going to have in our table at at this time so the number of elements or the elements present in this table at any given point of time is called the current state or state of the relation table at that time all right and next one is yes relation schema means the heading you understood that right and next one is degree of a relation so degree of a relation means um you can think of it this way the number of if you if you look at this columns the number of columns you can call it as relation straight away or the number of attributes right so the degree of a relationship is relation is sorry not relationship it is relation see relationship is different and relation is different okay so the degree of a relation is the number of attributes I have in the table is called relation degree of the relation right and next one is relation state so the relation State or the current relation State both mean the same thing which means the table itself and intention sometimes the relation schema is also called as relation intention right so intention means the heading schema only so the relation schema is also called as relation intention and relation extension means the table itself all right so these are the various terms which we are going to have so you know just to have just not to have any confusion and you know to make it clear Whenever there is a term relation I use the term table and whenever there is a term let us say tle I use I use the term row right so with this you should not be getting confused I hope that you understood these Concepts and and I know instead of these names I'll use the informal names okay whenever you represent this relation the table in the memory either in the main memory or in the hard disk or whenever it is being displayed the table will be displayed in some order right which means uh uh some rows will be appearing before the other rows therefore when you store the relation or the table in the memory some order is actually applied but the relation database itself this model itself the relational model it assumes that a relation is a set which means even though when we store a table it is going to be stored like this and you know every row is going to be written like this and so there is some ordering in the rows like this is Row one row two Row three row four row five the definition of the relation in the relation model itself this model this particular model it says that a relation is a set which means a rows they are just the elements of the sets and so it doesn't give any ordering right see ordering is what we give and since it is actually written as a set one more interesting thing about relational model is in a relation no two tles can have the same values in all the attributes which means no duplicates are allowed it is same as set theory isn't it in a set we cannot have you know two members same two members isn't it so similarly here a relation will never have two tles as the same which means let us say it is a relation and it is student name and then student number and let us say it is address okay in of address let us say phone number okay now somewhere a student number a is there a student name is a student number is one and let us say this is 201 1 301 phone number and at some other point you should not have the same thing in a relation because these two tles are having all the values and therefore they duplicates and in a set duplicates are not allowed so it is important that you remember a relation is a set so once you remember that it is a set you'll understand what are allowed and what are not allowed okay and next thing is see the values that can be present in an attribute are generally derived from a domain right and the domain is know predefined sometimes what happens is even so we have we know that we have to take the values from the domains and write it here right let us say in the phone number we have to take all the valid four numbers and put them here right sometimes what happens is some tle some row might not have uh the value for example a student might not have the phone number then in that case what are you going to write there so just to handle this exceptions like there are two kinds of exceptions one is uh we don't have the values at all or sometimes it is not applicable at all let us say name is having first name middle name and last name field right and a student might not have middle name completely right in this case this particular field is not applicable for that particular student right or let us say phone number so phone number is applicable but then the student is not having a phone number right so it is not applicable and it is applicable so whenever you have such cases where either a field certain field is not applicable to someone or you know value is unknown so if it is not applicable or if it is unknown okay we are going to use special values in relational model called as null so these null values are are special in this sense they are not present in the domain but still they can be used as the attribute value to some toule got it so these are the exceptions you should keep in mind one interesting element about this uh relational model is while you design the database itself you know while you are designing this know database schema on the schema schema means you know that right schema means the headings I mean that is the simplest way to remember so while you are designing the schema itself you know you can specify some restrictions on how the data has to be inserted into the schema that is interesting feature which means in the design level in the design level of this we could put even more restrictions on the data which will be updated later see now we are just deciding about what are the headings of the relations and how many tables are going to be there and how many you know what is the headings of each table and what are the attributes that is what is being decided at this know design model right and in the modeling of the design itself we could even put some restrictions saying that uh see the values which have to be inserted into these tables should follow these restrictions right and this kind of facility was not completely available in the ER model in the ER model we'll not be able to put many restrictions on the data that will be inserted later but now here in the relational model while designing itself we are going to put many restrictions especially on the schema schema means the headings we don't have the data at our hand it but still in the headings itself we are going to put lots of restrictions and and you know the main restrictions are actually four types you can remember it this way see they are also called as constraints constraints are nothing but the restrictions okay the same meaning restrictions or constraints which means whatever data you are going to insert into these tables they are supposed to know obey your restrictions otherwise they'll not be you know inserted or they'll not be updated or modified right so the most important know constraints are one is domain constraint so domain means whatever we do on the domain itself right so I I'll talk about it and next one is key constraints key constraints talk about the uniqueness we already know that a relation is a set therefore no two tles are supposed to have the same values right and but then some of the values of the tles may be same right for example if you look at the marks you cannot say that you know no two marks should be same for a student marks can be same right but then the entire tle when it is considered it should not be same in order to implement this we are going to use uniqueness constraints and key constraints are also called as uniqueness constraints I'll talk about it and next one is entity Integrity constraints which means uh you know the entire tle itself has to follow some of the constraints we shall see it and then referential Integrity so referential Integrity is actually a different thing because all the other constraints are actually applied on one table but when you talk about referential integr they they are applied between two relations which means two tables so one table you know while we do some modifications on one table you know the other table is also involved in somehow okay in some matter [Music] so now let's see uh domain constraints first so domain constraints is like this H let us take some example and I'll show you what the domain constraint means let us say there is uh you know student table it is a student relation right then what are the domain constraints is every value or you know every uh domain that you choose for for an attribute it has to follow the domain for example student name now you might Define the domain for student name to be you know set of character or set of characters of you know variable length if you have defined it then all of them are going to follow that and moreover um one one main thing about the relation is you can view a relation like this as a flat file structure flat file means no hierarchy is allowed so in case if you have any any attribute which is a name right even though name is an attribute which is a composite attribute such a kind of attribute is not allowed in relational model the reason is every every element that you are going to insert it insert into the you know attributes of any tupple should be Atomic Atomic Atomic means smallest individual unit right so it has it cannot be divisible it has to be indivisible for example if you take name name can be further divided into three parts first name middle name and last name right so whenever you have such a domain such as an attribute such as a name it is better that you you split up that composite attribute into simple attributes right so instead of having name you are supposed to have first name maybe middle name and last name this is allowed so what I mean to say is you know every domain should contain Atomic values you are not supposed to allow I know these composite attributes you are post all only simple attributes and sometimes you might have some domains which are multivalued right like phone number a person might have many phone numbers right so in this case this multivalued attribute should also be not allowed right so which means we are not going to have more than one value for any for any attribute or we are not going to have you know many a collection of many values for a attribute so domain constraints say that we are not going to allow either composite attributes composite attributes or you know multivalued attributes into the domain so everything that you insert has to be Atomic which means the smallest individual indivisible part if you're going to have any big bigger than Atomic then you are supposed to break it either in the same table or in a different table generally what we do is whenever we have these multivalued attributes we construct a new table or relation specially for that attribute and in case of composite attribute we break them later I'll show you how to deal with it we are not going to talk about it here but then there are ways to convert any non-atomic attribute into Atomic attribute there are definitely ways possible right so what does this constraint say is whatever schema you are going to design in relational database see that the entire schema of attributes should always be Atomic that is what is domain constru friends got it and uh you know once you decide about how many attributes are going to be there it is generally going to be fixed see generally we you know we insert and delete the data into the database which means we insert and delete the tles into the relation but then once we fix up the domain it the uh entire schema we are not going to change it right now let's see this entity integrity and referential integrity so entity integrity means this so once we have decided the primary Keys No primary key should ever have a null value the reason is if you have if you allow null values to be in the primary key then what happens is two or three tles they might end up having null values and you know we will not be able to identify which one it is given the null value see what I mean to say is if you say that the primary key for a relationship for a relation sorry the primary key for relation is employee number right I'm saying that that you should not allow any null value in the employee number the reason is if you have allow null value if two or three values happen to be null and now if you want to search for a tle whose employee value is null then you might come up you know you you might not be able to locate exactly one tle right you may you may be referring to more than one tle in that particular query isn't it therefore entity Integrity says that no Prime attribute should ever have null value got it and next one is referential integrity so referential Integrity is U you order to understand referential Integrity you should understand the concept of foreign key now we have seen the primary key now let's see the foreign key assume that it is the employee database or employee relation which means it is the employee table right here you are going to have employee number and maybe employee name right and maybe there is some field called as dep department number so this department number is what is the type of the department what type sorry what is the department for for which this particular employee is working let us assume that there is employee number one right and his name is a and the department number is we have write it some some number here right but then you are not supposed to write any random number the reason is you should not an employee should work only for the Department which is existing therefore you are supposed to write some number here which is already existing in some other relation of the department table isn't it which means there must be some other table or relation which is called Department which will contain the information about you know uh what are the valid departments in our company right and that particular Department number has to be present here what I mean to say is this is what I mean to say right so a particular attribute of one relation should refer to some attribute of other relation and whenever you write some value here you should see that this particular value already exist here right assume that in our depart in our company we have only four departments 1 2 3 4 then you are supposed to write only one of these four numbers which means an employee can work only for one of these four numbers he cannot work for you know let us say Department 10 unless the department 10 is there so you are not supposed to write you know number 10 here if you want to make sure that your dbms the software dbms means the software database means the these particular tables dbms means the software if you want to make sure that your dbms will catch you whenever you try to do anything like this anything wrong like this then you should implement this constraint on the schema right so which means like this see now your department uh whenever you try to insert some number which is other than 1 2 3 4 it will definitely show an error right if you implement this Integrity constraint right then what what is that you are do you you will be doing is you have to write some valid number like 1 2 3 4 maybe one right this is allowed so uh this particular uh this particular key is called as foreign key so what is a foreign key is if you are trying to if you refer to some other attribute of some other table and if you see that always the values which you are going to insert in this particular attribute it should always be present there then that particular attribute is called as foreign key right and this this table is set to refer to this table right so this is referring and this is referred so referencing and referred okay and this is called as foreign key that is called foreign key and generally what we do is every whenever a attribute is referring to the other attribute the other attribute will generally be a uh you know primary key it is not a hard and fost Rule but most of the cases it makes sense that if the other one other one is a foreign key the primary key foreign key always refers to a primary key of some other table that is what we generally see okay maybe if you want to see one more example let's see this this let us say every employee is supposed to work on the project then the project number field will give us what is the project on which this particular employee is working right then what I'll try to do is I'll have one more uh table let us say this table is about project and in this project if I have set of all project numbers available then this particular attribute is going to refer to this right and in the schema we are going to put this references by putting this Direct arrows direct arrow means we'll have a arrow like this in the schema diagram so that it will be easy for anyone who is reading the model to understand it okay and now any value that you are going to insert here should always be present here okay let us say you know the project numbers are 1 2 3 4 then you are supposed to have only 1 2 3 4 numbers if I write like this what is the meaning of it is employee number one is having name a and he's working in the department one and he's working on the project four right uh actually if an employee is going to work on more than one project then we cannot have this project number attribute here the reason is then the project number will itself become a multivalued attribute the reason is you know an employee may work for more than one project but here assumption is that an employee is working for only exactly one uh one project got it what is the main difference between uh foreign key and the primary key is if you remember remember this entity Integrity in primary key we never allow null values isn't it but here in case of this foreign key we can even allow null values which means in this foreign key you can even have null values what does it mean is maybe an employee has newly joined and he is not at assigned to any Department then in this case let us say 2 a null can be allowed so foreign key will allow null unlike primary key right remember that foreign key can allow null if he near if he newly joined then maybe his project may be unassigned then it it will also be null so either you can have a value of null in the foreign key or in case of any value that value should always exist in the I know attribute to which it is referring to got it and one more other one other you know interesting this foreign key is okay generally where do we get this referencing is if you have seen all the constraint till now they were all actually implemented on one relation isn't it which means one table uh but then this particular for this referential Integrity is actually implemented between two tables I have I should have two tables isn't it so how can you compare this particular referential Integrity with the ER model is in ER model wherever we had this relations those relationships are actually leading to references if if you remember the TR model between two entities we we had relationships isn't it now those relationships will lead to the differential Integrity here that is the relationship between ER model relationships and the referential Integrity here and referential integrity is between two tables or sometimes it would be it could be more than two tables but sometimes it could be between the same table like this if you remember that uh you know recursive relationship which is defined between two entities of same type or two same entities uh supervisor let us say we are going to have one more field which is called as let me write it here which is called as supervisor number right an employee is going to have a supervisor and that supervisor is also going to be an employee right therefore the supervisor should also be in the employee database and now you can refer to them which means if you are going to have a supervisor that supervisor should also be an employee and that number should be a valid number from the employee numbers right therefore in the on the same table itself or on the same relation itself we can have referential integrity like this so one one attribute can refer to the other attribute in the same table then this particular attribute is called as foreign key and this this attribute is normally the primary key isn't it therefore referential Integrity can be defined between two tables or on the same table in case of recursive relationship right so are you following this the main difference between primary key and this you know foreign key is null values null values are not allowed in primary key but they are allowed here right and moreover we we can have more than one foreign key on a table but in a primary key we are supposed to have only one primary key for a table isn't it even though we have more than one keys they are called Candid Keys once we choose one of them that is going to be only unique primary key and we are not going to change it and know generally we don't change it but on a table we might have more than one foreign key which means more than one attributes of your table might be referring to other attributes of some other table or of the same table got it so these are the various integrities once we decide about the year diagram or once we build the year diagram at the conceptual level later we might have to convert that ER diagram itself into the relational model then we can apply the relational dbms on the relational database right so there are there is a procedure or in fact the algorithm in order to convert ER diagrams into relational model so there are seven steps so let's go step by step um you know it is all about this we are going to have entities relationships you know and weak entities and identify relationships so these are all the entities present now we have to convert everything into tables the relations so now the first step is for every entity in the ER model we have to come up with a relation in the irational model right so the first step is like this I'm just taking an example with this example I'll explain you it is Step number one we want to convert an entity into the relation okay now how to convert entity into relation is we know that entity is going to have various attributes right so let us say this entity is student entity okay and there is uh there are attributes like this one attribute is student number and the other attribute is a composite attribute which is student name and assume that it is having various parts like first name and lost name okay and the other attribute is uh one multi multivalue attribute is there multivalued attribute is there right which is phone number and say one more attribute is there which is marks okay now this rule says that for every entity in the ER model we are supposed to construct a relation in the relational database model right so now for this particular entity called student I'm going to build a table or I should at least build a schema right so now the schema of this relational model is going to look like this student is the name of the relation name and how many fields are going to be there for every simple attribute we are supposed to have a attribute in the uh you know relational model so what is the simple attribute here no serial number the student number so student number I'm going to have a attribute in the relation model and marks these are the simple attributes okay now after that look at all the composite attributes what are the composite attributes student name which is going to have you know first name and last name so don't represent the composite attribute as it is just take the uh you know compositions which means the simpler or the simple attributes which are a part of the composite attribute should be taken and they should be included which means we are not supposed to include student name we are supposed to include first name and last name right and this one don't include it no multivalue attributes will be included into the table we shall deal about this later later in some other step I'll tell you what to do with this for now just understand this so all the simple attributes are represented in the table along with that if there is a composite attribute the uh you know I'm going to break it down into simple attributes and I'm going to represent them so student name is going to have first name and last name so represented right and next thing is if there are any Prime attributes let us say the student student number is prime attribute then I'm going to represent student number as the prime attribute even for this primary key for this okay so whatever is the primary key attribute for the here this entity I'm going to make it as primary key for the relation right in case if more than one attribute are going to form a primary key for this we are going to do the same here right in case if the you know composite attribute is actually you know is a primary key for this then I'm going to use the same notation here which means I'll have all the all the simple attributes which are the part of the composite attribute and I'll take all of them and make them the primary key primary key can be more than one attribute all right step two is about converting the weak entities into relations so strong entity can be converted straightforward uh coming to weak entities there have to be some extra things here let us take an example let us say there is employee relation or entity okay this is the employee entity and there is a weak entity called dependents okay and both are related through identifying relation okay this is the identifying relationship right and now assume that the attributes of this we entity are one is name which means the dependent name and other is let's say is and other is relation relation means what how is the dependent related to the employee okay and now within this uh you know dependent dependence table or this entity we don't have any primary key which means we cannot identify any entity in the dependence uniquely but then what we could do is you know there is something called as partial key partial key means we cannot identify anything uniquely but then given the employee for a given employee we can use this particular key particular thing as the key and we can we can distinguish among various dependents among all the dependents over all the employees we will not be able to identify it but then given a particular employee or given the dependence of particular employee we'll be able to identify it such a key is called as partial key let us assume that this name this particular thing is a partial key right partial key means for a particular employee if I give you the name of the department dependent I'll be able to identify the dependent entity okay now I want to convert this into the table then what I do is um conver you know create a relation as it is I'm I'm talking about the schema okay create the relation as it is and have all the attributes one is name other is a and the other is uh relation right and along with that let us assume that this entity is a strong this employee is a strong entity which is already created let us say there is employee number which is primary key and the employee name these are the two attributes and that particular relation is already created because it is a strong entity so it is having employee number and employee name right now after doing this you know uh if it is a weak entity what is that we are supposed to do is we have to add all the primary Keys understand this we have to add all the primary key attributes of the owner entity this is the owner entity right this is owning this dep dependent okay and moreover the participation has to be total right see this is the owner entity and this is the dependent entity right and now this is the identifying relation now what is that I'm saying is once you create the table or the relation for this weak entity you add all the uh primary key attributes of the owner entity into this one right so what are the primary key attributes of the other entity employee number therefore add employee number into this and you add it as a foreign key which means this particular key this foreign key will be referring to the primary key there in case if you have more than one attribute here as the primary key then you are supposed to add all those attributes as a Super Key that uh you know uh foreign key and you are supposed to refer to that primary key got it then what about the primary key of this table the primary key of the other one which means if foreign key along with the partial key which means this one these two are going to make up these two are going to make up the primary key where name must be a partial key so what is a partial key is see what I mean by partial key is if you have a table like this right now given that partial key you will not be able to identify a toule uniquely in this table but then given the partial key and then the no employee number which means for a particular employee the dependence will be only few and in this few given that partial key you'll be able to identify that particular tle that is about the partial key partial key means you will not be able to identify a particular tle uniquely in the know entire table but then given a part of the table how can they know the part of the table only the dependence on one employee right given the part of the table inside this part of the table you can use that partial key to identify toule uniquely right so things that you have to keep in mind mind here is one is you can directly make a table for this the relation and simple attributes directly go into it in case of any composite attributes break them and put them there and in case of this multivalued attributes we shall see it later right and you take the actual uh whatever it is there actual primary key of the owning uh know entity you add it as the foreign key and you see that that particular thing refers here right and more you you declare the combination of that primary key as well as this one the partial key as the primary key for this one right and moreover by writing like this even this identifying relationship has been taken care which means you need not do anything for the identifying relationship also it is also being taken care by this how is it taken care by including this foreign key right so foreign key is not just about the weak entity weak entity is already represented as a table and this relationship itself is actually represented as the foreign key therefore by including this foreign key even this week this identifying relationship is also represented you need not worry about it later what it in case if it is having any attributes identifying relationship you you generally will have it here what it okay so one thing you should be careful here is what about the uh you know Integrity violations let us say in case if you are deleting an an employee element here then what should be done so in case of weak entities right since the dependent there is existence dependence existence dependence means there cannot be any dependent without any employee right so in case of such a dependency especially in these cases in case of this weak uh weak entities and identifying relationships if you ever delete any entity from the owner entity side you should you should delete all the entities which are depending on that therefore on delete and on update it is cascading which means if you delete something here you should even delete there got it where especially in the weak entities right so when there is a week entity and when there is this reference which means there is a foreign key which is referring to a owner entity then whenever you are going to delete something here you are supposed to delete all the entities from this side right and this rule is applicable especially for this weak entities right not for other things and uh you know in the other case see whenever there is this foreign key it does not mean that the entity is weak here we are going to have the foreign key it doesn't mean that the entity is weak right and whenever there is total participation it doesn't mean that entity is weak it here so happened that the entity is weak but then even without this weak entity type there will be total participation and even without this week entity type there will be cross referencing which means there'll be a foreign key which will be referring to the primary key of the other table right therefore only in case of weak entities Whenever there is deletion here we are going to delete all the tles here because without the owner there will not be these dependents got it so in case of other relations where we are going to have this cross references you know cascading need not be applied and cascading should not be applied according to the semantics now let's talk about how to convert the relationships into you know relations okay Rel relationships into relations relationship is a term from the Air diagram and relation is a term into in the relational database so just to you know not not to have this ambiguity let me call relationship and table okay relationship means in the diagram table means in the relation okay now let's talk about the relationships how to convert it into tables so let me take an example it will be easy for us to understand it that way let us say there is employee entity employee entity type it is okay and there is a relationship and employee is related to department and here the relationship is let us say manages which means an employee manages a department right now what type of uh this participation is it one to one the reason is an employee can manage let us say according to the rules defined the semantics of this database from the requirement analysis an employee can manage only one department and every department has to be managed by exactly one employee and the every Department should have the manager right therefore an employee can manage only one department but it is not necessary that every employee has to manage the department among all the employees there will be some managers and some of them will not be managers right therefore employees all the employees will not participate in this relation which means all the employees will not manage any Department right will not manage the department some of them will manage therefore from this side the participation is partial from the other side every department has to be managed by an employee therefore every Department department will have a manager here so from this side the participation is total all right and just for the sake of example let me take few attributes here so one attribute is employee number and say other attribute is employee name okay and employee number is the primary key for this for the other side let us assume that there is one attribute which is depart department number and one more attribute which is Department name right and assume that department number is a primary key right and now we have this relationship which is actually one to one okay now uh since these two are strong entities they are strong entities right uh they are supposed they are they are they must already be having their own uh you know uh tables so there must be a table already created because in the step one itself we have already discussed about what to do about the entities the strong entities tables are created right now step two decided about discussed about the weak entity here there are no weak entities both are strong entities which means both must already be having tables so one table for employee must already be existing and it is having employee number which is the key primary key and employee name these are the two attributes which are already present in this table and the name of the table is employee right see instead of calling it as a relation I'm calling it as a table otherwise this relationship and the relation you might get confused and now I'm going to use other table which is already created for Department okay which is having department number as the primary key right and the other attribute is is Department name fine now in order to represent this relation the best method is uh take the primary key of one side and include it as the foreign key on the other side you can do anyways which means you can take this primary key and include it as a foreign key here or you can take this foreign this primary key and include it as primary key here anything you can do but the best thing is is uh do it do the inclusion on the total participating side which means you know since department is totally participating in this relationship it is better that you include the primary key of this one as the foreign key of that one which means it is better that you include this employee number here right and make sure that this one refers this this is how you can represent that relation now that relation is included by this uh you know foreign key got it and having this name as you know employee number here is actually a bit U not conventional or it is not meaningful so it is better that you change the name of this attribute to manager right let us say manager so what does it mean it means that whatever values you are going to write here should already already be present here every employee can be a manager there only an employee can be a manager there there therefore referential Integrity has to be maintained right so why do you think that we have chosen to add uh you know the primary key of this side as the foreign key into total participating side since this is partial participation and it is total participation I told you that the total participating side we are going to do the update why do you think it is true why do you think it should hold the reason is if I if I add this particular entity on the total participating side then for every particular Department dep M this will be containing some value the because the reason is department is defined in such a way that every Department should have a manager isn't it therefore for every toule of Department definitely there will be an there will be a manager that is the semantics of the database right but if I try to you know include this department number on this side then the problem is if I write the department number here then every employee might not manage a department therefore for most of the uh you know employees we might get null let us assume that the number of departments are two and the number of employees are 100 then if I include this department number here 98 entries will be null only two entries will contain the department on the other side you know these two let us say there are two departments these two departments will have the actual values here right therefore it is better that you always have it in the on the side side where uh you know the participation is total got it and the second thing is um what if what if this relationship itself is having some attributes let us say there is an attribute here and the attribute is start date start date means what is the date in which this manager has started you know managing this uh Department in case if this relationship is also having some attributes then add this attribute on the total participation side itself which means you take the start date and you add it to the same side start date got it so uh this is how you deal with one to one relationships so this step actually deals with this step actually deals with one to one relationship okay only this type of relationships so how how are we dealing it uh we are not going to create any any new table for the relation we are going to take the relationship sh and we are going to add on one side the foreign key which is going to refer to the primary key on the other side anything you can do either you can add it this side or that side it is better that you add it in the total participating site because if you do it that way you might not you need not have waste the space got it and in case if you have any more attributes you are going to add the attributes also to the other side the you know total participating side got it um in case in case uh if it is like this let us take one more example let us say there is a entity person name and then there is a an entity which is called license license Cod license Cod okay now what I want to do is this is relationship holds which means the person is holding a relationship and let me say the semantics of this database are like this from the I know requirement analysis let us say they said that every person is supposed to have the license the driving license and they are supposed to have only one driving license then what happens is this is going to be total participating which means every person will be holding in a license right and moreover a license will never occur know without a person therefore both sides it is total participation right and assume that it is one to one which means a person cannot have more than one license and moreover a single license cannot be held by more than one person so it is a one toone relation in which the participation is total so participation is total means okay see this this cardinality says how many maximum relationships in which a particular entity can participate right therefore it is saying that maximum a person can participate in only one relationship right and the total total says this total participation says how many minimum you know entities uh in relationships that this particular person that this particular entity can participate it is saying that minimum is one when maximum is one and minimum is one you can you know on both the sides you can easily derive that on both the sides definitely the number of tles are equal the number of entities are equal think about it you know we are going to have relationship like this see this we are going to have relationship like this right now for every person there is going to be a license and for every license there is going to be relationship and this is possible and moreover a single license cannot be held by two people right this is Possible only when the number of persons and the number of uh you know cards are equal isn't it so whenever there is total participation with one to one relationship with one to one cardinality you can think of you can you can know uh what I say derive that the number of entities here is equal to number of entities here so in this case you can use the same method which means you can have the person uh table and you can have the license c table and you can include either the license number here or person ID here and you can make the other side refer to it because both are total or a better method is you join both of them that is even better right so in case of this you know one to one relationships whenever the participation on both the sides is total you could even uh combine both the tables without having two tables that is even better right so what happens is now when you combine both the tables all right then for every uh person see this already we have person table right this is the person table because it a strong entity and already we have license let us say license is a strong entity and it is not a weak entity then uh we are going to refer these two we are going to combine the we are going to combine these two tables and we are going to put the two tables in I know one table right so this is this really makes sense because we are not actually adding any more space so anywhere we have to save all the license entries and anywhere we have to save all the person entries and saving them together is actually not any extra space instead of having them separately and then adding one more attribute combine them without any attribute easy right now what what happens if you have done the same thing here if I try to combine them what happens is see whenever I combine two tables then the a total attributes are going to increase right so that resulting table is going to have attribute employee name employee number department number Department name everything right now when I combine these two then the problem is for most of the employees these three these two attributes will be empty because only some of the employees are managing the Departments but but then here when I combine these two let us say it is having person ID and person name and it is having a license number and let us say license date something like this now when I combine these two every every cell will be filled because a person is having person ID person name license ID and license date right but here an employee may not be managing a department right only for two employees you know like in you know earlier example only for two employees if they are managing the Departments then when I combine these two tables what happens is only those two particular employees will get the Department details filled up and all the others will have null right so in case of one to one relationships if it is total participation on both the sides better you come combine both the tables right because here the total number of tles this side and this side are equal and there is actually a one to one mapping so you can easily combine them appropriately that particular one to one right but here in case of one to one you know relation if the total participation is only on one side you modify that side got it so these two are the best known practices so here it is up to you whether you choose to combine them or add add the foreign keit is up to you right so anyway combining them is actually taking less space isn't it because you need not add one more extra attribute here right so this is this is the best one here don't combine both of them have one more attribute all right step four is let's see how to convert a one to relationship into a table for that let's take an example you must be knowing this um we already seen it maybe works for so if an employee is there let's take the same example employee it and there is a relationship and there is Department entity okay this is employ entity and this is Department Department entity and the relationship is works for so an employee works for a department right and Accord to the meaning of this uh you know let's let's first talk about the meaning the semantics which you got from the requirment analysis let's say the requirement said that every employee has to work for at least one department and exactly one Department okay and a department can have uh many employees right then what happens is employee is going to participate totally in this relationship right because every employee has to belong to one department or let's leave that restriction because when we delete a department some of the employee you know employees might not work for the Department let's say it is not total participation it is uh uh it is partial participation but then let's let's assume it this way a department can have many employees right then what about the cardinality so if you're writing it in terms of cardinality here it will be one and here there will be one which means an employee will work for only one department but a department can have an employees it is cont intuitive you know even though uh you know the maximum number number of relationships in which an employee entity can participate is one we write one that side and even though the maximum number of entities that a department can participate in this relationship is n we write n this side right but anyway the one which has got n that is going to participate in only one relationship okay maximum and the one which has got one that is going to participate and okay so you have to you have to think it this way so Nite is actually participating only in one relationship entity but one side is participating in end relationships okay now uh since these two are already strong entities let us assume that there is employee number here which is the primary key for this so it is strong and then employ name here which is an attribute okay and now here also we have department number which is the primary key therefore it is strong and there is uh Department name right and let us say there is one attribute for this works for also maybe uh the start date the date in which he started working for uh you know that particular Department fine now what I wanted to see is how to represent this particular relationship we already know that for strong entities we already have the uh tables the relations so one relation is going to be this way [Music] so one relationship one relation is going to be this way employee is having uh two attributes this is the employee relations right one is employee number and other is employee name and it is a primary key and we know that department is also having two attributes one is department number which is prime attribute and Department name right now what we are supposed to do is represent this relation so only way to represent a relationship is always using the foreign keys right uh in case of 1 to n or 1 to one so in this case of 1 to n or 1: one we are we are supposed to use the foreign key concept right so how are you going to put the foreign key should I put the foreign key this side or that side which means uh should I put the department number here and then you know make this refer to this or should I put employee number here and then make it to you know refer to this what which one makes sense which one is Meaningful which one is possible in fact so if I put the department number here and make it refer to that side then what happens is for every employee we know that maximum can work for only one Department therefore you know we need to represent only one value here in case if you try to put with the department number Department name the employee number also it means that we have to write all the employee numbers who are working for a department it turns out that for a particular Department there are more than one employee working for it therefore you might have to put more than one value here which makes it multivalued and we already know that there is no provision you not to put a multivalued attribute in just one single column we need a separate table we shall see it later right therefore putting all the employee IDs who work for a particular Department in just one tble which is related to that department is impossible right so the logical way or or you know the only possible way is have the uh take the nide which means the employee wherever there is n take the inside right and then in that inside you should add the for key which is going to refer to the primary key of the other side what it therefore it is not meaningful to include this one all right so meaningful is take the inside inside is employee and add the primary key of the one side here and see that it is going to act as the foreign key and that foreign key refers to the primary key here got it and now every employe has to have a department number and the department number should already exist in this table otherwise reference that referential Integrity will take care of it got it okay and now uh one other thing is what are you going to do with the attributes which are associated with the relationship itself the same thing take go to the inside and you add the attributes so whatever you are going to add it add it on the inside itself the reason why am I doing this is because on the inside every entity is participating only in one relation or for every employee there will be only one department but but then on the other side for a department there will be many employees and I'll not be able to add all of them in just one toule but here you know I can add the department name in one toule right therefore I'm going to have here you know uh this particular start date also right so this is how we can implement this uh this particular relationship right so this is the implementation of 1 to n see in the earlier step we have seen how to implement one to one relationship and here we have seen how how to implement 1 to n relationship in both the cases uh we are converting the relationship into actually a foreign key not into a table itself right we are actually making one foreign key refer to the other other side and that is how the entire relationship is represented inside it right we are not using a special table okay fine in this step uh we shall look about how to deal with the multivalued attributes so we have seen that composite attributes can be split down into simple attrib attributes and those simple attributes can be recorded in the relations the tables but then we didn't see what to do about the multivalued attribute so what is that I'm trying to say is if you have an entity right and let us say it is employee or let us say student student entity then you are going to have student number which is a simple attribute and which is a primary key and assume that the name itself the student name is a multi multi the sorry composite attribute which is comp comprising of two simple attributes one is first name and other is last name then how are you going to represent this in the relation in the table itself right so we are going to have s you know student number as the attribute along with that you are going to have these simple attributes which is first name and last name right and along with this you are going to have assume that we have a multivalued attribute which is which is phone number so what is multivalued is a student might have more than one phone number then uh you know student number one let's say his first name is a second name is B and phone number if he is having more than one phone number I might not be able to represent all of them in a single tle which is representing the student right therefore we are not going to represent it at all in the table so for the multivalued attributes we have to create one more new table which means for this particular attribute phone number I'm going to create one more new relation the complete table itself so I'm going to create the new table completely in this new table I'm going to put phone number and along with that in this table I'm going to include the foreign key of uh you know foreign key which is the primary key in this so student number which was the primary key here I'm going to include it as the foreign key which means this one will be referring here so what does it mean for every student if he is having more than one phone number let us say student number one is having one phone number then student number one phone number one student number one phone number two student number one phone number three I can have all of them right now since we have got a new table you should decide about what should be the primary key for this table right so what do you think is appropriate primary key should I go with only no student number if I go with student number in this table obviously uniqueness is not guaranteed right so can I go with only phone number maybe not because maybe two students might be sharing the same room and they might be having the same know phone number which means some some some other place student number two might be having the same phone number because they are they are sharing a single room right then the problem is it is also repeated so you you might not be able to use either student number it is definitely not possible to use student number because since it is a multivalued attribute you'll definitely have two two values for the same student therefore there will be repetition here so student number will not give you uniqueness so it cannot be used as a primary key now there is no chance that or you know sometimes there might be collisions even if you go with the phone number so only option remaining is use both of them both of them as a primary key a combination got it in case in case if the um if the multivalued attribute is is also a composite attribute which means if the phone number is containing in itself two more simple attributes let us say uh STD code and telephone ID then what should we do then we should break this phone number into simple attributes one is STD and other is maybe telephone ID right so in case if it is complex what is complex multivalued as well as composite then you are supposed to break that composite attribute into simple attributes got it and in case here you know instead of having one one attribute as a primary key if you have two attributes then you are supposed to have both the attributes and both of them should refer to there got it anyway everything you put here is going to be a primary key right so whenever you convert any multivalued attribute into a table remember that everything in that new table should be a primary key for the new table right and you are going to have a foreign key which is going to refer to the primary key of the initial one that original table got it so multi Val attributes have to be separately placed there the last step is to deal with the en relationship so whenever you have en relationship which means uh you know binary means uh two two entities are participating in the relationship right en means n entities are participating if you have more than one entity participating in the relationship right then what you should do is you should definitely create a table for representing the relationship right so if this is relationship in which four attributes are participating then you should definitely create a table which is representing the relationship and in this particular table you are supposed to have as foreign key the primary keys of all the tables let us say the primary key of this one is you know A1 the primary key of this one is A2 the primary key of this one is A3 primary key of this one is A4 then in this particular table you are supposed to have A1 A2 A3 A4 all of them referring to those particular you know primary keys so these are all going to act as the foreign key inside this table right and what is going to be the primary key for this table the combination of all these attributes right all these primary the foreign Keys together put together is going to represent the primary key for this table right in case if this attribute you know if this relation is also having attributes some attributes then if they are simple attributes just put them there right if they are composite attributes split them and put them there got it so this is how you deal with uh you know relationships which are having multiple uh you know entities right see most of the databases what happens is we have various tables we form various relations and then uh let just take an example see this let us say we have an employee table this is this contains all the information about the employee let us say this is the employee ID this is the employee name and maybe this is the department ID in which uh you know this particular employee works for employee number one whose name is a works for department number one something like this and now what should this department ID we know that it has to be a foreign key referring to the department right now this department ID will refer to the department ID these two Fields need not have the same name you know it is a good practice to avoid same names even though they have the same meaning and even though they are same it is better that you have the uh know same names because what happens is okay we shall see that later now um Department name right now department number is one Department name is let us say computer science okay now if you want to see what is the department in which employee number one works what is the name of the department such kind of queries are very often possible which means we have many uh many relations or tables possible in our database and then uh we might we might be having a query someone will be interested in knowing the information which might require you know going through many tables for example what is the um what is the department name in which employee number one is working then you have to find out the department number in which employee number one is working and then you should go to the particular department number and then find out the name so this type of queries are possible so now then what happens is a kind of joining these two tables will be done right a kind of it we shall disc discuss about it later anyway when we have hundreds of tables and if we have to you know continuously join the tables in not to answer many queries then what is the you know what is logical is why should we make these many tables at all the simplest database design will be putting everything together in one table what is Advantage no overhead of Maintenance right you put them all together in just one table have a universal table let's call it as universal table which means I want to put everything that I have in my database in just one big table right everything either it is employee or department or uh you know like this I'll have many many uh columns all the attributes will be kept in these columns and everything is kept in one big table let me call it Universal table now what is the problem with this or what is the advantage of this see information retrial is easy now because you need not go through many tables painfully you can go to anything that you want and you can search for whatever they're asking for example if I have employ ID here and then employee number and along with this if I even put Department ID and maybe department number right and if this department is also having some supervisor ID right then I'll have supervisor ID of the department also everything here then if I need what is the department for which employee number one is working then I can directly go to the department name and I can give you this field isn't it without going through various tables it is simple and I need not break my head over how many entities are there how many relationships are there what is the what are the attributes given the extract all the attributes and put them all in one table and it is done you need not do anything else right but the problem with such a table is there are various problems here one simple problem is obviously redundency right so redundancy is possible why redundancy because let us say a department is having 100 employees right employee number one employee number two employee number three so on 100 employees right then I should continuously have the department ID right let us say all of them are working for department number one whose name is you know computer science and the superintendent name is super that supervisor name is let us say supervisor ID is 10 right then I should have this information for every employee who is working for the Department in case if you would have had these two tables then keeping this information in a separate table requires this information to be present at only one place right this ID will be you know repeated here but then entire information will not be repeated therefore redundancy is there so obviously there is wastage of space fine okay anyway say let us say we have enough space and we want to go with this but then there are lots of problems that will get arised whenever you try to you know insert something delete something or update something right they are called as anomalies so one is rcy other problem with such a table is anomalies so what are there are three types of anomalies okay anomalies means um problems you can think of it that way so what are the problems is one is when you insert there will be some problems insert anamaly so how will an insertion create a problem here is assume that we want to insert um a new employee with one one who is also working for the same department and you are trying to you know insert it you have you have written the department ID as one and the department name is supposed to be computer science but because of some mistake some error some typing error let us say you have written it as you know ECE okay now let's say by mistake you know uh because of some error you have typed it as EC then what happens is the same department now in the database will have two names and this will this insertion might go unchecked which means you know database might accept it because it doesn't know where to check or how many tles to check and it doesn't know which one is right right so when you are having the same uh same information at many many places there is a chance that it might get inconsistent at one point at one place it might show some information and at some other place it might show some other information right therefore insertion anomalies are possible right next one is deletion anomalies deletion anomalies means I'll just take an example here let us say I want to delete all the employees all the 100 employees working for department number one now no employee works for department number one then what happens is when you delete all the employees of Department then the department itself gets deleted because there will be no entry which is containing the department number right so you know in case if you want to have that department even after deleting all the employees then you might have to have only the department uh details and in the place of employee details in that tle you should have all the null values and again you should keep track of whether I have deleted all the employees or is it the last employee or the first employee is added if the first employee is added then you have to modify this it is going to be a very headache I mean it is all overhead in this on the software you have to you have to make lots of you know checking and the software code itself will become um you know hectic because writing the code itself is going to be a pain because whenever you insert something delete something you might have to check the entire table which sometimes may span to GBS or terabytes right so deletion is also going to create some problems and then update update analy means whenever you try to let's say modification okay or update analysis update anomaly so update anomaly means whenever you try to update some entry that might create a problem for example let us say you wanted to change the name of department number one from computer science department you wanted to add something to the name of it let us say it is CS and it now the computer science department is now changed to computer science and information technology then what happens you have to search in the entire database and you have to see wherever computer science is written and you have to change every name it is going to be very very painful right in case if this information is just present in one table like this going there and changing it it is very easy it is like that hash Define isn't it in C programming language if you have a constant it is always better that you define the constant using hash Define at one place and use that constant name wherever you want it later if you want to change it just change that hash Define right similarly here instead of having this throughout the you know database just have it at one place that will be better isn't it okay so these are all the problems which will occur if you try to uh you know reduce the overhead of Designing the database by combining all the tables right so this solution is always simple divide the tables into as small tables as possible right then how many how small should it be ideally if you don't want any of these problems to occur if you don't want any anomalies or if you don't want any problems the ideal size is two attributes which means make a table in which every table has two attributes if I if I have many such small tables what happens is in order to retrieve some information I might have to go through hundreds of tables in some cases therefore even though going for two attributes is always best sometimes we can get the same results I mean the best uh best database designs even without uh even with some bigger uh you know some bigger tables you need not go till uh you know Smalls this small see going for attributes of you know a table which is containing only two attributes is the best thing I'll tell you why later that is called as bcnf we shall see that later that is the best thing you could do but then because of this design the query time is going to be very very high so what other solution we have is you know instead of going for so small tables use some laws use some formal methods in which you can get the same kind of good design even with a bigger table but not with so big table right so now the solution for all these problems is to divide all the tables not just this one even this table might also be having the same problems right do there might be somewhere some duplication problem or there might be somewhere you know anales we don't know that take every every uh table and see if it is good test if it is good test if your design is good right if is not good we are going to go for division or splitting the table right so that is called as normalization okay so we are going to split the tables divide the tables into small small tables which will contain less number of you know attributes in such a way that your design will not contain all these problems right in order to do that that particular process which is called as normalization that procedure of dividing the tables is called as normalization in order to do this normalization we are going to use something called as functional dependencies FD in short functional dependencies right so we use functional dependencies and the concept of candidate keys so we you already know what is a candidate key isn't it so we use functional dependencies and candidate keys in order to evaluate formally formally means we have a well- defined procedure right all this formally whether it design is good or not in case if it is not good using some algorithms using which are based on this functional dependencies we are going to divide the tables right so once we know about the functional dependencies once we learn about it we can go for normalization okay fine now let's see uh the concept of functional dependencies we have already seen the concept of keys isn't it candid key Super Key like that so what is a key in the in general given the value of that particular attribute we should be able to identify a row in the table uniquely so what I mean to say is if you whenever you say that an attribute is a key the main the actual meaning of the term is either candidate key or a you know Super Key the meaning of that term is given that particular let say this is a and I'm saying that a is a candidate key right so given that value of a a as let us say two you'll be able to identify the other values let us say this one is a and this one is B right so given the value of you know capital A as two you'll be able to find out the values of other attributes right that is the meaning of the key uh so one way to write it is given the value of a you'll be able to identify B and C isn't it so this is called as functional dependency got it I'm just generalizing it right so in case I assume that um you know so what is the meaning of formal definition is this if I give any value of a you'll be able to uniquely say you know what are the values of B and c's for that particular one which means if you say that a value is two then you'll be able to say B and C are A and B like this right uh so you know one way to define it is if if a do let us say t of T1 of a which means if a tle T1 is having some value in the attribute a and if it happens to be the same value for some other tle right in a then if this is the case then for the tle you know for the tle T1 and T2 B and C values should be same this is the meaning of it so what I mean to say is in case if a is having some value in tle T1 and some value in tle T2 then a will have the same value in case if these two values are equal a will have the same value here what I mean to say is you know wherever if a repeats if I'm just taking it as an example in case if a repeats then B and C are also supposed to have the same value that is the meaning of it right or one other way to interpret it is given a value of a you should be able to determine what the values of B are right so it is not exactly the key there is a kind of you know relationship between the key and the functional dependencies if you want to understand it let me take it this way if I say you know a determines B and if this is a and if this is B then a need not be a key always right the meaning of it is whatever is the value of a you'll be able to get a unique value of B right so it can be you know small a small a small B small B it can be 1 1 22 which means for every value of a right there will be a unique value for B for every unique value of a there will be unique value for B which means for the value of small a if you query about what is the value of B you'll always get one either here or here right that is the meaning of it so a determines b means given any value of a you'll be able to uniquely find out the value of B now why is it very important in terms of you know splitting the uh splitting the table or you know um let us say eliminating the redundancy is see this I'm just taking this example see this now we know that given the value of a you will be able to find out the value of B isn't it then uh whenever a repeats B is also repeating right let us say a is repeating 100 times then what happens to B value if a is repeating small a 100 times B is also going to repeat small B now equal to 100 times which is completely a waste of space so instead of this what you got I'm just taking an example let us say if a is having like this A A 1 1 and then maybe B and then let us say two right or even one is also fine right now what is the meaning of it whatever is the value of a you'll be given the value of a you'll always get a unique value of B then storing this value of b along with this is going to create all these redundant values right instead of that what we could do is don't store assume that c is having here D E F G H don't store B here just delete it you can save lot of space you can save B separately and you can write it new table AB all right in this new table AB you can write value of a is 1 and value of B is 2 that's it so this enre information is not now not required just I can write it like this in case if it is you know repeated 100 times I have to just write it one time so so the main use of this functional dependency is see what is functional dependency is B is functionally dependent on a or a determines b or given a value of a we can functionally determine what is the value of B the advantage of this one is we can reduce redundancy like this right so whenever you have such a relationship among various attributes it is always better that you create a new table right in such a way that a will be able to determine B right so when is it useful whenever uh you know we are repeating lots of values Whenever there is lots of repetitions for a right so the main purpose is this in a relation let us say very big relation is there okay and with lots of attributes you have to find out some areas like that where there are lots of repetitions and if you could uh let us say there is a a a a and then one one one one you have to identify all all such spots in the tables and see that you can make it as a separate table with just A1 in order to identify this functional dependencies are going to be useful so functional dependencies will say what are such areas which could be minimized further right so using these functional dependencies we can actually split the tables it is also called as decomposition right so these are going to play a key role here okay now uh what is that we are actually trying to do is our final aim is to see that for every functional dependency the left side of it the attribute which is determining is going to act as the primary key for a new table right that is called as bcnf the ultimate aim is to make that for every functional dependency I'll try to separate the tables in such a way that all the attributes which are know determined by the left side are going to fall in one table with left side being the key that is the final a bcnf now in order to go to that final bcnf I'm going to go through various levels of normalization so I'm going to start normalization like this one is called as first normal form so we see that initially every table is in first normal [Music] form we see that every table is in first normal form from then from there we see that every table next is in second normal form then we see that third normal form and then bcnf right so ultimately our aim is to reach bcnf so in order to reach bcnf we go through all these steps in order to go through all these steps we are going to use functional dependencies and candid case Okay uh so we no there are various types of functional dependencies like here I have shown you one example where left hand side is one attribute and right hand side is one attribute here you have seen know left hand side is one attribute and right hand side is two attributes right so it can be left hand side can be any subset of attrib attributes and right hand side can be any subset of attributes right so in general if you write X determines y like this it is X determines y not X tends to Y okay or not X derives y the same symbol we might have seen it even in um the grammar right there we say x derives y but here x determines y given the value of x you can unly determine the value of y now X and Y can be a collection of attributes or the subset of attributes okay so X and Y need not be single symbols they can be like you know a b c here determines DF something like this the formal definition of a functional dependency is this whenever you have a determines B where a can be a collection of attributes and B can be a collection of attributes then what is the real meaning is this one see let us say there are two tles T1 and D2 in the table and you know this is collection of a attributes and that is collection of B attributes if T1 and T2 agree here which means if T1 and T2 are having same values in a then they must have same values in in here then only insertions will be possible right and if T1 and T2 disagree here which means if T1 and T2 are having different values for a then you know they may agree or disagree here so what I mean to say is let us say that particular functional dependency is uh applicable for a table when do you think that a functional dependency is applicable for a table whenever all the attributes present here and here are also present on the relation schema then that particular functional dependency has to be applied on every such relation okay so before you insert or delete or before generally insertions only right generally whenever you try to update it or modify it we are going to see that you know this functional dependency always holds on all the relationships for which it is applicable let us say this is the table and there are some set of attributes even though I'm writing it as as if it is two columns A and B might be two columns which means might be simple attributes or they might be collection of attributes right now what is it they are saying if a determines B is a functional dependency you have defined then definitely on this table whenever a values agree which means if a values are like this same then they must agree here also which means B value should also be the same so if it is a here it should be a right if they don't agree which means let us say it is 23 right and here they may or may not agree which means you know either you could have a here or you could have B here it is valid got it so now if You observe it by defining it this way right so if You observe it by defining it this way what happened is everything here so for example a deres b see this for a given value of a value of B is unique and in case if it is different we never check about it what it so functional dependency means it is applicable wherever you know in some part of the relation if it is applicable then wherever you see the left hand side as same then the right hand side should be same and if it is different it is going to be different right so why are we going to insert two times the same left hand side see uh it is definitely possible Right the entire relation as a whole should not get repeated but a part of it can get repeated there is no problem right and now especially this is going to cause such entries are going to cause redundancy let us say we have one more time one a one more time one a one more time one a right now instead of storing at this entire thing in this table we could have stored it in a separate table simply containing a and B and then we have only one attribute like this right so instead of all this 1 2 3 4 5 we can have just one toule and that one will represent thisy can be eliminated so the entire Focus here is you know making every functional dependency applicable to one particular table in which the left hand side is not repeated see here the left hand side is repeated because a is not a primary key for this table got it in case if you to make it a primary key definitely left hand side will not get repeated if left left hand side doesn't get repeated then there will be no redundancy redundancy is only when left hand side is you know repeated isn't it see the rule is this if T1 and T2 agree which means if two tles are having the same value for a then only we are getting the same values here then only we are getting the redundancy in case if we can make it a primary key how can you make it a primary key you make it a separate table itself completely in that table you can make it a primary ke key in that you see that you know all the values of a are different right then there will be no redundancy at all okay fin Now using this closure properties I want to find out the candid key let us say this is the table table is containing four attributes and these are the functional dependencies given a determines b b determines c c determines D and dine here these are the functional dependencies now my aim is to find out what are all the candidate keys on this table the reason is I will find out the candidate key and then make one of them as a primary key right so how can I find it out now what is the candidate key is uh given an attribute you should be able to uniquely determine all the other attributes of the table then it is going to be a candidate key in this uh you know definition right so now how many candidate keys can be possible or how many um elements or how many candidate keys I should test in the sense if I have four attributes how many total candidate keys can be possible see this if I have four attribute let us say if I have two attributes A and B right and how many how many candidate keys can I get one is a maybe other is B and other is a isn't it similarly I have if I have three attributes a b c then how many attributes how many candidate keys can be might be possible I'm not saying that everyone is going to be everything is going to be a candidate key but how many combinations or possibilities are there a can be a candidate key b c can be a candidate key a can be a candidate key BC can be a candidate key right CA can be a candidate key or ABC can be candidate key so here I got three and here I got uh 7 isn't it so in general what is this uh what is this given this set what is this this is nothing but set of all subsets except one element isn't it what is that element the null element right so except null this is the set of all subsets right therefore if I have n Elements which means if I have A1 A2 so on a n right how many candidate Keys might be possible Right totally so it could be 2 power n is the total number of subsets possible from this out of which you should you should always take out that null null cannot be a candidate key right therefore you know 2 power n minus one candidate keys will be there so I might have to test each one of them and see whether it is really a candidate key or not right okay and then uh one more thing is okay let's see this example and we shall explore it right so for this coming to this example how many candidate keys will be there 2^ 4 - 1 which means 15 candidate keys will be there so so should I examine all the 15 combinations or can I rule out some of them it turns out that we can rule out some of them so you know just for the sake of this example I'm just trying trying to do it in you know we are not going to do this uh know procedure in all the examples just for this example we shall see it okay it is not required so don't worry there are shortcuts also we shall see them but just for just for you to understand the concept I want to do it okay now for this one for this particular uh table is there a guarantee that at least one of these combinations turn out to be a candidate key there is definitely a guarantee and what is that uh candidate key if you don't find any candidate key you take the combination of all the attributes and that is supposed to be a candidate key in case if you don't find anything else to be a candidate key how is it possible because we already have the rule that in a table no two tles can can have the same values in all the attributes therefore by the definition of relation itself the table itself in relational database we have this constraint that if you take the table all the attributes you'll definitely get that as candidate key in case if you don't find you know any other candidate key got it therefore there is definitely a guarantee that if you don't find any any candidate key set of all attributes is going to be the candidate key fine now how many candidate keys are there for this example 15 now I want to see out of all these 15 possibilities which of them are really candidate keys right so how can I find it out is first there is uh you know this is the candidate key of length uh 4 now I want to find out the candidate key of length three AB C right or a c d or AB b d or B CD these are the candidate Keys which are possible of length uh four now I want to see the possible candidate keys of length two ab b c c d right and uh da right and AC a d or a is over right so AB is over AC is over a is over AB a a is over and then BC BD BC is over BD is not over BD and then CD let me check 1 2 3 4 5 6 7 I'm supposed to get only 6 4 C2 is 6 huh CD is repeated here okay fine so six right so here I got one and here I got four and here I got six right so how many is this uh 11 I got and what about the candidate keys of size one so a b c d right these are the candidate keys of size one so four isn't it so I got all 15 now I have to test each one whether it is going to be a candidate key or not now tell me uh which from which order should I start which means should I start from here searching for the candidate key or should I start from here you just think about it it is better if you start from here if you start from here you might have to do lot of searches if you start from here you you will have to do only few searches the reason is see if a turns out to be a candidate key I'm just assuming okay if a turns out to be a candidate key then what happens is anything which contains a will not be a candidate key that will be a Super Key isn't it so candidate key is minimal now if you say that a is a candidate key you cannot say AB is a candidate key because AB has to be minimal if you remove B you can still get a better candidate key better no minimal right therefore if a is a candidate key no superet is going to be candidate key therefore if you search for this one and if you find that this one is a candidate key then you can rule out many things right so you can rule out everything that is containing a maybe you can rule out this this this right and then you can rule out you know this and you can rule out this this this therefore see this how many have dropped out right so in case if you find out B you can rule out many things right that is how you should go in case if a a is not a candidate key then you might have to observe the things which are not know which are like that so what I mean to say is it is always better that since a candidate key is a minimal Super Key you start with the minimal subsets which means subsets containing less number of elements and you just try to verify whether that is a candidate key if you're lucky right you'll find it very easily in case if you are not lucky you might have to go till here in that case you know you might have to search 2 power n therefore it is going to take order of 2 power n right exponential time but anyway for most of the cases you'll be lucky and moreover second thing is you need not search all this in many of the questions options will be given by looking at the options you know you can test which one of the one which one is correct you need not actually derive it you you can check the options and go go ahead with this now let's let's see for this one now let me see if a is a candidate key or not how can they find out find out A+ what does A+ give a and because of a I got B because of B I got C and because of C I got d right therefore a a is able to derive all the attributes unly so a is a candidate key right and what about B+ so we get B and because of B we get C because of C we get D and because of D we get a right and we got all of them therefore B is going to be a candidate key B is also a possible candidate key right what about C+ so C is going to give D and because of D I get a and because of a I get B I got all of them therefore C is also candidate key what about D+ because of D I get D and again because of D I get a and because of a I get B and because of plus b i get C I got all of them right therefore a b c d are going to be candidate we are lucky in this case that we got a B CD as candidate keys since we got this ABCD as a candidate Keys none of the above can be candidate keys at all what is the reason because they all contain a combination of this all right so whenever any any any subset contains a candidate key then it is going to be a Super Key now what we are interested in is finding out the candidate Keys then therefore for this particular example these are all the candate case got it now we shall practice lots of examples with which you know you'll be able to identify uh you know this candidate key problem easily now given two sets of functional dependencies sometimes we wish to find out whether they are equivalent or not which means you know writing functional dependencies in one form is completely equalent to writing it in other form right for example if you take these two functional dependency sets f is denoting some complete different of functional dependencies and G is denoting some complete different of completely different functional dependencies now what we wish to find out is whether they both are equivalent which means semantically are they same see they're not equal but they are equivalent right that is what I want to find out right away they are not equal isn't it if there is no one to one correspondence between all of them there is no there is no equality at all but what I wish to find out is equivalence right so how I do it is see this now first I'll find out when I have two sets first I'll find out whether f is covering G right so I write it like this F is covering G or not so how can I find it out is so whether F covers G or not I'll take each functional dependency of G and I'll see if this dependency is already implied in F then I say that if every functional dependency in G is already implied in F then I can say that yes F covers G right and then I'll find out if G is covering F or not right so you can find out anything see the order is not important which means either you can check f is covering G first or you can even check G is covering F or not first right so what does it mean it means that I'll take each functional dependency of F and I'll see if it is already implied in G right how to do that using closure properties only now let me check whether f is covering G or not which means I'll take one by one each production and then I'll see if F can cover those functional dependencies or not now let me start with this I want to see whether a derive a determines CD can be covered by F or not that is why I'll find out A+ in F in F if A+ contains CD then this is already covered by F right so now I want to find out A+ in F so what does it mean in this one right A+ so a and now because of a I get C and because of a I get d right I don't want to find it completely I just wanted to see if A+ is you know a is able to determine CD or not therefore I'm going to stop it here even I get more more attributes also I don't need them here right so yes definitely you know A+ is having all this so a is having the capacity to determine CD therefore a determines CD is already implied in F right and next thing is I want to find out if e determines ah is covered in F or not for that I have to find out e+ e+ in F so what is e+ in F e+ is I get e and because of E I get a d and because of a I get C and because of a c i get d right and because of E I get H also so what is it I want yeah that's it over right uh yeah because of he I get ad and because of he I get H I would have directly got it so now ah ah is already you know present here therefore e has the capacity to determine a and H in F and therefore this particular functional dependency is already implied here got it and now I want to see so definitely this is true it turned out to be true which means F covers G it turned out to be true now I want to find out whether G covers f or not now I'll take each one in F and I'll check with the G right which means I'll take this and I'll check this whether it is implied here or not how can I check it I to find out A+ in G right see these are these are found out in F right now I want to find out this in G now what is a plus in G because of a I get CD and therefore C is already there so I can stop it here and say that it is covered and next thing is I want to see see if this one is covered or not so how can I find out AC Plus in G because of a I get a c d that's it I got D therefore it is covered now what about it e see are you observing it I'm not going to find out complete closure of AC because I don't need it here I just want to find whether the right hand side of a production is going to be present in the closure or not so once I get the right hand side I can stop it I need not complete the complete I don't want it right and next one is this one I want to see whether that production is covered by G or not so for that I had to find out e+ if I find out e+ I get e right and then um see I'm finding it here right because of E I have ah and because of a I get CD therefore ad is covered so ad a is already there in+ so this one is covered in this and anyway again e h is also covered because e+ is having H right so this the entire set f is covered by G and G is covered by F therefore both are equivalent right so whenever both are covering each other both are equivalent from these two we can say that both f f is equivalent to G not it okay now let's see if F covers G and G covers F here or not so first of all I'll check whether f is covering G or not which means I'll take each production in G and I'll see if it is covered by F or not okay now first I want to check this so for that I have to find out A+ A+ in F so what is A+ in F I get a and because of a I get B and because of B I get C therefore A+ is containing BC so this is covered and what about this one in order to check this I to find out C+ so what is C+ in F C+ because of you know C D because of this I got D so it is already it is already there anyway right it is covered so it is true f is covering G now I want to find out if G is covering F or not right I'll take each production in F and I'll see if it is covered by G or not so what is this production uh in order to find if this is covered or not I'll find A+ so if I see A+ in G I'll get a b c and therefore this is covered right so this production is covered in G now in order to check this one I'll find B+ in G if I find B+ I get B right and I'm not going to get anything else therefore B+ is does not contain C and so this particular production is not covered by G so G is not covering completely f f is covering G but G is not covering F so both are not equivalent got it so why why is this so because this particular uh production this part sorry this particular FD is not uh you know implied in this therefore uh therefore we cannot say that uh you know both are equivalent all right so they are not equivalent now let's try to minimize if a functional dependency set the reason why do why we want to minimize this it will be easy to represent you know lots of functional dependencies in a smaller form if you have very less functional dependencies and which is going to convey the same meaning it is obvious easy for us to store it in the computer isn't it so what I mean to say is if you have a set of functional dependencies F and if you could minimize it to other set of functional dependencies G in such a way that g covers F and F covers G and G is minimal so what do I mean by minimal is you will not be able to delete either the right hand side of a production oh sorry either right hand side of a FD or the left hand side of a FD and you could still maintain this property right that is called minimal minimal means you cannot delete anything from it further so once let us say you got a you got a functional dependency set G in such a way that it is covering F and F is covering G which means both are equivalent to each other and moreover G is minimal which means you'll not be able to delete anything from G and still have this property in such a way that if you could if you could get something right then we can say that g is minimal right uh minimal cover of f so what is Advantage it contains very less number of Productions and moreover it contains less number of attributes uh you know in the left hand side so anyway if a if a FD set is already in its minimal form you'll not be able to minimize it in case if it is not in the minimal form you'll be able to minimize it right let's see the procedure if you follow few steps it will be easy right yes you can obviously use that uh you know the properties of functional dependencies but it's going to take a lot of time and you know the answer might not be right also so we shall have a different Pro different procedure if you follow that procedure always a minimal set is guaranteed if it is if it exists okay now see this procedure to minimize the set first step is split the fds in such a way that right hand side contains single attributes always see that right hand side is going to contain single attributes before you apply the procedure because it will be easy for us to you know eliminate it that way so see this if I have a determines BC then break it into a determines b and a determines C why is it important is by breaking it this way we can determine whether we could remove b or we could remove C or we could remove both of them so if I have both of them in Combined manner I'll not able to test if B is redundant or C is redundant once I split it then I can test if B is redundant or C is redundant independently okay and next one is find the Redundant fds and delete them from the set so once you split it like this find the Redundant fds and delete it from the set when can you say that FD is redundant you remove that FD and see that from the remaining fds you are able to derive it somehow which means see this if you have any like this containing a determines b b deter C and A determin C right so here you can remove a determines C because you'll be able to derive this even without it which means without this if you try to find out A+ that contains C right if we using these two only if you try to find out a plus what do you get a B and C which means without this we are able to get a plus which contains C therefore it is obviously redundant so that is how remove it next one is find the Redundant attributes on the LHS and delete them so you can even find redundant attributes on the LHS left hand side for example if I have you know fds a determines C right then one of them may be redundant and that one you can easily find out you know in this way see this you find out B+ if B+ contains a then this is redundant okay it is not straightforward to understand just think about it see if B+ contains a then a is redundant here the reason is the entire purpose of this FD is to derive C determine C isn't it now when you try to start with only you know when you try to have A+ definitely you are going to get C fine and in case if B has the capacity to determine a then B+ will first contain a and then using a b you know you can determine C therefore this turns out to be redundant got it so in case if B+ contains a a is not required for this functional dependency because just with B+ you'll be able to get a and anyway you know a is going to imply C right therefore you know if you if a A+ contains B right then B you know you can easily delete b or if B+ contains a you can delete a got it now let's see this example with this example I'll explain you all these steps maybe it might be clear then okay so first step is you try to split them so step number one is you try to split them in such a way that right hand side contains only one attribute see first production a determines C only one attribute is there and AC determines D only one attribute is there e deter Min a one attribute is there I'm splitting it okay e determines d one attribute and then e determines H now what you do is take each production one by one and see without that if that production could be covered by the remaining which means if I delete it right then without it I'll see if this this one can be covered by the remaining a determines C from the remaining I'll try to find out A+ if I find out A+ from the meing what do I get I get a that's it I think nothing else therefore A+ does not contain C which means without this production a does not have the capacity to determine C therefore it is required got it and now let's see about this take this one and delete this and from the remaining which means this one this one this one and this one you try to see if uh you know it could be cover word so without this production I'll just try to find out ac+ if I find out ac+ I get AC that's it nothing else and I don't get D therefore without this production AC will not be able to determine D therefore this production is required and now let's see this so take this production delete it and you know in the remaining Productions see if you could get that a in e+ let us find out e+ e+ contains e and because of E I get D and H right but there is no way I can get a in fact in fact there is no other production which can determine a without this check that a is not present at right hand side anywhere so there is no way you'll be able to determine a unless it is in the left hand side right therefore it is required and what about this let's see this without this without this production you try to find out e+ and you see if D can be derived so if I find out e+ then it contains e right and because of E I get a and because of a I get C and because of a I get D yes so even H is also present but it it doesn't matter so e+ is going to contain D therefore without this production I'm still able to get D therefore this production is useless what it so sorry this FD is useless right so you can actually delete that FD now what about this one again do the same thing assume that it is already deleted don't take into consideration now let's check this one e e determines H so without this right and without this in fact because that has already been know deleted now without these two just find out e H and see if uh you'll be able to get anything here right so e determines H I'm I'm going to find out e+ without these two because it is also it is already found out to be redundant and removed and now we are going to remove it and see in the remaining if we are going to get H so anyway we are not going to get H because it is simple see this right hand side of any of the other Productions does not contain H so how can I get H here there is no way isn't it unless the right hand side of other Productions contain H we cannot get it see in this case right hand side of other Productions contain D that is why I'm able to you know determine D without using this production so there is not it is not possible so it cannot be deleted right so it turns out that only this particular FD can be deleted not the others so after deleting this particular FD should I again check if anything is becomes redundant actually after adding something some other production might get redundant after deleting something some other production might not get deleted therefore therefore you can just do it one time and and and stop it which means just go through it in one cycle and you find out what are the functional dependencies that could be know deleted and once you find out delete them and leave it okay you need not do it second time now let's go to the Second Step so what is second step see first step in fact know decides about the right hand side so since right hand side is containing only one attribute deleting FD is nothing but deleting right hand side isn't it so first step is about finding out the uh sorry it is let's say it is second step right this ener thing is second step this writing this is first step and deleting it is second step okay now second step is about finding out the redundance is in the right hand side deleting FD is nothing but deleting the right hand side since right hand side has only one attribute and the third step is about deleting redundancies in the left hand side now when will there be redundance in left hand side whenever there is more than one attribute in the left hand side right so if there is only one attribute in the left hand side or if there is only one attribute in the right hand side that will be taken care in the Second Step because deleting the fds is nothing but deleting the left hand side if there is only one attribute or deleting the right hand side if there is only one attribute now when there are more when there is more than one attribute then we go to third step in this we shall see if in the left hand side if you have more than one attribute if you could delete one of the attributes right so from the from the remaining set what is remaining set a determines C is remaining AC determines D is remaining e determines A and E determines H these four are remaining now we want to find out what could be deleted from this further so with these things we need not check about them because they have already been taken care here right so only concern is this one now is a redundant when will a be redundant if C+ contains a then you need not write a here the reason is you can find out C+ first and C+ if it anywhere if C+ if it anywhere contains a then AC is going to determine C therefore C is just enough to determine d right so are you getting this if C+ contains a then you find C+ it is going to give you AC then AC is going to determine D anyway therefore writing C determines D is enough right so let's find C+ in this entire production and in this entire thing C+ right and then uh you know we shall see if C+ contains a either you include it or you don't include it it doesn't matter while you are finding C+ either you include it or don't include it it doesn't doesn't matter because it is already contain containing a unless C+ contains a right this this functional dependency doesn't make any change so when you're testing for this extra redundency on the left hand side either you have it or don't have it doesn't matter when you're talking about the right hand side you are supposed to remove it and then test it in the remaining but when you're talking about the left hand side you need not uh you know delete this production either you have it or don't have it it really doesn't matter okay now what does C+ contain it contains C only C isn't it it does not contain a therefore a is refed now what about A+ if A+ contains C then C can be deleted now let's see A+ A+ contains C from here this is enough you need not take it further right so you just found out that A+ contains C you can stop it here and you can say that c is rendant right so this is the only production which has two attributes right and one of the attribute turned out to be redundant then what what did we get we got a determine C and then a determines D and then e determines a and then e determines H got it right so this is the minimal set if you want you could actually merge it right how can you merge it a determines C and A determines D you you would have written it as a determines CD right and E determines a and a determines H you could have written it as e determines a h right therefore this is the minimal set for this set so you know you have actually minimized it into two Productions given four Productions we got two Productions right fine so anyway uh you know minimal minimal means you should not be able to reduce anything and you should not be able to get the same thing and and you know if you have any doubt after doing this procedure I suggest that you just see if both of them cover each other right which means you should be able to get this production from there see this A+ should contain CD here so if you find out A+ A+ contains AC and AC contains you know because of AC you got D therefore this one is covered and e+ should contain you know a here so e+ will contain a d and H yes it is covered and now this one should be covered here which means a should be able to derive C s and AC should be able to derive d s in fact a itself is able to derive d and e should be able to derive a d e is able to derive a and a is able to derive d right and should be able to determine H right yes is able to determine H right therefore both are covered by each other and so they are equivalent and moreover it is containing minimal number of attributes which means you cannot delete anything from this further and you can get the same property holding what the property both cover each other right this is how you can minimize it so before going for normalization okay first of all normalization means you know most of it involves decomposing a table which means if you have a big table we generally try to divide into small tables right and whenever we do such uh you know decomposition we should see some properties one property is whenever you decompose a table into many tables then we later would like to ask some questions which are based on all the small tables then we might try to combine them so when we decompose a table and again when we combine the tables into the original table the number of tles or the data that should not get altered which means there is no way you lose the data but then you might sometimes get extra data right so we I'll just show you that with with this example let us say we have this table and then we decided that we want to divide it into you know small tables right so whenever you divide into small tables it is generally uh if you don't have any common attributes in the tables it will be difficult for you to combine it later for example if you just split it out this way you know if you have taken it into two tables one is containing just a and other is containing BC right then later if you had to combine them it will be really a big problem see this if you try to do like this then what happens is a will get a will have only two values A1 A2 and b and c will have you know three combinations I think B1 C1 and yes B2 C2 these two combinations and later when you try to combine them you know you try to take a cross product isn't it which means again if you try to merge them into the table a b c then what happens is you have to combine this with both of these right which means you'll get A1 B1 C1 right and again A1 B1 A2 A1 B2 C2 right so actually this uh A1 B2 C2 is not at all there yeah it is there let's see one more now then again you get A2 B1 C1 right so A2 B1 C1 is there and again you get A1 A2 B2 C2 and A2 B2 C2 is not there isn't it see one more is A2 B1 C1 and other is A2 B2 C2 right so by looking at this we got one more new tle added right so just to avoid this whenever we split a table into two or more tables we see that among these tables at least some attributes are common one or more attribute is common so that it will be easy for us to combine later and then what attribute should be common and we should not take any attribute randomly I'll just show you what happens if you take any attribute randomly assume that we are trying to divide it into two tables like this okay so I want to divide into two tables one table contains ab and other table contains AC which means I'm having as common attribute you know uh a a as the common attribute now what does the table containing AB will contain see this the which means if the table is split split up this way then the table containing AB will contain A1 B1 A2 B1 A1 B2 isn't it A1 B1 A2 B1 and then uh you know A1 B2 and the table containing AC will contain A1 C1 A2 C1 and A1 C2 right now when I try to combine them so again later because of you know some information if I want some information then I try to combine it why do I combine it is sometimes we would like to ask some questions about it you know given the value of a if I ask about C then we might have to combine it and then get the value because here the there is no relationship between a and C the only relationship is from here you have to go there and you have to get it right in that cases we combine it now we combine them using the common attributes so uh common attribute is a so wherever a is having A1 we combine these two right and again a is having A1 here right so this one is going to be combined with this as well as this so what do we get a b c we get this this one is going to be combined with this as well as this so for this let's combine these two first because A1 is common right now A1 and B1 and C1 right and now let's combine these two because A1 is common then what do we get A1 B1 and C2 right now let's see if this information is present there A1 B1 C1 is there but A1 B1 C2 is not there isn't it this information is completely not there this is extra added right let's see let's complete it now what about A2 A2 is combined only with this one right so what do we get A2 B1 C1 and again here A1 right and let's combine these two A1 B2 C1 and let's combine these two A1 B2 C2 right so if you watch it we got two more extra tles so one extra tle is this and what is the other extra tle A1 B2 C2 is fine and A1 B2 C1 this one is also an extra double right so these two are extra doules we don't have uh these two values there all right so this is the problem whenever you divide the table like this we might we might see that you know sometimes extra doues get added right it is called as lossy decomposition lossy actually data is not lost we gained the data but still it is a loss isn't it we have got some extra information which is not true that is a loss so this this type of decompos decomposition is called as loss decomposition if you want to see one more decomposition let us say uh I I want to show you that every possible decomposition is not lossy right so we might decompose the table into two ways this way instead of having a and AC maybe I'll have ab and BC let's see what happens with this if I see AB what are the various combinations for a one combination is A1 B1 and another combination is A2 B1 and another combination is A1 B2 right and what are the various combinations for BC One combination is B1 C1 and other combination is B2 C2 now I want to combine them so these two can be merged and this one can be merged this way right then what do we get when I combine these two into into the table containing all these three so one tle I get is A1 B1 C1 because of these two and then A2 B1 C1 and then then A1 B2 C2 right check this we got the actual table there is no data loss which means no extra Tes are added so one thing is whenever extra doues are added we call it data loss okay just don't get confused we didn't lost any data we gained it but still it is wrong okay so what I mean to say is every decomposition is not going to be a lossy decomposition so some of the decompositions are going to be lossy so what we want is we want lossless decomposition ition so you know it turns out that lossless decomposition is possible whenever we split the table into two parts and the common attribute if that common attribute is either a candidate key or some key attribute is key in one of the tables then we can say that the decomposition is not lossy which means see this we decompose the table into two parts isn't it now what is the common attribute B if the common attribute is a key in one of the tables then the decomposition will not be lossy right here it so happened that b is a key in here which means B values are not getting repeated even though B is repeating here right that is why you know if it is at least you know key in one of the tables then the decomposition will not be lossy that is why this is not lossy and here if you watch it a is a key Either in this or this right a is repeating here as well as here right therefore whenever you decompose it see that the common attribute in the decomposition is going to act as a key so what do I mean is if you're are going to know decompose a big relation R into two smaller relations R1 and R2 right whatever you take R1 intersection R2 it is the common right it should either be able to determine R1 right R R1 intersection R2 it should either be able to determine R2 right which means the common attribute has to be either a key here or a key here right then the decomposition is not going to be lossy right sometimes you know one other way of writing that it is key is you can even write it as R1 - R2 okay which means uh R1 - R2 means it will not contain R1 intersection R2 one other way of writing it either you write R R1 leave it there or you write like like this it doesn't make any difference okay because in some questions you might see like this and you might get confused that is why I'm writing it it is also saying that you know R1 intersection R2 is going to determine every attribute in R1 except that common part anywh that common part is already included isn't it R intersection not to contains that common part right so either you write like this or you write like this it is also fine so anyway both of these say that the common attribute has to be a key in one of the table that is the meaning of it so from now on we are going to see decompositions you know whenever we divide the table see that the common attribute is going to be a key in one of them now let's see um the next property when we try to decompose that is dependency preserving so whenever you try to decompose the table you should even see that all the dependencies are preserved I mean it is not a compulsory thing but then you know it is better if you have it lossless is compulsory but decomposition you know this functional dependency preserving is not a must let's see this I'll just show you what it is let us assume that we have a relation R which is containing some attributes let us say uh you know A1 A2 so on a n some attributes right and on this we might have already a functional dependency F defined right from the sematics of the database we might get the functional dependencies and now this functional dependencies F will be such a way that they are applicable on R every table will have at least some functional dependencies which are applicable on that table right what do I mean by saying applicable if all the attributes of the functional dependencies contain only A1 to a n then we can say that this particular set is actually applicable on that okay now anyway we know that using the closure properties of attributes we can get all the all the functional dependencies which are possible isn't it so let us say all the functional dependencies which are possible and which can be derived from F or f+ so what is f+ it is nothing but set of all functional dependencies which can be derived from F that can be applied on you know this one so we we have seen that right already we have seen how to derive all the functional dependencies which are valid from a given set of functional dependencies we already seen some examples on that right and now let us say we want to divide this decompose this table into two smaller tables R1 and R2 in such a way that R1 contains some attributes of this and R2 contains some attributes of this and Union of R1 and R2 contains all the attributes see first thing is it is definitely you should always see that whenever you decompose a table you should not lose any attributes that one I'm not going to talk about it because it is we always assume that every decomposition is attribute preserving which means we are not supposed to lose any attribute if you lose some of the attributes obviously the data is lost isn't it so first thing is attributes should always be there so if you have an attributes here A1 to a n all these attributes should be present either in R1 or in R2 right which means R1 Union R2 should give you r that is fine and what we are trying to do is we are trying to analyze the functional dependencies now out of all these f+ all the all the functional dependencies might not be applicable on one relation because some of the functional dependencies here might contain attributes which might not be present in R1 right so let us call fub1 as the set of functional dependencies which are subset of f f+ which are applicable in R1 are you following this which means some of the functional dependencies may not be applicable in R1 because it might contain some attributes which are not present here for example let us say R is like this A B C D four attributes okay and here in R1 we got let us say two attributes A and B right and here we have a functional dependency you know a determines C now even though a determines C is a functional dependency originally present you cannot apply a determine C here because C is not present here that is what I'm saying even though we have many any functional dependencies here all these functional dependencies will not will not be applicable on this table right only some of them will be applicable what will be applicable the functional dependencies which contain only these attributes got it that one I'm calling it as F1 right similarly FS2 is a subset of f+ which contains all the functional dependencies which are applicable in R2 on R2 right now dependency preserving means if I take fub1 Union FS2 and if I try to derive all the functional dependencies which are possible from this then I should get back the original set this is the meaning of it right so if I can see that this happens then such a kind of decomposition is called as dependency preserving which means we don't want to lose any any dependencies that is the meaning of it right and now we have seen two properties one property is lossless decomposition which means whenever you de compos and whenever you combine we are supposed to get the original table not anything extra and second thing is functional dependency preserving which means whatever functional dependencies we originally had we want all those functional dependencies later also right these two properties should definitely be followed whenever you try to go for any decomposition and uh you know this second property dependency preserving is not generally uh know so compulsory which means so even if we don't have this decomposition preserving also sometimes we decompose the tables what we really want is lossless decomposition preserving sorry functional dependency preserving is not a mandatary thing right but still it is better to some extent if you can protect the functional dependencies without losing all of them right let's see some examples and now we shall decide whether a de composition is lossless and dependency preserving right let's see this so why is it important because entire normalization is about decomposing the tables and whenever we do decomposition we want to see that these properties are followed so before talking about the normalization we shall see whether some kinds of decompositions are you know following these properties or not later we shall go for normalization see everything we are doing here just as a you know basics for normalization later these things will be you know important and applicable in normalization procedure fine now let's see this first normal form whenever you create a table depending on the type of attributes the table might not be in first normal form and one such attribute is called as multivalued attribute so if one of the attributes of the table is multivalued then there is a chance that the table is not going to be in the first normal form so according to the definition of first normal form we want the table to be as flat as possible flat means we don't want to have we want to have only Atomic attributes we don't want to have a list of attributes or attributes which are not Atomic so I'll take the two types of attributes which will violate this first normal form and I'll explain you how to deal with them so first thing is assume that there is a table let us say first one is employee number one attribute and the other attribute is employee name and the other attribute is phone number okay now assume that one employee is having employee number one and his name is a and and he is having more than one phone numbers now such an attribute is called as multivalued attribute now that is a violation of first normal form first normal form says that all the attribute should be Atomic but then if you see the phone number now assuming that it a person can have more than one phone number now the phone number will become multivalued attribute for example let us assume that the phone number is one is 1 2 3 4 and other is 5 6 7 8 which means this person is having two phone numbers now it is not not Atomic attribute is a list of attributes I mean it is not Atomic value a list of values right now how to deal with it is okay I'll take one more entry to B let's say something like this two numbers are there right so for this one two numbers are there and for this one two numbers are there now how to deal with this is there are two ways to get the table into first normal form one way is for every phone number maintain a separate entry in the same table that is the one way right so which means for every phone number we are going to maintain the separate entry so let us say this is employee number employee name and then phone number now 1 a 1 2 3 4 and again which means for this phone number 1 2 3 4 I have maintained one entry and again for the next phone number 45 67 right I'm maintaining one more entry got it which means for every phone number if I maintain a separate entry in the same table this is going to be one approach but as you can see this is obviously I mean it is not a good approach because if You observe it there are lot of redundancies one a is repeated one a is repeated right so it is not good now uh on the same grounds you can also do for this 2 B 2B since he's having two also is having two numbers 2 five 4718 right so now what the other approach is try to maintain two different tables one having the original values and the other one is specifically to maintain the multivalued attribute so in this case the multivalued attribute is phone number so try to create a new table for this attribute and in that attribute whatever is the primary key for the original table maintain that primary key in the second table as a for key referring to this primary key right now what I mean to say is the other approaches you try to split into two tables so one table will contain the original employee details so one is employee number and the other is employee name now employee number one employee name a employee number two employee name B fine this part is clear now in the other table we are going to maintain the attribute which has created the problem that is nothing but the multivalued attribute which is forone number in this case right so for that we are going to have one attribute phone number and the other attribute is going to be employee number only now this employee number should refer to this original primary key as a foreign key got it so whatever is the primary key here I'm going to maintain that Prim that primary key as a foreign key referring that original primary key right which means one if an employee is existing there then only one entry will be here right right otherwise if if there is no employee here why do you want to maintain the phone numbers of an employee who is not there in the company right so one one so because one is having two numbers right now what are the two numbers 1 2 3 4 and 4 5 6 7 and 2 2 what are the two numbers 1 2 5 6 and 4 718 okay now what should be the key for this I'll come by see one cannot be a key here because one is not unique so I'll combine these two employee number and phone number together will form the key right and one will be the foreign key and these two will be the primary key for this table got it now one will be referring to this and both of them will be unique for the entire table right now what is the advantage of this approach compar compared to this approach you can see that a is not repeated many times even though once are repeated right so you can assume a table which is very big which is very Broad in the sense if you have many attributes here right if I go with this approach I'll have to repeat all the attributes for every phone number Right But Here If You observe it I'll be repeating only the employee numbers for every phone number therefore obviously the second approach is better right so you can go with any approach what I mean to say is there are various ways of dealing with it so whenever you have these multivalued attributes the table is not in first normal form because according to the definition of first normal form all the attributes should contain Atomic Atomic values and since since it is not Atomic we are going to go with this two any of these two approaches now the other problem is there are some kind of attributes which will be called as composite attributes now if you talk about name name can contain first name and last name right let us say we have a table in which there is employee number and for the sake of Simplicity I'll assume that there are only two attributes one is employee name and now when I say employee number is one then if if I try to write the employee name in one attribute then the employee name itself might contain more than one Atomic value for example first name and last name right ra B is the first name Raa is the last name like that every employe might have first name middle name and last name now again if you see this they are not Atomic they are not single values right so again this is going to create a problem in first normal form we don't want to have anything which is not Atomic right then what we do is again we can deal you know with the same way how we dealt with that we have to try to you know find out a solution here so instead of dropping out this attribute all together we have to deal with it because this is important information we have to save it somewhere right so how we deal with it is one is maintain separate attribute for every uh you know com let us say the composite attribute is a combination of various Atomic attributes now ID identify all the atomic attributes that can be present in this and now separate that compound attribute into various Atomic attributes which means let us assume that employee number is there then split this employee name as first name middle name and last name now what happens employee number one will have first name a middle name B and last name c now if You observe this everything in this table is atomic therefore again this table is in uh you know first normal form it so and and there is there will be one more case the case will be uh you know nested attributes nested attribute means attributes can be both multivalued as well as uh you know composite so for example if you if you see if a person is having two addresses address itself is a composite attribute because it is going to have door number Street number and all this know country and all address itself is a composite attribute now if a person is going to have more than one address then it is going to be multivalued as well therefore there can be some cases where an attribute will qualify to be both as the multivalued as well as composite such attributes are called as nested attributes now we have to deal with it using these two approaches right first you split it out like this and then you can split it out like this all right so let's see the definition given in the textbooks we'll go for normalization in order to remove rendy so we generally that is why we go for normalization it is not just for first normalization in any normalization why we apply it is to eliminate the redundancy now in first normal form attribute values in a table should be Atomic Atomic means as simple as possible or as small as possible you should not be able to divide them further that is neither multivalued attributes nor composite attributes are allowed now every table is in first normal form since the formalized definition of the relation guarantee that the attribute value should be Atomic so in general when you are coming from the definition of the relation the definition of relation itself says that relation is a cross product of two sets and each set is a each set is going to contain Atomic values therefore whenever you say that the set is containing at Atomic values all the attributes are supposed to contain Atomic values so the formulized definition itself guarantee that every table is in first normal form now let's see this second normal form so using the second normal form we can eliminate some redundancies I'll take an example and explain you before going with the definition let us say we have a table a b c and the dependencies the functional dependen is given on this table or let's say like this one is AB determine C and the other one is b determin c okay so first of all try to find out the candidate key if you try to find out the candidate key on the right hand side you don't see A and B therefore every candidate key should definitely contain a b because they cannot be determined by any of the functional dependencies so the candidate key itself should contain it okay so let's find out whether AB is sufficient see AB are necessary to be present in the candidate Kee so let us see if it is sufficient to be the candidate key which means if I find out A+ I want to see if it is covering everything now I get ab and because of ab since AB in the left hand side I can add C therefore everything is covered by ABC so what can we say AB can be a candid key right now if You observe these functional dependencies the see now whenever you find out the candidate key these attributes A and B are called as key attributes so in this case the key attributes or prime attributes sometimes called as Prime rut sometimes called as key attributes both is one and the same now A and B are key attributes and non key attributes in this case is only C now if You observe this key attributes are completely I know determining C which means C is completely dependent on the uh candidate key in this case but if you see this dependency C is a non key attribute and it is depending only on the part of the key isn't it what what is the key candid key a and now only a non key attribute is depending only on the part of the key so such a dependency is called as partial dependency and because of this partial dependency the original table might have some redundancies I'll show you what kind of redundancies it might have let us assume this AB is the candidate key therefore A1 B1 C1 and then A2 B2 let's say C2 and again see this A and B combinely is going to be the candid key therefore the only requirement here is a and b should be unique for a toule which means a can repeat like this A1 as long as a and b doesn't repeat so what I mean to say is see this now I can have A1 B3 If You observe this A1 and A1 are repeating right which means the attrib the values of a is repeating but then if you take the value of ab as a whole it is unique see this A1 B1 A2 B2 A1 B3 what it so that can happen here so now let us say it is C3 and assume that we have now A3 B3 A4 B3 A5 B3 like this let's say A6 B3 now observe this so in all the uh in all the tles if you see this A and B are unique A and B taken together are unique right now if you see this dependency b determin c what does it say given a value of B you should be able to determine the value of C uniquely right given a value of B you should be able to determine the C uniquely what does it mean if you say that b value is B1 then you should be able to say that c value is C1 right and if you say that b value is B2 you should be able to see that c value is C2 from this table I'm saying right if it is B3 then you should be able to see that it is C3 when will this one happen for every repeated values of b c also should have the same repeated value isn't it so what I mean to say is here also C is going to have C3 C3 C3 then only you can say that for every you know value of b c is going to be unique which means if you say that it is B3 it is B C3 if if you have some other value let's say C4 then this doesn't hold anymore isn't it let us say for B3 you have C3 and for B3 you have C4 then this functional dependency doesn't hold since we are already saying that this functional dependency is holding for every value of B3 I mean for every place wherever there is B3 there has to be C3 now if You observe this this entire thing is a redundancy why we are repeating the same value many times and this dcy is mainly because of this partial dependency so what is partial dependency uh part of the key right we are depending on the part of the Key C is depending on the part of the key so whenever you see such a redundancy and if it is because of this partial dependency we can eliminate this dependency by making it a separate table that is called as decomposition now if you are going to decompose the table like this let us say ABC is the table now if you see a partial dependency just find out what is the closure of the left hand side now what is B+ if you find out B+ you are going to see that B+ is BC which means with B you take out C and make it a separate table and let a be in one table right H now if you decompose it this way okay so why to maintain B here as well as here whenever you see you know it decompose a table always try to have some common attribute there and the best practice is to maintain the entire candidate key in one table and the part of it in the other one and now if you find out the intersection that intersection should be a key in one of them that is called as lossless decomposition see what I mean to say is even though you are decomposing it now later you might need uh you know to merge them so why do we need to merge them is if you want to find out the relationship between a and C let us say you got a query where they're asking given the value of a what is the value of C now after decomposing the table there is no way you are going to see that then what we do is we again merge them right so when we merge them we we want to get the original table as it is if you don't have a common attribute based on which you are going to merge you might get spous stles that is called lossi right now as long as you are going to maintain a common attribute and if that common attribute is a primary key for one of the table your decomposition is lossless we already seen that right so what is that I'm saying now if you see the intersection the intersection is B now B has to be a key in one of the tables now if you look at the functional dependencies so B determines c will be applicable here right which means B is a key for this table therefore it is definitely lossless got it okay now let's see this so what will the table be table will contain A1 B1 A1 B1 A2 B2 I'm just writing all the values again A1 B3 and again A3 B3 and again A4 B3 A5 B3 and then A6 B3 okay and now coming to the BC part there is only only B1 C1 B2 C2 and B3 C3 now if you see this I'm not repeating the values of C3 so many times so that is how you know eliminating this partial dependency is going to help us right but if you see this redund this cannot be eliminated so this is present in the original table that can never be eliminated because AB is the key but you can eliminate this R Rundy to some to some extent now if you see this is a small table you might feel that you know there is no improvement bigger Improvement but if you can go to a scale where uh these entries are going to be thousand times then you'll see a lot of improvement there got it so let's see the definition here in 2nf we do not allow any partial dependencies so partial dependencies means dependencies of this kind a relation schema capital r is in 2 NF if every non Prime attribute if every non Prime attribute capital A in R is not partially dependent on any key of R so if you see this this non key attribute is partially dependent on the key isn't it so that is called as partial dependency if you don't have such dependencies then it is called as second normal form a functional dependency X Y is a partial dependency if some attribute a belongs to X can be removed from X and the dependency still holds so what they mean to say is if you have if you take this a a det c h is a dependency now it is called a partial dependency if we can remove some part of it and the dependency still holds then that is called as partial dependency right so this is one other way of identifying the partial dependency so best thing is you find out the candidate key and if you see the left side is a part of it then you can identify that it is a partial dependency also right side should be a nonk attribute now till now we have seen that once the table is in second normal form some of the redundancies have been eliminated and these redundancies were mainly because of the partial dependencies now it doesn't mean that all the rundes are eliminated right even though a table is in second normal form still there can be redundancies because of other types of dependencies I'll show you an example I'll just take an example and show you how a table in second normal form is not going to guarantee 100% redundancy elimination okay so let us assume that we have a table with a b and c three attributes okay now let's say the dependencies on this the fds which are applicable on this are like this a determines B and B determines C now if you look at these dependencies and try to find out the candidate key you'll see that a is a candidate key because A+ is going to be a b and c right and since the candidate key is containing only one attribute there is no way that you are going to have any partial dependency isn't it partial dependency arrives only when a part of the candidate key is determining nonky attributes right or other attributes now if you see this there is no part of the candidate key the Entre candidate key is single attribute therefore there is no way that there will be dependent is I mean redundancies because of partial dependencies or I can say that there is no partial dependencies in this right therefore the table itself is in definitely second normal form but still there can be rundes in this which can be eliminated right so if You observe this okay I'll just take an example see this now since a is the candidate key it should be unique in the entire table right let us say he is having values like this 1 2 3 4 5 6 okay and a is determining B so B can be like this B B B and maybe c c c okay and along with that we have one more dependency which is saying B determines C which means for a given value of B you'll be able to say the value of C uniquely right so what does it mean if B is having some value here same value then C will also have the same value there if two values of B are same then two values of c will also be the same right so what I mean by this is this will be like this so if if for one value of B capital B if it value is B and C value is X then for all the values of small b c value will be X only then only we can say that you know B is determining C given that you know that small Capital B's value is this one if they ask what is the value of C then you can say that it is X always that is the meaning of the deter determining right okay now B determine c means this is the meaning now similarly if you say Y is here then y will be definitely here now if You observe this this entire thing let us say B is know repeated 1,000 times capital B is repeated 1,000 times then C will also be repated 1,000 times since this is a small table you might not feel that you know the redundancy is too much but if you try to have a you know a table which is having millions of entries then for all the repeated values of b c will also be repeated so what could have been a better way of writing it the better way would have been keeping A and B and B and C separately so a better way to write it is instead of having it here remove it and create a small other table that will just contain B and C values for the value of small B value of C is X and for the value small C of B the value of C is y it is enough got it therefore if you ask for the for the value of capital b equal to small C what is the value of capital c then you can say it is directly y so in order to say that you need not maintain this entire row right now why did this case arise is If You observe it carefully this a is a key attribute key attribute is determining B which is non-key and similarly B is a non-key attribute which is determining other non-key attribute so that is that is called as transitive dependency transitive dependency means a is a key attribute it is trying to determine a non-key attribute C through a non-key attribute B right which means C is transitively dependent on a so such kind of dependencies are called as transitive dependencies so there what is the way of understanding whether there is a transitive dependency is there or not if the left hand side of a functional dependency is non-key attribute and if the right hand side is also a non-key attribute which means if a non-key attribute is trying to determine a non-key attribute then that is called as transure dependency now because of such transure dependencies we are going to get such redundancies and now these redundancies can be eliminated if we can split the table in such a way that you are going to take with this non key attribute all the attributes that are determined by this into a separate table got it now what did we do we are dividing the entire table a b c into two tables one table is going to contain a b and other table is going to contain BC right now the intersection between these two is B right and if You observe this B is a key for this so if you see B+ B+ is going to contain BC therefore B is a candidate key for this table so when the intersection is at least you know candidate key for one of them you can say that it is lossless so the the decomposition is definitely lossless decomposition right and what about the dependency preserving if you see this a determines B and B determinancy are applicable here right therefore dependencies are also reserved so this table is saying that a determines B so you have this dependency you can apply this dependency on this table and you can apply this dependency on this table therefore dependencies are also preserved so by splitting up the table based on the transure dependency we can see that the newly formed tables will all be in third normal form which will reduce the redundency right and now the third normal form in the third normal form it is lossless decomp composition when you're decomposing in third normal form it is lossless decomposition and also dependency preserving now whatever I have explained till now are all under the assumption that the table is is already in second normal form so what is the what is the meaning of it first we are seeing that the table is in first normal form according to the definition of a relation every table every plain table is going to be in first normal form right and then we are seeing that the table is in second normal form which means there will be no partial dependencies and after checking that we are seeing that the table is in third normal form which means whatever method I have applied here of finding the transure dependencies and then decomposing the table according to Transit dependencies will give us the tables in third normal form only if the original table is in already second normal form in case if the original table is not in second normal form then also you can directly apply third normal form but then we shall see other definition by which we can do that okay before going ahead okay anyway we are always going to follow this first we see that the table is in first normal form and then second normal form and then third normal form so till now we have seen one way of getting the tables into third normal form that is first get them into second normal form decompose the tables in such a way that we are going to get it into second normal form and after that we shall see uh that non key determines non key which means trans dependency right so that is how we are doing the examples still now now there is one more way of finding out whether a table is in third normal form or not directly without getting it into second normal form right so see now given a relation till now what we are trying to do is first decompose it in such a way that we are going to get it into second normal form and then decompose them and then you know get them into third normal form this is what we are trying to see but without doing this if you want to directly take the table and then see whether you know it is in third normal form or not or get into directly third normal form we are going to use this formal definition that is the only difference okay and also till now whenever we have been discussing about the examples we are lucky that for the given relation we are getting only one candidate key right but this formal definition will discuss even the cases where for a given table there are more than one candidate keys let us say there is candidate key 1 candidate key 2 and candidate key 3 then we can apply this formal definition so what is the main difference is when you have only one candidate key only the attributes which are present in the candidate key are called as key attributes or prime attributes and the uh attributes which are not present in this but which are present in the given table are called as non-key attributes right and based on that we have applied second normal form and third normal form what does second normal form say if a part of the key which means partial key if they determine non key attribute then we can say that it is partial dependency and therefore the table is not in thir second normal form what does the third normal form say if a non-key attribute is determining non-key attribute then it is a transitive dependency which means key attribute is determining this non key attribute transitively that is why it is a transitive dependency and the table is not in third normal form right now this formal definition says that take all the possible candidate keys or take all the candidate keys of the relation and then find out all the key attributes so what is a key attribute in this case is if an attribute is present either in this candidate key or this candidate key or this candidate key then you can call it as the key attribute now whatever are remaining you call them as the non key attribute right then again you can apply this right and also when they talk about uh Keys when they say that it is part of a key right in the in the till now all the examples we are talking we are thinking that the partial key is only when it is a part of this key right but now the partial key will be whether if it is a part of this one or this one or this one so our general definition is going to cover all the cases which means when a table is having one candidate key or more than one candidate key right okay let's see this general definition a relational schema capital r is in third normal form so if You observe this it is not a relation capital r it is a relational schema capital r what is relational schema it may be more than one table right which means if you have tables like this let us say this is table a table B table C assume that there are three attributes here two attributes here four attributes here right now all of them put together it is called as a relational schema right so once you take a relation one table and if you keep on depend you know dividing it at any phase whatever tables you get they all can be called as a relational schema at any point right or even initial one big table is also called as relational relational schema so relational schema means it is nothing but a collection of tables and tables means we take only the attributes which means the headings you can you can assume that way simple way a relational schema capital r is in third normal form only if every non-trivial FD X determines Y is either X determines Y is either X is a Super Key okay again see this a relational schema capital r is in third normal form only if in every nontrivial functional dependency X D minus y either X is a Super Key or Y is a prime attribute so what is that they are saying let us say this is the schema and there are many functional dependencies right of form X determines y now this schema is in third normal form if either for all the fds if you take each FD and examine it then either X has to be a Super Key or Y has to be a prime attribute if you can check it that is enough getting this now let us say this is the relation schema given and there are a set of fds now take each FD and you see whether each FD is passing this test or this test what is this test X means left hand side left hand side of the FD has to be a Super Key a Super Key which means it can either be a candidate key or a superet of it or it should pass the second test what is second test X is a prime attribute now what is the meaning of it is let's take it the other way now let us assume that there is a schema and X determines Y is making this to be not in third normal form when will the schema be not in third normal form when you are able to find out at least one FD which is going to fail these two conditions right now if these two conditions are failed what could be the possibilities for this particular FD let us say this is the FD which is failing these two conditions now what would have been what would be be the meaning of that see this now if this is failing it means that X is not a Super Key then what are the chances for x x might either be a part of the key which means it might be a partial key or X might be a non key attribute getting this see when is that this particular FD is going to fail this particular test whenever X is not a super key if X is not a Super Key then what could it be it could either be a partial key or it could either be a nonk attribute got it there is no other possibility now it is also failing the second test what is the second test X is a prime attribute if sorry Y is a prime attribute if Y is not a prime attribute then what could it be it is a non-prime attribute which means non key attribute right so now what are the two cases you get one case is that this is I either a primary part of a key right PK means part of a key or partial key and right hand side is a non key attribute if that is the case then these two are going to make it partial dependency right so whenever partial dependency is there then the table is not in second normal form and so it is not in third normal form got it so this particular definition is handling the case where uh partial dependencies are going to be present right and what is the the other one they're saying that if it is a non key and non key then what does it mean so non key determining non key means it is a trivial sorry transitive dependency now whenever there is a transitive dependency then this cannot be in the third normal form therefore we are handling both the cases so by this definition we are handling both the cases simultaneously what is it if this third normal form is going to fail it is either because there is a partial dependency in the functional dependencies or there is a trans dependency in the functional dependencies therefore it is the fastest way to test whether a uh table is in third normal form or not so how to test it take a table and take all take the collection of tables and take all the part functional dependencies on this and you find out all the candidate Keys possible and now take each functional dependency and check these two conditions what is it either left side should be a Super Key or right side should be a prime attribute right if all the functional dependencies are satisfying either this one or this one then you can say that the table is in third normal form if you see that I know at least one of the functional dependency is not satisfying that you can stop there and say that the table is not in third normal form and you can apply the decomposition taking that functional dependency right and then again you can see whether these two are satisfying or not either one of them is satisfying or not not right you can take some example and work on it see are you getting what I'm trying to say if you have a collection of tables and then collection of fds take all the fds and apply on the tables right and then take each FD and test these two conditions all the fds should satisfy this one or this one right or both of them now if all the fds are satisfying you can say that the tables are in third normal form if at least 1 FD is not satisfying both these conditions then it might be because that FD is either partial dependency or trans dependency which means the table is failing either second normal form or third normal form and so fails third normal form got it now you decompose the table by taking that functional dependency and then you can check this again till you get the you get these two either one of them is satisfying got it so without going towards second normal form by applying this definition you'll make sure that the final result will be in second normal form as well as third normal form form got it so which means if you are going by this way you are not following the sequence that we are dealing with the partial dependencies first and then transr dependencies if you go in this way by this definition and if you keep on decomposing you will decompose a table even if it is having a uh trans to dependency first till now what is that we have been doing we are following the order in which we decompose the table based on the partial dependencies first and then the trans dependency but if you go go like this now you will decompose a table even when you see the transit dependency for the first time which means you are not following that order now we have this rdbms right so rdbms is what we are practically using and on rdbms we have a language called as SQL so before going towards rdbms and talking about SQL the basics is if you think that this is the Practical implementation of the database there is a concept ual level at conceptual level we look at every table as a set in fact as a cross product of two sets see that is what the notion is we are going to look at every table as if it is a subset of the cross product of all its attributes for example you know if you look at name you can talk about name as set of all names possible in the universe right and let us say if you talk about years you can talk about you can think about all the numbers which are possible for a and let us say there is something called as marks you can think about set of all marks possible now if I create a table which is containing these three attributes one is name and the other is is and the other is marks you can think of it as if it is a cross product between these three sets once you get the cross product I'm not going to include every possibility I'm taking a subset of it therefore one other way of looking at a table is as if it is a subset of the cross product which is called as a relation that is called as if you are going to look at every table this way as if it is a set cross prodct is also a set right then it is called as relational model right relational model is the basics for rdbms and before going going towards SQL in order to build it we are going to use two basic languages or two basic operations set of operations which will be useful on relational model the way we use relational algebra and the relational calculus on this relational model will help us understand how to design and use SQL on rdbms so these two are theoretical Concepts which we look at a table as if it is a set and then these are the set operations which are possible on it and this is the practical model or if you want to look at it other way it is like an algorithm and is like implementation algorithms and implementation conceptual and reality Right theory and practical now before looking at SQL if you can understand this relational algebra and relational calculus we are going to understand SQL better and also coming to gate compared to relational calculus so these are two languages two theoretical languages which are possible on it there is difference between relational algebra and relational calculus but coming to gate relational algebra is more important coming to Rel you know more than this relational calculus anywh we are going to see these two but then first let's look at relational algebra and later we shall see relational calculus both are being used on relational model so relational algebra and relational calculus are two different things but SQL is derived as a combination of these two now coming to relational algebra here we don't we specify two things we specify both what we want and how we want it but coming to relational calculus we just specify what we want without specifying how we want it right okay later when we discuss about relational calculus I'll clearly tell you the differences here we shall Focus only on relational algebra okay first thing is what are all the operations or basic operations which are present in this relational algebra now one thing is called as projection so what is projection is now if you have a table let us say this is the table or here you should call it as a relation all right if you want to select only few columns from this table then we are going to use projection now if you try to project some few attributes you are going to get only few columns from the table and the next one is selection so what is selection is if you want to select only few tles so here I call it as a tle every row has a tle right so if you want to select only few tles then we are going to use selection and you have to be very careful here when we use selection and select in SQL both are actually different in SQL we are going to have something called as select and here we are going to have selection both are actually having the same name kind of it but then what they do is different okay later when we go to SQL I'll show you the difference but here selection is an operation which is used to select some of the tles from the table all right and the next one is cross product and cross product is sometimes what we need is if you have a table with a tle here and one more table with a tle here now whenever I want to compare some attribute of this tupple with some attribute in this tle then I might have to use these two tles from two different tables right so in that case what I do is I try to combine these two tables so that these two tles will also be merged and then I'll try to apply the comparison in a meaningful way okay so we shall see how to do it with examples and the next one is Union so in Union we want to combine two tables of similar types see here cross product you can apply on any type of tables but when combine coming to Union we want to apply Union on two tables of same type which means they should have the same number of attributes and those attributes should be same but when I apply cross product it need not be the case with examples it will be clear okay and the next one is minus or set difference so set difference is the same set difference that you have seen in sets now what is set difference is if you have a table let us say a and you have a table let us say B if I say a minus B so it means that you want you are interested in the Tes which are present in a but not in B got it so that is the meaning of minus and the next one is rename sometimes we want to save the result of an operation so that we can use it later for that reason we want to rename it and then store it or sometimes we want to rename the tables itself then we are going to use the rename operation okay and the next one is relational algebra expressions see these are all called as basic operations basic operations and you cannot apply some other operations to derive these operations these are definitely required Now using these basic operations I can build some other operations which are also very popularly used so they are so popularly used that we have given them some names as well right and symbols for example if you look at intersection intersection is not a basic operation by using the existing basic operations you can also derive intersection right now for these such operations which are popular but which can be derived using the basic operations for them we are just giving them names and when we Implement them we are going to implement them as if it is a implementation of this or usage of these operations for example if you see this intersection intersection can be expressed as if it is uh you know two set differences so what is the meaning of it see this now A minus Aus a if I want to find out a intersection B then I could have written it as a minus Aus B see this now first find out a minus B so what is a minus B if it is a and it is B first find out what is a minus B so a minus B is this part isn't it now if I write a minus a minus B what is the meaning of it from a you delete this part from a if you delete this part which is you know Stripes then whatever you are going to get is actually a intersection B therefore we are able to implement a intersection B without using intersection with using only the basic operation minus that is why this is not actually required but then it is so popularly used that we have given it a name and we are going to you implement it as if it is a sequence of basic operations right so it is a sequence of operations and in the same way we are going to have something called as join when you see cross product when I apply cross product every tle will be combined with every other tle right see if I apply cross product then what happens is if I have two tables let us say now every Tuple will be combined with every other tle without any meaning if you say this is an employee table and it is a dependent table now if dependent is saying who are all the dependents on the employees of the company then it will be meaningful if I combine every employee only with these dependents right not with all the other dependents sometimes the queries may be how many dependents that does each employee have in that case it is meaningless to combine every employee with every dependent we want to combine an employee with a dependent given that this dependent is actually a dependent on that particular employee right in order to combine such or doing such meaningful operations we need actually you know joins so join is an extension to cross product where we do it meaningfully right which means after applying cross product if you select only the meaning meaningful tles then that is going to lead us to join therefore join can also be implemented as if it is first thing is you apply cross product and then select few tles got it okay we shall see examples on it then you it will be clear and in next one is division even division is also implemented by taking difference cross product and production so with examples I'll tell you how to use these operations or where to use these operations and where to use these operations and also we'll see what do we get as the result when we apply these operations on two tables with examples it will be clear okay coming to get relational algebra is more important than relational calculus okay fine now let's look at the operation selection so we know that so what selection is we already know that it is going to select some of the tles of a table so for that reason I'll just take a table and explain you how it really works assume that this is an employee table and let us say it is having four attributes employee number employee name let us say department number and one more is salary okay so I'll just fill it and okay assume that this is the table we have and now I want to take from this table I want to select from this table some of the employees are all the employees of Department 3 then how I can write is Select from table employee so that is what is the table is right and I want to equate department number equal to 3 so department number equal to 3 now what does it mean is from the table employee you are going to select only the tles which have the attribute department number as three that is the meaning of it so what will be selected is these two will be selected right so if You observe it we are actually getting a part of the table but then the part is divided horizontally that is why sometimes selection operation is also called as horizontal partitioning right unlike projection we shall see projection later it is vertical partitioning and selection here is horizontal partitioning right so the terminology generally used is horizontal partitioning so so why horizontal partitioning is because we are we are actually cutting the table horizontally right and we are going to get all the attributes of the table so second point is whatever attributes we have in the original table in the result also we are going to get all the attributes so whatever is the original relation we are going to get the result also as if it is the same relation right okay and now if You observe it the way we have written it is here what we should specify here is either you can specify a relation directly right or you could have specified a relational algebra query relational algebra let's say this is a query right relational algebra query whose result is a relation got it relation algebra expression or a query whose relation is again uh you know whose result is again a relation so I'll take one one more example now let us say instead of giving you the table directly here I could have given you one more relational algebra expression now assume that I want to find out all the employees of department number one department number one but then I want to find only those people whose salary is greater than 10,000 so here it is 10,000 11,000 12,000 14,000 like this now I want to find out all the employees of department number one whose salaries is greater than 10,000 then I'm going to write like this select from the table employee all the employees whose salary is greater than 10,000 so now look at this what happens is it is called as something called as a nested expression which means there is a expression and then there is an expression expression within expression right so you have to evaluate the innermost expression first if I evaluate it what do I get I get all the employees whose salary is greater than 10,000 therefore If You observe this I'm going to get all these employees whose salary is greater than 10,000 I will not be getting this employee because his salary is only 10,000 right therefore output of this one is again a relation and which is containing all the attributes as the given relation right and it is containing 1 2 3 4 5 1 2 3 4 5 five tles therefore this one is going to give us five tles as the output it is a relation containing five tles right now on that relation again this condition is applied what is the condition select data know department number equal to one so which one will satisfy only this one will be satisfied all right therefore even in this case also you are going to get one tble or a kind of a table relation which is containing all the attributes of the original one okay fine now is the only way I could have asked this or is is there any other way now if You observe this on the table I'm applying two conditions first salary condition and then the department number condition I could have even applied it the other way which means I could have applied it as if it is first I could have selected select from employee table I could have selected this all the employees of department number one now on that one I could would have select I have chosen the employees whose salary is greater than 10 got it this way it would have been even efficient right so why only these two will be selected first and then we are going to compare among them right so anyway you are going to get the same answer now if You observe it the way I apply the conditions doesn't matter because the final answer is actually same therefore uh this one more important point or interesting point about selection is it is commutative it is commutative means I either you write like this a condition a and then condition B on a table e either you write like this or this is equalent to you write like this you apply condition B right both are same and it can be applied to any number of conditions see either you apply condition B first and then condition a or condition a first and then condition B the answer is going to be same now you can apply this to any number of conditions also you need not apply them separately you could have also combined these two conditions and applied in the same one which means you could have written it this way salary greater than 10 and I can use this Boolean connective and I can connect any number of conditions and I can check them in the single expression right department number equal to one in employee now all these three are actually equivalent either you write like this or write like this or write like this every everything is equalent got it okay now what about the cardinality of the output so let us say there is a relation R okay on which you are trying to select based on some condition okay now how many tles do you get as the output so what is the worst case number and what is the best case number now how many minimum do you get and how many maximum number of tles do you get in the output so minimum number of Tes you get in the output is going to be zero why if none of the Tes actually satisfy this condition then you are going to get a zero for example in this one if you ask a condition saying that find out all the employees whose salaries less than 10,000 then there are no employees therefore nothing will be selected therefore minimum number of tles you get is zero now what is the maximum number of tles you get in best case everyone in this one is going to get satisfied for example if you say what is the number of how many employees are having salary greater than 9,000 then everyone will get qualified right therefore the maximum number of tles you get will be equal to the maximum number of tles or the number of tles in the original relation got it therefore the relation between these three is 0 is less than or equal to this number is less than or equal to model so some questions are asked on in Gate based on this concept as well so you have to understand this one okay so what is the general syntax of this the General syntax of this one is going to be you are going to have selection and then you are going to have some conditions on either a relation or a relational algebra expression which is going to give us some relations now this condition need not be one condition it can be a combination of conditions right so which means it can be a is greater than 10 and B is less than C this kind of conditions can also be applied so if You observe this I'm comparing an attribute with a constant value or I'm combining an attribute with an attribute how can I combine an attribute with an attribute if these two attributes are present in the same tle with the same domain I can combine I can compare them which means let us say I have one more attribute and it is called as manager number right now if manager number and employ number are of same domain we can compare it or in general how we do compare you know two attributes is we apply the cross product first and then combine two tables and from one table we combine you know we compare an attribute with the attribute in the other table otherwise we cannot generally do that unless the domain is same right so in rare cases we are going to comb compare two attributes of the same table but in general what we do is we apply the cross product first which means we combine two tables and then we are going to compare right and generally you can see these kind of ques combining comparing an attribute with a constant is you can generally see it in general this is the syntax in which you are going to use it here the relation can be either a relation directly or a query or a expression which is going to result in a relation right and then the condition okay fine now let's see the operation projection so projection is generally represented by P and I already told you that projection is a kind of partitioning which is vertical partitioning see in case of selection we have seen that it is actually dividing the table horizontally in case of projection it is actually dividing the know table vertically so what I mean by vertically is you know whenever you try to project so I'll take an example and I'll show you let us assume that we have a table with three attributes let me say it is x y z okay and the three attributes are such a way that in such a way that XY is the candidate key for this table if XY is going to be the candidate key for this table the combination of XY has to be unique for the entire table which means 1 a 1 b 2 a and 2B and Z is not part of the candidate key or Z is not some other variable attribute let us assume that it is having some attributes like this right okay now if you try to project let's say I want to project some value XY of the table assume that the table name is some EMP employee table okay EMP right so what did I write I want to project some list of attributes X comma y from the table EMP so one thing you should always be careful about is whenever you're are trying to project whatever attributes you are trying to project should always be present in the relation that you going to apply it on for example since you are going to project the attributes X and Y always the attributes X and Y should be present in EMP otherwise this is not valid and in this case s x and y are present in this got it therefore what do you get as the output in the output it is as if you are partitioning the table you know such that X and Y only are taken so you are going to get X and Y in the result and the values of X and Y are going to be 1 a 1 b 2 a 2 B got it so this is the output now if You observe it the output is also a relation always the output of either select or project or any expression Iration algebra expression is always going to be be a relation right which means it is going to contain some tles and some attributes got it but then the main difference here is in projection you might get a degree of you know degree may be varying so what is degree is the number of attributes that are present in a table in this topic the degree of a relation is nothing but the number of attributes that are present in the table in the employee table the number of attributes present are three x y and Zed but in the result if you project the number of attributes present are only two therefore the number of the number of attributes are going to change which means the degree is going to change but in case of selection the degree is not going to change right and now what about the number of uh how many see since we are going to get to all the all the tles you might think that always the output should contain all the tles which means the cinal of the given table and the cordal of the result after applying projection you might think should be same but it is not always the case so why will it fail is just see this example if I try to project only Z from the employee table then what happens only if I try to project this attribute I'm going to get a relation right with attribute as Z and the value will be only C right why because even though you are going to get C C cc four values all these values are repeated and since relational algebra is is completely derived from relational databases right and the relational model right in the relational model every table is actually modeled after a set and in a set we are never going to allow duplicates so duplicate should always be removed automatically even if we don't mention it no relation is ever going to contain uh duplicates in relational database so since we are operating on relational database in relational algebra always remember that duplicate should be eliminated so in the given input also there there will be no duplicates as well as output should also not contain any duplicates since if I write all C it is going to be four duplicate tles all of them will be eliminated only one one will remain right now what about this one let us say you want to select only X from this table employee see in the given table there are no duplicates but in the result there may be duplicates which have to be eliminated right now if I have to select X only X then I'm going to get 1 one and then 2 two are there all right so I'm going to get a relation which is going to contain X as the attribute and one is repeated two times and two is repeated two times but then I have to eliminate the duplicates therefore I'll get only one and two got it and similarly if you try to project y from the employee now I'm going to get only A and B right so Here If You observe it if I have taken XY I got all the tles if I taken some other attributes I'm not getting all the tles I'm getting only less tles right so what do you understand from this whenever you are trying to write like this okay what is the syntax you going to have Pi followed by an attribute list list of attributes right and then followed by a relation or a relation algebra expression which is going to result in a relation right and now let us say here simply one relation is given now when are you going to get all the tles which are given in the input as the output of this Pi operation only when this attribute list whichever you are writing is a Super Key isn't it in this case XY is taken as a candid key right and when I'm talking about a selection sorry a projection which is containing XY then I'm going to get all the tles because if you if you look at XY any combination of XY if I take both of them together there will be no repetition that is why as long as you select or as long as you project all the attributes which contain the Super Key which means if the attribute list happens to be a Super Key on the relation you get here then you are going to get all the out know tles the number of tles in the output and input will be equal otherwise it may or may not be equal see if it is not a Super Key then I cannot say that you might get less it depends it depends on the table but if it is a Super Key if your attribute is a Super Key attribute list a Super Key you are definitely going to get the number of tles equal to number of tles in the input right what I mean to say is let us say the instance is like this 1 2 3 4 which means C1 C2 C3 C4 are there instead of having all C's now even though C is Zed is not a super key if I try to project Zed then I might get C1 C2 C3 C4 isn't it so like this C1 C2 C3 C4 so so you may not always say that the number of tles will be less if I don't take the Super Key but if you take a Super Key always the number of tles will be same so in worst case the minimum number of tles you might get is one in this case and the maximum number of tles you might get is all of them right so when sometimes with the non Super Key and always with super key got it okay and one more interesting point about Pi is it is not actually commutative so what I mean by commutative is if you say I want to project from employee table this table first XY and then from the resulting table I want to Project X this one what does it mean first you take only XY which means you will get this this table as a output and from this you are going to project only X which means you are going to get this one as the output the final output is going to be this right now this is no way equivalent to First you cannot Project X right and then you should not ask that from the resulting I want to project XY because in this table in this relation you are going to get a relation as in this output only with the attribute X when you have only attribute X how can you Pro Project X and Y right so it is definitely not possible always remember that whatever you want to project here this attribute list should be a subset of this attribute list got it so if you have this one as a valid let us say there is one attribute list and then there is one attribute list okay if you have two attributes list like is this relational algebra expression will be valid only when this first list is completely a subset of this if this one is subset of this then only it is valid now anyway if it is subset of this finally you are going to get only these attributes with duplicates eliminated isn't it therefore why don't you directly write like this so these two are equivalent so instead of finding out this attribute list first and then on that applying the you know projection you could have directly applied this projection on the employee table and you could have got the same answer anyway got it so these two are equivalent got it you can just simplify it and write it this way okay now one interesting point here is in SQL you are going to have an operation called as select all right so the select operation in SQL is equivalent to projection here so you might feel that you might feel that selection operation there is equivalent to select here because the names are same but it is wrong somehow you know there is this ambiguity right from beginning so always selection select in the SQL is equivalent to projection only difference is in projection duplicates are not allowed but in selection if you have duplicates they will be allowed so just to eliminate duplicates from the projection you can add a keyword select distinct now therefore select distinct if you add select distinct it is exactly equalent to projection okay now let's see the rename operation so sometimes we want to rename a table which means we want to give a table a different name the reason is there are various occasions so sometimes we want to you know save the result of a relational algebra expression as a table so that we can use it later all right for example let us say we have a table like this a table is having a b c and assume that employee is the name of the table now on this table let's say we have done some query like this so which means we have selected some few tles of it based on some condition let's say C and then and whatever uh output is there it is nothing but a smaller table based on what this condition is right now on that table if I try to project only know two attributes which means Pi a comma B so now we are going to get a new table which is going to have a b and some of the tles of this depending on which conditions we are going to satisfy now uh the whatever table we get here this table we want to use it later again then we want to save it right so in that case or we might want to use it in the same expression again in you know as a sub part of the query then in that case I'll use the rename operator and the rename is done by using the operation row so row is the symbol which is used to rename now if I write row capital X some C comma D now what the meaning of this one is this entire result whatever result you get which means this table is now renamed as X so the name of this one is X and the attributes a comma B are renamed as C comma d right or if you want to leave the attributes as it is you could have directly written it as X so there are many you know cases where we want to rename a table and give it some other name so one other operation is let us say you want to apply some natural join operation we didn't discuss it yet later we are going to discuss it even in you know SQL also we have something called as join now when you use these operations sometimes you want to join a table with itself which means a table will be joined with the same table in that case when you have same names to two tables it will be confusing for us to you know specify which one you are talking about in that case you can rename one table to other name and then you can use it so if you have a table like this let's say employee table a BC now if you want to rename this to some other name you can use this syntax rename employee as let us say x Now by writing this what happens is the name of this table will be changed to X right now along with the here only name is changed attribute names are same now along with the tables name if you also want to change the attributes name you can again do it this way so rename employee table so this is row this is row rename employee table as X in such a way that its attributes are also named as CDE e right now what happens a BC will be renamed as CDE right or if you want to rename only the attributes but not the table then you can write it this way rename employee but then only the attributes of it to CDE Now by writing like this only the attributes will be renamed right and here we are trying to rename all the attributes sometimes you want to rename only few of them for example I want to rename only A and B but not C then what I could do is rename employee table only the attributes A and B have to be renamed as X and Y and C has to be left as it is now in this case C is you know C is left as it is and the employee table is you know table name is going to be employee only only attribute a is renamed as X and attribute B is renamed as y or sometimes you can even do this rename employee name as the table is renamed as X but only let's say A and B are renamed to E and F okay let's not use c c has already been used right here you can you could have used F okay so A and B these two can be renamed as S and T and C can be left as it is now by looking at this syntax you can understand that the employee table the table itself is changed to X the name of the table is changed and the first attribute a is changed to S and the second attribute B is changed to T but the third attribute C is left as it is got it so this these are the various ways we can use the rename operation so every operation is going to be useful according to the circumstance so let's see what are the situations in which we might have to rename the uh you know tables when it comes to when we go there okay so later when we see some queries we'll use this again so this is how rename operation works now let's look at three set operations possible on the relational algebra relations Union intersection and set difference now till now whatever operations we have seen they are all un which means either for selection or projection or rename always we are going to take one relation and we are working on it but whatever these operations are they're binary so binary means we generally take two relations and then we operate on that now whenever we take two relations and operate on them by using any of these three operations now the they should be compatible for these operations right so if I try to apply r Union s on two relations R and S then R and S should be Union compatible or type compatible so what I mean by Union compatible or type compatible is let us say there is a relation r with R1 R2 and R3 as attributes and this relation is let's say is having S1 S2 and S3 as attributes now what I mean by type compatible or Union compatible is both of them should be having same number of attributes that is called as degree right so both of them should be having same degree that is first one and after that both of them should be having the same domain for the corresponding attributes which means if R1 is having set of all numbers as the you know the domain for R1 then S1 should also have set of numbers as the domain right see you cannot Union these two unless you have the same types here right so if you want to see an example let us say there is a table uh saying that employee table of company C1 now if they have employee name here and employee ID generally employee name will be set of all names that is domain for them and employee ID is nothing but set of all numbers right and if you have some other Company employee C you know if it is having a table employee of Company employee table of company C2 then it will have let us say employee name let's say en is the employee name and E is the employee ID then even though the names are different they have the same number of attributes as well as the type is same here also employee name and here also employee name which mean it is going to have set of all names and is also going to have set of all names and set of all numbers and set of all numbers got it so now whenever you take Union of two relations the meaning of it is the result is going to contain set of all tles which is pres which are present either in r or in s or in both of them got it either in r or in s or in both of them so only thing you should be careful about is whenever you apply Union the result should not contain duplicate values is there a chance that we might get duplicate values there is a chance right why let us say there is an employee here with name a and his ID is one there might be a chance that there can be an employee a with name one now when I apply Union for this if you don't eliminate the duplicates then there will be 2 * A1 A1 will be written so in this case A1 A1 is required to be written two times but then our Union operation when applied in relational algebra is will remove all the duplicates got it so in this case yes they are required but still our Union operation will remove it so only thing that you should be careful about is Union coming to relational algebra will never allow duplicates for that matter any relation in a uh you know relation algebra should not contain duplicates because relation is nothing but a set in a set we don't allow duplicate values got it okay and the next one is intersection intersection is also same like you know Union both the tables have to be Union compatible see even though we are talking about intersection again we say Union compatible only because if they are union compatible they will be they will be also be intersection compatible so what I mean to say is number of attributes should be same in both the tables and the domain of the corresponding attribute should also be same so which means even when you apply intersection you should you should see this Rule now what is the meaning of r intersection s is whenever you apply this operation the result is going to contain all the tles which are present both in r and s in this case you need not worry about duplicates why because since R is a relation and S is a relation the given relations themselves will not contain duplicate values therefore when you look at the intersection they will also not contain any duplicate values got it so what is intersection it has to be present here and it has to be present here if it is present here it will be present only one time because there are no duplicates here if it is present here it will only present one time therefore there will be no duplicates in the result right and similarly Rus s means whatever tles or present in R and not present in s they will be present in the result and here also both the table should be again Union compatible right which means you just find out what are all the relations which are present in R and they should not be present in s got it and you find out all such relations and you write them that is going to be Rus s so if you want to see an example let us say R is a table which is containing two attributes a b and s is a table let's assume that which is containing two attributes CD right now 1 a or let's say some numbers are there 1 2 some 3 4 5 6 is there and here you have 1 2 7 8 9 10 something like this right now if I try to write r- s then what should be in the relation whatever is present in r that should not be present here if it is present here we are not going to write there got it so if you look at 1 2 this particular tle this tle is already present here therefore it will not be present in the solution now what about 34 it is not present here therefore it will be present in the result right what about 56 it is not present here therefore it is supposed to be present in the result therefore r - s is going to be 3 4 56 3 4 5 6 right now one thing you should be careful about here is whenever you apply any of these operations the result is also going to be a relation isn't it and that relation is going to get a default name and the default name for the attributes as well now that name will be decided based on which attribute you have actually provided in the beginning or which operand you have given for the operation in the beginning which means if I write R Union s then the result will be named as R and the attributes of the result will be named after what are the attributes for R got it and same thing applies for intersection the result is named as R and attributes will also take the names from R and here also the result will be named as R and the attributes will be taken from R got it and uh one more thing is what are the various properties they hold so if you see Union Union R Union s will always be equal to S un R even though the result is going to take a different name the number of tles and the values of the tles will be same right what does it mean Union is commutative right and similarly R intersection s is equal to S intersection R so what does it mean intersection is commutative but if you look at subtraction this no sorry set difference r- s need not be equal to s- R always which means it is not commutative R minus s which means the set difference operator is not not commutative right coming to associativity R Union s Union T can also be done this way or it can also be done R Union s first and then Union T which means Union is associative and similarly R intersection s intersection T can also be done as R intersection yes first and then intersection T next which means intersection is also associative but coming to this set difference it is also associative so what do I mean you can either do like this s minus t and then minus this one or you could have done it this way Rus s minus t which means set difference is commutative got it okay and one more interesting thing is even though you are going to have three different operations set operations this intersection is redundant which means by using Union and subtraction you should be able to or you'll be able to implement intersection right how If You observe this if I write let us say this is relation R this is relation s relation R and relation s right now what is this part this part is r- s isn't it only this part this part is Rus s now what is this part this part is s - R now if I take Union R Union s and from that R Union s If I subtract this and then subtract this then the remaining part is going to be this isn't it therefore R intersection s can also be written in terms of Union and set difference like this R Union s minus from this I can subtract this so which is r - s which means I have subtracted this part from R un s means from this entire Parts three parts 1 2 3 I subtracted the first part and then from this I'm subtracting this one all right so if I subtract this one as well which is nothing but s- R all right then the result is going to be R intersection s only all it or other of writing it is if you feel that you know a lot of operations are involved here instead of this you know intersection is done only with one operator then you could do it other way so what is it R intersection s you have r s now from R If I subtract this part if I take R which means only this part right and from R If I subtract this part then the remaining is going to be R intersection s so which means R intersection s can also be done as from r if I remove from entire R now let's see the cartisan product operation so it is represented by cross and it is generally called as cartisian product right cartisian product in short sometimes it is also called as cross product right so it is exactly same as the set theory so where if you have two sets and if I apply cartisan product I'm going to get ordered pairs right so which is going to contain if there are M elements in one side and N elements in the other side the C product is going to contain M into the same way we are going to apply cartisan product on the relations as well see already we know that a relation is nothing but set of all tles now there are two sets of tles if I apply cartisan product it is nothing but taking one tle from one set and pairing it up with all the tles in the other one right so I'll just show you with example what I mean by C product and later I'll show you why it is important okay so now if You observe that let us say we have two tables so one table let us call it as R which is containing three attributes a b c okay and now assume that something like this and the other table is containing yes and which is containing two attributes let's say the two attributes are d and e and assume that the attributes which are present here are 1 C some 2 D something like this okay now when I apply cartisan product what I mean to say is we are going to get a resulting R process the result the result of this cartian product is going to be a table which is going to contain this entire tle clubbed with this enterre tle concatenated right which means the resulting table is going to contain five attributes right if there are here three attributes and if there are two attributes the resulting table is going to take this one attribute and merge with all the attri know take this one tle and merge with all the tles here therefore the resulting Tuple size is going to increase right which means in the result it is going to be one is a b c along with the D all the five attributes are going to be present right and now for every tle here it is going to be merged with these two tles so I get 1 a from this and it is going to merge with 1 C similarly 1 a 2 d right similarly 2 CD 1 c 2 CD 2 D and similarly 3 EF 1 c 3 EF 2D all right so if there are three tles here and two tles here if you can observe that we got six tles here right so what does it mean for every tle here we are going to combine with these two tles for with every tle here right so now if you assume that the number of tles in one relation is M and the number of tles in other relation is n now if I apply cartian product on these two relations the number of Tes is going to be M into n right similarly if the degree of one tle is let us say here it is three and if the degree of the other relation is two then the degree of the result is five right therefore if the degree of let's say one relation here if the degree of one relation capital r is let's say K and the degree of other relation cap s is L then the degree of R cross s is equal to k + L got it so this is the relation between them the size of it is going to be M plus n always so there is nothing called minimum and maximum here maximum and minimum is always going to be MN and the number of attributes in the result is going to be this one now you might get a doubt why are we trying to do it there are various circumstances where we need to do it see any query that you WR run on database generally it works this way at any time we are going to take only one tle in one table and we are going to examine it and we can say and we check whether this entire tle has to be present in the know output or a part of it has to be present there is no query or no query in database will work by taking two different tles from two different tables and they will not examine them at the same time got it at any time we can only look at one tle of one table and make some decisions there are no queries or any database will not take two tles from two different tables and work on them parallely the only way we can force it we can make it happen is by combining these two tables if you want this one and this one to be compared for some reason if you want this tble and this tble to be compared only way you can do it is combine these two tables in such a way that in some combination you get these two together if you see this here I got these two right and now when you look at this single tle of the you know result it is as good as looking at two different tles of two different tables at the same time so only way you can make it happen is by taking the C cross product or ctis product right if you want to see an example let us say this R is employee table and this s is dependent table right and assume that this a is employee ID and this D is also employee ID on which this particular dependent is depending on which means employee one is having dependent here one whose name is C employee 2 is having dependent whose name is D now it will be meaningful for me for you know to find out how many dependents does one have so if I have to find out then I have to look at one and then join with it all its dependents and then see what their properties are right if I want to find out how many uh let us say dependents that an employee with name a have then what I should do is I should merge this table with this table then all the dependents of employee one will be merged with all the dependents of his and then I can check if his name is a who what who are all the dependents got it so which means if you want to see see this operation right so here there is one and here there is one right now what does it mean this particular employee is having this particular dep dependent got it and now here there is two and here there is two so what does it mean this particular employee empe is having this particular dependent right now this way you can get the name of the employee and the name of his dependent by combining the appropriate attributes now how is that possible by taking the cartisan product and then from the caran product I want to select only the uh you know tles who have a and d matching that will give me whether this particular dependent is depending on this particular employee or not which means I could have written it this way so first I'll combine R and S so in this case it is nothing but employee and dependent now after combining them I can select out of all the tles only the tles who are having you know these two matching a equal to D which means this particular employee and this particular employee ID should match then only we can say that they are the dependents right so in general this is mean it is Meaningful to write queries like this we don't use cation product unnecessarily which means without any meaning we don't use cartisan product we generally use a cartisan product followed by a selection and comparison on the operations now this is going to give me some meaningful table for example if I do this if I do this way then what will be the output output will contain only two attributes two tles right all the five attributes are going to be there a b c d e but then only two tles so y 1 a b it is going to have one matching here that is why that will be selected and similarly 2 CD it is going to have two matching here that is why you're going to get 2D right now if You observe this these two are matching that is what the condition you have written right now if I write the query like this or the result of this one is going to be this way and the result of this one is this in general we we use cartisan product followed by a selection to get some meaningful information right and this combination is so popular that we have also named it as a separate you know a one more operation which is called as join so we shall see about this join later so for now in this video we focus only on cartian product so only question or important point that you have to remember in cartian product is whenever I cross product you know apply cartian product between two relations then the number of attributes is going to be sum of the number of attributes of the individual relations and also the number of tles in the output is going to be multiplication of the tles you know each one is having individually got it okay now let's see join so join is an extension for cartisan product and the symbol also looks like it is an extension for caran product it actually cartian product symbol which is closed on both the sides right okay now why do we need join is as I discussed in the earlier video previous video that whenever you are going to use cartian product the result is not going to be meaningful unless we again select some of the tles therefore carti product followed by selection is very popular right and so these two are actually combined and a new operation is proposed which performs the combined operation which is called as join right so now in the earlier example if you take it let's say there is a table R which is having a b c as the attributes and then there is a table s which is having let's say d as the attributes okay now after combining these two which means after taking the cartisan product of these two if I try to select some of the uh top based on some conditions let's say here the condition I applied was a equal to D which means if this value is equal to this value if I want to take it out it is nothing but a combination of cartisan product followed by select now this can be written with just join operation this way I can take R and I can join with s and here I can write the condition so what is the condition a equal to d right so now this condition is called as join condition right so what the Syntax for this one is you can take a table a relation and then you can join it with other relation and here you can put the join condition join condition right now this join condition can be a collection of any number of conditions which are connected using logical connectives for example here I can have condition [Music] one anded with condition two all right so what I mean by this is I can do something like this in this join condition I could have written it as a equal to b or equal to D and B equal to e right so if I write something like this a = to D and Bal to e here I'm comparing only attributes right so whenever you're comparing only attributes such kind of joint that kind of join is also called as Theta join so Theta join means if you're are comparing only the attributes but not an attribute with a constant then that is called as Theta join right if you make a comparison let's say with an attribute in this case if I put in the join a greater than 100 which means if I make a comparison with a constant then it is not Theta join got it so what is Chet join if I'm making comparisons between two attributes got it okay now one interesting question is if I apply join what will be the size of the result if one table is having three attributes and the other table is having two attributes then the size of the result the number of attributes present in the result when I apply the join is going to be 3 + 2 because it is it is nothing but a subset of cartisan product isn't it the join output is going to be a sub set of the cartisian product therefore whenever you apply join the output is going to contain the same size as if it is ction product size so if it is you know if M this R is containing let's say k attributes and if this l s is containing L attributes then the join of these two right which means if I apply the join then the join of these two is going to contain K plus L attributes right then what about the number of tles which are present in the result in case of cartian product you know if this one contains M tles and if this one contains n tles then the result is going to contain M into n tles right but then in case of join since after you know applying the cartisan product we are also applying a selection condition over it there is a chance that no tle might be selected in that case what happens is we might get zero tles in the output in the best case all the tles may be selected in that case I might get M into n tles therefore the minimum number of tubles which will be present after join is zero and the maximum number of tubles which will be present after join is M into n got it now let's look at an extension for join which is called as natural join so natural join is useful whenever you are going to combine two tables which have common attributes with the same name right so generally that is that is where how you combine right if you have a table let us assume that there is an employee table now in the employee table there will be something called as employee ID right let's say this is the employee table employee ID will be there and similarly if there is a dependent table then dependent table is also going to contain let's say this is dependent table dependent table is also going to contain employee ID now this employee ID represents who is the employee on which this particular dependent is depending on therefore this is going to refer to this form right so whenever we join these two tables we generally want to join them in such a way that you know this value of this attribute is equal to this value right or one more example if you want to see let us say there is a manager table right and Department table in a Department there can be a manager and the manager ID is also going to be one of the employee IDs right therefore this one will be referring to this and now whenever we join them we want to join them in such a way that these two gets matched so that is natural way of joining them right we naturally want that kind of queries to be answered so in that case we are going to use something called as natural join so natural join is represented by this star okay so what will natural joint do is if I apply R natural joint s and if you have inside R the attributes a b c and inside s the attributes let's say A and D it is as good as writing natural joint which means are natural sorry normal join are joined with s in such a way that a equal to a so here a means the a which is present in R and here a means the a which is present in s so which means these two are automatically you know compared that is the meaning of it right which is also equal to cartisan product isn't it it is as good as taking the cartisan product of R and S and then selecting from the result all the attributes or all the tles which have a equal to a all right so these three are actually equivalent and this is the easiest or smallest way know simplest way of writing it now whenever you have something some attributes in common if you want to join on them they should have the same name that is the only condition you should remember right and whenever they have the same name and when you apply this natural join these attributes this attribute a is called as the join attribute on which the join is done got it and in case if you have a table like like here the attributes are having different names if you want to combine them naturally applying the natural join and since there is they don't have the common name what you could do is you can rename the table and you can get it right so what I mean to say is let us say there is no there is no a here assume that there is you know e here okay now you want to apply natural joint then it is natural to you know rename this one and then apply the natural joint so how you can do it is take R and then apply natural joint with s only but then you rame the attributes of s so attributes of s have been e and D so rename it as a comma D of s so what does it mean rename the attributes of s as a comma D initially they were e comma D now what happens there will be this will be replaced as a and now you have a here and a here therefore you can apply natural joint which is going to give you the same result as if they had the same name right and it need not be always joined on one attribute you can even do it on two attributes okay before going ahead we shall see one example here let us assume that this name is a renamed it and now you have the attributes like this 1 a b 2 C D and here you have 1 D some 3 e now if I apply natural join what happens is in the result we are not going to get all the attributes so whenever there is a common attribute whose name is same in both of them instead of writing it two times anyway if you write it two times both of them are going to have the same value isn't it see now they will will maintain only one A B C D now if You observe it this is the main difference between the cartisan product and the normal joint and the natural joint in the natural joint since two attributes are going to have more you know same name at least one attribute is going to have the same name in both of them now that common attribute need not be written two times why anyway even if you write it two times both the instances we are going to have the same value that is why we need not write it two times only one time and see this one when compared with this here A and here a are having the same value that is why a will be written as one and the remaining is a b d got it now if you compare this two here a and here a are having different values so they will not be written now if you compare these two this one and this one here a and here a is having the different values so that it will not be you'll not get anything in the result now if you compare these two they are having different values so you'll not get anything in the you know result so if You observe it clearly this is the only tle that we are going to get so what is the observation you should make here is whenever we have two attributes having different names unlike join in natural join only one attribute will be represented there now assume that instead of this you had a b both of them and here we have ab and here we have AB right so there can be more than one attribute which have the same name in that case we are going to equate them both right let us say here the value of this one is 1 a right then what happens is here AB should match with AB then only that tle will be written in the result right so we means the result is going to contain if if this table would have been this way the result is going to contain only a which is representing these two ABS as well and C so the result is going to be simply AB C right and now for a it is going to be 1 a 1 a since it is matched with one I'm writing it there and the C is going to be B right now now if you compare this one with this one these two a are having different values which means a b are having different values and if you look at these two ab are having different values if you look at this two a are having different values so this is the only tle you are going to get in the output got it so again in the natural join same as join since we are applying the selection condition after applying the cartisan product the number of tles which you might get in the output in worst case may be zero why if none of them match then we are going to get zero tles and what is the maximum number of tles if everything match if the output of cartisan product if all the tles match our condition then we are going to get M into n where m is the number of tles in the first table and N is the number of Tes in the second table so this is the minimum and this is the maximum got it and what about the attributes the attributes in the result are not going to be k + L like in the earlier case that depends on how many attributes are having common got it and also natural join need not be applied only on two tables either join or cartisian product or natural join you can extend it to any number of attri any number of tables right what I mean to say is you can apply natural joint on r s St so on you can apply on any number of tables right sometimes what happens is the names may not be is same let's say A B C D the names may not be same and you may not even use the renaming operation also now if you try to apply natural join then in that case the output is going to be same as cartisan product why natural join is nothing but cartisian product after that comparing the attributes but then after cartisian product you have not given it let's say here ABC is there and let's say d right so no common attributes are there now if you try to apply the cartisan product you are sorry if you try to apply the natural joint first cartisan product will be done and which is going to be normal cartisan product after that when it try to compare the common attributes it will not find any common attributes there therefore it will leave give you the output as if it is the output of cartisan product which means the result of this expression if applied on this table natural joint is going to contain all the attributes es which are a b c d e all the attributes all of them are going to be present there all right and also the output is going to contain the same as if it is a natural uh this you know C product which means 2 into 2 all the four tles are going to be present there all right now let's look at this division operation so division operation is also a binary operation meaning that we can apply this over two tables or two relations and now this is not a basic operation the reason is it can be derived with the basic operations this way so before discussing about how to implement this division operation using the basic operations let's see an example to understand how it really works let us say there is a table r with attributes A and B okay and assume that there is one more table s with attributes a now when I write r divided by S or R division s then it means that the result is going to contain whatever attributes are there in here minus whatever attributes you have here see there is a chance that you might get confused with the you know set difference operation but here when I say minus I'm talking about subtracting the attributes not the tles which means if you see this the the attributes which are present in r or a b and the attributes which are present in s or a therefore If I subtract it the attributes which should be left is B that is what I mean right therefore the result is going to contain only attribute B in this case because that is the only remaining attribute right now what will be the tles present now for that reason we shall take some example here now let us say there is A1 A2 and there is B1 B1 and A1 A2 and there is B2 and B2 and let us say there is A1 there is B3 okay something like this and now assume that the table here s is containing A1 A2 now we are going to get in this all the values of capital B in such a way that whatever values you get here that combination with these two elements is present in the table for all the elements which are present in this capital A if you get a element here it means that the combination with this element with this these two are present so what I mean to say is see this now if you say B1 if you look at this attribute B1 right this attribute capital B and the values B1 now B1 is present in combination with both A1 and A2 isn't it that is why B1 will be there in the output similarly if you see B2 B2 is present in combination with both these elements A1 and A2 that is why it will be present here now if you see B3 B3 is present only with A1 and it is not present with A2 so it will not be present there got it so what is the meaning of this for every element or for every tle you get in the output the combination of that tupple will exist with all the value with all the tles in here in r that is the meaning of it got it so this is the meaning of division right now how to implement this division using you know the basic operations is first thing is you find out the projection of r - s/ R so which means in this case what happens is see now we are finding out D projection of Rus s so whatever tles are present here minus whatever tles are present here which is nothing but Project B B from R so what are what are we trying to do is we are trying to get what are all the values of B present in this so it is going to give us a temporary table which is called as T1 temporary table is called as T1 and in this temporary table we have only B with values B1 B2 and B3 right and next thing what we are trying to do is we are we are multiplying we are applying the carian product between s and T1 now what is s this one and T1 we are multiplying the cartian product therefore cartian product of s cross T1 is going to be now A B it is going to be A1 B1 A1 B2 A1 B1 A1 B2 A1 B3 and similarly A2 B1 A2 B2 and A2 B3 so this is the combination right now from this we are subtracting all so what is that we are trying to do is we are first selecting all the distinct you know Elements which are present in B and then we are trying to combine with this right so if this is this you know if these combinations are all present in R then the entire set B will be the output otherwise we are going to eliminate the combinations even if one of them is missing which means if there is at least one value of B which is not having a combination with at least one of these two then we have to eliminate it for that reason I'm finding out the all the combinations which we want see this is what we want to see in this isn't it we want to see that for all combination of these values they are having a combination with all these values right so that is what we want want now from this if I subtract R then what do I get I get out exactly the combinations which we do not have right so which means from this s cross T1 If I subtract R right now what do we get whatever are present in this and whatever are not present here right so now you check this A1 B1 If I subtract from this this one will be gone all right now A2 B1 yes gone and A1 B2 gone and A2 B2 gone and A1 B3 gone and what is remaining A2 B3 so what does it mean it means that there is a combination or there is a value for attribute B which is not you know present in a combination with A2 that is why this one should not be there in the answer are you getting this by doing this know subtraction what did we find out we found out all the values of attribute B for which it is not having at least one combination with all these values of this now if you see this in particular you got that B3 is a value of capital B which is not having a combination toule with A2 that is why this cannot be B3 cannot be in the final answer right therefore from T1 from this one you just subtract this B3 how can they subtract B3 these two are not actually compatible cannot apply set difference operation that is why you just Project B and then subtract it that is why you just project yeah you just Project B by this I'm just projecting B into T2 therefore T2 is going to contain just B3 and then I subtract from this if I subtract from this this one will be gone therefore the answer will be B1 B2 are you getting this so what did we do we have taken all the distinct values of B and we paid up with all the values of a intentionally that is what we did right and from this if I subtract R then I'll get out whatever then then the result will be whatever are the values of capital B for which even one combination is missing with this now I have to find out such values of B and from all the values of b i to subtract it that is why I'm just subtracting it at the end that is how I got it right so therefore the division can be implemented using these three I know these three steps using the basic ones so division is not a basic operation it is a derived operation even without implementing division directly you could have used these basic operations and you could have implemented it got it okay now we say that a set of you know operations are complete if we can Implement any other operation using this set for example a set a complete set of relation algebra operations are this so selection projection Union set difference and cartisan product if we have these operations we can Implement any other operations that is why these are called as you know complete set so we can say that a following we can say that the following set of relation algebra operations is a complete set that is any of the other relational algebra operations can be expressed as a sequence of operations from this set so what I mean to say by this is if you look at intersection intersection can be implemented by using difference only difference or by us using Union and differences right set difference for example if you want to implement join now you can Implement join by using selection and cartian product right similarly if you want to implement division right you can Implement division by using cartian product and then set difference right so like this you can say okay maybe you might need even selection as well right so like this if if you say other op operations which are not present in this all those operations can be implemented by using this basic set that is why this is also called as you know basic set of operations which is complete okay complete set okay till now we have seen relational algebra now let's see relational calculus okay so formal languages If You observe them they are actually divide into two categories so till now we have seen about relational algebra and now we have going to see something called as relational calculus and again relational calculus is also divided into two types one is tle relational calculus and other is domain relational calculus so what are the main differences is see both are formal languages only which means both are actually theoretical languages which are not practically uh in the existing so if you try to implement them as a practical database and if you try to write the queries you have to use some language like rdbms and SQL not the relational algebra and you know these languages so now why are these languages useful is they will be helpful when you are trying to implement some queries practically or when you when you're are trying to you know come up with a practical language to use then the these will be helpful there but then what is the main difference between these two relation algebra and relation calculus is in relational algebra it is procedural procedural means you are going to specify or you going to exactly mention what data you want from the uh relations from the tables and also you are going to mention how you should get it so how means the procedure you are going to also write you know join these two tables and from those two tables you get it all those things you are going to mention clearly so you are not just saying what you want you are also saying how you want it right and also you'll mention the order in which you should apply the uh you know if the if if a expression is collection of many Expressions if it is a complex expression you'll also specify what is the order in which you have to perform the operations if you have many operations in a query then you are going to specify everything right so this is this is called as procedural language we are going to specify what we want and how we want entire procedure will be given now coming to relational calculus it is not actually uh procedural language here we are going to just mention what we we want and we'll not get into the details of how we get it right we just leave it abstractly so that is why it is simply a declarative language and you know it is we are not going to use uh any kind of procedure I mean we are not going to say you do this then you get this output and on the output you do this we are not going to say all this we just specify yes we want some information from the uh you know database or the relations just give me that's it and we don't talk anything further and now if You observe it either relational algebra or tle relational calculus or domain relational calculus all are equivalent in par so what is equivalent means if you can write some query uh in relational algebra you will be able to write the query in tle relation calculus as well as domain relation calculus also that is all of them are equivalent in part but since relational algebra has been developed compared you know earlier compared to this relational calculus we use relational completeness concept by keeping this relational algebra in mind which means if a language is able to express everything that relational algebra is able to express then that language is called as relationally complete so relationally complete is a new term now relationally complete means if if you come up with a new new language and if you're trying to sell it let us say it is a practical language like SQL you have invented a new language and you are trying to sell it as an as a vendor then in the specifications you should mention that it is relationally complete so what does it mean whatever whatever you can do or whatever you know queries you can express in relation algebra you'll be able to express in your language also so generally relation algebra is used as a you know measuring stick against which you can measure the performance of all the other languages so every language is supposed to be relationally complete otherwise you'll not be able to express some of the queries or you'll not be able to extract some data from the database that is why all the languages will try to be relationally complete right now similarly since these three are equalent in par you can say that tle relation calculus and domain relation calculus both are relationally complete got it so all these three are relationally complete okay and now what is the main difference between tle relation calculus and domain relation calculus is in tle relation Calculus if we have a table let us say these are all the tles we have in the table tles means zeros okay now coming to tle relation calculus we are going to examine a tle as a whole we are going to take a tle and examine it and then we move to the next tle and examine it and next tle and examine it and we go like this right so which means if you assign or if you take a variable now that variable will range over or take each tle at a time and examine it that is called as tle relation calculus in tle relation calculus we are going to take the entire tle as a basic unit and we work on that and coming to domain relation calculus we are going to work on the columns which means we generally range over the column and we look at it right that is why it is called as domain relational calculus right so which means we take the entire column and we examine it and then we make some decisions on that that is the main difference between tle relation calculus and domain relation calculus got it here the variables will range over the tles and here the variables will range over the attributes or columns or domains all right and one thing you should be careful about is till now we have not heard about you know uh unsafe operations but coming to T relation calculus there can be some unsafe operations so what is of operation is let us assume that this is a student table okay now when I in a query if I write like T and student of T it means that I'm talking about t when T is ranging over this table if I write negation T then it actually means that we are talking about all the Tes which are not in student table right now according to the set theory set of all tles if it is present as this student is present as a subset of it right now if T is actually ranging over this student table and if you write negation T what you are saying is all the tles which are present in the universe of all the tles which doesn't belong to student right then it is going to be infinite right therefore it might lead to infinite Loop if you try to implement it right so there is a chance that you might have some unsafe operations or unsafe queries in case of tle relational calculus so it is uh you know uh even though it is as powerful as relational algebra it is containing some unsafe operations you should remember that okay so you should never try to use these unsafe operations because it is actually meaning that you have to look at all the doubles which are present in the universe which will be infinite okay now let's see how to write the syntax in tle relation calculus let's take an example it will be easy to understand that way instead of talking about the theory assume that we have a table student table and in this student table we have three attributes one is first name other is last name and the other one is marks now say we want to find out the first name of the student who has got you know all of all the students who are having marks greater than 50 right so what is it I want to know the first names of the students who have got marks greater than 50 that is what I want now how to do this is so we have to declare or we have to use a variable which will be called as a tle variable okay let's say it is T now we should Define or we should specify what is the range of that variable so range is nothing but what is the table on which you want this variable to go over and look at all the Tes right so now I'm talking about this so I'm talking about this student table and I'm interested in looking into only student table that is why I'm fixing the range of the variable T variable t as the student table all right now it is going to range over all the tles one by one so if you have the tles like this T is going to take each tle one by one and it is going to look at it based on the conditions that you specify therefore you are now supposed to specify the conditions on it so what are the conditions what is the condition you just write and which means T should range of student and if you want to talk about an attribute then you are going to write write like this once you define the you know tle variable then you are going to write dot T dot what is the attribute that you want to look marks isn't it so T do marks is greater than 50 so what does it mean we are going to select all the tles if you write T here directly then you are going to get all the tles which are present in the student table and marks of this is greater than 50 you are going to get all all of them in the output got it so it will take one by one one by one let us say this is a b 100 and it is b c 40 and it is is EF some let's say 60 right now it will go here first you will take the first tle and then it will see the marks if it is greater than 50 it is going to you know give you this entire tle as the output because the output is given as enti t or and this one will be given as well as it will go here and it will take this entire tle and it will give you this entire tle as the output right that is how it is going to work now if you want to find only the first name okay if you want to find only the first name then you are going to write like T do first name got it so in general what we want how we are going to write this syntax is one thing is we are going to look at uh the first part the first part should be set of all attributes that you want them to appear in the final output so you can have like T1 Dot A1 which means from the uh variable a or from the table on which T1 is varying you want the attribute A1 right comma t2. A2 so what does it mean from the table on which T2 is ranging the variable T2 is ranging you want the attribute A2 right so on you can have any number of you know toule variables ranging on any number of tables which means you can have T1 ranging on Capital T1 table and T2 ranging on Capital T2 table like this right T2 ranging on Capital T2 table so on so you can have any number of tle variables in any combination and those tle variables can range on many tables as well as uh you know there can be two variables which are ranging on the same table right along with that you can have the conditions like you can specify the conditions like this T1 do A1 greater than 50 like this right so depending on that you can choose anything so you can have any number of doule variables and you can choose any number of attributes in the output or you can choose the entire relations as the output and here you can have any number of tables on which your variables are ranging or more than one variable can range on the same table and then you can specify any number of conditions here now let's see um how to write the syntax of a relation algebra expression so in relation algebra we are going to write a vertical bar and to the left of the vertical bar we are going to write what are all attributes that you want to see like you can say that from table on which T1 is you know bounded you want to see attribute A1 and from table T2 on which you know uh uh T2 is bounded you want to see A2 something like this and in the right side of it on the right side of the vertical bar you are going to write some expression right and now these expressions are of two types whatever you can write on the right side they are of two types either they can be called as atomic expressions or complex Expressions complex or let's say composite okay Atomic or let's say simple Expressions now what is the example of a simple expression is assume that you are trying to bind uh variable T over a table let's say EMP so EMP is the table on which you are trying to bind T then how that how how are you going to express that you are going to write it as as EMP of T right so this is an example of you know simple expression or sometimes you might try to compare some attribute of a table with some value let us assume that this is the employee and say there is an attribute is and you want to choose all the employees who are older than 20 years right so let us say you want to choose all the employees who are older than 20 now how is that you are going to express this one is you going to say t do a greater than 20 now this is an expression of or this is an example of simple expression now in this way uh in this place it need not be always greater than it can be any compar comparison operator it can be greater than less than greater than or equal to not equal to anything here right so whenever you have any expression of this form you can call it as a simple or Atomic expression or sometimes we can also have some other type of you know comparison where you might try to compare one attribute from one table with other attribute from other table let's say A2 now what is the meaning of it is assume that you have a table like this let's say the table is T1 on which you have binded or the range of this variable T1 is capital T1 here I assume that there is a attribute A1 now this attribute you are trying to compare with some other table let's say T2 and a variable small T2 is ranging over this table and let's say you have an attribute here now you want to compare for every t for every Tuple this value with this value this value with this value if you want to do like this you can use this one all right so these are the examples of three simple or Atomic uh you know Expressions now from these Atomic Expressions you can form complex or composite Expressions now what is a complex or composite Expressions is every Atomic expression is also a composite expression right so the first point is it can be simply an atomic expression or it can be a collection of it which means this Atomic this comp complex or composite can be a combination of atomic or simple expressions in such a way that if you say that A1 is a atomic expression and A2 is an atomic expression I can use and right or I can use R logical and logical r or I can also use not now this is also an example of composite or complex expression other than this you can also have something called as quantifiers for all T and then there can be a simple expression or composite expression there similarly sorry this is there exist there exist T and then there can be a simple expression or composite expression or for all T there can be some expression now whenever I have these quantifiers then such a variable is called as bounded variable if you don't have any such quantifiers then it is called as free variable now assume that in a query you are going to use let's say four uh variables one is T1 T2 T3 T4 let us assume that we are using these four variables in this query now to the left side of this bar whatever you are going to use all of them should always be free which means T1 and T2 should always be free and whatever is not present here that will definitely be present on the other side isn't it so forget about T1 T2 they are already present here if something is not present here if it has to appear in this expression then definitely it should be present in the right side of the query isn't it now if it is present in the right side without being present in the left side of the vertical bar then definitely it should be a bounded variable which means it should have quantifiers like this there exist for all right now now let's see what is the meaning of their exist and for all so what is the main difference between free variable and a bounded variable is assume that we have some expression like this there exist t such that t of a i is greater than 50 now what is the meaning of this one is there exists at least one tle in such a way that a value for that tle is 50 right so if you look at this table I'll just take an example of this table now the main difference between the normal variables and the bounded variables is free variable and bonded variable is if you have a free variable you can simply go on evaluating it over the entire table one tle after the other tle but if you have a bounded variable you have to uh evaluate it over the entire tle then or the entire table then only you can say its value for example if you want to know whether this value is true or false what is the value of this one right now the tooth value can only be known after you process the entire table right which means if you have to see this what is the meaning of this there exists at least one tle in the table in such a way that a value of that tle is greater than 50 now let us say a value is 10 20 30 40 now the truth value of this one will depend upon what all the a values of this in this present in in this table are right now if you see this a values are 10 20 30 40 now there doesn't exist any value which is greater than 50 isn't it therefore it is going to be false right so the truth value of this of this expression is going to be false why because there doesn't exist anything but then how did you come to this conclusion only after looking at all the values isn't it you cannot skip any of the values or any of the tles and you cannot say the answer is you know true or false why even if you try to skip one of the values there might be one more tle which is having 51 there right therefore you have to see the entire T now let us say this is the instance on which you're working then what will be the output of this one it will be true why because there exists at least one toule whose value is greater than 50 got it okay now let us say one more example for all okay here the condition is this variable T is ranging over this table then only it can be applied on the table okay now let us say the for all t t of assume that b is less than 10 now what is the value of this so the meaning of this one is for all the tles the value of the attribute B is less than 10 let us say this is the attribute B okay now assume that here the value vales are 2 3 4 5 1 2 3 4 5 okay now if You observe it for all the tles the value of this B is less than 10 isn't it therefore after looking at all these values then only we can say that the truth value of this one is true right see if you don't have this quantifier if it is a normal free variable then T of B is less than 10 means it will select all the tles for which it is less than 10 which means for this tle this expression will be true for this tle this expression will be true which means free variables are going to work only on the tles one after the other therefore the atomic unit of processing there is a tle right and here when you are talking about quantifiers the atomic unit of Crossing is the entire table got it okay now we can also combine along with these quantifiers some negations also so if I say like this negation of there exists t such that t of a is greater than 50 now what is the meaning of it there does not exist any tle in such a way that a of T is greater than 50 what is it there does not exist any tle in such a way that a of a a t of a is greater than 50 now if you see this there exists a tle ins such a way that its value is greater than 50 isn't it therefore it is going to be false are you getting this there does not exist any tle in such a way that a value of the tle is greater than 50 but then there exists a tle in such a way that a value is greater than 50 now let's talk about SQL so before talking about SQL SQL is going to act on the you know database which is called as relational database so uh you know in the early days people don't know how to save the data and then uh you know this person EF code he has introduced a new way to store the data right and that is called as relational model that is what we have seen till now so relational model is nothing but storing the data in form of tables right so it is a way in which we can store the data and now uh in his paper a relational model of data for large shared data banks in this one he has discussed about how to store the data by using the tables now because of this model you know initially it is not very popular but later his colleagues have developed a language using which we can you know uh access the data which is present in relational model so at the same time while he has prop while he's proposing this model at the same time these two people Raymond and Donald who are his colleagues working at IBM uh they have proposed a language called as SQL now this language SQL uh you know talks about how to access the data if the data is present in form of tables or relations right and now the full form of SQL is a structured English query language now after this I know after they have proposed this language then everyone started using this model because there is a language which is helping us to retrieve the data from that model easily right so both of them have become popular at the same time right and then they have come up with SQL so anyway later this uh from the SQL all the ovs have been dropped out and now we are calling it as SQL so sometimes we are even still calling it as SQL uh because the name is actually having some conflict with some other name used by aircraft companies that is why they have dropped out this these ovs and they're simply writing it as SQL but still calling it as SQL now what are the features of SQL is it is it is based on relational algebra and tle relational calculus so we have already seen what relational algebra is and what tle relational calculus is so this is an implementation which is based on these two which means we are going to take some of the features from relational algebra and most of the features from tle relational calculus and we are going to implement it in SQL right and for the first time it is implemented on system R by IBM so IBM was having a relation database on which this particular language has been implemented and it has become very success successful and after that you know many companies started offering this language as a package like Oracle is there and then Microsoft SQL Server Ms access and MySQL so there are many companies which are up you know uh giving the commercial packages in order to access the database which all implement the same language SQL now since all of them are implementing the same language SQL now they are portable in the sense if you have initially designed your database based on arle and after sometime if you want to move on to mySQL since both of them are implementing the same features which have been proposed in the SQL which is which is used as a standard the portability is easy you can move from one platform to the other platform if you don't like it right so that is one of the advantages of uh you know uh implementing your database on any platform which is based on SQL right so SQL is somehow has become the standard right and that is why it is you know increasing the portability and then if you say that any package let us say any commercial vendor if he is providing some you know SQL complaints language it means that he is going to provide all the basic functionalities which are proposed by SQL that is is called as Basics and then apart from it some vendors have also implemented their own features which are called as extensions right so if you're going to buy let's say article now they are going to give you all the features which are proposed by SQL under the basics and apart from it they're going to give you some more extra features which will be called as extensions right now because of the extensions you'll be able to do some queries faster right anyway since every language or every platform is implementing SQL only portability is always there okay fine in any database they will be lot of tables and also many people will be trying to access it now if you consider a company there will be a lot of employees there and sometimes what happens is you don't want to give everyone the access to the entire database so there are various reasons one thing is they might not need the information and the second thing is you know there might be some security concerns or you want to maintain some confidentiality so what I mean to say is let us say there is a company right and in this company if you have various departments let's say there is finance and there is HR and there is let's say marketing now people working in the finance department they don't need to access or you don't want to share any access for them uh with the data which is related to you know HR department therefore all the data which is related to this department you want to group it together right so what is data means all the tables and the objects which are you know related to that you want to put it all together and you want to say that only people working in this department have to access it right now how to enable this one is by using a concept called as schemas Now by using schema you can group The related data together which means in this case I can group all the data related to finance in one you know schema and then all the data related to HR in one schema and all the data related to Marketing in one schema now I can specify who can access what for example I can specify that only some of the employees who are working in finance are going to access this schema right and also I can even specify that some people can can access a part of this schema all right so let's see how to do this so for this reason we are going to use schemas now what schema is schema is grouping logical objects together is called as schema right so when you try to put all the logical objects together it is called as one schema or simply if you want to understand it in another way you can think of the table headings if all of them are put together then you can think of it as a schema right right and generally all these tables are you know somehow related logically and then uh the syntax to create the schema is so this syntax is created by most of the SQL languages now create schema and you are going to specify a schema name and along with that you can specify who is know the owner of it got it so whenever you create this schema you are also specify who is is going to be the owner right now see this for example create schema Finance authorization Ravi so what does it mean Ravi is the owner of it and he is given the permission to access the entire data which is which is going to be present in this schema all right similarly after creating a schema you can also Grant the access to some users like this now Grant select on finance. store so finance. means everything that is present within this Finance schema now that will be given to user one so what does it mean we are giving the access to user one to access everything that is present in scheme you know Finance uh uh this one schema now apart from this you can also specify that you want to give access to a specific module and you can write that module here if you want to give access to a table you can write the table here and then only to that table which is present in this schema to that you know this user one will be given the access got it okay the most basic entity of a database is a table now let's see how to create a table now if You observe this create is the command which is used to create the table in the database right it is used to create a table in database now the syntax is create table table name and then we have to specify what are all the columns in it right like column one and what is its data type and what is its width and column two what is its data type and what is its width so you are supposed to specify that now with these specifications we can create a table see there are other things that you can specify while creating a table right we shall see those you know constraints later for now this is the basic command later we can extend it the basic command is like create a table and you have to you have to spe the table name and then you have to specify what are all the attributes the attributes are also called as columns right so column one column two like this and every attribute can have a data type for example uh name of a person is different from the salary he is getting right therefore uh the data type that is used to store the name and the data type that is used to store the salary both of them have to be different right and also the size size is also going to be different so if you look at the salary maybe seven figures or six figures are enough and if you look at the uh you know name then the width can be more right so based on that you know some data types are uh defined I'll tell you what are the data types let's say an example on this create table customer we are trying to create a table customer in which name is of data type variable character and see where Car 2 is the name of the data type don't worry about the exact details they are not required just understand that it is a data type user to store the characters and then the size is 30 so the meaning of it is you can have a name to a maximum length of 30 characters Now by writing this way uh we can specify how much space uh that we should be allocating for this particular field right when you're trying to create when you're trying to implement this database every table is a kind of structure in a structure you have to allocate space for every field now by writing like this you'll be sure that you don't need more than you know 30 characters so it is always better that you give the width so that you know creating of table will be effective in terms of the space you are not going to uh you know uh dedicate more than 30 characters for any name okay and the next one is customer ID it is a number so what does it mean customer ID is a field see so how to interpret it is we are going to create a table and the name of the table is customer and one of the attribute is name right and this is of type data type the data type which is used to store the name is whereare variable character and its size is 30 which means we are never going to exceed uh you know 30 characters in order to store any name and the next one is customer ID so it means that the customer ID is a column which means on attribute and generally customer IDs will be numbers that is why the data type we are using is a number and the next one is address now address is also a kind of text that is why we are using the characters to save it so where car is a data type which is used to save it and we are allocating 50 characters to store the address got it okay now what are all the data types if you see this these are some of the data types is it now let's see what are all the data types which are present in SQL we have numerous data types in SQL and these are all the list if you want to uh save numeric data which means if the data is consisting of numbers like phone number or salary right or let's say is these are all numbers right then you are going to use these formats so what are the various formats used for numbers is one is number and Float float is used for floating Point numbers and then integers real real numbers decimal and binary float so binary numbers can also be stored right and the next one is for characters so if you look at the name name of a person or name of a department or name of an employee name of a dependent right so if you are looking at the names generally there will be even address is also you know characters isn't it therefore we are having all these data types which can be used in order to save the characters so one is care other is we care and n care and NW care 2 long draw and long raw so don't worry about the exact details of these uh you know types so they are not required for us just just know that they are existing okay and the next one is date so in order to save the date again we have various formats we can use the date format or we can use the you know time data structure or time stamp or interval and also you can have sometimes Boolean right so Boolean data type is also being used for some attributes so in that case we are going to use you know Boolean now sometimes while creating a table we might have to specify some constraints on the attributes right so I'll show you what are the constraint you might have to specify while creating a table let's say this we have these seven constraints in SQL so one constraint is not null so sometimes we need an attribute to have some value and it should not show null as its value for example if you think about the employee name an employee name cannot be null he has to have some name right now why are these constraints important is let us say you have created a table and later someone is entering some data into the table right and if they enter some data which is wrong then you have to catch it there so for that reason you can spacefy uh what are the values that this table can accept and what are the values that this table cannot accept for example if I say if you are saying that you create a schema or let's say you you're creating a table and in the table you have created employee name right and you just created the table and you left it later someone is trying to update it now by mistake if it tries to enter name as null right which means if it doesn't specify any name then it is null right now you should catch it then and there and you should in from the person that you know name cannot be null now how can you make sure that your database will cach this only if you specify that this is an attribute which should not take any null right so in order to specify that you know employee name cannot take any null we are going to use the constraint not null exactly how we are going to use it I'll just show you with an example so for for now just understand that not null means the attribute is not supposed to take the value null and the next one is unique sometimes uh we want want uh some attributes to have unique values right for example if you talk about name of a department no two departments can have same name for example computer science department and again computer science department you cannot have two departments with the same name right so in that case you can specify unique unique means uh if already a name exists then uh you know your database management system the software has to check that you are not creating the same name again right if you try to create the same name again it should catch for example if you have Department name here right now if you want this to be unique if you specify that it it has to be unique then what happens is let us say you have created computer science and later someone is entering one more tle which means uh you know a row with the value computer science again right then you should catch and say that department name has already been specified as unique and you are trying to use it second time and should it should catch it and you know it should throw an error so for that reason we can specify this constraint and the next one is primary key so primary key as you know is uh is should be unique throughout the table and it should not be null right so primary key we have already discussed while talking about the functional dependencies and the same concept is applicable here primary key is nothing but a field in a table which is going to be unique and which does not have any null values therefore you can think of primary key as if it is combination of these two isn't it so three is a combination of one and two now what is a foreign key foreign key also we have seen in the uh you know this functional dependencies if you have an attribute in a table which is going to refer to an attribute in other table then it is called as foreign key now where are you going to use the foreign key there we have seen an example where if you have an employee table and employee table let us say is having employee ID this is let us say it is employee table and now you have a dependent table and in the dependent table also we have employee ID now for every dependent the dependent is going to uh depend on some employee in the company isn't it therefore this should always refer to this so the meaning of this one is if you are going to have a dependent now if you say that the dependent is depending on employee one then there should EX exist an employee with one otherwise you should not be able to write it right so by specifying the foreign key your database will be able to check or catch some errors so what type of Errors it might catch is let us say you are creating a dependent who is depending on employee number 10 and in case if there is no employee number 10 here then your database management system should catch it and say that since it is referring to this your employee number 10 should already exist there and since it is not existing there you know this is an error so you should catch it so in order to specify that this might this is an error you have to specify that it is a foreign key then only all such errors can be caught and the next one is check so sometimes you want to uh you know check certain attributes let us say is can never be negative isn't it so a has to be a positive number if someone tries to enter a as a negative number by mistake should be able to check it then and there right now how can you specify it you have to specify it by using this constraint right and the next one is default so some values if you if you're are not going to write any value then there has to be some default value right so let us say someone has not attended a test and now there is marks now in the marks you have to write something now what is the default Mark zero right so if you are not going to enter any value then the default has to be zero and the next one is a referential constraint okay so what is this differential constraint we shall see later in this video we shall see all these six constraints with examples okay now let's take an example I'll give you some requirement and then based on the requirement we shall use this constraints and we shall specify how to create a table with these constraints okay now let us say our requirement is this we want to create a department table okay see this we want to create a Department table and in the department table we need these three attributes one is Department ID and the other one is Department name and the other one is location of the department and in this department ID has to be primary key right so what is primary key it has to be unique and it should not be null right if you specify that it has to be primary key then these two constraints are automatically implied and then Department name now department name has to be unique so what is the meaning of unique is no two departments can have the same name that is the name of the meaning of unique now there is one more point you should understand about unique here whenever I say that it should be unique it means that no two entities should have same value uh no two row should have same value in that attribute fine but then one more thing is it also allows null values right so the main difference between primary key and unique is primary key is also specifying that the entire attribute has to be unique along with that it specifies that no null values are allowed but if you look at unique it's specifying that no two entities should have the same value all of them should be unique and also it will allow null values that is the main difference right so if we are going to use unique here it means that no two departments can have same name and some departments might not have name at all even though it is not practically you know uh that way it is not practical to have a department without a name and just for the sake of example I'm taking it this way right so now what is the meaning of it no to Department should have same name and there might be some departments uh you know which might not have a name at all in that case we are going to have null there got it so let us say this is the requirement we have one is Department ID has to be primary key and then Department name has to be unique and then location with no constraint now how to create a table with these constraints let's see for this example how we did how we did it here now let's see here this one now just look at only this this statement okay create table department so we are just creating the table whose name is department and in the department as we have mentioned we need you know three attributes so one attribute is Department ID and other attribute is Department name and the other attribute is location right and what is the data type of the department ID it is generally a number right therefore we are using number now after specifying it you are going to specify the constraint now what is the constraint that we have on Department ID that it should be a primary key that is why I'm specifying the constraint on the department ID this way by writing like this we are just saying that department ID has to be unique and there should not be any null values there got it okay and now looking at the department name we have uh the name is expressed as a data type where care of 30 so what is the meaning of it it is having some characters and its maximum size can be 30 right and what is the constraint we have on it the constraint we have on it is it has to be unique right so that is why I'm mentioning the constraint at the end here right now if you look at it primary key constraint is mentioned here and unique constraint is mentioned here now department name has to be unique right so along with the attribute I when I'm mentioning the you know constraint it is called as column level constraint right if I mention the you know the constraint after specifying all the attributes at the end it is called as table level right therefore we can Define constraints at two levels one is called as column level and other is called as table level and you can use any way which means I could have even mentioned this primary key of number at the end sorry primary key of Department ID at the end I would have mentioned that right so either you can mention a constraint along with the attribute or you could put it at the end of the table right both ways you can do it now there are some exceptions so one exception is that not null whenever you want to specify not null it should always be specified at the column level which means if you have a constraint let's say you know I'll show you later so what is not n is then it should be always associated with that particular attribute which means the column and composite key should always be defined at the table level what is a composite key is when you're going to combine more than one attribute and making it a key then that is called as composite key now in case of composite key you have to specify it at the table level only and not at the column level right these are the two exceptions okay now this is how we have created the table Department using the constraint that are specified or requirements right now let's try to create the one more table employee let us say the requirements are like this all right see this now assume that we need to create one more table employee and the requirements in order to create the employe are like this employee ID it has to have now let us say it is having an attribute employee ID and this employee ID has to be the primary key and then employee name is one more attribute and this has to be not null so what what is the meaning of it is you should not leave any employee without any name so every uh tle or the row in this table should have employee name as some value which means it is meaningless to have an employee without a name isn't it but then it is not unique which means two employees can have same names it is allowed right okay and next one is job so job is an attribute and there is no specific constraint mentioned on it which means you know job is just a description of what he is doing in the company and there is no specific uh you know anything like that so it need not be unique or it need not be any key or it need not be not null right it is a just a normal name and the next one is Department ID now if you look at the department ID this department ID is referring Department ID of department so what is the meaning of it every employee should work for a department which already exists if the department is not existing then the employee should not be working in that right now how can you make sure that a department is existing you should look at the department table and you should see that this particular Department ID is already there otherwise you can say that department doesn't exist right so just to mention that relation we are going to use Department ID and the next one is manager so manager is just uh you know who is who is the manager of this employee right so maybe it can be an idea right manager ID is also the employee ID of the manager who is managing this employee right and then salary now salaries having one more constraint that every employee in this company should have at least a salary of 5,000 right so this great than or equal to 5,000 is again a constraint on salary and then the next one is commission right and commission if it is not given then default value is 100 so again you have one more constraint which is default so if nothing is mentioned here commission should be 100 and then email email ID and phone number these two combined should be unique so it is nothing but a composite key doesn't it so it should be okay it is not a composite key it is just a combination okay so now what is it we are going to combine these two and we are going to specify that they should be unique got it a combination of these two should be unique all right so let's see how to write it there now create table employee so what are the various attributes we have one is employee ID now employee ID the data type is number so which means employee ID can only be numbers and it should be the primary key right so this is the constraint we are mentioning on employee ID and the next one is employee name employee name is characters that is why I'm using we care and 30 means the maximum size of employee is 30 characters and it should not be null which means you cannot leave it out you should write some name for you should give some name for every employee right and the next one is Department ID is a number but then it is going to refer to the department ID of the department just to make sure that every employee is working for departments which is already existing right and the next one is uh job job is simply a string of characters which can be maximum of 30 size and the next one is manager okay so manager's name must be given here why because we are taking the characters okay so characters and it is not going to exceed 30 and the next one is salary we have a constraint on salary saying that it should be greater than or equal to 5,000 right therefore salary salary is a number and what is that we are going to check we are going to check that salary is always greater than or equal to 5,000 now what is check is you can specify some static values inside check got it so this is a way in which we can specify the static values and also you can say it is between this range for example salary is between 5,000 and 10,000 you can specify that or you can say you know if if it is a department you can say Department in 1 2 3 4 right so there are various ways of specifying this constraint and there can even be sometimes Boolean values also but whatever you are going to write here it is better you maintain it as a static right and the next one is commission now we are saying that commission is a number and its default value is 100 and in next one is email ID and phone number so email ID and phone number are both taken as characters phone number is taken as a Char you know string of characters which is not exceeding 13 and then email is also taken as a string of characters which is not exceeding 30 now both of them put together they should be unique so what is the meaning of it email ID can repeat and phone numbers can repeat but then when I take a combination of these two they should be unique which means no two rows should have the same value uh of email and phone number got it so this can be cons you know you can think of it as if it is a composite key right so there are some attributes for which see if you look at this this attribute is not null now only thing is not null can never be specified at the table level but then if you look at this primary key I could have specified even it even the primary key at the end I could have written it as primary key of email ID which means primary could primary key could be specified either as the attribute level or the table level right and similarly what are the other things yeah so that that is the only thing here so not null not null has to be always associated with the attribute right Nal constraint should be defined at the column level and composite key should be defined at the table level which means this one when you are having a you know uh combination of two things it is always it has to be declared at the end that is why it is at the table level all it okay now if you look at this phone number for the phone number we are using Vare now you might get a doubt that phone number is a number but we are using a Vare right so it is actually used to represent character but then if you look at a number it can also be written as a character right since a phone number is a sequence of numbers which can be written as a sequence of characters I'm just using this one right and also when you're looking at this manager this can be a manager ID which can be a number which means we can express a number even using a string of characters or by using number data type right okay and let us assume that you forgot to mention some constraint while creating a table and later you you you know somehow you remembered it then you can alter the table and you can specify uh you know new constraint on it so after creating the table also you can use the command alter table and you can specify the whatever constraint you want to specify on the attributes again got it okay now that we have seen how to create a table after creating the table we might have to enter the values into the table uh let's see with examples and the syntax of how to insert some values into the table now for that reason I'm going to take an example so let us say there is a table by name department dupt and the attributes in the table are like this one is Department ID and the other is Department name and say one more is location Okay so if you consider that these are the attributes which are present in the table now if you have to enter a new tle or a new row into this table there are various ways one way is directly uh give the values into the table without you know talking about this attribute names if you are going to give three attributes in the order in some order uh it will think as if the first attribute belongs to this uh you know the first value belongs to this attribute the second value belongs to this attribute and third value belongs to this attribute now let's see the syntax corresponding to that style so what is it if you are going to give three values and if you want to enter it as a tle inside this table then the corresponding uh values will be considered as if they are values belonging to the first attribute second attribute and third attribute respectively let's see the example here now this is syntax one insert into table name so whatever table you want to insert this Row in you have to write the table name and you have to specify what are the values of the attributes right in this case values attribute one attribute two so on now for example if you want to insert into this table one CSC and Hyderabad then you have to say insert into Department department is the table name and what are the values of the corresponding attributes so one CS CSC and Hyderabad now what happens because of that query is see this here now for Department ID it is one and for you know Department name it is going to be CSC and for location it is going to be Hyderabad now how do you know that department number has to be one because out of the three values entered you are going to see the order in the order first comes one that is why it belongs to the department ID right and next comes Cs and next comes location now when you're using this kind of syntax you cannot miss out any of the attributes or you cannot change the order in which you are going to specify the you know attributes for example if you write it as 1 1 comma Hyderabad comma CSC 1A hyd comma CSC then it will take Department name as hyd and location as CSC therefore the order is important as well as specifying every attribute is important if you're going to use this syntax what is the syntax insert into table name without specifying the attribute names if you directly give the values got it and the next next way is okay the conditions are like this attribute attribute values should be in the order of the attribute list so what is the order first one is you know the department number and Department name and location that order should be followed and the next one is number of attribute values should be equal to the number of attributes in the attribute list which means you cannot skip or miss out any of the attribute values and let's see the second syntax the other syntax is if you want to specify this one in any other order let us say you want to enter one and then Hyderabad and then CS CSC then you have to specify that you are entering Department ID first and then location first and then you know Department name at the end you have to specify it clearly right so if You observe it insert into table name here you are going to give all the attribute names and then you are going to specify values so if you want to change the order or if you want to miss out some of the attributes then you have to use this syntax right for example see this insert into Department Department ID comma Department name comma location here you are clearly specifying that whatever value I'm first entering corresponds to Department ID and whatever value I'm second entering correspond to the department name and whatever value I'm entering at the end corresponds to the location now if you are going to write this then what will be entered is so first one is Department ID which means two will be entered and the second one is Department name which means cc is entered and the second one is location kgp now since you have given the attributes in the same order in which the attributes are specified in the table you need not actually write it this way you could have even written it without specifying the attribute name right names here but you know anyway both are going to be the same now this will be really useful whenever you try to skip or miss one of some of the attribute values now see the next one insert into Department Department ID comma Department name now if You observe this location is missing all right so whenever you're missing one of the attribute it is better that you specify what are the values of the attributes that you are mentioning you know you want to enter for example here you want the department ID to be three and you want the department name to be Triple E and you are not mentioning the Department location isn't it therefore three will be entered here and then triple will be entered here and now you are not you know mentioning anything about this so there are two choices then one is if default constraint is already you know uh specified on this location then that particular default value will be occurring here let us say while creating the table there is a default value for this and the default value is Hyderabad now you are not mentioning anything that is why Hyderabad will be taken now if you have not given the default value then simply null will be considered in this case got it so these are the two ways in which you can enter the you know uh values into the table in a basic way now later we shall see how to use this insert or how to enter the insert using subqueries and queries and Views later we shall see other formats but then to look at those formats we have not covered some topics yet so after covering some more topics we'll again revisit insert there we can see what we can write here without specifying know the values explicitly now let's see this uh Delete uh Delete operation now generally what we do is we might want to delete a row in the table or all the rows in a table or the entire table we want to delete so these are the three types of delete we might want to do right so so either one row or all the rows or the entire table okay now let's see how it could be done now the syntax is delete from so you whatever table you want to delete from you have to write the table name and then you also can specify some condition like if it is satisfying some condition that row is satisfying some condition you might want to delete such rows okay so what is this where and you know how to you know implement it we shall see now let us say we have two tables one is Department table and the other one is employee table these two tables we already created in the previous example right now assume that the department number here let us say the department ID of employee is referring Department ID of the department here right so which means this one is refering this one so what is the meaning of it if you are going to have some department number here you should be sure that the department is already present here then only you can have it otherwise you can't have it right that is the referential you know foreign key we are going to have so Department ID of employee is going to be a foreign key referring to the department ID of the department right and all the other things are same as we discussed now let's see how to delete a row and all the rows as well as the table now first one is delete from EMP where employee ID equal to 1 so what is that we want is we want to get into this EMP table so from is going to give us the table name delete from employee table where EMP ID equal to one so whenever this EMP ID equal to 1 we want to delete that row now what will happen because of this you know query is or because of the statement is this one will get deleted all right so employee one data is completely deleted and now if I write delete star from EMP then what will happen because of the statement is know this entire all the rows present here will get deleted got it so this one this one everything gets deleted but then the table is going to exist see only the rows are going to be deleted but the table is going to exist in the database again you can update and again you can insert some values into it right it is not that the table is going to be dropped completely right now if you want to delete the table and the rows completely nothing should be remaining then we can use the drop right okay so before that sometimes what happens is whenever you do some delete it might create some problems whenever you have foreign keys so in this case just see this one now we have foreign key one foreign key is you know see this this is the foreign key and one employee is referring to the value two and other employees referring to the value one now what is the meaning of it this particular employee is present in department number two and this particular employee is present in department number one and these entries can exist only if you if department number two and department number one exist right now in case if you try to delete department number one or two when you have employees here that is going to create a problem what is the problem according to this you know Integrity constraint you are not supposed to have any rows here which are going to refer to a department which is not present there now if you try to remove either department number two or department number one it is going to create a problem right so for example if you see this delete from department where Department ID equal to 1 now we are specifying here that employee 3 is working for department number one and now you are deleting the department right now it is going to make the database inconsistent because you are talking about an employee who is working for department number one when the department number one is not at all in the database right so this has to be handled in a different manner for that we are going to see something called as referential Integrity constraint all right something called as referential Integrity constraints get violated and how to handle it we shall see it so what is referential integrity constraint Whenever there is a foreign key whatever values you have for it should already be present there right but since one is not present there it is violating the referential Integrity constraint now how to handle it we shall see it later okay in the next video or sometime later we shall see it okay and now the next one is drop so drop is used to delete both the data and the table for example if I try to drop see the syntax is like this drop table table name if I try to drop the employee table it means that all the employees will be deleted and as well as the entire table will be deleted now after you drop the table you cannot use insert got it see now if you delete all the uh rows of a table again you can use the insert and you can you know uh try inserting the rows into the table but then once you drop the table completely unless you create it again you cannot use insert to insert the row that is the main difference got it so once you drop it again you have to create it but once you delete all the rows you need not create it you can directly insert right now again dropping a table will also lead to the problem of Integrity constraint violation so when is it possible is if you try to drop this complete table having this table in the database now you can clearly see that here some Department information is given and you don't have any Department information there therefore again referential Integrity constraint gets violated now how to deal with that we shall see later okay but but anyway you should understand that deleting May sometimes lead to violation of referential Integrity got it okay now let's see update now why is update used is it is used for updating the data of a table sometimes you might want to update certain attributes of a row then you have to select the row for which you have to apply the modifications and then apply the modifications right now see this update the syntax is like this update table name you have to specify what is the table in which you want to apply the update and what are the attributes you want to change set attribute which means this is the attribute name which you want to change and this is the new value that you want to set to that attribute where where condition is used to select some of the rows of the table okay let's see an example update Department set Department name equal to it where location equal to kgp so what is the meaning of it you go into the table which is having you know a name department and then you find out the rows which are having location as kgp and in those rows wherever you see Department name you are going to change it to it right now look at this in this example we shall see here here now in this table Department you have to go into the rows which are having location as kgp now this is this is z which is having location as kgp and now here you have Department name and you change it to it earlier it was EC now I'm changing it to it got it okay let's see one more now for example if you want to change update EMP set ID Department ID equal to 1 where employee ID equal to 2 now what does it mean you have to go into the employee table and then find out the employee with employee ID as two and then change his Department to one now see this how it is being done here now you have to go into this table and then uh find out the employee with ID 2 and change his Department ID to one that is what is done this one right now sometimes updating might also lead to violation of Integrity constraint now let's see an example on that let's see this query or let's see the statement Now update Department set Department ID equal to 4 where Department name equal to Triple which means for triple Department we want to uh set its Department ID to four now let's see here now if You observe this in triple Department we are going to set it department number as four now sometimes this might cause you know violation of referential Integrity constraint so when will it cause a violation is let us say there is an employee there is an employee who is having department number as three and let us say his name is ABC Now earlier there was a department with name three now the department name has been updated sorry Department number has been updated to four now we can clearly see that again this is violating the Integrity constraint because department number three is not there and also here also if you if you observe it department number one was not there right therefore whenever you try to update it is also going to violate the referential Integrity now whenever you have you are going to violate the referential Integrity then you are supposed to specify the database system like how it should behave like what should be the action Tak so should you allow the action or should you allow the action you know by doing some of the modifications so whatever you have to do you have to specify them clearly then only your database is going to do those modifications all right we shall see that in referential Integrity constraints okay fine now in the previous example I shown you that while deleting a row or while updating some value in a row we are going to violate referential constraints for example if you see this table let us say this is the department table and is employee table now in the employee table we are going to have the information about which department each employees working in for example if you see this employee one is working in department number three right now what happens if I delete this department number three is you know referential Integrity constraint is going to fail or what happens if I try to update it then again referential Integrity constraint is going to fail therefore two main things where referential Integrity constraint fails is uh one is either insertion or other is while updating therefore whenever you do this you are supposed to tell the database system that it has to perform certain actions to still maintain the referential Integrity right so it is always important that you maintain the referential Integrity somehow now there are various ways you can maintain the referential Integrity one one way is whenever you change this let us say you are deleting it right when I delete it if I set the particular value to null then it is nothing but updating it to null all right so set null is the query which is or the statement which we are going to use set null is the phrase which means if I delete this if I set this one to null that is called set null if I update this if I set this one to null that is called set null right or the other option is if I delete this now since a department has been deleted if you delete all the employees from the Department then it is called as cascading which means the delete is propagating here right and the other one is let us say you are changing this department number three to department number let's say 10 then if you put department number 10 here also that is also called as cascading whatever you do here if I do here also that is called cascading right and if I set null whenever I modify that is called set null right and the other one is set default which means if I delete this three if I for all the employees who are belonging to Department three if I set a department as default right that is called as set default so we have these three options now let's see how to implement them okay let's see the theory here what is referential constraints is this allows us to further describe the relationship between the referential column and the object it references by attaching a referential triggered action to the foreign key so what they are trying to say is whenever you are trying to update uh you know uh the key to which someone else is referring the then what happens is the referential Integrity is going to fail but still if you want to maintain that relationship right it is further describing the relationship which means if you still want to maintain the relationship even after deleting or updating then we are going to attach some referential triggered action to the foreign key so where are we going to attach this action to the foreign key which means whenever you are creating a table and whenever say you say that you know there is a foreign key then there itself you can say that this is the action you need to take whenever referential Integrity is going to fail or later you can again update it right okay let me just give you an example and see and show you how it works there are actually three actions that can be done either on delete or on update so one action is set null set null means whenever you update or delete some let's say department number if you are going to set that particular Department in employee table to null that is called as set null and the other one is set default def set default means whenever you change in the department table if you're are going to replace that value in the employee table by a default value that is called a set default and the other one is set Cascade set Cascade means whenever you change some value or delete some value right if you change or delete the value in the employee table also that is called as cascading which means the change is going to propagate okay now let's see some examples and the queries there now how are you going to specify it is see one is while creating the table itself you can specify what is the action you need to do whenever referential Integrity fails for example create table employee now you are going to create the table employee in which uh department number references let's say Department ID of department so here this one is defining that this particular department number is is referring to the department number of the department now after this you can extend it and write the triggered action right so here if you write the action then it will behave appropriately Whenever there is a violation now how to write it is just see this one same thing I'm just writing the same thing if You observe it the same thing I'll take from here I'll just show you how to modify it for the set null first so if you want to set null as the default behavor then what we are going to do is whenever Department ID references Department ID of Department then on delete which means on delete of anything here then you are going to set null you are going to set that particular value here as null that is the meaning of it right or on update set null which means whenever you update something here then you are going to set null here right for example you just see this delete from department where Department ID equal to 1 let us assume that you have given this statement while creating the table now you are trying to delete department number one right what happens here is see delete from Department table Department equal to one means this particular thing will be deleted this entire row now who will get affected because of this in the employee table the employees who belong to department number one will be will get affected which means because of the presence of an employee who belongs to department number one now the Integrity constraint fails because there is no longer department number one here and you are showing that this this employee is present there and because of that foreign key constraint this one should definitely be present there otherwise it cannot exist here now how are you going to maintain that relationship now here you are saying that on delete set null because of that statement you have to set this one to null this is what is going to happen which means while creating the table if you give the triggered action as set null then whenever you delete an entry there for the corresponding entry here you are going to put null now this is how you are going to see that referential Integrity is maintained now see this whatever values are present here will all be present there now again the differential you know Integrity constraint is maintained now let us say you are updating update Department set Department ID equal to 7 where Department ID equal to 6 which means here wherever Department ID was six is now made Seven now who will get affected all the employees who are present in department number six which means this is where you are going to get affected now how to deal with that this one you have already declared while creating the table on update set null will be be taken here why you actually updating not deleting right therefore on update you are going to set N means this one will also be made null now again if you see this Integrity is maintained referential Integrity whatever values you see here all the values will be present there got it okay now the other default action is or the other action you might have to take is set default now what does set default say see this so how to write it is the same thing depart number and you are supposed to Define what is the default value if something happens if the referential Integrity fails now let us say here the default value I'm using is three now you are just defining that this department ID of the employee is going to refer to the department ID of the department along with that you are saying that on delete set default and on update set default let's see what what happens here now assume that on this table this s this one is executed this statement delete from department where Department ID equal to 2 which means from here you are going to delete this particular row now who will get affected all the employees who are depending on or who are present in department number two which means here so this particular row is going to get affected now how are you going to deal with that here you have mentioned that on delete set default defa right and what is the default here three therefore you are going to write here as three got it now what if you try to delete three itself when you try to delete three now if you try to execute it this three will be deleted and whoever got affected again if they if they are going to set the default as three then it is never going to satisfy the Integrity constraint right therefore whenever you are going to use the default value our database management system should always see that this default value will never be deleted right if that is deleted you'll never be able to satisfy the Integrity constraint the reason is whenever something is deleted you are going to make it as three and if three itself is not present there how can you say say that referential Integrity is maintained got it therefore it is responsibility of the software to check that whenever you have given something as default it should should never be deleted right in case if you want to delete it just update this first just change the default to some other number and then you delete three let us say you want to delete this one you want to you want to delete three then what you should do is change it here first and then you delete there all right okay now let's say this one how does this one work update Department set Department ID equal to 8 where Department ID equal to 3 which means if this one if you try to make it as has it then who will get affected okay so you are not supposed to do this the reason is here what you are trying to do is three you have already maintained as default and now you are going to change that to8 right now what will happen is either whoever is depending on you know department number three are going to get affected here or later if you try to change someone else some department number if you try to delete it then automatically for that particular employee the default will show as three but three will not be present there therefore you should not either delete or update three when it is being used as a default therefore this particular statement should not be allowed by the software you should say that you are not supposed to do this action because three is already used as the default value all right okay and next one is set Cascade now the same way so Department ID number references Department ID on delete set Cascade on update set Cascade so this is how you are going to write this statement if you want to enable this feature okay now let's say an example delete from department where Department ID equal to 4 so what is the meaning of it is if you are going to delete this one delete from Department table where Department ID equal to 4 if you delete this one Cascade means the same action whatever you have done here should propagate to the other table as well right so that is called as cascading so if you delete it here all the employees who are depending on this department should also be deleted which means the action taken here will be the employee who is present in department number four will be deleted got it now let's say update update Department set Department update Department set Department ID equal to 9 where Department ID equal to 5 which means here wherever it was five you are now making it as nine now what did we say it has to propagate so what is the change done here updation right therefore you have to update all all files here as well which means you have to take this entry why this entry because this is what is referring to the F there now you apply update here as well all right so that is how you are going to see that whenever the referential Integrity is going to fail either because of deletion or updation we are trying to do something right either set null or set default or set casket and still maintain the referential Integrity right by now if you see this whatever actions we did there because of those actions whatever uh you know values you have here will all be present here otherwise they will not appear here which means after doing all this still the referential Integrity is maintained now if You observe this I have I have paid up on delete setel and on update set Nel it is not necessary that you have to mention both of them you can mention any one of them if you don't want the other Behavior to be there or you can also use you know a combination of this which means you can say on delete Set n and maybe on update set Cascade that is also valid right now depending on what you write there the particular action will be triggered whenever you either delete or update right so you can use any combination of this and even if you forget to apply these uh you know constraints while creating the table later also you can apply them now let's see about the select query so SEL selection is you know the basic query in uh dbms in SQL so if you see select it is used to retrieve data from the database and the syntax is like this select some attribute list is going to be given there from some table list will be given here where some conditions will be given right so we shall see the simplest versions of uh you know writing the select here and later we shall extend it with complex queries like there will be nested queries and all so later we shall see that but this is the simplest way you know you can write the select so select attribute list from some tables where some condition is given and now what is this attribute list is is this is the list of attributes whose values are to be reted by the query so if you compare this one with relational algebra there the projection is equal to selection here right so there you have written Pi projection right so whatever attribute list you specify to be finally available in the output there we have used projection and here you are going to use selection for it right and next one is table list table list is how many tables you are using in this query to get the to retrieve the information sometimes if everything is present in single single table then we need not use many tables sometimes what happens is in order to get some information we might have to join uh more than one table right in that case we are going to apply some list of tables here now whatever list you apply here automatically a join will be taken for all the tables and then we are going to apply a selection based on where okay and now condition so the condition here conditional Expressions that identifies the rows to be retried by the query so how does it work is if you compare this where condition it is exactly similar to The Selection condition that we apply in relational algebra so if you're thinking about relational algebra since we already seen it we can compare these three so one is Select can be compared to projection pi and then where can be compared here this where and these conditions they can be compared to selection because we are going to fil out some of the rowes and this from table list it can be compared to the join right so again the join conditions will be written here so in raw form you can think of it as if it is a cartisan product all right so how will this query be implemented is in general you take all the tables from here if you if you are not using any optimization optimization is different in general how it will be done is you take the cartisan product of all the tables present in this list and out of that you are going to filter out some of the rows based on this condition and whatever is remaining on that you are going to uh you know take the values from the projection all right so this is why this is how it is going to be implemented cartian product first then selection then projection right okay let's see some example here now let us say we are going to use these two tables so one table is depart Department table which is containing attributes Department ID and department number and other table is employee which is containing employee ID Department employee name and job and the department number in the employee is actually referring to the department ID of the department okay and now if you want to retrieve see the query is like this so what you want the information is this retrieve the names of all the employees who works for department number one now we want to find out the names of all employees who are working for department number one so if you look look at this employee table it is containing the entire information which means in this query we need only one table right so if you look at the employees who are working for department number one this is the only employee who is working for department number one right so this one and now you want to list the names which means this is what you are going to get right so what does what from contain in the select query what does from contain the from Clause is going to to contain the table employee because this is where you want to get the information from and what is the selection condition the selection condition is whenever department number equal to one you are going to select such rows and what is the final proection you want in the select CLA you are going to write employee name got it so how to put it in the query is see this select employee name which means we are finally going to project EMP name right from from where from the employee table right from the employee table where department number equal to one so it will take this employee table and then apply the selection condition which is department number equal to one based on that selection condition it is going to filter out this one this one this one this one this one all of them are going to be filtered out and whatever is remaining on that we are going to project whatever we need right so what is that we need only the employee name which means we are going to get Santos as the output all right okay next one is retrieve the names comma employee ID of the employees who work for IT department right now if You observe this here we have only department number but we don't have anything specifying that you know it is it department or anything like that so the required information what we have to you know display is names and IDs right so name is here and the ID is here this is what you want to display but then in order to display this you have to find out the department it so that information is present here I it is present here therefore whenever you have two tables you are supposed to join them and get the required attributes right so how are you going to join is first you are going to apply the caran product and then on the caran product you have to match every employee with the corresponding department for which he is working for example if you see this if you apply C product then this record of employee one will be matched with all of them but then what we want is Meaningful data which means this particular employee has to be matched only with the uh you know department number five so how are you going to take that there we are going to apply a selection condition which is going to filter out the unnecessary rowes right so since it is going to be matched with all of these if you apply the join now you have to write a condition so that it will filter out all the remaining and only this one has to be paid with this one all right and similarly this one has to be paired with this one right so how to see that is see this now this is nothing but the projection so select employee ID and employee name why only these two because that is what is asked names and employee IDs that is why only these two from where from these two tables employee and dependent so department now why these two tables because required information which you are to display is in this table and then uh the department name is in Department that is why these two tables now whenever I write from in some tables it is nothing but we are taking the cross product of or cartisan product of these two tables which is going to give us lot of tles now out of all these tles you have to filter out meaningless tles right so what are meaningless combining this particular employee uh with any Department other than department number five is meaningless for this query isn't it so you have to combine this employee with only department number five so in order to see that it happens after cartisan product you are going to apply this condition so in relation algebra this is the join condition right so what is the condition Department equal to Department ID which means after caran product join only the tles which are having matching these two which which means this one will be matched with this and this one will be matched with this and this one will be matched with this see this department one is one right and this one is matched with this and this one is matched with this and then three is matched with this right which means you are going you have to visualize it as if there is employee data and to the know adjacent to that there is corresponding Department data now how many tles you get is after running this query you are going to get the number of Tes equal to the number of tles which are present in this employee table every employee will have uh you know uh will be joined with the information of the department for which he is working got it and now out of that we need only the entries which have Department name equal to it right so which means uh only two this one so wherever you are having this matching you are going to take this right so if You observe this this one might have been paired up with this entry as well as this entry right so only these two rows will be selected got it and now what will be uh printed the final print print will be employee ID and employee name so corresponding to these two you are going to get employee ID and employee name which means two comma 3 inverse and then the other one is four and somia so two and three inverse and 4 and S will be printed got it see this is the way uh generally your search engine is going to work but if you try to optimize it right you can still optimize it further so depending on how do how can you optimize it is first you filter out this table based on it department and then you join the resulting with this that is one other way of doing it right let's talk about the optimizations later in fact we don't have optimizations in Gate syllabus so okay so let's not discuss about it I mean optimal way is first filter it out make it small and then join with the corresponding table and you get it but then anyway it is not in the syllabus the implementation of the you know dbms so this is the way it is going to get executed in general okay and the next one is retrieve the jobs of all employees now we have to retri the jobs of all employees so where is information present the jobs of all employees is present here isn't it this entire column so it is simply a projection isn't it in case of relational algebra it is simply a projection but coming to SQL a projection is equivalent to select therefore we are going to write select select job from employee table that's it because the entire information is present there you need not write anywhere because we want everything right no no discarding or you know no selection is done that is why we are going to write everything without where now if You observe it the output is going to contain some duplicates as well right the entire uh data whichever you get here will be displayed now if You observe this there are duplicates the main difference between the projection that you have used in relation algebra and the selection you use in SQL is that in projection or in relational algebra everything is a set right everything we talk about is a set a relation or a table is a set of tles right therefore whenever you talk about a set there you don't have duplicates that is why in this formal language relation algebra when I'm using projection there will be no duplicates we discussed about it there anyway so no duplicates will be given but then SQL is not a formal language it is a practical language right and if you are using select both are exactly same but only difference is that select is going to give you duplicates as well if there are going to be any duplicates now why is this feature implemented is even though it is costly see eliminating duplicates is costly you have to find out that there are duplicates and then you have to eliminate it it is extra work right but still even though it is costly why we implement it is okay sorry so eliminating duplicates is costly so we don't implement it right so why we don't implement it is one thing is so why we don't Implement is uh first thing is it is costly and the second thing is sometimes uh user wants to see the entire information he want he don't want the database to eliminate any information for example if you want to count then if you eliminate the duplicates the count is going to be different right or if you want to find the average then some of the values will be missing right therefore in some cases user want to see the uh data completely with duplicates and also eliminating duplicate is a you know a costly operation which is not required unless user is you know uh know specific about it so that is why we are going to have one more Clause distinct when distinct is added to select then whatever output select is going to give from that duplicates will be eliminated for example if I write the same query by using distinct keyword then if I use this keyword this particular you know duplicates will be eliminated and I'll be getting the output without duplicates right so you have to remember that relational algebra projection is equalent to selection only difference is that here no duplicates will be allowed here duplicates will be allowed what it okay now let's say uh we have have a student table and the student table is containing this the information about all the students in the college right but then let us say uh there is a h for EC department or let us say yeah EC department and now if you look at this from his perspective he will not be interested in knowing about the students of all the Departments or or we don't want to give him the information about the students of all the Departments we just want to isolate the data of you know from from the set of all data we just want to isolate the data of the students who belong to ECE and we want to give it to him then how can we do that so from the student table we can create a new table that will contain only the information about the students who are belonging to EC Department right for that reason how to create that table is see this create table student EC means a new table is going to be created with the name student _ EC as now this is this entire thing is a query all right which is going to frame a new table select student name comma student ID from student comma Department which means these two tables are going to be joined now what is the join condition join condition is that department equal to Department ID right so after cartisan product using this condition the row will be filtered and Department name equal to EC now the result of this uh query will be a table containing two attributes student name and student ID right and all the students will be belonging to the EC department now this table will be named as EC student _ store ECE and a new table will be created now you can give that know access to the H only to this table but then there is a problem the problem is once you create such a table let us say from this this table is created okay now from this table if you created we got this now assume that from the original database suddenly one student has been deleted let us say the student has been removed right now from the original table if the student is removed this table will still show that the student is present right so whenever you have you are going to have same data at multiple places there will be this coherence problem right the data which is present here may not match with the data which is present here now in that case creating a new table statically and leaving it there is not a solution now we want a dynamic mechanism by which we should be able to create this table every time our our H wants to see it then only he is going to be updated with whatever has happened there right so for that reason we are going to use something called as view so what is a view is it is a dynamic creation of the content whenever you are going to know need it so it is not like you going to know create it once and store it there without changing it right so view is it is a virtual table based on the result set of a SQL statement which means we are going to get some SQL statement from that you are going to get a table but then it is not going to be saved like that statically every time you want to see it it is going to be executed again and the new new data new table is going to be prepared right now in order to prepare this the syntax is like this create view view name as everything is same the select is used right this entire thing is same now in this case if you want to create a view instead of table you can write create view got it so like this you can create any number of views and you can use uh you know drop view if you don't want to have the view got it now let's see the set operations which are available in SQL they are exactly same as those are available in mathematics operations so we have three such operations here Union intersect and then accept so Union is exactly same as the union operation in mathematics in the set theory and intersect is same as intersection in set theory and except is nothing but the set difference in set theory but then coming to SQL we have two versions so one version of these commands are going to allow the duplicates and the other version is not going to allow the duplicates right right so now if you look at these commands which are union intersect and accept so in this case duplicates uh will not be allowed but then there is a requirement that in some of the situations we might intentionally want to see the duplicates so for that reason if you want to allow the duplicates you are going to use this right so Union all intersect all and accept all right so let's see uh where we need I mean how to use these two commands and what will be the outputs okay with some example here so let us assume that so let's see this table now let us assume that this is the table whose name is enroll and now on this table we are trying to retrieve some information so let's see this query first retrieve the list of student idas who got either grade A or Grade B so which means from this table we want to find out all the students who got either grade A or Grade B so it is a kind of Union right so it is a union between what the set of all students who got grade a union the set of all students who got Grade B so it is actually Union between these two sets right now let's try to find out what is the set of all students who got grade A now if You observe this grade A is here and then grade A is here and again grade A and again grade A and again grade a right therefore you are going to get 1 2 1 2 2 1 2 1 2 2 so this is the set of all student or student idas who got grade A now why am I repeating this two and one these many times is sometimes we might want to display the duplicates and sometimes we don't want to display the duplicates let's see how when we are going to use that and and then what about the set of all students who got Grade B in Grade B If You observe it here there is two here there is two that's it isn't it therefore a student with ID 2 has got Grade B 2 times okay now let us assume that it is a version of the query where we don't want duplicates to be allowed then what we do is we write this query first we select the students from the table where grade equal to a then we are going to get this then we select the students where grade equal to B then we are going to get this now if I directly write Union only Union without writing Union all then we know that duplicates have to be you know should not be allowed so what happens is in this case we are going to get so in this one we are going to get one and two and anywh two is listed here therefore this one will be the output if I write Union right now let us say I'm going to write Union all now what happens in this is I want to display even the duplicates also so everything will be displayed if I write Union all so you can see this the output of Union is going to be this one and the output of Union all is going to be everything including the duplicates right which means all these will be displayed along with this so which means we have going to see 1 2 1 22 and then 22 all right so why do we want to display this uh you know duplicates also is sometimes we want to count the number of instances or number of occurrences exactly then it is going to be useful or you want to find out the average then also you know allowing the duplicates is going to be useful so in that case you are going to allow it now similar to this Union we have even intersect and intersect all queries also so let's see what happens if you want I'll just try to you know change it retrieve the list of student ID who got both grade A and Grade B let's say who got both both grade A and Grade B now what is the meaning of it now we want to see the students who are in the intersection right again there are two versions right in the query if they're asking that find out all the intersection I mean repetition also then you're going to write it in one way if you if they don't want the intersection repetitions then we are going to write it in another way now let us say I'm going to use since it is intersect I don't want to see any repetitions then if I write it this way intersect okay then what is that you are going to get in the intersect if you write it see what is intersection here there is two and here there is two so we don't want any repetitions therefore the output of intercept will be simply 1 which is two got it now let us say I want to write I want to see even the duplicates then I'm going to write intersect all now how will the intersect all behave is find out what is in the intersection and also find out what is the number of you know repetitions of that intersection which means here two is repeated three times and here two is repeated two times now find out the minimum of these two and you are going to write there right therefore intersect all is going to contain intersect all is going to contain see two is repeated two times and two is repeated three times therefore you are going to write two as two times why because two is repeated two times in both of them you cannot write two three times that that imply that three is there two is there three times in both of them by writing this two two times times you are clearly saying that two is there two times here as well as here which is true got it okay and now let us say we want to find out the list of students who got grade A but not Grade B right who got grade A but not Grade B okay now how are you going to do that so here you are going to write accept again the accept is going to have two versions one does not allow the duplicates and other allows the duplicates now we are going to write accept here right now if I write accept what will happen is it will treat as if there are no repetitions here and then you are going to get only one in the output isn't it if I write accept then it is going to treat as if there are no repetitions and it will just do the set difference as it is which means is going to show one two here and two here and the output is going to be one all right now in case if you want to see the duplicates as well then you are going to write except all when you write except all consider this as if there are you know repetitions and then take every occurrence here and you try to strike it off there right which means if for this two you have to strike off one two which means you're going to strike it off and for this two you have to strike off one more two all right now whatever is remaining just write it there so what do you get in accept all and except all you are going to see what is remaining here 1 1 2 therefore you going to see it as 1 1 2 got it so this is the difference between uh you know using all and not using all got it okay now there is something called as arithmetic operators here it is same as the mathematical arithmetic operations which we use so mainly we have plus minus multiplication and division so addition subtraction multiplication and division I'll show you with an example what it means SQL allows the use of athematic operators on queries in queries on numeric domains so only condition you should see is whether the domain that you are trying to apply it apply these arthamatic operators or numeric domain or not the reason is you cannot add or subtract or multiply divide something which is not a number so for that reason the domain of the attribute on which you are going to apply these operators have to be numeric got it now increase the salary of the employee by 10% and display the salary and employee name if that is the that is what we want then we are going to write this query like this select employee name and salary because you know see this we want to display salary and empy employee name that is why I'm writing it as employee name and salary assume that the table is going to contain these two attributes employee name and salary from employee in such a way that we are going to multiply salary the entire attribute so Sal is the name of the attribute salary now Sal into 1.1 so it is nothing but incrementing it by 10% isn't it so for this table if you assume that there is a table with the attributes one is EMP name name right and the other one is salary and we have all the other attributes as well here you are trying to apply uh you know this multiplication on the salary attribute where salary is having a numeric domain which means all the values which are present in the salary are going to be numbers now when you multiply each number with 1.1 it is nothing but incrementing it by 10% got it okay and next one is concatenate operator so concatenate operator generally used whenever we have string data so for string data type the concatenate operator which is represented by two pipes can be used in a query to append two string values for example if you want to combine the first name and last name and if you want to write it as full name right then you can do this select first name assume that first name is an attribute which is present in the table employee f F name and L name is an attribute which is present in the uh table employee now we are going to select first name and last name and we are going to apply concatenate right now when I apply concate both the strings will be joined and you are trying to display it with a name full name got it so by doing this if I have two values let us say there is a table and in this table if I have first name attribute and then then last name attribute and some other attributes are there and say the name of the table is employee right now if you say that there is if you assume that there is a name uh there is a tupple for which the first name is Ravi and in last name is Raa now if I do this concatenation it will combine these two names and it will give you like this so you are going to get a new table with one attribute and the name of the attribute is full name here we are using alas sing right so the name of the attribute is going to be full name we have created a new table with one attribute full name and the values here will be whatever values are there we take them and we concatenate them which means here you are going to get like that got it without any space so it is same as concatenation which is applied which is used in you know Java there we are using dot here you are using two pipes got it okay now let's see the other operator between now if you want to specify a range and if you want to display all the values which are present in that range we are going to use between all right it is a comparison operator on numeric data type right so we are going to use numeric data types as the domain for between now retrieve all the employees whose salary is between 30,000 and 50,000 if you want to display everyone between you know uh ,000 and 30,000 which means the salary range then you are going to write the query like this select star from employee where salary is between 30,000 and 50,000 now it is going to display you all the employee details who are having salary ranging between 30,000 to 50,000 if someone is having salary exactly equal to 30,000 even that will also be selected or if someone is having salary exactly equal to 50,000 that will also be selected now you can also add not so what will not do is exactly whatever you are not going to get here you'll be getting in not which means both are complement to each other if I write not you are not going to get anyone who is having salaries between these two including 30,000 and 50,000 other than that everything you are going to get there what it okay now let's see this uh we have already seen that between is used on the numeric domain it can also be used on text as well as dates the same way that we have applied on you know numeric numbers only thing is you should be able to understand how to compare two strings if you are going to apply it on a text how to compare two strings and then how to compare dates so now let's see an example where we are going to to apply it on the text select star from employee where employee name between A and D so it means that if the employee name is between A and D we have to get the details of all the employee now what does it mean by Between A and D now if you have the names like this so whatever names are going to start with a they all will be considered so all the names starting with a will be considered and they will be displayed and all the names starting with b will will be considered and displayed and all the names starting with C will be considered and displayed and coming to the name starting with d if you have a name which is only D and nothing else that will be displayed but then if you have a name like this da now this one is considered to be greater than D and it will not be displayed getting this so if you have names like this a it will be displayed if you have the name AA it will be displayed and similarly if you have name see having one character as a name is meaningless but just for the sake of understanding I'm telling you what it means and if you have ba it will be displayed let's say b a b it will be displayed b a b will be displayed right and so on let's say there is a name d it will be displayed and if you have a name let's say da it will not be displayed so all the names starting with a starting with b everything will be displayed and also if there is a name which is containing only a single character D that will be displayed and anything else that will not be displayed got it and now you can apply this even as not between right so between is actually inclusive inclusive means whatever boundaries you have given they will be included in the output they will also be considered and included in the output and not between is not inclusive which means the bound will not be appearing in not between right so what does it mean if you say that here let's say uh B and D so let us say it is between b and d and here I have applied not between now what is the meaning of it this one is starting from B B all the names starting with b will not be displayed and all the names starting with C will not be displayed and all the names starting with D only out of those names only names containing exactly D it will not be displayed other than these three everything will be displayed if I'm going to use not are you getting this so between means inclusive we are going to have even the boundary conditions included not between means you are not going to have this other than this you are going to get got it okay and now it can also be used uh you know on dates if the domain his dates it can be used so you can do this select star from employee where hire date between uh 1st January 2010 and 31st December 2010 so it means that you are going to display all the employee details who are hired between 1st January 2010 and 31st January 2010 now all the employees who are hired on the day 1st January will also be displayed and and also on the day 31st December will also be displayed right and everyone in between will also be displayed got it and similarly you can apply not for here and every everyone before this and after that date will be displayed all right okay now let's see order by Clause so when you're are going to when you want to sort the result of an SQ query either based on some attribute in the ascending order or descending order then we are going to use use a by Clause so see this order by is used to order or sort the result of the SQL query in ascending or descending order so if you want to sort it out then we are going to use order by and now the syntax is Select column list column list means attribute list from table list from the table that you are trying to combine order by column one which means you are going you can use the order by for many columns so if I say column 1 column two so on it means that first you give priority for column one and then see whether ascending order or descending order is given if nothing is given go with ascending order right if descending is given spe you know specifically then you have to order the output in such a way that it is in the descending order of this attrib column one right now in case if two values or for two uh rows if this column one is having the same value then you are going to go for the next one all right so as long as all the column one attributes or all the column one you know values for all the tables for all the rows if they are distinct you need not see the second one in case if the two values of this column one if they are equal then you are going to then again form the order based on the second one I'll take an example and explain you how to do this let's see an example here now assume that this is the the table given so given the table R so this is the table given and now the query is here select ABC which means we are supposed to select the attributes ABC all the attributes from table are order by ABC so we are going to order this know by using ABC so if you look at this first thing is top right is given to a and then B and then C and nothing is specified here therefore we are going to use ascending order right so what does it mean first we look at the uh you know try to uh put all the uh rows in the ascending order based on the values of a and if two values are equal in a then we are going to use the B to resolve the conflict and if two values are equal both in A and B and if you are not able to decide the order then we are going to use C to resolve the conflict I'll show you what happens with this okay now see this this query is saying that you are supposed to display a b c okay a BC all of them have to be displayed in such a way that you are going to order them in the ascending order of values of a so if You observe this table here already it is you know in the ascending order of the values of a so first one maybe the one of these two but we don't know which one of these two has to appear first that depends on this one right see if nothing is given then you could as well display this entire table and that would be the answer but if these two are given it means that whenever the values of a using the values of a you are not able to decide the order then you have to use the values of B right and if these two are equal then you have to decide the ordering using the values of c whenever A and B are equal now in this case these two are equal therefore you have to use the value of B in order to decide the order now again if you see the value of B these two are equal so you will not be able to decide which one to print now therefore you are going to use the value of C now of C is saying that c is 3 here and C is 1 here but then here we are saying that c has to be in the ascending order therefore according to this all of these have to be in the ascending order so the best order is this one will be displayed first and then this one got it therefore you are going to see 1 2 1 and 1 2 3 got it and now looking at the next one again see for the values of here you going in the ascending order only right therefore two is right but then these two values are same that is why you have to go with the values of B again the values of B Al these two are same therefore you have to go with the values of c now which one should you go for the least value for C which means this one will be the next one to be displayed therefore 2 1 1 will be displayed next and after that 2 1 3 will be displayed 2 1 3 will be displayed why these two are same therefore we are going according to the values of c here also we are going according to the values of c got it and if you look at the next one 3 and three value of a is same but then the next one is value of B value of B is different therefore using the value of B we are supposed to order it now according to the value of B this one should appear first and then this one therefore we have to write 3 4 3 and then 3 5 4 all it so this is going to be the output of this query now let's look at the next next one select ABC from R order by a in the descending and B and C nothing is specified therefore B and C have to be in the ascending right so let's go in the descending order of a if I go in the descending order of a first values or the first tles which will be displayed is the tles which are containing three and then two and then one now among all the tles which are containing three we have to order them first by using B in the ascending order right so which means we have to start with tles containing three and among the tles containing three for a since these two are same you have to take the next attribute to order by which is B and going for B you have to use the ascending order ascending order means B has to be in the ascending order therefore four will be displayed first and then five so the first one to be displayed is this one got it so 3 43 will be displayed first and then this one so which means 3 5 4 will be displayed and what will be the next one again take the value of a and go in the descending order now the highest value of a has been three it is finished and now the next highest value is two therefore one of these have to come next now which one should come next that depends on the values of a now since the values of a is same you have to go to the values of B now since the values of B is same we cannot decide anything here go with the values of c now again arrange them in the ascending order because C is given in ascending therefore the next one to be displayed will be 211 and then 213 so you are going to get 211 here and then 213 got it and the next one is a value has to be one now among this these two tles these two are same so you cannot decide anything there and again these two are same you cannot decide anything there by using either A or B therefore you have to use the value of C now if I use the value of C the least one is 1 so since C has to be displayed in ass setting order the first one that has to be displayed here is 1 2 1 and the next one that has to be displayed is 1 2 3 got it so this is how this will be displayed now if you look at next one select a BC from R order by a in the descending order B and C in the descending order right which means a has to be the descending order only and then B has to be displayed and then C in the descending a descending B ascending C descending all right so it is exactly same as the previous one but but then C is actually in the descending order right so first let's go with the a in the descending order which means all the tles which are having the highest value of a should be displayed first now these two Tes are having the highest values of a but then both are equal therefore go with the next one so what is the next one B now B has to be in the ascending order ascending order means this one has to appear first and then among these two tles this one has to appear first because it is the least value of B therefore the first one to appear is 3 4 3 right and then the next one to appear will be 354 isn't it not it and then again a is in the descending order which means the next tles that have to appear is these two among these two we have decid the order again now for that reason since a is same we are going for B now B is also same therefore we have to go for C now what does c say C has to be the descending order descending order means highest value first therefore this has to come first and then this so we are going to write it as 213 and then 21 1 got it and the next one is a value the least value of a is here so we have to write these two which one among this has to appear first that depends on the values of a but since the values of a is same now we have to go with the values of B but the values of B is also same therefore you have to go with the values of c now C has to be in the descending order which means the highest value of C has to appear first this one has to appear first and then this one so you are going to get it as 1 2 3 and then 1 21 got it so this is the order in which it is going to be displayed right okay now we have operators like this any or some and all when combined with greater less greater than or equal to less than or equal to right we are going to get uh you know different meanings here so let's see a question here find out first names of all employees whose salary is greater than all employees in department number five now we have to find out all the employees who is earning more salary compared to all the employees in department number five so for that reason first I'm going to find out what are all the salaries you know which these employees of department number five are getting so I'm going into the employee table and then whenever the department number equal to five I'm taking their salaries therefore the in the query here is going to return all the salaries of the employees of department number five let us say all the salaries happen to be maybe 10,000 20,000 and 30,000 right now if I write greater than all find the first names of employees where salary greater than all so if there is an employee whose salary is greater than all these salaries then that particular employees first name will be printed that is what we want isn't it so we want to find out the employees who have salaries greater than all the employees so only when their salary is greater than these three numbers then only we are going to get their first name so by writing this you know outer query this way we'll be able to find out all the employees whose first name I mean first names of all the employees who are having greater salary compared to all this now in place of all if you have written any or some let us say if I wrote any then what would have happened is if there is any salary right and if an employee salary is greater than any of this then it will be printed for example if some employees is having name as a and his and his uh you know salary is 11,000 then since 11,000 is greater than 10,000 a will be printed if there is an employee with salary that 31,000 since 31,000 is greater than 10,000 it will be printed which means in this case all the employees whose salary is greater than this minimum value will definitely be printed that is the meaning of greater than any right and greater than all means you know employees whose salary is greater than the highest salary here will be printed right in case if we had all here and now if there is an employee a uh with let's say uh salary 11,000 he will not be printed got it so greater than all means greater than the highest only will be printed greater than any means greater than the lowest will be printed got it okay and now what is the difference between in and we have already seen in right so if I write like equal to any now equal to any means if an employee salary is exactly equal to one of them it will be printed right or this is also equivalent to equal to sum so wherever you are going to write any you can replace it with sum and you can get the same effect but then equal to any and equal to sum has the same meaning as in right now if you had used only in then also you'll get the same output as you as if you had used equal to any and equal to some let us say the query is find out the first name of all the employees who get this salary equal to any employee you know in department number five salary must be equal to some employee in department number five then what we can find out is all the salaries of employees of department number five and then here you can write equal to any if I write like this it means that if if there is any matching let us say there is an employee B with 10K since this salary is matching up with this salary this particular employee will be printed now the same effect you can get the same effect if you can write salaries in then also you are going to get the same effect therefore this one in is equivalent to this and also equalent to this there is a small difference with this so in case of in we have seen that you can compare more than one values at the same time for example in the previous you know in the previous example only we have seen this I think we we are comparing two values one is the project and the other one is the number of FS we are comparing these two values simultaneously by using in but then if you're going to use equal to sum or equal any here the Restriction is that you cannot compare two values simultaneously at the same time right you can either compare the number of projects or the project number or the number of O but you cannot compare both of them at the same time that is the advantage of in compared to these two got it and now you can combine this any all sum with any of these you know operators equal to or less than greater than greater than or equal less than or equal to you can compare with you can combine with any of these and you can write depending on the need all it okay now there is one more symbol so which is you know having less than and greater than together so this is equalent to this is actually called not equal to all right now if you can also combine this one with any or some if I combine this one with any then it is not it is like not equal to any now if I combine this one with some it is like not equal to some if I combine this one with all it is like not equal to to all right now if I write like this not equal to any this one will be equalent to not equal to sum and this one will be equalent to not in so you can also write not in so not in means if the value is not going to match with any of the values which are present inside this bracket then you are going to get that value in the output similarly you can replace that one with the any of these two provided that you are always talking about comparing a single attribute not more than one attribute this way got it so as long as you are combining comparing only single attribute you can use any of these symbols instead of the symbol what it okay now let's see exist and not exist the SQL exist condition is used in combination with a subquery and is and is considered to be met if the subquery returns at least one row which means we are going to have a subquery in a query and initially we run the subquery and if it subquery is going to return at least one row then we can assume that for that particular row which we are examining in the outer outer query that the condition has been met and we are going to retrieve the information from the tle so I'll just take an example and explain it this way it will be easy for me to explain now retrieve the first names of the employees who have dependents with the same first name comma sex as that of the employee right now see the way we have written the question the query here select let's say here the solution is Select eame from employee e where exist select star from dependent D where e do SSN equal to D do SSN and D dox equal to D dox and D do F name equal to D do dependent name now how to understand this one is if you if you observe it it is a subquery right there is an outer query and there is an inner query and then if You observe this one attribute from the outer query has been used in the inner query therefore it is a correlated subquery now whenever you have correlation between two two queries then you have to take the outer query and see the table it is examining in case if it is only one table just see one table in case if you have more than one table you have to take the join of them and examine it now there is only one table so take that table and for every tle in the table get into the inner query and try to execute it right so here how it translates I'll just write down what are all the uh attributes that we need even though employee table is going to have lot of attributes I just write what are all the attributes important for this query now employee is going to have one is SSN social security number and the other one is f name this is what you want to print and the other one is XX so male or female all right and let's say let's call this table as e now there is one more table so which is dependent table in this dependent table also we are going to have one is essn which is nothing but the SSN of the employee on which a particular dependent is depending on and the other one is sex all right and the other one is dependent name so these are the important uh attributes for this query see there are other attributes as well but I'm not writing all those attributes because for this query they are not important right now how will this uh you know particular query will get executed is now for this particular let's say a table which is used in the outer query it will take each row one by one now for each row in the outer table it will get into the inner table and it will try to see or examine every row here got it now for example there is an employee with SSN 10 and his first name is let us say a and he is a male right now he will now for this particular row we'll get into the inner query and we'll execute that particular query on all the rows of the inner query that is why uh you know this is called as you know nested or correlated correlated means for every outer row we have to execute the query on the inner query on the inner table right okay now what will it test it will try to find out if there is any Row in this table with essn equal to dssn which means it will try to find in all the table if there is any uh you know row with the essn equal this SSN and E do x equal to this one which means if there is a match in this X and then first name is equal dependent name which means if these two are matching or not all right now if this is matching what is the meaning of this let us say for this particular row there is some Row in the dependent table which is having these three matching what does it mean this means that this particular dependent is depending on the employee number 10 who is the that is the employee whom we are examining now and the dependent is also having the same sex as this employee and the dependent is also having the same name as the employee right now we have a matching so now what is that we want we want the first names of all the employees who have dependent who is having the same sex and this right therefore we want the first name of this employee then only we are going to print it so if there is at least one such tle existing here then we are going to print this right therefore exist is going to see that or it will return true whenever the inner query is going to return at least one tle in this case we are able to find out at least one tle therefore we can stop scanning there so we can stop executing the inner query there we don't want to execute inner query completely on the table right so whenever we find any tle we stop there therefore since we got at least one uh you know tle so we are going to stop there and this exist is going to written true to the outer query now since the outer query has got true then this one will be selected now in this one we are going to project only the first name got it therefore a will be printed now after this is done we go to the second row and we do the same thing on this table now after this one is done we go to the third row and we do the same thing now let us say there is an employee 30 with first name B and let us say sex is female right now again if you try to find and see every time when you start search you'll be starting the you will be searching the entire table from the beginning right now let us assume that when you have started search from the beginning you are not able to find any touble in this table with these matching attributes then what does it mean they does not exist any dependent for this employee with the same name and the same sex therefore this exist is going to return false because there does not exist any row isn't it that is why it's is going to return false and whenever you are going to get false you will not print anything therefore you are not going to print the employe name so finally whatever employee names you are going to see in the output you can be sure that for those employees definitely there is an there is a dependent with the same name and the same sex all it okay now look at the next questioner retrieve the first name of the employees who have no dependents now we want to find out the employees who doesn't have any dependents so select F name from employee where not exists select star from dependent where SSN equal e do SSN so let us say so what is done here is now this same table is taken one is employee table and the other one is dependent table right now if You observe this this SSN is an attribute from this table which is used in the outer query again this is a subquery in which an attribute from the outer table is used in the inner table therefore it is a correlated subquery so how does it uh work again for every Row in the outer table we are going into the inner table and search the entire inner table right but then here this search is based on only one parameter SSN is going to match with essn or or not now let's say for this row we are going to search this entire table till we find uh you know anyone with 10 let's say you are able to find someone with 10 then you can stop there and exist will return true for it therefore not exist will return false therefore it will not be printed so what what does it mean if an employee is having a dependent here then we are not going to print his first name got it now let us say there is an employee 30 in such a way that in the entire es SN there is no 30 then what happens here is for this particular row we are going to search this entire table for in the column essn to see if there is any matching between these two which means we'll try to find out if there is any 30 in this if you are not able to find 30 it means that it does not exist right therefore does not exist is going to true in case if it returns true then that particular employee will be printed so which means in this case b will be printed got it so that is how exist and not exist will work so in case of exist if this query is going to return at least one tle then exist will return true in case of not exist if you are not going to get any tle here then only not exist is going to return return true and that particular row will be selected and that particular value will be printed got it now let's see aggregate functions so aggregate functions are you know are functions that take collection which means either a set or a multi set of values as input and written a single value now whenever we say a set it means that duplicates are not there whenever we say multi set it means that duplicates are there right so aggregate function is going to take a collection either a set or multi set and it is going to return a single value right for example what are the various aggregate functions we have is one is average other is minimum maximum total and count now if I use average ABG it is going to give us the average number for example okay uh if you want to find out the average of all ages then you can find it out or if you want to find out the average of salaries you can find it out which means I can write like this select average of salary from employee table if I write like this now let us assume that EMP is a table which is having an attribute salary now if I write like AVG it is going to give me what is the average of all the salaries of the employees right and if you look at this average this has to be applied only on one attribute right and similarly if you apply in place of average then if I apply Min then it is going to give me what is the minimum minimum salary of the employees now if I apply Max in place of average then I'm going to get what is the maximum salary of an employee now if I apply sum then it is going to sum all the salaries from the employee table and give me one sum now if I apply count it is going to give me how many salaries are there right I I'm going to get entire thing now if you see this average and sum these have to be strictly applied on attributes which have the domain as numbers so you can find out the average of numbers and sum of numbers otherwise applying average on names or sum of names or anything which is not numeric is meaningless and coming to this minimum and maximum you can apply even for non- numeric data as well and count also you can apply for non-numeric data now all these functions average minimum maximum and sum these uh four functions they can they have to be applied only on one attribute which means you cannot write more than one attribute there but coming to count you can write any attributes there right you can put the entire table also okay fine now one more thing is with these uh you know all these aggregate functions you can add keyword distinct now if I add distinct here it means that eliminate the duplicates and on the resulting set you are supposed to find out the result if I say select distinct select average of distinct salary if I put it like this right select average distinct salary if I put it like that then from the salary we are going to find all the distinct salaries and from that we are going to find out the average right now in case if you try to find out the select average distinct salary you know select some distinct salary we are going to eliminate all the duplicates then we are going to find the sum all right and if you try to apply distinct for minimum or maximum anyway the result is not going to be changed so if the minimum is there even if it is repeated many times even if you eliminate all the repetitions and if you keep only one copy then also minimum is going to be constant same thing is true for maximum right so in in case if you want to eliminate the duplicates then you use distinct otherwise you just write it this way okay fine so see we cannot add uh or we cannot put two attributes together inside this average or inside any of this but then in case if you are going to use some you know mathematical operations arithmetic operations you can put it there so what I mean to say is let us say there is a table in which you have Marks One and marks 2 or marks in subject a and marks in subject B now if you want to find out the average of these two I mean you know what you want to sum up all the marks total marks and then find the average of it you could write it this way now if I write average of marks in subject a plus marks in subject B this type is allowed even though you are do you know you are giving two attributes to average it is not actually Marx a comma Marx B what you are giving here is Marx a plus Marx B so this type of uh you know two attributes can be specified here but you cannot put comma all it so whenever I say that only one attribute has to be given here it means that uh you know you cannot give commas and you cannot give more than one attribute that way here it is allowed okay and one more thing is in the wear clause also when you're are putting wear Clause so in the select you have we right so you cannot specify these aggregate functions in the wear Clause so you cannot write like from table where let's say sum of some attribut Beauties so this is not allowed so you are not allowed to put aggregate functions within we Clause so these two points are also important okay now let's see how null values will behave with aggregate functions so all aggregate functions accept count star ignores null values in their input collection so it means that whenever you're are going to come across a null value we simply ignore it we are not going to treat it as zero or we are not going to treat it as null we are simply acting you know we act as if it doesn't exist right so we just ignore it and the count of an empty collection is defined to be zero so I I'll tell you with an example what it means and all other aggregate operations written a value of null when applied on an empty set so let's see some examples on here let us say this is the table on which we have to apply aggregate functions A and B are two attributes in the table and a is one null I mean first tble is one null 2 null null null and three null so with these four Tes what happens if I write various you know aggregate functions now if I try to write count star then it is going to count everything the number of Tes which are present in this and it is going to return that number even if uh you know the rows are completely the one row is completely null even if in this you know even in this case also count is going to count it as a separate tle and so you are going to see the count as four so this happens only in count star okay now let's see what happens in count a in count a when you are trying to count only the attributes of a then it is going to count ignoring the null values which means 1 2 3 will be counted as three and null will be ignored right and now count B if I try to count B then whenever I'm trying to count the number of values available here all the nulls will be ignored which means it will completely treat it as if it is empty set and whenever you're going to apply this on empty set then you are going to Define know give zero that is the meaning of this point the count of an empty collection is defined to be zero meaning of it is whenever you have all the uh you know values as null all of them will be ignored right so when when you ignore all of them it is going to become an empty set and now since you are applying count on empty set it is going to return zero so one important Point here is see the difference between count star and count B in case of star even though the values are null we are not going going to ignore it but in in case if you don't have star and if you are applying it on an attribute you are going to ignore all the values of null all right and same thing happens with sum average Min and Max so whenever you're doing sum average Min and Max we ignore the value of null and for the remaining values we actually compute everything right for example example here if I want to find out sum on a which means I want to find out sum of all these elements present in attribute a I'm going to consider 1 2 ignore null and consider three therefore sum is going to be six now if I want to find out average on a then it is also going to ignore null if I ignore null the sum is going to be six now average is nothing but sum divided by number isn't it now while counting the number also this one will be consider this one will be ignored and so you are going to write it as three and so the average is two getting this so some will be done ignoring null and also count will be done ignoring null and then uh some by that count is going to give you the average and the next one is Max of a while Computing the max of a we are not going to assume any value for null we simply ignore it and in the remaining values we are going to find maximum 1 2 3 maximum is three that is why here we are going to get three and while Computing minimum also same thing happens so 1 2 3 minimum is one so we are going to write it now if we are not going to consider this one as zero null as zero so that is why we are going to get minimum as one and coming to this uh other one since we have all nulls in attribute B if I try to find out sum now if you see sum how it behaves is all the nulls will be ignored sum on B since all the nulls are ignored there will be nothing remaining and so we can consider it as if sum is applied on the empty set so whenever you're applying sum on the empty set then the result is going to be null right whatever aggregate function you apply on mty set then the result is going to be null right see this except count all the other aggregate functions written a value of null this is the point of this this meaning of that point got it so whenever it is count we are going to get zero on empty set and for all the other aggregate operations we we are going to get a null on empty set now since it is an empty set because all nulls are ignored now if I try to find out some I'm going to get null similarly if I try to find out average again all the nulls will be ignored and I'm going to get null and if I try to find Max also all these nulls will be ignored empty set and since you are applying Max on empty set it is null and even Min also the same way all the nulls will B node again we get an empty set and so we are going to get null as the output all it okay now let's see this question for each department that has more than five employees retrieve the department name and the number of employees who are having more than 40,000 and the number of its employees who are having more than 40,000 who are making more than 40,000 so what they are trying to say is uh find out all the Departments who are having at least five employees or greater than five employees and in those departments you are supposed to find out how many employees are having salary more than 40,000 so now this is the way we have written it there are many ways we can write this qu know query but then since we are talking about uh uh you know having I'm writing it using this so what is this select Department name d name comma count star from Department comma employee where department number equal to D number and salary greater than 40,000 and D number in select department number from employee Group by D number department number having count greater than five and group by D name now if You observe this there are two queries here so outer query and inner query so there is a subquery now in the subquery If You observe it we are not using any variable from outside in the inner query therefore it is uh non-correlated subquery in this case we can execute this inner query first and get the output put the output there and then execute the outer query which means it is going to be executed only once and auto query is going to be executed after that right so let's try to execute this one and let's understand what we are trying to do by this now select department number from employee which means we are using employee table in that employee table we are grouping by Group by department number so what happens by this is all the employees who belong to the same department will be grouped together so we are going to get the groups based on the department number and then we are applying having count star greater than five so using this criteria we are going to filter out the groups for for which count which means number of employees is less than or equal to five which means if it is greater than five then only we are going to show otherwise they will be filtered out so finally by writing like this I'll be getting the department numbers of the departments in which employees are greater than five so all the all the Departments which you know which are having at least six we are going to get here right so that is what we want each department that has has more than five employees so that is why we are finding the Departments which are having more than five employees so this entire query could have been now we could replace it is it has just the list of departments which are having uh you know uh employees greater than five so let us say we got these departments 2 3 4 5 after doing this let us assume that these are the Departments which we got uh for which the number of employees are greater than five okay now after doing this now let's execute the outer query in the outer query what we are trying to do is Select Department name comma count star from tables one is department and other is employee so whenever you write from Department comma employee these two tables it means that we are actually taking a join of these two and the join condition is D number equal to D number which means department number from the Department table is equal to department number from the employee table so what we are doing in effect is we are combining every employee with the information of the you know department for in which he is working so every employee will be paired up with the with his Department right so why are we doing this because we want the department name department number is there in the employee table but Department name is there in the department table for that reason we are going to combine these two now once I combine these two every employee will be joined with the corresponding department and from that we can get the Department Department name as well right so that is the reason I'm combining them using this join condition so what is the join condition department number here is equal to department number in the employee and salary should be greater than 40,000 so after combining these two I'll be picking out only the employees who are having salary greater than 40,000 otherwise everything will be filtered out so here I'm applying the filter in such a way that only employees who who are having greater than 40,000 is going to be picked out now after this again one more filtering is applied and department number in which means the department number whichever the you know employee is working in should belong to the Departments which are having greater than five employees so what does it mean the employee is supposed to have greater than 40,000 salary and the employee should be working for a department which is having at least five employees so these are the two conditions which we wanted to see isn't it so we got those two now after the result we are going to get a table in which all the employees are having greater than 40,000 salary and all of them are working either for two or three or four or five that is the information we are going to get right now in that information we are finally going to apply Group by now how are you grouping it by Department name so whatever you are going to get you are going to group by Department name and after you know grouping them by Department name we are applying counts store right so what does it mean so for every Group which means for all the employees belonging to the same Department we'll find out the number of employees who are present in that final result and we are going to display that so Department name comma the count so what we what do you get finally for each department how many employees are there who are earning more than 40,000 rupees provided that the department is having greater than five employees all right so that is that is how this query will get executed okay now let's see Group by Clause if you use Group by Clause we'll get extra you know flexibility in displaying the data like this so I'll just take an example and explain you what this group by is going to do exactly find the average salary in each department so now we want to find out the average salary in each department earlier we have seen the examples where we are finding out the average salary of the know all the employees which means we have tried to you know find out the aggregate function on the entire table now by using Group by we'll get one more extra feature where we can even use the aggregate functions on groups so for example here if you see this select department number comma average of salary from employee Group by department number so by writing like this what happens is in the employee table the entire tles they are going to be grouped by based on the department number and for each group we'll be finding out the average salary and then we are going to display only one record for every Group which is showing what is the department number and what is the average salary for the department so if you want to see an example just see the example here now assume that we are having the employee Table and there are there is SSN is there which means social security number and then the department number in which a particular uh uh you know employees working and then the salary is given there now let's say they are like this department number one department number one department number two department number three and the employees are like 10 employee is 10 20 30 and let's say salary here is 100 200 300 and let's say there is one more employee 40 50 60 who are working in the Departments 1 2 3 and say this have iies are like 400 and let's say 500 and 600 okay now if I apply the group by see what I want is I'm not interested in finding out the average of the entire salaries I just want to find out what is the average of the salaries earned by the employees of each department for that reason if You observe this group by this group by is going to collect the information of all the tles which are having the same Department right so Group by department number means whoever are having the same department number they will be collected so these two will be put together and then these two will be put together and then these two will be put together right now after that for each group let's say these two are now in one group right now for each group it will try to find out the average so 100 + 500 ID 400 divid 2 which is 250 now it is going to display for each group what is it department number department number is is 1 and what is the average salary average salary is 250 here got it and similarly for this group so which is containing you know all the employees of department number two 200 + 500 which is 700 700 means 350 so department number two is having an average of 350 now if You observe this we are able to compute the average separately right we are not Computing the average on the entire table right similarly department number three will be having 450 got it so this is how Group by is going to be useful now one important point that you should be remembering about group by is if there are any attributes see you can you can also give more than one attribute there in this example I have given only one attribute which is department number but in general you can give more than one attribute right then how will the group by be done is if those two attributes are having the same values in many Tes all those tles will be be grouped together right let's say you are giving three attributes then for all these three attributes if any Tes are having the same values all those Tes will be grouped together but it okay after grouping we are going to find I know apply this aggregate function now whatever attributes you are going to specify here they all have to be present here and if there is any attribute which is not present in the group by and if you're trying to display it in select then you are supposed to put it only you know in association with this aggregate function so you are not supposed to have any other attribute which is not present in group by in select unless it is going to appear along with the aggregate functions this is very important point and this is what the standard SQL says SQL standard says this and even all the standard textbooks are also having the same thing but even if you don't follow these rules some of the Practical database implementations like MySQL and SQL server and Oracle all these are going to show you the results and they'll not give you any errors even if you don't follow this rule like if you're going to have some attributes which are not present in group by you can have them but then some of them are going to throw error and some of them are not going to throw the error but anyway coming to gate we should always follow the SQL standard and also the standard textbooks so I'm following only those and I'm teaching you whatever is present there but it doesn't mean that you know you will not be get you'll not use it or you should not use it in Practical databases right when they have implemented it you can use them but then it doesn't mean that that is the right right answer right so coming to get follow this okay and next one is all see this point is whatever I I I told you here it is written here all attributes used in the group by class need to appear in the select class so whatever you have written here they should be present here any attribute that is not present in the group by class must appear only inside the aggregate function in the select class so if you going to have any attribute which is not present here for example salary that should always be present in the aggregate function all right okay and along with Group by we are going to have one more Club having so if you see the order in which we generally you know execute the SQL query if you have something like select select Clause is there and then from Clause is there and then where Clause is there then there is going to be group by right so whatever is present whatever tables are present in from you are going to join all of them and then you are going to filter the rows by using the condition which is specified in the where so in where you are going to specify many conditions which are going to filter the rows which we get from the joining tables from the from club right but then after forming the groups if you want to still discard some of the informations about the group which means if you want to filter the groups then this we is not going to be useful right for that reason we are going to use one more clause which is going to be having now SQL standard says that having has to be used only in conjunction with group group by so if you don't have group by you are not supposed to use having but again the Practical implementations they may differ but then we are not interested in looking at the Practical implementations forget only this SQL standards are important so according to the SQL standards you whenever you have group by then only you are supposed to have having now what is the main advantage of group by is sorry having is by the time you reach Group by and you get the groups if you want to filter out the groups where will be useless because where would have been already used up when when to you know when we want to filter the uh rows now if you want to filter the groups then you are supposed to use having got it so I'll just take an example and explain you what it means list the department numbers with average salary greater than 20,000 so we want to find out the department numbers you know where the average salary of the department is greater than 20,000 so for that reason we are going to uh select department number from employee table and we are going to group it based on the department number so that all the employees who are belonging to the same department will fall at one place now for that entire group group of all employees who are belong to the same Department we are going to uh you know uh find out average salary and only if average salary is greater than 20,000 such groups will be allowed to stay and the remaining will be filtered out right therefore for filtering the groups we are going to use having and in case if you want to put where where will be before it and where will be executed before it that is why where will be useless there right and after filtering it out one entry from the group will be displayed right which means one department number for the entire group will be displayed even though you are going to have many Department numbers and all the department numbers are going to be same for a group it is not that we are going to display this Department numbers those many times we'll display just the department number once so whatever result you get as an output of this quer is nothing but the Departments for which you know average salary is greater than 20,000 okay if you want to even see what their average salary is you could also add one more uh you know uh one more small aggregate function saying that select department number comma average of salary you can also add that to see what is the average of each department given that the Department's average is already greater than 20,000 right okay and now what is the important point about this is SQL query can contain a having only if it has Group by class this is what the standard says okay fine now in programming while writing a fun while writing programs we are using something called as functions right so in C program also if you see we are using functions many times right scanner F print F all those things now why do we use that function is whenever we are going to use a piece of code many times then it is obviously better if you can give it a small name and you know don't write the entire code again and again just use that name name of the function and your compiler is going to call that function or execute that code wherever it is required similar to that the same functionality is provided in SQL by using you know the width Clause so what does with Clause say is if you're are going to use a subquery over and again in the same query again and again now instead of repeating it many times and making the query very big what you can do is you can name the subquery or a query with a small name and wherever you want to write that query you can simply use that name it is exactly same as calling a function in C programming language I'll just explain you with examples here now the theory about it is is the SQL withd Clause allows you to give a subquery block a name so we are going to give a subquery block a name right a process also called as subquery refactoring so giving a name to a subquery is also called as refactoring okay which can be referred in several places within the main SQL query so what does it save us from we need not type it again and again see when you're are typing this same thing again and again there is a chance that you might type it in a wrong way and also the query will become very big and the readability is going to decrease now instead of that if you rename a subquery and if you use that name again and again it will be simple right and now the name assigned to the subquery is treated as though it was a view or a table so if you remember how we created viewr table it is actually the same isn't it so we write a query I mean we can use using a query we can create a table or a view so what I mean to say is just write an SQL query and whatever output you get that output you can save it as a table in the database but that is going to be permanently saved but here we just want the subquery to exist only while executing the query after that it need not exit there right exist there therefore we are going to use this subquery naming it is basically a dropin replacement to the normal subquery so wherever whenever you rename a subquery with something and later when you use that name in the query what you are trying to do is what your you know processor try to do is SQL processor it will just replace that name with the query that is why it is called it is basically a drop in replacement now let's see an example even though here you will not be able to see the advantage of using width it will just help you understand how to write the width clause now let us say there is a query like this select EMP ID from employee now you can rename this entire query with some other name and you can use that name wherever you want to use this query in main query right for example see this with followed by the name that you want to give to this query as now write the entire query all right so we are writing the entire query and the name we are going to giving to that query is employee tab right therefore wherever you see employee tab name now your processor will replace it with the subquery so if your query is very big then uh you know you need not write this many times in your query just use the same thing wherever it is required the same name employee table right now since we don't we don't have very big query here I'm directly writing it this way right select star from employee table now what will happen is Select star from this entire part will be replaced by this query right so in this example you'll not be able to see the advantage but assume that this particular query is very big this query is very big and in many places if you are using employee tab then in that case it will be useful for you if you have let us say uh this subquery being used in the main query let us say 10 times now in all those 10 times you are going to use just the name employee there you can see the advantage okay and now we can use the width class many times so it it need not be like this which means you need not always rename only one query uh with a name you need not give only one query a name and use it you can have many queries with you can rename many queries with many names and you can use all those names without using those queries and just I'll I'll tell you how to use it here now if You observe it we are going to name Department table this entire query so this entire query if you see this from here to here now this entire query is named as Department temp right and now it is going to be used in the main query see this now again you are going to use it here right and now again this entire part this entire query from here to here is again named as employee name which means with is used to name two queries with two names and these two names can be used any number of times in your main query right if You observe this again employee name is used here right so whenever it is being processed what will happen is wherever you see the name of it right this entire thing will be replaced simply with the query right and again this entire thing will be replaced with the query got it okay we shall see one more example on it you'll understand it now let's see this joints concept it is exactly the same that we have seen in relational algebra I'll just show you what what happens here but even though the concept is same I'm just showing you it again now first one is n normal join normal join is uh you know you are going to specify a condition on which we are going to join two tables for example if you write like this select start from or join as let us say this is table R and this is table s if I write R join s on Capital AAL to Capital C it means that we are going to join these two tables on the attributes A and C whenever A and C are equal we are going to combine those tles for example here what you get is the output of this one is going to be a b c d right so in the normal join we are going to see all the the attributes which are present in both the tables now whenever there is a matching that particular tle will be completely displayed so which means see this one and one they are matching that is why 1 a 1 G will be combined in one tle they are going to appear like this all it and two and two are matching that is why 2 b 2 H will be seen in the output 2 b 2 H and 3 C 3 I will be seen 3 c 3 I right so likewise you are going to write all of them okay so let me finish it up 4 d that's it so four is not actually matching with the anything there so we are going to get only these three when I apply you know join so this is normal join with condition and the next one is natural joint so natural joint is same as normal joint only difference is we are not going to specify any condition like this earlier we are specifying the condition like that if I don't specify any condition then it is going to be natural join but if I don't give any condition then how will it know which one to use I mean what are the attributes to match for that reason we are going to apply natural joint only under the uh condition that two attributes are same or they have the same name in the tables right so which means this one also should have been a otherwise what we do is we temporarily rename it as a and then we apply the natural joint got it now in that case what happens is since a is already there in both the tables we are going to get only one time you know a so the output is going to look like this a b d and whenever these two A's are having the matching you know values that particular result will be displayed which means 1 a will be there 2 BH will be there 3 CI will be there nothing else that's it all right so this is about the natural joint and next one is left outer joint so whenever you write left outer joint right outter joint fill outter joint these are exactly the same that we have seen in relational algebra so in left out join what we do is we try to join two tables and then whatever is not there in the left side we are going to add it in the left side table so let me show you with this example in this example this is the left side table and this is right side table if I'm going to write RNs like this now in this case this is after joining what we do is I'll test what are the tles which are already included in this output so these three tles are already included isn't it now what are the tles which are not included these three are not included so for these three tles I'm going to write there with null on the remaining attributes which means if I write left out a join all the all the tles in the left table should be present in the table that is the meaning of it since 4 is not present 4 d I'm going to put 4 d 5 is not present I'm going to put it 6f is not 6f is not present I'm going to put it now what should be these attributes since there is no matching just put nulls there so we are going to have null null null null null null this is left outter join now in the same way we can do right outter join as well so what does right outter join mean is instead of adding the tles from the left side table we are going to add the tles from the right side table whichever were not already added now these three tles have already been included in the table therefore now we are going to add these three in this place and in this place we are going to get null that is nothing but the right outter joint Now what is pull out a join is we are going to see that all the tles in both of them are going to be present somewhere now if You observe this after applying the join this part is missing so that part will be written there and this part is missing so that part will also be written there so which means you going to see in full out a join null null 7 J similarly null null 8 K similarly null null 9 L you going to see all that got it so this is all about the outer join now if you apply natural left outer join natural right out join we are going to get this only when we have two attributes with the same name see when you are going to use this here we need not have the attributes with the same name we can specify the condition here right now when you're talking about the natural joints it means that we are going to have the tables with the matching attributes then only we are going to do this and entire concept is going to be same so what does it mean in natural left outer joint we are going to do natural outer joint first and then we are going to add all the tles from the left table which were not present in the result right with null in the corresponding attributes of the right side table and what about this we are going to do natural outer joint first and in the result if any tles are missing from the right side table we are going to add all those Tes with null in the corresponding attributes of the left side table right and full outter join also we are going to do the same thing so what does it mean we are going to do natural outter join and then we are going to add all the tles from the left side as well as the right side and if there are no matching attributes from the other table we are going to fill it as null got it okay now let's see uh the topic of transactions so what is the transaction is a transaction is a collection of operations that perform a single logical us unit of work so let's look at a transaction from the perspective of a bank database server now if you're looking at the operations or The Logical work that a bank database will get generally there are various things like this assume that this is the bank database server okay and it is going to get a lot of requests asking to perform some operation now if you take any operation you can think of it as if it is a transaction because it is a single logical unit of work now let us say there is a transaction T1 let's call it as T1 which is requesting the bank to transfer account from some account a to account B right now we are trying to transfer some money from account a to account B then what is that we are typically supposed to do is take the account a and subtract it from the and subtract that amount from account a and take account B and add it to B and write it there so what I mean to say is let us assume that account a is having $100 or 100 rupees as a balance and account B is having let us say 200 rupees as a balance now if I want to transfer 50 rupees from A to B if I want to transfer this 50 then after the transfer how much money will a have and how much money will B have is a is going to get decremented by 50 rupees which means you are supposed to have 50 here and what is B going to have B is going to have 50 rupees extra got it this is what is supposed to happen by doing this logical piece of work even though it is a single logical piece of work you might have to do it in various steps now what are the various steps involved in this is first thing is you might have to read the data from the database right now A's data and B's data all this data will be present in the database first you are supposed to read the data from the database Okay so read the account balance of a right now by doing this what we get is we can see that the amount of the balance of a is 100 okay and after that you are supposed to decrement a by 50 because 50 rupees is what you are trying to transfer right and after doing this you might write the balance of a back so what did we do we have decremented the value of a and we have written it there now we should not stop here what should we do after you know deleting or decreasing the amount you have to increase the amount in the B side right so that is the reason you have to read the account balance of B and then add 50 rupees to B right so why am I reading because I don't know what it balance is then only if I once I know the balance and I can you know increment it or decrement it and then write it back now by doing all the six operations 1 2 3 4 5 6 I'll be able to perform one single logical unit of work all right so all the six are required now let us say you have transactions and all the transactions are coming to you and all of them are queued up which means transaction T1 is there transaction T2 is there transaction 3 many transactions are there and transactions are there and if a process is going to execute if one process is going to execute each transaction uh then what happens is if you look at the transaction from the process perspective it is going to have two parts here one part is certain operations require I operations to be done and certain operations require many you know CPU to be done for example this operation requires I operations to be done and this operation requires CPU to compute it isn't it and this operation again requires IO why because I have to read or write the data from the disk so which is going to be given to the disk and you might have to wait so which means CPU will typically be idle when the process is executing these two statements right and when the process is executing this statement CPU will get some work and here also IO and here also CPU work and here again IO so coming to databases most of the work present in any transaction will actually be access Us in the database which means IO related work will be more compared to the CPU work right and now if you try to execute the transactions one after the other then CPU is going to be idle for most of the time right then how can I increase efficiency of the CPUs you can think of it from the perspective of a process right in the process management system also we have seen that in operating system when we are trying to manage many process if you have to increase the uh efficiency of a CPU you should keep it busy as long as possible right which means when whenever one transaction is performing the io you should be able to give the CPU to other process so that it will be doing you know uh it will be Computing some work so what I mean to say is now if You observe it transaction T1 looks like this for some time for some time it is going to do only IO and then again it is going to do some CPU right work on CPU and again it is going to do only IO and again it is going to do some CPU right so this is how transaction T1 is working now let us say there is other transaction T2 which is able to uh which is which has got some computation work so then whenever your T1 is busy with IO then you could schedule some other transaction T2 T2 let us say if it needs CPU here and whenever T1 again needs a CPU you just switch it right so this is called as switching so giving the CPU to T1 for some time which means giving the CPU to the process which is running T1 and then taking it back to T2 like this so to T1 for some time and again for for T2 for some time and again for T1 this is called as switching all right so we can do this kind of switching in order to let us say this is going to be ideal whenever it is going to be given to T1 and again when you know T2 T1 wants to do IO then you can give it for CPU all right so whenever you do s such kind of switching you should be very careful because there can be various problems because of the concurrent execution of the process so we have seen in synchronization techniques that when more than one process executes and if between these two process if there is some common data if they are going to access something in common then there might be concurrency issues right so here also it is most common that when you're are talking dealing with databases many of the transactions will have some common data to be working on right so then you might get some problem right so what are the problems you might get is I'll just give you an example let us say one transaction T1 is trying to transfer some money from A to B which means this one only so which is going to read a and then which is going to to decrement a by 50 right and let us assume that while this process is reading the data there is other process or other transaction which has started and which is actually trying to withdraw the money from a now at this point assume that because of some reason you have you know preempted the transaction T1 and you have started the transaction T2 now at this point if T2 tries to read the value of a right then what it will see is if the initial value of a assume that the initial value of a at this point is let's say 100 rupees now T1 is going to see that a is 100 rupees and T2 is also going to see that a is 100 rupees right now let us say here you are withdrawing the money let's say 25 rupees you are going to withdraw a minus 25 all right so here you are transferring 50 rupees from a and here you are trying to withdraw 25 rupes from a then how much should be the balance 25 rupes should be Balan after T1 and T2 finishes their execution but now since you have preempted T1 and started T2 in between now what happens is if you write the value of a here and then write the value of a here right so this one is going to write the balance of a as 50 because according to this transaction a value is now 50 and this one is going to write the know value of a 75 all right therefore the final value of a here is going to be 75 after both these transactions actually the amount has to be 25 but now the amount is wrongly shown as 75 right so if You observe this here on the other side even though you are going to read B and then increment B and then write B it is not going to change the value of a so anyway A's value is going to be fixed at 75 only right so whenever you are going to interl the transactions there is a problem that you might get inconsistency right what is inconsistency there is it is not correct isn't it so such problems are going to arise whenever you try to increase the efficiency of the CPU by intering the transactions now in order to manage all this we need transaction management system now what is the main responsibility of transaction management system is whenever you trying to inter leave it it should give us the same effect you know see what happens if you you know if there is no inter living you would have executed completely T1 and then completely T2 and then let us say if you have three or if you have two transactions you would have executed completely T1 and completely T2 in this case you will get a correct answer 25 or you would have executed completely T2 and then started T1 right then you are going to get a correct balance of 25 now because of this inter leing only you are getting a incorrect answer right therefore if you execute the transactions one after the other in a Serial manner then you are going to get the correct answer but the efficiency of CPU is going to be hurt and since you are going to get millions of transactions as a request to the database system if you do it in this way your system is going to be very slow right which means the response rate is very slow so you are not going to do this now you have to you have to have a system which is going to increase the efficiency of the CPU and at the same time it should see that the transactions are executing correctly even with inter leing right for that reason we need the transaction management system right which is going to do this concurrency control exactly the same way we did in operating systems but we have to be much more careful compared to operating systems right because here most of the transactions are having some common now the transaction manag system the software which is responsible for managing the transactions should see that whatever way it executes the transaction either by inter leing or in a Serial way whatever way it does it all the transactions individually if you look at them they are supposed to follow this properties right so only when they follow these properties the database will be consistent now see this so we are taking we are talking about transaction taking you know each one one by one now when you look at a transaction then it should follow atomicity so what is atomicity is if you're going to have a transaction as a collection of operations like this let us say in the earlier case we have seen an example where we had six lines of operation in a transaction right now if you're going to see this transaction as six lines then either all the six lines have to be executed or in case let us say because of some error or because of the know power failure or some error let us assume that at the middle the transaction has been stopped now if you are going to stop the transaction at the middle you should be able to roll it back roll it back means undo all whatever you have done there so either do it completely or don't do it at all so all or null all or none so this property has to be satisfied by every transaction which means either you do it completely or don't leave it in the middle see what happens if you leave it in the middle if you try to you know transfer money from A to B and let us say you have decremented the amount from a and before transferring the amount to B you stopped it then you know unnecessarily the money will be drawn from a but it will not go to B so therefore it is a problem isn't it so you should see that every transaction is done either completely or none of it is done at all and the next one is consistency consistency means the correctness so after doing this you know okay who is responsible to do this you know to look look at this is the transaction manager itself the transaction manager is supposed to see that either you are going to do you know uh do it completely or you are not going to do it at all so transaction manager means the software which is responsible for it is called as transaction manager and the next one is consistency so consistency means after executing the transactions or let's say we are looking at one transaction the data should be consistent right so what is consistent see let us say in the previous case if you're transferring an amount from A to B now before transferring it let us assume that the balance of a plus b is some number after transferring it the balance of a plus the balance of B should be same isn't it so let us say a is having initially 100 rupees and B is having initially 200 rupees now if you add them both it is 300 rupes in total now after transferring 50 rupees a is going to be 50 and B is going to be 250 isn't it now here here it is 300 before you started after you do it also the total has to be 300 so that kind of consistency should be there now who should be uh responsible for this consistency the one who is going to write the transactions right which means the user or application programmer who is actually writing it has to see that you know this is being done and the next one is isolation isolation means even though we are executing many transactions together there the overall effect should be as if a transaction has been executed in a isolation in isolation means a transaction should not have any effect on it because of the other transactions executing that is called as isolation right each transaction TX must be executed without knowing what is happening with other transactions now who will be responsible for this one is a software module called as concurrency control manager so what is concurrency control manager is it is going to control the concurrent execution of various transactions in such a way that you'll get the same effect even if you run a transaction alone which means without any inter leing right and the next one is durability so durabil means uh let us say you have we have made some you know uh changes to some database element and then after doing it you are supposed to save it somewhere and if you save it in the hard disk then it is going to be there forever right now let us assume that before saving it to the hard disk something happens then even after you know let us say the power failure or you know because of some error you have stopped the transaction now again when the power systems are up you should be able to maintain that information right so whatever changes you made and whatever you want to be permanently available that should be permanently available in case if they are not permanently available then it is going to be a problem right so durability says that whatever modifications you do should be permanently present in the database right if you want it to be all the updates done by a transaction must become permanent right so who is going to do this the recovery manager is going to do this now let's see what are all the problems we might get uh while executing transactions in a concurrent manner so by classifying all the problems into various classes we can see that whatever method you come up with he is going to solve all these problems okay so the first problem is lost update problem or right right conflict in operating system also you might have seen something called as risk condition in a risk condition let us say if a value of variable is five and if there are two processes P1 and P2 if process a is going to increment it and process a is going to decrement it and if you are going to see these operations in the interl fashion there also it is going to do something like this one is it is going to read the value of a and then increment the value of a right and then write the value of a now let us say here there is a preemption because of which it is going to read the value of a which means before writing the value of a it is going to read the value of a right see here the value of a will be five and when I increment it is going to to be six but it has not yet written the value back right now what will this one see it will also see the same value five actually should it is supposed to see six but then it will see five only because update is not done there right now if it tries to write here let us say it is decrementing a right and if it is going to write a then what happens is if this one performs right then a will be written as six and then after this decrement is done on the local copy which means on this file so this one will be decremented and here the value of a will be four and now if the right is done six will be replaced with four all right so if I increment it and decrement it actually the value should remain same but then because of this problem right we are going to get inconsistent value so this problem in operating system we call it as race condition now the same way we can look at the problem here it is you know given a different name it is called as lost update problem so lost update problem is whatever you did see here also whatever updation you did here that is lost one of the updation is completely lost the updation of incrementation is completely lost now what is reflecting there is only decrement right therefore one of the updates is lost here also the same thing will happen look at this now there are two transactions now one traction one transaction is trying to decrement the value of a by 50 which mean is actually transferring money from A to B by 50 and the other transaction is trying to increment the value of a by 4% now let us say while executing this transaction there is some preemption here right now at this point if the second transaction has started now see this the local copy of a will contain 50 and at this point the value of a is going to be let us say initial value of a is 100 let us say initial value of a is 100 now the local copy of a at this point is going to be 50 but then it is not at written therefore this update will be in the local temporary let us say memory it is not yet propagated to the hard disk now when you're reading the data you'll again read from the hard this now this one is going to see that the value of a is 100 here and whenever you have incremented the value of a by 4% all right then it is going to be4 at this point right not 4 only right yeah 4% is uh 0.04 all right okay so it is going to be 104 and now based on who is going to see the local copy in this transaction is containing 104 and the local copy in this transaction is containing 50 now based on who is going to write it at the end the value of a will depend on that right for example if this one is going to write the value now let us say what is happened here is this one is writing the value first and then this one is writing the value now even though it is going to make the you know the actual copy in the hard disk as 50 later this one is going to overwrite on that and it is going to replace this 50 with 104 got it therefore the final answer is going to be 104 actually if if it would have been done one after the other then what should happen there should be a change in 50 and then you have to increment it by 4% or after this you had increment by 4% the the actual answers would have been different right but then because of this change one of the updation which means actually the updation is completely lost so the overall effect is as if this has never happened isn't it even though this happened even if this has never happened you are going to see the same value which means this updation is completely lost that is why the problem is called as lost updation problem so you have to write the concurrency control uh mechanism in such a way that this problem will never arise right okay let's see other problem so this is also called as right right conflict okay one more name is right right conflict why because of these two right now when will this occur whenever you are going to have two wrs without any read in the middle then it is this is going to occur all right when you have two rights on the same data item this is also important when you have two rights on the same data item without having any read operation in the middle of the data item then it is going to lead us to right right conflict see now this one and this one is not going to give us any conflict because even though it is right right here it is about B and it is about a so two rights have to be on the same data item got it okay let's look at the other problem now this is called as dirty read problem so what is dirty read problem is let us say a transaction has executed for some time and then it rolled back before rolling back if some other transaction has read the data which it is uh you know not supposed to read then it is going to be that you read which means you are actually reading some data which is not committed I'll just take the example and show you see this now assume that transaction T1 has started the same way and is trying to transfer money from A to B and so it has decremented the value of a and after decrementing the value of a it has written the value of a which means the final copy or the actual copy of a has been modified see here a has been modified locally and the change has been transferred to a right so which means initially if a was 100 this is decremented by 50 and so a is made 50 and now this change has been transmitted to the hard disk from which let's say T2 has started reading and so T2 is now seeing the value of a is 50 and it has done its computations so let us say here also 4% is what is going to be increased and now if I try to increase it by 4% it is going to be okay so it is going to be I think 52 rupees right so now if You observe it at this point it is going to be 52 and now it is going to write there so again here it is going to be written as 52 now let us say at this point so after this transaction is over at this point again a you know T1 has started executing now let us say T2 has somehow failed here because of the hard disk failure or Hardware failure or some other failure power failure whatever the reason is now it suddenly stopped executing and later what will our concurrency control system will do is or the recovery manager will do is it will try to roll back the entire transaction because if it is not completely done we have to start it again now when it rolls back right which means it is going to undo all the operations it it did now what will it do it will try to see that okay have changed the value of a therefore let me restore it to the original value here the original value was 100 now it will try to restore it back to 100 all it now because of this roll back again this updation is also lost isn't it which means we are going to get wrong uh values whenever you are going to read a value from a transaction without the transaction getting completed without the transaction getting committed so committed means whatever modifications you did you are not going to undo if you have not committed the transaction which means at the end there is something called as commit right so if you don't see this commit it means that there is still a chance that whatever modifications we did to the data items here we'll just undo them right so you have to wait until a transaction commit then only you are supposed to read the data by it if you do it in the middle there is a chance that you might you might be reading some dirty values right so in this case dirty values means a value which might change later all right so how to solve this problem is just wait for the transaction to complete then only you are supposed to read it otherwise whenever you are going this transaction is going to roll back again this transaction also should roll back and both of them have to I know start simultaneous now there is one more problem called as unrepeatable read problem or nonre repeatable read problem I'll show you what it means this let us assume that initial value of a is 20,000 okay and let's say a has you know T1 has read the value of a which means at this point T1 will see that A's value is 20,000 okay and then after a has T1 has read T2 is going to read the value of a at this point a is going to see that a value is 20,000 and now it is T2 is going to modify a by it's subtracting 15,000 from 20,000 if you subtract 15,000 it is going to be 5,000 right therefore a value here will be 5,000 right and now it is going to write it back write it back means the original copy has been modified now right the original copy which is present in the database is now modified to 5,000 see whenever I modify the original copy doesn't mean that it is permanent if the transaction rolls back there is still a probability that you might have to you know get back to the oral back in the previous value right okay fine so now here right is going to make this as 5,000 now again if it tries to read the value here it is going to see that the value is 5,000 right see this according to the transaction T1 it didn't do any modifications to you but it is seeing that one time when it read it it is 20,000 and next time immediately when it reads it it is going to be 5,000 right therefore the data has changed without the involvement of any operation from T1 right now this is actually uh you know T1 should get an effect as if it is running in isolation but then it is as if some other transaction is also having an effect on the values which are seen by T2 right therefore it is a problem now this problem is also called as read write conflict if you see this there is a read right conflict here right so there is read operation on data item a and again there is a right operation on data item a right so whenever you have such a problem right you are going to see uh the different copies got it so how to why did this problem occur because after reading someone is going to change the value you read and they are changing the value original copy also that is why you going to see this problem okay now let's look at the other problem now this is called as Phantom tle problem so what is phantom tle problem is now assume that we have in our data base we have a table employee table with three tles right sorry two tles so these are the attri attributes and the tles are like this 1 a 5,000 3 C 4,000 right and now when you are trying to see what is all who are all the employees who are having salary more than than 3,000 then you got that these two are going to be the output right okay that is what this transaction has done now later on the other side some some other transaction has started and there is an interleaving between these two which means after executing this transaction I know this query someone has started one more uh you know transaction and this transaction is just inserting a new row into the table now because of the insertion of the new row now the table will become like this earlier the table was having only two rows now the table is having three rows right now after this if the transaction again does the same thing and it is going to see different values right now it is going to see three Tes which means for this transaction it didn't do anything it is asking the same query two times and two times you are getting two different answers right now again what is it this transaction is having an effect from the execution of the other transaction but then that should not happen right so every transaction should execute as if it is executing in isolation but then it is you know some other transaction some other transactions actions or the operations are having an effect on this transaction right so that is why it is a problem now this problem is also called as Phantom tle or Phantom phenomenon okay fine now let's see uh the meaning of a schedule so what is a schedule is when you have many transactions coming in you can execute the operations of the transactions in many ways right like I can take one transaction and all the operations of it and execute them first and then start with the next transaction right if I do that it is going to be one type of schedule or I can execute some of the actions of or operations of one transaction and then execute some of the operations of other transaction and again come back to the first one and again come back to second if I do that that is also a kind of schedule right so schedule is nothing but what is the order in which you going to execute the operations of various transactions when you have more than one transaction if you have only one transaction then you have no other way you are going to execute from top to down so there is no no way you are going to get many schedules but then when you have more than one transaction then you are going to get many schedules possible right now I'll I'll just read out the definition and give you the examples now see this what is a schedule is a schedule represents the order in which the operations of transactions are executed so what is the meaning of it is I'll just take an example assume that our database has got two transactions our database server has to execute these two transactions and one transaction is T1 I'll just take a simple example assuming that there are only two operations present in transaction T1 and the other transaction let's call it as T2 is having only two operations just as assumption generally two operations are not possible but I'm just assuming it so that explanation will easy right B1 and B2 so what does the what is the meaning of it in order to execute the transaction T1 the operations that have to be carried out are A1 and A2 in order to complete T2 the operations are B1 and B2 now what are the various ways I can I can execute these four operations is that is going to form schedules right so there can be one schedule of this type T1 and T2 I can execute completely T1 first and then T2 right so A1 A2 and then B1 B2 right so this is one type of trans schedule and the other type of schedule is I can execute let's say T2 first and then T1 which means B1 B2 operations will be done first and then A1 A2 this is other type of sh schedule right similarly you can have some other type of schedule on which let's say I start with one operation from T1 which means A1 and then I'll do one operation from T2 which means B1 and again I'll do one operation from T1 which means A2 and then one one right this is one schedule right similarly I can have one more schedule like this I can start with one operation from T1 and then I can finish T2 and then I can finish T1 or other type of schedule can be I can start with one of operation from T2 and then one operation from T1 and then one operation from T2 and then one operation from T1 or other type possible is I can start with this and then I'll finish up T1 and then I can end this one right now if You observe this these are the various possibilities we have no more you can test it right so uh one thing that might be confusing you is you might also think that this type of schedule is possible let's say S7 you might think that this type of schedule is possible I'll start with A2 and then I'll start with B1 B2 and then A1 right now this can never be a schedule the reason is within a transaction you are supposed to follow the order if you look at the order within a transaction A1 should be done first and then A2 right so this should not be altered right if you look at any of this transaction schedule that I have written within a transaction you are always going to have the order now if you look at this the order is A1 A2 and B1 B2 right if you look at this order is A1 A2 B1 B2 here also A1 and then A2 B1 and then B2 A1 A2 B1 B2 A1 A2 B1 B2 A1 A2 B1 B2 right so if you look at it I have I'm following the order right so with these two transactions with two operations each how many schedules are possible six schedules are possible right now if you don't let any control any no if you assume that no concurrency control mechanism is applied and you are simply allowing the transactions to inter leave and operate then they might execute in any of these possibilities right now how many of them will lead to the correct answer that actually depends on what types of operation there are if there is no intersection between them which means these two transactions if they are not operating on any common data item then all of them might be true if they are completely independent right but then if they are dependent then depending on their actions some of the transactions might lead us to wrong answers depending on what problem know the problems we have seen earlier right if some of the schedules are leading us to the problems that we have seen in the earlier examples yes that might be wrong but it can be very be sure that two schedules among this will always be right so what are the two schedules this one and this one right so if you look at these two schedules this one and this one are actually serial serial schedules why serial is you are letting one transaction completely be over then only you are starting the other one here also you are letting this transaction be completely over and then you are starting this one right therefore these two are called as serial schedules so with serial schedules there is no problem at all and always they will lead us to the correct answers but the only problem with serial schedule is your performance might be hurt the reason is you know some of them might be IO operations and if you wait for Io operation to complete without starting the next transaction then it might lead to uh the performance issues right so what you should do is even though this serials are correct you are not always going to execute the serial transactions you you have to you know execute the schedules in which some concurrency is allowed in such a way that it will not hurt the performance as well as the result is Right which means among these uh you know schedules find out the schedules which are equivalent to the serial schedules and then execute them all right okay how to find them uh what are the rules we shall see them later for now let's stick to how many schedules are possible now with these many uh transactions and these many operations these many schedules are possible is there any general rule we can apply yes now assume that I have uh T1 with n operations and T2 with M operations right then how many ways I can form the schedules is the formula is n + m factorial / by n factorial into M factorial so how to get this we have discussed about this in mathematics in permutations and combinations I given you some examples I'll just tell you how we get get this now you can sum them all up and find out all the permutations possible you take all the operations together and you find out all the permutations possible it is going to give us n + m factorial right now we have we are not supposed to change the order within each trans transaction which means even though this transaction is having n operation and this transaction is having M operations you are not supposed to put all these n in any permutations they have to be always in that order right now if you're going to get all the permutations most of them you got because you are permitting this one right now if you compute how many you got because of Permitting this one you'll see that it is n factorial and how many you got here M factorial therefore you have to divide them right because many of these trans transactions many of the transactions in this one actually represent one and the same uh you know transaction therefore you are not supposed to change the order that is why I'm dividing it with this or if you want to clearly understand why this is true better you watch permutation and combinations you'll understand it right so what I mean to say is all these n operations A1 A2 A3 so on a have to appear in the same order within the schedule and B1 B2 B3 have to appear in the same order right now you can inter you can have any combinations of these two but then the ordering has to be maintained right so the relative ordering between these n operations have to be same and the relative ordering between these M operations have to be same right now this number we got assuming that we are going to change the ordering between this and the ordering between this and then we have to cancel that effect that is why I'm dividing with n factorial into M factorial now now in this case n and M are 2 and2 therefore what is that you are going to get here 2 + 2 factorial divided 2 factorial into 2 factorial now if you computed this number is going to be 4 factorial / 2 factori into 2 factorial which is 6 got it so that is why you got six schedules now out of the six schedules two are going to be uh you know serial Treads right and all the remaining are going to be non- serial Treads got it now if you have let us assume n transactions T1 T2 T3 so on TN n transactions and let's say the number of operations in each one each transaction is A1 A2 A3 so on a n then how many schedules are POS possible the number of schedules possible will be A1 + A2 + A3 plus so on plus a n divided by A1 factorial into A2 factorial into A3 factorial into so on into a n factorial right this is the total number of schedules possible right now out of the schedules how many schedules will be serial serial means we had to execute completely one transaction and then next one and then next one like that right now how many is it POS possible so you are going to get n with n transactions you are going to get n factorial serial schedules right this is the total number of schedules possible and this is the total number of Serial schedules possible now if the question is how many number of non- Serial schedules are possible then from the total number of schedules you can subtract the total number of Serial schedules then you are going to get total number of non- Serial schedules got it and non- serial schedules can also be called as concurrent sh schedules why because you are actually mixing up the operations whenever you mix up it is concurrent execution got it now let's see the types of schedules so one type of schedule is serial schedule so what is the serial schedule is if we don't have any inter leaving then generally that type of schedules is called serial schedules the meaning of this is if you have started a transaction just finish it off till the end without going to other other transaction in the middle if you're going to do that then such type of know schedules are called as serial schedules and next one is when transactions are executing serially that always ensures the consistency so this means that when you make sure that all the transactions are going to execute one after the other then the database is going to going to be consistent consistent means it is correct so always serial schedules are going to give give you correct answers but then it doesn't mean that all the non- serial schedules will not will give you inconsistent States no so there can also be some non-s serial schedules which might give you correct results which means consistent States but is difficult to find them out or you are supposed to find them out right find out all the non- serial schedules which are equivalent to this serial schedules and execute them that is the main purpose of this entire Theory and the next one is if there are end transactions in a schedule the possible number of Serial schedules serial schedules are n factorial this is what we have seen okay now let's see an example assume that we have two transactions then how many serial schedules are possible and then let's see what are the examples assume that two transactions are like this T1 and T2 now this is a schedule in which I'm finishing T1 first and then I'm starting T2 so I'm finishing T1 first and then I'm starting T2 right and again this this is the example of a schedule where I'm finishing T2 first and then I'm starting T1 right so both of these since there is no interleaving which means once I start it I'm going till the end and then only I'm going to the next one since there is no inter living between the transactions you can call it as serial schedule this is the example of Serial schedule now what about non serial shedule whenever see this you have started this T1 and you have executed till this point point and then again you are going to T2 without completing it right so there is inter leing now whenever you have a living then it is called as non- serial right and in this case this non- serial schedule is going to be inconsistent right so if You observe it it is going to be a lost lost update problem isn't it but I'm not saying that all the non- serial schedules are going to create problem no there can be some non- serial schedules which might work well right but in this case that is that is an example of a non-al schedle which is not working well right but anyway here we want to see what are the examples of Serial schedules and these are the examples of Serial schedules only two are possible got it okay now let's see what a complete schedule is a schedule is said to be complete if the last operation of each transaction is either abot or commit so what is the meaning of it is till now we didn't see what is about and what is commit I'll just explain you now whenever a transaction is saying that the law statement is commit and if you're going to execute that statement it means that whatever rights it has done till now they have to be made permanent right so whenever you do write see whenever you read you are going to read from database and whenever you write you are going to write to the database and you know meanwhile the copy is going to be in your temporary memory whenever you write the copy is going to propagate to the hard disk or the database which means the right is going going to be propagated into the database but still you are supposed to say commit now whenever you say commit it means that don't allow anyone to you know change it that is the meaning of it right or you are you are you know you want this change to be permanent right so no other transaction should come and undo this uh the changes made by this transaction with example it will be clear right it might be bit confusing here so when you have already written what is the use of commit right with examples I'll tell you what is the meaning of it uh so you can for now you can understand that whenever I say commit it means that whatever changes are done till now they have to be permanent and we are not supposed to change them okay later so it is not possible that you know you you can undo the changes and let's say this abot abot means so whenever any any transaction does abot it means that uh you know whatever changes are made by this you just undo them right for example it has done right operation you just undo it and set a value to previous value you know before what before it has done this which means before when when it has started reading a whatever value it was you going to put it there right now the problem here is this is going to create a problem so by the time you are trying to restore the value someone else has already committed the value of a then you cannot do this so anyway that is not what we are trying to explain here here I just want to tell you that whatever the type of schedule it is if all the transactions are showing you either commit or abot at the end we call such a schedule as complete schedule now is this possible or not is it right or wrong don't worry about it as of now okay that is not the intention of this of our explanation here here we are just concerned whether it is complete or not okay now come here huh now we can see based on the placement of this commit and based on the placement of the abot we can we can say that some are recoverable and some are unrecoverable schedules now let's say this recoverable schedule recoverable schedule means uh I I'll show you what is happening here let us say T1 is trying to transfer some amount to from A to B right assume that 31 is trying to do this it is trying to transfer from A to B some 50 rupees and initially a value is 100 this is what is a a value right and T2 it is trying to increase the a by 4% right so which means T2 is trying to make a = to a + 4% of a this is what T2 is trying to do right now let's say T1 has started and then T1 has written back the value which means T1 has started the transaction and write the value of a at this point value of a will be 100 and then it is making it local copy to you know minus 50 which means the local the value of a is know 50 now and then it is going to write back this value into the database now what will be the value present in the database it will be 50 right and now from the database T2 is trying to read it so T2 will read 50 instead of 100 got it and now it it is going to increment it by 4% which means it made it to 52 right and then it incremented means here it is going to be 52 a value is going to be 52 and it is going to write the value of a to the database which means in the database its value is Now 52 earlier it was 50 now it is made 52 initially it was 100 then it is made 50 now it is made 52 and now it is saying commit commit means whatever changes I made I want them to be permanently available there and please don't undo whatever I made right so what is the what is that this transaction T2 has done is incremented the value of a by 4% right now that change we don't want to you know undo it therefore this value of 52 has to be there permanently or whatever changes are made by T2 should be always reflected there somehow now what is happening if T1 is after executing for some time it has decided that you know it has to roll back right because of some reason it is failing right either maybe you can assume that there is a hard disk failure or some Hardware failure or some power failure because of some failure you know you are trying to you are not able to complete it and so according to the atomicity rule you are going to roll it back right so when you roll it back what you are trying to do is what is this transaction trying to do is it is going to reset whatever it has done whatever you know modifications it has done it is going to undo them now it will think that I made the value of a from 100 to 50 so let me write 100 right so that is what it wants to do but then it has already committed right and so what happens is whatever it has done if you allow this you know this action then whatever action is performed by T2 that will be gone commit means it is saying that all my action should be permanently reflecting in the database but by doing the roll back here all the actions done by this one are lost right therefore this is not recoverable got it so we this such a such a problem such a schedule is called as un recoverable problem schedule right okay now how to solve this problem is why did this happen is you can think of this you know in in other way let us say it is an exam and there is a person here writing and someone has copied from him right so let us say know two people are cheating in an exam and someone has written some answer and someone else has copied it right and now before this person has submitted his answer paper to The Examiner this person has submitted the answer paper to The Examiner and he left now after he left this person you know changed the answer right he thought that okay this answer was not right so let me change it right now what happens this this person is going to submit the answer paper after this this person has already left now he is going to lose the marks got it now how to make sure that this person will not lose the marks in this case so simple way is one simple way is if you have copied from other person then don't submit your answer paper until this other person has submitted the answer paper right in case if the other person has submitted the answer you know has you know changed his answer then you are supposed to change the answer right just an analogy right so in this case if you want to see what happens in commit is whenever you are going to read a data which is not committed it is not committed isn't it whenever you are going to read the data which is not committed then you don't commit until the other person has committed all right in case if the other person is rolling back then you to roll back then only you are going to have consistency right now look at this the problem how how to solve this problem is now this person has written the value and this person is reading that value from him this person has written some value and this person is reading the value from him right now when he's going to write it this answer is going to be right provided that this changes are going to be there in the database if this changes are not going to be there then your increase of 4% will would have been done on this all it so you just wait until the other person commits so whenever you are doing this dirty read you don't commit until the other person commits which means this commit has to be ordered right so when you're performing dirty read just wait for the other one to commit then only you commit in this case if the other one is not going to commit let us say other one is going to say that I want to roll back I want to undo whatever changes I did right then you will have a chance that you two can roll it back got it that is called as cascading roll back if you have that chance then it is called as recoverable here you don't have that chance you are already done and it is over right now you cannot roll back but here you have a chance that whenever it roll back you two can roll back and then you can undo and again later at some later point in time you can start again right without any effect on the consistency got it so if a transaction has to be recoverable then in case of any dirty read don't commit unless the other other fellow has committed other transaction has committed if you can follow that rule it is going to be recoverable otherwise it is unrecoverable okay fine now let's see cascading aborts if one transaction failure causes multiple transactions to roll back then it is called cascading roll back or cascading about so what is the meaning of this one is If You observe this you know there are three transactions T1 T2 T3 now let us say uh T1 is reading the value of a and then doing something here right and then it is going to write the value of a but it didn't commit it before it is getting committed whatever value it has written T1 now T2 is reading it and then T2 is doing some modifications on a and then writing it but then it didn't commit it right right now whatever value is written by T2 is read by T3 and it has you know run some modifications and it also has written the value there right now look at this now t2s value will depend on what T1 has computed and t2s value will be right provided that T1 value is T1 transaction is committed right which means if it says that all the changes I made if it they are you know correct then only uh you know this one will be correct which means the correctness of T2 will depend on correctness of T1 or completeness of T1 if T1 suddenly says that I'm not complete then whatever T2 has computed will be wrong right and then the correctness of T3 depends on the correctness of T2 right now if T2 is wrong then T3 will be wrong right so at this point let us say at this point before this one and this one has got committed assume that T1 is saying that I want to roll back because of some failure then what happens then you have to roll it back because it will not be correct unless it is committed since it is not committing you do have to roll back and undo all the changes and now you two also have to roll back and undo all the changes right so yes this is definitely recoverable the schedule is recoverable but then the schedule is waste of time isn't it now if You observe this all the computations done here have to be undone all the computations done here have to be undone right so now what is the solution in this case is don't uh read from uncommitted transaction then you need not do cascading roll back right or if you want to understand it clearly what what has happened here I'll just tell you what it means now let us say T1 has read the value of a let us say initial value of a is 10 and it has made the value of a as 20 incremented it by 10 now let's say T2 has started now T2 has started from this point not from this point right assume that all T1 T2 and T T3 are three transactions which are trying to increment the value of a by 10 if all of them happen simultane I mean in the correct order then what should be the value of it if the initial value of a is 10 if all of them are going to increment it by 10 then it has to be 40 at the end right now let's say T1 has started and it finished it and it has computed its value as 20 and now T2 it has started and it has you know started from 20 value and it has updated it to 30 which means incremented to 30 now T3 it has started from 30 and has incremented to 40 therefore final value computed by T3 is right now what happens if T3 commits is it is going to make this change as final and then if these two are going to roll back then you'll not be able to undo this modif you know change done by it or the change done by this will be gone right now let us say if they have committed earlier right if this one would have committed here if the commit of this one is instead of this if it is at this point then what will happen is we'll consider that T2 has completed his execution and you will not execute T2 again right now if you are going to roll it back then what happens uh it has read the value of T1 has read the value at 10 and it made it to 20 therefore it will again set it back to 10 right which means T2 is over and now T2 is setting it back to 10 and let us say T3 is not over and T3 is able to roll back then what happens is T1 will again come for execution because it rolled back and T3 will again come for execution at later point in time but only value of 20 will be incremented right why 10 by this and 10 by this next time if it everything goes goes well then the value of this one is going to be 30 only got it so having recoverable schedules is important for that reason we are not going to commit uh any transaction this transaction until this transaction has been committed right and we are not going to commit this transaction until this transaction has been committed fine and it is going to lead us to cascading roll backs right so what is cascading roll back is if this one is going to roll back then this one also has to roll back now this is going to be a waste of CPU time isn't it so we want our transactions which are cascad less so what are cascad less is even if it rolls back I don't want to roll back got it so how when can I when can that happen now let's see this example now let us say cascad schedule a cascad schedule is one where each pair of transactions TI and TJ such that TJ reads the data item that is written by TI then the commit operation of TI should appear before the read operation of TJ so what they are trying to say is now in the earlier case we we have to roll it back because we are trying to read the data and perform the operation s before this one has committed now how can you avoid it if you would have waited till transaction T1 has committed then there would have been no no reason for you to roll back right so don't read data from any uncommitted transaction just wait till it commits so later at some point if you read it there will be no need for you to roll back because it is already committed anyway it is not going to roll back therefore there will be no need for you to roll back right similarly if this transaction is reading the data from this then wait for this read until this transaction is going to commit now once it is saying that I'm done I'm complete then only you read it why because there is no way it is going to roll back therefore you will be safe got it now uh what how to ensure it is so if you are going to read from some transactions see that its commit will appear first got it now let's let's compare this one with recoverable so what does recoverable say recoverable say that whenever you are going to read some from some transaction see that you commit only after he commits now since you are putting uh this uh you know read after commit definitely are ensuring that the commit will be after this commit are you getting this see in case of recoverable schedule what was the rule if you're are going to read let us say there is T1 and let us say there is T 2 right let us say it is writing the value of a and you are going to read the value of a right now it is saying that let this one commit then only you commit right so this is the order you are supposed to maintain got it this is what is recoverable schedule mean now coming to this cascad schedule what it is trying to say is you put this after this so by ensuring that the read operation itself is after the commit operation you can Ensure that the commit operation of this one will definitely be after this commit operation getting this therefore what can we say if a transaction is cascad less then definitely it is already recoverable why uh if you are going to order the read operation after this commit automatically this commit operation will be after this commit therefore it is satisfying the rule of recoverable schedule so what can you say every cascad schedule is recoverable but can you say that every recoverable schedule is cascad less no why because because of this isn't it this is recoverable schedule but then you are reading before it gets committed therefore if it rolls back before you know at this point if it says that I want to roll back then you are supposed to roll back got it therefore if you are trying to see the relationship between cascad less and recoverable it is like this set of all recoverable schedules and set of all cascad less schedules now every recoverable schedule oh sorry set of all recoverable schedules and set of all cascad less schedules now we can say that every cascad less schedule is recoverable which means if you're going to see this is definitely recoverable but then there can be some recoverable schedules which are not cascad less right so what does it mean the recoverable schedules may also contain some roll back schedules right I mean that cascading roll back schedule what is the meaning of it if you're are going to roll back a transaction then you might have to roll back the other transaction that is not a problem but just a waste of computation time see always it is better to have recoverable schedules because if something wrong happens with one transaction you can start everything once again without losing anything that is why recoverable schedules are important right now let's see strict schedule a schedule is strict if a value written by a transaction cannot be be read or overwritten by other transactions until the transaction is until the transaction either commits or aborts so the meaning of this one is if you're are going to have uh a transaction like this now this transaction has to be committed then only you are supposed to even write see it is more strict compared to the cashless in cashless what we did was if you're going to have a read operation then after this one commits then only supposed to read that is what you said but here but there you didn't said anything about right so according to the castus even this type of schedule will be allowed which means now read a write a and now it is not at committed but then the other transaction can do write a and then commit right so this is actually cascad less so why if it decides to undo the changes it did it can do it without affecting anything by this one right so actually when you are trying to read something without writing it is it is a very rare rare case where you are going to read sorry write something without reading this is called as blind right blind right means you are not reading it you're directly writing it that is you're not seeing it you're just writing it that is why it is called as blind right okay now by allowing this one uh this the trans the schedule is going to be cascad L now if you want to be even more strict you don't want either read or write anything to happen until this one gets committed right that is what they're saying read or overwritten so here you are going to overwrite before it is committing right you are not going to allow this instrict soever instrict uh it is called a strict schedule because it is more stricter compared to the uh you know the cascad less got it so what can you say about uh the relation between strict and cascad less every strict is is definitely going to be cascad less why here you are not allowing write or read therefore write or read will will appear only after the commit and therefore there will be no need of rolling back this if this one rolls back therefore it is cascad less right so now if You observe it uh all the three the one is recoverable other is cascad less and the other one is uh let's say strict If You observe this in case of recoverable we are saying that the commit should be ordered let us say if this is T1 and if this is T2 now T2 if it reads anything from T1 that you know from T1 then T2 has to commit only after this right so this is the only restriction for recordable schedules now coming to cascadel schedules it is saying that if T2 wants to read something from T1 then let T1 commit then only you read this is what uh you know uh cascad L is saying right by putting this what we are saying is since this c c will always be following this the commit of this will always be following this you can ensure that every uh cascad schedule is already recoverable which means this condition is also you know embedded in this condition now if you look at this uh strict schedules what is it trying to say is it is not just about read whatever operation it is read or right you have to put only after this which means if you have T1 and T2 and if T2 is trying to Blind write something which T1 has written it is saying that wait until it gets committed then only you write or you read then only you commit right therefore it is even more stricter than this therefore If You observe this strict schedule you are not allowing anyone to read until you commit this one therefore every strict schedule is definitely cascad less now if you look at cascad less you are not allowing this read to happen before this therefore you are not allowing this commit to happen before this commit so every cascad less is recoverable got it so now if you have to see it might be confusing but if you slowly listen to this it will be easy okay now if you put all these things together right so this is about recoverable this is about cascad L and this is about strict now if you put all these points together whatever I discussed till now now then you are going to observe this point now let's see this then you can clearly see that one is right now if You observe this every strict schedule is going to be cascad schedule and every cascadel schedule is going to be recordable schedule that is the meaning of it if you take a strict schedule it is both cascad less as well as recoverable and if you take any cascad L schedule see what is this set this is set of all strict schedules if you take look at set of all strict schedules they are definitely Cascades and if you look at set of all cascad schedules they definitely recoverable right now if you want to summarize all the information that we have seen till now what is that we have seen till now is what is a schedule right now a schedule is nothing but the way in which you are going to execute many transactions uh together that is a schedule how we are going to execute the operations of a trans of many transactions which are presented to you now I told you that a schedule can be of two types one is serializable and the other one is non- serializable now if you look at the serializable schedule you are going to complete completely perform one transaction then only you are going to start the next one in case if there is any reading right so you need not worry about it because one transaction is going to get committed then only you are going to start either read or write off other transaction and so every serializable schedule is definitely strict are you getting this every serializable schedule is definitely strict why is it strict because you are going to start with a transaction let's say T1 and you are going to complete it commit it then only you are going to start the next transaction T2 either read or write I don't care it is going to start only after this commit right therefore it is definitely strict now as I told you that every strict schedule is definitely cascad less as well as recoverable right so you can think of serializable schedule as as if it is obeying all the properties all right now coming to non- serial schedules so don't get confused here it is very simple concept right so every cial schedule is strict therefore it is going to be everything right now coming to the non serializable schedules now some of them may be recoverable and some of them may not be recoverable right some of them may be recoverable and some of them may be non recoverable so what do I mean by this there might be some transactions which might get committed before the transaction from which it read has committed in that case it is non- recoverable right and now coming to recoverable schedules some of the non- serial schedules may be cascading and some of them may be Cascade some of them may be cascad less or some of them may be cascading what does it mean whenever the the schedule is recoverable there might be sometimes a need for roll back and there might be sometimes no need for roll back right and now coming to this cascadel schedule some of them may be strict and some of them may be non-strict got it so this is the classification for non- serial schedules right so in serial schedules directly they are strict therefore they are everything in non serial schedules you are going to get this entire classification right so if you look at it in terms of this diagram okay now you can say that this is set of all non serializable serializable schedules all right and this this is how you can look at it now if you want to even put serializable schedules into this diagram it is somewhat difficult to put it there right why you might have to put the serializable schedules inside this but then that will say that every serializable schedule is non serializable schedule so let's not put it there all it so what I mean to say is there might be non some non seriable schedules which are not recoverable so what are what are the sched that fall here the schedules which are non- serializable and you know which are not recoverable which means this part this part right if we consider that this outer part this outer ring then the outer ring is going to represent this one right and now what are the uh if you look at this ring this ring this entire ring okay between this one and this one this part if you look at this part this is set of recoverable schedules which are not cascading which means these are recoverable but cascading this is cascad less this is recoverable but cascading which means this part they are recoverable but cascading now if you look at this part right let us say this part now what is it they are cascad less but not strict so which means they are cascade head less but not strict this part now if you look at this one it is strict which means this part got it now if you Union this one and this one you are going to get cascad less which means if you Union this part and this part you are going to get all the cascad schedules got it and if you Union this one and this one which means cascad less and cascading you are going to get all recoverable schedules right and if you Union this one and this one so which means recoverable schedules and non- recoverable schedules you are going to get the total non- serial schedules got it which means this one and this one is going to give you this understood that okay now let's see serializable schedules so what is serializable schedule means now if we assume that we have two transactions let's say T1 and T2 and assume that T1 is having the operations A1 A2 and T2 is having the operations B1 B2 right now if I execute uh T1 followed by T2 it is going to be the the transaction the schedule is going to look like this right or if I execute T2 followed by T1 then the schedule is going to look like this so B1 B2 followed by A1 A2 right now we are sure that these two are the serial schedules and which are going to give us the consistent results or the correct results right but then if you have any inter leaving which means if I have any schedule which is going to be non- serial then let us say you have one more serial like this B1 A1 A2 B2 right now let us say these two serial schedules if I execute it any any one of them it might waste some of the time because of the I operations and CPU being idle now if I allow inter leaving to happen let us say it is giving me better performance in terms of the CP utilization but then in order to go for this I should I should be very sure that you know this one is going to give me correct results or not now when can I allow this transaction this schedule to be executed is only if it is equivalent to either this one or this one right now if this is equivalent to either this one or this one then we can say that this schedule is serializable right even though it is a non- Serial schedule I can say that this schedule is serializable now how to say that this one is equivalent to either this one or this one there are ious Concepts we can use right now the formal definition is like this this serializable schedule means a transaction schedule is serializable if it's outcome is equal to the outcome of its transactions executed serially that is serial sequentially without overlapping in time so what they're trying to say is if you have any schedule it is set to be serializable if it is equalent to any of the serial schedules right now there are various ways we can see this equivalence one is called as result equivalent schedules other is called as conflict equivalent schedules other is called as view equivalent schedules now based on this concept we can say you know conflict serializable view serializable Etc now we shall see one by one now first one let's see what is result equivalent schedules let's say this one now result equivalent schedule means the two schedules S1 and S2 are set to be uh equivalent result equivalent schedules if they produce the same final database state right what I mean by this is whatever schedules you take you start from a state of database now after you execute that schedule you are going to change the values in the database now let's take a schedule S1 and do this I mean take a database and execute the schedule S1 on that now you are going to get the new instance of database now if you take some other schedule and execute the schedule on the initial database if the final database whichever you get is equalent to you know is equal to the same database you got from the first schedule you can say that these two are result equivalent so I'll just take an example and explain you what I'm trying to say here now question is is the following schedules result equivalent for the initial values X and Y right so for the initial values X and Y If X and Y are 2 comma 5 respectively all right so what which means let us assume that there is a database and in the database the value of initial value of x is 2 and then Y is 5 right and we are supposed to run uh you know transactions T1 and T2 and we are trying to run it in these three ways One schedule S3 One schedule S1 One schedule S2 now we have to verify which of them are actually uh you know equivalent okay now let's see one by one if you're are going to look at this now what will happen to value of x after this schedule is over now it is going to increment the value of x by 5 and Y by 5 and again Inc you know multiply the value of x by 3 so at this point x is going to be 2 at this point x is going to be 7 right and at this point Y is going to be five and at this point Y is going to be 10 right and now at this point x is going to be 7 because the value of x is 7 here and at this point x is going to be 21 right therefore the final rate of Y is going to write y as 10 and write X as 21 therefore by the end of this you know schedule the value of x is going to be 21 and the value of y is going to be 10 got it now on the other side let's say we are going to execute these two transactions like this which means this is a uh new schedule now if I look at the schedule and start from the initial database I want to see what happens now at this point initially X is 2 and at this point x will become uh you know 7 and at this point x is 7 is written there now here when I try to read it the reading is going it is going to read seven see don't worry whether it is is you know recoverable or cascading cascad less that is not what we are worried about now we are just saying that you know if we try to execute this way what is going to happen right and also don't worry whether the know the transactions are complete or not or the schedule is complete or not uh you know that doesn't that doesn't matter if I have to explain this concept I'm just trying to explain this concept without worrying about what type of know schedules they are so only thing that matters here is this is a Serial schedule why transaction one is completed and then transaction two if you want you can assume that here there is commit and here there is commit you can assume that transaction one is complete and then transaction 2 has started right and what matters here is this is a non- Serial schedule where transaction T1 has started and then we went to transaction T2 and again we coming back to transaction know T1 so which means it is a non- Serial schedule that is what is important here okay now here it is 7 and x = x into 3 now what what about this if x = x into 3 so it is going to make 21 and write X which means 21 is going to be written and again here x is y is going to be red so what is the value of y y is 5 and Y is going to be incremented by five means Y is 10 and Y is going to be red got it now if You observe this by the end of this uh you know schedule the value of x is going to be you know this is the final right of X isn't it therefore the value of x is going to be 21 and the value of y is going to be 10 right now if You observe this this is a Serial schedule which is producing this output and then this is a non- Serial schedule which is producing this output right so if you look at these two schedules they are actually equivalent when you compare the results right that is why they are called as result equivalent schedules right so result equivalent schedules means if I execute this one or if I execute this one both are going to give me the same answer right now what do you understand from this so we understand that uh you know this one is going to be consistent and this is also a non serial schedule which is giving me the same answer which is given by this therefore it is safe to execute this right therefore according to the result it is serializable schedule because it is equivalent to this serial schedule right right so it is results realizable right but then we are not going to use this concept or this type of comparison in real practice because if you have to do that comparison then you might have to execute this and you might have to execute this and then compare the results if you already have executed this then why do you really want to execute this see we are trying to uh somehow finish the transactions in such a way that we get better utilization compared to the serial ones now if you are already going to execute the serial once why do you want to again execute this what it so we don't really use it at practice we at practice we use other methods okay so this is just a theoretical concept but then at practice we generally don't use it okay now let's see what happens with this one now initially x value is 2 so two is red right and then X is multiplied by 3 so which means here the x value is going to be 6 right and then W sorry X is going to be written so X is x value of 6 is going to be written and now here x is again red so x value that will be red will be six and now x is incremented by five so which means x value will now be 11 and again X is written which means 11 will be written now at this point Y is going to be red so which means Y is going to be five and Y is going to be incremented by five means Y is going to be 10 and again Y is going to be written means Y is y 10 is written right now at the end of this schedule what will be the value of x the final rate of X is here therefore the value of x is going to be 11 and the value of y is going to be 10 got it now if you see the result this result and this result are not same right therefore you can say that these two are not view equivalent right and this result is and that result is not same so you sorry not view it is result right so this result and this result is not same therefore they are not result equivalent and this one and this one is not same therefore we can say that these two are also not result equivalent but then these two are result equivalent got it okay now let's see this conflict equivalent schedules so before talking about conflict equivalent schedules you should understand what is a conflict now conflict means whenever you're executing a transaction or let us say a schedule if it is having more than one transactions then there can be some conflicting actions now what are they so if say there are two different transactions present in a schedule and if both of them are acting on the same data type or same data item and one of them is writing and other one is one of them is reading and other one is writing then this is a conflict right or if one of them is writing and other one is reading the same data item then it is a conflict and one of one of them is writing and other one is writing then it is a right you know again a conflict so how to remember this one is Whenever two actions are from different see both the actions have to be from different transactions right so there will never be a conflict between the actions within the same transaction so first thing is both the actions have to come from different transactions and second thing is both of them should be uh you know working on the or acting on the same data item and the third important point is is at least one of the action should be right action right if these three conditions are followed then we can say that you know uh there is a conflict between two operations right if I have to say that there are two operations let us say operation one and operation two if these two are going to be conflict operations then both of them have to be from different transactions and both of them must be acting on the same data item and at least one of them has to be right got it so in in this case this action is from TI and this action is from TJ and both of them are acting on the same one and one of them is Right therefore it is a conflict right and this one is from T this one is from TJ and both of them are acting on a and the one of them is Right therefore it is a conflict and similarly here also it is a conflict now whatever are remaining other than this they are all going to be non-conflicting right so what I mean now now if if actions are all from the same transactions they are non-conflicting or if the actions are just simply you know read operations not the right then they are non-conflicting or if they are acting on two different data items then they are all non-conflicting which means if TI is know acting on data item a and t TJ is acting on data Item B then since they are working on different item data items they are not conflicting right so other than this whatever you see are non-conflicting now if you have to talk about conflict equivalent schedules you have to understand or identify what are all the conflicts conflicting actions and then you should you should order them okay let's see this two schedules are set to be conflict equivalent if the conflict operations in both of the schedules are executing in the same order okay with example I'll explain this what I mean by this is let's see this now let us say there is a schedule which is having two transactions T1 and T2 now both of both of them are having some operations now if you see this this one is operating on a and this one is also operating on a since it is read read we don't have any conflict between them right and this one is operating on a and this one is operating on a but since it is read right there is a conflict right therefore there is a conflict between these two operations why because these two operations are from two different transactions and one is read and other is WR and both of them are doing on the same data item but then you should not say that there is a conflict between these two because they are they are they both are from the same transaction all it and now look at this this is a write and this is a read and both of them are operating on a and both of them are from two different transactions there there is a conflict between these two right and again this is a right and this is a right and both of them are from two different transactions and both of them are acting on the same data item therefore there is a conflict right and what about this one and this one so this one is on B and this one is on a and this you know similarly this is entire set is working on B and this enti set is working on a therefore there will be no conflict between them even though they are from different transactions right now if You observe it clearly there are three conflicting operations now let's see the order in which they are appearing so if you have to write the order it will be better if you can you know rename it as all the all the actions which are on the T1 side I'm just naming it as R1 W1 R1 W1 right and here R2 W2 just to say that this is from transaction one and this is from transaction 2 now let me just uh say uh what is the order in which they are appearing Right In Here If You observe this this conflict is in such a way that there is read from transaction one on a then only there is a right from transaction 2 on a this is the order in which it is appearing now what about this one there is a write on data item a by transaction one then only there is a right by transaction two on data item a right and if you look at next one here this one between these two there is a right on data item a by transaction one then there is a read on data item a by transaction two all right so this is the order in which the conflicts are occurring now if you can test that whether in some other schedule if there are any conflicts if they are occurring in the same way then you can say that this particular schedule is conflict equivalent to that schedule let us compare it with some other schedule let's say this one okay now this is also a different schedule this is a schedule and this is a different schedule and in this schedule we are going to have same transactions see both of them are ex actually executing the same transactions T1 and T2 which means if I have two transactions coming in then these might be two possible ways of executing them this is one schedule and this is other schedule now I just want to see whether uh you know what are the conflicts in this and then whe whether both are equal or not okay now if you look at this a and a right these two are not going to be conflict because both are read read right even though they are acting on the same data item and even though they are from different transactions read read is not going to create any problem right now if you look at this one and this one then read right yes so it is a conflict because both of them are from two different transactions and both of them are working on the same data item and at least one of them is Right therefore is a conflict yes right and what about this one next this one this is going to conflict with this because both of them are working on the same data item which is a and one of them is Right therefore it is going to be conflict all right and again this one is going to be conflict right right because both of them are from two different transactions and at least one of them is right and they are all they both are working on the uh same data item got it and what about this one and this one no conflict because they're working on two different data items no conflict because they're working on two different data items right okay now let's see what is the order of this conflicting operations s now just for the sake of understanding you can rename this you know as 11 one one one to understand that these all the know operations happening on transaction one and we can write it as 22 so that you can understand that these are happening on trans action two side okay fine now if you see the order first this should occur and then this should occur which means first R1 of a which means transaction one is going to write read the value of a and then only transaction 2 is going to write the value of a and then here transaction one is going to write the value of a and then only transaction two is going to write the value of a and transaction one is going to write the value of a and then only transaction two is going to read the value of a right now if You observe this the way see this one is there the same the conflict actions are occurring in the same order by first one first and then the second transaction same thing right and now if You observe this W1 W2 the same thing is happening there right W1 and then W2 which means by first transaction and then second transaction now if You observe this W1 and R2 right yes got it therefore these two are conflict equivalent now if You observe these schedules there is one more interesting Behavior there are one more interesting property now this schedule is a uh is not a Serial schedule but this schedule is a Serial schedule right in this serial schedule it is actually T1 followed by T2 see if you just want if you want to complete it you can just write a complete schedule by writing commit and commit here but anyway that is not what we are worrying about here so let us say this is the entire you know complete transaction this is a complete transaction now if you compare it this is a non- Serial schedule and this is a Serial schedule now A non- Serial schedule is conflict equivalent to a Serial schedule got it that is why this non- serial schedule will now become conflict serializable so what is this one called this schedule is conflict serializable because it is conflict equivalent to a Serial schedule got it and it is an important property so we are going to allow conflict serializable schedules only because it is going to be equalent to a Serial schedule got it now uh that is what is called as conflict serializable concept but then this way of checking it is going to be tedious if you're are going to have lot of transactions see what did we do we have taken a transaction or we schedule which is not serial and then we compared with a Serial schedule and since both are equivalent according to the conflict we are saying that is conflict serializable then what will the general procedure be you might have to take all the serial schedules and you might have to compare this non- serial until you get it equivalent to one of them but then this method is going to be very lengthy if the number of transactions are going to increase in a schedule let us say you have end transactions right or four transactions if if you have then how many serial schedules are possible the number of Serial schedules possible will be four factorial all right four factorial means 24 so 24 serial schedules are possible and if you have to check whether uh you know this particular non- serial schedule is equival is conflict realizable or not then you might have to write all 24 possibilities and if you have to check whether this one is equivalent to any one of them but it is going to be a lengthy method if you're going to go this way so for thison we shall use some other method using which we'll be directly able to say whether this one is conflict Ser serializable or not in case if it is conflict serializable what are the serial schedules to which it is equalent to okay we shall we shall see that with examples that method will be simple this method is lengthy but then in order to understand this I have just given you this okay don't use this in the exam okay fine now let's look at the topic of view serializability so for that you should understand what is VI equivalent so let's try to understand what is V equalent and if a transaction sorry a schedule if it is VI equivalent to other schedule which is serial then you can call this schedule as view serializable so what I mean to say is okay let me read out the points here you'll understand it a Serial schedule and a non- Serial schedule are set to be view equivalent if they satisfy all the following conditions so there are three conditions first condition is if TI reads initial value of a in s then TI should also Al read initial value of data item a in s Dash so what does it mean if TI is going to read a value from in the schedu let us say data value is a right so whoever reads the initial value of a in one schedule should also read the initial value of a in the other schedule right that is the simple meaning of it which means whoever reads it first should read it first in the other side okay and the next one is if TJ produces final right operation of a in s then TJ should also perform the final right operation of a in s which means for every data item a whoever writes it in the last should write the should write it in the last in both the trans schedules got it and if TJ reads a value produced by T in s then TJ must also read the value produced by TA in s Das so we are using S and S Dash so where s s is a Serial schedule and S Das is a non- Serial schedule which means you can think of them basically as two different schedules okay now the third point is saying that if there is any WR dependency which means if one trans one transaction is writing let us say w i of a what does it mean I is writing data item a uh you know in the schedule now in one schedule if it is whatever is written by I let us say is read by J right so if they are like this which means whatever is written by I is read by J then in the other schedule also the same thing should happen whatever is written by I should be read by J right so basically in order to summarize this you can put it as if you know there are three simple points first thing is whoever reads first in one schedule should read first in the other schedule and the second one is who whoever write lost in one schedule should write lost in the other schedule and the third point is if there is any Rory dependency that should be in the same order that is the meaning of it okay now if two schedules are following these three rules then we can say that both are view equivalent now if one of the schedule happens to be non- serial and another schedule happens to be serial then we can say that that particular non- serial schedule is view serializable because there is at least one serial schedule to which it is equivalent to right okay now let's see this let's see this example now here we have two transactions and using these two transactions we have made two schedules right so let us say this is S1 and this is S2 now this S1 is completely a Serial schedule if You observe it right and S2 is not a Serial schedule now I want to find out whether these two are view equivalent or not okay whether these two are view equivalent or not now how to test it just see what are all the data items you have and compare both of them right so what are all the data items you have one is one data item is a is it visible one data item is a and other data item is B right now let's see who reads it first and who writes it last in both of them now I'm just writing it this way let us say in schedule S1 who who reads it first and who who writes it last okay so let's see this in schedule S1 who reads it first yeah T1 reads it first okay isn't it and who writes it lost if you look at a there is a right and again if you look at a there is a right so among all the rights to a the last one to write is T2 are you getting this who is reading it first T1 and who is writing it last T2 therefore I'm just writing it this way so for a T1 is reading it first in schedule S1 and T2 is writing it lost now I want to test the same thing in schedule S2 also right okay in schedule S2 I want to see who is reading and who is writing okay now see this in schedule S2 who is reading it first T1 okay fine and who is is writing it lost if you see this is right here this is not because there are only two data items if you see a is there and B is there that is why only I'm writing for two data items okay now for B who is reading it first so in s one look from here right so for B this one is reading therefore T1 is reading it first now who is writing it l go from the bottom and you see where is right of B so right of B is here therefore T2 is writing it lost okay now coming to this S1 S2 who is uh reading B first come from the B so here there is right so T1 is reading B first therefore T1 and who is writing this first lost who is writing B lost come from the bottom here you see it therefore T2 is writing it okay so first rule and second rule are satisfied so what what is first and second rule say whoever reads it first should read it first there and whoever writes it l should write L there right that is how we got it okay and now the third rule says that if there is any read you know WR read dependency that should be in the same order which means uh I'll just show you with an example now if You observe this here coming to data item a T1 is writing and T2 is reading isn't it this is what has happened now coming to data Item B also T1 is writing and T2 is reading got it now in the other side also same thing should happen so if T2 is reading from T1 other side also same thing should happen right coming to a see this coming to a here there is a read a who has written it because of this he's getting it right see this now whatever is written by T1 is being read by T2 right and then there is read B here and again there is right here which means for B also same thing has happened right therefore right redactions are in the same order so the third rule also has been satisfied so we can say that S1 is V equalent to S2 right now if You observe this S2 is a non- Serial schedule which is V equalent to a Serial schedule therefore we are able to find out a Serial schedule to which it is equal and to and so we can call that S2 is view serializable got it so S2 is view serializable okay fine now let's see this example let us say this is a non- Serial schedule given S3 is a non- Serial schedule given now I want to test whether this non- serial schedule is view serializable or not now how can I test it one I mean the basic method is using the rules that I have given you earlier you can write down all the serial schedules possible and you can test whether this one is view equivalent to any of these right if in case it is view equivalent to any of this then we can say that it is view serializable right even though it is a lengthy procedure just for this one example let's try it from next time onwards we shall use other methods okay so for now just just understand the procedure I want to find out whether this one is view serializable or not for that reason I have written all the serial schedules and now I'm checking whether this one is equivalent V equalent to this or not and then if it is not then I'll check with that as well okay fine now how to test view equivalent so same method that we have is earlier now for a whoever is writing read know writing here first or whoever is reading here first should read there first right now for a T1 is reading here first and T1 is reading here first no problem with that now what is the other one let's say for B for B whoever is reading here first should read there first now who is reading here first B is being read by T1 right and now here also being is being B is being read by T1 fine now for a whoever is reading lost now writing lost now if you see a here who is writing lost T2 right now if you see this side who is writing lost a so a is written here and here therefore T2 is writing lost and for B who is writing lost here for B lost right is here T2 and on the other side also forb lost right is here so first two rules are satisfied there are only two data items now whoever reads the data item first here is reading the data item first there and also whoever is writing the data item lost there is writing the data item lost there so that is not an issue now this third rule says that if there is any right rate dependency you should have happen in the same way now if You observe this what is the WR dependency is if someone is writing and someone is reading see this now right of a is being done here no one is reading here a and right of a is being done here and no one is reading a and similarly right of B is being done here no one is reading here and right of B is being done here no one is reading here therefore there is no right dependency here right now coming to this here clearly right of of a is done here but there is a read here which means write and read There is dependency isn't it see so clearly whatever is written by T1 is being read by T2 But If You observe this T2 is directly reading from the database it is not reading the value which is written by T1 therefore here it failed so we can say that this one is not equivalent to this one VI equivalent to this one right therefore but then you cannot here right away say that this is not view serializable it is not equivalent to this serial schedule but there is one more serial schedule which you might have to see right okay now let's test that one as well now here you understood that there is no righty dependency which means no one is write reading anything written by the other both of them are reading directly from the database now let's see this one here you can directly go to that point you need not know worry about other points or you can start with other points as well okay now what is the what are the three two points first two points for every data item check whether you know read is happening in the uh same way so who is reading here first a T1 now if you look at the other side a is being read by T2 first therefore it clearly failed here T1 is reading it there T2 is reading it therefore this one is not V equalent to that serial schedule so with two transactions only two serial schedules are possible and this non- serial schedule is not V and to any of the serial schedules possible so we can say that it is not view serializable but then if I have to test it this way for all the uh schedules it might take a lot of time the reason is see if you have three transactions then how many uh serial schedules are possible three factorial which means six serial schedules are possible and if I have to take every schedule and test whether it is you know view equalent or not then it is going to take know it is going to take a lot of time for me so that is why uh we shall see other better methods okay so let's see what is the relationship between conflict serializability and View serializability and then we shall compare both of them okay we shall see some easy methods let's come here now comparison between conflict e if the question is find out whether the uh you know schedule is VI realizable or not you found out whether it is conflict serializable or not now if it is conflict serializable you are saying that it is also view serializable but then if it so happens that if it is not conflict serializable then still there is a chance that it might be conflict realizable got it so that is where the problem is so uh you know that is the point that is the meaning of this point every conflict serializable is view serializable but the reverse is not true now the next question is it is easy to achieve conflict serializability than view serializability okay so I'll show you with examples why it is easy and it is also easy to test conflict serializability than view serializability we shall see why it is easy okay with graphs I'll explain you these two points now how we use it uh you know how we use the conflict realizability to test the view serializability is first thing is whenever they ask you for view serializability now test for conflict serializability right now if the schedule happens to be conflict realizable then we can say that it is definitely view serializable right if the schedule is not conflict serializable then you cannot say that it is not view serializable you have to test further right so for that reason we are going to use a New Concept called as blind right okay so now we test for blind rights now if there is a blind right then we test for view serializable if there is no blind right then we can directly say that it is not V serializable are you getting this so how do we use conflict serializability is first we test whether the schedule is conflict serializable or not if it turns out to be conflict serializable then we say that it is view serializable as well if if it turns out that it is not conflict serializable then you should not directly declare that you know it is not V realizable just test whether there are any blind rights if there are no no blind rights then you are lucky you can directly say that it is not VI realizable now if this is the case if there are blind blind rights then you might have to test whether it is view serializable or not now how to test it you can test using the earlier methods that I have discussed write down all the serial you know schedules and from that you can test it now we have seen that to increase efficiency of the server we are not going to run the you know transactions in serial order we are going to mix them up and run then when you're going to mix them up and run there are various schedules possible and only the schedules which are equivalent to the serial schedule are going to produce as the valid results otherwise the results may not be as desired then what we should do is we should be able to allow only the uh schedules which will give us correct answers right or consistent results but the problem is till now whatever we have seen the rules by which we are checking whether it is conflict realizable view serializable whatever we have seen we are testing after the execution of a schedule whether that schedule is you know equivalent to a Serial schedule or not but now the problem is while executing the schedule itself we should be able to find out whether by executing some operations we are going to violate this serializability or not now for that reason we are going to come up with some rules so rules are generally called as protocols a protocol is nothing but a rule isn't it now concurrency control protocols now it is nothing but concurrency control rules if you follow these rules you will be able to generate the schedules which are equivalent to the serial schedules now if you are going to execute any operation by which you might violate this rule let us say some serializable rule then then itself you know uh these rules will say that you are not supposed to do that action got it therefore by using these rules we'll be safe safe in the sense we'll be able to execute the schedule only if it is equivalent to the serial schedule right okay now what are the what are these rules are first one is there are some rules based on locks so locking means we are going to lock a data item at any level and then we can talk about when to lck when to release and who can access it and all these things so we shall discuss about it anyway now there are some log based rules now these log based Protocols are again of two types two-phase locking protocol again it is of four types basic 2pl conservative 2pl strict 2pl regress 2pl and again graph based protocol and then apart from locks we have timestamp based protocols so this is B basing on the you know values of the times at which you're accessing the data now time stamp ordering protocol and Thomas right rule so these are the two varieties which are available in those rules and the next set of rules are multi-granularity protocol and the next one is multiversion protocol in multiversion protocol also we have multiversion 2pl and multiversion multiversion now let's see uh about log based protocols the log based Protocols are mainly based on you know locking a data item before you access it and this lock has to be done appropriately for example if you have a data item let us say a and now you want to you know read it then you have to lock it and then read it and if you want to write it then you have to uh lock it and then write it but then reading and writing are actually two different kind of operations while you are reading the data you can allow some other transaction also to read the data but while you are writing the data till you finish that operation it is better you don't allow any other transaction to write on it you know otherwise there will be inconsistencies like that racek condition in operating system right so mutual exclusion and all so you know it is exactly the same as Mutual exclusion which we have done there uh in operating systems but here since we have read and write both of them so we are going to use two different logs so now we can assume that we have two different types of locking one is called as shared lock shared lock so shared lock means if you are going to read a data item then you are going to apply a shared lock on that right and this is also called as read loock which means it is mainly used for read loock and now if you want to lock uh a item using read log the command generally we use is loore R which means read lock on a all right and the other one is exclusive lock exclusive lock means if you want to write a data item then you take a exclusive lock on it and no one will be able to read or no one will be able to write that okay now it is also called as write lock it can be written like this loore w a so the conventions which they use to write the logs they vary from textbook to textbook and in the exam they'll clearly tell you what does it mean I mean they will say that loore R of a is locking a the data item a for reading right and locking datm a for writing exclusive and you know shared now what the relationship between shared and exclusive if you have shared log and exclusive loog let us say I'm writing it like this now if you already have a shade lock on a data item then you can have one more shade lock on the same data item which means if you if a data item is already logged under shared mode then someone else can request for shared lock and they can get it now if you have logged a data item in shared mode then someone else cannot lock it under you know exclusive mode so these two are not compatible got it so let me write s and no so X means exclusive s means X means exclusive locking s means shared locking right so these two are compatible which means if you are already having a shared lock yes you can ask for one more shared lock on that if you already have a shared lock you cannot ask for exclusive lock these are the general rules right which means any number of uh you know transactions can read the same data but then while someone is reading no one should update it that is the meaning of it and while someone is updating it no one should read it that is why if someone if a data item is already loged Lo under exclusive mode then again locking it under shared mode is not allowed right and it is also not allowed all right so from this table you should be able to understand that any number of transactions can read at the same time but then even if one of them is going to write then no other transaction should access it this is what is simple locking in simple locking we don't have anything else right now what are the problems with simple locking why do we need more features in simple locking is I'll take an example and explain you let us assume that we have two transactions T1 and T2 and one transaction is trying to transfer an amount of let's say 50 rupees from account a to account B and other transaction is trying trying to display a sum a plus b what is the total amount present in a plus b now this is what this is what both the transactions are trying to do now for that reason let us say there is a schedule possible in locking now the schedule is like this it is not a Serial schedule the schedule is like this T1 and T2 now T1 will take a lock on a and then T1 will first take a lock on a let us say loog exclusive of a which means T1 is going to take a lock on a and it is going to write a before writing it it will try to read it right so loog shade of a it is going to read the value of a right after locking it is going to read the value of a and then unlock a let us say unlock Shar of a all right which means we logged a and write the value of a and then we unlogged a and now at again lock a for exclusive and you try to decrement the value of a a = a - 50 and then release a so unlock a got it so now I unlocked a so what did I do I read the value of a and I decremented the value of a and maybe I have written the value of a right let me write it write the value of a and then unlock it okay so till this part I didn't do anything I just decremented the value of a by 50 right and now let us assume that by locking and unlocking T2 has at this point started this operation A + B now since it has released all the locks it has been holding on a T2 will be able to get a lock on a you know which is nothing but shared lock and get a lock on B which is nothing but shared lock and now it will try to display a plus b right now what happens is we are in the middle of the transaction now assume that initial amount that a has is 100 and initial amount that b had is 200 now after transferring a will have 50 rupees remaining and B will have 250 rupees remaining got it now the sum initially if you compute it is going to be 300 and the sum if you compute it later is going to be 300 right so any at any point in time if you compute the sum it has to show us 300 but now at this point if it tries to compute this sum this is going to show as since a has been decremented by 50 and this amount has not yet been added to B and at this point you trying to compute the a plus b you are going to get a number of I think 50 + 200 is 250 right so which means this is inconsistent right so you are going to see inconsistent data therefore by just lock getting acquiring the locks and then you know releasing them immediately in the simple protocol we are not able to produce consistent results cons inconsistent results are still possible now why do you think that this problem has occurred because you are in the middle of the work and you have released the locks too early if you would have hold the locks you know for some more time then this this transaction would have waited isn't it now you have released the lock on a therefore they are reading the temporary value of a which is not actually right isn't it or even though the value of a is permanent you should have waited for B right therefore releasing the lock too early in the simple locking case is going to give us the inconsistent results that is one problem right and the second problem you might see is there may be a deadlock so let us assume that there is simple locking and let not think about this transaction there are some other transactions T1 and T2 and some schedule may be possible like this let us say there is a transaction which is running and this transaction has acquired a lock lock exclusive a it has taken a lock on a right and now assume that on the other side someone has logged B right now assume that on the other side now B wants the next lock is transaction T1 wants exclusive lock on B and transaction T2 wants exclusive lock on a let's say there is some situation which which has got like this now what is the meaning of it is the data item a has been locked by transaction T1 right and then there is transaction t T2 and data Item B has been logged by transaction T2 right and now transaction T2 wants a lock on T1 and transaction T1 wants a lock on B right now if You observe this there is clearly a cycle because of which there is going to be a deadlock therefore if you just allow the simple locking to be done then there is a chance that there might be a deadlock even if it is not the exact way there might be some other way we might get into Deadlocks exactly the same way we have seen in operating systems right this is also a problem and also one more problem might be see you are getting the problems so if you just allow simple locking to be done then one problem is incur and results second problem is deadlock and the third problem is they might not always guarantee any um you know serializable schedules so what I mean by this is let us assume that we have transactions two transactions like this now transaction T1 has got a lock let's say exclusive lock on a and it is writing on a and then it has unlocked a right and then let's say transaction T2 has now asked for Shar lock on a and then it read the value of a and then it unlocked the value of a unlock the data item a and again here transaction T1 has obtained Shar lock on a and let us say it has again written the value of a and again unlock a so there might be some other you know actions in in between but what we wanted to see is what happens in this scenario the the main transactions which I want to see is this and now if You observe it there is a right dependency here and again R write dependency here right now this one is saying that this you know T1 then T2 this one is saying that T2 then T1 right so what is it there is a cycle possible here and so this is not going to be conflict realizable right so which means by going with the simple locking just locking and unlocking immediately right I might fall into various problems so there is even no guarantee that I'll always be able to get serializable schedules so something more has to be added to the simple locking protocols just providing the exclusive access to data items is not going to clear you know solve our problems yes it is going to solve our problems in some cases but then in some cases we might get into trouble so what are the three problems we might face one is inconstant data other is Deadlocks and the other one is serializability may not be guaranteed that is why we are going to add more things to simple locking we shall see it in the phase locking okay so we are going to have two-phase locking next fine now to the basic uh locking protocol we are going to add some more rules and then it is going to become two-phase locking protocol so in two-phase locking protocol what happens is you know uh it requires locking and unlocking can be done in two phases so one is called as growing phrase and other is called as shrinking phrase so whenever a transaction starts taking the locks it is not supposed to release the lock until it has acquired all the locks it needs so what I mean to say is now if you assume that this is the number of locks taken and this is the time now as the transaction starts it might have zero locks now slowly it is going to acquire some number of locks right and after it has acquired all the locks it needs let us say it requires 10 locks on 10 data items only after it gets all the locks then only it should start releasing the locks right so that is why there is going to be something called as growing phrase and then shrinking phrase right therefore that is why it is called as two phase so growing phase and then shrinking phase in growing phase we are going to obtain the locks and in shrinking phase we are going to release the locks right now transaction can obtain locks but not release the locks in growing phase got it and transaction can release the locks but not obtain the locks in shrinking phase now what is the advantage of this kind of you know mechanism is uh if you see why there will be some conflict I mean if a transaction if a schedule is not serializable is let us say there is some right here right on a right and again there is some read on a right and again there is some write on a something like this right then this one is let us say this is from transaction T1 this is from transaction T2 so this is what is going to create the problem isn't it it is saying T1 then T2 it is saying T2 than T1 that is why you're going to get a cycle Now by using this growing and shrinking phases right now if a transaction has written the value of a and again if it has to do some read or right here right it will not allow any transaction to come in the middle like this why because it is not going to release this lock and therefore this one cannot acquire that lock got it so by having this growing and shrinking phases we'll always be sure that as long as this transaction needs more locks it will not know release the locks and so no one can come in the middle into this all right so that is how it will be clear I mean it will solve that problem of serializability right so by using this two-phase locking we'll definitely get serializable schedule right okay I'll show you example how it is possible see here now if You observe this so so we are going to start with a see T2 has taken a Shar lock on a right and then T3 has taken a shade lock on a any number of transactions can take Shar lock and then T2 has taken exclusive lock on B and then it has started unlocking a see so if you look at the way it has started locking and unlocking now if You observe this it has acquired all the locks then only all the unlocks have begin right and on the other side if you see this it has taken all the locks lock on a lock on C then only it is going to unlock right here also after taking all the locks it is going to unlock right now by writing like this in case if there is any conflicting action let us say uh if you see any conflicting action assume that here I think there is no conflicting action I can I can form an example where there will be some conflicting actions like this now let us say there is loog exclusive on a all right and then we are trying to write on a okay and again at later point in time it has to let us say loog exclusive on B and then right on B okay now at this point if someone one tries to write on a and then write on B these two actions will not be allowed the reason is since lock exclusive lock is already taken by let's say transaction TI and transaction TJ right now since exclusive lock is already taken by transaction TI on a this action will not be allowed by transaction TJ because exclusive lock is already with transaction TI right and again if you see this since uh if if this has to happen right then definitely there has to be exclusive lock of uh you know on B by TJ but since here itself it has been blocked whenever you fail to you know acquire a lock you'll be blocked so since this transaction is blocked nothing will happen and so this will continue this way got it so that is why we don't have any serializability problem with this always our locking protocol two-phase locking protol is going to ensure serializability okay and what is the order in which you get the serializability is in order to understand that you have to understand something called as locking point so what is locking point is the point at which any transaction will obtain the Lost lock is called as locking point right so what is the Lost lock is Here If You observe it in these two the L lock is here therefore the Locking point for this transaction T2 is here right and in these two the L lock is here therefore the Locking point for the transaction T3 is here now in these two the L lock is here therefore locking point for transaction T1 is here now if You observe it the Locking points are in the order T3 T sorry T2 T3 and then T1 therefore this schedule will definitely be equivalent to the serial schedule which is given by the order T2 t 3 and then T1 got it so we we'll even be able to find out what is the serial schedule that this one is equivalent to right that is why this locking is two phe locking is important but then it has got two disadvantages so one disadvantages there is a chance that there might be a need of cascading aborts so what is cascading abort is now assume that you have written let us say ta has written some data and then let say I'll just give you some example let's say there are transaction like this T1 and then T2 now after obtaining locks only T1 has written some data okay so it has obtained a lock on a and then it has written a and similarly it has obtained lock on let's say B and then it has written some value on B and at some point it is going to unlock a and unlock B right now let us say after a has unlocked it T2 has read it which means it has taken a lock on a and it has read the value of a okay now at this point if T1 thinks about rolling back right if it is going to roll back right then this one also has to roll back got it therefore you are not making sure that only after the commit you are making the other one to read so other transaction can read even uncommitted data in two-phase locking therefore even though it is recoverable it might be cascading so there are some cases in which you might get cascading roll backs even with two-phase locking right and also there is a chance of Deadlocks so what the deadlock is now I'll just take an example about the deadlock here let us say there are two transactions T1 and T2 right now transaction T1 has obtained a exclusive lock on a and transaction T2 has obtained an exclusive lock on B and again transaction T1 now wants exclusive lock on B and transaction T2 wants exclusive lock on a the same situation which we have seen now both of them are in the growing phase therefore it is definitely pres possible in 2pl isn't it both of these transactions are in growing phase only so this kind of transactions and this kind of schedule is possible in 2pl now in 2pl If You observe it it is going to lead to deadlock why because T1 is having the lock on a and T2 is having the lock on B and T1 is waiting for a and T2 is waiting for B so that is where you are going to get the deadlock exactly the same way we have seen earlier right so what are the problems with 2pl is one problem is there is going to be deadlock and the other problem is there can be cascading roll backs but what is advantage of 2pl serializability is always guaranteed and the serializability order will be in the order of the lock points got it and what is the lock point the point at which any transaction obtained