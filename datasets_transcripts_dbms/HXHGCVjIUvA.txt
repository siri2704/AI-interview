hi everyone welcome to go classes in this session we are going to study relational algebra complete summary remember this will be complete summary and comprehensive summary of relational algebra so after watching this complete summary you can solve all the gate previous year questions from relational algebra topic okay so if you did not study relational algebra so far then also this this complete summary will help you solve all the gate previous year questions from this topic relational algebra okay so let's start now so let's see what is relational algebra this relational algebra this is a theoretical this is a theoretical query language for relational database model okay very simple remember this relation algebra this is a theoretical theoretical query language this is a query language means we want to rri the data from the database in database the data that you have stored okay we want to retrieve that data so this relation algebra this is a theoretical or I can say mathematical or I can say formal query language for relational database model okay so now let's see the recap of relational database model what is this relational data model let's see this so you already know that in the relational data model the database is collection of tables yes or no the database that is collection of tables every table table is called a relation okay and in a table what you have so in a table you have attributes and you have tles okay so you can see for example this is a table on your screen you can see this is a table this is the table name you can see table name is product and these are the attributes or I can say column names or I can say attribute names so you can see name price category manufacturer these are the attribute names and you can see these are the tles or I can say these are the records so remember you can call it rows or you can call them tles or you can call them records this is the actual data okay very simple so this is the idea that database is collection of tables every table is called relation and in a table you have attributes or I can say columns and there are tles tles means these are the records okay these are the this is the actual data I can say tles you can call it row or you can call it tles now you already know that every attribute has a domain from which it can take values okay every attribute for example this attribute has a domain I can say character string okay this attribute has a domain I can say integer or I can say real number okay real number so very simple every attribute has a domain and remember domain is set of atomic values every I can say every domain remember every domain is set of atomic values okay so all these things you already know so this is just a recap of relational model you can see this is another table this is another relational database model OKAY table and and you can call it relation every table is called relation you can see these are the attributes okay these are the attributes and these are the Tes okay very simple now so let me tell you that this is called schema okay you can see this is students table the name of the table is students the name of the table is students so here let me tell you one thing that this entire thing including the domain every attribute has a domain right this entire thing this is called schema this is called schema and remember these these tles okay this is called instance so very simple point that these tles or I can say these records these are called instances and remember this this entire thing means I can say table name attribute names and their domain okay this entire thing is called SCH schema so this is the difference between schema and instance okay what is instance this is the actual data I can say this is the actual data content and what is the schema this is I can say the structure the structure of the table The Logical structure of the data so you can see in this table you can see what is schema so let's see what is schema in schema you have name of the table okay and name of the attributes also the domain of the attributes so these three things they create SCH schema and this is your instance okay now so you can see here for example in your datab in your database let's assume there are three tables okay these are the three tables so this is esema because esema is logical structure of the data in your database what is the structure of the data so you can see in your database there are three tables these are the three tables user table group table member table okay so you can see in a schema what things are there so in a schema you have table name okay you have attribute name and domain name so these three things these three things they create the schema very simple and you can see this is the instance instance is the data for example look at the member table this is your member table schema okay this is the schema of the member table and and this is the data or I can say this is the instance you can easily see in the member table there are two attributes uid GID there are two attributes so you can see that these are the tles uid GID uid G okay so these are the tles you can see this is tle number one this is tle number two and so on okay very simple so this is instance okay and you already know that every table that is a set of tles yes or no so tell me order of tles matter or not order of tles does it matter the order of tles the order of tles that does not matter because remember every table every table is a set of tles and in a set order does not matter and tell me because it is a set of tles every table is a set of tles so is it possible you can have duplicate tles is it possible two tles can be exactly same it is not possible right because in the relational data model every table is a set of Tes so in a set the order does not matter also duplication is not allowed okay very simple now let's see what is a query language that you already know query language means basically we want to retrieve the data from the database okay now remember there are some query languages there are theoretical query languages and there is practical query language theoretical query languages these are two type of theoretical query languages are there one is relational algebra that we will study in this lecture another is relational calculus okay there are two type of relational calculus one is tle relational calculus TC another is domain relational calculus that is DRC okay so very simple there are two theoretical query languages I can say one is relation algebra another is relational calculus these are the two theoretical query languages and this is practical query language that is SQL okay this is practical all are retrieval remember all of them these are query languages means the data that you have stored in your database we want to retrieve that data okay very simple and all these query languages remember whether you have relational algebra relational calculus or SQL all of them they work on relational dbms they work on relational database model okay now we will focus on relation algebra so now let's see relation algebra procedural versus declarative what is the meaning of procedural language what is the meaning of declarative language and let's see this relation algebra this is what type of language whether it is procedural or it it is declarative so let me tell you that relation algebra this is procedural language what it means the name itself is telling you procedural means in the relation algebra query we specify step by by step we we we specify step byst step process to get the result okay very simple remember this in the relation algebra we specify step by step how to get the result and in the declarative language what we do we just specify what we want we don't specify how to get the result okay this is the difference so let me tell you the difference between procedural language and declarative language so let me tell you first of all let me tell you that relation algebra is procedural that is not declarative okay now what is procedural and what is declarative so let's see so let me tell you declarative language means in this declarative language we specify what we want okay we specify what we want without specifying how to get it okay but in the procedural language we specify what we want and also the steps to get the result okay this is the idea SQL is declarative and and relation algebra is a procedural let me give you one analogy you can see this is the analogy this if you want to make a cup of tea this is your task right okay I want I want a cup of tea this is the task now in the procedural language what we will do we will provide the step byst step procedure how to get this task done okay I want to get this task done so in the procedural language I will provide a stepbystep process how to get the task done okay so you can see procedural language which is a procedural language relation algebra is a procedural language in the relation algebra we specify step by step how to get the task done okay and in the declarative language what we do we just specify what we want we don't care how to get the result see we will just specify get me a cup of tea now we don't care how the how the person will do okay what are the steps taken to get this task done we don't care okay so this is the very simple Point declarative and procedural relation algebra is procedural in the relation algebra query we specify step by step process the step by step procedure how to get the task done okay in the declarative we just specify what we want we don't specify how to get the task done and you can see SQL is the example of declarative okay very simple now let's move on so we have seen what what is procedural and what is declarative and remember relation algebra this is procedural what this means this means that in the relation algebra query we specify exactly what steps to follow step by step procedure we specify how to get the task done we specify the exact steps okay to use very simple now let's see some important points before we start relation algebra these are important points and some students they have misconception so let me tell you the important points of relation algebra okay first of all this relational algebra in short I will write it R A okay this relation algebra let me tell you this works on pure relational model this works remember this works on pure relational model what that means okay what that means this relation algebra works on pure relation model what that means that simply means that these are the things first of all every table is a set yes or no okay every table every relation every relation or I can say every table is a set is a set okay what it means when I say set what it means it simply means no duplication of tles okay no duplicate tles there there we don't have any duplication of tles no duplication of tles two tles cannot be exactly same okay no duplication of tles also let me tell you in the relational algebra there is no concept of null there is no null values okay so remember when you study relation algebra you don't have to worry about null values okay in the relation algebra there is no concept of null values okay so very simple your input table will not have null values so these are simple simple points there is no duplication of tles and you already know that there will be there will be at least one primary exactly one primary key yes or no there will be one primary key okay there will be one primary key so these things you already know okay very simple so let me tell you that these are the rules for relation algebra first of all that every table is set of tles okay every table that is a set of tles set of tles means duplicate tles are not allowed and the Order of tles does not matter order of tles inside the relation that the that does not matter okay so very simple and remember there is no null values in the relation algebra this is important because I have seen many students they whenever they are solving any relation algebra question then they think about null values then they worry about null values okay they will put a comment on get or flow that what what if the input table has null values so let me tell you that there is no concept of null values in relational algebra you can see this is from a university this you can see this statement there are actually no concept of null in the relational algebra so remember whenever you are solving relation algebra question then you don't have to worry about null values yes or no it is a good thing right because null values they can create trouble okay in SQL we have seen that null values can create trouble okay very simple so you can see that there is no concept of n values in relational algebra okay now let me tell you that you might be thinking sir in relation algebra we have outer joints yes or no in the relation algebra there is a concept of outer joints this concept we have and in the outer joints there will be null values yes or no the null values are inserted when we apply the outer join do you agree with me pull outer join right outer join left outer join so you might be thinking sir in relation algebra we have concept of outer join and when we apply outer join then null values will be inserted then why I why am I saying that there is no concept of null values in the relation algebra can anyone tell me I am saying there is no concept of null values in relational algebra then what is the reason so let me tell you very simple that outer joints these are not considered part of basic relation algebra these are actually part of extended relation algebra is this clear the outer joints they are not considered part of basic relational algebra they are part of extended relational algebra is this clear also one more thing when you apply the outer joint remember the input table does not have null values okay the resulting table the final result that can have null values but the input table does not have null values okay but the actually important point is that outer joint that is not considered part of basic relational algebra okay so find I can say that these are the important points that relation algebra this works on relational model it means every table is a set set means order of tles does not matter there is no duplication of tles there are no null values and there is one primary key in every table okay so these are the simple simple points I hope you understood is this clear so tell me if you solve the gate question of relational algebra then will you worry about the null values let me know will you worry about null values no don't worry about null values because there is no concept of null values in relational algebra okay now let's get started now we will see The Operators and the syntax of relational algebra we will see okay so before that let me tell you that in this relation algebra what actually happens overall what happens let me tell you in this relation algebra overall this happens that see you have query okay this is your relation algebra query this is the relation algebra query and the input is what what is the input the input is tables yes or no the input is tables okay the input are instances or I can say relations relation R1 relation R2 and so on okay so remember the tables are relations and remember output what is that that is also a relation okay output is also a relation so very simple okay is this clear and remember every relation is set of tles so the input is also set of tles the output is also set of tles okay so let me write it here that the input is also set of tles and the output is also set of Tes in the relation algebra query okay you do not have duplicates remember in the input also in the output also because the input is also set of tles there is no duplication of tles okay the input is also set of tles and the output is also set of tles there is no duplication of tles very simple and the Order of tles does not matter okay so all these things are very very simple this is overall the structure of relation algebra query okay now let me tell you if you want to become expert of relational algebra then what you need to do let me tell you then you need to understand every operator clearly okay we will see in the relation algebra what are the operators each operator we will study okay so you understand each operator and once you understand every operator then what we will do then we will write and understand this relation algebra queries okay we will use the operators so first you understand what is an operator okay you understand each operator clearly and then we will see how to use that operator to write relation algebra queries is this clear very simple now let's see algebra operators in the relation algebra what are the operators so let's study that so let me tell you that in the relational algebra there are six basic operators you can see there are six basic operators in relational algebra these are the basic operators one is Select operator this is the symbol for select operator project operator symbol is pi cian product symbol is cross set difference symbol is minus Union symbol is U and rename symbol is row okay so remember these are the six basic operators is this clear these are the six basic operator we will study each of them one by one you understand each of them one by one and then we will see how to use them to write relational algebra queries okay very simple point so let me tell you the overall overview so the select operation what it will do this will select the tles this will filter the tles okay project operator it will filter The Columns it will select the columns Cartesian product it will join the two tables it will join two tables or I can say every tle of one table will combine with every tle of another table I can say you will combine two tables very simple set difference this is your set operator okay Union this is also your set operator you will do the union of two tables here you will do the set difference of two tables and here you will do the renaming of table or the attributes okay we will rename attributes and the relation so these are the six basic operations in relation algebra okay but there are some more operations in relation algebra there are there are some more operators like we have intersection we have natural join we have division we have Theta join okay and there are outer joints okay so these are additional operations now tell me one thing I'm saying these are the basic basic operators and here I'm saying these are the additional operators so tell me tell me are these not basic what is the meaning of basic and what is the meaning of these additional operators so let me tell you these additional operators these are derived at these are derived operators these are derived operators operators what that means that means these operations you can derive from the basic operations okay so let me tell you one thing that if you have these six operations then from them you can derive these four okay is this clear very simple so from these six basic operations you can derive these operations so that is the reason tell me if I remove from the relational algebra if I remove these facilities then can I say I'm decreasing the power of relational algebra from the relational algebra if I remove these facilities then am I decreasing the power of relational algebra the answer is no okay because remember what they can do they also can do okay from the basic operations you can easily create these operations okay so remember these additional operations or I can say these derived operations they do not add any power to relation algebra okay very simple so overall what we need to study we need to study these six basic operations then we need to study these derived operations okay simple now let me tell you one more thing some operations are unary operations and some operations are binary operations anary operation means they will take one table and output will be one table and some operations are binary operations they will take two tables output will be one table okay is this clear so remember some operations are anary operations and some operations are binary operations we will see which is anary which is binary but is this point clear that inary operation means the input will be one table output will be one table and in the binary operation input will be two table output will be one table okay remember basic operators these are the basic operators selection projection cross product Union difference renaming these are the six basic operators okay and remember these are the additional derived operators like join natural join intersection and so on Division and so on let's move on now we will study each operator by one first we will study selection operator what is this selection operator so let's see this understand this carefully selection operator let me tell you the symbol the symbol is a sigma okay the symbol is Sigma this is the name of this symbol that is Sigma this is small Sigma right this is big Sigma this is big Sigma but this is small Sigma so remember select selection operator the uh the symbol is Sigma or I can say small Sigma this is the symbol now what what is the selection operator this selection operator it will filter tles okay let me tell you what is the task okay what is the task it will do it will filter tles it will filter tles based on a based on a tle selection condition okay very simple this will filter tles based on a tle selection condition to section condition C very simple so remember the syntax is like this let me tell you the syntax the syntax is like this that you have this relation R okay and what we are doing we are selecting the tles we are selecting the tles based on a condition okay is this clear this is the syntax overall this is the syntax so here what is happening here remember this see this is a condition this is tle selection condition condition for tle selection I can say this is condition for tle selection which tle we want to select this is the condition for tle selection you can see this is your selection operator right agree okay this is the select this is the selection operator selection operation what it means it means we are filtering the tles we are selecting the Tes and this is your relation okay so here what will happen here the result will be those tles which satisfy condition C okay yes or no so very simple basically what will happen those tles which satisfy condition c will be in result okay so I can say those tles that satisfy okay those tles that satisfy condition C condition c will be in result will be in the result so very simple Point okay is this clear now let me tell you one more thing you can see look at this selection operation this is the condition and this is one table we are giving so you tell me is this anary or is this binary let me know is this anary or is this binary this is anary yes or no this select operation this selection operation this is anary Operation okay what it means it means that in the selection operation in the selection operation the input will be a table one table yes or no input will be one table another output will be one table very simple okay so and remember what it will do it will only filter tles very simple it will only filter tles it will only filter tles so the schema will not change yes or no we are only filtering the tles means the tles which will satisfy the condition C only those we will keep the remaining tles we will remove okay so the schema will not change yes or no the schema unchanged the schema remains unchanged okay but their data will change so remember the R1 R2 their schema will be same so let's see example you can see this is your table this is the user table now on this user table I'm applying this selection this is the selection condition you can see user table this is the select operation and this is the condition condition is po popularity is greater than 0.5 okay means remember remember I want those tles because this is tle selection condition okay this is your selection operation so this will select tles I want those tles where popularity is greater than 0.5 okay so remember this tle let's check this tle here popularity is greater than 0.5 so this tle will be selected this tle will not be selected this tle will be selected this tle will not be selected finally in the result there will be two tles okay did you notice the schema is not changing yes or no did you notice schema is not changing because we are just filtering the tles the tles which satisfy this condition will be selected and the tles which do not satisfy this condition will be removed so the schema will not change is this clear very simple so if this is your input table you apply this query then this will be your output table I hope this point is clear let me know is this clear understood okay one more thing one more thing remember this this tle selection condition we will apply on each tle individually independently okay this tle selection condition this we will apply on each tle independently and individually okay very simple so you can see here so this is your syntax you can see this is the table this is the selection operation and this is the condition and finally you can see the tles which satisfy this condition they will be in the output the remaining tles will be removed so can I say can I say that selection operation is doing horizontal partition of the table this selection operation can I say it is doing horizontal partition of the table notice this selection operation or I can say this Sigma I can say this is basically doing horizontal partition it is basically doing horizontal partition of table okay what that means see this means like this this Sigma c r okay so here what will happen if your input table is this let's assume this is your input table then you can notice the tles will be divided into two categories can I say okay can I say that on this table if you apply this query this query if you apply then what will happen then I can say the tles will be divided into two categories okay one category will be those which satisfy condition C and those which do not satisfy condition C okay you can see tles will be divided into two categories those which satisfy condition c those which do not satisfy condition C okay so very simple here I can say c not satisfied c not satisfied and these are the tou with C satisfied so I can say that this selection operation it is basically doing the horizontal partition of the table I hope this point is clear and in the output what you will have you will have those tles with satisfy condition C yes or no in the output finally I can say you will have these tles okay with satisfy condition C these tles will go to the output simple okay so this is the idea now let's see this if this is your table and we apply this query then what will be the result so you can see from the student table we are selecting tles where GPA greater than three okay remember this tle selection condition we will apply on each tle independently so let's apply this on the first tle so this tle will be rejected let's apply this on the second tle this also will be rejected let's apply this on the third tle this will be selected let's apply this on the fourth tle this will be selected so find fin I can say that you can see the result of this the result of this query will be this okay one more thing here you can see this result we are basically assigning to S okay this result we are assigning to S so the result will have this name s okay this is just a simple Point nothing here okay nothing important here but we are basically this result we are assigning to S okay so you can see this is the result very simple so we have seen this selection operation input is one table R okay so this is anary Operation I can say input is a table R so I can say this is an operation okay and this is the notation here you can see this P this is the seel tle selection condition okay and what is the purpose purpose is filter rows based on the condition the schema will be same as the input so you can see for example if this is your table R then tell me if I apply this query then what will be the output what will be the output of this query this is the table so you can see on this table R this is the tle selection condition a is equal to B and D greater than 5 remember this tle selection condition we will apply on each tle independently so let's apply this on the first tle will it be selected or rejected this will be selected right because you can see D greater than 5 and a equal to B so this first tle will be selected you can see this first tle is selected next this second tle this will be rejected because you can see a is not equal to B this tle will be rejected because D not greater than 5 this tle will be selected so finally this will be your output very simple you can see that the schema is not changing so that's it now let me tell you one more thing about the tle selection condition what you can write in the tle selection condition what is allowed in the tle selection condition so let me tell you that the tle selection condition so you can see Sigma this P this is the tle selection condition and this is the table name r okay so let's see what we can write in this p in this P basically we can write like this these things we can write okay remember here we can write and or or you can write for example either and you can write or you can write or okay so different conditions you can join with and or or okay very simple and you can see here what we can write here we can write for example attribute is equal to attribute or you can write for example attribute is greater than some constant okay attribute is greater than some constant okay or you can write for example attribute is less than equal to some constant okay so like this I hope you understood so remember in the tle selection condition these type of things are allowed okay very simple so here you can write for example you can see attribute comparison operator uh attribute comparison attribute or you can write attribute comparison constant attribute comparison constant and these different different conditions you can join with and or or so that's it this is your tle selection condition so remember in the tle selection condition we can write these and or not these things we can use and okay you can see attribute operation attribute or I can say attribute operation constant okay and these symbols we can use for comparison these symbols we can use okay so very simple point I student is asking can we write C greater than D yes no problem see attribute comparison attribute C greater than D that is also fine attribute comparison attribute see look at this look at this attribute comparison attribute okay you can write these comparison these comparison operations okay is this clear let me know attribute comparison attribute these comparison operations you can use or you can write attribute comparison constant okay attribute comparison constant here again you can use these operations okay you can see here look at this query in this query what is happening see in this query this is happening Sigma from table R basically what we are doing here you can see that a should be equal to B and and this is the symbol for and okay this is the symbol for and okay so this is the symbol for and and this is the symbol for or and this is the symbol for not so you can see this and D greater than 5 is this clear so like this a equal to B and D greater than 5 okay let's move on so we have seen these simple simple points for example if this is your table then what the output of this query you can see from the sales table this is your sales table you can see we are selecting tles which satisfy this condition where bar is equal to Jo okay so you can see bar should be equal to Jo so these two tles will be in the output in the output these two tles will come and these remaining tles will be rejected you can see the input and output they have same schema schema is not changing okay tell me the answer for this qu this question let's see select the toles for all employees who work in Department 4 and make over 25,000 per year or work in Department 5 and make over 30,000 then how to write the query I want to write the query for this so how to write very simple remember we want we want to select tles from all employees so there is a employee table there is a employee table from this employee table I want to select tles I want to select tle and what is the tle selection condition you can see this is the condition that either they work in Department 4 and make over 25,000 means either this should happen or or this would happen okay there is or here so either so you can see what can happen I I can say they work in Department 4 means department number is equal to four okay either this should happen department number is four and and you can see salary salary is greater than 25,000 or or department number is five and this salary this is greater than 30,000 okay so this is the query is this clear very simple you can read so this is the employee table this is the select operation you can see either this would happen or this would happen Okay department number four and salary more than 25,000 or Department 5 salary more than 30,000 okay so very simple like this you can write now let me tell you one important point that is that selection condition this SEL this tle selection condition remember that is applied on each tle independently individually is this clear so remember this tle selection condition when you apply on any tupple at that time assume that you don't know other tles is this clear the tle selection condition remember very important point this tle selection condition this is applied on each tle independently individually okay on one tle at a time so when you apply this on any tupple then assume that the remaining tles you don't you cannot see the remaining tles you cannot see is this clear so very simple the tle selection condition is applied independently to each individual tle in the in the relation R okay now now let's see some more things let's see some results let's see some results okay if you apply this query if you apply if you run this query now now you tell me first of all you tell me the schema will change or not what will be the schema of this result the schema is unchanged yes or no okay I can say the schema unchanged so the schema of input and output that will be same SCH schema will be UNC what about the cardinality what about the cardinality and what about the degree you tell me about degree degree or I can say arity you tell me about aity will it be same you tell me about degree arity okay what about this will it be same degree means number of attributes right yes or no degree means number of attributes you already know degree means number of attributes so degree means number of attributes now you can easily see that degree degree of this output degree of this output will be same as degree of r because the schema is not changing okay number of columns is not changing so degree will be same what about cardinality what about cardinality what is cardinality that is number of tles yes or no that is number of tles so you tell me about cardinality number of tles what relation I can write I can say that cardinality of this result cardinality of this result and cardinality of R what is the comparison let me know what is the comparison the comparison is the result cardinality will be less than equal to the cardinality of R yes or no okay less than equal to can it be more than for example is it possible you can put more than is it possible no this is not possible okay because some some tles you can remove we are not adding any tles yes or no some tles we can remove we are not adding any tles so very simple cardinality so the cardinality of the result will be less than equal to cardinality of R okay so these simple simple points we have already seen you can see this that cardinality of the result that is less than equal to cardinality of R and remember number of attributes that is unchanged okay number of attributes that is same as number of attributes in R so the degree is is unchanged the schema is unchanged select operator is a operator it will apply on each tle individually okay the selection operation will apply on each tle individually all these points we have seen are you comfortable please tell me look at this query tell me is this query correct or not look at this query look at this query and tell me is this query correct or not this query is wrong okay this is wrong why tell me why because I told you that I told you this tle selection condition is applied on each tle 1 by one independently okay so we cannot write like this that every popularity in user table okay because remember the tle selection condition this selection operation this is applied to each tle individually independently okay so when you apply this selection operation when you apply this on any tle then assume that you cannot see the remaining tles okay so this type of query is wrong let's move on now is selection operation commutative tell me is the selection operation commutative what it means let me tell you what it means it means that if I do this for example this is your table R let's assume I apply this Sigma condition one and then on this I again apply Sigma condition two okay will it be same as will it be same as on this R if I first apply condition two then I apply condition one will they be same are you understanding the difference I'm asking is the selection operation commutative means means this query and this query will they be same on the table are first I apply condition one then I apply condition two and here first I apply condition two then I apply condition one will they be same the answer is yes the answer is yes okay because see this is very simple tell me what this means you have a table R okay first you want those tles with satisfy condition C1 okay we want those tles which satisfy condition C1 then I want those Tes which with satisfy condition C2 then overall what I'm doing tell me here overall what is happening which tles I'm getting you tell me me which tles I will get a simple question I'm asking which tles I will get from this table are first you first you want those tles with satisfy condition C1 so this will give me those tles with satisfy condition C1 then I'm getting those tles with satisfy condition C2 so overall which tles I'm getting overall I'm getting those tles where C1 and C2 both conditions are satisfied do you agree with me do you agree with me basically overall I want those tles where C1 and C2 both conditions must be satisfied okay here I have those tles which satisfy both the conditions first you satisfy condition C1 then you satisfy condition C2 so overall these two conditions both of these two conditions you satisfy so now you can easily see okay now can you notice they are same this will be same as what here also both the conditions you need to satisfy is this clear so overall I can say that Sigma whether you apply this C1 first C2 first the result will be same as whether you apply C2 then C1 okay basically both will be same is this explanation clear please tell me did you understand and will you forget it will you forget it or not let know just understand the logic don't buy heart if you buy heart you will make mistake just understand the logic what is happening so did you understand this see understand the first line because here basically we want those Tes which satisfy condition C1 and C2 here also the same thing so finally I can say these two are same okay is this clear so remember important property of selection operator what is that that is commutative important property this is the important property property that selection operation is commutative means Sigma C1 okay inside your have Sigma c2r that will be same as that will be same as Sigma C2 Sigma c1r and both of them will be same as what both of them will be same as C1 and C2 both of them will be same as Sigma okay uh this C1 and c2r so this is the property so this is the important property basically I can say this property is called commutative property okay yes or no look at this this is called commutative property so selection is commutative selection is commutative understood very simple right okay let's move on now can I do the same thing if I have many Sigma Sigma Sigma like this can I can I do the same thing for example if I have let's assume I have Sigma P1 okay then inside I have Sigma P2 okay then inside I have Sigma P3 okay like this okay any number of Sigma I can have yes or no this will be same as what you can change the order no problem okay yes or no you can change the order no problem basically overall this will be same as Sigma P1 also must satisfy and P2 and P3 all of them must satisfy all of them must satisfy P1 and P2 and P3 all of them must satisfy so very simple okay so these are the properties you can see properties of selection operation okay so this selection condition we will apply to each tle yes or no we will apply the selection condition to each tble independently okay this is an operation the degree will remain same the schema will not change number of Tes in the result is less than equal to number of tles in the input okay yes or no commutativity is there so you can see condition one condition two that is same as condition to condition one okay yes or no so all the results we have seen also we have seen this for example you can see Sigma C1 Sigma C2 Sigma CN that is same as Sigma C1 and C2 and CN okay so all these important properties we have seen so this is your selection operation we have completed it please tell me understood now we will study projection operator we have done the complete analysis of Select this selection operator all the important properties everything now let's study the next operation that is projection operator what is this projection operator so let me let me tell you the symbol first of all let's see the symbol symbol is pi the symbol is pi this is the symbol and and the syntax is like this syntax syntax is like this Pi then you have some list of attributes for example A1 A2 these are the attributes okay or maybe A1 A2 A3 so you have list of attributes and R okay so let me tell you what this projection operator does basically it IT projects attributes or I can say basically it will project attributes or I can say it will filter attributes okay remember it will filter attributes it will filter columns it will filter columns is this clear it will filter columns means from the table R basically we just want these three attributes we are filtering the attributes okay yes or no we are filtering the attributes this is called attribute list this is called attribute list okay is this clear so from the table r we only want these three attributes so this is the simple Point okay so now let me tell you for example let's assume you have table R and in this table R let's assume you have these attributes a b c okay and these are the Tes you have for example 1 1 2 1 13 okay 1 12 1 this is your table R now if I run this query okay if I apply this query that I want only these two attributes a B from R from r i want only attributes AB then what will be the output tell me in the output how many tles will be there I only want AB how many tles will be there I only want a remember only these two attributes I want so the answer will be the answer will be 1 one 1 two okay remember duplicates will be removed yes or no remember duplicates will be removed because in the relational algebra the table is set of tles okay the input and output all the tables they have set of Tes so means duplication is not allowed you cannot put duplicate tles very simple so this is the idea okay so tell me one thing is the schema changing is the schema changing this schema and this schema are they different yes they are different schema is changing also the cardinality can change yes or no also the cardinality can change here cardinality 3 here cardinality 2 so schema is also changing and cardinal also can change okay so very simple this is your table R now what the output of this query this is the projection we are projecting AC from R we are projecting AC remember we are only projecting AC so you can see alpha 1 okay alpha 1 beta 1 beta 2 so your answer will be this okay is this clear very simple so this is the projection in the projection what we are doing we are filtering the attributes so can I say projection basically that is a vertical partition can I say projection is vertical partition tell me can I say this projection this is basically vertical partition vertical partition because what is happening C very simple that if this is your table r then this is the table R then remember the attributes you can divide into two categories yes or no the attributes you can divide into two categories we can divide attributes into two categories these are the projected attributes these are the projected attributes okay yes or no and these are the filtered out or I can say these are the removed so very simple so I can say that this projection this is basically vertical partition of table simple okay for example if this is your table and I only want the name attribute okay yes or no I want to project name attribute this pi means project so from the student table from the student table I want to project only the name attribute then this will be the output okay and remember again the same thing this result you are assigning to s means basically this result we will call it s we will call it s very simple okay so this is projection again this is anary or binary let me know is this anary or binary the input is single table R so this is anary the input is single table R you can see this is the syntax what is l l is a list of attributes okay very simple what is the purpose purpose is output the chose output The Chosen columns very simple okay if this is your input table let's see this example if this is your input table and then what the output of this query what the output of this query basically we are projecting pi means project we are projecting these two attributes uid name these two attributes we are projecting so this will be your output simple okay so we have seen this this is the projection this is the list of attributes you can see this is your user table and I want to project a yes or no pi means projection I want to project this this attribute a okay so you can see duplicates will be removed remember so in the output there will be only two tles you can see okay duplicate tles they are removed by definition okay eliminate the duplicates if there are duplicates eliminate the duplicates you can see if this is your input table and I run this query okay then what is the output of this query very simple pi means project I want to project these two attributes beer comma price beer comma price these two attributes I want to project then again duplicates will be removed here you can see this and this first and third tle they are duplicates so duplicates will be removed okay so you can see this will be the result in the result we will have three three tles so that's it we have seen this now let me know some important points again some results if I apply this Pi l r what is L this L is basically attribute list this L this is attributes list okay so you tell me the schema will change or not let me know the schema will change or not what will happen to SCH schema schema may change yes or no SCH schema SCH schema may change okay second what about degree let me know about the degree the degree of this result what can you say about the degree of this result and what can you say about the degree of R what can you say what the relationship between them the relationship between them that is less than equal to yes or no very simple what about the cardinality what about the cardinality of this result okay means I asking the cardinality of this result can I say that will be same as cardinality of R can I say no it will be less than equal to okay don't say it will not change because duplicates will be removed yes or no duplicates will be removed because duplicates are going to be removed okay for example consider this if you have a table R and in this table R let's assume you have a b okay 1 2 1 3 1 4 4 2 4 now look at this then tell me what will be the cardinality of Pi a r just tell me the cardinality of Pi a r let me know what the cardinality of Pi a r that will be two yes or no okay because when you project the attribute a then only two tles will be there the duplicates will be removed yes or no the cardinality of R is actually Four okay and and what the cardinality of pi b r that will be three yes or no okay is this clear so remember the cardinality of this result this projection result that will be less than equal to cardinality of R is this understood please tell me now tell tell me the answer for this question to make sure that cardinality of projected relation is necessarily same as the input relation for every instance then what can you say about the attribute list please tell me I want to make sure that cardinality does not change cardinality of projection does not change for every instance the cardinality of the projection does not change okay then what can you say about the attribute list very simple if the cardinality of projection should not change then it means in the attribute list we must not have duplicates yes or no do you agree if the cardinality of projection should not change then it means attribute list must not have duplicates so I can say this must be a Super Key okay yes or no so this must be a Super Key if the attribute list is super key then you can see the cardinality of input will be same as the cardinality of the output okay is this clear let me know understood so very simple Point remember this you have relation R okay and I and consider this query consider this query now you can see if if L is super key if L is super key then what will happen then this will definitely happen that cardinality of cardinality of this result will be same as cardinality of R is this clear if L is super key okay so very simple the same thing you can read here from the navate book the same thing that I I told you that is written here you can read it is projection operation commutative please tell me is the projection operation that is commutative means what I want to ask I want to ask Pi first let's assume I apply some attribute list on R and then then I apply some other attribute list okay can I say this will be same can I say this will be same if I do this L1 and here L2 think about it and tell me will they be same will they be same the answer is no the answer is no okay because see very simple Point let me give you one example consider this R in this R let's assume these are the attributes a b c d okay now just consider consider this Pi on this R let's assume first first I'm projecting ABC then then I'm projecting AB okay is this clear now you tell me so this is your L1 and this is your L2 so tell me will it be same if I write like this if I write like this here I write L1 and here I write L2 are they same let me know are they same this is not even valid yes or no this is not even valid invalid yes or no this is invalid so remember that this projection operation is not commutative is this clear did you understand projection operation is not commutative you cannot commute you cannot commute the projection operation you can see this is invalid first you are projecting AB then you are projecting ABC that is invalid why this is invalid first you are projecting AB now here you only have AB attributes consider this here you only have AB attribute from Ab attribute can you project ABC from Ab can you project ABC no okay so that is the reason this is invalid I hope you understood is this clear so this projection is not commutative okay now let me tell you a property of projection operator and this is important property so it is like this just think about it and tell me let's assume you have this a c d this is your table and let's assume that PI from this R first I'm projecting ABC okay and then I'm projecting AB okay can I directly project AB can I will it be same as if I directly project AB this is my question if I directly project AB will this be same think about it this is your let's call it this is your L1 let's call it L2 okay tell me think about it and tell me can I directly project AB the answer is yes the answer is yes okay just think about it the answer is yes why see first I'm projecting ABC okay here I will get ABC here I will get ABC then then I will get AB overall ultimately what you are getting tell me finally what you are getting finally we are getting all the tles of ab finally we are getting all the tles of ab all the tles of ab we are getting or not here we are getting all the tles of ab so the same thing I will get here all the tles of ab and remember duplicates are not there so you don't have to worry about duplicates because duplicates will be removed okay so you can see here I'm getting attribute AB here also I'm getting attribute AB so this is the property of projection what the property let me tell you the property is like this if you apply like this Pi okay first let's assume you have Pi L1 on R and then let's assume you apply Pi L2 first you tell me if this is valid query then what should be relation between L2 L1 a very simple question I'm asking if this is valid query then what is relation between L1 L2 L2 is subset of L1 right yes or no okay this is a simple thing you can see okay I'm asking if this is valid to be valid to be valid okay what will happen the L2 must be subset of L1 okay if this should be valid is this clear is this understood because this L2 must be subset of L1 very simple Point okay now you tell me that so here I can say this if if L2 is subset of L1 then can I say that I can directly project L2 yes or no I can directly project L2 okay but this would happen that if L2 is subset of L1 then I can directly project L2 is this clear is this understood please tell me let me know simple right so let's move on now so you can see this is the project operation that is anary Operation okay the degree the degree will be the degree can change yes or no I can say the degree will be same as the number of attributes in the attribute list the degree of of the result will be same as number of attributes in the attribute list very simple okay number of tles can change because of duplicate elimination commutativity does not hold for project operation also you can see if L1 is subset of L2 if L1 is a subset of L2 then I can directly project L1 all these properties did you understand let me know now let's see properties of selection and projection operation first tell me this property we have already seen selection operation is commutative we have already seen selection operation that is commutative yes or no this point this point we have already seen that selection operation is commutative this is same as this is same as this and this is same as C1 and C2 R so selection operation is commutative this we have already seen here you can easily see that okay you can see Sigma P Sigma QR that is same as Sigma p and QR okay so selection is actually commutative okay whether you have Sigma P Sigma Q or you have Sigma Q Sigma P both are same okay so this we have seen we have also seen this if you many in a sequence if you have many uh selection like condition one condition two condition n then overall you can say condition and condition two and condition n okay so these simple simple points we have already seen what about projection operation that is not commutative yes or no projection operation is not commutative this point also we have seen okay so if you have let's assume Pi L1 Pi L2 R then this this is not same as P L2 P L1 r okay simple so here you can see and this point we have seen that if a is subset of B then can I say this property will hold if a is subset of B then can I say this property will hold yes yes or no if a is subset of B then I can directly project a I can directly project a so you can see if this list one this is subset of list two then I can directly project list one so these properties we have already seen now let's move on can we commute selection and projection operation this is my question next question can we commute selection and projection what this means basically I want to ask you that let's assume you have this selection first first you are applying selection then you are applying projection can I say this will be same as can I say this will be same as first I apply projection and then I apply selection please tell me will it be same as this will they be same can I say they will be same can I commute selection and projection this is my question can I commute them let me explain with help of one example consider this table okay in this table I'm giving you so let's consider first I'm doing this selection a equal to Alpha from R okay and then I'm projecting I'm projecting the attribute C I'm projecting the attribute C okay now tell me what will be the result of this query and what will be the result of this query first I project attribute C and then I apply condition a equal to Alpha now tell me what will be the result of this query and what will be the result result of this query please tell me what is the result of this query the result of this query that will be first you filter tles where a is Alpha so these two tles will be selected yes or no these two tles will be selected then I want I want to project attribute C so output will be basically output will be like this output will be 15 what about this query what I'm doing I'm commuting them yes or no I'm swapping them so if I swap them now tell me this is actually invalid yes or no this is invalid because here you have attribute a sorry here you have attribute C can you apply this condition yes or no very is simple so remember this will be invalid query so can I commute can I commute selection and projection tell me can I commute selection and projection let me know the answer is no okay can I commute selection and projection the answer is what the answer is no I cannot commute selection and projection is this clear please tell me you can see this example you can see here this query is fine this query is fine but if I commute them if I swap them if I swap then you can see this query is invalid because here you will have attribute C can I apply this condition on attribute C this condition can I apply on attribute C the answer is no so you can see this is invalid okay so I can say that you cannot swap I can say you cannot commute selection and projection but now consider this now consider this situation I'm applying the condition on let's assume a okay I apply the condition on a now I project I project let's assume a comma B okay is this clear I project a comma B now let me swap now let me swap so first I project a comma B and then then I select a equal to Alpha okay now you tell me will they give the same result did you notice what I'm doing I'm commuting select comma project okay you can see I'm commuting select comma project so you tell me now will they give the same result yes now they will give the same result okay first here you can see those tles where a is Alpha so here these two tles have Alpha okay these two t they have Alpha then projecting AB okay so here the output will be like this here the output will be alpha alpha alpha beta okay yes or no and what about this first I project AB first I project AB first I project this I project AB then where a is Alpha then where a is Alpha okay first I project ab and then where a is Alpha so finally I can say alpha alpha alpha beta are they same yes they are same so tell me why they are becoming same did you notice you can see in this example I can commute okay but in the previous example I cannot commute like in this example I cannot commute did you understand Did You observe the difference between this example here I cannot commute these two projection comma selection I can cannot commute let me tell you the reason the reason is like this because the selection condition is not on this attribute list yes or no did you notice this attribute list is different and this selection condition is on a different attribute this selection condition is on a different attribute this is on attribute a and this this attribute list this does not contain a okay and now notice here notice here the this attribute list contains ab and the selection is on attribute a so in this situation I can swap I can commute okay so let me tell you that this is the question can we commute selection comma projection the answer is no okay remember the answer is no the answer is no it means if I give you this equation if I give you this equation p l Sigma c r will it be same as Sigma C pi LR will they be same the answer will be the answer will be no okay the answer will be no but now notice if I give this condition okay if if C uses attributes of L if C uses attributes of L remember if C only uses attributes of L I can say if C uses of attributes of L only then tell me okay if C uses attributes of L only now remember now they will be same for example now if I write now if I write this Pi L Sigma c r now this will be same as Sigma C pi LR okay is this clear let me know did you understand simple Point okay so this is a simple Point remember and this is important in the gate exam they can ask you this this is simple point that if this C if this condition C if C uses if C only uses attributes of list L okay is this clear then then remember we can commute then we can commute then in this situation whether you have this P LR this will be same as p l Sigma CR okay the example we have already seen but let me give you one more for example for example what about this what do you think can I commute just look at this condition and this is the list now tell me can we commute do you think we can commute this is condition C this is condition C and this is list L what do you think can we commute can we commute or I can say swap can we commute Pi comma Sigma the answer will be yes let's check it let's check it okay let's check the result of this and let's check the result of this you tell me are they giving the same result let's check the result of this one are they giving the same result see what this result what is what this query will give what result this query will give first you are selecting tles where rating is greater than 8 from S2 this is your S2 from S2 we are selecting tles where rating is greater than 8 we rating greater than 8 so this will be gone this will be gone these two Tes will be gone remember yes or no because here rating is not greater than eight so these two Tes will be selected and then we are projecting s name rating so the output will be output will be S name rating the output will be like this okay the output will be like this the output will be you can see s name and rating so that will be yepe rating is nine Rusty rating is 10 okay what about this query what the output of this query first we project s name rating first we project s name rating first we project this then we select tles where rating is greater than 8 then we select this tle and this tle did you notice we are G we are getting the same output this query is also giving the same output s name rating yes or no is this clear please tell me did you understand let me know is this point clear so they are giving the same output I hope this point is clear to everyone let me know okay so finally I can say this is the note the note is very simple that if if C if C uses attributes of L then we can commute yes or no if C uses attributes of L only then we can commute okay then what we can do then we can commute for example in this situation this query will be same as this query okay understood let me know is this is this clear to everyone please tell me so very simple Point here you can see if the condition uses attributes of a if this condition P uses attributes of only a then we can commute then we can commute okay yes or no is this clear simple then you can see we can commute okay let's move on now so these are the properties of selection and projection let's see these properties look at these properties and tell me did you understand all of them these are important in the gate exam they can ask you many questions based on these properties for example did you understand this that Sigma C1 Sigma C2 r that is same as Sigma C1 and C2 R commutativity of selection Sigma C1 Sigma C2 is same as Sigma C2 Sigma C1 yes or no and we have already seen if if this attribute list is subset of this attribute list then we can directly project this attribute list yes or no so the third property third property also we have we have seen and the fourth property also we have seen if this attribute list includes the attributes of C then we can commute Sigma comma Pi so all these properties we have seen I hope you understood is this clear let me know let's solve this gate 1998 question this is a very beautiful question which of the following query transformation means replacing the LHS expression by rhs expression is incorrect which of the following query transformation is incorrect you are replacing LHS with rhs then which of the following transformation is incorrect R1 and R1 and R2 these are relations C1 C2 are selection conditions A1 A2 are attributes of R1 okay now the question is asking which of these transformation are correct okay so let's see the first one the first one is saying Sigma C1 Sigma C2 can I replace this with this yes we can do that actually LHS and rhs are actually equivalent we already know this okay let's look at option A what option A is saying option A is saying that if you have this query if you have this query can I replace this query with this query can I do this can I replace yes we can replace okay very simple you already know actually this LHS is actually equivalent to rhs okay so you can replace this also you can replace this also both are fine okay you can replace in this direction also you can replace in this direction also both are fine because actually LHS and rhs they are actually equivalent we have already seen that this LHS this is same as Sigma C1 and C2 of R similarly here this is same as Sigma C1 and C2 of R so you can see they are actually equivalent means if you have this query I can replace with this query and if you have this query I can replace with this query okay both are fine is this clear so I can say this transformation is correct this is actually correct transformation what about option b option b is saying Sigma C1 Pi A1 this query I can replace with this query okay let's see option b option be saying Sigma C1 Pi A1 r i can replace this query with pi A1 Sigma c1r okay so tell me can I do this replacement this replacement can I do okay before anything you tell me are they equivalent I'm asking are they equivalent this LHS and rhs are they equivalent can I say they are equivalent LHS and rhs are they equivalent please tell me are they equivalent they are definitely not equivalent okay they are definitely not equivalent the answer is no they are not equivalent right we have already seen that they are not equivalent okay now you tell me they are not equalent but the question is not asking about the equivalence please understand the question is asking about the transformation the question is saying that if LHS is valid query then can I replace this with rhs in your system let's assume you have this query in your system then can I replace that query with this query so one assumption automatically you will make that LHS query are valid do you agree with me do you agree with me see very simple point the question is asking about the transformation the question is saying that this query can I replace with this query so it means this is already a valid query now we are replacing this query with this query yes or no is this clear so this is a beautiful question because the question is not asking about the equivalence see here LHS and rhs they are not equivalent but the question is asking if this is a valid query can I replace this with this query is this question clear to everyone in your system let's assume you have this query already this query is already there okay now to make your system efficient maybe okay maybe efficient or inefficient doesn't matter but to basically this query can I replace with this query and will I get the same result will I get the equivalent result did you understand the question let me know so remember in this option b this is your option b can I replace this with this in this option b actually LHS and rhs actually they are not equivalent but the question is not asking about equivalence the question is saying can I replace this with this so you tell me if this is already valid then what it means just think about it if this is already valid if this is already valid if this is valid if this LHS is already valid then what it means it simply means C1 is using attributes of A1 do you agree with me if this query is already valid query in your system you have this query so this is a valid query in your system now we want to check can we replace this query with this query so first you tell me if this query is already valid query then it automatically means what it means this C1 is using attributes of A1 yes or no then I can say then C1 uses attributes of attributes of A1 only okay now in this situation in this situation when C1 is using attributes of A1 only then definitely we can replace this query with this query we have already seen in our lecture okay previously we have already seen this agree with me please tell me is this question clear so option b this transformation is correct remember this transformation this is correct okay because if this is already valid it simply means that C1 is using attribute roots of A1 and in this situation definitely I can say remember in this situation in this situation this query this query will give you the same result yes or no in this situation this query this query they are same so very simple this transformation is definitely correct okay let's see the remaining let's see option C option C is Sigma C1 R1 Union R2 okay and here Sigma C1 R1 Union Sigma C1 R2 the these are actually equivalent this LHS and this rhs they are actually equivalent again here also in option C let me tell you in option C they are actually equivalent see option C is saying that you are doing Sigma C1 you are applying some condition on tles of R1 Union R2 what is R1 Union R2 this is the union of Union of both the tables yes or no so in this you will have all the tles of R1 all Al all the Tes of R2 okay you just tell me one thing can I say this is equivalent to this think about it and tell me are they same are they same let me know see just think about it if any tle is here can I guarantee that tle will be here okay see very simple Point sorry this is C1 this is a C1 okay because you can see here you can see Sigma C1 Sigma C1 Sigma C1 okay so tell me here in this option C you tell me if any tle okay so I can say here this is C1 very simple question I'm asking let's assume there is a tle here can I guarantee that tle will be here also okay let's assume there is a tle here this tle T this tle T is here it automatically means what in this result you have tle t it means what this tle is either in R1 or R2 and it satisfies condition C1 can I say this T T1 satisf uh this this tle T satisfies C1 do you agree in this result you have tle t what it means it means T satisfies C1 T satisfies this condition C1 and T either belongs to R1 T either belongs to R1 or t belongs to R2 agree either T1 T either T belongs to R1 or t belongs to R2 now you tell me will this T be in this result will this T be in this result yes because remember if T belongs to R1 and already T satisfies condition C yes or no already T satisfies condition C1 so remember there is no problem this tle will satisfy condition C1 now if this T belongs to R1 then T will belong here yes or no then T will come here and if T belongs to R2 if T belongs to R R2 then T will be here overall I can say in the union definitely T will be there do you agree I can say whatever you do T will definitely be there here okay T is present is this clear so very simple if T is present in this then T will be present in this do you agree with me let me know did you understand very simple Point see look at this query and I'm telling you that in this result if you have tle t then that tle will also be there in this result now very simple in this result if I have tle t then it means tle T satisfies condition C1 okay T satisfies condition C1 and this T must be either in R1 or in R2 either T is in R1 or t is in R2 okay now you can see remember T satisfies C1 so there is no problem this tle will satisfy the condition C1 now whether you take this case or whether you take this case in both the cases what will happen in both the cases I can say here we are taking Union so in whatever case you take I can say t will belong to this okay is this clear please tell me so I can say that if tle belongs here then definitely it will belong here now what we need to prove now we need to prove if T belongs here will it belong here if T belongs here if tle T is here if tle T is present here what it means this tle T this is present here what it means it means either this tle is coming from here or this tle is is coming from here do you agree with me do you agree with me if T is present in this result if tle T is present in this result and there is Union here if tle T is present in this result then then I can say either T is coming from here either T is coming from here or or or t is coming from here agree let me know agree or not okay now you tell me whatever case I take if I take this case assume assume I take this case means T is coming from here then can I guarantee T will be in the output of this query assume assume T is here in this result T is there okay just assume that in this result you have t in this result you have t what it means it means T belongs to R1 and T set satisfies C1 yes or no it means T satisfies C1 and T belongs to R1 okay so if T belongs to R1 then T will belong to R1 Union R2 agree if T belongs to R1 then T will belong to R1 un R2 and already T satisfies condition C1 so this T will satisfy condition C1 so T will be in this result yes or no similarly you can do the other similarly you can say if T is coming from here if tle T is coming from here it means T belongs to R2 and T satisfies condition C1 so if T is Bel if T belongs to R2 then T will belong here and T satisfies C1 T satisfies C1 so T will come here so finally the result is if T is present in in the rhs then T will be present here so finally I can say LHS rhs they are actually equivalent is this clear please tell me in this option C LHS rhs they are actually equivalent condition C1 R1 Union R2 this is actually equivalent to condition C1 R1 Union condition C1 R2 the proof did you understand please tell me this was a beautiful proof I hope you understood this this was not complicated this was a easy proof that this query this query they are actually equivalent if this query has any tle T then this query will also have tle t and if this query has tle t then this query will also have tle t this is what we have proven so they will have same result okay they are actually equivalent is this clear so you can do this transformation no problem you can do this transformation no problem both the transformation you can do this is your option C analysis now let's see option D analysis let's see what is option D option D is saying can I replace this query with this query Pi A1 Sigma C1 Sigma C1 Pi A1 okay so you can see option D is saying can I replace this query Pi A1 Sigma C1 R1 can I replace this query with Sigma C1 Pi A1 R1 let me know is this transformation correct is this transformation correct see first you tell me can I say they are equalent query you just tell me this point can I say they are equivalent are they equivalent no they are not equivalent but the question is not asking equivalence yes or no question is not asking equivalence question is saying if this is valid query then can I replace with this query okay let's assume in your system you have this query now can I replace this query with this query so already assume this is a valid query can I replace this with this query tell me again this transformation is also wrong okay this transformation is also wrong let me give you one condition see here you tell me look at this assume this is a valid query this is a valid query Okay so assume this is a valid query if this is a valid query can I say C1 will use attributes of A1 only tell me assume this is a valid query can I say C1 will will use attributes of A1 only no not necessary for example for example let's assume your table is R let's assume your table is R1 ABC ab b c d okay let's assume now assume that this condition C1 is like this that a is equal to Z okay let's assume this is your condition Sigma this is your condition C1 this is your condition C1 and let's assume I'm projecting the attributes b d now you tell me now you tell me can I replace this can I replace this with Sigma AAL to0 pi b comma d r R1 let me know can I do this no this is not even valid this is invalid think about it this is invalid why this is invalid why this is invalid because remember here I have attributes B comma D I only have attributes B comma D and I'm using the condition on a here I have attribute BD and I'm using condition on a so this is actually invalid so this transformation is wrong is this clear this option D transformation is wrong wrong so finally I can say this is wrong so this is actually beautiful question I hope you understood this let me know is this question clear to everyone please tell me I have done the complete analysis of each option I've given you the proof of this option that here LSS rhs they are actually equivalent so you can do transformation from LHS to rhs or you can do transformation from rhs to LHS both are fine okay or we have we have also seen that this is also correct transformation so this is the complete analysis of this question this is a beautiful question and this type of question they can ask you in the gate exam okay what is one possible variation anyone want to tell me what is one possible variation let's assume they ask you which transformation is correct this is a variation let's assume they ask which transformation is correct okay and let's assume in the question this condition is given that C1 uses attributes of C1 uses attributes of A1 let's assume this is given that C1 this condition C1 selection condition selection condition C1 uses attributes of a let's assume this is given now tell me which transformation is correct this is a variation now which transformation is correct now all the transform informations are actually correct okay all are correct so for this question answer will be a b c d okay understood so now let's move on now let's see set operations let's quickly see all the set operations tell me why we can apply set operations on the relations because every relation is a set yes or no every relation every relation is called table this is basically a set this is a set of t Okay so that is the reason we can apply set operations because it is a set of tles so set operations can be applied can be applied okay we can apply set operations with set operations we need to see okay so let me tell you the set operations that we need to study we will study the set operations Union set difference intersection cross product okay so these set operations we will study okay and which of them is basic and which of them is not basic I told you this is not basic this is derived okay this is derived and the remaining are basic okay and the remain mean these are actually basic is this clear this one this one and this one these are actually basic operations okay is this clear now let's see what is Union you already know okay so let me quickly tell you the definition of union the definition of all set operations okay for example what is if I have what is r Union s what is that that will be basically all the elements which belong to r or s okay all the elements you take all the elements of R you take all the elements of s okay so all the elements you take which belong to r or which belong to S this is the definition of union okay next what the definition of intersection intersection means common elements you take those Elements which belong to R also and which belongs to S also okay is this clear next is set difference next is set difference so here you take those elements which belong to R but do not belong to S which do not belong to S okay which belong to R but do not belong to S this is set difference and what is cross product cross product means you combine every element of r with every element of s okay means if this is element of R okay and this is element of s then you combine this element of r with element of s okay is this clear so we combine every element of r with every element of s so these are the definitions of set operations now you can see in the Union what we do we take all the elements of R comma s take all the elements of R take all the elements of s so you can see take all these elements which belong to r or S so you can see if this is your table R this is your table s then what will be Union so very simple take all the tles of R take all the tles of s finally this will be your output okay is this clear this this is R Union s remember duplicates are removed so very simple you have to remove the duplicates next what is r minus s this is set difference means those Elements which belong to R but do not belong to S okay so basically those Elements which belong to R but do not belong to S so these elements are R minus s okay for example this is your table R this is your table s what is r- s r- s means those Elements which belong to our but not belong to S you can see this belongs to R but does not belong to S you can see this belongs to R but this also belongs to S you can see this belongs to R but does not belong to S so I can say the output will be these two okay very simple R minus s means those tles these two tles they belong to R but they do not belong to S so I can say this is in the output next is intersection intersection means common elements you can see these are the common elements they belong to R and they belong to S so this these are the common Tes so you can see if I do R intersection s then what will be the output tell me if I do R intersection s let me know R intersection s means just take the common tles those tles which belong to R and belong to S so I can say only this tle belong to both of them okay the answer will be Alpha 2 this belongs to both of them so one tle in the output very simple okay so let's move on now what is cross product so let me tell you about cross product or I can say cartisian product you can call it Cartesian product or you can call it cross product okay the symbol this is the symbol cross this is the symbol okay so remember if you have R cross s this simply means every tle of R combines with every tle of s okay very simple I can say combine every tle of r with every tle of s combine every tle of r with every tle of s simple yes or no okay combine every tle of r with every tle of s this is the point okay so here you can see for example this is your table R this is your table s here you have two attributes here you have three attributes so in the r cross s what we will do there will be five attributes in the r cross s okay basically combine every tle of r with every tle of s for example this tle we will combine with everyone similarly this tle we will combine with everyone so finally total eight tles will be there okay because you can see 2 multiplied by 4 okay because this tle we will combine with with everyone this tle we will combine with everyone so this is the result of R cross s okay is this clear simple right okay so very easily you can see and remember in this R cross s you will have all the attributes here followed by all the attributes here so there will be five attributes here simple now let's move on now let me tell you one thing that is if you want to apply Union intersection set difference if you want to apply these operations then relation must be Union compatible if you want to apply Union intersection set difference these three operations if you want to apply then relations must be Union compatible now what is Union compatible let's see Union compatible relations so if I give you a relation R and let's assume these are the attributes A1 A2 and so on a n and you have another relation s and these are the attributes B1 B2 and so on BM okay now when can I say R comma s are union compatible when can I say that they are union compatible Union compatible means you can do their Union you can do their intersection you can do their set difference so when can I say they are union compatible they are union compatible if and only if see this is the condition that number of attributes must be same first of all number of attributes must be same this is the first condition that number of attributes means n should be equal to m and and what should happen the corresponding domains must be same the corresponding domains must be same domain of A1 should be same as domain of B1 domain of A2 same as domain of B2 domain of a n should be same as domain of BN okay is this clear so very simple point that domain domain of AI should be same as domain of bi should be same as domain of bi okay for oi for oi is this clear the names can be different remember here the names can be different but domains must be same okay so this is the definition of union compatible these two tables R comma s they will be Union compatible if number of attributes must be same here n attribute here also n attribute and domain corresponding domains must be same domain of A1 should be same as domain of B1 domain of A2 should be same domain of B2 so you can see domain of AI should be same as domain of bi for all I okay so very simple this is the definition of union compatibility and remember Union compatibility we apply only for Union Union intersection and set difference for cross product do we need Union compatibility for cross product for cross product we don't need Union compatibility okay so very simple these points we have seen now let's see this example first of all you tell me are the union compatible these two tables are they Union compatible can I do their Union very simple you can see checking account saving account this is checking account this is saving account so you can see are the union compatible can I do their Union can I do their Union Yes they Union compatible yes because see here also three attributes here also three attributes you can see domain of customer number and this number sorry domain of checking account number and saving account number they are same yes or no domain is same here domain is same here domain is same here domain is same the names can be different here checking account number here saving account number the names can be different but the domain is same right domain is same domain is same domain is same here domain is integer here domain is character string here domain is some real number yes or no did you understand so they are union compatible the names can be different Union compatible means number of attributes must be same three attributes okay next corresponding domains must be same here domain is integer here domain is character string here domain is real number so can I do their Union please tell me can I do their Union Yes we can do their Union okay and one more thing let me tell you that when you do Union R Union s first of all they must be Union compatible okay they must be Union compatible now if you if you do R Union s then remember the resulting schema will be same as R okay the result schema will be same as schema of R the result schema will be same as schema of LHS basically L schema of LHS that means R okay is this clear the same thing you can do for R intersection S and R minus s okay the schema will be same as R so I can say same for I can say same for R intersection S and R minus s okay is this clear so you can see here if I do Union of checking account Union saving account then SCH schema will be checking account can you notice can you notice schema is this LHS so the the schema of this LHS will be used you can see schema of LHS we are using and then we are doing the union take all the tles from here take all the tles from here this will be your output okay so in this example you can see everything now let's move on now let's see this tell me can I do their intersection first of all you tell me can I do their intersection checking checking account saving account this is a checking account and this is a saving account can I do their intersection yes I can do because they are union compatible here also three attribute here also three attribute and you can see corresponding domains are same okay corresponding domains they are same so I can do their intersection tell me what is the answer of this query intersection means you take the common tles you take those tles which belong here also and here also is there any common tle is there any tle which is common no there is no tle common so empty empty result yes or no you can see the result will be empty okay so there is no tle in the output very simple okay now tell me if I do projection of C owner and here I do projection of s owner first of all you tell me can I do their intersection here I projecting C owner and here I'm projecting as owner can I do their intersection yes they will be compatible because here I will have C owner here I will have S owner so they will be compatible they will be compatible because they have same domain now you tell me what will be the result this is C owner this is s owner I'm doing their intersection so take the common tles so one tle will be in the output that is J Smith okay you can see one tle in the output that is J Smith and tell me the schema will be used for what tell me the schema of the schema of which table will be used the schema of LHS will be used yes or no schema of LHS will be used so you you can you can notice this C owner is used here you can easily see C owner is used okay let's move on you can see similarly difference Okay C owner minus s owner so tell me what will be the output C owner minus s owner basically those tles which belong here but do not belong here so you can see these tles will be in the output and did you notice the schema of LHS we are using you can see the schema of LHS we are using the C owner we are using schema of LSS okay so we have seen all these simple simple points I hope you understood everything we have seen that is written in these slides every point we have seen okay yeah let's see this question this is a good question so let's see this I want list of names of all people in the department okay I want names of all people in the department means all these people I want in the in the output so tell me can I write this query that first I take the union of student and Professor okay first I to take their Union and then I project name then I project name is this query correct please tell me did you understand I want list of I want names of all people in the department I want names of all people in the department I want these names these names I want all these names all these names I want then can I do this first I do their Union then I project name no I cannot do that no I cannot do that this is invalid okay why this is invalid tell me why this is invalid this is invalid I cannot do that because student comma Professor they are not compatible so I cannot do Union they are not compatible right yes or no you can see they are not Union compatible not Union compatible because they are not Union compatible so I cannot do their Union so these are invalid queries so what is the solution then anyone want to give me solution I want all the names then what the solution yes solution is very simple okay you project names you project names and then you do Union yes or no you project these names you project these names and then you do their Union correct so this will be the answer project names from student table project names from Professor table then you do their Union so this is what you can do okay now I told you intersection is not a basic operation what it means it means this is a derived operation it means this is a derived operation so can you derive it from Union comma difference can we derive intersection from Union comma difference and this is actually very simple let's look at this see very simple let's assume this is your table R this is your table s okay then you can easily see this R intersection s can I write like this that I want this R intersection s remember this is your R intersection s so how can I write R intersection s very simple can I do this that from R if I remove s my uh C from R I remove R minus s if I do do this then what I will get just think about it from R if I remove r- s see this is your r- s this white is your R minus s from R if I remove this white will I get this R intersection s tell me from R if I remove this white then will I get R intersection s yes okay so very simple like this you can write intersection in terms of difference okay there are many more ways let me tell you for example let me tell you another way okay another way let me tell you R this is s I want intersection this is our intersection s this is what I want okay so notice what I can do from the Union what I have to remove just think about it R intersection s this is same as from the union okay let's assume I take the Union first from the Union what are the things I need to remove tell me from the union I need to remove this yes or no from the union I will remove this this is r - s and this is s- R okay so from the union I will remove r- s okay from the union I will remove Rus s then again I will remove s minus r okay is this clear from from the union I will remove r- s then I will again remove s- R okay so like this also you can write there are many more ways okay let me tell you there are many more ways so for example this is R this is s you can see this is R intersection s okay what I can do again very simple you know this is R minus s and you know this is s minus r okay so what I can do this R intersection S I can do like this from the union from Union what I do I remove I remove the union of these two yes or no from the complete Union from this complete Union I remove Union of these two I remove r - s Union s- R okay so like this there are many ways you can write is this clear there is one more way what is that for example I can say R intersection s that is same as from S I remove s minus r okay all of them are correct from R R I remove R minus s okay R intersection s from R Union S I remove I remove their Union okay so like this there are many ways R intersection s that is same as from R Union s from this R Union s first you remove r- s okay first you remove r- s then you remove s minus r okay so you can see there are so many ways yes or no 1 2 3 4 there are many ways to write intersection so very simple let's move on now let's see some details about cross product also okay so let's revisit the cross product you already understand what is cross product but just tell me if you have this table R and let's assume that there are total A1 A2 and so on N attributes okay and you have table s where you have total M attributes then tell me what will happen in R cross s in R cross s first you tell me what will be the attribute list very simple this followed by this yes or no because every tle of R will combine with every tle of s so remember in R cross s you will have A1 to a n followed by B1 to BM yes or no so remember every tle of R will combine with every tle of s so tell me in R cross s what the degree let me know let me know what the degree of R cross s what is that that is equal to degree of R plus degree of s degree of R plus degree of s yes or no next what about the cardinality what the cardinality of R cross s that is equal to remember every tole of R will combine with every tle of s so I can say that will be cardinality of R multiplied by cardinality of s okay cardinality of R multiplied by cardinality of s I can say that will be MN sorry number of tles in R number of tles number of tles in R multiplied by number of tles in s okay is this clear actually N is a n is degree of R okay and M is degree of s so actually degree of R cross s will be m+ n but here the cardinality will be number of tles here multiplied by number of tles here okay is this clear so very simple these points you can see what about this situation if you have same attribute name for example here AB here BC these two names are same in this situation what you will do in this situation what we will do I want R1 cross R2 here I have AB here I have BC you can see they have same name so very simple solution is very simple here we will write r1b R2 dob but remember there will be four four attributes okay four attributes and these are the Tes so remember you can write r1. a r2. a if both of them have attribute a if both the tables have attribute a you you can write r1. a R2 do a like this if both tables have attribute B then you can write r1b r2b okay in the cross product very simple okay let's move on now you can see here okay here four attribute here two attribute in the result there will be six attribute and every tle here will combine with every tle here okay and remember U ID here and uid here they have same name so actually what will happen actually what will happen here actually here tell me what will happen here user. uid okay here you will write user. uid this this will be user do uid and this will be and this will be member. uid okay simple now let's move on so we have seen the cross product all these details we have seen now let's move on so you can see number of tles in the cross product that will be number of tles in R multiplied by number of tles in s and degree in the cross product prod that will be degree of R plus degree of s okay and this is a binary operation and it does not require Union compatibility every point we have seen okay let's see some more points these are simple simple set theory points what about commutative see let's see commutativity these are simple symol points what about commutativity okay can I say R Union s this will be same as s Union R tell me if only data is concerned don't don't worry about schema see here the schema of R will be used here schema of s will be used do you agree do you agree here schema of R will be used here schema of s will be used so assume only data is concerned okay so assume only data is concerned only data is concerned now you tell me if only data is concerned which is which is the situation most of the time okay remember we are we only care about the data most of the time we only care about data so if data is concerned then can I say that R Union s s Union R they will be same yes yes they will be same what about R intersection s s intersection R yes that is also correct what what about R cross s s cross R if only data is concerned yes all of them are correct okay but but but now what about R minus S and S minus r if only data is concerned then can I say they will be same no they will not be same okay they will not be same if data is concerned then also r- s s- r they will not be same okay let me give you one example okay for example let's assume r has this attribute a and let's assume you have 1 2 okay and in s let's assume you have attribute a and you have 13 now tell me what is r- s and what is s minus r tell me R Min - s is what what is r- s Rus s means those values of R which are not in s r minus s means those values which are in R but not in s so this will be R minus s what will be S minus r those values which are in s but not in R those tles which are in s but not in R okay so this will be did you notice they are different even the data is different yes or no even the data is different so you can see that if only data is concerned remember most of the time we only care about the data okay so easily you can see see that they are commutative like Union intersection cross product they are commutative if only data is concerned if only data is concerned okay in the in the database in the dbms we only care about the data so they are actually commutative okay but remember this set difference is not commutative this is not commutative okay is this clear simple right and what about associativity and what about associativity what about associative property tell me associative property means like this see if I do R Union s Union T first I do their Union or first I do c notice okay first I do R Union s okay or first I do s unit will the result be same will they give me same result yes they will give me same result okay so this is actually associative similarly intersection is associative if I do let's assume intersection for example I do intersection of s okay if I do like this then remember whether I do this first or whether I do this first both are fine both are fine okay in the cross product also the same thing will happen if only d is concerned yes or no if data is concerned then tell me about cross product R cross s cross t r cross s cross T again the same thing will happen whether I do this whether I do this both will be fine okay what about the set difference tell me what about the set difference if I do r - s minus t r- s minus t if I do this first or I do this first will they give me same result no they will not give okay they will not give so remember these are associative in dbms they are actually associative because we only care about the data okay this is not associative so these things are written here okay in this slide you can see intersection Union they are they are commutative they are associative you can see minus is not commutative okay so all these things we have seen let's move on now cross product is commutative as long as data is concerned you can see you can see that as far as data is concerned as far as data is concerned then you can see cross product is commutative because we only care about the data okay now a very small topic that is rename operation okay what is this rename operation and assignment operation this assignment operation we have already seen right yes or no this assignment operation we have already seen this is very intuitive that you are assigning okay some result you have that you are assigning to something okay this result you are assigning you are calling it by name s yes or no this result you are calling it by name s so this assignment is actually very simple this we have seen now let's see this rename operation and this rename is also very simple let's see this rename operation first of all the symbol the symbol is row okay this is the symbol okay what is the name of this symbol that is row so this is the name of this symbol now what is this rename operation remember you can rename attributes also you can rename table name okay what we can do we can rename table name you can rename table name or you can rename attribute names attribute okay you can rename attributes or you can rename both okay we can rename table name or we can rename attributes or we can rename both for example if I want to rename table name this is my table R I want to rename this table with s then what I can do very simple I can do this row s means basically this is renaming okay is this clear this is renaming now let me tell you one more thing when you do this renaming then it does not mean that the name Will Change no a new copy will be created okay is this clear when I say rename when I say you are renaming a table then the original table will not rename a new copy will be created by name s is this clear when I say rename then it means that a new copy will be created by name s Okay so the original table will be as it is the original table will not change okay a new copy will be created by name as so you can see if I want to rename a table name then I can do like this that this table name I'm changing to S okay very simple so this is the rename this row means rename if I want to change attribute names then what I can do for example let's assume my table is r and I want to change the attribute names then very simple I can put the attribute names here okay let's assume R has A1 A2 A3 and I want to change them B1 B2 B3 then I can do that okay let's assume R has A1 A2 I want to change them B1 B2 then I can do that so this is attribute renaming okay and the third if I want to do both of them then that is also fine this is relation r i want to call it s and I also want want to rename the attributes B1 B2 okay so all of them are fine is this clear all these are fine so this is a very simple topic for example let's assume you have a table R which is a a comma B okay and let's assume I write this Sr then what it will mean it will mean I'm renaming the table yes or no is this clear so here I'm renaming table renaming table r2s okay next if I say like this for example if I say e comma f r now what it will mean let me know here I am renaming attributes here I'm renaming attributes okay I am renaming attribute a to e and attribute B to f okay yes or no and similarly if I say s EF now here both okay renaming both I'm renaming both very simple and if I want only want to rename one attribute can I do that if I want to rename only one attribute can I do that I want to rename only one attribute yes I can do that see very simple I want to rename this a from this table R I want to rename this a so this like this you can do that a change it to E A change it to e is this clear okay like this I can write what it will mean it will mean that basically a name is changing to e okay is this clear simple very simple okay so like this also you can do I hope you understood so these are simple simple points I hope you I hope all these are clear so here I am renaming the table okay this R renaming to S here renaming attributes yes or no here I'm renaming both of them s and attributes okay so all these three things you can do okay here renaming both here renaming table here renaming attribute okay so you can just easily check you can see these are the three things renaming table renaming attribute sorry here renaming both here renaming table here renaming attributes okay you can see if I want to rename a to okay if I only want to rename a then I can do like this that I'm changing a to A2 okay like this you can see for example changing a to e changing B to K okay changing a to e changing B to K okay so like this you can do the renaming very simple the renaming concept is actually very simple you can see here changing a to A1 changing B to B1 okay so like this you can do the renaming and R2 s changing R2 S A to A1 B to B1 so like this you can do the renaming okay is this clear simple so we have seen the concept of renaming you can see okay this type of renaming you can do so we have seen all the basic operations we have seen selection projection cross product Union difference renaming all these we have seen and we have seen intersection but that is not basic yes or no see the basic operations are selection projection cross product Union difference renaming okay there are how many basic operations let me know how many basic operations six basic operations on your screen what this selection will do it will select tles so it is doing horizontal partition what projection will do it will select attributes or I can say it will project attributes so this is vertical partition cross product it will combine every tle of this relation with every toule of this relation Union we are doing the union set difference and renaming so these are the basic operations we have also seen intersection but this is not basic this is derived okay so all these points we have seen I hope everything is clear please tell me is every everything clear let me know in this session whatever we have seen did you understand let me know did you like this session we have covered each and every important Point let me tell you okay for every operation every important point I told you I told you the important properties of selection operation important properties of projection operation and gate 1998 question a beautiful question based on projection comma selection okay so every important theorem every important result everything I have told you in this session okay so we will continue in the next session in the next session we will we will see the derived operations we will see join we will see division operation okay outer join full outer join basically all the remaining operations we will see in the next session okay thank you everyone