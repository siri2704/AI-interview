foreign welcome to one of the important topics in dbms the Keys in idbms before going into the topic of the day the key is in rdbms let's first understand why do we need keys in rdbms let's assume there is a relation or a table and this is the employee table and we have the attributes in the employee table the employee ID the employee name the SSN the social security number we can also consider this as an other number in India the salary the phone number and email and we have nine tuples here and these nine tuples are just for example purpose now why do we need keys in rdpms let's assume I am going to increment the salary of Jon by 10 percent in that case I am informing the database with a query that increase the salary of John by 10 percent and obviously database will be incrementing the salary of John by 10 percent but the problem is there are three Johns that are updated in the database 101 John 105 John and one not eight John do I want all John's salary to be incremented no actually I wanted 105 John's salary to be incremented but what did I tell the database to do I instructed the database to increment the salary of Jon by 10 percent but all three John's salary will be incremented by 10 percent if I provide a query by referring the name of the employee which is John instead if I give update the salary of Jon who is belonging to a specific department and that may be okay to some extent what if there are two Johns in the same department and we wanted to increment the salary of only one John again that will bring some inconsistency to the database right so the real problem here is identifying the unique tuples if I want to do some operation with the database I want to uniquely identify the tuples in this case if this John that I am referring it should be clear that this John's record only is updated and not any other John's data and they instead think this way we know John salary is 62 000 and we want to update the salary of John by 10 percent for this John and if I give a query like this update this salary who is having the existing salary as 62 000. obviously many people may be having the same salary so the real problem is identifying the unique tuples and that is why we need keys so here we confirmed that name cannot be a key because there can be multiple people with the same name so if I use ID number and if we are sure that this ID attribute is unique in the table then definitely that particular Tuple will be identified and that particular Tuple only will be updated just think here update the salary of the person I need not even give the name of the person update the salary of the person who is having the ID number as 105 so obviously this particular salary only will be updated because I am very clear with my query that I want to update the salary of a person who is having the ID number 105 and it is obviously this John who is have having the ID number 105 because there will not be another one or five ID in the same table this is how we can uniquely identify the tuples so I hope now you understood why do we need keys because these keys are actually required to identify the tuples uniquely let's now step into the topic of the day the case in rdbms when we talk about Keys we clearly understood that we want to uniquely identify the Tuple so for that we need keys when we discuss about the relational database management system we might come across a lot of key terms the key terms related to key are super key candidate key primary key alternate key unique key composite key and foreign key in this presentation we will see all the keys one by one let's first start with the first key the Super Key what is a Super Key actually the super key is like the superset and this super key is actually the all possible keys that can be formed from a relation or a table so if we have an employee table and we can create any number of key combinations from this table say this ID number alone can be a key or we can combine ID number and name as a key we can combine name and salary to work as a key so this is a superset so why we are creating a Super Key of course this is a key basically and we are going to uniquely identify the Tuple and that is the real need for having key and super key is not an exception it is going to uniquely identify the Tuple in the relation then why do we need Super Keys why not primary key or candidate key or any other key because super key is the superset from which we can derive other keys if you are not sure anyway we will see that with an example shortly and let's take this example IDE and if this ID is going to have a null value I'll put a question to you can there be a null value in this ID I mean to say can there be an employee without an employee ID no any organization will not encourage that because we want to uniquely identify that particular employee in that case every employee will be associated with the employee ID will every employee have a name yes every employee will have a name so obviously ID will be unique and this will not be null so I can say ID attribute is unique and not null and coming to this name attribute if I make this name attribute as a unique attribute it won't work because in a table there may be multiple employees with the same name so in this case this will not be unique at the same time every employee will have a name so obviously this attribute will also be not null and coming to SSN the social security number or the other number the reason why I am picking SSN is in certain countries every citizen will be assigned a social security number like in India we have other number with other number we can uniquely identify by that particular person so this will also be unique and this will also be not null to some extent why I am saying not null if a person who has not applied for other so you will not be having another number but we need to ensure that every person is having other number so anyway let's not go deep into this for now let's consider this SSN is also unique and not null and coming to salary every employee will be having a salary and coming to phone number employee may have a phone number or may not have a phone number at the same time this can be unique but null values also should be accepted in this field what if the employee claims that he or she does not have a phone number of course we are in the Contemporary world every employee will have a phone number but there are chances that employee may not have a phone number so we can't enforce that every employee should have a phone number isn't it so in that case this attribute should accept null value and coming to email ID every employee will be having a unique email ID at the same time if there is no email ID this column should accept null value as well now why I am saying all this is that the key attribute whatever we are figuring out it should accept null values also when we talk about the Super Key now this super key is going to contain either one attribute or set of attributes and there can be null values in the attribute say for example if I am saying name and phone number as the super key so name will not have null values whereas phone number may have null values in that case the attribute or attributes which we are considering as a Super Key attribute may contain null values so in this I can say ID is a Super Key because it is unique as well as there is no null values of course we may have an attribute which may contain null values also one example for super key here is ID and why name is not a Super Key I am saying name is definitely not a super key because there may be multiple people with the same name when there is no uniqueness in the attribute which is acting as a key then definitely that attribute cannot be a key attribute so name attribute cannot be a Super Key let's see some example so from this we can confirm that a Super Key is a collection of attribute or a set of attributes so that we can uniquely identify the Tuple and one of the important points to note about Super Key is that it may contain extraneous attributes say for example ID alone may work as a key but I can combine ID plus name together in order to form a key or I can combine ID plus SSN or I can combine name and SSN the social security number to work as a key so what I mean to say here is super key may contain extraneous attributes simply extra attributes the example for super keys are remember it is actually a superset so here ID alone is acting as a key so ID alone is a key or SSN number is also unique right so in this case SSN also can be a key or I can combine ID and name to work as a key right so ID and name put together is also a key and coming to the next one ID and SSN works as a key so ID and SSN can also be a key so what I mean ID and SSN I am combining together and ID and phone number can also be a key so this ID and this phone number is joined together as a key so we can have multiple keys in a relation and that's why I told you this super key may contain extraneous attributes in this case ID alone is enough or I can combine with other attributes this is actually a superset it may have n number of Super keys so anyway why we want all the super Keys just to uniquely identify the Tuple let's take one example name and email if you see name is definitely not a unique attribute because many people may have same name but with email ID it can uniquely identify a tuple right and this super key is actually a super set I hope things are clear to you now we are done with the super key with this knowledge let's step into the next key the candidate key so just now we had seen that super key is the superset which contains all possible keys right all possible combinations whatever we create everything is the superset now from the superset we are going to derive the candidate key and how we are going to derive it the minimal super key is actually the candidate key remember the minimal super keys are called as candidate keys so let's see this example now we have a lot of keys here I mean Super keys from this we will derive the minimal Super Key let's take the first Super Key the ID it has only one attribute yes of course we can choose this so the candidate keys can be ID then I have one more attribute here SSN I can take this also as a candidate key remember if I take this SSN ensure that the previously taken key is not having this attribute the previously chosen category is ID which is this so this is not having SSN with it so ID is a separate candidate key now we are taking SSN as a separate candidate key let's come to this key ID and name put together working as a key now in this case we can't take it as a candidate key because there is an attribute ID which is already a key so we cannot take this key as a candidate key of course it is a Super Key but this is not a candidate key let's come to this ID and SSN already ID and SSN are chosen as the candidate key so this super key cannot be a candidate key ID and phone number no because ID is already chosen name and phone number yes because the already chosen candidate keys are ID and SSN so we can have this name and phone number can be a candidate key and again ID and email ID no ID is already chosen name SSN and phone number no because name and SSN are already chosen name and email no name is already chosen ID SSN phone no ID SSN are already Chosen and phone is also already chosen simply email ID yes with email ID also we can uniquely Identify some tuples right so email ID alone can also be a Super Key in that case since all the candidate keys are not having email ID I mean all the already chosen candidate keys are not having mail ID attribute this email ID alone can be a candidate key so what do we mean by a candidate key the minimal Super Key remember the list of candidate keys that you are taking from the super key there should be no repetitions of the attribute so if ID is there and it is acting as a candidate key no other candidate key should have this ID attribute so we are done with the super key and the candidate key let's now move on to the next key the primary key now we have seen the list of candidate key and this primary key is used to denote a candidate key what is a candidate key just now we have seen right the minimal super key so we have already derived the list of candidate keys from the Super Key pertaining to this table employee now the candidate keys are ID SSN name and phone number and email now just pause this video for a while and think which can be a primary key remember primary key should be unique and it should not contain null values so ID can we choose ID yes ID will be unique and it will not have null values can we choose SSN SSN yes it is unique and this SSN is Incorporated in a country where every person in the country is having an SSN number and of course in that case this SSN will be 100 unique and not null coming to name and phone number there is an attribute which contains null values so this key name and phone number they may be unique but they are having null values in it because there is an attribute which may take null values and coming to email of course with email we can uniquely identify the Tuple but unfortunately there may be null values in the email because employee may have an email ID or may not have an email ID so in that case which will be the primary key a primary key which is chosen should be unique and it should not accept null values in this case I am preferring to go with ID because this ID column in the table or this ID attribute in the table will be 100 unique in the table so there will be no duplication of values if one or one is there there will be no employee in the same table with the same ID value or not one so only one time that value will be existing in the table so this is hundred percent unique there will be no duplication and at the same time every employee will have the ID value so it is unique and not null from the Super Key we derived the candidate keys from the candidate Keys we are going to choose one of the keys as the primary key remember the primary key is chosen from the set of candidate Keys we have four candidate Keys here and I am choosing one of the keys as the primary key which is ID and this ID is chosen based on two factors one is its unique and the other one it is not null now who is going to choose that I can either go for ID or I can even go for SSN right then who is choosing this primary key it is chosen with Care by the database administrator see such a powerful position is having in terms of databases he is the one who controls the entire database so he is the one who chooses the primary key from the set of candidate Keys remember in a table we can have n super keys and we can derive a lot of candidate keys from the candidate Keys we can have only one primary key because this key attribute will never be changed or very rarely changed remember there is an employee with the id101 so we will not change the value of this ID or not one to a new value because this is how a database should be constructed we are choosing the primary key attribute it's not only just based on uniqueness and not null features but we should also consider that the values present in that attribute should not be changed never be changed or very rarely changed remember candidate key with null value is not chosen as the primary key in the set of candidate Keys we have chosen ID as the primary key because it is unique and not null we may also consider SSL but we cannot consider this name plus phone number or email as the key the reason is this candidate key name plus phone number or name phone number is having an attribute which can support null values at the same time email also can support null values so one of the keys in the set of candidate Keys is chosen as the primary key and the set of candidate keys with null value is not the primary key because primary key should contain unique values also there should be no null values simply primary key is unique plus not null we are done with the third key the primary key let's now focus on the fourth key the alternate keys so far we have seen Super Key candidate key and primary key and for this employee table only we derived some keys the Super Key candidate key and we have chosen the primary key now what is an alternate key in the set of candidate Keys the key other than the primary key is actually the alternate keys we have the super key from the Super Key we derived the candidate Keys let's say there are four candidate keys and one of the candidate case is chosen as the primary key so there are three candidate keys left and these candidate keys are referred as the alternate case so alternate keys are the keys which are not primary case in the example that we are dealing we have already chosen the candidate Keys as ID SSN name and phone number and email there are four keys and which key is chosen as the primary key ID is chosen as the primary key now what are the remaining Keys SSN name and phone number and email so these keys are actually the alternate case what are they SSN name and phone number and email so we are done with the alternate Keys let's now focus on the next key the unique key see there are situations where we may need to choose a key that key is unique in terms of values but it can also have null values in that case we are calling that as a unique if you are not clear just see this example we have already chosen the candidate Keys ID SSN name phone number combo and email and we have chosen the primary key which is ID so obviously the alternate keys are SSN name and phone number and email now what is a unique key just pause this video for a while and think which of the keys may contain 100 unique values but it can also support null values SSN if it is 100 unique and hundred percent not null so this can be a unique key remember this will not accept null value and coming to email this is unique every employee will have their own email ID but if employee does not have an email ID then it can have null values so it is unique but it can have null values and coming to this example name and phone number there is an attribute in the key that can support null values but there is an attribute which says unique plus not null but there is an attribute which can take null values it can give uniqueness right so the unique key can be name phone number or even email ID and now let's move on to the next key the composite key I'm not going to show that in a new slide if you see in the set of candidate keys this is only one attribute one attribute is working as a key here and only one attribute is working as a key here but in this key can you see here there are two attributes forming the key so when you have a key that is comprised of more than one attribute that key is called as a composite key in this name phone number is the key that contains more than one attribute we can also have another composite key SSN plus phone plus email so that is also a composite key because it contains three attributes in it that key contains three attributes more than one attribute so we are done with the unique key and the composite key as well before we sign out let's see the last key the foreign key now what is this foreign key this foreign key is unlike other keys that we have seen because in the all the other keys that we talked about those key deals with only one table but foreign key actually deals with two tables let's take student table and let's also take Department table just see this department table contains two attributes Department code and Department name and this department code will be obviously unique in this table and let's say this department code is the primary key attribute in this table and we also have a student table and obviously student ID is going to be the unique attribute or the primary key attribute in this table we know student table is having four attribute student ID student name Department code and credits and Department table contains Department code and Department name now whenever I am going to insert some record here say for example 105 104 I cannot insert already one or four exist because student ID is a primary key attribute let's say I am inserting one or five name is Rachelle the department code is 200 this row will not be accepted because I am trying to insert the department code 200 where this 200 is not existing in the parent table the department table so only all these four values 101 10200 and 304 only are accepted in this table and whenever any row that is inserted that row should contain the department code which exists in the parent table only these four values are accepted so in that case one table is referring another table that is the student tables Department code is referring to the department tables Department code so this Integrity constraint we call as referential Integrity where the insertion in one table is actually depending on the values to be validated in the other table that value should exist in the other table and foreign key offers referential integrity anyway when we see SQL Topic at the time I will be explaining more about all the Integrity constraints for now just understand referential Integrity is achieved by using foreign Keys before we sign out I wanted to say one thing please understand the concept of keys clearly because when we deal with the chapter normalization there we are going to deal with the functional dependencies at the time the concept of case should be clear and that's it guys I hope you liked the video and thank you for watching [Music] [Applause] [Music]