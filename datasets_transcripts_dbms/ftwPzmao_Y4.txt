[Music] hey everyone you are watching tech time out and this is the database design course now before we dive into the database design course we need to understand some basic terminologies first data a distinct unit of information is called data data is information that has been transferred into a form that is efficient for movement or processing now that we know what is data we need to understand databases a database is an organized collection of data used for the purpose of modeling some type of organization or organizational data any application used to store or collect data in an organized manner for a specific purpose can be used as a database now thinking about organizations let us consider a retail store now this store has various types of data which include transaction data product data customer data sales data etc and these different types of data need to be modeled and organized in such a manner that it is easily accessible and easily understandable and this can be achieved by storing and collecting data in an organized manner even an application as simple as a spreadsheet can serve as a database since it is being used to store or collect data in an organized manner next up the types of databases depending on their use databases are broadly classified into operational and analytical databases operational databases are primarily used for oltp or online transactional processes where there is need to collect modify and maintain data on a daily basis constantly changing databases serve as operational databases now going back to our written store example consider the transaction table or the transaction data this data is being constantly changed since there are a number of transactions happening over a short period of time every day hence the database is being constantly modified it is collecting data and sometimes even updating data so the database is constantly undergoing change such a database is called operational database next up we have analytical databases these are primarily used for olap or online analytical processes where there is need to store historical data data isn't updated modified or deleted now consider that you are a business stakeholder who needs to understand and analyze the trend of sales for the past one year now you wouldn't want the data to be constantly changed or updated if you are trying to analyze the data also you need historical data that is data over a long period of time to be able to analyze the trends and for this you are going to use an analytical database this database is different from the operational database in the sense that analytical databases are mainly used for read operations whereas operational databases are primarily used to collect modify and maintain data relational databases a relational database or a relational db stores data in relations which is presented to user as tables relations are composed of tuples or records and attributes or fields so when data is being stored in the form of relations and being presented to users as tables then that is called a relational database a relational database has rows or tuples and columns or attributes to give you an example here we have the student table this table is being presented to us in the tabular form but is in fact stored in the database as a relation this has four attributes or columns or fields either of the three terminologies is fine and those attributes are student id first name last name and course id similarly the course table has two attributes those are course id and course name next the student table has four tuples now each of these four data points arranged in a horizontal manner constitute a tuple the tuples are also called rows or records so there are four tuples in our student table and three tuples in our course table [Music] physical order of records or fields in a table is irrelevant just like the database stores data in the form of relations and is perceived by the user as a table it does not matter how the data is being stored in the database as long as it is being presented to us in this tabular form that consists of attributes and tuples [Music] each record is identified by a field or group of fields that contain unique values going back to our student table example we observe that student id column is being used to identify each row of the student table uniquely the first student id that is student id 1 identifies a student whose name is john joe and is enrolled in course id 1. similarly student id 2 recrimes is enrolled in course id 3 and so on now why do we need a student id to identify a student uniquely that is because two students can have the same first name and last name just like john joe here both the students have the exact same name now you might be wondering that why not have first name last name and course id all three of them taken together to identify a unique student well it is also again possible that both the john joes are enrolled in the exact same course in that case the only solution is to assign both the students different student ids so that they can be identified uniquely it has happened previously in my high school that two or more students had the exact same first name and the last names however they were uniquely identified by their role numbers by the school administration system so student id is a useful attribute here as it helps us identify each row of the student relation uniquely here again we have course id course ids 1 2 and 3 each identify different course names uniquely so course id again here is an attribute that is being used to uniquely identify the courses the attributes which uniquely identify each row of a table uniquely could be a collection of attributes going back to the point each record is identified by a field or group of fields so like in our case we had student id but we could also have a collection of fields that is more than one attribute being used to identify each row of table uniquely this enables physical data independence we will read more on physical data independence in our subsequent chapters relation between tables is established by matching values of shared or common fields going back to our student and course table example we observe that course id is being used to connect the student and the course relations to know which course student id 1 is enrolled in we can simply match the course id of student id 1 to the course name in course table so course id 1 corresponds to dbms similarly student id 2 is enrolled in course id 3 and course id 3 corresponds to python both student ids 3 and 4 are enrolled in course id 2 that is java finally to have a brief definition of sql sql or structured query language is a standard language used to create modify maintain and query a relational db or a relational database now i'd like to mention that this course does not teach you sql or structured query language this course is purely focused on database design and does not discuss the syntax and queries of structured query language [Music] advantages of relational databases multiple levels of integrity at table level it helps avoid duplicate records using primary keys discussed later and at relationship level it ensures shared columns are valid using referential integrity just like we saw in the student and courses relation student id was the primary key of the student table and course id was the column that helped us create a relationship between the course table and the student table logical and physical data independence logical and physical layers are independent of changes made to each other we will discuss more on this point later enforcing data consistence and accuracy constraints and integrity ensure that data is accurate and consistent to certain degree so we have a system of constraints and integrity that ensure the data is accurate and consistent for example we could ensure that student id is always an integer in that way nobody can enter a student name as student id and that will ensure that all the students have consistent student ids ease of retrieval of data join tables to retrieve data from multiple tables we saw that course id was a column that could help us connect the student table and the course table we will later observe that we can join these two tables using the shared column rdbms or relational database management system is a software application program that enables you to create modify maintain and manipulate a relational db some examples of relational databases are mysql postgresql oracle microsoft sql server and ibm db2 database design what and why database design is a process of designing a database to facilitate its development and implementation it includes deciding the name correlation data types constraints and structure of database and tables like we observed that we had several columns or attributes for the student table but someone would have to decide what the columns are going to be which is going to be the unique identifier column for each of those tables how are those two tables going to be connected what are going to be the data types of each column for example the student id is supposed to be an integer the student name always has to be a worker the course id always has to be an integer now this process of designing the database is called database design it is crucial to consistency and integrity of data that is retrieved from a db might lead to inaccurate results if not done properly has adverse impact on business it is also analogous to deciding the blueprint and design of house before construction next we have the thriller architecture of dbms there are trailers those are external or view layer conceptual or logical layer and the physical layer now these layers are abstractions and each has their own distinct function the external or view layer is the view of data in user interface on the basis of conceptual level tables now let us consider the scenario where we have student data and course data now if a student wanted to access his or her own data a student will naturally not be given access to other students data he or she will have access to only his or her own data also the student will have access to only the course data that he or she has chosen however a teacher will have access to all the student data and all the courses data as well again the teacher will not have access to other teachers data but the system administration will have access to all the teachers data and all the students data now as we can see the different views of data was presented to each user however in spite of having different views all the users essentially share the same relations or the same tables that is the same tables are being used to give certain information to certain users next we have the conceptual or logical layer data is represented in the form of views and tables in the conceptual layer in the conceptual layer we define the different relations and the relationship that exists between those relations in the physical layer we define the information about the location of the data objects in the device hardware that consists of tapes and disks data independence we observed in the previous slide there existed data independence between the different layers of abstractions the ability to change the schema at one level of a database system without having to change the schema at the next higher level is called data independence physical data independence this type of data independence exists between the physical layer and the conceptual layer any change in the physical location of tables and indexes should not affect the conceptual level or external level we will understand indexes in the end of the lecture but for now understand that if we change the physical location of tables in the memory it should not affect the structure of the table in the conceptual level or even the external level conceptual data independence exists between the conceptual layer and the external layer adding or deleting an attribute of a table should not affect the user's view of the table phases of db design there are four phases to database design the first phase is business requirement here we understand the business in terms of events entities and functions basically we understand the structure of the organization and the important constituents of the organization second comes the conceptual design here we do the data modeling we define the constraints and the relationships between the different relations logical design is converting the er model or the entity relationship model to relational model and also defining the table structure we will learn more about entity relationship model and relational model in our upcoming slides finally deciding the physical design of the database data in relational model to implementation in dbms [Music] before we move on we must understand what are the asset properties and before understanding the asset properties we need to understand a database transaction a database transaction is a logical unit of processing in a dbms which entails one or more databases access or write operation to maintain the integrity of data four types of properties are described those are atomicity consistency isolation and durability the initials of these properties constitute the acid properties first atomicity data remains atomic any operation performed on data should be performed completely or not performed at all partial execution is not permitted so here we have account a and account b account a has an initial balance of 100 twenty dollars is debited from account a then the balance remaining is eighty dollars the twenty dollars debited is transferred to account b account b initially had a balance of thirty dollars it was credited with the twenty dollars received from account a however the balance finally is thirty dollars whereas it should have been fifty dollars atomicity property was violated while performing these operations and hence this cannot be a transaction this on the other hand is a complete transaction because all the steps were performed and finally the total balance of account b turned out to be 50 dollars which abides by the atomicity property consistency value should always be preserved database must be conserved before and after the transaction so we again have account a it has a balance of hundred dollars twenty dollars is debited and the final balance is eighty dollars the twenty dollars debited was transferred to b [Music] account b initially had a balance of thirty dollars it received twenty dollars from account a and the final balance turned out to be 50 now if we add the values before the transaction that was 130 100 in account a 30 in account b it was 130 dollars the values after transaction turned out to be 80 plus 50 that is also equal to 130 so this transaction didn't violate the consistency property [Music] isolation property of database where no data should affect the other one when many transactions occur concurrently operation on one database should start only when the operation on the first db gets done both operations must occur separately else ensure that the execution of transactions concurrently will result in a state that is equivalent to a state achieved if this were executed serially in some order example here is account a which initially had a balance of hundred twenty dollars were deducted and the balance is eighty the twenty dollars that was debited was transferred to account b account b had an initial balance of thirty dollars it is credited with twenty dollars and the final balance is fifty dollars and lastly the credit is the total balance now the second transaction that we have here that is transfer the entire balance of b to c happened before the balance here was updated to 50 so what happened here is that account c read the balance of account b as 30 that is before the balance was updated to 50 but the actual amount to be transferred to account c was supposed to be 50 hence the isolation property was violated during these transactions [Music] finally we have durability which ensures that once transaction has completed execution updates and modifications to the db are stored in and written to disk and they persist now that we are done with the asset properties we will proceed to understand data modeling it is the process of creating a visual representation of either a whole information system or parts of it to communicate connections between data points and structures goal is to illustrate the type of data used and stored within the system the relationships among these data types the way the data can be grouped and organized and its format and attributes there are different types of data models those are er model or entity relationship model relational model object-based model semi-structured data model in this lecture we will only focus on the er model and relational model but before we proceed we should understand what is schema schema represents the overall logical design of a complete database in a dbms application a schema is a container for tables views primary keys stored procedures etc entity relationship model or the er model an entity relationship model or er model describes interrelated things of interest in a specific domain of knowledge a basic er model is composed of entity types which classify the things of interest and specifies relationships that can exist between entities instances of those entity types now what is an entity entity is something about which we store data for example customer or product it need not necessarily be tangible for example departments courses entities are described by their attributes so customer and product these are entities these could be entities of an organization that essentially sells products to customers and departments and courses could be the entities of an educational institute these are described by their attributes in student table we had attributes such as student id student name and course id next we'll have week entity this depends on another entity so we have the scheme entity which does not really hold any meaning if we don't have loans so scheme here is a weak entity which is dependent on the entity loan attributes these must be single valued in case of multiple values create new instance so here student id and phone number are the attributes but there's a slight problem here phone number consists of multiple values and attributes must consist of single values so what we did here was we assigned two more attributes that is phone number one and phone number two to accommodate the two phone numbers that each student could have and now we can properly call these attributes because they are all single valued er diagram or entity relationship diagram a way to document the entities in a database along with attributes that describe them there are certain types of attributes those are key attributes multi-valued attributes etc now let us discuss the types of attributes one by one the first one is the key attribute it is the main attribute of an entity represents the primary key represented by an ellipse with text underlined for example student id so we'll move on to our next slide this is nothing but the er diagram for a student the student is the entity and student id is the key attribute since it uniquely identifies each tuple of the student entity [Music] multivalued attributes attributes that take up multiple values denoted by concentric ellipse multiple phone numbers for one student so we observe that a student could have multiple phone numbers so in that case phone number is multivalued attribute and it is denoted by concentric ellipses derived attributes attributes that can be derived from other attributes for example h can be derived from birth state and this is how we denote derived attributes by ellipses but those have a dotted boundary composite attributes attributes constituted by multiple attributes for example address could be constituted of house number street number city and pin code again name could also be a composite attribute as it could be constituted of first name middle name and last name now let's talk about relational model in relational model the data and relationships are represented by collection of interrelated tables each table is a group of column and rows where column represents attribute of an entity and rules represents records say for an organization like the educational institution we can have multiple tables such as student courses department faculty etc now each of those tables will consist of a group of column and rows where column represents attributes of an entity and rows represents records relational models follow a set of rules known as the voice code rules the first rule is information all information in a relational database must be logically represented as column values in rows within tables so this essentially talks about representing the data in a tabular structure arranged in columns and rows guaranteed access every value in a table is guaranteed to be accessible through a combination of table name primary key value and column name so each value in data is a part of a table and that data has to be accessible through column name primary key values and the table name systematic treatment of nulls nulls must be represented and treated in a systematic way independent of data type dynamic online catalog based on the relational model the metadata must be stored and managed as ordinary data that is in tables with a database such data must be available to authorized users using the standard database relational language information such as the table names the attributes of the tables their primary keys and data types also have to be stored in tables within the database and all those tables should be available to authorized users using the standard database relational language comprehensive data sub language the relational database may support many languages however it must support one well-defined declarative language with support for data definition view definition data manipulation interactive and by program integrity constraints authorization and transaction management begin commit and rollback so this essentially means that there should be a standard language that will help us perform various functions in the database such as creating tables modifying data updating deleting data and it should also provide support for data definition view definition integrity constraints authorization etc view updating any view that is theoretically updatable must be updatable through the system high level insert update and delete the database must support set level inserts updates and deletes physical data independence application programs and ad hoc facilities are logically unaffected when physical access methods or storage structures are changed [Music] logical data independence application programs and ad hoc facilities are logically unaffected when changes are made to the table structures that preserve the original table values that is changing order of column or inserting columns integrity independence all relational integrity constraints must be definable in the relational language and stored in the system catalog not at the application level distribution independence the end users and application programs are unaware and unaffected by the data location non-subversion if the system supports low level access to the data there must not be a way to bypass the integrity rules of the database this essentially means that the integrity constraints of the database have to be preserved at all cost rule 0 all preceding rules are based on the notion that in order for a database to be considered relational it must use its relational facilities exclusively to manage the database now let's talk about a few relational model concepts the first one is attribute attributes are the properties that define a relation now the table employee here has four attributes employee id name phone number and city id relation schema a relation schema represents the name of the relation with its attributes for example employee has attributes employee id name phone number and city id it is a relation schema for employee if a schema has more than one relation it is called relational schema tuple each row in the relation is known as tuple relation instance the set of tuples of relation at a particular instance of time is called as relation instance table employee shows the relation instance of employee at a particular time it can change whenever there is insertion deletion or updation in the database degree the number of attributes in the relation is known as degree of the relation the employee relation defined above has degree four so right employee has 4 attributes hence it has degree 4. cardinality the number of tuples in a relation is known as cardinality the employee relation defined above has cardinality 4 column column represents the set of values for a particular attribute for example the column employee id is extracted from relation employee null values the value which is not known or unavailable is called null value it is represented by blank space for example phone number of employee having employee id 4 is null [Music] here employee id 4 does not have a phone number and hence this right here is null or blank constraints in relational model constraints are conditions that are imposed on data in relations any insertion updation or deletion operations must satisfy these constraints before being performed else's operations will fail next we will understand the types of constraints there are three types the first one is domain constraints these are constraints at attribute level an attribute can only take values which lie within the range of defined values for example phone number of employee can only be integer then having an alphabet is not allowed key integrity every relation in the database should have at least one set of attributes which defines a tuple uniquely those set of attributes is called key for example employee id in employee is a key no to employees can have same employee id so a key has two properties it should be unique for all tuples it can't have null values the third is referential integrity when one attribute of a relation can only take values from other attribute of same relation or any other relation it is called referential integrity city id in employee relation can only have values present in city id of city relation so i'll go back to my employee and city tables now we observe that city has city ids one two and three and if there is a referential integrity between the city id and the city id in city table then the city id in employees cannot have any values that is outside the values present in this column of the city table so it cannot have value 4 unless there is also a corresponding city id 4 in the city table let us now talk about relational algebra it is a procedural query language that takes relationships as input and returns relations as output after applying operations to the relations the basic operators are selection denoted by a sigma it select tuples from relation based on conditions so sigma condition and relation for example sigma city id greater than 1 in the table employee will return all the results such that city id is greater than one however it will not display the results this requires projection and that brings us to the next operator that is projector and is denoted by this greek symbol that's called pi used to project chosen columns so by columns chosen columns separated by commas and the relation name we want to display the name and city id columns of the relation employee and this displays the result next we have the cross product which matches every row in first table to every row in the second table relation 1 x relation 2. [Music] for example if we want the cross product of employee and city and these are the tables that we have we are going to get this particular result as a part of the cross product so we have that all the values of the employee table are being matched against all the values of the city table so if there are four tuples in the employee relation and three tuples in the city relation then we are going to have 4 multiplied by 3 that is 12 tuples in the result set union union on two relations r1 and r2 can only be computed if r1 and r2 are union compatible that is these two relations should have the same number of attributes and corresponding attributes in two relations have the same domain union operator when applied on two relations r1 and r2 will give a relation with tuples that are either in r1 or in r2 denoted by r1 u r2 so if we have the employee and the student table where employee id name and city ids are the attributes of employee and student id name and city id are the attributes of student then the student union employee result set will look like this now each tuple of this result set is either a part of the student or the employee relation observe that the third tuple in the employee relation is also part of the student relation and hence it appears only once in the result set also the corresponding columns have the exact same data type employee id is integer student id is also integer city id in both the tables are integers names in both the relations are of type varchar minus operator minus on two relations r1 and r2 can only be computed if r1 and r2 are union compatible minus operator when applied on two relations as r1 minus r2 will give a relation with tuples that are in r1 but not in r2 denoted by r1 minus r2 now if we do a minus now if we do um now if we do employee minus student this is the result that we will get essentially it will subtract the common tuple between employee and student from the employee table and this is the result set that we are going to get finally we have the rename operator which is denoted by a row rename operator is used to give another name to a relation now we shall talk about joins in tbms here i will be using some sql or structured query language for you to have a better understanding of how dbms uses joins however it is not compulsory if you want to understand that just at a conceptual level so let's talk about joints now now what is a join a joint clause is used to combine rows from two or more tables based on a relational column between them so a join is nothing but a way to combine two or more tables and this is done on the basis of related columns between them now to give you an example i'll just start with a very basic one so i'll do a select star from the table person which i've already created beforehand and when i run this i find that these are the columns id name city present in here there are a bunch of numbers in id uh letters in name and name of cities so i'll just copy this data and i'll paste it here in my cell now moving on i just go and see what i have in my student table and when i run this i also find that this has three columns but the third column is scores and the numbers are also different ie three four five and six whereas person had id one two three and four so also to copy this data yeah better now what i will do next is i will join these two tables person and student on the basis of id column and we'll see what i get here so i'll do a select star from student join person on [Music] student dot id equals person dot id so now we observe that our result set contains six columns and these are id name and course and again id name city these are nothing but the columns from student so the first three columns are from student table and the next three columns are from the person table and as you can see this has the column city while this right here has the column course now i know this is not very clear and this was just to give you an idea that this is how we can use joins to combine two tables we see that the result set now contains both the tables data now to move further on we need to learn some basic concepts so here we have four types of joins and there is another one that i will explain to you later so this image i downloaded from the internet and it very beautifully and it very aptly explains the joints so when we use a left join it essentially means that we are going to include all the results from the left table and only those results from the right table which are an exact match with the left table this will be clear when we work on left joins and then again come the right join so there will be again a left table and a right table all the values from the right table will be present in our data set and only those values in the left table that intersect with the right table will be present in the data set and when we go to inner join we observe that only those values which are common to both left table and the right table will represent in our data set and when we talk about full join it means that all the values from both the tables will be present in our data set and when i talk about values here you know when i said that all the values from the left table will be present and only those from the right table will be present which are common to left table i mean that the ids or the columns on the basis of which we are doing the join now let us head back and look at our result what we had here this join is nothing but the inner join that we learned right here and only the values that are common to both the tables were present and how do we know that now i'll just copy this result [Music] and i will paste it here [Music] now what i want you to observe here is that 3 and four are the values that are common to both the tables in the when we talk about ide and this is what matters because id is the column on the basis of which we are joining person and student so three and four were present in both and hence in the result set also only three and four were present now what would happen if we had a left join right okay so my guess is all the ids from the student will be present and only those ids in person which are also present in the student table will be present in our result set so if i look here all the ids from the student table that is 3 4 5 and 6 will be present in our result set and only 3 and 4 from the person id column will be present because these are the only ids that are part of the student id column and also i want you to observe that left join gives preference to the left table so student is to the left of the joint clause and person is to the right of the joint clause and we talk about left join it gives preference to the student table right here so when i run this we observe that 3 4 5 and 6 that is all the ids in the student table are present in our result set and only those ids that is 3 and 4 which are common to the student table are present in our result set one and two were eliminated from the result it is also not necessary that we can do joins only on the pieces of one column we can also have and student dot name equals person dot name we can join the two tables on multiple conditions so here the first condition is that student id should equate to person id the second condition is student name should equate to person name also the column names need not be exactly same you could have something like person underscore name as the column name so what happened here is 3 and c found their corresponding values in 3 and c here in the percent table however 4 and t did not find because both 4 and t have to find their corresponding values it just can be that 4 found a corresponding value an id and d did not find a corresponding value because it is an and condition right it is not an or condition so both id and name have to match so that is how we ended up with null here so let us now turn it into a right join and this time my guess is the preference will be given to the person table so right now we have the ids 3 4 5 and 6 which will now turn into one two three and four so let us run this and we find that all the addis 1 2 3 and 4 are present in our id tape in our table however only 3 is present in our result set why because both again id and name have to satisfy the condition so 3 and c both found their corresponding values in another row however 4 in spite of having a corresponding id did not have a corresponding name for c so this did not happen if i however i got rid of the name then 4 will appear here and we see that yes it happened right so this explains right join now we are clear with inner join left join and right join we can also write right join as right outer join let's see what we get here we get the same result right and if i remove this here again also i found the same result that we got before so left outer join and left and right outer join can also be written as left join and right join now let us discuss full join and now we'll head back to our diagram here full join gives us all the results from both the tables now let us run this and this time my guess is we will find all the ids one two three four and five and six so let us run this and okay for the timing let us remove this condition as well right so you find that we have three four two and one from person and also we have three four five and 6 from student right and if we had this condition as well now what would happen here is that only this row would remain as it is rest of it will be affected we see that only 3 and c that ig 3 bears still still bears the same result right and then let us move to cross join now this is an interesting type of join because we will see what happens here cross joint and for question we don't need the own condition why because we'll see that here each row is matched with another row of the other table so essentially if we have so essentially if person has m rows and student has n [Music] rows then our result will have m multiplied by n rows [Music] right so this is nothing but a cross product of both the tables this particular row is from the student table and it is repeated four times first time for the first row second time for the second row third time for the third row four time for the fourth row right and this happens every interval for each row of the first table okay so this so this is how a cross join works relationship type represents the association between entity types this can be established via a set of primary and foreign keys so if you want to represent the relationship in er model this is one way of doing it student is enrolled in course so student and course are the entities and enrolled in in this rhombus here denotes the relationship between these two entities now there are three types of relationships one to one one to many and many too many [Music] one to one when a single record in the first table is related to one record in the second table and single record in second table is related to only one record in the first table then it's called a one-to-one relation now we have these two relations employee and salary employee id 1 is present only once now for each employee id we also have only one corresponding employee id in the salary table and for every employee id present in a salary table we also have an employee id present exactly once in the employee relation in the er model representation it is denoted by these numbers 1 and 1 which means one employee draws one salary one-to-many relationship or one is to m this is how we can denote this relationship when a single record in the first table can be related to many records in the second table but a single record in the second table can be related to only one record then it's called a one-to-many relationship we observe here that one agent here could be associated to multiple entertainers in the entertainer relation but multiple entertainers could be associated to one single agent so this entertainer here ml can be associated to only one agent but agent id 1 can be associated to multiple entertainers we denote this relationship in the er model representation by having 1 next to the agent entity and m next to the entertainer entity [Music] now let us talk about many-to-many relationships and it is denoted by m is to n when a single record in the first table can be related to many records in the second table and a single record in the second table can be related to many records in the first then it's called a many-to-many relation so we have the movie relation the entertainer relation and this is a data lineage relation which essentially connects movie ids to entertainer ids right so we have that for each movie id we are connected to multiple entertainers through this data lineage table so movie id1 is connected to entertainer id2 and also entertainer id3 also one entertainer id could be connected to multiple movies so entertainer 1 is connected to movie id2 and also movie id3 so this right here is a many-to-many relationship it is denoted by having m near one of the entities and n near the other entity now this right here is a complete er diagram for a student enrollment system we observe that there is a many to one relationship between student and enrollment many-to-many relationship between student and lecturer and these are the attributes associated to the student table these are the attributes associated to the enrollment table lecture has these particular attributes associated with them and the lecturer has these attributes associated to the entity now let us discuss a few more terminologies the first one is functional dependency it describes the relationship between attributes in a relation for example if a and b are attributes of relation r b is functionally dependent on a denoted by this arrow mark if each value of a is associated with exactly one value of b that is a and b may each consist of one or more attributes determinant it refers to the attribute or group of attributes on the left hand side of the arrow of a functional dependency now if we observe here this one is a functional dependency in the relation that we have here so student id and project id so each value of these two attributes taken together will uniquely identify all the other attributes taken together so student id 1 and project id 1 will uniquely identify all the other elements in project duration student full name and student last name similarly student id 1 and project id 2 uniquely identify 4 ml and jones next we have determinant it refers to the attribute or group of attributes on the left hand side of the arrow of a functional dependency full functional dependency it indicates that if a and b are attributes of a relation b is fully functionally dependent on a if b is functionally dependent on a but not on any proper subset of a now observe here project duration student first name and student last name are functionally dependent on student id and project id but not on any proper subset of this set of attributes like project duration student full name and student last name are not solely functionally dependent on student id or project id alone these two have to come together to be the determinant for these attributes that is project duration student first name student last name partial dependency a functional dependency a determines b is a partial dependency if there is some attribute that can be removed from a and yet the dependency still holds so like we have here student id and project id together can determine project duration but also project id alone can determine the project duration how well student id 1 and project id 1 will give us project duration 1 1 2 will give us 4 then 2 3 will give us 4 and so on but we also observe that project id 1 is mapped to only one value of project duration so one here corresponds to one one again corresponds to one four corresponds to one three corresponds to four and so on so this right here is a partial dependency when we talk about student id and project id being the determinant for project duration [Music] now let us talk about keys we are going to discuss super key candidate key primary key alternate key and foreign key so a super key is any key that uniquely identifies each row in short the super key functionally determines all of a row's attributes a super key may contain additional attributes that are not necessary for unique identification and we are interested in identifying super keys that contain only the minimum number of attributes necessary for unique identification for example student number uniquely identifies each row of the student tuple however student number and student last name taken together will also uniquely identify each row similarly student number student last name and student init will uniquely identify each row so we can see that student last name astro and last name and student in it these are redundant when uniquely identifying each row student number alone can do the job so when talking about super keys we might also include some attributes which might not be necessary for unique identification candidate key a super key such that no proper subset is a super key within the relation there may be several candidate keys for a relation when a key consists of more than one attribute we call it a composite key a candidate key can be described as a super key without unnecessary attributes that is a minimal super key using the distinction note that the composite key student num and student last name is a super key but it is not a candidate key because student num by itself is a candidate key the combination student last name student first name student init and student phone might also be a candidate key as long as you discount the possibility that two students share the same last name first name initial and phone number so what we essentially mean is that a candidate key is basically a super key but without the redundant columns it is a minimal set of attributes taken together that can be used to identify each row uniquely primary key the candidate key that is selected to identify tuples uniquely within the relation within the table each primary key value must be unique to ensure that each row is uniquely identified by the primary key in that case the table is said to exhibit entity integrity to maintain entity integrity a null that is no data entry at all is not permitted in the primary key now if we go back to our candidate keys here we will understand that why student num is the primary key because it will never be null however these set of candidate keys can never be primary key because at any point we could have student phone number to be a null value in that case this automatically disqualifies from being a primary key next let us talk about alternate key the candidate keys that are not selected to be the primary key are called alternate keys foreign key an attribute or set of attributes within one relation that matches the candidate key of some other or possibly the same relation when an attribute appears in more than one relation its appearance usually represents a relationship between tuples of the two relations a foreign key is an attribute whose values match the primary key values in the related table [Music] now that we understand what are keys and what are functional dependency we can talk about normalization normalization is a process for evaluating and correcting table structures to minimize data redundancies thereby reducing the likelihood of data anomalies the purpose of normalization is to identify a suitable set of relations that support the data requirements of an enterprise the characteristics of a suitable set of relations include the following the minimal number of attributes necessary to support the data requirements of the enterprise attributes with a close logical relationship described as functional dependency are found in the same relation minimal redundancy with each attribute represented only once with the important exception of attributes that form all or part of the foreign keys which are essential for the joining of related tables now this relations stuff and branch here are in the normalized form but if we denormalize them then we get stuff branch taken together now we will try and understand why having a normalized form is better than the denormalized form [Music] it is essential to address three types of anomalies the first one is updation anomalies if we want to update branch address of a branch then we have to update the multiple tuples in staff branch relation that is the denormalized relation this won't be necessary in normalized form where we have to update only the branch relation so we observe that if we want to change the branch address of say branch number b003 then in the denormalized form we are going to have to update it in the second row the third row and the fifth row whereas in the normalized form we only have to change it once in the third tuple of the branch relation insertion anomalies to insert multiple new stuff in branch in stuff branch relation we have to correctly enter branch address to all the tuples however in normalized form we only have to write the branch number correctly also to insert a new branch in the denormalized stuff branch relation is difficult as all the columns except branch number and branch address have to be null this is not the case in normalized form where this can be easily achieved with a new tuple in branch relation now here in the denormalized form every time we insert new stuff we also have to mention correctly the branch address but in the normalized form if we have new staff members coming in we only have to enter the branch number correctly also say we have a new branch that does not have any stuff yet in the normalized form we can easily have another row in the branch table and that is it but in the staff branch we cannot really have a branch address and branch number without the stuffed details and if we do this attributes are all going to be null with just a branch number and branch address which will look really strange deletion anomalies deleting all the tuples associated to a particular branch leads to loss of branch details in denormalized form going back to our normalized and denormalized relations we're going to observe that if we have all the stuff of a certain branch say b005 erased from the relation then we won't have any details of that particular branch in our database but that won't be necessary in the normalized form because even if we don't have all the stuff members from branch number b005 we still have the branch details in our branch relation so the loss of data is avoided here [Music] now let us talk about normal forms we are going to discuss four types of normal forms first normal form or one and f second normal form or two and f and the third normal form denoted by three and f and finally the boys called normal form now let us start with the first normal form here there are no repeating groups in the table in other words each row or column intersection contains one and only one value not a set of values all attributes are dependent on the primary key relation is in first normal form if every attribute in that relation a single valued attribute so we have this denormalized student table because the phone column does not have single valued attributes and to normalize this table what it did here was we created a separate row to accommodate another phone number that belongs to emily jones and as we observe here that all the attributes in this student table are dependent on the student id so this right here is the first normal form [Music] moving on second normal form or two and f the table must already be in one nf or the first normal form second normal form applies to relations with composite keys that is relations with a primary key composed of two or more attributes it includes no partial dependencies that is no attribute is dependent on only a portion of the primary key in other words no non-prime attribute or attributes which are not part of any candidate key is dependent on any proper subset of any candidate key of the table so we have student id and project id together as a candidate key project duration is not a part of candidate key hence a non-prime attribute but project duration is dependent on project id a portion of candidate key this scenario is called partial dependency now let us view this table that we have here student id and project id uniquely identify each row of this relation so these are a composite primary key and naturally they are also the candidate key and if you observe closely project duration which is a non-prime attribute that is it is not part of the candidate key it can be uniquely identified with the help of project id for project id 1 we have project duration 1. again project id 1 corresponds to 1 2 only corresponds to 4 right 3 corresponds to 4 so project duration can be uniquely identified by project id and this here is called a partial dependency now what we can do here is we can convert our table into three tables first part of the candidate key or the primary key that is student id and it will have student first name and the student last name the project table that is the non-prime attribute and the attribute that it was dependent on are grouped together into another relation and finally we have a third relation which has both the constituents of the candidate key or the primary key here we need both the student id and project id as the composite primary key for the assignment table in project we have project id as the primary key in student we have student id as the primary key and this right here satisfies the second normal form as you won't find any partial dependency here in these relations next let us move to the third normal form or three nf a table is in third normal form or cnf when it is in second normal form it contains no transitive dependencies a transitive dependency is a dependency of one non-prime attribute on another non-prime attribute the problem with transitive dependencies is that the steel yield data anomalies here this table right here is already in second normal form because i derived it from the student table here and just added two more columns such that country and city are both non-prime attributes because student is a candidate key and primary key city and country are non-prime attributes because they are not part of the candidate key but country is dependent on city this is transitive dependency because both country and city are non-prime attributes again to solve this problem what we do here is we divide our relation into two relations the first one is a student and the second one is location here we have city column as the referential integrity that holds student and location together last but not the least we have the boys called normal form a table is in boyce-codd normal form when every determinant in the table is a candidate key that is here we have the dependencies student and teacher uniquely identify subject student and subject uniquely identify teacher teacher uniquely identifies subject so student teacher together and student and subject together are candidate keys but teacher is not a key right because it does not uniquely identify both subject and student but for this relation to be in bcnf every determinant in the table should be a candidate key that is teacher should also be a candidate key [Music] so what we did here was we divided it into two tables teacher and student teacher uniquely identifies subject and the teacher can be taken as a candidate key because the subject does not uniquely identify the teacher so the determinant here is also the candidate key in the student table we observe that we need both the student and the teacher to uniquely identify each row so this right here is a composite primary key and we need both the attributes together to be a composite key so the determinants are also part of the candidate key and thus this satisfies the boyce-codd normal form [Music] in our final section let us talk about indexes an index is an orderly arrangement used to logically access rows in a table indexes in the relational database environment work like the indexes described in the above point from a conceptual point of view an index is composed of an index key and a set of pointers the index key is in effect the index's reference point more formally an index is an ordered arrangement of keys and pointers each key points to the location of the data identified by the key an index can be used to retrieve data more efficiently but indexes can also be used by a dbms to retrieve data ordered by a specific attribute or attributes when you define a table's primary key the dbms automatically creates a unique index on the primary key columns you declared so we have a student table here and say student id is the index key and pointers to student table rules so we have index key 1 that is when student id 1 it essentially means that the pointers will be pointed to row number 1 and two so this right here one and two these are the two rows that the pointers will be pointed to for index key one which in our case is student id index key 2 is pointed to the third row right so the third row right here has the index key or the student id as 2. the index key for tree has pointers in the fourth and the fifth tuple and finally the pointers to index key four are pointed to the sixth tuple so this is how indexes store data so when you want to access the student id 3 it does not need to scan the entire table to be able to give you the result with the information stored in the indexes it knows that it needs to reach the fourth and the fifth tuple to be able to retrieve this information and it will directly access these two tuples so this brings us to the end of the database design course hope you enjoyed this video thanks for watching till the end have a great day goodbye thanks for watching this video don't forget to like this video and drop your thoughts in the comment section below also subscribe to the channel and press the bell icon to get instant updates more videos coming up stay tuned