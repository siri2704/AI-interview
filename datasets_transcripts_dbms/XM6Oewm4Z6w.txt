 Hello, welcome to CHAPTERS. Today we are going to discuss second normal form. This is with the continuation of table used in the previous class We added a bit more attributes in that table to explain this second normal form. Now we will see what all are the conditions for a table in second normal form First condition says, it should be in first normal form ie the table should be already in the first normal form. First normal form condition is, there must not be any multivalued attributes That condition has to be satisfied. Let us see the second condition All non keys are fully functional dependent on the primary key. ie In a table there are keys and nonkeys. In this, all nonkeys has to be fully dependent on primary key. There is one more condition or the same is being said in another way, it says No partial dependency ie. when we say there should exists a fully functional dependency, it also says there should not be any partial dependency. A questlion arises what is full dependency and what is partial functional dependancy? Functional dependency is used in a table to find out the relation between keys and nonkeys or to denote the relation  So functional dependency is coming in two forms, as we said, fully functional dependency and partial functional depandancy. This problem comes if the key in the table is  a composite key. What is composite key? If a key is made by joining more than one attributes, then it is called a composite key. We will take an example for that Suppose we have a table with four attributes a,b,c,d. Now I am going to write the functional dependancy between them. here ab->cd. That means this dependency is existing in that table. and the key here can be considered as ab. That means, if attributes a and b is combined then ONLY it can determine cd. We already know ab is determining ab itself. and to determine an entire row ab is the only key that can be used. We will now consider one more dependency b-> c also existing in the table. In that case, if ab exists together then it can determine c and b can also determine c alone. If the dependency in the table is in this way, we will say it is a partial dependency. In other words, if b->c is not there in that table, only a and b together will be able to determine c and d, and cd is fully depending on the parameter ab only. There exists a fully functional dependency. This is the brief about fully functional dependency and partial functional dependency Our first pont says, all nonkeys are fully functional dependent on the primary key. This cd has to be fully dependent on the ab and that condition is satisfying here. second definition says no partial dependency. suppose a->c or b->c or a->d or b->d . If any of these dependency is existing in these table, then that is considered as  a partial dependency. Now we will see how it is implemented in in a table to make it in second normal form You can derive a lot of functinal dependencies from this table. I have mentioned some of those over here. You may be able to find still more from these if required. We also got  a candidate key cidpbrand from this table. You can also take cnamepbrand also as a candidate key. We are able to determine every attribute correctly with cidpbrand. ie the candidate key is cidpbrand apart from that two more dependencies also just mentioned over here. cid determines cname ( cid-> cname) and pbrand -> ptype. In our definition, we mention what is a key and what is a non key. In this case key is cidpbrand that means in place of key, there is a composite key. In case of composite key, we will check which all attributes are joined to get it, that all attributes can be called as prime attributes. So here these two are prime attributes. pid and pbrand. After prime attributes comes non prime attributes. Every attributes coming other than prime attributes are dependend on prime attributes They can be called as non prime attributes. The definition mentions, all nonkeys are fully functionally depends on the primary key Here non keys are the ones o the right hand side of the arrow. Those all has to fully depend on the primary key. On left hand side, primary key is cidpbrand so fully on that, not partially that is, part of  the primary key must never determine any of the these nonkeys independently. If that happens that is a partial dependency Now look at these dependencies. cid alone determines cname ie a prime attributes alone determines a nonkey attribute. That mean a partial dependency is existing. Next we see pbrand determines ptype. pbrand is also a participant to make candidate key. In that case it is violating the condition. pbrand is a nonkey but it is able to independently determine ptype That means a partial dependency came there. You may be able to derive more partial dependency from this table. But from these two itself we can conclude the table is not in second normal form because of partial dependencies. So what is the solution? Split the table into two or more tables When we do it, each resulting table must be in the second normal form. If we make it into two, both must be in second normal form If it is three, all of them has to follow second normal form.That is our aim. Now we have split the big table into two based on the dependencies. They are the table containing customer details cid and cname and another table with product details. As these two tables are from a common table, there must be a connection between them. We have given this connection using cid. cid is coming as foreign key in product table. In customer table it is a primary key. When we analyse the second table, there also the partial dependency problem exists. The key here is cid pbrand similar to the first table, But pbrand alone is able to determine ptype and pcategory independently. That means partial dependency exists. customer table is in second normal form but as the product table is having partial dependency we have to convert it into second normal form. So we will get another group of tables. Now the table with partial dependency is decomposed into two tables . This decomposition is based on the dependecies inside them. In case of this table, price will be determined only with the key made by joining cid and pbrand A table is created based on that dependency and the candidate here is cidpbrand Now considering next table, with the help of pbrand we are able to determine ptype and pcategory So we made this table based on that relation and to give the connection, pbrand is the common element between the tables. that means it is working as a foreign key. This is a way in which we are making a table into second normal form. If you want, you can decompose the main table into these three by a single step itself Final tables are these first table, second table and third table. Three tables are the final ones. This intermediate table is  used only to describe the method or step through which the final tables are derived. This way we have seen the process happening in normalization in a theoretical way. Another type of question you can expect from this topic is by giving so many functional dependencies to check whether it is in second normal form or not In that cases we are taking a particular condition and checking that condition with respect to those functional dependencies. For that we have to find candidate key and for that we have to use closure method, and with that we will check whether the table is in second normal form or not based on the conditions That is numerical type question and we will discuss that method in next video. One more thing to note is, these tables are also not in perfect form and  there exists some anomalies. To remove that we may have to make it into third normal form. We will explain third normal form in the next upcoming videos and we will also see how the normal form is checked with the numerical method. So I believe the concept discussed in this class. Thanks for watching, see you on next class, Bye.