hey everyone welcome back again and people who are watching me for the very first time myself shashank and i've been working as a data engineer and for me it's been almost five years in the big data domain and previously worked with companies like paytm mckinsey and amazon so as i said uh my field is actually the data engineering and big data and that's what we will be talking about today and its main component or we can say basically the entire tech industry whatever we see and this is the backbone and we are completely dependent on that then the topic is the databases so we will be talking about that one database management system and before starting this video if you are new to our channel and watching any of our video for the very first time then make sure to like this video as well because this is going to be the very informative from zero to the level n so that you can get a complete understanding of databases and also to get such kind of amazing content on a regular basis make sure to hit the subscribe button as well so yes let's start with our agenda first so the agenda is basically uh to set a background for the databases its need and slowly we will be talking about its component its technicality architecture related and how uh it basically became the backbone of entire software or tech industry why it is important and different types of databases and some very very important things right which are even very important for the development perspective the software development and i know at least uh if you are from student background and like this could be your subject as well the databases i have done my like mca and in our syllabus this was the topic database and one of the important one so this is the entire agenda and uh we will deep dive into this databases and i will also share some cool case studies as well for real world projects how its database looks like and talking about its technicality so let's jump on to that first we will start with the introduction of the dbms and uh within the dbms i mean the first and very important thing is to understand the database keyword itself that what the database why we are calling it and what uh the why we actually need it so we first need to understand those terminologies and for that we will first try to understand what is database so as per the technical definition or i will also try to elaborate in terms of the general definition so just imagine right you guys are using the internet and you are using different kind of applications let's say within your like mobile you are using different apps and on the internet on on the browser you are using different kind of web application so everything is the data right the very basic example let's say you just go to cyber cafe to fill any kind of form like examination form so you go there log in on to their website and after that you fill your data and everything is with them and you will get your registration number and they will keep your detail and after some time you will get your admit card so how this is actually happening let's say you just fill your information and it is not somewhere stored right so how would they even know that somebody like shashank has applied for our like examination so this is the very basic example in order to process something and in order to just modify anything and in order to play around the things so you need the data without the data you cannot even do anything beat any web app be it any android ios application so data is everything that's why uh this database was something which was discovered and its technical definition is basically a database is an organized collection of data that can be modified retrieved and updated and that's the true and practically we have seen it as well so uh if we are from the software background so we know what the database is actually so in technical terms just treat it like a bucket or treat it like a any external entity right which is able to store your data in any kind of specific format so let's say you want to organize your book so you will open your shelf and you will place it like one after uh each and that's how you placed it and similar way just whatever you want to store in the practical life you have something for that to keep it right a box a ball and something like that so even if we want to let's say store the data in some specific format and why specific format because uh we are not going to keep this data for let's say like thousand years we will be using it every day there will be modifications there will be new data coming in and probably we will be cleaning up some data as well like deleting part as well so that's how a database is basically an organized collection of data which can be modified retrieved and updated so nowadays in the modern tech industry right there are a lot of databases there are different different categories and we will be talking about that one as well but on like highly used or you can say basically most often used uh database is something which stores data in the tabular format right let's say you might have seen uh like the excel sheet right in in your laptop where you create some column names and start filling the data there right so in the similar form uh there is a database which can store the data in that format right and in in that particular database we call this shape of data as a table and uh its granular shape is like row and column basically so let's say we have three columns is to store name and the college name and the marks and there will be multiple entries for that so it's it is as simple as that third is every website uh which needs us the sign up part uses the database and that's what i was saying because they will keep your data as soon as you make a login uh let's say any food delivery app an e-commerce application as soon as you log in they will keep your data and that is the entry point and it will be stored somewhere and will be processed further and this is true that's why even i have highlighted the no internet so there is no internet without databases and that's true if you are not able to keep the data what would you process so the part i was talking about the database so here uh let's say this music right let's say that's that's the outer line treat it like a box and what we called it we called it as a database which is going to store the data related to the music that's why uh i have labeled it as a music and this outer boundary is again just treat it like an empty box where you are going to place your data and within that you can see right different different types of data you can actually place here so one table so here this this point was table right within the database we will be storing the data in the form of table and which will contain the data in the shape of rows this these are the rows and these are the columns so one table named as artist which actually store the data for artists so let's say artist id name and description similarly albums so album id album name and description ratings uh there can be another table like rating id album id and rating so these are the kind of data we can store here and this is the very simple pictorial notation of the row column kind of database so let's move on to the next point so here in the beginning as i mentioned now the tech industry has advanced a lot and based on the different different use cases and based on the innovation in the tech industry we have different different variation and different different categories of databases so in the previous slide what we talked about that was the most often used where data will be stored in the form of rows and columns now i'll be talking about different categories which will actually store the data in different different shapes and different different format so types of databases first can be object oriented database so this this is actually related to the oops concept as well object oriented programming concept so if somebody is from the programming background and knows the object-oriented programming like java c plus plus scala so there we have a concept of classes and object okay so object is something which is an active entity and each object will have its own attributes its own behaviors so similarly we have a kind of database as well which uh don't store the data in the form of row and table it actually stores the data in the form of object so let's understand it from the technical definition perspective so object oriented databases are the databases that present data in the form of objects and classes in object oriented terminology and object is a real world entity for which we basically compute something and we use it and a class is a collection of objects so these are the standard and technical definitions so if you just want to understand what's the example of such kind of databases so postgres is basically a kind of a database uh which stores the data in the object format so in future let's say in any of your development tasks or any of your software project you might need this kind of object-oriented database as well and the choice of database will most of the time depend on the use cases as well right so let's say you have 10 things on your table and at a particular point of time you want to use something so first you will decide right at this moment which thing we can use and what will be the good fit for particular situation and that exactly happens with the databases as well and in real world development that's how we uh design the things right so we know this topic as well system designing where we need to actually counter and where we actually need to decide what kind of database we'll be using why this one why not that one so that comes from the practice that comes from the industrial experience and that comes from the experience of system designing and understanding the real world use cases so next category would be the relational databases and that's what we were talking about so previously so uh the example i showed you right the music database within that there were different different tables and which were storing the data so relational databases is a collection of data items with predefined relationships between them okay so there in previous slide if i can show you we had artist albums ratings so here you can see the relation right if you like simply understand the music industry so we will have artists those artists will record some albums and as a listener i will be rating i will be giving some ratings to different kind of albums okay so we know somehow these entities or these tables will be related with each other okay although this data is separated but somehow we will be doing a kind of lookup or we will be able to make that mapping so that we can identify that this artist has recorded this album and this album has got this many ratings so that's why this is called the relation and that's what the relational database is all about and in the rdbms these items are organized as a set of tables and the data will be in the form of rows and columns and the very popular example is the mysql so this is an open source database which is a kind of a relational database as well on we actually call it the transactional database as well we will talk about those topics in the later slide but here this is what we have for the relational database category next the distributed database so this is the actual part of the big data ecosystem as well because uh these kind of rdbms system or relational databases have some limitation of scalability and when we talk about the big data volume is quite big in the terabytes petabyte and like exabyte so here obviously we need something which can scale and when we talk about descaling so we are actually talking about the horizontal scaling where we can add more and more commodity hardwares whenever we need and we can store the data in the distributed format so that we can get default tolerance as well our data is not lost uh and the and our data is not lost because of the data replication and other things those kind of facilities will be provided by the databases which are known as the distributed databases here so in the distributed databases is an integrated collection of databases that is physically distributed across sites in a computer network and that's what we are talking about so when we talk about the bunch of commodity hardwares and uh like bind it together with a computer network so that will be known as a cluster okay and as soon as we are restoring something that will get distributed on these kind of nodes and uh that's how you achieve the distribution data distribution so there are many many well popular and uh like you can say most often used distributed kind of databases uh so we have cassandra we will be having hbase as well we will be having mongodb okay and many other these are the actual example of the distributed databases which i have mentioned here as well next the hierarchical database uh we uh we might actually face a situation or a use case where like somehow we need to design a kind of database and within that database data will follow some some level of hierarchy right so just imagine a tree tree data structure kind of thing where we'll be having the root and left node write node leaf node so that is also one of the hierarchy same in the graphs so a hierarchical database is a data model in which data is stored in the form of records and organized into a tree like structure right or we can say parent child structure in which one parent node can have many child nodes connected through links and the example for the hierarchical a kind of database is the ibm information management system like the developed by ibm and the actual complete name was ibm ims information management system so this database actually stores the data in the hierarchical form like in the records will be actually created in the form of nodes and all those nodes will follow some kind of connection with some links so this is the uh theory behind the hierarchical databases and these are the four most important categories of databases and i have talked about the examples as well so next uh move on the actual party dbms so first we try to understand what is the database now we will see what is dbms so to understand the dbms uh the technical definition is it is a database management system which is a kind of software for storing and retrieving users data while considering appropriate security measures so previously we talked about the blueprint the database was a kind of blueprint but let's suppose one thing that even when you work on the application web application or any software right uh so you will actually create different different services for it you will create different different components for it so that you can actually use an application let's say again the very simple example you have any application in your mobile and as soon as you open if it don't have any sort of ui and if don't provide any kind of search button or any kind of let's say add to cart button how will you be able to access the particular item and any kind of data obviously you won't be available obviously you won't be able to do that so same goes with the databases as well so database is a very very base layer for anything like and the technical thing it was a basically thing to store the data but in order to just access it uh programmatically in order to access it via some application via some network right so you need a kind of software layer which will uh basically manage everything for your database like uh giving you the entry point to basically make a connection and like giving you the entry point to insert the data update the data retrieve the data and even applying some very very important security layers because data is crucial so that why so that's why it is so that's what dbms is basically called as the software which gives you these kind of facilities and so that you can work on the database it consists of a group of programs which manipulates the data that's what i said because if you don't have those kind of instructions right if you don't have anything like that available with you how would you able to command your database that i am sending this data you need to store it so who will do it this set of programs or that software so that software layer will do it for us the dbms accepts the request of data from an application instructs the operating system to provide the specific data that's how the entire uh this back and forth works while like manipulating and retrieving the data in large system dbms helps user and other third-party software to store and retrieve the data that's what we have different different kind of databases as well they have different mechanism to store the data and those like we call them as a dbms complete dbms which gives every component and that can be used by any user any program and any software application which will make connection and store the data in the physical location dbms allows user to create their own databases so in this first slide where i was talking about the outer bucket which was named as music so let's say just imagine a very large warehouse right where like n number of people can go and uh they can just buy some space and they can put their own thing and you will be provided a label because uh that is specific to you so similarly right in an uh kind of dbms system any user there can be n number of users and every user can have their own database because it's a kind of dbms is a complete manage application for you right which provides these kind of facilities so that different kind of users can create their own databases and we can store the different kind of data whatever we want so here if you see right uh this is a very simple example at how we actually uh different different application or different different kind of things can use the database so this is the application these are the users which are interacting with the databases and pulling the uh data from the database which is actually uh stored here so that's how the dbms this is basically a point which is referring so api is something again set of uh you can say program or set of instruction which will interact with the database and will uh fetch the data from this point where our data is stored on the physical devices based on the api instruction it will pull the data from that specific database from that specific table and will uh just pass it back to the api if it was queried from there and same the user and any other application so that's the whole fundamental and the technical aspect of the dbms now we'll be talking about its characteristics we will try to understand what are the different different characteristics of the dbms so the first characteristic is the uh it is the real world entity obviously we uh basically talk about whatever we think right whatever we want to store uh in the world of databases uh whatever we are trying to keep that is somehow a real world entity whether we talked about uh let's say uh any user data so user will have a name they have their age their address so these are the some real world and practical things and that's why we we call it like a any any kind of storage system which uh holds the data for real world entities next the relational databases so relational databases was one of the type for the databases we talked about and even to work with the relational kind of databases we will have a dbms and ultimately it is known as the rdbms relational database management system and we know the simple property of rdbms like every table will have some sort of link or some sort of relation with each other structured query language this is the important part as well and one of the important thing and in the shorter form we know it as a sql right so in simpler form how can i explain it let's say you are learning java you are learning c plus you are learning python so these are the programming languages in programming languages what we do we write some set of instruction and those programs actually accept some kind of input from the user and based on that input that program will get executed and we will get some kind of output generated from it so same goes with the uh like sql as well so sql is a kind of language which is designed for the databases so that we can use this language and whatever logic we will be writing in this logic that means that will be transferred to the database and that is nothing basically a language which is specifically designed to communicate with the database right in order to insert in order to update in order to delete and in order to do any kind of query or in order to do any kind of data manipulation on top of it so this is the kind of language which is designed specifically for the databases isolation of the data and application and that's true if this concept of database actually provides a application and the next is isolation of data and application that is also true when we are talking about the software products we will see the application part right whatever user is using that is the application part and its back end is somewhere else and that is actually communicating with the you can say the databases so we can see the clear segregation your application the actual component which consists the actual logic is a separate entity and your database is separate entity so they are not uh you can say running in a same box they can like they can be uh like placed on different different places and they can communicate with each other so the concept of database actually provides this sort of isolation and let's say it was not there so somehow application had to manage this data as well uh probably storing it in memory and any kind of mapping but obviously that is not a practical solution uh because we also have a limited memory be it the external part be it the uh in memory thing so that's how the data base is something which provides this sort of isolation next the acid properties so these are specifically related to the transactional databases and uh we will be talking about it in depth like what is acid as a uh like full form we can understand it a from the atomicity sees consistency i is isolation d's durability so these database management systems actually provide this kind of important properties uh which makes it a transactional which makes the database consistent and and many other uh technical stuff next the multi-user and concurrent access so database as i already said uh if you imagine a large data warehouse similarly uh the database is something one of the entity which can be used by multiple user i can access the same database and another person can also connect to the same database application and we can have our different different database within the same uh dbms right so that's how the multi-user and concurrent access at the same time like obviously n number of people can point to same set of record same set of the table our same set of the database because that's how like in the modern application every minute like there will be thousands of the concurrent request which will be like trying to access the similar data right let's say i can access the same record for different business logic for different purpose and somebody else can use the similar record and similar data similar table for their own purpose so concurrent part is something which is important and the multi-user thing which is the important part of the dbms systems next the transactional processing and that is again one of the part of the acid properties when we will be talking about that one we will get the good idea what the transaction is and why it is important third is the uh and the next is the less redundancy and consistency so these dbms are actually designed in such a way that our database will always be consistent and like there will be very very minor chances of having the redundancy if we are following the best practices to avoid those kind of redundancy so that's how these dbms applications are designed and we will also talk about it in the later section data security and integrity so the integrity part is something which helps the database to uh maintain that level of consistency if integrity or you can say integrity constraints are not applied our data won't be consistent for example let's say i have declared one variable which is named as integer and any random point of time if i am able to see float value in it so this is the data inconsistency because i defined it as an integer but it is holding the float value how it can happen so that's how the databases actually manage these things as well so that data don't get corrupt and data is actually consistent throughout the life cycle and the data security it also like these dbms systems also provide the mechanism or you can say basically kind of set of instructions so that you can secure your data and it can be only accessed with the proper authentication so these were the some practical characteristics of the dbms or the database management systems now we'll be looking at the important part and to like reflect the main main purpose of having the dbms so that is the application of dbms uh here i have listed down some important domains or industry related things where this uh dbms is getting used so uh first is the banking and uh in the banking sector how our database uh is getting used and honestly telling great this banking and finance sector is something uh which is heavily heavily dependent on these kind of transactional databases and why it it actually depends on those kind of transitional database so let's say nowadays you are using the upi system as soon as uh you click you type 1000 and transfer it off via a mobile number or any upi id instantly you get the message from your bank that this much amount has been debited and credited to somewhere else so that is happening like just within a fraction of seconds and you can even like understand in india actually the scale of banking and finance sector it is very very huge and these these like backend databases are running like a charm they are handling millions of transaction requests per second per minute and they have managed everything the complete concurrency or complete consistency of database as well right and that's the beauty of it and that's why even banking sector is actually dependent on it for customer information they know uh who their customer our account activities uh whatever you have been how many times you have debited the amount how many times you have credited the things they keep all the information and that is something which is again stored in the database as well the payments and the deposits loans etc so these kind of information will be stored by the banks and for that they will use the dbms airlines again for reservation scheduling information and many other part uh so like airlines you can say any hospitality services hotels or um any let's say car rental or any any other thing right which is related to the hospitality sector universities they store the data for the student their information course registration colleges and grades telecommunication it uh actually this telecommunication part is something or domain which again uses the databases for different kind of purposes like keeping all the call records and the monthly bills maintaining balances and what was the call activities what you have done how many hour how much data you have consumed so far finance sector again for storing information about stocks sales purchases of financial instruments and like bonds and next is the finance sector where again databases will be used for storing information about the stock sales purchases of these kind of like financial instruments like stocks and bonds next the sales department use of storing customer product and sales information manufacturing it is used uh for the management of supply chain for tracking production of items inventories status uh in warehouse so this is i think a very good example right manufacturing or deliveries right um nowadays whenever we want to send something right what happens we just go there and whatever the delivery service we just send our package and at every step we'll keep on getting these status right uh they will be giving you some tracking id that hey your parcel actually has been dispatched and this is the tracking id you can keep a track of it so every time it actually reaches to any let's say intermediate point or any intermediate warehouse in a different city you will get a notification and that will be reflected in that tracking id that your parcel has reached till this point next dhr management for information about employees salaries payroll deduction generation of paychecks and many other things so these are the some important sector and this is not the specific list this uh list is basically endless so whatever we are talking about in the modern software development and modern uh it industry so there are multiple sectors and every sector is depend on the data and to store the data we need the database management systems so this was something about the practical application of databases now uh we will move on to this important part understanding the database architecture in dbms we understood the dbms which is a kind of software application which helps users third parties to interact with the databases in order to manipulate the data but there can be different different architectures of it within the dbms there will be different architectures and now we will try to understand those sort of architecture what is it and uh like when you can use it and what kind of application or what kind of architecture design should be there where you should use different different types of database architecture in your application so first uh the first architecture is basically known as the one-tier architecture and we will try to understand what is this kind of one-tier architecture of database in dbms and how it works so in one tiered architecture and dbms is the simplest architecture of database in which the client server and database all resides on the same machine a simple one-tier example a simple one-tier architecture example would be anytime you install a database in your machine right if you have a laptop desktop and access it to a practice sql queries but such architectures uh is really used in production and obviously this architecture which we have talked about one tier architecture so let me explain it in the simpler terms uh so let's say you have a laptop you have a desktop and when you work right when you actually install the things for the learning perspective so what will happen in your local laptop you will set up any kind of database beat the mysql postgres right there will be some steps so that that database is actually available in your machine and in your simple uh system and simple machine you can have a web server right uh which will actually listen to your uh like request which will be coming from the client and that client can be anything it can be any web application as well right from there whenever you will be doing some activities that web server will capture those requests and if that request contains any instruction to query the database the data will be queried so this is one example so that's why it is said uh this uh installation in a single machine or in the local machine where client server and database all reside in the uh same a kind of uh host machine right so that is the example of one tier architecture and even i'm again giving a practical example whenever let's say you would have uh like installed any kind of database uh as soon as you are basically manipulate or as soon as you try to make a connection from the command lines right uh there will be a command prompt where you can type the sql queries and you can actually access the database so this is the very simplest form of the database architecture in dbms and kind of one-tier architecture next we will talk about the two-tier architecture so in two-tier architecture dbms is a database architecture where the presentation layer runs on a client and that is can be like any pc mobile tablet and data is stored on a server called the second tier so that's how you can see this architecture diagram where the whole thing is actually divided in two tiers or two sections so one a section is completely dedicated for the clients and seconds is something just just think like it another machine or another server where your database is running okay so how this thing actually operates this two-tier architecture provides added security to the dbms as it is not exposed to the end user directly it also provides direct and faster communication so in this architecture we can like closely see whatever is the like client it can be again any uh desktop laptop mobile tablet etc and that is uh somehow accessing the database or even making a direct connection to the database so that's why there is no middle layer in between okay and that's why it this point is actually mentioned direct and faster communication because uh there are no multiple hops in between from the client to the database client can make the connection to database directly and get the data from there so this is the two-tier architecture of database indeed bms next is the three-tier architecture so in this three-tier architecture is something which is really really common in the production level of services so why i am saying the production level kind of thing so production level means here whenever we are done with the development task right whenever let's say we would have started working on a software application first we would have uh like created its beta version which will be running on a very low scale and we need very less servers for that to handle the traffic but whenever we just make those changes live or whenever we make our product live so that is exposed to the customer that means hell lot of traffic will be coming and we need to handle it and we need to handle these things in a real time in a production so production is something which is exposed to the customer so whenever we we like go live with our systems or any kind of software product so we will actually work on a larger scale of the scalability we will actually deploy our application in the best architecture format as well so three-tier architecture is something is the most popular client server architecture in dbms in which the development and maintenance of functional processes logic data access data storage and user interface is done independently as separate modules all right so separate modules why i'm telling you because here in this application you can see three components first component is the client second component is the server or you can say the web server and third component is the databases so a database uh is something which is a separate complete separate module and its main responsibility is to just keep the data and whatever request is coming based on the query just manipulate retrieve the data and just send it back from from wherever the request is coming and the responsibility of this server would be to handle all the incoming request and pass it to the database right make a connection to the database perform the query like whatever logic was sent from this client perform it and whatever the output data we are getting from the database just again bundle it and just send it back to the client so that's how in the three hops three architecture three layers are actually here so this is uh your you you can say actually the complete database layer part here and this is your application layer part here and this is the presentation layer part here so here this is how the three tier architecture actually works for the dbms section and now we will be looking at the different part that was our three tier database architecture in dbms and this is again something which is used in the production level things and it will have a separate component which provides more decoupling right things are not tightly coupled with each other because that's how your entire application may uh like go down completely and uh whenever we have a different things in a decoupled format that means if something fails uh in between or as an individual entity that can be recovered back but that failure won't impact the entire application or entire thing so that was about the three tier architecture all right so now we will start looking at the important concept in the rdbms like relational database management system and that important concept is the database schemas so schema is the important keyword and we will try to look at it it's different aspect like what is the schema first of all and different types of it and i will try and i will also try to explain it with some like very simple examples so let's look at it so if i want to give you a very simple example of schema so just try to relate it with the programming languages so in programming languages what happens whenever we try to write any specific code so first definitely we will declare some variables those variable can be of any time let's say the integer or some arrays maps or float values strings right so those variables that means they will be the actually name or you can say a variable name assigned to any memory location which will hold that particular value like whatever we will assign to it and now in terms of the databases when we talk about the relational database management system where the actual data is in the tabular form like the rows and the columns okay so how we will be doing it right let's say we have any rdbms right any database management system obviously we know it's a software application so how it actually manages all these things right how we actually create the let's say database and where the memory will be allocated and after that once we create the uh table right so how our database will get to know that what is the table name and main part is the what will be the attributes within the table so this is the actual thing right so whenever we talk about the rdbms related system where the data is in this form right the tabular or quite structured form so the very first and very important step is to define its skeleton skeleton means right how it will look in at the overall picture so defining that kind of skeleton you can actually just relate it with the schema so schema is something which is kind of blueprint of your entire table structure that okay how this table will look like these will be the column names and even those column names are the variable name assigned to those column values right and even those column values has its own type some of the column name might be of you can say the interior type right so very good example is let's say the age right if you are not considering any float point so 20 21 these are the integer values and similarly name it's a string value okay and there could be a salary column which is holding the salaries that could be flowed as well so that's how like every individual attribute has its own type and whenever we try to create the tables in the databases so declaring the schema or basically preparing the blueprint and the structure of any table is known as the schema and uh there are two different aspects of it so we will try to understand it which aspect lies where so let's look at the technical definition first a database schema defined its entities right entity means the table and the relationship among them if there are multiple tables there will be some attributes which are connected with each other because we have also understood the concept of keys and all so that will be the thing like which actually relates more than two tables with each other it contains a descriptive detail of the database which can be depicted by means of the schema diagram so schema diagram is nothing just you can say again the pictorial notation like what is the attribute name and in the later part of the this session we will be reading about the important topic as well the er diagram entity relationship diagram there this thing will be quite clear to you so it's a database designer who designed this schema to help programmer understand the database and make it useful so guys if you don't know even uh in this software industry there is one like common profile job profile itself the database developer right or even the database admin so what's their uh their job responsibilities actually to deal with these things even the complete admin related part of the databases and also looking at the optimization part of it and any business team or any development team comes to them right because we will be creating those application and adding those application will be using some database for the data transfer and all so that data will be in this structure form and these guys will take help from the database developers and the database admins will sit together and they will share their requirement that that that's how we want to design our database right and since the database developer is actually have the expertise in this section so he can definitely design a well structured and well optimized database uh at the behind so that's the thing now look at the schema part so here in any of the database management system there are two parts of the schema first we call it the physical database schema second is the logical database schema okay so what is the difference between these two so first let's look at the logical one and then we will look at the physical one so this schema defines all the logical constraints that need to be applied on the data which is stored it defines tables views and integrity constraint so uh integrity constraints like when we were talking about the keys concept and all so i talked about this part as well right um that in the databases we will be storing the data and how it actually just maintain everything right how database doesn't allow let's say you you created one column which is of the integer type or something and let's say you're trying to store the string value in it so obviously this is the data inconsistency and it won't allow you to do that because its definition is integer okay so so the rule which we have applied that it has to be the integer and apart from that we can apply multiple multiple constraints on it as well for every column we can define multiple constraint like what should be the default value whether it is a primary key if it's a primary key then multiple checks will be applied that it is not duplicated and these things will be done by the database management system itself but here this is the actual picture like what you write on the paper and what you define and what you actually prepare while creating this table that is the logical logical picture you are looking at it like okay this should be there should be a name column there should be a salary column there should be a column and defining its data type right and putting some integrity constraint on it and then like assigning some name to your table something so this is the logical schema so here i will explain with this diagram as well that what is the physical part on what is the physical schema where it lies and what's the logical schema thing so physical schema this schema pertains to the actual storage of the data and its form of storage file like indices etc it defines how the data will be stored in a secondary storage so that is the actual part for the physical schema so again let's take a step back where we were talking about the programming languages what we did there we created a variable name and that variable name was like it was just a reference to any memory location but let's say we are typing on any uh coding editor right let's say individual code studio or something so there we type in a something so for us that is the logical thing which we are provided to that editor and under the hood or within the like computer machine and within your memories it will be allocated in a different way right how many bytes will be created for any variable if it is an integer what kind of byte supports that kind of machine so for integer it could be let's say four and if you have defined the long long integer it could be uh more than 16 bit something so that's how we can like just understand the definition of the logical and physical schema so logical what you define right and physical means how this data will be stored in the physical memory because at the end whatever you are storing in the data that what at the end whatever you are still and at the end whatever you are storing in the table that is the data and there are some numbers some values and they will occupy some space in the secondary storage as well your memory hard disk wherever so this is the thing the difference between the physical schema and the logical schema so everything will be taken care by the dbms itself like wherever uh you are like whatever kind of database you are using so that will be handled like what's the logical schema part and deciding based on the system configuration that what should be its physical schema and where all things will be stored because your dbms will be the actual mediator who will interact with the uh machine or the memory locations and pull the data for you so that knows everything so that was the concept of these schemas the logical and the physical now uh let's look at the important part uh like where we were talking about these schema diagrams er model let me tell you one thing that this topic is quite important because in the previous part i mentioned about the database developer profile and just don't think from the database developer profile but also thing from the system designing perspective as well right let's say being a developer you are working on a system you are trying to design an application the first step is that you that like you don't jump onto the coding part first right first you work and you brainstorm on the design that okay this sort of database will be using this kind of components will be using right high level design low level design everything you will be working on it and similarly to help anyone or to like help any development team or any developer to come up with a solid design for a database this is a kind of you can say model or this is basically a set of rules methodologies or concept or instructions which are mentioned in the er model somebody can use to notate or pictorially visualize its database how it will look how it will be related or how other tables will be related with each other how to define the attribute right so that is the main concept of having the er model if you want to understand it in easy terms so again let's go back to the programming side so there we have a concept of flowchart flow charting what happens uh before writing the actual code we try to uh just write or we try to draw a flowchart like from where our program will start and then decision box then arrows if yes any condition then where the flow will go where the computation will happen so everything has its own dedicated instruction right the decision box will look like a diamond and what is the meaning of arrow what is the uh meaning of the parallelogram kind of box so everything has its own meaning because that is the common structure somebody can follow like across the software engineering right if i'm someone i have written a code and i wrote it in a different language let's say java okay and there is another developer who knows python okay so for both of us the things are quite different right in terms of the programming syntax but let's say whatever logic i wrote if i just draw a flowchart for it and hand it over to that guy who knows the python so he will able to understand the flowchart because that is the common thing within the software engineering flow chart has its own fixed rules fixed set of you can say instruction so that somebody will design it so common thing right and basically a medium to share the information right across the community and somebody can convert that logic or that flowchart in its own programming language so that is the same concept here with the er model uh itself just to uh pictorially visualize that how your entire database looks like in the logical form like defining those entity name table name their relationship with their attributes and keys and that's the main concept so we will be discussing about that and trust me it's again important concept and it also becomes important from the interview perspective as well because interviewer might ask you a very straightforward problem statement that can you design an er model for the food delivery app so you need to come up with the uh entities that what kind of tables would be there what kind of attributes they can have and what would be the relationship with each with each other so you should definitely know how to design an er diagram and its concept as well like everything what is the meaning of every image box or anything like that so let's try to understand it with the uh technical aspect and let's try to understand the technical definition of er model and also what are different components of it so yeah model it stands for entity relationship model it is a high level data model like in the system designing we have a hld like high level design uh where you just draw some boxes and the arrows to just make sure what is the flow and how other components interact with each other this model is used to define the data elements and relationship for specified system like how those tables and the attributes will be connected with each other it develops a conceptual design the logical design you can say or the pictorial notation for the database it also develops a very simple and easy to design view of data right because if the database things are clearly visualized in the pictorial format it's very easy to understand how things look like and how like those tables are created in er modeling the database structure is portrayed as a diagram called an entity relationship diagram now let's look at the three important components of the er model and after that we will talk about each and everything one by one so first component of er model diagram is the entity right entity and within the entity uh you can say it has a one sub type as well like weak entity as well so two things entity and weak entity second is the attributes right attributes basically can be of different different types as well so attributes just think the column names so key attributes means what would be the column or the column name which will act like a primary key so that will be known as the key attribute and in order to represent within the diagram in order to represent the key attribute it has its own definition it has its own uh rule like how somebody can define yes this is the key attribute so we'll be looking at that one composite attribute multivalued attribute derived attribute third thing is the relation because the entities which are actually the tables they can be connected with each other based on the key relationship the foreign keys kind of concept so what kind of relationship they can have obviously we know this is the very common in the uh you can say the classes object and you can even say the database word the kind of relationship the one-to-one one-to-many relationship many-to-one and many too many so we will be looking everything with the example and i will make sure that everything is clear to you for every important part first uh like how we declare and how we visualize the entity uh within the er diagram so entity what it is an entity may be an object class person or place so this is simply uh like in the beginning we talked about the music database right there was different different tables the artist the let's say album the music the rating okay so everything artist is something you can say based on the definition object class person or place for which we will be talking about and for which we will be storing the data right so that is the entity and in the er diagram an entity can be represented as the rectangle so when we will be designing the er diagram how we will get to know that okay this is the entity right this is the actual table name so we will get to know based on the representation and in the er diagram we represent any entity with the help of this simple rectangle so anytime you see any rectangle box and anything written into it that means that is the entity so here for the example let's say you are working for a company that company will have the employee data okay and how we can segregate that entire employee uh related database in different different tables so every single table will be like a one entity so if there can be one employee table there can be one department table uh there can be one let's say address related table and many other things okay so that's how you can see rectangle box and within that this employee keyword is written so that means this is one entity and this is another entity which is named as the department now let's look at the weak entity what is the purpose of weak entity how it is notated in the er diagram and what does it actually mean so an entity that depends on another entity right so these are something which are the origin or the original you can say they are not dependent on it anything they have their individual existence but here an entity that depends on another entity called a weak entity the weak entity doesn't contain any key attribute of its own i mean it won't have any kind of primary key sort of column the weak entity is represented by a double rectangle so i will explain it with this example where we can see this is mentioned in this simple rectangle that means it is the original entity and there is one arrow that means it is it has some relationship we will talk about those things later but here this installment entity is mentioned in the double rectangle that means it is the weak entity now why it is a weak entity because installment completely depends on the loan how let's say somebody didn't took any sort of loan then there is no concept of installment for you all right so similarly if let's say this loan table is completely empty and this loan table doesn't even exist in any of the er model then there is no purpose to mention the installment as well because somebody didn't even take the loan part so there is no concept of installment and that's why it is known as the weak entity it is completely depend on the loan loan is there installment will be there now let's talk about the next thing that is the attribute like how we actually uh represent the attribute how it actually look like right so attribute the attribute is used to describe the property or again in simpler words the column names of any table are actually known as the attributes and here this diagram is little bit not correct because the attribute which are mentioned here actually mentioned with the help of the eclipse right so whenever we want to define any kind of the attribute name that will be enclosed within the eclipse kind of shape right not this the complete circle and that's what is mentioned here like eclipse is used to represent an attribute for example let's say we have a student table or student entity the common column name can be like student id which is simply mentioned here as the id and it can have another column name name as the phone number and it can have another column name name as age and obviously the name which is the student name so this these things will be mentioned in the eclipse these things will be mentioned within the eclipse kind of shape not the uh this one the exact circular thing okay so let's look at the important uh part of the uh like you can say important part of the attribute category as well so attribute category first we mentioned the key attribute what is the key attribute so the key attribute is used to represent the main characteristics or simply in very simple words the primary key of that table right that is why it is the main characteristics with the help of primary key we will be able to identify the unique record and it represents a primary key the key attribute is represented by eclipse within the text underline right so i will show you that ignore this diagram i will show you in the next one that what is the uh the key attribute so let's say this id is the uh like student id because it is unique every student will have its own unique id so there will be one underline in it like id within the name of uh this under the name of this uh primary key column name there will be one underline and that is the notation of the actual primary key and i will show you up one good example as well the complete er diagram there like everything will be clear for you how every attribute is mentioned everything so that was the thing about the key attribute now we will look at the composite attribute and here you can clearly see right the eclipse shape so eclipse shape means that is mentioned as the attribute or the column name of that respective entity so what is composite attribute an attribute or a column name that composed of many other attribute is known as a composite attribute so what can be the example simple example is the name column because that name column can itself have like kind of three sub categories first name middle name and the last name so these are the uh attributes right these are the attributes which are helping this name attribute to get completed okay if you don't have first name last name right then definitely you won't be able to derive the complete name so here it has nothing to do with the derived derive column or derivation but here the example is quite clear because this name attribute can be divided in the three parts itself the first name middle name and last name and when we combine these things these three together uh it will give the full name value right so these are the composite attributes now what are the multi-valued attributes so an attribute that can have more than one value will be known as the multi-valued attribute in the er model and how we actually represent it so that is represented with the help of double eclipse so any attribute which is having more than one values which can have more than one value will be notated as the double eclipse so here this is the good example the phone number right can have multiple phone numbers multiple sim i can have also multiple numbers multiple sim so if somebody registers my data or somebody collects my data as a student and there is one phone uh number column i can mention more than one phone number there so that attribute is capable of containing more than one value so that's why it is known as the multivalued attribute now let's look at the other part what is the derived attribute so derived attribute and attribute that can be derived or a column like which can be derived from another column is known as the derived attribute so here in this example student we have one entity it has for the start it has three columns the roll number the name and the birth date and here roll number this complete if you draw the complete underscore line under this roll number uh string so that will obviously become the primary key and obviously roll number is a primary key for the student in the student table so that can be drawn here but here we can see this age column it is a kind of dashed eclipse eclipse which is drawn as the dashed not complete eclipse so dashed eclipse and the column name is h and why it is the derived attribute because you can calculate someone h if you know its date of birth right so if i tell you my date of birth so with the help of current date you will be able to calculate my age so that's why this age column is somehow completely depend on the birth date and like not dependency if we want we can derive if we don't need it we cannot derive it right so that's the simple thing but it is something the age is something which we shouldn't like capture from the uh any student itself that we tell any student that please tell your date of birth as well and also tell your uh complete age as well so if somebody tells me the date of birth i can easily calculate the age column itself right so that's why it is the derived and it is mentioned at the dashed eclipse now let's look at the other thing the third part which was related to the relationship and we will try to look at that how relationships are defined and what is the representation for it so representations were like one two one one too many minute one and many too many so in the er diagram if two tables are connected with each other connected with each other or shares some sort of the relationship with each other then that will be represented in the shape of the diamond right and that relationship will be written here in the diamond box like what is the relation and here you can see some numbers as well so these numbers are actually representing uh the direction of the relationship and even the category of the relationship as well so we will try to understand one by one so first relationship here right the diamond symbol is used to represent the relationship so in this er diagram sort of very small example here we can see one entity or table name which is teacher and there is another table name which is student so teacher and student are connected with this relationship like the teachers teacher teaches students okay so that's why among them the relationship is the teachers and that's what is mentioned in this diamond box now let's look at the different categories of the relationship so first is the one-to-one relationship one-to-one relationship what happens when only one instance right one instance means one record one record of an entity is associated with the relationship then it is known as one to one relationship all right so let's take an ideal case male female okay so female and male we have like two categories two entities female is the individual category male is the individual category right and taking the concept of marriage so female will be married to a male right and we are just thinking for the ideal scenario so one to one like one female will be married to one male person right so that's why one to one relationship is mentioned for any record which is present in the mail there will be one dedicated record for that female in the male uh attribute so there will be one dedicated record for that female in the so there will be one direct connection of that female record within this mail table as well so that's why it is mentioned as the one-to-one mapping now one two uh many relationship let's try to understand when only one instance or one record of that particular entity on the left side right and more than one instance of any entity on the right side of the entity associates with the relationship then this known as the one to many relationship so again it's very easy to understand from this uh diagram that if we want to design a er model where the scientist data right is there so just suppose two entities so one entity is the scientist this will this table will contain the all the data related to scientists they're probably name uh or like their uh designation or something like that right and there will be another table which will actually contain information about the inventions right every invention is unique and it will have some unique attribute to define it so let's try to understand so one single scientist can invent multiple things so this relationship is quite clear right so even this relationship what it mention invents invents is a relationship like scientist invents something right so and those some things will be known as the inventions and here we can see this clear relationship as well one like record within the scientist table is actually mapped or can be marked with the multiple values on the invention table so this is the concept of one-to-many relationship in er diagram now let's look at the third thing many to one relationship let's try to understand when more than one instance or more than one record of the entity like which is represented in the left side so if this is the relationship this is the left entity this is the right entity on the left and the only one instance of an entity on the right side then this relationship will be known as the many to one right so again let me explain with the example so here we have a student table we have a course table and the relationship will be the enrollment because students will be enrolling in the different different courses all right so now how this is many to one relationship because let's say there are 1000 uh students and let's say there will be like three four hundred uh who want to do the b tech there will be 3 400 who want to do the vba and there are two 300 who want to do the bca so bba is one course and bca is one course b tech is one course and multiple students are getting enrolled in one specific course right so this is many to one relationship right so that's how this simple it is many to one relationship now let's understand the many to many relationship so here in this mate one if it is the m that means on mention on the left side so this is going to have the many record which will be mapped to one record of the course table and let's talk about the many-to-many relationship where more than one instance of entity which is on the left are associated with the multiple records on the right side of the entity that means it is going to have a many-to-many sort of relationship and again let's uh explain it with the example so we have a table named as the employee we have another table named as the project so in that case how it is going to happen the relationship will be assigned right every employee will be assigned some sort of the projects okay so again just think from the company perspective company perspective uh means you are working in a company so right there will be different different projects there will be different different projects and there are different different employees so let's say me being an engineer i can work right on project x as well and i can work on project y as well like at the same time i can be starved into more than two projects itself right so one employee is assigned to multiple projects so this is one thing now similarly within a one project there will be multiple employees working in so one project can be assigned to multiple employees as well so that's how it becomes the many to many kind of relationship all right so now we will look at the er diagram sample case study and in this case study i will actually try to explain whatever we talked previously right the entities the attributes the relationships so with this help of the diagram i will explain each and everything if still there are any kind of information gap if you feel so this is a very very decent case study and so this is actually uh you can say a database for a simple school or college you can say right so when you think from the academic background even in colleges right uh each college or a school will have its own website where they will be maintaining every kind of data that data can be related to these students courses their teachers and the entire admin related things right so lots of things needs to be managed on their end so this is the sample case history for that one right so let's look at uh each and every entity attribute relationship one by one and try to understand how things are placed in this er diagram so we know uh like we will primarily focus here on the four key entities right and we'll try to understand how they are connected with each other so first look at the important one the student right for the college like the most important thing would be the obviously the students part so student is the one entity and let's look at the attributes it can have so previously we we studied these things right how to represent the attributes those will be in the eclipse format how to represent the uh multi-valued uh attributes how to actually represent the derived attributes how to represent the key attributes right so for the key attribute part if you are still confused that what is this so in the later half of the video we will be talking about these things in depth right the concept of keys in the relational database management system so don't worry about that on a higher level you can think uh or you can treat any key attribute like simple simple attribute or id right which is unique and uniquely identifies our record within our table right so let's say uh for our example our aadhaar id so other id is actually unique for every uh citizen of india so like my unique other id will be there and if you have the other card like you will be also having a different id for that so aadhar id is something which is unique so similarly there should be some attribute which can uniquely identify a record or a student so that's the key attribute which we call so student it can have attributes like the student id first important one and the uh student name here so a student name here uh we can see right and the address attribute is also there and this entity has other attributes like hobby date of birth so now address is something which is sort of multi-valued right multivalued means what we can say uh it can actually have uh like sub attributes as well within the address we can have the door street city state pin now underline this attribute is mentioned with the underline that means this is the key attribute now let's look at this one this is the dashed eclipse that means this age part is something which is the derived attribute and i hope you guys remember why it is the derived attribute because uh that can be uh calculated with the help of the date of birth now hobby is something uh this is you can say uh the kind of attribute which can have like different different values like uh one within the one single uh attribute we can assign multiple like any individual personality can have more than one hobbies right it's a swimming music singing and multiple things so that's how it is mentioned with the double eclipse right so this part is clear and this student entity has one more attribute which is the course id okay why course id is actually mentioned here i will explain it because for that first we need to look at this relationship right so there is another entity named as the course course as i already explained previously in in an college there could be courses let's say b tech uh mca bca bba mba m tech so these are the courses and each course will have a course id for m tech there will be a specific id for bc there will be a specific id so there is another entity course so it has simple two attributes course id something which is the key attribute that's why this underline is mentioned here and another attribute is the course name okay so what's the relation between these two when when we were talking about the different relations one to one one to many many to one many to many there we also take took this kind of example right how student and courses or subjects can be related with each other so obviously the relationship between the student and course entity will be many to many right and that relationship we can mention like in roles attends like multiple synonyms can be there for one single relationship but this m n right this are the notations like simply many too many uh even this end notation is same to m itself right many to menu this denotes right if anything apart from the value one that means this is the many-to-many kind of relationship because there can be hundred students who can uh attend the bca course right and similarly one uh you can say course uh here like in terms of the course part one course can be attended by the multiple students okay so that's why uh we have the kind of uh this many to many kind of relationship here and now i was talking about this course id part as well why this course id is mentioned here actually so whenever let's say somebody ask you to figure out that let's say shashank is enrolled in what type of course so if i don't have any relationship or i don't have any mechanism to just connect student entity with the course entity i won't be able to get that information that shashank is enrolled in which kind of course so that's why this is actually the concept of the keys right the differential keys which we'll be uh studying in the later part of the session so here just for a like simplicity you can treat it like a reference attribute for the course entity which is the part of this one okay so if you know the course id you can simply just join these two entities together and you will get that course name for sure and whatever terminology i am i'm talking about here the joining and everything this is the actual part of the entire relational database management system which we'll see in the later part of the session now let's look at the uh entity lecturer lecturer means you can say your teachers right so lecturer they have uh basically this is also one of the entity and it has attributes like the lecturer id simply you can say a teacher id or something which is the key attribute lecturer name and also the course id okay so now let's look at the relationship first between the student and the lecturer so here the lecturer here the relationship between the student and lecturer is basically one too many right one too many why because one student can actually take lectures from multiple teachers like uh if in my course uh i have subjects for science i have subjects for mathematics i have subjects for the computer science so i will be uh like guided by the three different teachers that's why one student is actually mapped with multiple lecturers so that's why this one two m kind of relationship like one-to-many relationship is mentioned here and uh lecturer the relationship would be like lecturer teaches students so that is the relation which we have mentioned in the diamond box now let's look at the uh relationship between the lecture and course that will be also one kind of uh the relationship between the course or something okay so let's understand why there is a many too many kind of relationship okay so lecturer takes course so see there could be multiple subjects which are somehow common between the courses itself right let's say the iit management a kind of subject which can be probably part of the vtec as well and can be part of the bba mba as well all right so that's why one lecturer simply you can uh say here if that teacher is especially for the i.t management subject so that can actually uh teach that subject within the bba mba course as well if it is a part of that course and also can teach in the bt course as well if that id management subjects is part of the btec course so that's why this many to many kind of relationship is mentioned here and similarly here the relationship is the lecturer takes right which kind of course that lecturer will take and here also the course id is a reference mentioned here this is the attribute visits the prime attribute of the course entity but the reference is mentioned here so that whenever somebody asked that this lecturer is basically teaching in what kind of courses so you can simply join the lecturer and course entity and you will get that information now let's look at the last entity which is basically the subjects so this were the course part and the subject so let's uh look at the simple relationship between these things so lecturer and the subject relationship so this relationship is lecturer teaches like uh basically what kind of subject or one particular teacher can teach right so that's why this relationship is named as the teachers and the relationship would be one to one because if i am a science teacher then i will be only teaching science right and science is one particular one dedicated subject so one to one mapping is there and in the subject entity we can see we have the three attributes primarily the lecturer id and subject id something which is the key attribute for this entity and the subject name so lecturer id why it is mentioned there so whenever we want to uh just get that information that sign subjects is actually taught by which teacher so lecturer id as a reference attribute should be here so that these two tables can be joined together and the population the values can be populated here and now we will look at the relationship between the course and the subjects so course and the simple you can say the relationship can be like something one too many right because in one course there can be multiple subjects in b tech right there will be multiple subjects let's say data structures algorithm programming and the cyber security graph theory and many other subjects right so that's why within one course one course multiple subjects and that's what the relationship has mentioned here one course can has have many subjects so this is the overall uh example and the simple case study for the er diagram and very basic that's why i picked the very basic simple case study so that things are actually clear to you and after that you can probably pick some complex problem statements by your own and try to design an er diagram for that so the problem statement can be like designing the rei diagram for any e-commerce website let's say amazon flipkart and designing the er diagram for the library management system for the hospital or for any kind of let's say food delivery yeah so you can try to practice it that would be a really good exercise for you now uh we will be moving on to the uh next part which is actually the study of the rdbms like understand the relational database management systems in depth uh it's all technical concepts whatever we talked so far in the dbms just as a keywords and now this is the time to explore those keywords whatever we talked so far and understand everything about the relational database management systems so first uh thing would be what is rdbms and i think whatever we have discussed so far you have at least decent picture to visualize what is the database management system what it does and most of the time we talked about the tabular or the structured form of the data right in the form of table rows and column and that is what exactly relationship that is exactly what the uh like relational database management system relational means something wherever you have created some sort of the data sets or kind of a structure data you have and somehow you are able to build some relationship between the tables that will be your relational database management system okay so let's understand the technical definitions first so a relational database is a type of database that stores and provide access to data points that are related to one other that's what we talked about relational databases are based on the relational model uh previously whatever we saw in the er diagrams how that relationship was built in a relational database each row in the table is a record right so whenever going forward we will be using these terminologies so one row will be like simple one record we are trying to insert one record deleting record updating record right now here with a unique id called the key so previously in the er diagram i was focusing on the key attribute so in most of the tables definitely at least in the transactional tables for sure we will be having some key attributes right any kind of column or the set of columns which can uniquely identify any record right so that is the main concept of having the key columns and here uh any relation uh relation is equivalent to the table so for the ease of the understanding the columns of the table hold attributes of the data so apart from the rows there will be one more thing which is the column and column is nothing like simply a variable name given uh or assigned in the or you can say the created within the table which will hold the values right for a particular thing if it is a salary column it will hold the values of salaries for different employees and different workers similarly age column name columns so these are the columns which are holding some sort of the data so in the market what kind of popular uh databases or basically the rdbms are available so the most popular are the mysql oracle and even many other organization have created their own transactional databases but the most popular and most common most widely used is the mysql postgres oracle these these kind of the transactional databases so this is a very simple example which actually describes everything uh we talked about the rdbms so this entire thing is nothing simple you can say a relation or an entity or a table and that table is actually named as the students and this student table have these many records so which you can see right this arrow or this simple line uh there are different synonyms for it we know it as a tuple we call it uh as a row as well we also call it record and here uh these are the attributes right uh attributes means the column name and this column will actually hold some values so these are the rows this is our table and the table name is the students and these are our the columns and these are our rows so this is the very simple uh typical structure of the rdbms now let's look at the some key points for the rdbms like advantages of rdbms why they are popular and what kind of thing they are trying to solve so first thing is easy to manage and why easy to manage because even earlier when we were talking about the databases and trying to understand the dbms so these are also the software application which will help any user or third-party software application to interact with the data which will be stored on the physical devices right so easy to manage why because we can see uh the rdbms are quite simple right in a very well structured and human readable form you can simply retrieve the data in in very very easy manner like no that much level of complexity in terms of accessing the data data sets table or anything that's why first thing which is popular for the rdbms is easy to manage first second is security and uh you will get to know more about the security aspects when we will uh move or when we will study more about the sequel and these things so uh security why it is even actually very very important when we talk about the databases which are very very critical let's say the uh banking data right which is very very critical because it holds your account information the entire amount debit credit related things so it's a very critical data so same thing happens right within the organizations as well if there is any kind of data which is very very important and very very crucial so you cannot allow everybody to have the access on it right you need to have some sort of mechanism so that you can restrict uh let's say there are three members in a team only shashank can access the this kind of table uh rest of the people won't be able to access it so you need to apply those kind of access mechanism and apply those security layers and that is actually doable and that can be done with the help of the uh relational database management systems next the flexible databases can easily be extended to incorporate more records thus providing greater scalability also facilities uh easy application of sql queries so flexible in terms of the scalability right whenever uh you have a use case where you want to uh store some huge amount of data itself right your traffic is getting increased your data volume is getting increased you can vertically scale your transactional databases and even uh some complex uh concept of starting you can even manage your transitional databases in the horizontal scale format as well and flexibility of accessing the data with the uh like with the help of the sql queries which is uh in the english format just writing or giving a one instruction or one command to your rdbms system and the data will be uh like the data will be displayed on your screen uh in the form of the output so that's how the rdbms are that much flexible in terms of the access users rdbms supports client-side architectures storing multiple users together and that's that that is definitely true whenever we talk about the large scale applications right just think from the large scale applications like e-commerce platform amazon they will be having some database in the background and every second every minute there are like millions of users who have actually logged on to their amazon e-commerce platform and making some activities doing some transactions so and and like under the hood obviously that database is something which is handling the real world traffic so this is something like the rdbms or these transactional databases somehow capable enough to allow that level of concurrency and multiple connections so that the data can be retrieved and manipulated easy data handling like uh that's what uh like we were probably discussing when um i talked about the sequel part but also uh right when or you can say as soon as the data volume grows uh there will be some complexities as well uh in terms of the run time or the execution how time for the queries or the data retrieval but also rdbms provides some like core concepts or the optimization concepts as well so that we can store our data in such fashion though so that it is very very fast to access so like data fetching is faster because of the relationship architecture right we can simply point out to any particular table attribute name and we will quickly get the data and uh data redundancy or duplicacy is avoided with the concept of keys indexes and data normalization principles so these are the some core concepts which rdbms provides so that we can handle and we can uh like avoid such kind of anomalies data consistency is ensured because rdbms is based on acid properties so this is also one of the core concept of rdbms we will look at in the later part of the session and acid properties for data transaction and acid actually stands for atomicity consistency isolation and durability so we'll look at it fault tolerance replication of databases provide simultaneous access like the concurrent access and multiple access and helps the system recover in case of disaster such as power failure or certain shutdowns so what does this fault tolerance actually means so the way these transitional databases work they have the locking they have the logging mechanism right logging mechanism in in case of the failure or any kind of uh like abnormal failure they can definitely recover with the help of the kind of metadata and kind of the bin locks they have right so this is actually the fault tolerance part in the rdbms now let's uh look at the uh important concept i was talking about the concept of keys and that is something kind of the backbone of entire rdbms or the relational database management system because tables are known as the relations but whenever uh we want to uh like whenever we want to build a solid database which are somehow connected with each other so these key attributes are something which will play a very very important role and that's why we need to understand like what kind of key is are available and what is the meaning of each and every key so why we need a key first of all let's try to understand that and the typical reason can be like unique identification like in simple words this is the actual meaning of the key attributes right uh and why it is important again like when you have a huge set of data and huge volume of data and you are particularly trying to target one specific uh you can say record or one specific uh tuple anything you should definitely uh like know how you can get that data or how you can get that record uniquely okay so key actually is help you to identify any row of data in a table in a real world application a table could contain thousands of records that's what i was talking about moreover the records could be duplicated duplicated means the duplication may happen multiple entries for the same record keys in rdbms ensure that you can uniquely identify a table record despite these challenges so this is the actual thing even though if you have the duplicate records right they can let's say a table has uh 10 15 columns and uh somehow seven eight column values are actually matching with each other so somehow that record is partially duplicated and even sometimes it could be multiple duplicate entries like every record is just matching with each other but if we actually want to avoid those kind of things in the rdbms we have the integrity constraints we have the concept of keys which will be applied as a constraint when we will create those tables and the relation and we are trying to like whenever we are trying to insert any duplicate event uh that will be flagged and that won't be entertained by the rdbms because we have applied that kind of integrity constraints based on the key attributes next they allows you to establish a relationship that's what in the er diagram we saw right why the course id was uh available as an attribute in student entity because so that we can relate and we can connect those two entities whenever we want and whenever we actually want to uh just relate or pull some information with these two entities we need to know how we can just connect these two entities with each other and that's what the differential integrity or reference kind of attributes will help and also like the thing which i am talking about help you to enforce identity and integrity in the uh relationship so integrity is something uh related to the integrity constraints so that uh your data is consistent throughout the processing now let's look at the type of keys what kind of keys we can have in the rdbms so there are typically four types of keys in rdbms first is the primary key second is the candidate key third is the super key and fourth is the foreign key now let's try to understand each and every uh segment of it so what's the primary key so primary key in rdbms is a column or a group of columns in a table that uniquely identify every row in that table right so primary key that's why it's even name is the primary or primary point of contact or you can say a primary attribute which is responsible to provide us the uh like unique record from the given table right the primary the properties this is the actually very very important property and we should know uh what is that so the primary key can't be duplicate meaning the same value can't appear more than once in the table and i gave you the simple example of the aadhaar right so let's say our government of india is actually maintaining that complete database every citizen's details with the help of aadhar id so like aadhaar id is the primary key for every uh citizen right and that is the primary key of that citizen table and obviously like two other ids cannot be same together and if it happens that means a database is inconsistent and that cannot happen that that is violating the uh the concept of having the primary key or concept of having the other id because that is something which is uh simply like meant to be unique right every every citizen is unique their information is unique so that's why it is important so that's what mention here duplic like the primary keys cannot be duplicate and also a table cannot have more than one primary key there could be multiple alternatives for the primary key we will also look at uh what we call it but there will be only one and only one primary key in the table so let's look at the example here we have the employee table right so whenever a new comer joins a company right or any person joins a company so that guy will be assigned one unique id that will be the employee id right so two employees cannot have the same employee id because in that case uh there will be mix up in the information of these two employees so here that's what even mention if in the employee table we have different attributes like employee id employee name address passport number license number ssn then employee id is something which is the primary key but after looking at these num these attributes passport number license number ssn number you will be confused that these are also somehow the primary keys because they look uh unique obviously passport number will be identical license number same ssn but that's what i mean that there can be alternatives based on the use case you can decide what kind of attribute you want to use as a primary key but only one attribute will be treated as the primary key not more than one i mean even if it is a set of the attributes so that set of attributes is itself a one primary key like there could be multiple combinations with other attributes but that won't be called as a primary key now let's look at the other type that was the candidate key let's understand it so a candidate key is an attribute or set of attributes which can uniquely identify a tuple i mean if these are the key attributes so their main role their main responsibility is to uniquely identify a record from the table the remaining attributes except for primary key are considered as a candidate key right so that's what i was talking about the candidate keys are as strong as the primary key because they also help us to get the unique record from the table here in this table that's previously i was mentioning right uh employee id was the primary key but apart from that we know passport number can be used as a primary key license number can also be used as a primary key ssn number can also be used as a primary key so since we already made employee id as a primary key then rest of the attributes which can uniquely identify a record from the table will be known as the candidate key right so passport number license number ssn number will be known as the candidate key and again based on the use case if you have some use case where you need to use ssn somehow right so you can make it a primary key because these are some alternatives for you and present as the candidate key now let's look at the other type so the other important type is the super key so super key is a set of an attribute which can uniquely identify a tuple again super key is a super set of candidate key right super set of candidate key because in any of the table there could be even one column which can uniquely identify a record and set of attributes which can uniquely identify a record so uh the super key is actually a super set of all these kind of combination of attributes which can uniquely identify the unique record from the uh given a table so for example the previous table we were looking at the employee table so in the employee table uh employee id comma employee name right the name of two employees can be the same obviously but their employee id can't be the same hence this combination can also be one of the keys right employee id comma employee name and the super key would be employee id right this one employee id something which is uniquely identifying the unique record so on a very very higher level think it in that perspective what all uh you can say what all attributes which are uniquely identifying a record and even different permutation combinations of different attributes who are actually uniquely identifying a record will be known as the super keys so that's what i have mentioned here as well now let's look at the uh last one which is the foreign key this is the important thing the most important thing to build the relationship between the two entities and the two relations foreign keys are the column of the table which is used to point to the primary queue of another table probably this this definition might look bit complex but think in that perspective so we know the primary keys there can be one table and it has its own primary key and there is another table it has its own primary key and if somehow we are making the uh or somehow we are placing the primary key of this table right as a part of the attribute of this table so that means we have provided the reference if you remember in the previous er diagram we were talking about that one right where the course id was referenced as a attribute in the student table so course id was somehow the primary key of course entity but it is or it will be known as the foreign key because we have the reference so the foreign concept is is applied in that way let's say uh we live in the india and any person right from different country visit to our country right let's say from the usa and the russian from from anywhere right across the globe so we call them as a foreigner because uh like if any person visiting from the usa so for that person usa is their country right and they are the prime citizen of that country but if they are coming to our country we will call them as a foreigners right so similarly bringing something or pulling something as a reference in in in one of the table and which is the primary key of another table is actually known as the foreign key and the foreign key concept is the something which creates that relation or the reference among the entities so here we can see two simple tables the employee and the department an employee table we have different different kind of the attributes and obviously every employee will be is part of some specific department somebody will any employee will be a part of software development department and some employee will be part of the finance department some will be looking or some will be the part of hr department right so every employee will be assigned to some departments and if we want to reference that one so here we can see we will be having another department table and department id is the primary key of this table and we have referenced it or you we have basically pulled this uh primary attribute of department table as simple attribute of the employee table and this will be known as the foreign key right so this is as simple as that i hope the primary key super key candidate foreign key concept is quite clear to you and this is something we will keep on using in in the later part of the session where we will be looking at the sequels or the transaction concurrencies indexing and many other typical concepts of the rdbms all right so guys now we will talk about the transactions in the relational database management system and we will deep dive into it we will try to understand it because i am pretty sure you might have heard these terminologies again and again like let's say this kind of transaction happened in the database then what we'll be doing and we need to perform this transaction insert update delete so people used to refer something with the transactions okay and in the database management system what is the technicality of transaction what is the idea behind it so now we are going to talk about that and one thing as a disclaimer this is the very important aspect of the rdbms and even you can say the entire backbone whole thing is actually dependent on the transaction whatever came that is just uh something which which is basically mean to work on the transactions right so let's look into it one by one so first we will try to understand uh the technical definition of transaction and after that we will also try to understand about the transaction with some practical examples and if there are some core complexities we will be having examples for that as well so transaction is a single logical unit of work which accesses and possibly modifies the contents of a database okay and i think this will be more clear if i just read this example so this is very generic right uh like in in our real world scenarios uh the best way to understand your transaction is a bank transaction let's say i want to transfer some money to my parents account right or my friend's account so that is one trans section let's say i'm i'm ordering something right from any e-commerce platform then i will i'm making some transaction from my wallet or from my bank so that is some transaction where what is happening from one side something is getting debited and other side something is getting credited okay and both of the parties right even in in the beginning when we were talking about the use cases of big data or in the beginning when we were talking about the use cases of databases so there i explained like banking and finance sector is something where they are using the databases very extensively and similar whatever you are seeing nowadays on the internet any application android web app everything is storing data and they are using the databases so i made some transaction so bank will deduct some amount and will update the new amount in the bank's database right and similarly wherever i have sent that amount that respective bank will just add that money in respective account and the amount will get credited and that's how this entire flow of this transaction is happening so this is the very practical uh example you can say but in terms of the technical definition what the transaction is it is a very smallest unit right smallest unit of execution when we talk in terms of the databases so a smaller uh segment which got executed that is known as the transaction so here there are some simple simple uh like steps which are written here like when a simple bank transfer or money transfer happens as a transaction what all steps will be involved there and that's how probably you can even understand the sequencing of transaction so first what will happen uh let's say i made that transaction i'm i ordered something and now i'm just paying that amount so first whatever amount i have requested right okay let's say 100 rupees i need to pay so that read operation will happen on my account second step will be just deduct say i requested for 100 rupees that 100 rupee will be detected third write the remaining balance to your account and let's say i was having 1 000 rupees in my account so after deducting 100 it will be 900 so just the deduction happen i need to update that value on my account as well next read your friends account balance or let's say wherever i'm transferring the money so that amount will get read and whatever is debited from here will be getting credited on my friends account and same updating the balance detail something so this is the whole process of the transaction so this whole set of operation can be called as a transaction although like we we can say that there are multiple operations you can say which are involved here read write update operation but the transaction can happen but the transaction can have operations like read write insert update delete so these things will be actually part of the entire transactions so these things which are happening here read write update insert delete these will be the part of transaction but this entire from starting to the end whatever actually happened that was the you can say the logical unit completely end-to-end logical unit which was getting processed and that's what we called as a transaction and these things read write insert update delete can be the part of any transaction so sometimes right at any given point of time we might be doing like these kind of things right with our database probably we will be reading something right or we will be writing something we will be inserting something we will be updating something and we will be deleting something okay so these will be the part of the transactions now let's try to understand from the the uh technology perspective or the technical perspective the different states of transactions as well so uh and this state term is quite common uh in the software development right across the software development thing this state management everything uh will be having some particular state right so and if you want to understand what is the state here uh so estate is just nothing like you can say the value of something at a specific point of time okay that will be actually known as a state and uh so or you can even say let's say the progress bar we we have seen the progress bar right yes start from the zero percent till the hundred percent so let's say at a specific point of time it is at the 70th percent so i will say the current state of my progress bar is the 70 okay so similarly what is happening right even i will take that example again if we are ordering something on e-commerce platform it will have multiple step right so at any specific point of time the value of some specific record in a database can have a different state right let's say you booked uh something right you ordered something you purchase something from that e-commerce platform so first your order will be created so the current state of your order is created now after that what will happen uh the payment part right the payment part will happen after that your order will be placed so your order the status of your order is placed now after that what will happen shipment so your order has been shipped after that that order has been arrived at your place and after that if you want to let's say cancel or any refund related something so this state of order record or audit transition is getting updated so different timestamp different state similarly when a transaction happens it actually passes through with multiple states and those states can be actually start from here right so let's say as soon as i am going to do any activity on my database that means our transaction has come into this active state right active state like where i have submitted i written some query right or i written some logic which can get or which can actually manipulate my database so now that transaction is in active state so from active state it can actually go into two direction or in two states right because of let's say uh manual intervention or system failure or let's say your application got crashed okay so instantly your query or whatever statement you have uh just thrown to your database to manipulate it will get into the failure state right because it was not able to get executed instantly as soon as it was in the active state other state can be like let's say we were doing some read write insert update delete operation so if there was no instant failure it will go into this partial commit state right so like we will get to know more about this committing logic and why this is actually happening because uh to maintain our database in the consistent state right in in the world of technology like any kind of failure or any kind of malfunction can happen at any point of time so that uh in order to prevent this uh like these kind of systems the database management systems or any kind of application are built in such a way that even if this kind of scenarios happen we are not losing our data whatever we were trying to do that right so this is the like you can say before actually committing some something this is a partial commit or you can say a checkpoint where whatever we were trying to do that is that is committed in in a temporary way right not the fully into the database but in a temporary way it has been committed or it has been logged for us okay so that is the partial state and even from this partial committed state right because of the reasons it can go into the failure state right let's say some some synthetical checks right fail or some semantics check fail or some logical uh check failed okay so very simple operation let's say you were trying to do some mathematical operation which were kind of logically not possible let's divide by zero so although like when you submitted your statement it was in active state but when it was getting computed or trying to change something right it got failed because of those a logical computation error so from this partial committed state it can go into the field state again now let's say partial committed part everything was successful here like your transaction got successfully executed whatever you want to do read write update or insert anything after that probably you will try to commit the changes right or whatever was in the partially committed because this was the temporary commit or the partial commit now i want to reflect since i need to make my database consistent or i need to permanently lock those changes in my target database so i need to do this permanent commit right so that changes can happen in the target database so here we can see this commit state and this this cycle i hope it is clear active state from the active state it can go into the fail state okay and here if things were fine it will go into the partial committed state from the partial committed state we will be doing a permanent commit and that will go into the committed state and after that it will go into this terminated state right that means everything was successful after the commit i am just terminating this transaction so here from this failed state right what will happen it will go into the aborted because uh things got failed whatever transaction we were doing it got failed that means i need to abort that transaction instantly so it will go into the abort state and after that from this abort state it will go into the uh terminated state right so this roll back is right what is something failed and then roll back arrow which is pointing to this aborted state so rollback was something let's say uh we updated here something okay for a very very simple example again we will try to understand it with the you can say the money transfer so let's say there were i made some transaction 100 rupees were deducted from my account and because let's say i provided wrong account information of my friend in that case let's say the uh amount which was debited the application or the intermediate bank transfer what it will try it will try to credit uh that amount whatever account information i have provided but because of the misinformation uh since that account doesn't exist what my bank will do it will just revert that thing so that things are consistent on my database because the success of transaction was dependent until and unless that amount is getting credited to the end or the targeted account since that transaction wasn't complete in the middle so the the thing i was talking about uh it once the 100 rupees got deducted or debited from my account it was in the partial state right the partially committed okay i have done that i have updated values in your account now i need to make the permanent changes on the target account side and from that because of that wrong information it came into the failed state right so as soon as the fail state is updated now this uh with the help of rollback it will go into the abort state so abort means roll back what happened here like whatever amount was debited i will just again put it back and so that the actual values are consistent there is no inconsistency within the transaction or within the databases okay and that is the actual rollback whatever we did or you can even in terms of very very easy language you can understand it like a undo operation right whatever we did just do a control z and your previous state so with the help of this rollback operation we will go into the award that means whatever was deducted or if anything happened on the source database those changes will be reverted back and this transaction will be cancelled or terminated so these are the different different states of the transaction and uh trust me this is one of the important question as well from the interview perspective as well and if you are in your colleges uh when you will appear in the interviews and even your end semester semester exams this is a kind of pet question right like define the different states of any transaction what will happen so like if this is looking complex to you right i hope it won't because i just explained it with the help of example but still the bank transaction is something which is very very logical and very very common to explain you can just imagine that scenario and try to map everything with these state transitions so these things were about the transaction states now let's look at uh the uh this part right uh the actual uh part of the theoretical concept we were trying to understand what is active state fail partial and these things in the theoretical aspect so here if our transaction is in execution then it is said to be in the active state so as soon as we fired or we shared some command to our database that means execution has started so if anything any statement or command is in the execution that means it is in the active and that will be known as the active state of the transaction failed state if a transaction is executing and failure occurs either a hardware failure like we were talking some like your machine got crashed or anything or a software uh failure let's say your application uh because of the overload or multiple processing it got hanged or something right so that in that case is obviously the transaction will go into the failed state partially committed as we can see in the previous diagram right uh so state from the active state when there are read and write operation present in the transaction so whenever there will be read or write kind of statements will be present obviously things will happen in two phases first partial commit will happen and then the permanent commit will happen a transaction contains number of read operations write operations once the whole transaction is successfully executed right because uh that one particular transaction can have multiple steps right so until unless all these statements right within the transactions are completely successful that will be partially committed not be permanently committed okay and the transaction goes into partial committed state where we have all the read and write operation performed on the main memory right local memory of the system instead of the actual database so in whatever will be happening in the partial commit that means those actual changes are not getting made on the target database right that means the execution is happening because your rdbms is something it is an application which has been provided to you and which is helping you to manipulate your database right so it has the capability to execute your transaction in such a way that okay we read some values but we are not instantly going to make the changes in the target database first we will try to compute it wherever we are installed and once this successful all the statements are successful then we will reflect those changes or commit those changes in the target database so that is about the partial state again the committed state if a transaction completes this success full execution then all the changes made in the local memory like what which were in the partial committed state will be directly committed or permanently committed to the target database aborted state as we have seen in the previous diagram if a transaction fails right because of any reasons right if it get fails then it will go into the aborted state and the aborted state means everything has been rolled back so whatever was the previous consistent state that will be that will actually become the state of my database because the current transaction got failed so there shouldn't be any sort of inconsistency so that was the theory about the transactions and i hope the fundamental of transaction is at least clear because now these terminologies will come like again and again that's why i covered this transaction part here so that whatever next important topics we will be discussing you can actually understand what we were talking about and what we are trying to make you understand regarding the transactions so next topic is the acid property so this is again one of the very important very very important fundamental of the transactional databases now i think i i think this is the right time as well to let you know that whatever kind of relational database manual systems have right there actually this this term is very important the transactional databases so transactional databases where uh these multiple and frequent transactions are happening let's say the read write the insert update delete okay so those will be known as the transactional uh databases and there are another category of uh databases as well the nosql databases so in the nosql databases uh these kind of uh transactions are not that frequent right transactions means the insert delete update right those are not that frequent but because they are meant for the analytical purpose but here these are these kind of relational database funding systems are meant for the real time processing or real-time transactions continuously insert update delete right the crowd operations are coming in and that's why the continuous transactions are happening and that's why they are even known as the transactional databases and also uh for your better understanding i would ask you to explore this terminology uh olap and the oltp olap is basically online analytical processing oltp is the online transactional processing so that concept will actually clear your thoughts about the why we call it as the transactional uh applications or the uh transactional databases right so now let's understand the acid property and as i said again this is also uh very very important from the interview perspective and from your college curriculum as well from your semester exams because this is one of the important questions in the databases as well so uh so actually this acid stands for the atomicity like a for atomicity c for consistency i for isolation d for durability okay so these are the actual uh like meanings of this uh in each character within the acid property and everything has its own uh different meaning and own technical aspect to understand and we will talk about it one by one so first let's try to understand about the atomicity so what is atomicity by this we mean that either the entire transaction takes place at once or does not happen at all so atomicity like uh atom right just again uh this atomicity came from that word itself so something or a like piece something which is not breakable now right uh it cannot go uh into like we cannot break it down further okay so this this is how this atomicity came into the picture like there will be no intermediate state of any transaction either that transaction will happen successfully right else it will be in the failed state there is no intermediary state because uh if we are focusing uh on this intermediate because if you are focusing on the intermediary states that will create a inconsistency in the database because from your source uh value is something else and and your destination database value something is so again with the help of example let's say 100 rupees deducted from my account and updated value uh let's say i had 1000 rupee updated value in my account will be 900 but that amount has not reached to be the target database or my friend's account so obviously this is complete inconsistency right because uh the the thing we were expecting after the successful execution that 100 amount will be get credited and let's say my friend also was having 100 rupees in his account so now after this transaction on my account the remaining amount should be 900 and on his account the remaining amount should be 1100 okay but if the transaction failed obviously money was debited from my account but that is not credited in his account so this is inconsistency and in order to strictly apply that consistency and to maintain that kind of consistency this is the main purpose of having the acid or putting that kind of you can say putting that kind of rules and checks that the transaction will complete right either or it won't complete there would be no intermediate state at all and what happens in the automatic city it involves following two operations so abort and commit so these two operation will be something like uh which will actually uh guarantee this atomicity right or which will help this transaction to maintain this atomicity because abort is something what it does about roll backs everything like it will actually in case of the failure what will happen abort will roll back anything whatever was your previous consistent state it will put you in that state right if the failure happens and the commit what it does it helps the database to make the changes permanent so now even you can understand the importance of these two operations how abort and commit operations are actually helping this database to maintain the atomicity now uh we will again try to understand that thing with the help of this simple transaction table or charting you can say here again one thing like all or nothing rule just simple rule thumb rule to understand the atomicity all or nothing either everything will happen successfully else nothing will happen so here we can consider this transaction right of the following transaction t and it consists actually two parts like t1 and t2 so here what was happening uh before this is again kind of money transfer x was something which was having 500 rupees and why he was having 200 rupees in his account so two different databases for x and y two different things and here the transaction of hundred rupees is happening from the account x to account y so t1 will contain these kind of steps and t2 will uh contain these kind of stuff so in t1 what will happen first uh the entire value the money value will be uh like read from this source account or the account from where we need to debit the money then 100 just do a minus 100 because 100 amount we need to deduct and after that whatever is the new value because x minus 100 and again assigned back to 100 so whatever is the new value just commit it in the database source database for the consistency part and after this t1 what will happen the remaining of value in the account x will be 400 and if we focus on t2 so it will read the uh balance amount in the account y whatever has came from here the 100 rupees that means add in it and update the value of 5 so this 200 will become the 300 so if the transaction fails after the t1 because that's what t1 was something which was operating on the x account and t2 is something the steps which are operating on the destination account so in case let's say t1 get failed before t2 right this t2 is getting complete or this t1 got failed okay then amount has been deducted from x but not added to y that's what i was explaining this results in an inconsistent database state because in my uh source database or wherever my account is actually created in that database this will be inconsistent entry right because something debited from my account but has not committed or has or has not credited into the destination account therefore the transaction must be executed in entirety in order to ensure correctness of the database state so that was the theory behind the atomicity now let's look at the consistency i think previously whatever we were talking about you can say the example that would have definitely cleared your thought about the consistency how this consistency part actually looks and what is the actually meaning of consistency so this means that integrity constraints must be maintained so that the database is consistent before and after the transaction so whatever uh let's say a successful or a very like committed consistent state before any transaction after the transaction any of the database should be in the consistent state there shouldn't be any kind of inconsistency because of any anomaly or because of any uh malfeasance uh or because of any uh malfunction in the uh or because of the or because of any or because of any weird or weak behavior of the database so consistency what it actually refers it refers the correctness of a database right so how we actually check or validate the correctness of the database right with the help of the data checks or the data quality or equality whatever let's say previous or what will be the current consistent state in the database so because of that comparison we will be able to understand what is the consistency and that is that equality is actually the consistency part here if that is not getting maintained because of any reasons within the transaction that means our database is not consistent but in the transactional databases rdbms this is something the very very important part the consistency okay and that's how probably we can look into the previous example so here let's say the previous example right so before transaction this transaction if we want to validate right total amount so x was having 500 and y was having 200 so total becomes the 5 plus 2 700 okay that means before this transaction the total summation of amount was 700 now after the transaction let's say i did any kind of the transaction whatever let's say debit it from here and get credited here so after this transaction as well the total amount should be equals to 700 right if you agree with that how that is happening 400 plus 300 because i made a transaction of 100 rupees which got debited from here that's why this value became 400 earlier it was 500 and since 100 got credited here so that's why the previous value was 200 and now it has become to the 300 so before this transaction the total sum of money was 500 plus 200 700 and we can see here after the transaction it is 700 that means our database is in the consistency state right so that is here the consistency means the correctness uh and again if i can help you the income if again if i can help you to understand the inconsistency let's say 100 was debited but this t1 got failed and this t2 didn't happen so what would have happened since 100 has debited from here so this value would have become 200 but the 100 rupees didn't get credited here so in that case this value would have been 200 itself not the 300 so now if we would have done the summation 400 plus 200 which will become 600 but the previous the total sum of the 700 so 700 is not equal to 600 that means our database is not in the consistent state something happened with the transaction something wrong happened and that needs to be fixed and that is where the atomicity helps like if we are not maintaining these states in such fashion we are not doing that roll back operation abort operation or the commit operation our database or values will go into the inconsistent state now let's look at the isolation part so this property ensures that multiple transactions can occur concurrently without leading to the inconsistencies of the database stage so here what we actually mean here is that isolation is something just try to understand in the simpler word let's say you have one single table right one single table and that one single table can be accessed by different different users at the time right makes sense let's say there is user one he want to do or he want to read write something from the same table and i being a different user i can execute different commands on the same table same database and there is third person who is actually using the same table so that is actually the concurrency at the same time multiple users are accessing the same resource or same object same data okay and now let's say they are filing their own statements at the time multiple statements or multiple transactions are running on the same data or same record so with the help of the locking mechanism which will be reading in the next part because these rdbms systems are smart enough to implement these kind of things or to follow these kind of properties that's why those kind of technical implementation has been done in the system in such a way even if the multiple transactions are trying to access the same value same records that won't hamper each other whatever let's say they were trying to read or whatever other transaction different transactions were trying to read it won't impact each other values because this rdbms will try to process those transaction in such a sequence that nobody is uh or there there isn't any kind of transaction which is uh updating any random values right let's say i i given some command to my database that update the value of x the previous value of x to x plus 10 and this guy also did same time of operation let's say update the previous value of x x plus 30 so that is not like going to happen i mean at the same time our system is not going to do it it will do it in such a way so that everything is consistent and those uh like whatever these statements and they were trying to access the same object they are somehow not overwriting the values of each other okay everything will run as a single unit that transaction will do its own work and that transaction will do its own work they are not getting conflicted with each other so transaction occurs independently without any interference changes occurring in a particular transaction will not be visible right whatever changes that transaction is going to do it is not visible to any other transaction that's why there is no conflict in between these two transaction this property ensures that the execution of transaction concurrently will result in a state that is equivalent to a state achieved these were executed seriously in some order okay so because if we know the sequencing of different different orders we can even predict the output right let's say i have some value x which is having the actual numeric value x equals to 100 and in sequence let's say we are doing something right first there is one command which did let's say x plus hundred there is another command which did x plus 200 there is another command which did x minus 500 so this system will intelligently try to understand which transaction came first and based on those uh allocation right based on the transaction timing and all it will try to manipulate that's why there won't be any kind of inconsistency again right if that system is actually allowing everybody to update that same value same object at the same time that will be an ambiguous answer right everybody will see a different result so now i will talk about the durability so durability what it means this property shows that once the transaction has completed execution the updates and modification to the database are stored in and return to a disk and they persist even if a system failure occurs right so here what actually means with the durability like these rdbms or transactional databases they are again capable enough right that if something happens okay or whatever executions we are doing first that will get computed in memory and that will be uh in like two phase commit thing right like we were looking at the states of the transaction so there was a partial committed state so that partial committed state is nothing it is again simply that the something got executed in memory and after that it is just being written to the external disk or as a like temporary state or temporary committed state and how it is actually helping again because ram are something which are volatile right if something happens right because of the system crash or anything whatever was in memory that will be lost because your system will restart it so that's why in the durability uh it ensures that whatever has been computed that is stored temporarily in the committed or as a committed states at some external disk which is kind of a persistent memory and after that if we just restart our system back the entire system can start from that state itself and those permanent changes will reflect in the end database right so that's how this durability property works these updates now become permanent and are stored in a non-volatile memory the effects of the transactions thus are never lost so durability actually helps basically in the fault tolerance you can say as well right because uh if there is any kind of uh mechanism where we are not doing this two phase commit and anything happens in between during the execution or uh before just committing the changes into the databases and if you don't know about those changes those changes are not stored as a temporary committed state if something happens to the database there will be inconsistency again because something has been read from the source database computed but the changes are not committed to the final database so this durability is all about that so the acid property in totally right the main agenda or the main purpose to have these acid properties in the transactional databases is to maintain the correctness and the consistency of the database and i think whatever i have explained in the atomicity so we can again just reiterate it so atomicity is about that either everything will happen successfully or executed successfully else nothing will happen right so after atomicity there will be consistency so consistency what it does mean before the transaction whatever was the consistent state after the transaction our database again should be in the consistent state right now after that the consistency part there will be isolation isolation means if multiple transactions are getting executed in parallel or at the same time and pointing to the same objects so those will be running separately no transaction will know about each other what that transaction is trying to update and they will run or they will executed independently so they are not doing any interference with each other or trying to overwrite their values okay and the last will be durability durability is basically uh to provide the fault tolerance like until an unless uh like our final changes are committed those changes or the statement which has been executed the result will be in the partial committed state and after that it will get to the final committed state and why that was maintained because in between something can fail and we need to just we actually need these kind of committed state for the recovery purpose so that is about the durability all right so now we will talk about the concurrency concept in the relational database management system and even the previous slides when we were talking about the acid properties i actually called out this term again and again multiple user multiple connection and multiple statements are getting executed on the relational database management system and in that case this concurrency factor will come into the picture and this is the generic one in the tech industry or in any of the application even if you are developing software applications uh android apps web apps or any kind of application so concurrency is something which you actually need to deal with it because uh in today's modern tech industry we are trying to write the scalable applications so scalability means at any point of time there can be more than n number of connections at the same time on any application so your application should be capable enough to serve those multiple concurrent requests and same goes with the rdbms as well because that is also one of the software applications so at all single time there can be n number of connections and number of statements can be executed on the database and when this actually happens so those uh concurrent connections or those concurrent statements sometimes might try to access the same table same sort of record and that may actually lead to ambiguous results if the sequencing is not maintained properly right so this concurrency concept is all about that so let's deep dive into it and understand its different technical aspects so in a multi programming environment where multiple transactions can be executed simultaneously it is highly important to control the concurrency of transactions because it can lead us to the ambiguous results right there some let's say transaction one or let's say there is transaction two they are trying to access the same object trying to modify the same object and there is no proper sequencing is maintained they may overwrite values written by each other so we have a concurrency control protocol to ensure uh the atomicity isolation and stabilizability of concurrent transactions so these things are actually maintained by the rdbms system itself so that is the inbuilt feature of them the way they have been designed so they actually take care of these things in its core so concurrency protocol can be broadly divided into two categories so since here we we saw right the concurrency control protocol so there could be multiple ways to handle the concurrency right and here in the databases we have the two methodologies you can say two protocols or two set of instructions we use to follow in order to maintain the concurrency first type is the lock based protocols and second is the timestamp based protocols so let's try to understand both of them one by one so in log base protocols what happens database system equipped with log based protocols use a mechanism by which any transaction cannot read or write data until it acquires an appropriate lock on it so let me explain uh what actually mean so this locking system or the log base protocol is very very common right very very general in nature as well right even we used to put a lock if there is some some data right and we don't want anybody to access it just we we put a log in it and until unless we are come let's say we are came back and then we hand over the key to someone else and then they can access it right and similarly in uh like the uh real world whenever you see right there there can be multiple scenarios where uh you are actually not allowed to access something until uh somebody else has executed it or somebody else has uh used it properly right so this is nothing basically the resource consumption and proper allocation of resources based on the sequencing and even to maintain the concurrency part so in log based what happens uh if there are multiple transaction which are getting executed so here what will happen any particular transaction won't be able to execute anything on particular table particular record until and unless it will require some lock so if you want to execute something first lock that object whatever you want to compute it can be a table record whatever it is just first make sure that you have requested proper early and you have got the lock on that particular table because until unless you won't get the lock i like we won't be able to execute anything right because that locking itself means that somebody else is using it right so i will be waiting for that lock to be unlocked so that i can consume that resource so here even the locking is actually two types binary locks and the shared or slash you can say the exclusive locks so in binary locks what happened a lock on a data item can be in two states it is either logged or unlocked so this is very straightforward binary means either it will be locked completely locked that means let's say five transactions right simultaneously concurrently they are trying to access same table and based on uh let's say different intervals they came into the system so whosoever got the log first let's say t2 got the log first so it will just access that object and it will keep on executing whatever execution or whatever computation it was supposed to do and once that is done successfully gracefully t2 will unlock that table that i have completed my task now i can unlock it and other like remaining transaction t1 t3 t4 t5 can use it so here like no sharing in between okay let's say partially i'm doing my task partially you can do your task on the same object no if somebody has logged it it is completely blocked until unless that person or that transaction release it so this is the purpose of the binary locks second is the shared or the exclusive locks so even the share to term itself represents what is the meaning of the uh sharing base uh lock protocol so this type of locking mechanism differentiates the lock based on their users if a lock is acquired on a data item to perform a write operation it is an exclusive lock allowing more than one transaction to write on the same data item would lead the database into an inconsistent state read locks are shared because no data value is being changed all right so here y is shared and exclusive so these two do two terms added here itself like a lock can be exclusive and unlock can be shared as well so let's say uh 10 transaction came into the picture okay and they somehow actually uh let's say five of them are just doing the read operation from table x and five of them are actually trying to do the right operation on that same table okay so whatever transactions like they are trying to access the same table and same set of records and trying to modify it that in that case lock will be exclusive for those five transaction who are here to update some value to write something because writing is something a very critical operation it is modifying the state of database uh it is updating some value so again that's what i was saying it will lead us towards the inconsistencies in the databases if we are not managing the concurrent write request on our database so that's why when write request is there definitely like lock will be exclusive uh it will be a very straightforward if let's say t3 has locked the table for its write operation once it will be done then it will be released then other t4 t5 t6 will be able to consume it but this is not the case with the read operation because read it read is something which is very straightforward so read let's say there is a book right there in the book uh it is a book of science something right same author same subject and anything so like i can read that book my friend can read that book and me and my friend can together read that book because here what is happening we are not going to modify anything in that book that book is a common resource for us we are consuming something right the value or the content which is written in the book that is not going to modify at all we like manually we are not modifying it uh like in any way so that book is actually a common resource for us so similarly if uh within a table there is some information which can be consumed by multiple operations and multiple transaction so there is no harm to make that table as a shared table for those transactions who are actually doing the read operation and that's the purpose of or that's the main motto behind the shared locking so i hope you get the difference the exclusive and the shared and the binary type of logs now this this was about the log base protocols now let's look at how this timestamp based protocol works and helps in the concurrency part so time based protocols the most commonly used concurrency protocol is the timestamp based this protocol uses either system time or the logical counter as a timestamp so i hope uh somehow with the timestamp based name right you might be getting the idea of this protocol and just apply it in your general life as well right let's say you are going uh to the railway station right for the train reservation or anything right like physically uh you just are going there and want to book a ticket so obviously there will be a queue in that queue how they actually figure out uh who who is actually able to who is actually eligible to get that ticket first or uh second third and so on based on the time value let's say i arrived station at 10 am and somebody is coming at 10-5 so obviously i am someone uh who is uh or who should be on the priority to get that ticket right and that is the timing part so similarly like even that databases or the rdbms system applications are smart enough so as soon as there will be some transaction or any incoming traffic of statements will be coming they can use the system time and even any logical counter as a time stamp right in order to uh just figure out okay who came first and who came next something like that so this is the first point second log base protocols manage the order between the conflicting pair among transaction at the time of execution so at the time of execution like this is theory about the log base protocol so how they actually work at the time of execution they will figure out okay whether do i need to just log this table for transaction t t3 t4 t5 because at the time of actual execution our dbms will be able to know that yes there are five transaction which are here to do the right operation okay so in that case obviously uh in the log base protocol the actual decision is being made during the execution of statements whereas time based protocols start working as soon as transaction is created so here there is nothing like that means somebody will wait until you start your execution and at that time i will figure out whether i should provide you the lock or not in times time whosoever is coming first let's process it that's simple as simple as the definition is so every transaction has a timestamp associated with it and the ordering is determined by the age of the transaction age of the transaction means how old it is and how new it is so that is the age factor means a transaction created at let's say two o'clock time would be older than all transaction that come after it like that's obvious uh let's say i i'm someone who came at the 10 am right and somebody came at the 10 20 am then 10 30 am so i am a kind of transaction which is older than those two who came after me right for example any transaction y entering uh the system at four is two seconds younger the priority would be given to the older one so this is like the at the second second uh this transaction came into the system and at the fourth a second this transaction came into the uh system right so who will be given the priority obviously this one because this was the older one in addition every data item is given the latest read and write timestamp this lets the system know when the last read and write operation was performed on the date item so even like the database when it will use this timestamp based protocol so these timestamp related values will be managed by the database uh itself like when the latest read or write operation happen on the table even if a transaction is coming into the system then what uh is what was the time for that transaction and based on those time sequencing ages it will maintain that sequencing and since sequencing is maintained property if so since sequencing is maintained here properly there won't be any chances for any inconsistent state or any sort of stuff because uh like the proper sequence has been made here and everybody is getting time for their execution not uh like all five or six transaction at the same time at the same second pointing to the same object because obviously it's quite normal there will be some at least a millisecond sort of difference uh in the arrival of different transaction and even based on that millisecond of the time interval the dbms can decide who should be given the first priority and who should be the next one so that was the main concept about the concurrency in the dbms so these two kind of protocols are basically used and even the important factor in the databases and in the journal applications as well now comes to the main part and one of the most important concept in the dbms as well most important concept from the interview perspective as well and most important concept in terms of the database optimization or the query optimization perspective right so we will look at the indexing and we will try to understand why it is that important what's the main purpose to have it one by one we will discuss it so first let's start with this try to understand what indexing is and i think this is very common and indexing in general right we can even uh understand the value of the indexing just with the help of our books right if we have a 500 600 or 1000 pages of book uh how can i precisely find a particular chapter or like and how can i actually read it so obviously the thing which actually helps us the index page because in index page the uh subject title or the topic title even sub topics right will be mentioned and those sub topics are on which page index and we quickly just find it out so same concept works in the databases as well transactional databases as well and i will tell you that how this actually works and what's the typical meaning of it so indexing is nothing just a kind of data structure technique to effectively retrieve records from the database files based on some attributes on which the indexing has been done so again simply you can uh in order to understand the indexing just keep this example in your mind the index of your book right so the way the index page of your book actually helps to quickly retrieve or to quickly jump on to that particular page so similar concept has inherited from that concept in our databases in particular table it can have like very uh huge amount of data it can have let's say uh 1 million 2 million 10 million kind of records okay and whenever we actually operate on these tables or on these kind of database system we will be working on some specific set of records and in order to work on those some specific set of records uh we need to actually just try to uh find it where they are located in the physical memory okay we as based on the uh statement which has been received by the database it will quickly check okay which table it is what kind of column is being accessed in that query and the internal pointer or the internal head pointer of the system will just locate that record wherever it is stored in the physical memory and then we'll be able to retrieve it so there is too much uh like you can say seek time involved here right if we are not including this indexing concept so because that couldn't be a potential question as well like why do we even need the indexing so in order to understand the indexing we need to understand this concept as well like how this uh simple uh record like storage and record retrieval works and everything is data here so that will be stored in the memory so just you can relate with your simple programming languages where you have some variables and you assign some values so those values will get stored some memory location and same happens with the databases as well whatever table we have created whatever data we are giving it to the database that will be stored to some particular memory location and if we quickly when we talk about these number of records like 1 million 2 million 10 million that seek time can be really really big right and it will result this slow query performance let's say we fired the statement uh right and after five minutes we will be getting the result because the data volume was big and uh there should be some mechanism so that we can quickly find that particular record which we want so here this indexing will uh help into the picture and uh similarly it is just a kind of data structure you can say custom data structure for you which will hold the actual memory locations right the actual memory locations of those records which are stored in the databases or eventually you can say in the physical memory and since you have the memory location of those actual records you can directly jump there and pick that record so retrieval would be really really fast if you have applied the indexing and even the indexing part is something uh which works on based on the column uh concept right because there will be some specific column which we will be using again and again in our queries and when this thing actually comes into the picture like repetitive columns or any logical thing which you uh particularly think that should be used as the indexed column we can use it and based on that indexed column uh the actual memory locations will be saved here right so that is the whole concept of indexing and there are different different types of indexing as well and now we will talk about it one by one right how these different indexing actually looks and what's the advantages of it so first is the primary index second is the secondary indexing third is the clustering indexing so in primary indexing what happens primary index is defined on an ordered data file order data file nothing like again a structured data it will have some set of rows columns okay the data file is ordered on the key field the key field is generally the primary key of the relation right so when we can say that we have applied the primary indexing so if we have used the primary key as a column where uh or using which we have applied the indexing that means this is the primary indexing so here because primary key is something right which will be unique as we know from the previous concept that will be unique throughout the table because this is the primary key and obviously it will have some ordering as well some specific or sequential ordering as well so as soon as we apply this uh primary or if we actually use the primary key in order to create the indexing so those records will get ordered in that fashion and as soon as that index part is actually uh present uh with us we can quickly just point out to those records uh for which uh or basically you can say which are actually mapped with the help of these primary keys we can quickly retrieve it so again like to just reiterate this indexing is just nothing again you can see like a simple table has been created for you right where uh like you can have multiple columns multiple columns will be something like the columns you have choose for the indexing and those columns are actually where they are located like the values where they are located okay and that will be your uh you can say memory address of those record itself so secondary indexing secondary index may be generated from a field which is a candidate key so if you remember the previous topics where we talked about the key concept so candidate key is something which is then the alternative of any primary key because those candidate key will eventually return as the unique uh record or basically these candidate keys are also something which uniquely identifies a record from the given table so if we are using the candidate keys in order to do the indexing based or you can say the uh we are doing the indexing based on the candidate keys that means that is a type of the secondary uh indexing now let's look at the clustering indexing so clustering indexing is defined as an ordered data file the data file is ordered on a non-key field so whenever we are doing so whenever we actually trying to do the indexing on non key attributes that means that will fall into this uh cluster indexing so clustering actually means right so like let's say we have our data for the populations right we have the data for the population of different countries so here what will happen in that particular table there will be one non-key attribute let's say country name so india let's say china usa and uh like um there will be england or any anything right so there will be country names for for the same and what will happen uh within that table for uh country india there will be multiple entries right now if we know that somehow i pick this value india i can make a cluster of it like whatever records where this value is at the country value uh or the country name value is equals to india that is a separate part itself so whenever let's say i want to compute anything within the population of india i can quickly use that column name where the column name is equals to india and if i exactly know where all the records related to country name india restore i can quickly go there and use that part there is no need to unnecessarily scan the entire table where we have the mixed records of the india different countries because that will be unnecessary a traversal time it will even uh like increase your seek time because you are unnecessarily scanning the table although you actually need the data set or the cluster of that particular data which is especially meant for the india right so that's how like sometimes those kind of non-key attributes can help us in order to create the indexing in such a way now within the primary indexing uh it is actually of two types so first is actually the dense index and second is the sparse index let's look at it so what happens in the dense index in dense index there is an index record for every search key value in the database this makes searching faster but requires more space to store index record itself index records contain such key value and pointer to the actual record on the disk so that's what i was saying right uh so when we are actually trying to create the simple uh indexing kind of a small table or basically a kind of small table or you can say it's a data structure somehow it will hold that column values right for which we have applied the indexing and correspondingly it will hold the memory location where we can find that record or where we can find the record where if we apply the search key is this right let's say search key india so in front of it it will have some memory location and it will directly point to there and then after that our uh like seek pointer can read all those records related to india quickly from there so in the dense uh index what actually happened so here this index will be create for every column value right so if let's say we had that country name column and we have let's say more than 30 or 40 50 countries something right values so there will be one entry in the indexing table for each column value so for india there will be one entry like the value is india and its corresponding memory location similarly for the china for the usa for the united kingdom for the russia and many others so for every single distinct value there will be one entry in the indexing table so that we can quickly jump there so that's why it will become quite dense right because there are so many values and we have accommodated everything and that's why it will be known as the dense indexing so dense indexing is definitely beneficial because for everything you have a mapping available you can directly jump quickly on that particular memory location and pick the record but it will definitely eat up the space as well because indexing like when we talk about the data structure so uh somehow like you are holding or you are like creating a kind of uh or you are somehow actually occupying the space in the memory itself in order to create these entries okay for india this will be the memory location for usa this will be the memory location so that also needs some space and you have let's say somehow pick that particular column uh which has so many so many distinct values right let's say you have in your target table you have more than 10 million records and you picked that particular index column right which is having even let's say 1 million kind of distinct values all right and you did a indexing on it so that will also like take up a good memory storage right because in order to hold those 1 million distinct mappings for the memory locations is something which which can take a good amount of space so that is the main thing although it will be dense it will help us in the quick search but from the space consumption perspective it is not that efficient now let's talk about the sparse index in sparse index index records are not created for every search key an index record here contains a search key and an actual pointer to the data on the disk to search a record we first proceed by index record and reach the actual location of the data if the data we are looking for is not where we directly reach for the following index then system will start sequential search until the desired data is found so now what actually mean here so here you can see right the all the mappings has been created here so in sparse metrics right our database will smartly smartly it will not try to create the index entry for every distinct value or the search key you can say whenever i'm saying distinct value for the search key right here india is a search key like or you can say value for some specific search and japan for some specific search values and germany and france so what it will do uh it won't create the entry for every distinct kind of uh you can say the entry which is present right in the particular table what it will do it will just pick some of the distinct values right some of the distinct values and it will make an entry for that as simple as that it will make an entry for that cool so in that case what will actually happen so if the we also know so indexing is something which will be again in the order even let's say you can see right uh whatever we have here right the this will be these search keys will be some in in some specific order right so in some specific order what will happen here you can see wherever we have these arrows right so that means index has been created for india right uh as soon as we have uh this value india as a search key and in the index table obviously the entry has been made we know the direct memory location of this record i can quickly jump there for japan we have the direct mapping in the or the direct entry in the indexing table but uh here again for the france we have the direct indexing but for germany we don't have the direct indexing so in that case what will actually happen if you again read this statement to search a record we first proceed by index record right first index record and reach at the actual location of the data if the data we are looking for is not where we directly reach by following the index then the system starts sequential search until the desired data is found so in that case what will happen first it will see right whatever the column of value or the search value we are trying to find if that is somehow present in the indexing list okay so based on that uh directly we can jump onto that location right we will get the particular record so here let's say we wanted to search a record or we wanted to pull a record for the country germany so here you can see for germany there is no direct index entry has been made in the indexing table so first uh as soon as we pass this request uh the pointer will come here it will check okay uh if that value or the search key present here if yes i can quickly jump on to that memory location if not what will happen it will try to do the sequential searching right sequential searching until and unless uh it will uh find the record so it will check if okay the current uh search keys equals to germany and if i'm pointing to this record here india not equals to germany here japan not equals to germany but here germany is equal to germany that means this record will be just thrown back to the input request so that's how this is pass indexing work and here you can see since like entry was not made for every single uh you can say uh the distinct value that's why uh it won't take that much space few of the distinct values will be picked and that's how the indexing will be created now let's look at the secondary index what happens in the secondary index and we will try to understand it okay so in secondary indexing to reduce the size so why we are again focusing the size uh that is the important perspective as well from the uh memory uh efficiency and from even the optimization perspective if you are not like smartly taking care of these things our applications or may get crashed and because of that heavy load on the databases and even our database won't be able to scale because there is unnecessary memory is getting occupied so in secondary index to reduce the size of mapping or basically you can say the indexing table another level of indexing is stored or another level of indexing is introduced in this method the huge range for the columns is selected initially so that the mapping size of the first level becomes small then each range is further divided into the smaller ranges okay so here in this diagram you can see right this is the data block you can say in memory or you can say this record this is record one which is stored at memory location hundred this is record two which is stored at memory location 101 and similarly right now here we can say first we have created this indexing table in this indexing table what happened we actually just picked this entry right let's say if we have or we basically want to find here this 100 was actually meaning some column value let's say the roll number right roll number of any student so roll number 100 is stored in this memory location roll number 101 is stored in this location this this this and so on so here first on the like what we did we created one mapping table or again a kind of uh indexing table first level of indexing table what it will do it will uh use this roll number as a search key and for this one it will create one entry okay where this record for the roll number 100 is stored so again things will be in some specific order like ordering will be maintained okay so here you can see right row it has this entry has only stored the memory location of this record or this block and this this one like the roll number 10 the second entry in this indexing table is for the roll number 110 so the the entry for these one because else it will become quite dense right so this first level of indexing is somehow the good example of sparse indexing as well because if we know somehow we can reach here and from there we can sequentially somehow uh just reach at a specific record so how let's say i want to search a record for that student whose role number is equals to 105 so quickly from here to here right roll number one and i know roll number 105 will somehow lie between these two roll numbers okay and 105 is something which is less than 110 so i should quickly pick this record and i need to reach the memory location for this roll number 100 and from there i can quickly start and i can simply reach 2105 and we'll pick that one same goes for the other example so this is the first level of indexing we have maintained now similarly we can actually somehow disperse or we can bypass our incoming request for the filtering or record searching how again based on this ordering and indexing right we can even minimize the scanning of the data so here this is the first level of the indexing uh will be created this index will be created in the main memory because whenever we perform the indexing or whenever we try to create the indexing that indexing is something that will be stored in the in memory the ram part right that's why this search query becomes very faster because as soon as there is a search query we will quickly go into the indexing which is stored in the main memory and will quickly directly refer to that particular record so here the first level of indexing has been done because it will be quite big in size here we have took some smaller gaps okay and created the entry based on that and that's how that will be stored in the secondary right you can say your external hard disk not external means the um other one like the which is in your system itself right the external hard disk part so this one will be created here and now somehow if we uh the concept we followed here same concept we follow here here we have increased the gap right from here we are not again storing entry for everything we made entry for roll number 100 we made an entry for roll number 200 we made an entry for the roll number 300 and now this this index uh table or this indexing table will be in the main memory now let's say there is an incoming request where we are trying to filter out the recorder we are trying to find the record for the student number 209 right roll number 209 so what will happen so that request will first try to check okay if the index request has been like maintained in this indexing table right so how can i actually pull that record quickly so i can somehow find the memory location of that record and quickly retrieve it so it will come here it will check the record or the roll number value is 209 which is greater than the 200 and we also have a value or memory location is stored for the roll number 200 now the next one is the 300 so roll number 209 is something which lies between these two right and with this entry or with the help of this entry i know the exact memory location for the roll number 200 so i will quickly jump here because this memory location is pointing the the memory location of this record which is maintained in the secondary memory okay so step by step we are going so now i am here and here i know what is the memory location for the like roll number or for the student whose role number is 200 or what is the actual memory the physical memory where that data is stored so i can quickly jump here with this arrow i will be quickly jumping here now i know i need to pull the 209th record so sequentially i can come here two zero one two zero two three something something and then we will reach to the two zero nine so you can see right how smartly our database ignored these unnecessary uh like scanning of the records it quickly first checked here right then it directly jumped here it avoided these many scans and then it quickly jumped here and pulled that record so somehow with the help of this indexing or the two level or the secondary level of indexing it avoided these many scannings or these many records and it directly jumped to the uh roll number 209 and that's how our retrieval also became quite fast here now let's look at the last one the clustering indexing how it actually works so sometimes the index is created on non-primary key column which might not be unique for each record in such situation you can group two or more columns to get unique values and create an index which is called the clustered index this also helps you to identify the record faster so here in in the previous slides when i was talking about the clustering there can be non uh key attributes as well on which we can apply uh the indexing as well and that's how like they can eventually help us right to directly point on to that specific chunk and as soon as we we just jump there or we moved there or basically that kind of cluster we can somehow uh like apply another kind of indexing there right if that those even data volumes are quite small if not we can uh somehow just directly do the sequential searching from there so here in this clustering index you can see we have a table for a company where different different departments right and in different departments there will be different different employees working in so now uh we at any specific point of time if we want to point out or we want to pull the record for the department where basically or that particular employees is working uh in department number four right and department is something uh department name you can say basically something which is uh like non uh primary key attribute in the employee tables right because that that will be duplicated entry there are 100 employees so out of 100 there will be let's say 30 employees who are working for the let's say software department so that software department value will be repeated 30 times so software or the department name is not a kind of column or the key attribute column which can which we can use it will be a non-peak non uh like it will be a non-primary key kind of attribute so on that here you can see right for all the records where the department is something like that right where the department id let's say one two three four so i have stored the pointer value for that right so you can see this cluster right clustering means this piece of memory locations is something or is basically ordered in such a way these are like somehow giving all the values or all the records for the employees who are working in the department one that's why i have only stored the starting location or the starting address of this entire set of memory blocks because somehow if i am able to read or reach at this starting address of the first record itself of the department one i can sequentially iterate here and pick any specific employee id or employee record here so similarly this value is pointing to this one right uh these memory blocks and this is the starting address or you can say if this is the collection of memory blocks for the department or basically for the employee records where the department id is three so that entry is made in this cluster index table similarly for four and similarly for five so here you can see that that cluster was made whatever we have just divided the chunks and we are just pointing that chunk within that chunk we are trying to find some records so that was the concept of indexing and i must say this is very very important from the optimization perspective the query optimization now even you understand how those unnecessary scans were avoided with the help of the proper cl with the help of proper uh indexing and this is why this is the very very important concept as well to understand uh in order to create the optimized application even in order to uh perform the optimized queries and other kind of stuff so make sure to read these things carefully from the interview perspective from your technical understanding perspective these are really important now we will look at the most important part of the dbms or even you can say the databases like how to execute statements how to write such kind of statements which will somehow manipulate the data which is stored in the databases how to retrieve the result how to write those kind of operation so let's take an again this simple example of the programming languages so every programming language has its own type of syntax like its way of declaring the variables at way of writing the for loops if else condition and many other things right so similarly when it comes to the databases and when we want to interact with the databases and want to manipulate or anything any operations like that we also need to follow some specific rules or some specific syntax right and that syntax is something which is called as a sequel or you can say structured query language so this is basically a set of you can say operations or a proper syntax or a kind of you can say programming language in order to just query some data or to just retrieve or manipulate some data stored in the databases so whatever steps or whatever statements we write right those executable statements in databases those statements will be known as the queries so we are just firing a query and we are sending a query that query will be nothing a set of instruction we will write okay this column needs to be picked this table we need to point and these kind of aggregation this kind of filtering operation we need to do and that entire set right whatever we have written that will be sent to the database and it will get computed so that's why the sql is obviously one of the most important part i mean whenever we are let's say working in any of the application software applications uh of obviously there will be obviously we need to interact with the databases so if you let's say you are in web developer or any android developer ios developer and majorly lets you are working on the back end part so you might be writing some rest apis okay and those rest apis somehow will make some db calls and that db call might be finding one of the sql queries right to let's say get the user data or to get the updated amount or to update something right something and read something right and return that output to the front end part right so this is one aspect but in the word of big data right when we talked about the data analytics and anything so that is heavily heavily dependent on the sequel because this is something which will help us to manipulate the data whatever raw data is stored on the database side we can write our own logics business rules using this sequel right in order to calculate some insightful matrices in order to create some insightful or to bring meaningful output data from the databases so in the big data profiles this sequel is very very important and has a very very big advantage and you can see a very very big weightage in the interviews as well so 30 40 percent of your section in the interviews uh will be dependent on your sequel so you have to be real really good at it but since this this entire session is all about the dbms so we won't be deep diving into the very very core part of the sequel but to just give you a glimpse how sequel works with the dbms and what are the basic operations here i will talk about that and for the dedicated sql we have already created some videos you can check out our previous videos uh like dedicated lecture for that as well but here we will talk about the basics only very very basic things right how uh different commands are segregated in different categories and apart from that since this is something which cannot be like elaborate in in terms of the theoretical aspects so i will also demonstrate some of the important right on some of the basic commands with the help of live demo right i will type some commands and will even show you on this screen that how these commands are working what's the database create and these kind of simple queries so first look let's look at what are the important uh commands we have the different categories let's understand that and then i'll show the practical part so sql stands for structured query language it is used for restoring and managing data in rdbms so basically this will help this syntax this because sql will also have its own syntax in own way of writing the things so we need to follow it in order to interact with any rdbms it is a standard language for rdbms it enables a user to create read update and delete relational databases and tables so we will have some kind of database where we are storing some data and that data will eventually stored in some tables so with these sql commands we can manipulate uh any data stored in any database and any table all rdbms most of the like popular relational database management systems are known as so most popular right which one is used is the my sequel infor makes oracle is there ms access and sql server right so these these type of actually uh like relational databases which are in the market they actually use the sequel in order to interact with it sql allows user to query the database in number of ways using like english like statements so same happens in the programming as well right in programming we we whatever that is a very high level uh like we have python java scala right other languages so those are the high level languages where everything whatever instructions we are typing it's a pure english type of language and we just type and that gets executed so same happens with the sequel as well so within the sequel uh there are different different commands right and those commands are actually divided into few categories so let's understand uh what each category means and why that command is like has maintained in that in that category so ddl first is categories the ddl data definition language so again i'll take the example of programming so when we want to execute something right we will need some inputs and we will need some output and in order to install store that or read that input and output we need some variables so whenever we start writing some program so obviously in the beginning we will declare some variables right we will define those variables some of the variables will work as a input they will whatever user is sending us that input will be stored in those variables and there will be other variables where we are computing something and storing the output in it and those variables will be known as the output variables so similarly uh we know in the relational database management system we will have the databases and within the databases we will have the tables right so these tables also contain some of the columns let's say name salary date of birth right multiple type of columns they can contain and each type of column will have its own type let's say name is something which will be of a string type date of birth is something which will be of date type salary something which can be the float or the integer type so here obviously before uh like working anything or before uh moving into the data storage part in any of the table first we need to create it right we need to define it we need to create define these that is why that is named as the data definition language so any sql command which is somehow impacting the structure or which is somehow modifying the structure of existing table right or a table which is going to be created that sort of command will fall in this category ddl right so what typical type of command sql commands we have in the rdbms which can fall into this category so create command create command very simple to understand that we are creating some table right so that means creating that is a new structure we are building for any table that is one thing drop command drop command will be something it will delete the entire table and its structure as well okay so that means we again modified the structure of given table we just like played around the structure of any given table so that's why this is also in the ddl alter alter command is something uh that will be uh in in or that can be used in order to just change the structure of any existing table right let's say earlier you had four columns in your table now you want to add one more column okay so you need to run this alter command and that's why that means you added or you actually change the structure of existing table by adding one more column similarly let's say there was one column in salary and earlier its data type was the float or kind of double okay which was uh even having the fractional values now we want to convert it into the integer type right so in that case what we are going to do we are going to change the data type of existing column so this is also the change in the table structure so that's why these are the commands which will be in the data definition language now dml dml is basically data manipulation language that means there could be or there will be some commands which will help us in order to manipulate the data manipulation can be of anything even we are trying to just do the read operation and write operation okay so those kind of things will be uh in this or we those kind of commands will fall in this dml part right so what are the some simple ones here the the most often use the insert so insert command is something where we want to uh insert one specific record right because a table will have some columns and uh in the table we store the data in row and column wise so whenever we want to insert one row complete record into the database or basically a table within a database that means we need to use this insert command then there can be update command as well update let's say uh there was some specific row and that row can be identified with the help of primary keys right and candidate keys composite keys right many other things we can use so that we can uniquely identify one record so for example now we have an employee table and that in that employee table we will have the employee id employee name salary and its department okay and since its employee table every employee will have its own employee id which is the actually primary key right in this employee table now let's say there is employee whose name is x and his employee id is one and what we want earlier let's say that guy was working that employee was working in the it department now we want to move into the software department okay so what will happen the earlier or the previous entry which was present in that employee table for the employee x and its department was id now we need to update that value hope we are getting uh hope you are getting my point since we need to update that value uh so updation means what we will do first we will just point out to that record where employee id is one right or where the employee id name equals to x okay and just update the value of the department column for that specific record only so here we are doing the manipulation again third can be the uh delete right so here delete means we are deleting the records which are present in the uh table right based on any kind of uh business logic or business rule let's say we have again we have the data of the employee tables and it contains the data for all the departments and from this table what we want we want to remove the records of all those employees which belongs to some department let's say finance right we don't want to keep their data in the employee table so we can simply remove those records and for that we need to use the delete command now these are something which is basically transactional control language tcl which means the transactional control uh language and when we were talking about the transactions and everything right and there was one more thing right acid properties atomicity consistency isolation durability and other things so those were actually meant for the transaction so everything whatever operations we will be doing right whatever queries we'll be writing to query the data from database that is something like the transactions will be happening like uh up reading some data and then updating in it and then writing right and in order to achieve the fault tolerant part right what we were supposed to do we or when i was explaining the life cycle of transaction so there were actually some states right first your transaction will go into the active state and once the computation has been done like first the computation will happen in memory right and whatever result will be there that will be a pre-committed or a middle state where the result has been computed okay and that result has been stored in the uh main memory okay but in order to reflect those kind of changes or in order to write those kind of changes okay what we need to do we need to do a permanent commit right so permanent commit when we will do it then those changes will reflect in the databases and that is why uh this tcl commands are important the two important ones are the commit so commit will what it will uh like do if we have performed any any kind of these data manipulation let's say operations the insert so insertion means we are adding new records updation means we are updating some records deletion means we are deleting some records so we need to commit these changes right so that will be a two-phase commit definitely right first those changes will write in will be written in the middle state or where that will be pre-committed and once we fire this commit that means now we are making or we are pushing those changes somehow to the active database and save we can say the rollback part was also there so whenever we let's say made some changes right and we thought those changes were by mistake or those changes can impact our database we can quickly fire this rollback command and rollback will basically take our database to the previous consistent state so that was the tcl and the dql data query so query uh also these things whatever operations here we will be using those will also be the queries we are let's say inserting something and we need to write a proper syntax but here the query which we are referring here that means to retrieve the data reading the data from a table so when we will read we will select some columns or we will actually can print the all the columns which are present in the specific table and for that we need to use the select command so select command what would it will do we will just uh like mention some of the columns or like all of the columns of any given table right select some uh employee id comma employee name from table right and we will get that data so here we are querying we are retrieving the data from the table and for that we need to use the select command and then data control language right so here we have actually grant and revoke these kind of two sql commands so in the beginning when we were talking about the advantages of the relational database management systems right so the main advantage was again the security part right let's say in your database you have stored some critical data okay and that database is something we are working as a team in a team there will be multiple members and you don't want to uh you don't basically want to let other users to access that critical piece of data okay in that case we somehow need to put some restrictions on those tables like who can actually let's say manipulate the data on the table a who can actually just query the data which is stored in table a who can actually delete the data uh which is stored in table a so that means these permissions right being an admin of a database i can actually decide which user can have what kind of permissions so when we talk about these permissions and giving these permission to any specific user that can be done with the help of the grant command and similarly let's say a few of the permissions were given to any specific user and now we want to actually remove those permission from that user we can use this revoke command and those permissions will be completely uh like gone for that particular user so these were the important categories and these important sql commands uh which lies in different different categories based on their characteristics and now let's look at the kind of operations we can do uh with the help of sql and what kind of operations we can perform on a database or the data which is stored in any specific table so see there can be n number of operation based on the business logic and based on any logical concept but here what i have listed those are very very often uh used operations right these are some specific things which we keep on doing probably on daily basis while interacting with any table stored in a database so like where clause this this works like a filter condition right let's say you have a table and from your table you want to pull some specific set of records based on some specific filtering condition we need to use this where statement or where clause we can also say order by order by basically let's say you retrieved some data and on your display on your computer screen you want to display it in some specific order right let's say ascending order of roll numbers descending order of roll numbers and similar type of condition then we need to use this order by command group by command is basically like we want to perform some aggregated or aggregation or we want to perform some mathematical aggregation operations right the so group by an aggregation function will be something uh mostly they will be used together right let's say we want to uh find the sum of the salary of all the employees who are working in the finance department right so first what we will be doing we will make a group right group based on the column finance or based on the column name which is department and where the value is the finance we will make that group and within that group whatever employees are there i will pick their salaries and will submit together okay so that's how these aggregation and functions and group by operations will work together next the case one statement uh this is again very simple if this this is like a if else condition right in the uh dcl uh category like data or sorry it will be a kind of if else condition in the data query language like when whenever we are selecting some columns so in that case what can happen we can display the data based on our some conditions so very simple example let's say you had a data for the student table right and uh student role number student name and the marks they have obtained and now you on your output screen you want to display a simple result right uh student name comma grade right let's say a person who got 90 grade or sorry who got the 90 marks that will be a given a grade or a plus grade so here we need to apply a if else condition in our select statement like select student name comma we will apply some if condition let's say if marks greater than 90 then print the value a grade if marks less than 90 greater than 80 print the grade equals to b plus something like that so for that we can use the case when operation and then the joining operation uh this is also next topic which we will be discuss so this is also one of the next topic which we will be discussing after uh doing some query operations and joining is something like in a database right there will be like n number of tables as well okay and when when we actually talk about the insightful information okay so there will be a need where we are supposed to join multiple data sets together in order to get the final result right let's say uh we have three tables so in first table there are four columns in second table there are three columns in third table there are nine columns and i need two columns from table a one column from table b and three columns from table c and since we already know that this is a relational database management system and when we are talking about these data sets so there will be some referential uh integrity among these tables right you with the help of foreign keys we can somehow interact with or we can just uh merge the information present in both of the tables and get the desired result right so similarly in this case join operation will come into the picture because here we are interacting with two three data sets together with the help of foreign keys and that operation will join that means we are joining two data sets with the help of some uh keys with the help of some column names or some uh conditions and similarly union operation this is a kind of uh you can say concatenation of two uh data sets or two data results or two query outputs which are having same number of columns and same name of the columns as well so these are some very very uh like important one as well we can say the basics as well from the sql perspective but very very often used right in our day-to-day activities these will be the common operation uh like we will be doing most of the time so that is about the theoretical part of the sql now i hope you understand what are different queries statements categories we talked about now in the uh next part what i'll do i'll uh open the console right in my local machine i have installed a relational database uh system that is the my sequel and uh mysql i can actually access it and i can operate on it on my command line itself right it gives the access to uh manipulate the data in the mysql using the uh just linux type of terminal where i can type these sql queries first i need to make a connection to my database and then i will be able to fire these queries so i will try to execute uh some of the uh basic and important commands one by one so that you can practically see what is query how it is being written and how it is getting executed all right so uh here this is my uh sql setup here you can say and uh here i am using the macbook and you guys can also follow different different instruction let's say you are using a linux based system or you are using a windows laptop right so here what you can do you can follow that particular instruction because these are the open source databases mysql at least right so what you can do you can follow those instruction and even you can set up or you can install these open source relational database management system on your local machine and you can play around it so similarly what i have done uh in my macbook i used the instruction and installed my sequel and as i was saying um here uh like this will actually allow me to open this uh my sequel shell you can say or a console access where i have a control on that particular mysql uh dbms and i will be able to just perform different different sql queries and i will show you how everything will work here so whenever like you will install mysql in your local right so what will happen by default it will create uh some databases which will be actually used to uh hold some metadata information related to the mysql database itself okay so uh let's say you have an empty database or even let's say you have any existing database and you want to actually see uh what is stored in that database or any database has been already created so there is a specific command for that show database so that will be a command right so here you can see right these are the some you can say system configured databases already created when we installed mysql in the local so whenever even you will install you will be able to see these things here so that happened now uh what we will do first we will create our own database you can see right these existing databases already exist we will create our own database and within that database we will create one and two tables and i will show you different different commands whatever we talked different operations even we were able to do it right so first how we can actually create the database in mysql so command is very simple create database and database name so here we will create a database with the name of scalar so now here we can see right this is a successful message query okay that means completely successfully executed and now if i again run this command so databases so now this scalar database should be listed here okay so now we can see this database has been created here now i need this database because within this database i will be creating my own tables right and within those table i will store some data so now database has been created so how i will enter into that database so for that we can use this command use database right so here uh i just need to mention this database name use scalar right so here we can see this command database change right that means now i am into this scalar database whatever table i will create delete update or any operation i will be doing that will be performed the tables which are stored in this uh database named as the scalar so here this this this success message uh actually refers that thing and the command is use a database name so scalar was the database which we created now uh this thing is done so let's recall our the categories right so there was a data definition language ddl and within that ddl we had the create command we had the drop command we had the alter command right so here what we are going to do we are going to create a employee table first we will create an employee table it will have three four attributes so let me show you that how we actually create a table in mysql so create the syntax is create table and then table name and within this small brackets we need to mention the comma separated column names and their data types so here what will happen first we will actually say there should be and column name as the employee id right and employee id that will be of integer type now there should be second column employee name right and here uh if anything is of a string type right or it will hold some kind of uh like uh characters so there is no as such data type named as a string but it is a like var car right varchar means it is uh representing the characters you can say okay or those values right a b c d e f d and other uh values which which comes under that uh character variables and employee name varchar and within that worker right after this worker we can create one parenthesis and we can define the length right this employee name will hold let's say the employee name uh can be of just 50 character that max so we can define here and there will be a column name as salary right salary let's say we are declaring it as a integer and we can do it as a int and last will be the uh department okay and here uh i am going to use department id only i am also uh like here i will also create some ids or here i will create one more table name as the department and i will show you like in later when i'll end up with most of the commands that why i used it so if you remember we were talking about the join operations right and in order to give you the example of join commands different type of joins i will be using that so that's why i'm here creating an uh column named as the department id and that will be also of the integer type okay so here you can see this syntax right column name it's data type comma another column name it's data type comma another column name it's data type comma another column name and its data type and after the comma we can give some integrity constraints as well so here first integrity constraint or the basic one is declaring the primary key which column we want to use as a primary key and here we know employee id is something here we know employed is something which we can uh basically declare as a primary key here right so after the comma we can use this constraint primary key and in the bracket we can actually mention this employee id right so that means uh this will be used as the primary key uh i'm just not sure whether this underscore should be used or not uh like whether it should be written like this or this but quickly let me check uh we will get the error if it is not like that so here salary integer department id primary key is there right and now semicolon and simply let's do it finally so it's created here right so how we actually created the table so create table keyword table name small brackets your column name its data type column name data type comma column name data type so on and at the end we can give different different kind of uh here you can say the constraints or here we can actually call out different different kind of you can say the uh integrity constraints we can apply here itself but these are the some thing which is related to the primary key related uh so here we have mentioned it in that way so the if you we want to actually create any column or we want to declare any column as a primary key we can do it in that way primary key keyword and bracket the column name which will be used as the primary key now if you remember the concept of primary key that means that cannot be duplicated in that particular table so if we are trying to insert any of the record which hold the value of primary key and that already exists with different record in the existing table that time we will get the error because it is violating the property of primary key so now our table is created next step would be to insert some data right to enter some data so here this create command we checked that part data definition language because we have created the structure now we will come to the data manipulation dml manipulation means we are manipulating some data or we are pushing something right so for that what we are going to do we are going to write the uh insert command that how we are going to insert the data in this particular table yeah so let's look at the insert command so the syntax is insert into and insert into the table name table name is employee and since here what we are going to do we are going to insert the all the values right so we can simply say insert into the table name we are going to insert values in all of the columns which are mentioned there could be multiple cases where you do not want to insert values for every column which is mentioned for few specific column there is a different syntax for that right writing the this insert command in that case uh in front of this employee table we need to mention those column names as well for which we are only going to insert the data but here our need is to insert the data for every column right one record will have the data for every column which is mentioned here so that means insert into employee so automatically it considered all the uh column names here then values right so within this value so here we need to follow the sequence as well right because this stable structure is a like well structure those columns are not randomly placed so the way or in the sequential way we just declared our variable or declared our column name in this table right we need to also pass the values in the similar fashion and if we want to just shuffle or reorder of the values in this insert command then we need to mention the column names in front of the employee as well so the sequence we will follow in front of this employee table name same sequence of values we need to provide in this values keyword so here the first value should be employee id right so let's say employee id one name that is of where i type let's say shashank now third column is basically the salary let's say 9000 right and now department id department id that means here for the simplicity you think there are five departments in that specific company one is id one is software one is finance one is the uh you can say the hr department and uh fifth is the basically operations department so we can assign simple simple ids to each of the department and that is we have done uh here so let's say department id one and later we will decide like which kind of the uh id we we will consider here right so for let's say software department we have assigned uh department id one and something like that so we'll look at in the later part so here we can see right query okay one row affected that means data has been inserted so quickly here uh let me try to show you that thing right let's say now this record has been already created this record has been inserted in the particular table okay now i was talking about this primary key constraint okay and if i try to insert the data with the same primary key and here let me just tweak or this value right let's say instead of shashank under score one so and let me just trigger it so duplicate entry one for key employee here we can see right this employee id is a primary key and that's why this error we are getting because the constraint or the property of primary key is that it cannot be duplicated that's why our database was also smart enough and since we actually uh described this thing in the beginning while we were creating the table structure that's why we can see this error here so now let me record or let me create another record let's say 8 000 and the employee name was let's say rahul and employee id was 2. so record inserted now let me create a third record and he was also in this one department id and his name was ankit and his employee id is three now let me insert one more record and he was working in department three and he was earning seventy five hundred and his name is anil and his employee id is four right so far we have insert four records all right so this is done like we have at least done one part or we performed one uh command in this dml one right now quickly i will show you or i will actually tell you uh the dql part the uh data query how we actually do this or basically querying the data okay so for that we simply remember select operation we need to do so let's quickly check out what is the syntax for that so select right select what we will be selecting from one specific table we will be selecting some column or all columns of it so let's say we want to display all the columns of one specific table on the output screen we can simply use this character star star represents all columns of that specific tables so select star from table name which is here employee so we can see this entire well structured data here employee one shashank rahul anki tunnel right so these are the four records we have inserted so now you also know how to actually use the select command and since star was there that means all the columns were selected now let's say we only want to display employee id and employee name column we don't want to display the salary in department id in our output so we can just simply mention comma separated column names and that's how we will be able to see this output here where only employee and employee name is here now since we have covered the select part as well i will quickly uh show you that how we were doing the uh basically update command and how we can even uh do the update command but after that i will first show you very very basic basic uh operations we were talking about right and after that that update command will make more sense because i will be using some filtering condition in that so these are the some basic things we have covered how to create a table create a database select the data inserting the data right and after that i talked about few of the basic operation let's say filtering condition using the where clause group by order by all right so now let me do that so first i will be working on the where clause so let's say what we want we want uh we basically want here the uh you can say all we from this input now we can see this data set right from this data set what we want uh we want to select all those records right or basically the details of those employees who are getting salary equals to 8 000 or greater than 8 000 right so let's do that so here what we will be doing that means we need to display the entire or all columns we can say select star from employee table where this is a simple condition like where salary greater than equals to like even in the programming languages these are something very very common thing right these logical operator conditional operator and same thing we will be using here in sql as well right because we need to perform this different different kind of operation so where salary greater than and equals to right or basically say greater than or equals to 8000 and if i mention this based on this input table or whatever data is stored in our table ideally we should get only these two records because these two records are only matching this condition not these two let's do that so here we got this output right now you simply know the how we actually apply the where clause all right so now this is done since now i have explained the where clause i can actually tell you how we were actually or how we can actually modify the values or update the values because see whenever we will be updating something on on a table right so there could be two cases um ideally we are overwriting the column value for any let's say specific column uh or we are trying to overwrite it we can do that right but there could be a situation where we just is specifically want to modify a value for a specific record right if you remember i explained that example for any employee we want to update the column value of the department name so here what we are going to do we are going to update the value right of uh employee who was rahul right and now his salary has been incremented from eight thousand to ten thousand now so uh let's say um how we will be actually doing it so for that we need to follow the update command so update this one like the syntax is update table name employee update table name here we will be reassigning something so for that we need to use this set keyword set salary like set value of salary column equals to 10 000 right so update employee table and within that employee table what we need to do we need to set salary equals to 10 000 right 10 000 where 10 000 where we can either use the employee id if we know it on upfront itself and we can even use the employee name so here i guess employee name is a perfect thing to use employee name equals to rahul right so here we can see query okay rows match that means whatever filter condition we applied where employee equals to double name that means our database or query was able to find one record in the database where the name was rahul and there what it did it changed the value of salary from 8000 to 10 000 but how we can verify we need to again run the select command right so here just look at this output and look at this one we stored earlier this one here value for the salary equals to 8 000 but now it has become the 10 000 right so i hope the update command is also clear so we have done the where closing we have done the insert updates now i was talking about the order by clause as well right so ordering let's say we we were using this uh here we are displaying this uh data right in any random order because right we can see the one order is simply employee ids and that is why because in this sequence we inserted the record but here let's say we want to display the output over the screen in the ascending order of salaries so how will we we will be doing it so here select star from employee simply add the clause order by and we can mention that which column we want to use for the ordering so here we will be using the salary column and we need to mention whether we want the values in ascending and descending so for that we can use this dsc d esc that means descending by default if we use the order by clause on any column it will be in the ascending order now let me just run it so here we can see this our output is completely arranged or ordered in the base of this salary column so 10 000 9075 and something right so this is done now we will talk about one more important operation that is the group by right so group by is something which we will be looking at now and if you remember i talked about grouping means let's say we know this is a set right again taking example of employee table there will be a software department i t department and any other department and if we want to just calculate the salary of those employees which lie in that specific particular kind of department we first need to group on that column and then perform the aggregation operations right so here we know like these even we can see right uh these two records like shashank and kit belong to same department and let's try to perform the same query here so here what we will be doing so select and we will be doing a group by on the department id right so here with the group by operation the catch is whatever column we will be using with the group by keyword only those can be used right in this final select column and apart from that if any column which were not the part of group by keyword that can only be used with the aggregation function right so here since we'll be doing our group by right first let me like let me type the later part so select we'll be doing some thing here from table name employee and we will be doing the group by base on the department id column right so here in the final output what we want if we will be doing the select star or anything obviously this select operation will fail because in with the whenever we will be doing the group by only the column which has been used in the group by keyword those will be the part of the select right of the output display apart from that whatever column we are going to use that will be or that has to be a part of any of the aggregation functions else we cannot use it so here what we wanted for every department we wanted to calculate the sum of their employee salaries so if we perform this some salary right that means for every department it will do the summation for department id 2 there is only one employee working so the total sum of salary will be 10 000 for the department three only one employee working anil and the total sum will be 75 hundred but for department id one there are two employees working and one employee is working uh earning nine thousand and another is earning seven thousand so nine plus seven sixteen thousand total we should get for uh like different different uh kind of uh departments so here one more thing i would like to highlight let's say uh in your table input table there is one column right and it has some weird name but when you are displaying it over the console or the output screen we can even provide it alias name any different name and with that alias name it will be displayed over the output so here we what we did we passed the salary column in the sum function so some function will add those numeric values together and here this output column will be named as the uh salary sum we can name it like that so whenever we are doing this way like as or this alternative name that means we have provided the alias name so let's do this quickly so here we can say this output right whatever we calculated perfectly we are getting it here so that's how this group by like there will be obviously so many logical and complex things as well in order to do with the group by operation when we talk about the analytical thing or as i was talking about the big data profiles where there is lot of lot of data analytics needed and advanced equal part will also be used there so now we are done with the group by operation as well and next uh we need to understand the join part right we talk about the join operation but before actually showing you the join right how the entire join operation different different joints are working first i would like to elaborate what are different type of joints available right and how that actually work and after that i will come back again on this console i will create a table with the department and we'll try to just demonstrate those different type of joins all right so now we will look at the different type of joins in the sequel and why there is a specific section for joins because honestly telling this is something a very very costliest operation in the entire uh big data systems as well or whenever like not only the big data if you're performing or you are doing some queries on a database which is containing multiple data sets right attributes from different data data sets then we somehow definitely need to join those data sets together and whenever it is about joining two data sets that is the costliest operation as well and that will take time things needs to be optimized we also need to take care what kind of join we are going to use based on our needs and based our use cases so that's why the joining is something which is the important concept and that's a different section for it so first definitely we will understand the joints from the theoretical perspective like when we write these sequel queries then how different different joints work and how this data will look like and after that i will also demonstrate same thing same type like how we actually join the data data sets together with the help of that demonstration using the mysql so let's look at that theoretical aspect first so uh joining again with the definition it's clear like just uh bringing two three data sets together based on some condition based on some columns right based on some matches right if you remember when i was previous slides when we talked about the key concept and the er diagram so there i told you right there will be a kind of key which is a primary key of one specific data set but then that can be referenced as a foreign key in another table and using those kind of key columns and anything we can simply uh do this uh join operations right so there are actually four type of joins we have so first is the inner join so in inner join what happens right let's say there were some records there one let's say m records in table one and m record in table uh two right and based on the foreign key concept let's say there will be a key which is a primary key of table two and that we have referenced in table one as well right because that was needed okay i will show you how that was needed i mean uh when i was talking about different operation i only created department id i didn't create the department table so when i'll explain that that will be quite clear to you so here you can see or you can say this is our department table okay and this is our employee table employee table obviously needs the information of employee department but here what we did we use the department id okay because department value can change later let's say today uh department name software and that's id is to let's say uh after few years we just finished that software department or we just removed that software department from that organization so that department id 2 can be assigned to something else let's say even sometimes we change information right how and why actually these kind of segregation is needed probably we will understand uh in the later part as well when when we will talk about the data normalization but on a higher level you can understand the difficulties we may face right so let's say there was one simple table and for every employee id we mentioned the employee department name right in in front of it and let's say there were 10 million or something like that data you had so in that case what will happen uh let's say there were 1 million employees who are working for the software department and after some days you change the department name to software inc right or software let's say software enablement something like that you change the value or right so in that case what will happen you need to go in your original table and in your original table you need to traverse or you need to find those one million records first and update the values with the help of update command obviously it's a something which shouldn't be entertained and you and it becomes a bottleneck when we are performing records in quite real time like multiple joins are like needs to be done right in in or multiple updates are happening in a real time something like that so that cannot be a thing which we can afford that's why we will segregate that kind of table right and here we segregated a department table and it has the department id column which has been referenced here so later if i want to pull the information or later if i want to pull the information of the department name for any employee i can use this department id because i know the department id of that particular employee i will join it with the department table using the department id column and i will bring that column simple the department name and that's what we have done so inner join is something right based on this vein diagram you can even understand so inner join there were some records in table one there were some records in table two so if values of those keys which we have used from table which will be on the left side and the table which will be on the right side if values are matched okay only those records will be picked as the output results apart from that everything will be discarded because there was no match for it apart from that everything else will be discarded because there was no match for it so here that is why only this middle part has been colored with the yellow because apart from that whatever was not able to matched we will just uh remove it or anything we are not going to consider it so that is the fundamental about the inner join next about the left join so in the left join we have the this table and the right table so in left join what will happen whatever records have been matched right from the table 1 and table 2 for the same values those will be pulled but all the records for the left table whatever we have used in the left side will also be present and in front of it whatever values of the right side table will be populated as null right there will not be any value for those columns which are coming from the right hand side table because there was no match found for those values right similarly this right join is a vice versa of left join in that case all the join which were matched that will be present but the records from the right table will only be present as a populated values but if there was no match with the left table so the the columns which are coming from the left side those will be populated as a null so in the full outer this is the last type so in full outer what happens everything like if match has happened those records will come together and left join will also come into the picture like those keys which were not like those keys which were present on the left side table but not right side table is still those well still those values still those values will come from the left hand side table and the right hand side column will be empty similarly those values which were present on the right hand side table and there was no match for those values in the left hand side table so the right hand side table columns will be populated for such keys but the left hand side columns will be populated as a null so this is the fundamental about the full outer join so these are the four important types of the joins in the sql and theoretical aspect i hope it is clear to you now i will quickly go back to the mysql console and there i will perform few of the queries in order to demonstrate these uh four type of joins all right so previously we saw different different operations uh on this table of employee name right in the database named as scalar so now we talked about the join operation and here now i will demonstrate these four type of joins in our left right and the outer join so first here in this table right if you can see this is our input table named as the employee and here i have employee id employee name salary and department id so first as i demonstrated i need to create a one more table as a named as department and i will use it for these join operations right so quickly let's create one more table create table table name will be department right and in the department table there will be only two columns department id which will be primary key as well so department id integer type and department name that will be of worker and length let's say can be 100 and again a constraint will be like i am going to use department isd as a primary key for department table and now since it is present in the employee table as well so here it will be called as a foreign key because this department has the primary key of a department table so department id should be the primary key here now the table has been created so quickly i will insert few record as well in this table and those records will be like let's say uh insert into [Music] department table and values will be let's say department one and that department one is for it okay we have inserted and there is another department let's say two and for that department name is software right now this is also done there is another department let's say department id 4 and that is named as let's say [Music] finance and there is one more department named as let's say ops department operations and there is one more department named as let's say hr hr department and the id is let's say eight all right so now data has been inserted into the department table if we quickly want to have a look at all the data which we have inserted in the department table we can quickly check right so now it is here so first example was to uh just perform the inner join inner join based on the condition or based on its technical aspect we know if there is a match for any given key value right whatever key we are using for the join condition if match has happened only those records will be there in the output table okay so here now we also know uh how our uh this table looks like this employee table and in the output what we actually want to do we want to uh just get this information let's say we know these two data sets are present for us we get we want to get the information let's say rahul and in which department he actually works only two columns we need to print so employee name we can get from the employee table but the department name we will be getting it from the department table and we need to join it so let's do that so select and here we need the employee name employee name comma we need the department name as well i will show you few things which i haven't write here but one by one so in the final projection we have selected these two columns from left side like whatever table we will be mentioning right that will be follow the sequencing of tables as well so from employee and what we want to do we want to do the inner join inner join with what kind of table the table name is the department on this is these are the like specific syntax and keywords to perform the join operation so first like from what will table will be on the left kind of join operation like the second table on means condition the condition we want to uh mention here okay so here uh how it is going to happen so what we want to use from the employee table we will use department id column right for a joining perspective perspective and from the department table we will also use the department id because in employee department id has been referenced as a foreign key so employee table name like in the on condition how we can access the column of different different tables table name dot the column name of that particular table so employee dot department id equals to department table dot department id so on that means this condition should be applied while matching the condition or while matching the records so the department id column has been used here and similarly how we are pulling these columns so from employee table i need like once the join is done give me employee name column from the employee table and department or department name column from the department table right so this is done let me run it all right so we got this information here right and how this would have done this is very straightforward right if you look at this table right here one two the department id one two four five eight right that is here but now what will happen here in this employee table we can see only records for department id one and two are present and here department id one is it two is software and there is one more employee who is working in department three and his name is anil but we didn't get any output for the anil here why because there was no match present so inner join is all about wherever the match has happened just give me those records that is the simple straightforward now let's uh actually make it more clear to you that how it will even look like so what i will do even from the department i will do this start like from the department to pick all the columns and from the employee pick all the columns okay so left from whatever is on the left side that means this is coming from the left table so employee id employee name so department id from the employee table matched with the department uh id of you can say the department table and that's how we are getting the code now let me quickly just change this inner join to the left join and if you remember in left to join if match has happened we will get that record but if there is any record which is on the left table and there is no match for that all the values will be there like will be present from the left hand side column but for the right hand side column those values will be populated as null so now let me change this inner to left right so here we can see now when we did the inner join we didn't get any output for the anil but now here although whatever matched happen whatever was match so that output we also got but here for the anil there is no right there is in in this department table right you can even see there is no entry for department id 3 that means that match didn't happen so at least these values will be present right in the output because these were populated on the left side but for that we didn't find any match so in the output these will be populated as the null so that is the concept of the left join from the left data is coming but if match if match was not there data from the right side is null now let's quickly check the right uh join operation as well like left join has happened so right join is again very simple to understand so here right what we are looking the output is bit different because in condition obviously match is being checked but the priority will be the right table not the left table because when we did the left join obviously the left hand side record was present here and for that corresponding right side values were populated null but when we did the right side operation so that means match is being checked from right to left side not the left to right side so for the left to right side when matched was checked so obviously uh for department one there was a match but when we started checking for this one right for this department id 4 there is no match available in the left hand side table that means we need to discard it similarly for 5s and similarly for it not discard means these left hand side values will be populated as null here right so this is as simple as that and uh that's how probably we can uh just check how these records will get joined together and how it will look like