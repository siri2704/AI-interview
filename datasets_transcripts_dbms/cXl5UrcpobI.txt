welcome to tech explained today uh we're diving into domain 8 our goal today is to unpack secure software development and databases right drawing from a couple of key resources you shared right think of it think of this as your personal guide to understanding these crucial areas right you know cutting through the jargon to get to what really matters yeah we'll explore how security becomes an integral part of building software from the ground up okay and then we'll dive into the world of databases looking at how they store and manage the information that powers our digital world right um one of the most striking takeaways right off the bat from these resources is this idea that security can't be an afterthought yeah definitely when you go through these materials it really hits you that it's not a separate feature you just tack on at the end it's got to be baked into every single step yeah yeah absolutely it's about ensuring that the applications we build um they can be trusted to protect that data right the confidentiality the integrity the availability the data that's the core of any secure system okay so let's dig into this whole baking in security concept a bit more sure one thing that really stuck out to me was how often security requirements are labeled as nonfunctional yeah yeah it's almost as if they're seen as these optional extras it's like saying "well the house looks great who needs a lock on the door?" exactly and of course you know when budgets get tight or deadlines loom which let's be honest they always do these nonfunctional requirements are often the first to go they're seen as expendable it's pennywise and pound foolish because the resources make it crystal clear that trying to add security later on to retrofit it is way more expensive and far less effective than building it in from the beginning think of it like trying to replace the foundation of a skyscraper after it's already built yeah a massive undertaking not to mention risky huge risk so if we think about the entire lifespan of a system what's called the system life cycle or slc it covers everything it really does from that initial idea the spark all the way to its retirement and disposal wow and within that big picture of the slc we have the software development life cycle or sdlc that's right focusing specifically on those development stages got it and why is that distinction important because security concerns shouldn't just pop up during coding within that stlc it needs to be a guiding principle throughout the entire slc from the very first plan to you know how you get rid of that system and all its data so let's unpack the sdlc where do we even begin well it all starts with a plan right right plan and management approval phase we figure out the goals the objectives what problem are we trying to solve here what outcomes do we want we also start thinking about highle cost estimates at this point makes sense and probably the most important thing getting management to say yes let's do this the green light it's the foundation the very first step that sets the direction for everything else it makes you think though going back to your sources how often do organizations really spell out their security objectives at this early stage that's a good point the material suggests it might not be as common as we'd like which can lead to problems down the road absolutely if security isn't a core objective from the get-go it's a struggle to prioritize it later after planning it's all about requirements right exactly here's where we get into the nitty-gritty what do the users actually need this system to do what kind of data are we dealing with how does it fit into existing business processes we gather all that validate it and turn it into a detailed set of requirements this is where that abstract idea starts to take shape okay so at this requirement stage security requirements also need to be treated just like any other functional requirement absolutely and they need to be specific not just some vague statement like the system should be secure yeah be more secure no we need clear measurable targets for example instead of saying user data must be protected a much better requirement would be all personally identifiable information or pii must be encrypted at rest using aes 256 encryption and in transit using tls 1.3 so being super specific about the how right that gives clear guidance for the design and development teams later on okay i'm with you and from those very specific requirements we move into architecture and design that's it we're taking those needs and turning them into the blueprint for the system the system's dna exactly detailed design documents outlining the architecture the security controls even things like screen layouts so it's all about defining how the system will function and crucially how it'll be secured spot on this is where security starts to become real you're going from abstract requirements to concrete mechanisms technologies even architectural choices okay so that brings us to the development phase this is where the actual coding happens the rubber meets the road and from the resources it looks like there are several different methodologies teams can use right right one that's mentioned is the waterfall model yeah the classic it's described as a linear sequential approach you plan everything out in detail then you define all the requirements then you build the entire system followed by testing and finally the big release and the key thing with waterfall is that you can't really easily go back to a previous phase like if you miss a crucial requirement halfway through a two-year project you're stuck pretty much you have to see it through then address that missed requirement in the next cycle it's like water flowing downhill it only goes one way sounds pretty rigid it can be waterfall works best for projects with very stable clearly defined requirements where you don't expect many changes right because the world never changes right well in some cases it might not okay but for those situations where things do change which is most of the time we have the agile approach yeah agile is all about adapting to change so it follows those same basic phases as waterfall plan define build test release but instead of doing them in a massive linear sequence agile breaks them down into short cycles usually about two weeks each called sprints ah so you're constantly cycling through getting feedback making adjustments as you go exactly it's perfect for projects where you expect those requirements to change where you want to try out new ideas quickly and where it's okay to fail fast but fail within those contained sprints and how does that play into security well think about it those early frequent feedback loops mean security issues can be caught much earlier two weeks instead of two years down the line precisely agile also brings in this role of the scrum master what exactly do they do the scrum master is like a facilitator for the team not a manager not in the traditional sense they're more like a coach making sure the team is communicating well working effectively and removing any obstacles that might slow them down and are security concerns part of those obstacles absolutely a good scrum master will make sure security is a regular topic of discussion and is addressed in each sprint okay so we've got waterfall and agile what's next devops this one is all about speed and efficiency how so it combines development quality assessment and it operations into one streamlined process streamlined for what to shorten the development life cycle we're talking daily releases of new code or features sometimes even more frequent wow that's fast how do they manage that devops heavily relies on automation practices like continuous integration where code changes are constantly merged into a central repository and continuous delivery where those changes are automatically prepped for release makes sense now this brings us to an interesting point sec devops how do you integrate security into this super fast devops world that's the challenge right you have this need for speed and agility and traditionally security practices have been seen as slowing things down yeah like that whole separation of duties thing exactly but with sec devops it's about finding that balance it's about shifting security left integrating it early and continuously we're talking strong collaboration between development and security teams adopting secure coding practices and using automated security testing throughout got it so we've gone through planning requirements architecture development what's next in the sdlc testing and i can't stress enough how important it is to test throughout the entire life cycle not just at the end no we're talking validating requirements reviewing designs unit testing interface testing integration testing and even system testing wa a lot of testing it's essential and we can't forget about testing during operation as well okay one specific testing technique that came up was canary deployments what are those all about think of it like a canary in a coal mine you release new features to a small group of users first like a test group exactly it's an early warning system to see if anything breaks before you release it to everyone smart minimize the damage if something goes wrong that's the idea so after all that testing we move on to certification and accreditation yes and remember the evaluation criteria we talked about in domain 3 vaguely all right so certification is a technical analysis of an it solution it's making sure it meets those security requirements and in the sdlc this fits under the testing phase okay the techy stuff right accreditation on the other hand is the official management sign off on that certification so the bosses say "okay we accept the risk for a specific period." yes and this usually falls under the deployment phase makes sense so once a system is certified and accredited we're ready for deployment right that's right we're moving it into the live environment it's go time and this requires careful planning too secure configuration of the environment access controls robust monitoring these are all crucial during deployment all right so now the system is up and running we're in the operation phase of the slc and security is still vital here continuous monitoring regular security assessments applying patches having incident response procedures these need to be ongoing activities can't just set it and forget it definitely not systems need to be actively managed and protected throughout their operational life finally we reach the disposal phase it seems like this stage often gets overlooked it does but it's critical when a system is retired or replaced you need to think about migrating data archiving what needs to be kept and securely destroying what doesn't especially with all the data privacy regulations these days right improper disposal can lead to serious breaches it's not just deleting files sometimes it means physically destroying storage media to ensure that data is truly gone okay so we've covered the entire slc let's shift gears a bit and talk about maturity models right your sources describe them as tools for evaluating and benchmarking organizational processes how well defined are they how consistently are they applied and there's this common fivelevel model yeah what's that all about level one initial is basically controlled chaos no real defined processes as organizations mature they move through level two repeatable where there are basic processes but maybe not well documented right then level three defined where processes are documented and standardized got it level four managed where those processes are measured and monitored so you're tracking how well they're working exactly and finally level five optimized where the focus is on continuous improvement sounds like a lot of work to get to that top level it is and honestly it's not always practical or even necessary for every organization makes sense so it's more about using this model as a benchmark for improvement that's the key takeaway okay let's move on to something a bit more technical application programming interfaces or apis ah yes apis the glue that holds the internet together really well they're definitely essential they're what allows different applications to communicate with each other give me an example say you're using an app on your phone to book a flight that app is likely using an api to talk to the airline servers retrieve flight information and make the booking so it's like a messenger between applications exactly and the great thing about apis is that they let developers reuse complex functionalities without having to write all the code from scratch every time saves a lot of time and effort a huge amount now there are different ways to build apis two common ones are rest and soap okay tell me about those rest or representational state transfer is the most popular right now it's known for being lightweight and fast so good for web applications perfect for them soap on the other hand is more traditional but more complex but offers a wider range of features the horses for courses exactly and of course security is a big consideration with apis as well how so we need to make sure that applications are authenticating themselves properly that they're only authorized to perform certain actions and that the api itself is protected against common web application vulnerabilities just like with any other software okay let's talk about something a little bit more obscure code obfusation what is that imagine you have this valuable source code right you want to make it really hard for someone to reverse engineer it to understand how it works like protecting your secret recipe exactly yeah so you use code obfuscation to transform that code into something that's much harder for humans to read and understand while still allowing the computer to execute it so it's still functional just harder to decipher exactly and there are different ways to obuscate code you can change the formatting rename variables to meaningless names even make the programs logic more convoluted it's like scrambling a message that's a good analogy okay so that's code obuscation what about acquiring software securely this is all about ensuring that the software you bring into your organization whether it's customuilt or off the shelf is free from vulnerabilities and will function as intended so you're not introducing any new security risks exactly and a big part of that is assessing the security practices of your software vendors do they follow secure coding principles do they have a good track record and contracts and slas's come into play here right absolutely that can be used to define specific security controls that the vendor must have in place as well as mechanisms for monitoring and reporting on their effectiveness it's like having a security checklist for your vendors exactly now let's dive into some of the common software security weaknesses and vulnerabilities all right let's get specific first up we have buffer overflows explain those to me imagine you have a container a buffer in memory okay and you try to pour more data into it than it can hold what happens that excess data spills over potentially overwriting important information or even code nearby and that can be exploited by an attacker absolutely they could potentially inject their own malicious code how do you prevent that through techniques like parameter and bounds checking making sure you never write more data than a buffer can handle okay so you're being careful about how much you're putting in right and there's also aslr address space layout randomization it randomizes where things are stored in memory making it harder for attackers to target specific locations like shuffling a deck of cards exactly next up we have sql injection now we've touched on this before yeah a classic and unfortunately still very relevant attack it's where an attacker inserts malicious sql code into a web application and that code then gets passed on to the database and if the application isn't careful that malicious code could allow the attacker to control the database steal data modify data delete data bad news very bad news and how do we prevent this rigorous input validation never trust user input you need to carefully check and sanitize any data that's coming from an external source before using it in a sql query okay so you're essentially filtering out anything that looks suspicious exactly moving on we have cross-sight scripting or xs another common web application vulnerability this one involves injecting malicious scripts usually javascript into web pages that are viewed by other users and when those users load the page the attacker script gets executed in their browser so it's targeting the user's browser directly that's the goal it could be used to steal information redirect users to malicious websites or even take control of their accounts and there are different types of xss attacks right yes there's stored xss where the malicious script is prominently stored on the server and reflected xss where it's injected into a request and then reflected back to the user okay now xss targets the browser what about cross-sight request forgery or csrf csrf is a bit different this one targets the web application itself how so the attacker tricks a user into sending a malicious request to the web application without the user even knowing exactly it often exploits the trust that the application has in the user's browser so the application thinks the request is coming from a legitimate user and carries it out right it could be something like changing an email address transferring funds or even making purchases without the user's authorization sneaky very sneaky next on our list covert channels what are those these are unintended communication pathways that can be used to leak information like a hidden tunnel kind of it could be something as simple as one process modifying a file in a specific way to signal information to another process ah so it's not using the intended communication channel right it's exploiting something else something that might not even be obvious and these are hard to detect i imagine very hard and even harder to eliminate completely okay what about back doors or trap doors these are intentional entry points that are put into a system to bypass security controls so someone intentionally creates a way to get in without going through the front door exactly it could be a developer who puts it in during development or an attacker who exploits a vulnerability to insert a back door later on and that gives them persistent access i assume most likely they can come and go as they please without having to authenticate each time definitely a major security risk a huge risk memory reuse what's that all about it has to do with how memory is managed when an application finishes using a portion of memory it releases it back to the operating system okay but sometimes that memory might still contain sensitive data from the previous application so like leaving your notes behind in a classroom kind of and if the operating system doesn't properly clear that memory before giving it to another application that second application might be able to access the old data exactly it's like finding someone else's diary not good not good at all what about toco or race conditions this is a bit tricky imagine an application checks the state of a resource like a file before it uses it but between the check and the use the state of that resource changes and the application is using outdated information exactly an attacker could potentially exploit this by manipulating the resource in that small window of time so it's a race against time exactly finally we have citizen developers what's that all about this is a growing trend where business users are creating their own applications using these new low code or no code development tools so they don't need traditional programming skills right which can be great for empowering users and driving innovation nice there's always a butt these citizen developers often lack formal training in secure coding practices so their applications might have vulnerabilities exactly it's important for organizations to provide guidance and oversight to ensure those applications are secure okay so we've talked about a lot of vulnerabilities let's switch gears again and talk about some secure programming techniques right one that keeps coming up is input validation the cornerstone of secure coding it's about making sure that any data that enters an application especially from external sources is what you expect it to be right you need to check both the format and the actual values of the data so you're essentially filtering out anything that's malformed or potentially malicious exactly another important technique is session management this is all about managing a user's interaction with an application after they've logged in so it's keeping their session secure that's the goal things like preventing multiple loginins using strong session ids enforcing timeouts and using screen savers to automatically log out inactive users okay so you're making it harder for someone to hijack a user's session exactly and finally we have poly instantiation this one sounds a bit more complicated it is it's a technique that allows different versions of the same data to exist at different security levels give me an example say you have a database with confidential and secret information a user with confidential clearance might see a record with certain information while a user with secret clearance would see a different version of that same record with more sensitive information so it's like showing different views of the same data based on the user's clearance level exactly it helps prevent unauthorized inference okay now your sources also briefly mention maintaining software and operation right keeping those systems secure over time they mention sem tools what are those sem stands for software configuration management these tools are used to track and control changes to software code so you have a record of every modification exactly it's important for accountability and for being able to roll back to previous versions if necessary and they also mentioned sr software sr stands for security orchestration automation and response what does that do it helps automate a lot of the tasks involved in security operations things like threat and vulnerability management incident response and security policy enforcement so it's like having a security robot that helps you manage things kind of it takes care of a lot of the repetitive tasks freeing up security teams to focus on more strategic work okay let's move on to our final topic databases what exactly is a database in the simplest terms it's an organized collection of data usually structured in tables with rows and columns like a spreadsheet similar but much more powerful we're mainly talking about relational databases here where data in different tables can be linked together based on defined relationships okay so it's all about organizing and connecting data right and that makes it really efficient to store access and analyze large amounts of information and at the heart of any database system is the database management system or dbms the dbms is the software that lets you interact with and control the database it handles all the underlying technical stuff like a database operating system you could think of it that way now the resources break down a dbms into several key components okay what are those first you have the hardware the physical servers that store and process the data right then there's the software the operating system and the ddms software itself like my sql or oracle exactly and then you have the database itself which can contain one or more tables okay each table is structured into rows which represent individual records and columns which hold specific pieces of information about those records makes sense and then you have primary keys which uniquely identify each row and foreign keys which link data in one table to another so it's all about relationships exactly and the language we use to talk to the dbms is usually sql or structured query language the language of databases you got it and of course we have the users the people or applications that use the database and the data itself the information stored within okay so that's the anatomy of a dbms now what about maintaining the integrity of data data integrity is absolutely crucial if the data in a database is inaccurate or inconsistent it's basically useless right so databases have a lot of mechanisms to make sure the data stays accurate like what one challenge is concurrency multiple users or applications might be trying to access and modify data at the same time leading to conflicts exactly so databases use locks to prevent one transaction from interfering with another so only one person can change piece of data at a time that's the idea and then there are the acid properties what are those all about acid stands for atomicity consistency isolation and durability okay break those down for me atomicity means that a transaction is treated as a single unit either all the changes happen or none of them do okay consistency ensures that any changes maintain the integrity of the data so no invalid data gets in right isolation means that transactions are isolated from each other so they don't interfere like separate workspaces exactly and durability means that once a transaction is committed those changes are permanent they're saved for good even if the system crashes wow those are some powerful properties they are the foundation of reliable database operations and finally we come back to sql injection this vulnerability just keeps popping up it's a persistent threat and it highlights how important it is to secure not just the database itself but also the applications that interact with it right because a vulnerability in an application can give an attacker a backdoor into the database exactly so as we wrap up this deep dive into secure software development and database security what are your main takeaways well i think the biggest one is that security can't be an afterthought it's got to be a part of the process from day one from that initial plan through all the development phases and even into operation and disposal and the second big takeaway is that secure software development and database security are deeply interconnected you can't have one without the other right if you have vulnerabilities in your applications your database is at risk and if your database isn't secure your applications are vulnerable it's like building a house you need a strong foundation secure walls and a good roof to protect everything inside exactly and just like you wouldn't build a house without locks and security systems you shouldn't build software without considering security at every step and as our reliance on software and data continues to grow these principles are becoming more and more important it's not just about protecting organizations anymore it's about protecting individuals and society as a whole exactly so as you continue to explore this domain think about how you can apply these concepts in your own work whether you're a developer a security professional or just someone who uses technology every day because understanding these principles can help you make informed decisions and stay ahead of the ever evolving security landscape that's a great point to end on thanks for taking this deep dive with me you got it until next time