[Music] thank you [Music] Hello friends welcome back to our channel so in today's session we'll discuss about one more important Concept in dbms that is a normalization so this is a very important concept and before watching this video so just please visit our previous videos about the functional dependency concept because so if you know that functional dependency concept it would be very easy for you to understand this normalization process so in the previous sessions we have discussed about the functional dependency and the types of functional dependencies the attribute closures and how to find the candidate key and super Keys using the functional dependencies so I'll post the link in the description the playlist Link in the description so just go through that one and after that you can watch this normalization concept definitely it will be very easy for you to understand this one now uh first let us know what exactly this normalization right so this normalization is a single term so we can say it is a single term that is optimizing optimizing relations optimizing the relations so here the relation means table right so optimizing the relations means so just we are optimizing the tables optimizing the tables so why we are optimizing these tables right so in order to avoid the redundancy avoid the redundancy so why why we are moving towards this normalization right so there are some drawbacks in our table schema structure so we can avoid that drawbacks so what are the drawbacks means the first one avoid the redundancy so the table May consist of redundancy that means a duplicating duplication of data so we we have to remove the duplication of data at the same time we have studied about the anomalies anomalies right inside anomaly delete anomaly and update anomaly so these are the floss floss in the table schema so we have to avoid these anomalies okay so in order to avoid the redundancy and anomalies so one solution one solution is to op optimize optimize the tables Optimizer tables or relations so how we can optimize this optimization can be done with decomposition decomposition so the table can be decomposed into subtables so relation will be decomposed into some relations sub relations and this process is known as a normalization this process is known as a normalization and this process will be done in different phases in different phases so the first one one NF which we call it as a first normal form first normal form and the next one 2nf which is a second normal form second normal form so how we can achieve that relation into this first normal form and second normal form we'll see later so the next one is a three and F third normal form kind of next one is a b c n f voice code normal form the next one is 4 NF which is a fourth normal form and last one is a 5 NF which is a fifth normal form fifth normal form so by using all these things we can achieve them normalization which we can achieve the normalization right so 1 f 2 n f three enough DC and F 4 NF and 500 so if you achieve up to bcnf we can say the schema the schema is good or we can say the database is a good design a database is a good design right so if you want to know whether the relation is in 2 and F the automatically the relation should be in one NF then only we have to go with the 2nm so if you want to check whether the relation is in 3 and F the first it should satisfy the 200 then only it should be in 3M and if you if you if the relation is in BC enough that that implies the relation satisfies with the three and then right so what I mean elaborate this one so how the relation can be in a first line of 1 and F how the relation can be in 2nf how the relation can be in 3 n f b c and a four n f n 500 so let us see the introduction and we will elaborate each and every normal form in our next sessions so initially let us assume that so I'm normalized data unnormalized data so unnormalized data means a single table consists of all the attributes only one table with all other attributes so this will be coming to the 1nf 1 and F only after removing repeating groups repeating groups so if you in the table if any one of the attribute is having a multiple values so then we have to remove all those repeating values okay so after that after removing all the repeating groups these unorialized data will be 1 and F will be in 1 error so if our relation does not have any repeating groups then simply we can say the relation is in 1 and F and coming to the 2ndf 2 NF so after 1 and F so we need to find the partial functional dependency so in the types of functional dependencies we have discussed about the fully functional dependency and the partial for functional dependency so we have to identify the partial functional dependencies are available or not if so we have to remove those partial functional dependencies so remove partial dependency so after removing the partial dependency we can say the relation is in 2 NF and before removing the partial dependency first the relation should be in 1 and F then only we have to remove the partial dependency then only the relation will be in 12 and after that 3 and F so once the relation is in 2nf so we can check for the condition of 3 NF right so without the relation is into NF we can't go for the 300. so first the relation should be into an F then only we have to check for 3 NF so after 2nf there will be no repeating groups there will be no partial dependencies and next here we need to find the whether there are any trendancies or not so in the previous sessions in the functional dependencies we have seen about the trivial non-trivial and functional transitive transitive dependencies so here we need to find whether there are any transitive relationship that means transitive dependencies so if so we have to remove those transitive dependencies then only the relation will be in 3 and F so identify and remove remove transitive dependency remove transitive dependency once you remove the transitive dependency automatically the debt the relation will be in 3 and F so after that bcnf bcnf so once if you want to check this bcnf make sure that the relation is in 3nf so otherwise we have we should not go for the bcnf so if the relation is not in 3nf check for the 2nf so if if the relation is not in two NF check for one NF right so because for checking for 2nf the relation should be in one unit the relation should be in one NF then only we have to check for 2nf so in order to check 3 and F the relation should be into NF if in order to check for BC and F the relation should be in tnf and here so if you want if you want to check for BC enough make sure that the dependencies there are no repeating groups in our attributes there are no functional dependencies in our functional dependency there are no transitive dependencies in our functional dependencies and here make sure that make sure determinants determinants are candidate key dependent determinants are candidates determinants means the LHS LHS in functional dependency okay lhsin functional dependent for example if the function dependencies extends to Y so this is the determinant and this will be the dependent right so this LHS should be a candid key make sure the determinants are a candidate case right so once it was done the relation is in bcnf so if the relation is in B C and F we can tell that the database design is a good design okay so after that still there will be a chance of having the redundancy even though the database design is good and the relation is in pcnf there might be a chance that a table consists of the relation consists of a redundancy okay so still we have we can normalize it so that is a 4 n f 4 n f so here we need to find whether the functional dependencies are having any multi-value dependencies that's also one type of functional dependency so is there are any functional multi value dependencies are there so if so we have to remove those multi-value dependencies so remove multi-valued dependency multi-value dependencies okay okay so after removing the multi value dependencies we can say that the relation is in 4 NF so if the relation is 4 NF definitely the relation will be in bcnf if the relation is bcnf we can say the relation is in 300. so foreign afterwards the next one is 5 and F the fifth normal form so we need to identify the joint dependencies if there are any joint dependencies so if so we have to remove the joint dependencies so here remove all the joint dependencies right joint dependencies after removing the joint dependencies we can say the relation is in 5 NF 500 fifth normal form fifth normal form right so this is the process of normalization so first we have to consider the unnormalized data okay so in that we have to identify and we have to remove all the repeating groups so that it will be converted into I mean it satisfies the 1 and of one and a normal form the first normal form and from that we have to remove the partial dependencies so that it will be in 2nf and after that we have to remove the transitive dependencies so it will be in 3 NS and make sure that determinants are candid case so it will be in bcnf so bcnf is somewhat strong than the 3nf right both are almost similar but it is somewhat strong for DC and then so if any relation satisfies up to the B C and F we can say the database design is a good design okay still there might be a chance of having the redundancy so we're moving to the four and F and 5nf by removing the multi-value dependencies and removing the joint dependencies right and once again I'm repeating this normalization process is mainly used to optimize the table table schema okay the structure of a table so why we are moving why we are optimizing means there might be a chance of having the redundancy and the anomalies so in the previous session we have discussed about the anomalies so Inception anomaly updation anomaly and deletion anomalies so those are the flaws okay floss in the table design relation design so we have in order to avoid those two things that means a redundancy that means a duplicate data as well as the anomalies problem so we are moving towards the normalization it will be uh done in the different phases that is a one enough to end of three and a b c enough at four and a friend 500 so in our next session we'll start with the 1nf right so we will go in detail individually from the next sessions so hope you understood this one so once again I'm saying so just go through the previous sessions the topics of functional dependency the types of functional dependency axioms and finding the candid key and super Keys using the functional dependencies so I'll post the playlist Link in the description so go through that afterwards just visit this normalization process so that it will be very easy for you to understand this normalization process because all these are the different types of dependencies only right so let's drop here so if you are having any doubts regarding this one feel free to post your notes in the comment section definitely I will try to clarify all your notes and if you really enjoyed my session like my session share my session with your friends and don't forget to subscribe to our Channel thanks for watching thank you very much