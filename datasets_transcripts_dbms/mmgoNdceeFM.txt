hello everyone welcome back to my YouTube channel we are learning database management system in this video series and today we are going to discuss unit five of dbms which is query processing and optimization so you will be able to connect the dots very easily the topics which we will be covering in this video are the steps in query processing measures of query cost selection operation evaluation of Expressions query optimization transformational of relational expressions and sorting and join let's get started with our first topic which is steps in query processing so first you will give an input which means for exsite RO number okay to fetch the output which is nothing but result so steps involved in database that we're going to understand today majorly there are three steps in query processing the first step is parser and translator second step is usually optimizing so optimizer and third step is execution through this diagram imagine you have put a query as an input in the database high level language high level language what SQL query in the first step which is parsel and translator parsel will check the syntax of the query and verifies attribute name relation name table and attribute name translator will translate the query into its relational algebraic form it is very important that high level language Al expression formater project operator all of that then expression optim expression Optimizer best algebraic expression choose on the basis of low cost low cost low time timey generate it will choose that datet the data about the data which we have studied in unit one metad information evaluation engine which will evaluate the data from the database and fetch the data and generate the query output again it will execute the query evaluation plan and Returns the output so is Loop so I repeat again the first step will be checking the syntax and translating it into the relational algebraic expression which is the lowlevel format then it will optimize the best algebraic expression and then it will execute according to that execution plan now since we discussed query cost let's understand what are the measures of query cost and what is query cost so cost is generally measured as the total time required to execute a statement or a query time on the basis of that the cost is decided the factors that contribute to the time cost are the disk access the time to process a data request and retrieve the required data from the storage device CPU time to execute a query and network communication cost conditions total time generate which is nothing but the query cost disk access is the predominant which is the major cause since the disk access is slow as compared to in memory operation cost to write a block is greater than the cost to read a block because data is read back after being written to ensure that the right was successful so right block usually has a more cost now let's understand the selection operation over here selection oper operator already operators if you remember it selects the from the relation and satisfy a given Condition it's name we want to display all the students belongs to C Branch to Sigma Branch equal condition and the name of the relation the name of the table student and this will generate the following output now let's understand the search algorithm for selection operator there are two search algorithm one is linear search and binary search so one by one linear search it scans each blocks and test all record to see whether they satisfy the selection condition or not for an example in this we have record number two 1 3 5 6 8 2 four number so by one is 2 equal to 6 no then it will go to the next one and check is 1 = 6 no it's not then it will go to the next one it will check 3 equal to 6 or not element to satisfy the selection condition so the cost of linear search worst case is equals to br br denotes the number of blocks containing records from relation R blocks to reach that relation R if the selection condition is there on the primary key attribute then system can stop searching if the required record is found primary if the selection is on non primary attribute then multiple block may contain required records and the cost of scanning such blocks need to be added to the cost estimate so linear search can be applied regardless of the selection condition or ordering of the records in the file this algorithm is slower than the binary search algorithm because one by one each record andom records it has to be in a sequence that is not necessary in this however still it is slower because it is checking one by one each block binary search this algorithm is used if selection is in equality comparison on the primary key attribute file relation is ordered sorted on the primary key attribute AR which has to be in a sequence sequence 1 2 3 4 5 6 8 even if one of the element is missing it's fine but it has to be in a sequence it can be either ascending order descending order cost of a binary search is log two of v v again denotes the number of blocks containing records from relation R and this algorithm is faster than the linear search algorithm faster 0 1 2 3 4 5 and six index so what it will do ler middle lower upper so 0 + 6 / 2 so that is 6 / 2 now it will check this side of the list again Lower upper bound divid find out and mid find out again and that is 6al satisfy and that's why this will be much faster one by one each block check rather lower and upper is iter or less elete and then again find out now evaluation of Expressions expression may contain more than one operation solving expression will be difficult if it contains more than one operation so if you see this expression Ty different operations to evaluate such expression we need to evaluate each operations one by one in appropriate order two methods for evaluating an expression carrying multiple operations are materialization and pipelining bottom to top approach use first we have solved this then this condition and this project operator as the last materialization and pipeline so materialization evaluates the expression tree of the relational Al jebra operation from the bottom and performs the innermost or Leaf level operations first bottom say and innermost expression first solve the intermediate result of each operation is materialized which means stored in the temporary relation and becomes input for subsequent next operation the cost of materialization is the sum of the individual operation individual operation sum plus the cost of writing the intermediate results to the disk and the problem with materialization is that it creates a lot of temporary relation it performs a lot of iio operations for an example and then again and then and then final result generate it creates lot of temporary relation and that will require lot of space Also Al and lot of time as well now let's understand pipelining in pipelining operations form a que and results are passed from one operation to another as they are calculated to reduce the number of intermediary temporary relation we pass the result of one operation to the next operation in the pipelines combining operations into a pipeline eliminates the cost of reading and writing temporary relation temporary relation answer directly pass on to the next relation pipelines can be executed in two ways demand driven and producer driven demand driven is system makes repeated request for tles from the operation at the top of the pipeline say request in the producer operations do not wait for the request to produce tles but generate the tles eagerly one by one next so these are two types of pipelines driven operations so to Summit up the pipelining it will execute this query first the result will get passed on to the next query in the pipeline and this will get operated first and then again the result will get passed on to the next query in a pipeline so method query temporary relation temporary memory so reading and writing at time again gets decreased so that's why pipelining is the better method over a materialization now let's go to the next concept which is query optimization is it is a process of selecting the most efficient query evaluation plan from the available possible plans Expressions generate the process of selecting the best one out of it will be a process of query optimization let's take an example over here we want to display the name of the customers J balance is less than 2,500 there are two plans over here so the difference in both the queries is the plan of evaluating that query both the queries have a different evaluation plan over here this record gives the six records and this gives the eight records what is the better plan over here because we solve the condition first and then the join operation over here we're doing the join operation first and then the condition so this becomes my efficient plan because this gives me data in a less amount of time and the accurate data there are multiple approaches to query optimization the first one would be exhaustive search optimization it generates all possible query plans and then the best plan is selected it provides the best solution that we generate all the plans and select the best one out of it euristic based optimization urtic based optimization use a rule based optimization approaches for query optimization it performs select and project operation before the join operation like we did in the last one this is done by moving the select and project operations down the query tree this red reduces the number of tles available for join avoid the cross product operation because they result in very large side intermediate tables cross product operations say generate a lot of query tables this algorithm do not necessarily produce the best query plan but it is the efficient one now let's understand the next topic which is transformation of relational Expressions two relational algebra expression are said to be equivalent if the two expressions generate the same set of tles example would be customer table is there and account table is there in this there are three attributes in this there are two attributes but however the number of tuppers in both of them are same first query is this and the second query is this if both of them giving me the output result same then this is said to be equivalent expressions what is the difference between both of this over here the join operation is getting the priority and over here we're giving priority to the select operator first but both results in the same output so it means both the queries are equivalent to each other combined selection operation can be divided into sequence or of individual selection this transformation is called as cascet of of Select operator understand this by an example there's a customer table over here with a customer ID account number name balance as an attributes there are two queries over here look at the differences here we select the account number which is less than three and balance less than 2,000 of the customer table the second query also says the same thing that select account number which is less than three instead of add we have put this in a separate bracket with select operator balance less than 2,000 of the customer table so which is the better way this is the better way as we have divided individual select op operations one by one and this transformation is called as Cascade however both are going to generate the same output so if you look at over here the first query and the second query of the expression and the first query and the second query over here are inside the bracket so which is the better way this is the better way by using the and operator selection operations are commutated let's understand this by an example it's the same table however different queries over here that let's select account number which is less than three in the bracket the second query which we saw in the last slide select balance less than 2,000 from the customer table if I compare that with another query then I will definitely select this one over here if you see balance less than 2,000 and in the bracket I have put the account number less than three so this is my primary key attribute that has to be outside so so that will require a less amount of time for me to execute that query we can say that this expression is more more commutative over here but here if we see project operator with the name project operator with the account number name and customer not required we can directly do that project operation name from the customer both are going to generate the same output selection operation can be joined with cartisian product and Theta join customer Table and there is a account table if I select the account number less than three and customer joined with the account table or customer table joined with the account number less than three with the select operator condition from the account both the ways are going to generate the same result operations are also commutative we can understand by this example that account natural join with the account number less than three from the customer or if this way if I use customer natural join with select operator account number less than three from the account table again this will also give me the same result so we can say that natural join operation are associative why because the order of the operation does not really affect the output of the expression the result of this will be equal to the result of this selection operation distribute over a Theta join operation under the following condition that when all the attributes in the selection condition Theta 0 involves only the attributes of one of the Expressions says E1 being joined is also equal that Theta 0 can belong to E1 and join with Theta E2 also so when the selection condition Theta 1 involves only the attributes of E1 and Theta 2 involves only the attributes of E2 which means the expression two in this case we can say that Theta 1 and Theta 2 with expression one and Theta Expression 2 can be joined and this is exactly equals to select operator with Theta 1 expression one joined with Theta and over here we can put Theta 2 with the expression 2 this will be more easily understandable with an example set operations Union and intersections are commutative now the set operations like Union intersection are commutative because the order of each any of them does not really change the result if we see over here customer Union employee or employee Union customer will give me the same result in the intersection also same thing customer intersecting with employee table or employee table inter acting with customer will produce again the same output however if you do the same thing with the third operation which is the difference the minus operation in that the set difference is not commutative set operations Union and intersection are also associative if we can see customer Union with employee table and that entire thing Union with the student table will give the same result exactly if we do that customer Union employee union student so this means it also says the order in which if I group the operation does not really change my final result over here also if I group this operation first and then this operation or if I do the vice versa customer intersecting first and then employee intersecting with student it will not change my result that will be same selection operation distributes over Union and intersection and minus selection operation distributes over Union intersection and minus so I have given over here three summarizing statement you can take a look at it or take a screenshot of this also for a better understanding or a quick overview let's understand the next topic which is sorting and Joints what does sorting mean any relation operations such as joints can be implemented efficiently if the input relations are first sorted so it could be implemented more efficiently we can sort a relation by building an index on the relation and then using that index to read the relation in sorted order such a process orders the relation only logically rather than physically hence reading of tles in sorted order may lead to disk access for each record which can which can be very expensive so it is desirable to order the records physically instead of logically so sorting of relation that fit into main memory standard sorting techniques such as quick sort can be used sorting of relations that do not fit into the main memory is called as external sort sting most commonly used algorithm for this type of sorting would be external sort merge algorithm so we're going to understand that sorting becomes very important if we want to save the query cost and it has to be done physically instead of logically now there are several ways through which we can do that so let's understand that so let's understand external sort merch I have an initial relation which is unsorted first we will divide it into four equal parts over here each part go sort each part is sorted in an ascending order then we will merge them together and sort it again then now I have two parts I will merge them again into one part and sort it again in an ascending order and finally this is my sorted output how does the external sort watch algorithm works that we denote the M as a memory size and Pages we create the sorted runs let I be zero and initially because first we will start from the zero index repeatedly do the following till the end of the relation we read the M blocks of the relation into the memory sort the inmemory blocks write the sorted data to run R and then increment I let the F let the final value of i v n now merge the runs nway merge whatever run we have done by sorting we merge them and we assume for now that n is less than M we use the N blocks of the memory to buffer into put runs and one block to buffer output read the first block of each run into its buffer page so the exactly same method which we done in the last slide we repeat select the first record into the sorted order among all buffer Pages we write the record to the output buffer if the output buffer is full we write it to the disk we delete the record from his input buffer page and if the buffer page becomes empty then we read the next block if any of the run into the buffer until all input buffer pages are empty so exactly the operation which we did over here is explained in terms of algorithm which we can use to follow now let's see the next one nested Loop joint which is also called as sum assuming the worst case memory availability and the given statistics for the relation for the customer and depositor so number of record for the customer which we have is 10,000 number of recorder for deposit depositor we have 5,000 number of blocks of customer which we have 400 and the number of blocks for depositor will be 100 so we need to estimate the cost with depositor as outer relation with customer as also outer relation let's say the first scenario with depositor as outer relation number of blocks access equals in depositor which means this multiplied by B customer which means this plus b depositor which means this so 5,000 * 400 + 100 will give you this as the result I do customer as the outer relation then n customer will come first get multiplied with the B depositor plus b customer and and that will give me this as the result and if I use this method number of blocks axis equals B depositor plus b customer which means 100 + 400 that will give me 500 so there are several different algorithms which we can use to impl joints nested Loop joint block nested Loop joint index nested Loop joint sord merge joint hash joint so the cost of computing for all joints R is outer and S is inner relation of the joint each joint we can see the worst case and the best case both certain joints we can only see the worst case so the number of records for R we have represented over here number of records for S represent by NS number of blocks for R BR and number of blocks for S will be BS you can take a screenshot of this and you can use it for solving other questions these are certain questions which are most asked in unit 5 so you can solve them and write proper answers if you have any doubts or any questions you can definitely mention in the comment section video then do give a like And subscribe my channel for the next video I will see you in unit six happy learning bye-bye thank you