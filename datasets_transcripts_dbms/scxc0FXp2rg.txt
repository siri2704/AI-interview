there are two terms you need to know before starting database management system first one is data and second one is information so let's see what data means so data refers to a collection of raw facts or figures that can be processed to derive meaning or knowledge in easier terms we can say any fact that can be stored is a data so let's see from an example consider an example of orange so what does orange means here orange can either be a fruit or can be a color as well so we don't know what does orange means here maybe it can be a fruit maybe it can be a color so now comes information in the picture so what is information process data is called as information so consider I'm writing here as fruit so now we are clear ke uh we are referring orange which is a fruit here consider I'm writing it as Orange orange and I'm giving it the name as color so now we are clear ke here the orange we are referring to is the orange color so basically what information does now it gives a meaning to the unprocessed data so data basically is a collection of raw facts or figures you can also take an example consider there is a value called as 12 so now here are you getting anything what is 12 maybe it could be an age maybe it could be a raw number maybe it could be a pocket money so like sorry it couldn't be but still I'm just taking an example so here 12 can mean anything like it is just a raw fact which is present here consider I'm giving it as 12 is the age now it is giving some process thing now okay age 12 so my data is uh my brain is interpreting is okay 12 might be an age of a person so this this is like what happens so basically there is a data we provide some additional uh information to it like we provide some additional things to it and it gives me an information after processing it so basically I have a data 12 I give it Like H now my brain will process key 12 and age okay 12 could be an age of a person so it give me an information so basically this is all about data and information let's see what's next okay so database is the next thing we are going to see so what is database database is basically a collection of interrelated data what does this interrelated data means so there are also two pointers like it can be stored in the form of table it can be of any size now let's see there are two examples of databases which are present here so one is multimedia database and second one is college database consider that I am having a table which is having all information about an image okay the pixels the height and everything I'm having another table which is having all information about a video like pixels uh length everything like that so kind of they're interated to a thing which is called as multimedia so multimedia consists of images videos graphics and much more thing so basically image and video kind of have a relation and these both interrelated data forms a multimedia database now in this example there is a staff there is a student consider there is a table one about the staff details there is a table to about the student details so kind of staff and student have a relation that they could be a part of a school database or a college database so they are kind of having a relation so they can be a part of college database and they are having a relation that is why they are called as College database or database like collection of a interrelated data now let's see from an example so here you can see the example in consider this is an A1 this is a A2 so we have given the name to the table first one is having an ID name and subject second table is having ID name and place for the same person Rahul Raj and RTI so here I have given the details about Rahul like the ID is one the subject is physical education ID is two the subject is economics ID is three the subject is it here I have given the information like ID ID's one the place is Delhi ID's two name is Raj and the place is Kolkata ID's three name is RTI and the place is Mumbai so whenever I combine A1 and A2 together they gave me a table A3 which is kind of having a relation like it here if I combine A1 and A2 I can get a relation like the ID of Rahul is one the name is Rahul the phys subject is physical education and the place he lives is Delhi so basically there is a collection of interrelated data so this is why database is called as a collection of inter related data now let's see that why we need database there was already existing file system so what was the need of database so let's see what is file system so basically an operating system approach for organizing and storing data on storage units like hard drive is called as file system so basically it is an operating system approach in which we stored the data on storage units like hard drive so what happens is consider I'm having a file called as a.txt and I have written some data like ID 1 name re I've written some data in now I want to save it so what it will do is it will go to the file system and the file system will call the hard drive to save that particular data inside it a.txt so basically you can say hard drive uh or a like a file system basically acts as an interface between the user and the data so basically it acts as an interface now you would be having a doubt okay using this file system we were storing the data we were we can also update the data we can also delete the data then what was the need of databases so basically there are some disadvantages of the file system so the first disadvantage of file system is data rency so what happens now let's go to the 1980s time so we used to have some registers in first register there might be some information about me where I live like the place I leave U uh what is my age and consider that there are two registers okay registers so there is two registers register one and register two register one is having knowledge about my name and my age register 2 is also having some data about my name and the place I live okay so basically there are two register register one and register two so register one is having data about my name and age register two is having data about my name and place but again uh there is a thing now if it is having a data about my name uh information about my name and age why not to incorporate place in the same register why to have multiple registers for a same person so I'll be having one register with my name uh age one register with the place I live in what register with the attendance one register with some other data one register about how much fees I pay so there would be plenty of registers right so uh like kind of data is being redudant here like it's being used in many formats in different places so that is the major disadvantage of file system that there is a data redundency that in many registers the same data is present about the same person so that is the drawback of a file system so this is something which we can achieve in a database database management system or databases now the second one is poor memory utilization obviously if I'm maintaining hundreds of register for a same information for a single person there would be memory which would be filled so there would be a poor memory utilization now the third thing is data inconsistency so consider I am having two registers register one and register two so register one is having my name and age register 2 is also having my name which is REI age which is not 18 but I'm taking that 18 and please consider it is Bangalore okay so U after 1 year obviously I'll become 19 years old so consider I'm making the change in this particular table uh register that I'm 19 years old my name is D and I'm living in blr but in this particular register I forgot the me I forgot to make the change so you can see that there there is an inconsistency between data the age is uh 18 here and here the age is 19 so there is data inconsistency which we can see here so that is also a drawback of file system now coming to the fourth thing that is data security and data security is like the topmost priority so we want our data to be secure enough we want some security some Integrity in our data some principles which should be in our data to restrict usage from like external people could use my data and which is not possible in file system so data security is also something we achieve much more in databases rather than in file system so that is the reason we introduced uh databases and we are not using file system now database management system finally so database management system is basically made of two words first is database and second one is management system so database as we know collection of interrelated data and management system is basically a set of rules we use to access that data we set of rules we which we use to manage our data is basically called as management system so the acronym database dbms stand for database management system user can access data save data retrieve it update it and manage it safely and effectively with the use of a software program or combination of programs so uh again the same thing that in the database database management system is basically a software which acts like we are having a database right in that database consider we are having a database D1 so in that database now this is dbms and this is an end user so consider I am an end user I want to make some insert into the database consider that there is a college database and on next day someone takes an admission so I want to insert the data of that particular person who has taken the admission so what I'll do I'll use dbms basically dbms is a software which is used to make some manipulation to the database like insert update delete save and much more things now the presence of rules and regulations in the management system is crucial as they necessary to uphold and maintain the databases effectively so there should be some rules and regulations to manage the database so that we can uphold the database effectively and maintain our databases as well so that is management system now this is the application of database so there are three application which I have noted down but there are much more applications of database so the first application is databas is being used in schools and colleges the second application is databases used in Banks and the third application is databases used in Airlines so here we can see the application of database now the first application is school and colleges so dbms is used to create maintain a student information system that stores student records including personal details academic performance attendance and extracurricular activities so consider I am a school student okay so uh whenever I take admission in my school there would be an insert like there would be already a school database which would be maintained School DB which would already be maintain which would be having data about the teachers principal staff and much more things students now consider I am a new student who takes an admission in my school okay so whenever I take admission in the school uh my there would be some data related to me like my name my age which class I want to take admission consider Nursery so there would be many data about me that what I I am like what is my name what is my age which uh class I want to take admission and much more thing so basically that particular data is being stored in this particular database to keep the record of Me Okay RTI is a girl which has recently taken admission to the school her name is this her age is this and she had taken admission in Nursery class so uh I'm just kidding but I'm just giving you an example don't take it seriously so uh these kind of data needs to be stored in the database so here the application of database comes in because again yeah if you are maintaining many registers about people who are taking admission people who are leaving the school people who have been promoted from Nursery to prep like there would be numerous number of registers and it would be hard to manage every data then again data inconsistency data rency there would be many things which which would occur so we use the database approach for this now again in the bank dbms is used to maintain a centralized and secure database of customer information including personal details account numbers contact information and transaction history so consider I am I am right now in Bank you come to me you say that I want to open a new account in your bank so right now I am having all the details about all the staffs who are working at the bank all the people who have account with us and much more things so now a person comes in and he or she says that I want to open a new account in your bank again he or she would be having some details like account number would be generated uh then amount balance uh she or he needs to store in their account and much more things so that particular data I need to feed in the database now again there is one more use case consider that today I deposited Rupees th000 to my bank account next day I pull out 50 rupees from my bank account to buy some chips or something so right now uh what would be the current balance of my bank account would be 950 so there are some regular insertions update delete and like some additions subtraction as well in the database so here also database comes into picture so as you can see on my screen there are many databases I have listed down almost 11 but we don't need to know uh like in depth about all the databases there are some database we should be knowing a bit more depth but uh we can get a slight idea on all the data databases so let's start so on the very first we are having relational database that is among the most widely used databases so in relational database what happens in that database there is a collection of data items which is kind of having some relation between them so consider I am having a database or a table I am having in this table there are certain number of rows certain number of columns and these are having some relations in between them so basically that is a relational database now coming to the second thing that is no SQL database no SQL means not SQL so basically in no SQL database what happens now they don't uh follow any kind of format so the data items are kind of stored in a key value pair so what happens can we have a key and we have a value and our data is stored in kind of this key value pair consider an example we have ay key as place and the value being stored as myour so there is no restriction or there is no relational way it follows to store the data like in relational database models we basically use rows and columns to store the data and it's like corresponding to this row there should be this data corresponding to this column there should be this data so we don't follow that much of strictness or that much of relational approach or a traditional relational approach to store our data we store our data in the form of key value which we basically do in a hashmap so now the third one is objectoriented database as the name suggest objectoriented so basically whenever the data is stored in the form of object it is called as objectoriented database we will be looking more about this in the further slides now fourth one is inmemory database so what happens in inmemory database now the database or the data is stored in memory like it is stored in the primary memory not in the hard disk or any sand disk or SSD anywhere so basically it is stored in memory so that is why it is called as in memory database now the fifth one is time series database so in database what happens now consider we are having a series of events on a different time intervals so that kind of events or that kind of time intervals are basically like a Time Value pair it is stored in this time series database now sixth one is spatial database so basically spatial is something like a kind of of a we can say a 2d thing or something which represents something so basically in SPL database what happens is can we generally tend to store the geometric space in the database uh don't worry if you're not getting these terms because it's just a basic intro of these databases you don't need to know in much more depth about all these databases now the seventh one is multimedia database so as the name suggest it is a collection of databases which is having like collection of data which is having text images graphicss and much more things now eighth one is columnar database so basically in this database every data is stored in columns not rows now ninth one is XML database again as the name suggest in this database the data is stored in the form of XML now 10th one is new SQL database so what new SQL database does now there might be some gaps in relational databases there might be some gaps in no SQL datab so basically it becames a bridge for all the gaps between SQL and nosql databases 11th one is blockchain database in this blockchain database the data is stored in the form of blocks so basically it is kind of a decentralized way in which data is stored so data is basically stored in the kind of blocks so there are four databases which we would be looking in depth because relational databas is kind of most used database no SQL database is also widely used an objectoriented database and inmemory database I guess uh according to the semester point of view you should be knowing about it not very much in-depth knowledge but you should be having some knowledge about it so let's uh have a look on all these four databases so basically the first one is relational database so these databases structure data into organized tables that have predefined connections between them so as I told now uh whenever uh like tables have some connections or have some relations among them it is called as relational database so consider there is a table one T1 and there is a table two T2 consider that they have a kind of a relation between them relation how you can say what what kind of relation or something like that so let's see consider there is a table which is having my name and my R number consider the table T2 which is having my name and and the place I live in so this is also a data by about me and this table also con contains a data about me so they have a relation which is like uh the information about me is also present in this D1 and the information about me is also present in this T2 so this is kind of a collection of interrelated data so this is like a connection between them now data manipulation and query performed using SQL so basically in these kind of databases the data man manipulation like kind of insert update delete and every other operations are performed using SQL queries now well-known databases are MySQL postgre SQL Oracle database and Microsoft SQL Server so this is all about relational databases now coming to the second term that is no SQL databases so no SQL database are created to handle data that does not fit neatly into the strict setup of TR additional relational databases so what does this means again uh like few minutes ago I told you what does no SQL database mean so basically no SQL database what happen now we don't store in a form of rows and columns and we don't do any kind of queries take from this row we are getting this particular things from this column we need this so we don't do store data in that format basically data is stored in the form of key value pair which I earlier explained consider there is a key called as place so the value would be myour so basically in a form of key value pair the data is being stored you can say in a form of hashmap and uh in relational database models basically the data is stored in the form of rows and columns they have some unique key which uniquely identifies the table and there are more things in relational database model which is not followed here so that is why it is called as no SQL that is not SQL like there are many things people say but but uh considering like it is a uh database where we don't use any SQL queries which don't follow any kind of relational databases so the third one in this list is objectoriented database so these databases hold objects utilized in objectoriented programming so you might have heard about oops that is objectoriented programming what basically oops does it stores uh everything as object there are instances of object which is called as class so basically in objectoriented database the objects is store as a form of data which are like instances of class and the combination of objects and classes is called as objectoriented database so they work well for the applications with intricate data designs like scientific simulations and multimedia software so here they are mostly used now fourth one is inmemory database so in this database data is kept in the primary memory that is Ram rather than on a disk leading to a quicker data retrieval so basically in inmemory database what we do now we keep the data in the primary memory not in the hard disk or not in the SSD we keep the data in the primary memory and whenever we keep the data in the primary memory what it helps now it helps to improvise the time as we don't need to make some data retrieval from the SSD rather than we can make the data retrieval from the primary memory itself so they are employed in an application that demand instant data processing and topnotch performance obviously it will give a topnotch performance because the time of consuming the data is very less we are not consuming data from SSD or from hard disk so need of database management system so we got to know about database databases ke types database management system what is database management system and much more things now we need to know that what was the basic need of database management system so dbms plays a vital role for business institutions and organizations of all skills in effectively managing their data ensuring data accuracy and security and supporting essential decision making process so basically what happens now database management system is kind of having applications at every places like in schools like in colleges like in Banks and institution and much more places it helps to easily manipulate the data it helps to easily store the data it helps to manage operations like inserting data deleting data uh doing some manipulation on the data like addition subtraction and much more things so it gives us the feasibility to do some manipulations on the data very easily so that is the reason ke database management system is mostly used now the second reason is the security as well it provides us a lot of security there are lot of user access control rules and some authentication rules as well which would help us and help other people as well ke uh whenever we are uh accessing any data there would be some kind of authorization present so that uh that data would be accessible only from me not from someone else so it basically helps in data security achieving security for our data and also the control of the data so it serves as a core of contemporary Information Systems faciliating efficient data management and serving as a basis for a wide range of applications and services so as told earlier that it helps to manipulate the data it helps to perform operations to data it helps to secure our data it provides a scalability also for our data and there are much more things in which database management system could help us so basically uh along with the needs we should also know the advantages of dbms so let's see so basically there are various advantages of dbm I just picked some of them which I thought were important but there are various advantages of dbms so the very first advantages is data security who doesn't want their data to be secure consider you are in an institution or you are in a college so no one wants key your data should be insecure or your data should be visible to every person of the school or anyone can access your mobile number your email or the place you live in so you want your data to be secured so data security is mostly ACH achieved in dbms dbms implements security mechanism that regulate access to sensitive information safeguarding it from the unauthorized access and potential data breaches so uh the thing which I said earlier consider uh there is a phone number of yours which is stored in the database so uh there are some kind of security rules there are some kind of security protocols which helps to uh provide a layer of protection for all the data so that no one else from outside world could access your data make some prank calls to you or uh provide you any kind of advertisement so basically that is the reason data security is something which is a utmost important now second thing is data rud dency and inconsistency I explained in the earlier videos as well data redu dency basically means the same kind of data is kind of being used at different places uh rather we can have a c calized space where all the data for a particular person is present and data inconsistency is can consider there are many chunks of data which are present at different places or different registers what if I correct a data in one of the register or update a data in one of the register and it's not updated in second or third register there would be a data inconsistency so dbms removes all the data redundency minimizing storage needs and ensuring consistency throughout the maintenance of a unified version of data so basically uh as I told in dbms we can have a centralized way in which we can store all our data at a central pace so that there won't be any data Rudy and inconsistency in data so in database management system now everything happens with a transaction so in a transaction what happens you consider I'm updating a data somewhere so I need to update data at every places so even if there is a system failure transaction would help us to update the data either it will like there are some many operations read read write read and many operations which we would be seeing in the further videos but with the help of transactions we can achieve data consistency not uh and remove the data inconsistency so the third thing is data Integrity now dbms guarantees data Integrity by enforcing some rules or constraints that prohibit the entry of incorrect or inconsistent data into database so basically there are some rules in the data base which prohibit the insertion of some inconsistent or some data which is not needed to be provided there so consider there is a column called as age so in this age I can't feed the data like ABC right so this is not something which is taken care in the uh earlier systems which we are using but uh in databases we can uh put a constraint that age could only be an integer so it will not accept the values like ABC it will only accept the values like 12 so so basically we can put some rules we can put some constraints so that any inconsistent data or any incorrect data is not uh entered into the database now the fourth advantage of database is database scalability so uh dbms can handle large data sets and scale to accommodate increasing amounts of data and as an organization growth so consider that I am having an organization which is right now having 1 to 40 employees so in my database I am having data about all the 40 employees what if I have a recruitment drive and I hire 1,00 more people so now there would be 1 to 4 Z employees and there would be some data so I need to scale my database to that level that I can store all the information of uh 1240 uh people so right now the total number of employees I am having is 1240 now I need to scale my database to that level that I can store all the information about 12 4 employees so uh scalability is something which we can achieve in a much more easier way in databases fourth fifth Advantage is data abstraction so dbms offers data abstraction allowing users and applications to interact with the database without needing to understand its underlying complexities so there are many complexities there are many hidden details which are present so database management system makes sure that there is a data abstraction so I know that a email is being sent to me from this particular person but I don't need to know that where that particular person leave from which server this email has been sent so there are some complexities or there are some details which needs to be hidden which are unwanted or which are some internal details which needs to be hidden and dbms helps us to achieve this so this was all about the advantages of dbms so with adant advantages there always come some disadvantages as coin always have two phases so let's see the disadvantages of database so the very first disadvantage of databas is cost so acquiring deploying and sustaining dbms software can in Aur significant cost so obviously if we are uh sustaining a database if we are deploying a database that would be a very costly thing furthermore the hardware essential for proficient operation of database management system can also lead to substantial expenses so basically uh whenever we want to maintain a database or sustain a database there are many operations we need to do to that particular database and then we also need a hardware which would help us to do that particular operations easily and effectively so there is increase in the expenses so uh database management system can lead to more cost so that is one of the disadvantage of dbms now this second disadvantage of dbms is scaling project yes in the advantage I told that we can scale the database management system projects but there is also a disadvantage with that let's see so when dealing with modest applications and minimal data storage requirements adopting a comprehensive dvms could introduce avoidable intricacies and additional burdens in this instances more streamlined data storage Alternatives could be better suited so consider I want to store data of only 20% and I got a database in which I can store data about of, people so again that is not making very much sense to me yes that database is scalable but I know that I only have to store uh data about of 20 people it can be 22 but it would never be 100 so uh scaling projects or scaling like we can see that the projects which require some kind of minimal data storage and adopting a comprehensive dbms could introduce avoidable intricacies and additional burdens so if I am like I just want a database which store 20 people information and I'm having a huge database so that is also something which I shouldn't be needed and which would eventually increase the cause and this will be which would eventually increase the cost and this would again be a disadvantage of database now the third disadvantage is vender lockin so once you have choosen a specific dbms it can be challenging to switch to a different one due to differences in the data formats query languages and other technical aspects then can lead to vendor lock in where you are dependent on a particular vendor technology and pricing so consider right now I'm working on a my SQL database or a database which uses SQL approaches SQL query and everything like relational database consider uh like after few years I want to switch to a no SQL database which basically stores data in key value pair so there are some constraint that I can't move from this database to this database because of the formats because of query being used because like in this data is being stored in rows and columns but in this the data is being used stored in Q and value pair so there are many constraints which come into picture whenever you are switching from one database to another database that also leads to an disadvantage AG of database so as you can see on my screen it is made up of two words data and abstraction so data basically is a collection of raw facts and abstraction you can understand in simpler terms is hiding something so whenever we are hiding some internal information or some internal details which a user doesn't needs to to know it is called as data abstraction so first let's see the definition and then we will understand with an example so basically database systems are built with complex ways of organizing data to make it easier for people to use the data base the creators hide the complicated stuff that users don't need to worry about the hiding of unnecessary things from user is called as data abstraction now let's see from an example so consider that I am having a data okay this is a student database now uh I am concerned about what all data I am putting in the student database like the RW number student name and different things but am I concerned about where this database is being stored in my disk which memory location this particular database is being stored no like why it matters to me now where my database is being stored in which memory location it is being stored what kind of data structure it is using for being stored like B trees or hashing like I'm not concerned about all those internal details or all those details which are not concerned to me I'm just concerned about data at a higher level I want to do some data manipulation I want to do some Insertion I want to do some update in the data but I'm not concerned about where my database is being stored where the data is being stored in a particular memory location so I'm not concerned with all those details so this is data abstraction The Hiding of unnecessary things from users is called as data abstraction so basically I'm hiding some unnecessary details or some details which is not not very much adds a meaning to me so that particular data I'm or that particular information I am handing from the user so I am not concerned about where my data is being stored I'm just concerned about what my data is is the data correct is the data consistent is the data doesn't have any redundency so for that particular things I'm concerned but where my data is being stored at a physical storage what techniques they are using for optimizing what kind of indexing is going on for all those details I'm not like very much bothered about so that is called as data abstraction we are not very much bothered about details like what is the index indexing approach we are using what kind of data structure we are using for storing the data at which memory location or dis the data is being stored I'm not concerned about all those details so basically this is called as abstraction basically uh we are abstracting something from the user we are abstracting all those details from the user user is just interacting with data at a higher level so there are multiple levels of abstraction so let's see about all those levels so there are three levels of abstraction let's see about all those three levels so the first level is called as physical level which is you can say the lowest level now the second one is logical level and the third one is called as view level so let's understand uh about all these levels of abstraction from an example so first let's start with the definition and then we will be looking at an example and we will be understanding all these three levels from the same example so first level is physical level so this is the lowest level of data abstraction it describes how data is actually stored in the database you can get the complex data structure details at this level so let's take an example again the same example which I took in the last slide so I am having a student DB student database okay now this level tells me how data is actually stored so consider I'm having this student database there are many datas in this particular table or the database now consider that this particular ele ment or this particular database is being stored at a memory location or you can say SSD hard disk anything so basically it is being stored physically at a storage location so in this physical level we get to know that where the data is being stored so at this level now what you can do you can also uh optimize your data so how you can optimize your databases ke you can perform some techniques you can use some data structures which will help you in proper optim ization like there are B trees hashmap and many hashing so you can use that particular approaches and that particular methods to optimize your database so basically here you are just concerned about where your data is being stored in a simpler terms so I am having a student database and I am only concerned about where the student database is being stored simple now going to The Logical level so basically logical level can you relate with the term logical so whenever we are doing something logical some logical operations are being performed like creation of a database adding some constraints into datab base identifying what is the relationship among the data elements like these all things are taken care in The Logical level so this is the middle level of three LEL abstraction architecture it describes what data is stored in database so here basically it was all about how data is stored and in this level we were concerned about what data is St so basically coming to the same example now I know that there is a student database now I'm making some tables consider there is a student table consider there is a table with uh student fee details or something like that so there are multiple tables for student student uh table which is having details about their first name last name r number and etaas student fee details where they are having all the details about when they paid the fees what were their fees and uh how much money they have paid together like some details like this so basically at logical level what we do now we make some tables like student we uh provide some data to them then we uh establish some relationship among them or we identify that what is the relationship between the student name or student rle number or the student fee details and various thing so basically all the logical things like creation of a student table then uh addition of some attributes addition of some tles in that particular student table so attributes basically means columns tles basically means rows so addition of some rows and columns into the student table then providing a unique identity that considered that ID so ID is something which is unique not all the students would be having the same ID so providing some constraints and like much more things are done at a logical level so basically in logical level we are not very much concerned about where our data is being stored or what all things we are just concerned about what data is being stored okay so the very third level is the view level so highest level of abstraction is called as view level this level describes the user interaction with database system so again taking the same example now consider there is a student database right so consider I am a teacher and my friend is someone who is working in the uh accounts team okay so as a teacher I would need some details of student like R number subjects uh student ID and as someone who is from account team they would need details like student fees paid in the month or month like these details so according to the need I can have multiple tables like if I am someone who is from the account team I am majorly concerned about what is the student uh fee details in which month they have paid uh till which month they have already paid till which month uh it is pending like all those details which is needed to me at a teacher level I would be just concerned about what the student name is what additional subject they have taken or what is their role number or what is their student ID so in the view level what happens like there are multiple uh like there are multiple views which we can see and which gives us like U you can say which gives us the opportunity to only see that particular data which concerns to me consider that I am in a school right so my principal can see all the data related to student related to teachers related to staffs now coming to teachers teachers can see all the data related to students now coming to students student couldn't see any data right firstly we will start with schema and then we will see what is instance so schema a schema is a logical container or a structure that organizes and defines the structure of a database it identifies how data is organized what data types are being used what constraints are applied the relationships between different pieces of data a schema acts as a blueprint for the database ensuring data inte ity consistency and efficient data retrieval so let's understand from an example okay so uh in programming terms we always give like int a so what does this means a is a variable which is stored at a memory location and its data type is int so we can only store integer type values in a and a is stored at a particular memory location now in a we can give the value as two either we can give the value as three either we can give a value as 21 we can give any value which would be integer but a remains this at remains at the same place at the same memory location so in the same way what is schema schema is basically now a blueprint of the database so consider I am creating a database of customer okay so for this what I need to do is first I need to make a customer table so we will be first making a c customer table second I need to give some rows and columns in this particular customer table okay at the third place what I'll give that I will give some field names or some column names and provide the data type they can hold now in the fourth number we will be defining the constraints in that particular DB so let's see so basically consider that this is my customer table now customer table would be having some rows and some columns so right now consider it is having two rows and three columns okay rows is two columns is three now consider that they would be having some column names as well so consider I am giving this column name as ID this as customer name and this as customer uh address okay now I have given the rows I have given the columns I have given the names to the column now I need to provide the data type so ID would be something which would holding an integer value name would be something which would be holding a character value and address the same character value and we can provide the size as well for the same like consider eight digits 14 14 okay so I have given the data type and I have given the limit of that particular data type now ID is something which would be unique for all the customer because it is generated at the time of you can say at the time of billing or at the time of we are uh feeding the entry of customer into our table so ID is something which is very unique so we can provide or we can say this ID is a primary key for my table so it is a primary key so basically constraints in DB all these things we have done in this particular schema so now in ID I can like give any value either I can give 1 2 3 I can give 4 5 6 I can give 78 9 I can give any value which would be of type integer so basically I'm giving a blueprint of my database here so schema is a blueprint for the database which ensures data Integrity like I can't put on any value which is apart from INT in this customer ID data consistency that my data remains constrained throughout all the databases or throughout all the table there won't be any duplicacy and efficient data retrieval so if I am having ID I can retrieve the data for any of the customers now here we have defined the data types we have defined the constraints we have defined the relationship between different pieces of data so this is called a schema now there are various types of schema so let's understand about that so types of schema the first schema is called as physical schema are you getting something in the last set of videos we discussed about physical level in abstraction so it is kind of similar to physical level of abstraction so phys physical schema in a physical schema it defines how the data is stored on the underlying Hardware including details such as storage format file organization indexing methods and data placement so basically in physical schema now we basically uh deal with the physical terms like where my data is particularly stored so in physical schema I am concerned about where my data is stored on the Hardware or disk or any memory space so uh consider that my data is stored at this particular memory okay so at this particular memory space my DB is stored now uh I can like see some of the methods of storing the data in the database like I can use the hashing method I can use the B method like there are many methods there are many indexing methods we can which we can use so that when we are querying and when we want the data there should be a proper optimization which is established so if I uh use like the file organization techniques the indexing techniques uh indexing methods indexing techniques then I could uh get my data very easily and very effectively and it can also help in optimizing the data and also these methods would help in the storage optimization as well so in the physical schema we basically deal about how the data is stored in the hardware or in the disk or in the memory space now what are the characteristics of physical schema so it primarily Focus lies in enhancing the storage and retrieval of data to boost the performance again the same thing which I told in the last slide that we make sure that we put the data in a proper place in a proper storage or in a proper memory so that it can be very easy for us to retrieve that a uh data and also it could help in the storage optimization which would eventually lead to boosting of the performance now the second one is modification meets to the physical schema demand meticulous planning and can potentially affect the overall performance of the database so basically U consider that my database is at one particular location now I am moving that database to another location then again I need to be concerned about how the data is being stored uh what all methods of indexing we are using how the data is being stored uh how I can retrieve the data what is the time it is taking for the data retrieval what is the storage optimization so there are many thing so if like there are some modification made made to the physical schema it could potentially affect the overall performance of the database because right now the uh data is stored in such a way that it gives me the higher performances G it gives it takes lower time and gives the higher performance but there could be a chances that if the modification is made it could take more time which could lead to a lower performance now the example deciding to use clustered index on specific columns for a faster retrieval as I told that we use some indexing methods about all these indexing methods we would be knowing in the coming videos but you just understand in a way that there are many methods uh we use some of the methods to uh like on specific columns for getting the data as fast as possible now the second schema is logical schema a logical schema defines the database structure from a logical or conceptual perspective without considering how the data is physically stored now in the physical schema we were majorly uh focusing on how the data is stored now here we would be focusing more on what data is stored so I'm not concerned about wherever my data is stored in the memory location I am mostly concerned about what kind of data is being stored so logical schema is of two types first one is conceptual schema and second one is external or view schema see all these terms we have already read in the abstraction video the types of level so it is kind of similar to that but uh still I'm trying a lot to make you understand again that what all these terms basically mean now the types of logical schema so the first one is conceptual schema the concept ctual schema represents the overall view of the entire database it defines the high level structure and relationships between all the data elements uh the example which I told in the schema that we are making a blueprint of all the uh all the columns all the rows we are giving some data types to these particular columns like ID can have only integer values name can have only uh character values and like this so basically we are defining a database we are making tables we are making rows we are making columns we are giving the data types we are identifying the relationship between them and we are also adding some constraints like ID something which is unique for every customer so that can be a primary key again for the keys we will be knowing uh about it in the next set of videos but just uh understand in a way key something which is unique something which can't be like uh something which shouldn't be twice or shouldn't uh exist twice so consider that there is a customer ID so every time whenever you are generating a customer ID it would be a random thing so one time my customer ID could be 1 2 3 one time it could be 456 it could be 789 but again it couldn't be 1 2 3 so there won't be any case where uh customer ID which is generated for every person considered it is generated for a it is generated for B it is generated for c for D also uh the customer ID Remains the Same which is of a uh it won't be possible so there are some constraint there are some columns there are some rows which we Define for a particular particular uh schema um it would be a better word to call so for a particular schema we Define everything so in conceptual schema it basically depends on that that what are the relationships we are giving for that particular schema what is the number of rows what is the number of columns what is the data types now the second one is external or view schema an external schema defines the user specific views of the database it focuses on the portion of database that are relevant to specific user roles of application so consider that there is a database of customer okay uh let's take an example of an e-commerce website so in e-commerce website there would be many tables one table would be of customer second table would be of orders the customer had made third table would be the prices for all the things and then discount and everything so there would be three tables present like there would be many tables but I'm just taking an example of three tables so consider I am a person who is working in the sales team of this e-commerce website so if I'm working in the sales team I would be mostly concerned about now what all prices uh customer has paid what all uh what is the total amount the customer has paid what was the total discount it got how the sales are increasing and much more things so I would be mostly concerned about some specific table if I am someone who is uh like seeing the analysis like what all things customer buys and how I should recommend the customer to buy the same thing I would see the orders table so basically according to the users now we show different tables or we show different views so in this view schema what we do is there are different views and according to the user specifications like I want to see the sales I want to see the data related to customer I want to see the data related to what all orders customer place and different things so in this way there are different views and these are user specifications on which the views are shown so in the schema basically defines the user specific views of the database so basically uh here it is a customer here it is an order and here it is a price table okay so there are some characteristics as well of logical schema so it delineates how data is structured into tables the interconnection between these tables and the Restriction placed on data again the same thing that the data could be only of type integer what all relationships are between the tables and what are the number of rows number of columns and much more things so basically it delineates how the data is structure into the table now second point is logical schema prioritize data modeling and database decide over considerations related to Hardware or storage specifications again we don't need to be much more aware about like how the storage where the data is being stored or something like that I'm not concerned about that I'm basically concerned about like how my database is being designed how the how much tables are there how much rows are there I'm mostly concerned about uh what data is stored I'm not concerned about how my data is being stored in the memory space example defining tables specifying primary and foreign Keys creating views for the data access so these are the examples for logical schema now the last term in this video is instance so what is an instance the information residing within a database at a specific point in time is referred to as database instance so consider that today I made a database okay it is of a it is a customer database so right now I am having three customer customer 1 customer 2 customer 3 okay so I am having a database of customer 1 like like how many orders the customer has made like uh orders the customer has made consider that this customer has made just give me a second let me make a bigger table for you okay so this is a customer table ID number of orders and uh I can give the address okay so ID is one number of orders is two address is Delhi ID is two number of orders remains five and ID is address is Bangalore okay so there is one customer which is having an ID one the number of orders they have made total orders is two and they reside in Delhi the ID is two the number of orders they have made is five and the address where they reside is Bangalore now there could be a possibility now right now I'm leaving in Delhi but what if I switch to uh some other place or some other state like Karnataka so I right now I'm working in Delhi but I have changed my job and right now I am going to Karnataka so I'm relocating to Karnataka so I would request the website like U what we can take an example of swii so right now I am in jarad that is my hometown I am making orders on swiigy I am giving giving my address now I am switched to like I I have came to Bangalore now I want the order delivered to be bang uh delivered at my bangalore's address right so I'll make some update okay right now the that was my home address but now the home address is the Bangalore one so there would be some update in the database regularly right so at an instance consider at this particular time this is the data which is stored in uh in the database there would be some modification made in coming days so the in information residing within a database at a specific point of time is referred to as database instance so basically the data which is there in my database at the specific point of time is called as instance within a given database schema the Declaration of variables within the tables pertain to uh to that specific database the term instance in the context denotes the current values of the variable at a particular moment in time for the database so at an instance the value of address is Delhi but after two days the address is changed to Bangalore so at a particular instance the address is Delhi but after 2 days if that particular uh specific time if we see the address could be Bangalore so in this context it denotes the current values of the variable at a particular moment in time for that particular database so schema is basically a physical representation of database or a blueprint of database instance is the value of database at that particular specific point of time so basically database management system architecture refers to the structural framework and organization of database management system how we are just organizing our database like what are are all the elements of the database we are using consider that I am designing a database system so how many elements I would be using how many clients would be there how many servers would be there how many databases would be there like there are many things right whenever we design a system we majorly be concerned about what all databases would be there what all clients would be there what all servers would be there so basically it helps in organization of a database management system that is dbms architecture it also defines how the various components of the system work together to store manage and retrieve data efficiently so basically in this dbms architecture now there are like different types of dbms architecture existing we would be mainly knowing about three architectures in simpler terms you can understand dbms architectures help us to achieve a way in which we can organize our data store our data access our data we can manage or we can organize the database systems we can manage how many clients would be there how many servers would be there according to our requirements we can select the tier level of databases so basically according to the user level you can select any kind of databases either it be one tier either it be two tier either it be three tier or either it be n tier basis on your requirement you can select any of the tiers of data so let's understand about the types of dbms architecture so there are basically several types of dbms architecture choice of architecture basically depends on the factors such as type of database that could be relational or nosql and the specific needs of the application so it mostly depends on how my application is like if I am having a website which is H handling so much of traffic in a single day so I would be using a database in which I can achieve scalability at a good level right so there are many user requirements there are many organizational requirements According to which we select the database so uh there are three architecture basically uh about which we would be learning in this video there are more architectures ah it like centralized architecture and tier Arch arure and much more but here we would be knowing much more depth about the three tiers of architecture so the first one is one tier architecture the second one is two tier architecture and the third one is three tier architecture the one tier two tier and three tier you can see that one two and three are being used so it is kind of related to the database designing or the database system which is present for these level of architectures so let's see for the one tier architecture Ure so in the 1 deer architecture the entire database application including the user interface application logic and data storage resides on a single machine or computer so basically whenever you have the database installed in your computer now and you are accessing that database for consider that uh whenever you are learning SQL you are performing some SQL queries you are seeing the result you are making some data you're making some table and on that tables you are man ulating or making any type of query so you are making that query in your system right so client user interface and database if all the threes are in the same system it is called as one tier architecture so here you can see that data storage resides on a single machine or a computer and the three things are the user interface application logic and the data storage so basically an example could be an illustration of straightforward single tier architecture can be seen when you install a database on your system and use it to practice SQL queries as I told so basically this is the file server and this is a PC tablet or anything so basically in my PC tablet I just installed a database software and I am using it for making some SQL queries so that is called as one tier architecture now coming to the two tier architecture in two tier architecture the presentation layer runs on a client that could be PC Mobile tablet Etc and data is stored on a server so basically two tier there are there would be two things right in one tier there was only one thing like uh the client the user interface the storage everything resides in a single entity but here there would be two entities the two tier architecture provides added security to the dbms as it is not exposed to the end user directly it also provides direct and faster communication so uh let's understand from the diagram as well so as you can see this is a two-tier architecture this is a client one and this is my client two now this client one and this client two are uh interacting with this server which is our database so here you can see now there is a presentation layer or there is a layer of security that this this particular client and this particular client are making request to this database right so there are multiple clients who are making request to a single database or a single server you can say so there are multiple clients and they are making request to a single server so two tier basically means there would be two entities first one is a client entity second one is the server entity the client is making some request to the server and the server is uh making some manipulations and doing some manipulation and returning that as a response to the client so you can consider an example of a workstation where there are multiple computers and all can query into the same database and work with the same database so there are multiple computers there are multiple clients and they are querying to same server so this is a two-tier architecture so basically uh just to give you an overview in one tier architecture the client as well as the server used to reside in a single entity and in the two tier architecture the client and a server used to interact using a layer so this is the basic difference that uh in one tier the client the server used to be in a single enti like if I am installing a database software in my system so that is a one tier architecture because I'm installing it my in my system I using that to make multiple queries but that particular server couldn't be used by any other person or any other person like uh it can be only assessed on my laptop no other person who is having a different laptop can access that particular server right so that is like in my computer I am having a software I am using that software I am making some SQL queries and it is given giving me results now when I switch to two tier architecture there might be multiple computers who would be uh reaching towards the same server this is also called as client server architecture client is like computer PCS tablet and server is where our database receives so basically three tier architecture what happens as the name suggest three tiers so there might be three levels of layers or three levels would be there so basically it separates the application into three logically distinct layers presentation application and data layer so basically what happens at three level architecture now there is a distinction there is a layer separation the first one is a presentation layer the second one is the application layer and the third one is the data layer so basically there are three levels of separation of these uh layers like the first layer is like the client layer the second layer is the application layer and the third layer is a data layer or you can say all the databases are present in there so basically uh let's understand about the layers and then we will see with a diagram and understand about this architecture so basically presentation layer it handles the user interface so basically whenever we go to any website consider we are going to swiggy so whenever we see swiggy on our website or see swiggy app on our mobile application what we see we see a page where all the menus are present all the restaurants are present all the food items are present so that is called as UI so whenever we are accessing any of the website either through app or through web we get a UI which is the frontend of the application where we see every details like the orders like my uh what are the restaurants which are on boarded what are the food items which are present so basically that is called the front end so basically in the presentation layer that is also called as front end layer we basically deal with the user interface of the application or the like website so in example you can see your PC tablet mobile Etc now the second layer is application layer so it manages the business logic example server so basically what happens now now we have seen the UI now consider I am at swiggy.com I want to order some food so for or ordering some food what I'll do I'll select particular restaurant I'll just add it into my card and I'll just place the order so there would be some kind of business logic or there would be some kind of logical operation which would be going on like the addition like the deletion of that particular thing from your cart or the addition of particular thing in your card so there are some manipulations which are done so basically all that Logics now that take place into logic layer or the application layer now the very third layer is the data layer as the name suggests it would be something related to database so basically it manages data storage and processing example the database server so it basically what database does is store our data manage our data and do some processing on that particular data so on the data layer there is a database where all the managing of the data uh processing of the data and all other things takes place now let's see the diagram of this particular architecture and we will get a more good overview about this architecture so basically as you can see there are three layers client layer server layer or application layer and data layer now in the client layer we basically deal with the UI which is called as user interface so basically consider swiggy.com so whenever we open the app we can see some restaurants and then whenever we open that restaurants we can see their menu then some food items and Etc so this is the landing page so basically that is called as UI or user interface now in the second layer consider I am I am like having a craving of eating chocolates okay so what I'll do I'll go to swiigy instamart and I will add some chocolates into my cart okay so basically whatever I am doing the addition it is kind of a logical operation and that is happening at an application layer now at the very third layer what uh what is that that is a data layer so in the data layer if I am adding something to my card there would be a database with called as orders so in that orders this particular thing would be feeded so there would be would be a storing of data also processing of data so all these three things now take place and all these three things like the presentation layer application layer and data layer they are not dependent upon each other they have different infrastructures so we can like make application more scalable by using like by broading this particular layer or another layer or different layers so basically they all have their own infrastructure so we can broaden our application we can scale our application accordingly because one layer doesn't affects the other layer so we can make changes at one layer we can use the scalability principles and much more things to scale our application so all of them have a different infrastructure that is why the three tier architecture is the most used architecture because again uh here we are getting an extra security of the application layer where all the business Logics is happening the client layer is not directly talking to the database layer there is a application layer in between and like there are much more things we can scale our application and very like there are many advantages so we would be seeing about the advantages in the next slide okay so this is the advantages of three tier architecture so the very first Advantage is as I told the scalability so basically it is easily to adjust each tier to handle changing user demands as I told that each tier have their different infrastructure so if we are having any kind of user requirements we can do any kind of manipulation at any layer which won't affect the another layer now the second thing is modularity and maintainability simply simplify maintenance by separating responsibilities again the same thing that the client layer has other responsibilities it is responsible for the UI the server layer or the application layer is basically responsible for all the logical operations which is happening and the data layer is uh mostly responsible for all the processing which is happening in the database and also storing the data so all of the layers have their different responsibilities so it is very easy to maintain now the third point is security protect sensitive data with an additional layer as I told that there is an additional layer of application layer and client is not directly interacting with the database so there is an additional layer of protection which helps uh like in the security purpose and also in the scalability purpose as none of them are dependent on each other performance optimizing presentation and application tiers for better performance as I told that we can optimize any of the layers but they are not dependent upon each other they have their own infrastructure so we can optimize them according to the user requirements to get some better performance and better optimization now with the advantages always there comes a disadvantage because every coin Has Two Faces so let's see the disadvantages as well so the disadvantage of three tier architecture it includes increased complexity obviously there is has been an introduction of an extra layer which is doing all the logical operations so the complexity is kind of being increased as the level of tiers of architecture increases now the second thing is potential latency issues so you you might find some of the latency issues as well because there are three tiers of architecture and there might be some issues which would be encountered consider there could be issues like when we are like talking to the database layer there could be issues in manipulating the data there could be some issues in processing the data there are many potential issues which could be encountered while doing any manipulation at any of the levels now the third thing is longer development time again three tiers are involved so at one level you need to code all the law that at one level you need to design the front end of the application then at one level you need to design the back end of the application so the development time increases because again the client is not directly talking to the database it is talking it via application layer then resource overhead and possibility of bottleneck because of complexity of the database there are much more things which are being introduced because this is a bit complex uh tier architecture so there might be like complexities which could arise in each and every moment of time again longer development time because of 3 TI architecture then overheads then there are many things lcy issues overhead bottle leggings and much more things which is involved because of which these are coming as a disadvantages of three tier architecture but it is kind of mostly used in the companies and mostly used everywhere because three tier architecture is a place where like you are dealing with the front end client layer you are dealing with the backend data layer and you have an additional layer application layer where all the business Logics is being happened so if you want to change some business logic or if you want to do some alteration you don't need to do alteration at all the levels you can just go and alter like update or alter anything at the business or application layer so that is the major thing that it is helping us to uh like there is a layer layer by layer production also it is helping us to achieve optimization it is also helping us to achieve scalability at a very good level so that is why T architecture is mostly used so data model a data model within a dbms that is database management system serves as an abstract representation of how data gets structured and organized within a database it outlines the logical arrangement of data and connection between various data components so it also plays a vital role in comprehending and shaping databases acting as a vital link between real World entities and actual storage of data within databases so we read more about definition now let's see what is exactly data model so uh let's understand what is flowchart first so people who would be doing programming they would be having a slight idea about flowchart so in flowchart what happens is ke we give some instructions like uh consider I don't know how to make Maggie right so I am making a flowchart on how to make Maggie so basically in the flowchart the very first thing would be to boil the water now the next thing would be to put noodles and Masala and much more thing we are not here to learn how how to make Maggie but there are much more things right so we can consider it as flowchart or algorithm also so there are there are many steps which is involved in making the flowchart as well as algorithm for making Maggie right so if we have the flowchart or if we have the algorithm with ourselves it would be very easy for someone who doesn't know how to make Maggie they can follow that particular instructions or follow that particular steps and make Maggie so basically in this way only flowchart helps very much uh and data model is kind of you can consider it as a flowchart where we get to know about like what all data would be there what all relationship between the data would be there what all constraints would be there what are the attributes what are the entities and much more things so uh let me just erase all these things okay so now let's understand so basically in the last lecture now we learned about schema now here it is data model now in data model what we do is we deal with datas then the relationship between data and then the constraints okay now in schema also you would have heard key I said some similar sort of thing that it is kind of a blueprint of a database where we are dealing with data relationship and constraint so you would be having a doubt then what is the major difference between schema and data model so data model is now a conceptual framework or you can say an high level View High Level view of database so basically in data model now we have a conceptual framework or it is a high level view of database like there is a database there would be such such such data in that particular database the relationship between the data would be that the constraint in the data would be that so like there is a conceptual thing which is going on okay so in a very high level we tell that what is the data what is the relationship between data what are the constraints present in the database but in schema what happens now schema is the implementation of a data model so if I provide a data model I can do the implementation using schema so in schema we basically do the implementation of the data model so as I told that if you have a flowchart or algorithm of how to make Maggie and if it is provided to you you can make Maggie very easily so in the data model we provide a very high level view of our database and in schema it is basically implemented using all the given data then the data is all the given information and then there are data then there are relationship and then there are constraints so data model is a conceptual framework or a very high level view of the database schema is basically the implementation of the data model so there are various types of data model so let's have a look so one is hierarchical data model the next is network data model the third one is relational data model which is very widely used the fourth one is er model which is again very very very important from the point of interview and from the point of semester exams as well then the next one is objectoriented data model and the last one is no SQL data model so let's have a look about all these data models so the very first data model is hierarchical data model are you remembering something we heard about hierarchical inheritance right so basically hierarchical data model is somehow taking all those Concepts and we would be seeing that here as well so in this particular model model it portrays the data in a manner that it is resembling like a tree like structure where each record maintains a parent and child relationship its primary application lies in older database system so basically in this particular model now as we learned in hierarchical inheritance so basically there is a parent child relationship which is maintained each child would only have one particular parent so uh every child would be having only single parent there are no more parents for a particular child so basically as you can see that here there is a child the parent is school so let's uh start from the top to bottom approach so school is a parent now school is a parent so it might have some Childs so now department and infrastructure are its child now coming to department now it is the child for school but it might be a parent for its child which is teacher student and staff so you can see there is a parent child relationship which is maintained all throughout and any of the child is not having more than one parent so basically in hcal data model there is a child which is having a single parent and there is a tree like data structure which is maintained so this is kind of used in very older database you can say as XML database and it's not used very widely but there is an enhancement of this particular database so let's see uh the enhancement so basically the next data model which is also an enhancement to the hierarchical model that is network data model so this model shares similarities with the hcal approach permitting records to hold multiple parent child relationship so there could be multiple parent child relationship one child could have many parents one parent could have two Childs like there are multiple parent uh child relationship which is maintained it adopts a structure like graph as you can see a structure like graph is obtained offering more flexibility compared to the hierarchical model again in this particular model one parent can have many Childs and one child can have many parents so uh in this particular model there is more flexibility in compared to the hierarchical model but again these particular model is also not very widely used so let's learn about the data model which is like very widely used so the next model is the relational data model uh about these data model I guess we learned in the starting videos itself but let's understand again so organizing data into tables known as relation consisting of rows and columns characterizes the relational model it stands as the most prevalent data model rooted in the principles and of the set theory and relies on structured query language for data man potion so basically what is database database is kind of collection of interrelated data so what does this term means interrelated data so inter related data means now when data like when the table are somehow interrelated with each other consider there is one table which is having details about student first name last name role number consider second table which is having uh details about student subjects then the co-curricular activities and much more things so these two data have a relationship among them they are mostly related to student only student information only so whenever there is like relation between two tables or two you can take it in this way table one and table two so whenever there is a relationship between two tables it is called as relational data model now uh basically it uses the structured query language for making queries like manipulation of data insertion of data deletion of data and much more things also this relational data model is most widely used here you can see this particular table table is also called as relation in data base rows which is also called as tles and columns which is also called as attributes and here there is a constraint which which is called as primary key which is a unique identifier so this is a table which is also called as relation that is why this is called as relational data model because somehow there is some relationship between different relations that is different tables so collection of interrelated data is database where there are many tables and all those tables have some relationship between them so that is why we call it as relational data model now the fourth model is the entity relationship model which is called as ER model so it basically deals with entities and their relationships entities is also called as objects so basically this data model is utilized for crafting relational databases the ER model represents data through entities attributes and relationships connecting these entities so consider student is an entity now student might have some relationship student studies student is a enrolled student and much more things so basically the relationship which is defined here is study now student does study now student may have some attributes like may have some properties ke student have like student name student role number student address and much more things so that is called as attribute so basically it is student name which is a attribute like the property of the student entity is basically a single object you can say student is an entity or any real world uh entity or object could be used here and then relationship that what it does and what the relationship it has with other people as well other things as well so basically student might have a relationship with course which is course is also allog together a new entity so there might be some relationship so that is represented here then there is entity and then there is attribute which is basically the entity properties so the next data model is objectoriented data model so objectoriented data model basically extends the principle of oops that is objectoriented programming into database domain and this model depicts data as objects complete with attributes methods fostering support for inheritance and encapsulation so consider that you have a your front end which is written using oops now you want a back end which would be compatible with oops so there this particular Model come into picture so it basically stores data in form of objects and also it uses the object-oriented programming principles it is also helpful in achieving inheritance and encapsulation also in objectoriented data model basically it is kind of a combination of objectoriented data model plus entity relationship data model because in entity relationship data model entity is treated as an object here also data is treated as an object now the next and the last data model is no SQL data models so basically in the no SQL databases in incompass a diverse are of data models such as document oriented data model that is mongodb key value data model that is redis column family that is Cassandra and graph that is neo4j these models are designed to offer scalability and flexibility when handling extensive volumes of unstructured or semi-structured data so basically no SQL database models are something in which we don't use the SQL database for making queries also we don't use uh like it doesn't follows any traditional approach of relational data models so in this data model the data is stored in the form of key value pair the complexity is a bit less and also it is very scalable and can be used anywhere so most popular nosql database which everyone uses is mongod DB it is like very widely used and it is also very helpful to fetch the data because again it is uh stored in key value pair which is also using hashmap for storing the data so data Independence is basically a fun fundamental concept with database design and management emphasizing the distinction between the logical and the physical dimensions of data storage and administration in a database management system this principle yields various benefits such as enhanced flexibility heightened security and simplified maintenance now do you remember in the schema video as well and in the abstraction video as well I told you about some s like view level conceptual or logical level physical level so if you're not remembering it right now I have a picture about that as well yeah so this is the diagram for the same so basically let's understand what is data Independence and how it is helping us to achieve more flexibility and higher security and much more things so basically in data Independence what happens now as you can see from the term data Independence so somehow we are making user independent of the data so basically data Independence here means now at any level either it be physical level either it be logical level either it be view level at any level if there is any change it won't affect the other levels so basically consider that there are three levels physical logical and view physical level basically deals on where the data is St logical level basically deals on what data is stored and view level basically deals on uh you can say virtual tables or views based on user requirements so basically this is a brief about all the three levels so in the physical level we are majorly concerned about where our data is being stored in The Logical level we are basically concerned about what data is being stored and in the view level according to the user requirements we see some kind of virtual tables consider like I am working in a factory right so there would be many people in the factory one would be a Salesman one would be someone who is looking into some other details in the factory so for like each member there would be some uh different database which would be shown to them also we can take an example of Library considering Library there are many people there are students there are then Library staffs then there is a a person who looks into all the databases so for the students there would be some data which would be visible for the librarian there would be data like when the student issued that particular book what is that particular book what is the price of that book and much more things would be visible and for the library uh for the person who is looking mostly into the database or a higher level Authority they would be having access to the librarian data as well as the student data so according to the requirements like if I am a student I I want to see these particular fields in that particular database or that particular column in that particular database so I can see that according to my user requirement if someone who is a librarian he he or she wants to see that which student issued which book on which particular date what is the price of that book what is the student idea and much more thing he or she can see that so basically in the form of virtual tables we get to know data according to the user requirements so this is about all these three levels so here data Independence what happened now data Independence says that if there is any change at physical level there won't be any impact at The Logical level so if we are making any change in the physical level The Logical level won't be impacted uh so basically this is also called as physical data Independence so in physical data Independence it says that any change which is which is happening at the physical level it won't affect the logical level uh let's understand it from an example so let me just erase everything and then we will see the example so yeah okay so physical data Independence so consider that uh let's take an example of book okay so there is a database of book okay consider that right now it is stored in an hard disk the database is stored in an hard disk like the number of books which is available at a particular library now consider one day since there is like lot of database we thought to Move It from hard disk to cloud storage so basically uh earlier the database used to reside in the hard disk but now the database has been migrated to cloud storage like you can also take an example of uh like various e-commerce platform so some e-commerce platforms or some e-commerce companies which used to exist 20 years earlier and are existing now as well so they might have some data so it sounds very Vaga from 20 years they are using the same source for uh their data storage and everything they might have migrated it to some different places they might have opted some new techniques for data optimization and much more things so basically whenever we are doing this migration from hard disk to cloud storage there is no effect which is seen in The Logical level so basically whenever we are doing anything on the physical level logical level is not affected and that is called as pH physical data Independence so basically any data change or like any data change I can't say but any uh thing which happens in the data like uh uh the data storage has been removed from one place to another or any change which is happening at a physical level won't affect the logical level so this is called as physical data Independence now the second one is logical data Independence so basically in logical data Independence what it means if any change is there in The Logical level it won't affect the view level so basically in logical level what could be the changes so basically in physical level we deal with where the data is stored and uh in logical level we basically deals with how the data is being stored like in the form of U tables rows column how many columns are there what are all are the constraints and much more things we deal with consider that again I'm taking the same example so I have a book database right now in the book database I have different factors such as book ID book author so right now I am taking these two columns into consideration so I have ID and I have book author for this particular book database now consider I want to know more about like what are the types of books like uh are there any Thrillers or are there any books which deals into drama and much more things so so I want to know about the type of the book as well so what I'll do I'll add a new column type so basically what I did I added a new column which is called as type okay so since I have added a new column there is some kind of change which is happening at logical level but it won't affect the view level how so consider that uh earlier I wanted to see the ID and book so I was doing a select ID book author from book okay and now again if I like uh this was before achieving logical Independence before achieving logical and again after achieving logical if I run the same query I would be seeing the same same data right so uh according to the user requirements we are modifying the data but consider that there are two users who are quering into the database user one and user two so if user one is making any change user two is not affected by this change so that is basically whenever we are doing any changes in The Logical level like addition modification or something it's not affecting the view level uh at all so this was all about physical data Independence and logical data Independence I hope you got a slight idea about what is data Independence so I'm just reiterating everything data Independence basically mean at any one of the level if we are making any change it does not affect the upper levels or the higher levels now there are two types of data independence first one is physical data Independence second one is logical data Independence in physical data Independence if we are making any changes to the storage or like where the data is deciding or like much more things are there but again I'm taking the example of only storage of the data so if we are storing the data at a particular place and we are moving the data to next place it doesn't affect the logical level and in The Logical level uh logical data Independence what happens if we are making any modification at The Logical level consider addition or modification of any columns or change in any constraint it won't affect the view level so basically data Independence helps us to ensure that at each level if any change is happening it is not affecting the others level so in this particular video we would be looking more on the essential components of table so again you would be saying why you are teaching us what is row what is column but again there are some words for rows some words for column and much more things so let's look at it and then we will uh start with all the ER models and then the SQL queries and much more things so basically the very first term is row or tle so basically the row like in table what we say is ke this is a table okay so this these are the columns and these are the rows but consider that someone ask you like what is the value what are the elements present in this particular Tuple it might sound confusing now sometimes because we generally remember these terms rows and columns we don't know what is tle we don't know what is attribute so in like this particular definition we are definitely going to learn ke row is also called as tle and column is also called as attribute in dbms so basically rows are known as records see we got a third name as well right so first is row second is tle and third is records so rows are also known as records or tles and it represent individual entries or instances of data within the tle within the table so basically again uh if we are uh inserting any individual entries for some particular columns like consider name consider class consider uh roll number so if we are giving some individual entries for everything that is a row like uh the place where we are giving individual entries in the table so uh there is one more term which is kind of can be asked in your online assessment test of like one mask or uh in your like semester exams as well because like again uh people tend to forget the name like tle for row and record so there is one more thing which is cardinality so basically what is cardinality now the number of rows in a table is called as cardinality consider that this is my table okay so this is the table I have consider it is a book table now someone ask me what is the cardinality of this table so what I'll do is I'll kind count the number of rows so this is R1 this is R2 this is R3 and this is R4 so all together the cardinality becomes four so cardinality is basically the number of rows in the tables now the second term is columns or attributes again the column is a name which is a very generic name so we tend to remember that attribute is something we tend to forget so column is also called as attribute column represent the attribute Utes of the data being stored and are named to describe the information they hold consider like ID name and age so basically columns are basically the attributes the table is having like consider that I am a person I may have some attributes like I may have a ID I may have a name I may have a age I may have a RW number and much more things so basically all the attributes of mine I can store it in table uh in the column in the tables so basically column represent the attributes of the data which is being stored and are named to describe the information they hold so consider that U there is a table consider so now I give here R I should have make a bigger table okay so this is a table and here it is reti and here I have given 99372 dot dot dot now can you understand what is r and what is 99372 dot dot so basically what we do is now we give a attribute name so basically this is a the name is re and phone number is this thing so basically whenever we Define any attribute for all the entries which are feeded in the row that is called as column so again as we read about cardinality in row there is one thing which is called as degree which is also the number of columns in a table okay so T is a typo so number of columns in a table is called as degree so basically for this case the number of columns are C1 C2 C3 and C4 so overall the degree becomes four so basically cardinality is the number of rows degree is the number of columns rows is also called as tles or records column is also called as attribute so you can remember all these terms now coming to the next slide this is a table which I have taken for reference so basically you can see these are all the rows or tles these are all the columns and attributes so is to we got a clear understanding what is rows and what is columns but what is this term primary key like what is this primary key so primary key is something now which uniquely identifies the table so let's look at it in the next slide so basically keys are at number two but let's see with the constraint and then we will come to keys so what are constraints so constraint Define rules or condition that must be satisfied by the data in the table common constraint which include uniqueness nullability default values and much more things so consider I'm making a table in that table there could be some fields which could be null there could be some fields which couldn't be null consider that I'm making a table about person and I am uh like mentioning like I'm making AAR card of a person so in the Adar card of person I want name I want the first name I want the last name okay but middle name is something which a person may have may not have so that column could be null as well so we can set ke take it this column can be null but the first name and last name is something now which is required so we have to mention that columns are not null so we put a constraint that these columns are not null and this column can be null or something so these constraint help us now even if I am like feeding any data and if I forget to put the first name of a person and I just put on the last name it will give me an error or it won't like it will show a error in the database itself so consider like this this example which I told right now so for Adar card details I have the first name I have the last name and I have the middle name so this is something which can have null values but this is these both are something which cannot have null values so these particular type of things now these particular type of checks whenever we put on in our database that is called as constraint it basically ensures ke we are not putting any kind of data in the database there are some constraints which we need to follow whenever we are putting data into the database so there are many constraints first one is the unique constraint which ensures the value in a column are unique across the table so if there are values in a column consider ID so I need to take care that ID is something which should unique uh which which should remain unique for all the entries which are there in the database so for that case unique constraint comes into picture now the second one is not null constraint as I gave the example of this Adar card ke first name and last name couldn't be null so we put a Nal constraint now the third one is check constraint which enforces a condition to be true for each row so there would be a check constraint that consider like there is a person and for them voter ID can only be made when they are over 18 years so there would be a check on the birth date that check if the birth date is over 18 years then only we can uh make the voter ID of a person otherwise we cannot and the fourth and final one is default constraint so it provides a default value for a column if no value is specified uh for this what example I can give you okay so consider that okay consider you are in Nursery class so you might have a name you might have some date of birth and you might have a section and consider in your school there is only one section that is Nursery a so what it will do now it will feed the name it will feed the date of birth but when it comes to the section there is only one section A so what we do is we make default as a so if I somehow lift this particular field uh field which is not filled so uh basically it will take the default value and it is feed it as a so default values what it ensures ke if the column is not having any values they would be having a default value as this so like these all terms are now you can understand from the very first thing first name of this unique so something very unique not null so something shouldn't be null check so there is a check on true or false or if there is a condition and we are checking it on the basis of that default constraint something default we are putting a value so what from the very first letter you can like from the very first letter you can understand the meaning of all these terms now the very last is Keys which I showed you here as well this primary key now what keys help us in so key what basically does now it ensures that there is uniqueness in our table so basically a primary key is a unique identifier for each record record is also called as row so each record in the table it ensures that each row can be uniquely identified and existed within the table so what does this means so consider I am having a table okay now I am having having a table as name I'm having the table name okay just me let me make a big table now so I'm just making a more big table okay so this is name this is uh consider address and this is considered phone number consider there are twins and both of them have the same names so consider that I and my twin both are having the same name as RTI and we both live at the same place that is bangaluru and the phone number is also same for both of us now since we are twins I know we might have same name we might have same address we might have same phone number but there would be something unique between us now there would be something unique uh this particular person is considered having a rle number one I am having a role number two or there should be something unique which could like at least identify my entire entries in that particular table like uh it is for REI 1 or it is for RTI 2 so basically uh what primary key does now consider if I add a new column called as ID and here I give ID 1 id2 now whenever I need to see data for one I'm considering twins but I'm saying like whenever I need to see data for RTI one I'll just make a query based on ID it will give me all the required data whenever I need details about R2 I'll make the query based on the ID and it will give me the entire data for R2 so there might be a possibility now many rows may have same data consider you are having the same address and your sister is also having the same address you are having the phone number of your father and your sister is also giving the your sister or your brother is also giving the phone number of your father so there might be a possibility that there could be same data which exist in the database so for that thing primary key is uh introduced which uniquely identifies all the records or all the rows in the table so it is basically kind of a unique identifier which uniquely identifies all the roles for a particular person uh or all the records for a particular person again there are two keys primary key and foreign key again I'm not discussing in much depth about all like these keys and just discussing about these terms because these terms would be used more and more from now and you should be having a proper idea if I'm saying that it is a record so you should be able to understand okay record is something which is called as a row or if I'm saying tle then you should also understand okay it is a row or attribute column so you should be having that proper understanding now the second key is a foreign key so a foreign key is a field in a table that refers to the primary key of another table it establishes the relationships between two tables now consider that there are two tables okay and both tables have somehow data about me only first table is having data about my name my age my role number and second data uh second table is having uh like details about my phone number and my address so there are two tables which are having same data about me what if there is one particular field ID which is there in table one as well and table two as well so uh if there is a ID section in table one and table two which is kind of having similar data we call it as foreign key so foreign key is basically a field in a table that refers to the primary key of another table it establishes relationships between tables so basically it helps us to establish relationship between two different tables so when we will be going in the query part and the SQL query part or in the ER model itself and we would be proceeding ahead I'll be explaining about all these keys in very much depth but it's just that for you to have reference so that you don't miss out the next videos so this was all about this video I hope you like this video this was a very uh beginner friendly video so I hope you don't curse me for this but again guys see I'm trying to like cover each and everything because it should be something which should be beginner friendly everyone would be able to understand a simple terms as well right uh I've seen my friends who are like very good at dbms but if they were asked in the interviews like tell me what tles are there the cardinality or the degree they weren't able to say that and it is a very minor concept now so it throws an image on the interview that the person hasn't read it very well so view is a virtual table that is derived from one or more underlying tables this means that it doesn't physically store data but rather provides a logical representation of data so from the definition it is evident that view is something it's not not a like it's not a table which is already created it's kind of a virtual table so if I need some data about like ID a student ID student name and student rle number and I have a database in which there is student ID student name student rle number student subject and much more things so I can just create a view and I can just get the all the data which is necessary to me so basically views is also called as virtual table like the table is not created in the memory but uh we get all the details through this virtual table so in views what happens now can we see the table according to the user requirements now consider I am having a e-commerce website consider a shopping website okay so let's just feed some data here so ID is one name is Rahul phone number is consider XY z address is Bangalore pin is uh again I'm giving some random values 192 and age is 18 now here also I'm giving some data here also I'm giving some data let's keep okay so basically I have this database which is called as customer database so I'm having a customer database as I'm running a e-commerce website there would be a database in which all the things would be stored so consider that there is one customer customer one it places a order in my website now what it will do is ke it will generate some ID for that particular customer it will feed the name the phone number the address the pin and the age of that particular customer now consider that there are many teams in the shopping website one is the team which is logistic team one is a team which basically looks on the marketing and different other teams okay so consider there is one person from the marketing team name AJ and there is one person from the logistic team name VI okay just a raming ramming word so basically Ajay is a person who is majorly focused on the marketing of the website and the shopping website and Vijay is a person who looks on all the logistics like the order delivery if the order is placed correctly or not if the order has reached particular person or not so there are two person now consider that AJ want to see some details about the customer now AJ is a person who is from marketing so does it make sense that I send the age of the person or I send the pin of the person or I send him the like address of the person like I creating a table he's making a query in the table so does it make sense that all these three fields are something which would be something conc concerting to him it won't there would be another field consider just give me a second okay yeah yeah actually there's no space okay just uh forgive my bad handwriting consider there is one more column in the table that is order so consider that this person order some top this person order some tea and this person order skirt so AJ basically from the marketing team now he would be more concerned about how I can raise the marketing how I can raise the sales so what I'll do if a person is someone who orders tea most of the time I'll show him most of the ads regarding the tea I'll filter his uh search and like there are much more things which I can do to increase the marketing but again am I considered about the age of the person am I considered somehow age is also considered but am I considered about the pin of the person am I considered about the address of the person or am I considered about the phone of a person phone number of a person person no I'm not so basically I'm from marketing team I just want what type of order this person makes and age to some extent because I can see uh I can like filter some of the items for a person who is above 18 some of the items for a person who is less than 18 so mostly I'm concerned on that particular factors so what I'll do I'll make a query in the table and it will show me two columns only first one would be the okay just it's two columns only so first one would be the order age so basically order and age is something which I am mostly concerned about now consider Vijay is a person who is from the logistic team now the logistic only needs to know what is your name and what is your address along with pin and everything but if a person is from logistic is he concerned more about your age what what would he do after knowing your age right it doesn't makes any sense to him to know your age right he's more concerned about like what type of orders you have placed what is the address of yours what is the PIN code of yours so that the order could be delivered at time but he's not consider uh like he's not very much bothered about your age and much more factors so views and virtual table what it does now it shows me the fields it shows me the table according to the user requirements so if one person is from marketing one person is from Logistics so in the marketing person marketing person will see all the fields which is concerned to him the logistic person will see all the fields which is concerned to him but it's kind of a virtual table a new table is not created from the existing table it creates a virtual table which shows me all those data but the database remains unaffected so basically this is view so view basically views or virtual tables is something which shows us all the required details according to the user requirements so this is a small uh like very small concept and dbms but people tends to get confused on this views in dbms so again reiterating the same thing views or virtual table is basically The Logical representation of data where we see data according to the user requirements if a user is from some particular team like marketing team he would be only more considerate about the data which uh deals with marketing like orders then the age and much more things and if a person who is from logistic team is more concerned about the address PIN code and much more things so basically keys keys in dbms make sure of data Integrity uniqueness and quick retrieval of information key is an attribute in a table so let's understand from an example so consider that this is a table which is a student table okay now in this particular table let's have some rows and let let's have some columns so I am having three rows and four columns so let's just name them let's name it as ID let's name it as name then let's give it as registration number and let's provide this as address okay okay so like uh if you remember in the earlier videos I told you that the rows and columns in the particular table is also known as like the rows is also known as tles or records and the columns are also known as attributes okay so basically what is happening here is we have taken a student table in that particular table there are some of the attributes or some of the columns which are like ID name registration number and address so let's fill in some data here 1 2 2 1 2 3 name let's consider just a random example a a and here address I'm taking it is XY Z okay so what is happening here is there is uh three entries or three records which is present in this particular table now what is key key is an attribute in a table so this is a student table right so in this student table what are the attributes let's list that down so first attribute is ID second attribute is name third attribute is registration number and fourth attribute is address so basically these all are keys so key is basically an attribute in a table now there is one more thing uh what we have seen here in the definition is keys in dbms make sure of data Integrity uniqueness and and the quick retrieval of information so how keys are playing role so consider that I want uh like all the details of a person whose ID number is one so if I make a query in the database with uh like uh give me the person whose ID is one so if I'm making that particular query what will happen I'll get all the details of that particular person or that particular student which is present in the database so it will help me for a quick retrieval of data because again I don't need to Pro provide whose ID is one whose name is this whose address is this so all these attributes or all these properties I don't need to Define I can just get the data with a single property so Keys uh always help in quick retrieval of information now coming to the uniqueness part so uh like in the further slides you will see about candidate key and primary key so what is uniqueness now consider taking this example only here you can see ke the person who is having ID 1 is also having name as a the person who is having ID3 is also having name as a so there could be a possibility that two persons can have same name right or two students can have same name so if two students are having same name and if you're making query based on name which data it will show it can show any data right but you want a data of student whose ID is one so if you make a query with the with the use of name that give me the particular details about a person whose name is a so you might get this particular data as well or you might get this particular data as well right so but to get a concise data to maintain the uniqueness in the table there is a concept called as primary key which comes into picture which we will be seeing in the further slides but just to make you understand id is something which would be unique okay so student a is having an ID 1 student B is having id2 and student a uh like the name is a is again having an ID3 so ID is something which is not duplicated or There Is Not Duplicate data which is present in the database so ID is something which is always generated whenever a student record is being feeded or ID is something which would remain unique for all the students so ID is something which is helping us to maintain the uniqueness in the table or the database so uh and data Integrity so data Integrity is something like if you have some Integrity constants which is present like consider that ID is something which is giving me uniqueness or providing me uniqueness in the table what if I put as ID as null so there are some constraints we put that this particular field can't be null this particular field should be unique this particular uh field should not be null or this particular field should be null so there are some unique constraints we put on the basis of which we can always feed the data in the database so if considered that I fe uh like if consider I'm making this particular attribute ID as not null so I can never leave this ID if I leave that ID and fill in the data or uh like create a query to insert the data it will always throw an error so there are some constraint which are being introduced to maintain the data consistency data integrity and much more things so keys are helpful in maintaining the data Integrity then the uniqueness and then the quick retrieval of data now let's jump into Tech type of keys so basically here I have listed on four types of keys first one is candidate second one is primary key third one is foreign key and fourth one is super key so let's have a quick look through on all these keys and understand it with an example so now the very first key is the candidate key so you often have heard this term primary key like in many prior videos of mine but you haven't have heard this term of candidate key so let's understand what candidate key basically means and how it is helping us in uh like what is the proper significance of candidate key so basically a candidate key refers to a group of attributes that are capable of uniquely identifying record within a table among these one is selected to serve as a primary key for example consider for student all the possible attributes for candidate key could be student this is a table where ID is a attribute role number is an attribute Adar card is an attribute so uh let's understand from an example itself so there is already a table which is present let me just create one more okay so again we are jumping back to the same example which we have seen in the last slide so there is a table student which is having ID name registration number and address okay this is the same example which we used in the last slide so right now I'm not filling much data I'm just giving again some random values and here let's keep it as okay so I have just put on some random values in this particular table now this is the table so let's list down this table entities so student is the table the attribute of students are student table is ID then the name then the registration number and then the address okay so these all are the attributes of the student table now in this attributes there are some of the attributes as I told in the early St ID is something which uniquely identifies records in the table so there might be some of the attributes which would help us for a uniqueness to maintain a uniqueness in the database if that particular key is or or that particular attribute is present if I make a query in the database using that particular attribute like suggest if I'm making a query in the database using ID where the person ID is this or if I'm making a query in the database using a registration number ke the person registration number is is this so it will provide me a uniqueness it will uniquely identify all the records all the records means all the records which are present for student consider there are three records which are present in for student so there is an attribute using which if I make a query in the database it will uniquely identify all the records in the table so basically what is candidate key candidate key basically refers to a group of attributes which are like which uniquely identifies records in a table and which can be served as a prim primary key or a possible option for being a primary key in the table so uh here I have listed down all the attributes now see name is something again there could be duplicate names there could be like there could be two person with the name Rahul or there could be two person with the name Raj as well right so name is not something which uh can uniquely identify records in table because again two person can have the same name now coming to the third thing is registration number now registration number is something which is generated at the time of admission so every person who is taking admission would be having a unique registration number so registration number is something which could help me to uniquely identify all the records or all the rows or all the details which are present in my table so registration number is a possible uh option for a candidate key now coming to address now address is also something like two people can have like address is also a attribute which have like lots of things like the street like the PIN code the area and much more things so area is something which could be like similar for two person Street could be something which could be similar for two person obviously house number is not something which could be similar but again area is something street is something like address is something which is further divided into many subsections right so for now I'm not considering address as a uh possible option for candidate key but again address could be but again it's like like you have to feed the entire address for that particular person like uh one person who leaves in Street a house number this area this and state this with pin code this right so um here there could be two possible options first one is ID and second one is registration number so ID and registration number is something which could help me to uniquely identify records in the table let's not make it as make it straight okay I guess now some doubts are clear so I thought address was something which was confusing now street so street is also something which could be same for two persons so I can't make that street as a possible option for a uh candidate key or a group of attribute which can uniquely identify records in the table so here we have possible options as ID and registration number so for me the candidate keys are ID and registration number uh explaining in one word candidate keys are the group of attributes which are possibly helping us to uniquely identify records in a table and again in that collection we choose a primary key from that particular collection only for our table so this is candidate key now the second key is primary key okay so primary key is like most important it would be used many many places at many places it might have been used in the earlier videos as well so understand it very clearly I guess uh candidate key if you have understand primary key is very easy to understand but let's just have a look at what is primary key and then let's understand it from an example so a primary key is a key which uniquely identifies records in a table again there were some keys which we find out first one was ID second one was registration number which was helping me to uniquely identify record in a student table right now it ensures that each tle or record can be uniquely identified within the table now this line is very important so it is always unique plus not null so primary key something which would all always have a constraint of unique plus Nal as again I explained in the earlier slides key if consider that I'm making ID as a primary key in this particular table okay so ID is a primary key now I feeding the record for all the particular uh for all the students which is present in my like task list or wherever Excel sheet so I'm feeding all the records of that particular student consider that while feeding I left ID for a student like by mistake I didn't fill the ID so it will throw me an error because again I'm saying that uh ID is something which is serving as a primary key so it should always be Nal and it should always be unique what does unique means unique means can not none of the two person can have the same ID and notal means that particular field can be left uh or that particular need field needs some value so basically uh starting from keys keys are something which uh like attribute of a table so keys are basically attribute now coming to the candidate key so candidate key is a group of attributes which uniquely identify records in a table now coming to primary key so primary key is a ke from all these group of attributes now from all these group of attributes there are attributes like ID consider that there is a attribute called as phone number there is a attribute called as Adar card let me just type it so consider that there is a student table so since student is a like vast table it would be having many information like student ID student name student subject student fee details student phone number student address and much more things so right now I'm just considering few of the things so consider the student table has ID Adar card number phone number and registration number okay so these are all the group of attributes which are possible or which are a option for candidate key now consider uh like start from ID or start from Adar number so basically id id would always be unique and there is no place that ID could be left U null right so ID is a good possible option to be a primary key right now consider Adar number nowadays uh the government of India has made it mandatory to have an AAR card for everyone but there could be a possibility that one of the student doesn't have an Adar number or one of a student doesn't have any pan number uh like let's consider pan number as well so there could be a possibility that one student has a pan number one student doesn't have a pan number right so it is somehow violating this fact it should be unique and it should be notal I can't make the pan card number field as not not n because many students can have pan card many students can't have pan card right so a pan card or adhar card is something can't be right now considered a possible option for primary key yes they qualify for being a candidate key but again for primary key they doesn't qualify because there is always a constraint which is there that is unique plus not null now coming to phone number consider that a parent has two childrens and both of Childrens are going in school for studying both of them are in the same class and then again they are giving the phone number now their father's phone number would always be same right so two Fields would have same value again it it is somehow violating the unique plus not null constraint right so it cannot be a possible option for primary key now coming to registration number as I told that registration number is something which is generated at the time of admission right so every student would be having a unique registration number so registration number is something which can qualify for a primary key so either of them can be a primary key right so basically candid uh coming from keys keys is a uh like Keys is basically attributes of the table candidate key is basically group of attributes which uniquely identifies records in a table and primary key is a key which uniquely identify records in a table having the constraints such as unique plus not null so if a attribute or if a key has a constraint which is unique which is not null it is a primary key so now the third key is foreign key so what is a foreign key a foreign key is a field in a table that refers to the primary key in another table it establishes a relationship between two tables so what is foreign key foreign key is basically a key in another table which acts as a primary key in the prior table so let's uh understand from example consider that there is two tables first table is a student table second table is the subject with the student has opted for so the first table or the table which is being referenced is called as as reference table or base table or the table uh which is like kind of referencing from other table is called as referencing table now here the student table has the attributes such as R number name and Hometown and here the subject table is having attributes such as R number name and subject now can you see this R number which is present here as well and here as well right so there is a RW number which is present in referencing table which is called as foreign key because it was a primary key in the base table so basically a foreign key is a field in the table that refers to the primary key of the other table and how it helps in establishing a relationship again student and subject there are two tables and they have a relationship between them student studies a particular subject like uh the student name is this and the subject he has opted is maths so basically in student table and in the subject table there is a kind of relationship which is being established and there in the relationship or in the referencing table like there is a table from which we are taking a reference and we are making other tables so basically from student table we can make like many tables right there would be many tables which would be referencing from the student table consider a subject table consider a fee table or consider other tables as well right so there would be many tables from that particular base Table and there would be some relationship of that base table with the referencing table and in that referencing table the uh the attribute which acts as an key is called as foreign key because it is being referenced from another another table so basically foreign key is a key which acts as a primary key in the ref reference table so basically this is all about foreign key are fill in a table that refers to the primary key in another table so basically what is happening it is referencing this particular attribute so here for this student table R number is the primary key and for student table in the subject role number is foreign key so I don't want to extend the video very long I guess it has been more than 20 minutes the video has gone to so let's discuss more about foreign key candidate key primary key uh in the coming videos we would be also discussing about super keys and we will be Sol solving many questions to understand in depth what is candidate key how it is helping uh how it uh it is providing a possible option for primary key and much more things there are so many numericals as well so I'll pick two or three and we will solve that numericals as well so this was all about keys in dbms just to give you a summary key is an attribute key is like you can say that all the attributes which are present in a table can act as an key if they provide uniqueness if they ensure data integrity and if they ensure the quick retrieval of data now coming to candidate key candidate key is a group of attributes which could possibly be served as a primary key or group of attributes which uniquely identifies record in a table now coming to primary key primary key is a key which uniquely identifies record in a table but there is a constraint that that particular key or that particular attribute which is be choosed as primary key should always be unique plus n Nal and foreign key is a key which is uh which is basically acting as a primary key for another table so basically these are all about the keys so here we are seeing foreign key but I want to re- revise the concepts of last as well so basically what is key key is basically attribute in a table so any attribute in a table is called as key now what is attribute so if there is a table there would be some rows there would be some columns so basically all the columns is called as attributes and all the rows are called as t in a table so basically attributes so key is any attribute in a table now what does Keys help in key help us to maintain the uniqueness in the table key help us to maintain the data consistency in the table and key also help us to get the faster retrieval of data so basically Keys helps in many ways now next we saw a concept called as candidate key now what is candidate key candidate now as I told now key might have three properties first one is key it ensures uniqueness second one is ke it ensures faster retrieval of data and third is ke data consistency okay now in candidate key what happens now candidate key is basically a set of attributes which can uniquely identify records in a table so what that does that means is he consider that there are attributes consider that this is student ID this is a student table there is a student ID there is a name there is a Adar card and there is a phone number okay so now in this table ID is something which would always be unique for every student right like consider that there is one student so for him the ID would be generated and it will always remain unique now for the next student also ID will always remain unique now for the next student also so these all rows are also called as records so for all the records the ID something which remains unique so it can be a candidate key so it qualifies to be a candidate key so in this candidate key this uh candidate key is basically the set of attributes or the set of keys we can say and here the ID is one of the key which help us to uniquely identify records in a table now the second one is name name is something like two persons can have the same name name so name is not something which can uniquely identify records in table consider that there is two persons who are having the name as Rahul and consider that I'm making a database query based on the name of a person so consider I'm making a query can select star from table where name is equal to Rahul now which Rahul data it will give me it can give me some inconsistent data but I want the data of a Rahul whose ID is one whose Adar card number is uh any 54 something like that take so we are here providing some details or we are here trying to uh fetch the details of a person whose ID is one and whose AAR card details is given so uh if I get the details of another Rahul it is like the incorrect information which I'm getting so basically name is something which can remain same for different people so name is not an attribute which would qualify to be a candidate key so for name we would discard this now coming to adhar card again adhar card is something which is unique for all the people so it will be unique for all the records in the table using the Adar card if you're making the query we can fit the details correctly and there would be a uniqueness like for if I'm giving AAR card number of a particular person I would be only seeing data of one person not two persons so basically Adar card helps us to uniquely identify all the records in the table so Adar card can also be a part of candidate key now the next one is phone number again phone number is something like it can be unique for every person or every person which is present in the record or every student which is present in the record so phone number can also be a possibility to be a primary key so here we can give phone number so basically candidate key is a set of attributes which can qualify to be a primary key or the set of attributes which uniquely identify records and table now coming to the third key that was primary key now what is primary key primary key is a key which uniquely identifies all the records in the table now you would be saying ke candidate key also does the same there is a set of keys which uniquely identifies all the records in the table then how come I can select a primary key so basically primary key is being selected from all the set of attributes which is mentioned in the candidate key so from all these three attributes one can be primary key now let's see that which one can be a primary key so now consider ID again ID is something which is generated whenever a student take an admission so ID is something which won't be okay there is one more constraint for primary key that any key which is having unique plus not null constraint can only be a primary key so any key which is having unique value also null value shouldn't be there because again it can't uniquely identify the records in the table so any key which is or any attribute which is serving as unique or which is having the constraint as unique plus not null is only qualified to be a primary now coming to id id is something which is generated every time the student takes the admission so basically ID is a good qualification for primary key now coming to adhar card there could be a possibility now few of the people don't have adhar card number like they haven't registered for the Adar card yet few people have the Adar card but few people don't have the Adar card so for them the adhar card uh attribute or the Adar card column would be null and again what we told at primary key is something which is not null so it won't be a good option for being a primary key in the table now coming to the phone number consider that there are two students and they both are siblings now they would be filling the details of their father phone number and father phone number is something which could be same for two people as well because two or three students could be there who are having the same father or they are siblings right so phone number is also not something which will uniquely identify because there is a possibility of duplicacy and again it will then destroy this unque constraint so phone number is also not something which will qualify for a primary key it can qualify for a candidate key but it won't qualify for a primary key so at the last ID is something which becomes our primary key so in short key is something which is attribute of a table candidates key is a set of attributes which uniquely identify record in a table and which can also qualify to be a primary key primary key is a attribute which uniquely identifies record in a table also primary key something which is unique and not null so any attribute which is having unique plus not null constraint is only qualified to be a primary key so this was all about candidate key primary key and keys now we will look on foreign key I'm just re- revising the concept because differential Integrity is something which is related to foreign key but just a revision because it is keys in DPMS so basically foreign key a foreign key is a field in a table that refers to the primary key in another table so basically Al what is foreign key foreign key is a attribute or is a field in a table which refers to the primary key of another table so what is happening ke there is two tables right in one there is a foreign key in one there is a primary key the t uh consider that there are two tables I'm just drawing table a and table B now consider table a is a student table and table B is a table which uh have all the details about students like the course they have taken or the subjects they are studying take so here there would be some columns here also I would say the word attributes so here would there would be some attributes here also there would be some attributes consider that here the attribute is ID name and uh name and Hometown consider and here the uh attributes are ID subject ID and and subject now what is foreign key so foreign key is basically a field in a table which refers to the primary key of another table so basically uh in table a the primary key is ID in table B right now I'm not more focused on primary key I'm more focused on foreign key so foreign key is ID because ID remains same here and remain same here so what foreign key is doing now foreign key is kind of establishing a relationship between two tables so table a and table B have a relation so table B is having a foreign key which is pointing to the primary key of table a student and course are two table student is somehow related to or have a relationship with course they have opted so course is having a foreign key and the student table is having a primary key now student table which is being referenced is called as reference table and uh subject table which is referencing other table is called as referencing table so basically here table a is there table B is there now uh let's take an example ke what if key these two are separate table table a and table B are separate table what if ke the foreign key in this table is ID but could the primary key be also ID is it a possibility if foreign key and primary key is same for table B so there could be a possibility the foreign key and the primary key for table B is same but again uh like there could be a chances of anything so foreign key and primary key for table B can be same as well can be different as well so it totally depends but again foreign key is something which should be present in the table we are referencing to right so reference table or the base table if it is having a primary key in the another table to stablish a relationship it should always have that primary key which is present in the form of foreign key so basically what foreign key does now foreign key maintains referential Integrity which is the video all about so I guess it's almost 10 minutes and we are now jumping to the topic uh prior was all the revision about keys and everything I hope uh everything is revised because I really need you to understand keys in depth and then we can jump ahead to referential Integrity so now coming to reference table and referencing table so basically what is a reference table reference table is a table which is having primary key PK and referencing table is a table which is having a foreign key so basically this table is having a foreign key which is basically pointing to the primary key of the base table so this is called as referencing table and this is called as reference table we would be using this terms all throughout this uh particular slides so please be careful about what is reference table and what is referencing table you can understand it in this way can reference table is something which is being referenced from another table so table B B is referencing to table a so table B is a referencing table and table a is a table which is being referenced so table a is a reference table or base table now what is differential Integrity in foreign key so basically referential Integrity now uh let's just break this term so it is referential integrity so what does integrity means integrity means now same thing everywhere so let's understand referential Integrity from an example consider that you are hungry right now so you have two three options to order food either you can order it via swii either you can order it via zomato either you can order it via Uber Eats like there are many options for you to order the food or either you can order it from dominoes Cloud kitchens and much more okay consider you want to have a pizza so consider in swie the price for the pizza is 154 rupe after discount the price of Pizza in zato is 152 and the price of Pizza in Uber H is around 150 so you can see that there are differences in prices in all the three apps zato uberit and swii so uh data is something now which is not consistent in all the apps the prices for the food differs in all the app so basically Integrity is something something which is not maintained here because again it all depends on the apps and the companies that how much profits they are making how much margins they are keeping on and much more things right so Integrity is something which says us there should be same data which is present everywhere for a particular thing like for a particular Pizza there would be a same price which is present on all the different platforms but somehow it is violating that thing because the for the same pizza at different platforms the price is not same so basically what happens in referential integrity referential Integrity is an important Concept in foreign key we always say foreign key maintains referential Integrity what is the reason behind we saying that foreign key maintains the referential Integrity so basically referential Integrity ensures that the relationships between the table remains accurate consistent and meaningful within a relational database so referential Integrity what it says is he consider that right now I am a college student okay so I'm a college student RTI who is uh currently in computer science branch and who is having a role number as 14 okay so if someone ask me in the entire College if someone ask any person ke uh get me the details of reti who is right now in uh CSC branch and whose role number is 14 so they would get the same data from everywhere like they if they ask my data in the library if they ask about my data in the admission corner or if they ask about my data at other places as well so the data Remains the Same my name my role number my ID everything Remains the Same there is no change in the data so basically Integrity is maintained here so integrity means in any databases if you are making any query there is a same data which is present for a same person so I guess referential Integrity is something which is a bit confusing but I've tried to break it into simpler terms and explain you but again in the coming videos we would be looking on how referential Integrity is being maintained in the databases how foreign key is helping us to maintain the referential Integrity what if key uh if consider that there are two tables and referential integrity is something which is maintained in both the tables now consider that in one table we are inserting something in one table we are updating something and they are somehow related with the primary key and foreign key relationship so what would be the effect on the tables and much more things so there are much more things we would be looking in the coming videos basically you can understand ke foreign key is something which maintains a relationship between two tables and there are some set of rules which make sure that the relationship between two tables which is maintained is accurate consistent and uh have a meaningful relation so basically to ensure that thing referential Integrity comes into picture and we have to see that what happens if we are uh inserting something if we are deleting something or if we are updating something from the reference table or the referencing table how the referential Integrity is taking place and what all violations of referential Integrity could take place since there are two two tables consider there is a table student and there is a table course okay so now consider in the student table we have some set of records and some set of attributes in the course table as well we have some set of records and some set of attributes consider here we have a student role number then student name and then student for phone number and here we have the course ID the course name uh the roll number and the course details so we have two tables student table and the course table they have some attributes such as roll number name and phone number and here course ID course name roll number and course details for this the primary key is roll number which will basically help us to uniquely identify all the records in the table or all the details about the particular student and here the r number is present and somehow student is related to course like student is taking a course so there is a relationship which which is maintained because consider now student there is a huge database of student student name student phone student address student rle number then what courses student has taken then what fee student is paying what is the attendance so there is humongous data about student so what we do is can we split it into a tables so basically this is a student table and this is having the details about all the courses student has taken now consider here I'm giving some RO number RO number 1 2 3 4 and here also I'm giving roll number R number 1 2 3 4 and uh other fields right now I'm leaving it as blank so here basically R number is the primary key now I want to establish a relationship between student and course so what it will do is ke here it will mark this as foreign key so what is foreign key foreign key is basically a key which uh targets to the primary key present in another table so basically it is somehow referring to the primary key in another table so this is a foreign key so basically a relationship is being established in this particular tables so referential Integrity help us to maintain this relationship referential Integrity help us to maintain the data accuracy RO number one is here so here also R number one is here the details are remaining the same and data consistency again if R number one is somehow removed from here and here the r number one is there so data is in consistent so basically it helps us in these particular ways now the table which is being referenced is called as reference table or base table and the table which is referencing to another table or which is pointing to the primary key of another table is called as referencing table I think I should point there like this so basically this is a referencing table and this this is a reference table now what if key we insert some data in the reference table what will happen to the referencing table as this table is particularly not having much of importance without the student table so what if in the student table we add some data what if in the student table we update some data as well as delete some data so what will happen in that particular cases so we will be seeing Case by case what happens and how we can ensure that these particular violations of rule if happens doesn't happen so basically now consider there are two tables one is referencing and other is reference table so reference table referencing table let's see how some operations like insert update and Delite works here so referential Integrity in foreign key insertion in the reference or the base table so consider again I'm making the same drawing I'll make it a bit quick so basically this is a student table and this is the reference table okay reference. base table this is the course table now it is having field as course ID course name and roll number and this is also having Fields like roll number student name and student phone number so I'm just filling two or three details so 1 2 and three student name Amon Raj R and phone number 001 02032 here C ID course ID I'm giving as 01 02 course name dbms operating system and R number is 1 and two so now I have made a tables and here it is a primary key roll number and here the same roll number is called as for key which is pointing to this now we are talking about what happens when there is a insertion in the reference or base table consider that a new person or a new student takes admission another day so I'll register his data or fill his data his name is uh his RW number is four his name is consider uh Radha and her phone number is 022 now if this insertion take place of R number four RHA does it affect this particular table think no it doesn't affect so because student table or student database is a database now which keeps on increasing every year some new student take admission in between the sessions also some new student take admissions so uh right now in the course table I having details about the students who have already taken admission and have already been assigned some courses but since this particular student has taken admission newly maybe he or she haven't been assigned any course yet so if there is insertion here and it doesn't violate any of the rules or it doesn't affect this particular table because this particular table is having details of student with r number one and two so R number three roll number four or even if there are some more R number 18 or 90 that be if there is some insertion it won't affect the table so basically if there is any insertion in the reference table it won't be affecting the referencing table now the second one is deletion in the reference or the base table so I yes it is a tedious task here to make table each and every time so again I'll make it a bit quick so this is a course table with C ID course name and course detail uh roll number and this is a student table with roll number name and phone number so this is basically the referenced or the base table and this is the referencing table so it is having 1 2 3 1 2 3 and uh 0 1 02 03 and here 1 2 3 course name dbms just making it with very fast and name consider r e f so basically there is a person R there is a person e and there is a person F so what happens if there is a deletion in the base table or the reference table consider role number three uh he or she has passed out from the particular uh school or college or consider that he or she had like her father or his father had a transfer and now she need to leave the school in the middle of the session so what happens when there is a deletion from the reference of the base table would it cause this particular table yes it will why because see here for R number three we have entered all the details ke R number three is having uh uh a course name uh is being assigned a course basically operating system and is having a course ID 03 so basically if I we are removing the r number three all the details from the base or reference table the referencing table does doesn't make sense which it will be pointing to so basically here the foreign key is pointing to the primary key of this particular table and if we are deleting any data here so where it will point do so basically it will uh consider I want the details for R number three so this particular field will not give me some any details because it is only saying role number three is having course name as this uh course ID as this but the student is not yet in the school so if the student is not in the school does this data make sense no so basically Whenever there is a deletion in the reference table we need to move it from the referencing table as well we need to remove the data from the referencing table so basically if any student has dropped out from the college or from the school there all the details all the data which is present needs to be deleted so it may cause violation if the corresponding data is present in the referencing table so basically if the corresponding data which is removed from the reference table and is still present in the referencing table may cause some problem and may cause some violations so to make sure that if some data is uh deleted from the reference table uh it's not present in the referencing table there are some methods and some tricks which can use so let's have a look so if a record in reference table is deleted or updated the corresponding records in the referencing table should also be deleted or updated to maintain the Integrity of the relationship basically integrity means data consistency data relationship data accuracy so what we can do is we can use actions like Cascade delete for the same also we can set null for the values deleted so what it will do now Cascade delete it uh what it will do if some data which is being deleted from the reference table what it will do it will delete it from all the referencing tables so basically uh if a person who is named ramed has dropped out from the college or from the school if we delete his data from the student database what it will do all the other tables which are referencing to student database they will Cask delete will delete all the data which is present in the other tables as well so basically cascet delete is a method which we can use to ensure the integrity M maintained or what we can do is we can set the values as null for that particular student whose record has been deleted but again there is a Twist ke uh consider that in the referenced table if a record is deleted and we set the value null in the referencing table like consider null null null what if this course ID is a primary key and we are setting the value as null here so primary key be null right so uh this null method is something which is not very much used or which I also won't suggest to be used because again if you set all the values as null what if uh any of the attribute is a primary key so primary key can't be null right so uh you can use this Cascade delete which would really help to delete all the data which is present in all the referencing tables now the third and the last operation which is left is update so updation in the referenced or the base table may cause violation because if the corresponding data is present in the referencing table so consider key again we are having two tables one is the referenced table and one is the referencing table now I'm just filling the data only for one field because it's an update operation so I can explain with a one field only consider there is a r number student name student phone number and student address and here it is course ID course name and course roll number so can R number is one two student name is uh RAM Raj phone number is something address is something U 012 013 address is a b c XY Z and here the course ID is 01 1 012 013 Cod name is dbms OS CN and the r number is 1 2 and 3 so consider that uh there is a update in the data what happens if there is a person with roll number three named R uh 014 and z z z okay so what happens ke if r number two which is Raj has dropped out from the college or dropped out from the school so what happens he his data is deleted from here as well and there as well what if K REI data like now RTI is RO number uh PRI RTI was RO number three but now RTI has been changed to R number two as R number two has left the school so there is an update in the r number right consider that there is more update in the student name as well like uh sometimes student give their half name or the first name only but according to to AAR card or according to the board marksheet they should be giving their full name or something like this so consider that there is any update in the data which is happening at the reference table so would it affect the referencing table yes it would affect because if we are updating the data here the data should be updated everywhere the r number three is now having uh computer networks and having the course ID is 013 so R number two data has been deleted so basically just like delete in update as well there is a command called as Cascade update which will update all the details for the particular person you are updating in the reference table so basically for insertion there is no violation for deletion and updation there is a violation so we should be using on casket delete on casket update to update in in the all the referencing tables and delete it from all the referencing tables what is a reference table and what is a referencing table referenced table and referencing table so uh like you can understand it in a way now can reference table is also called as base table basically reference table is a table now which is being referenced like consider that I have made a table it is taking reference from one table so that particular table from which it is taking the reference is called as reference table so basically you can uh think in a way the table which is having primary key is called as the reference table now the referencing table the table itself which is taking reference from another table is called as referencing table so here you can consider the table which is having a foreign key is called as a referencing table so basically this was referenced and this was referencing table now in the last video we got to know what happens whenever there is a insertion deletion or updation which is happening in the reference table now why we need to know this operations and what happens like how all these things are related so basically what happens now whenever there is two tables one uh there is one table which is having a primary key and there is another table which is having a foreign key which basically establishes a relationship between two tables now why this relationship between two tables is needed so consider there is a student database right now student database is such a huge database if we consider okay there is student name student role number student ID student address student subjects there are much more things right so there would be some multiple tables in which there would be student information stored there would be some tables which basically depends on student itself so consider that a student has taken admission into the school or college now the student may opt some subjects May uh pay some fees may be a part of some club or different things so club and like if the student takes the admission on only then he or she can be a part of Club if a student takes admission only then he or she can take a subject so basically subject is a table which is called as a referencing table which basically takes reference from the reference table so consider here the reference table is a student table and here the referencing table is the club they are a part of so basically referencing table is mostly dependent on the reference table referencing table has all the data which reference table like basically in the reference table all the data which is present in the referencing table you will get all the reference data for that particular person or for that particular student so for that particular student what is the club in which uh he or she is what is the subject he or she has taken so there could be multiple referencing tables for one reference table so there is a relationship between reference table and referencing table now uh what happens whenever there is some crud operations which is being performed on the reference table and referencing table so for the reference table as I told you ke Whenever there is an insertion deletion or updation there are some violations or there are some rules which is broken in some cases so what are these rules and why broken and violation means so much to us so basically what happens now let's start from the very beginning so there is a reference table now there are some subtes which acquire datas from that particular table or that particular database so there is a reference table called a student let's take it so there is a reference table called called as student now student is having so many referencing tables like the club with student is a part of subject co-curricular details and much more so basically this is our referenced table which is having a primary key and then these are the referencing tables which is having a foreign key now these two tables may have a relationship between them now there is a term called as referential Integrity what does this term means so basically referential integrity means now integrity means can same data in all the databases so what does this same data in all the database means so consider that there is a student Raj okay so Raj is currently a CSE student or an IT student now in the college whenever you will go to any of the cells of the college like the placement cell the admission cell the library the physics lab the chemistry lab everywhere you will find Raj with r number this and having a subject as CSC or having the branch as CSC you won't find any data of Raj where Raj is studying in electronics who is having the same RO number so basically in all the places in all the databases the data would remain the same so basically integrity means same data everywhere so referential Integrity are some set of rules which ensure that the relationship between two tables have the data accuracy have the data consistency and have the faster retrieval of data so referential Integrity are some set of rules now these set of rules May violate whenever you are doing any kind of insertion deletion or updation in any of these tables so basically uh uh we discussed in the last video about the reference table ke what happens whenever there is an insertion updation or deletion in the reference table basically in this particular video we would be mostly focusing on the referencing tables so uh it was just a recap for what we have learned in the last video I thought to give you that because if someone is new to this video won't understand what is the term referencing table reference table and foreign key primary key referential integrity and much more okay so let's start so basically the first is insertion in the referencing table so now let's make two tables first one is a student table and second one is the subject student has taken Okay so so here I am giving student a roll number student a name and consider student a phone number okay and here I am giving student a subject ID subject name and here the r number so basically 1 2 3 uh there could be many more students first is Raj RTI Rahul and phone number is consider 0012 0019 0674 and here I'm giving as ID as 01 02 03 subject name as physics chemistry maths and RO number is 1 2 and three so basically we have two tables here first one is the student table and second one is the subject table now in coming to the student table so student table has a field called as R number so R number is a attribute which can uniquely identify all the records in a table if I just make a query with the roll number can give me all the details of a person whose roll number start with start with two or who is having a roll number three it will give me all the details for that particular person so roll number is a primary key for us so basically an attribute which identifies all the records in a table uniquely so basically this is a primary key now since these two tables have a relationship between them so to establish that relationship there should be an attribute which is present in this particular table which should be present in another table so basically here this attribute is R number which is called as foreign key and it points to this so what is foreign key foreign key is basically a key or you can say collection of keys or collection of colums which basically refers to the primary key in another table so basically this foreign key is referencing to the primary key in another table they are having a relationship between them now the referential Integrity comes into picture which establishes some rules which should be there to maintain the data accuracy uh to ensure that there is no data inconsistency and faster retrieval of data now in this particular table first thing is insertion in the referencing table consider so let me just give the name it is a referenced table and this is a referencing table so the first is insertion in the referencing table consider that I want to insert some details in the referencing table consider Sid is for subject is biology and R number is four so would it cause any violation or what would happen so see now what is happening here we are inserting uh a particular Row in the referencing table now what will happen if we have inserted this particular Row in the referencing table but do any student present in the student table whose R number is four is there any student who who is having a r number four and is present in the student table there could be a possibility there couldn't be a possibility right so this insertion may cause violation because we are not sure that R number four exists in the student table or not and somehow this subject table is taking a reference from the student table so if this R number number four does not exist in the student table it doesn't makes any sense to add it in the subject table so in the subject table we had added key a person who is having role number four is having the subject name as bio and is having the subject ID as 04 but there isn't any student who is having a role number four exist in the student table so basically insertion may cause violation why I saying may cause violation because consider not there could be a possibility that role number one is taking two subjects physics or chemistry so I can insert data for R number one twice or Thrice or four or five times so basically uh it's not important key uh insertion will always cause a violation but it may or may not cause may not cause in a case key Whenever there is a r number which is present in the student table and for that R number I'm making an entry in the referencing table but it may cause violation Whenever there is an insertion for a entry which is not present in the student table now coming to the second one that is deletion in the referencing table so let me just quickly draw this is subject so this is RW number this is student name and this is phone number now this is to subject ID subject name and then this is R number so I'll just quickly give the datas 1 2 0 1 02 subject name physics biology name Rahul Raj R actually these three are the common name I use and 0 012 0 0 13 0 014 now again this is the primary key this is the foreign key and it is taking reference from the primary key now what happens ke uh what if there is a deletion in the referencing table so basically this is the reference sing table and this is the reference table so consider today I have deleted the data for R number two so I've deleted there is a r number two which existed and has taken a subject biology would it cause any evolation think it won't so why it won't cause any violation because see now there are many R numbers present in the student table so there is R number one who has taken a subject physics number two who has taken a subject as bio but what if role number two doesn't want to take a subject bio what if he or she gets promoted into next uh higher uh sections or higher classes and they don't want to take bio so it will be deleted from the database of the referencing table so does it cause any Evolution no right because see after 10 you get an option ke bio or maths so if I choose bio why would I take maths so I can delete this particular data from the database base of referencing table so basically it won't cause any violation whenever we are deleting anything from the referencing table even if the data present in the reference table so basically there might be a possibility there is a student uh uh student Raj with r number two who is now not having bio as his additional subject or bio as his subject now he's opting for math now the third and the last is the updation in the referencing table so uh actually I'm drawing these tables because I want want you guys to understand what is happening at the very depth so let me just make it very quick student subject subject ID subject name roll number roll number student name student phone number so here 1 2 3 here also one2 0 1 02 subject physics bio name Rahul Raj RTI and for number 00 1 002 0 03 any random values now what happens whenever there is an updation in the referencing table so basically this is the referencing table and this is the reference table so whenever there is any update in the referencing table what will happen think so basically Whenever there is an updation in the referencing table now what happens you consider that you want to update the student uh subject ID for that particular subject physics till then it's okay if you want to update the subject name what if uh R number one now wants to take maths instead of physics it's again okay but what if you want to update the r number so basically roll number is acting as a foreign key which is taking a reference from the primary key which is present in the student table so if you update the roll number consider you update the roll number to 10 but there is no roll number with 10 which exist in this reference table so does it makes a sense no so basically what updation does is if whenever you are updating any of the values which is uh any of the values apart from the foreign key it may not call cause violation but whenever you are updating the values which is uh acting as a foreign key or in the referencing table it may cause violation because foreign key is referencing to the primary key of the reference table and whenever we are making any update in the foreign key it may cause violation because the same details may not exist in the student table so R number 10 if we have updated this RO number from 1 to 10 there is no such student with r number 10 which exists in the student table so how it would take a reference there would be some data inconsistency so basically here we won't find any R number 10 and here we will find the details for RO number 10 who has has or who hasn't taken any admission yet so basically all these things happen whenever we are doing any kind of crud operations in the referencing table so what is integrity constraint now consider that there is already an existing database and considered there is a scenario where we are creating a database so in this existing database there would be some kind of update we would be doing in our day-to-day life or some kind of insertions we would be doing in our day-to-day life now for that insertion and for that updating the values of some particular Fields or some particular attributes there are some set of rules which needs to be applied before doing any kind of insertion or any kind of update in the database now why this set of rules is needed or why it it is so much important now consider that there is a student table okay so there is a student table in which we have Fields like student ID student name and uh just a second okay let me again draw it so basically we have a table of student in which we have two columns and some Fields first one is student ID second is student name and third is student age now consider that there are already some existing datas present in this table now consider that there is a new student who has taken admission in the school now I am inserting values for that particular student so I've inserted the student ID 03 the name is RAM and consider I've given the age ABC by mistake so if ABC is inserted here now this is kind of a invalid or incorrect data because student age can't be ABC right so there are some set of rules we apply at that particular time the student age is a field which will only take integer values or consider that again I'm entering uh a new field or a new record and here I'm giving student idea 04 the name as uh prianka and now here the age I'm giving as minus5 again no one age could be minus 5 right so there are some invalid data which could be entered if if we don't ensure that there is integrity constraint or there are some set of rules which is applied so basically Integrity constraint come into picture whenever we are inserting any kind of data or whenever we are updating any kind of data in our database they make sure that there are some set of rules which is enforced so that we don't U mention or don't apply or don't insert any kind of incorrect data or invalid data and data consistency is maintained all throughout the databases so basically there are various typee of Integrity constraint so the first one is domain Integrity constraint the second is entity the third one is differential Integrity fourth is key fifth is check sixth is null seventh is unique and eighth is default so basically there are various type of integrating constraints and we would be knowing in brief about all these integrating constraints in next slide so the first one is domain Integrity constraint now what is domain Integrity constraint see domain is something now consider that you have a table in that particular table there are some attributes which we usually called as columns and attributes in terms of dbms so there might be some columns or there might be some attributes right so for that particular attributes we give some domain that okay if there is a attribute called a student name it will only take character values if there is an attribute called a student age it will only take integer values so basically what happens is ke considered we have a table there are two columns there is a name and there is a age so basically in age we give that it will have integer values in name we give that it will have character values in age also sometimes we make sure that AG shouldn't be zero because no one is having an age as zero AG shouldn't be negative values so basically for these particular things we add a check constraint so what this check constraint does is can check constraint makes sure that a particular condition is fulfilled only then the data is inserted in our table so basically we'll put a check can check if the age is greater than or equal to zero and less than or equal to if there is some criteria present there if not you can put that check if the uh age is greater than or equal to zero only then insert the data so basically for this particular name we are inserting character values for this particular field or attribute Age We Are inserting integer value so basically domain constraint it ensures that the validity and appropriateness of data values that is valid data types character or integer ranges check constraint key it AG is greater than or uh greater than zero not equal to zero uh ranges and formats for the column So within a specific column or attribute of a table so basically it ensures that the validity an appropriateness of data values within a specific column of a table or attribute it basically ensures that the validity is there the appropriateness is there that uh the valid data types are going there the valid ranges are going there or the valid formats are going there now there is an example check for date column so that it contains only valid date values so basically consider that there is a date field or date attribute which is present in the table and in this date attribute someone writes ABC again it makes no sense to give ABC in a date column what does this mean a date ABC what does this mean this means nothing right so there should be some checks which should be there for all the attributes there should be some domain which should be uh given for all the attributes so that everything lies within that particular domain there should be some range of values there should be some domain of data type or some types of data types which should be there like there are many things which should should be insured in particular columns or the particular attributes of a table so basically domain constraint make sure that these particular things are insured now the second one is entity Integrity constraint so basically it ensures that each row or record in a table is uniquely identified by primary key it also helps in preventing duplicate or null values in the primary key so basically entity Integrity constraint it B basically you can say that deals with the primary key so what it makes sure is it makes sure that each and every table have a primary key so that it can uniquely identify all the records in a table now what is primary key primary key is basically a attribute which is like unique plus Nal so any attribute which qualifies the unique constraint and the Nal constraint is called as primary key an entity Integrity constraint makes sure that there is always a primary key which is present in the table what primary key does is ke primary key help us to reduce all the duplicate values maintain the data consistency throughout or within the table and it also helps us to uniquely identify all the records in the table so basically entity Integrity constraint makes sure that there is always a primary key which is present in the table so it ensures that each row or record in a table is uniquely identified by a primary key now the third one is differential Integrity constraint now this constraint is basically dealing upon the foreign key now what is the foreign key concept foreign key is basically a key which references to the primary key of another table now what happens if there are two tables which are having a primary key and foreign key relationship consider that there are some insertions in one particular Table and there is some deletion in one particular table there shouldn't be any data inconsistency that should be there so consider that there are two tables one is having a primary key another one is having a foreign key so basically in that table which is having a foreign key or the table which is the referencing table if we add any value right if we add like we randomly insert any data in that particular uh table so it will not reference to any particular uh student or any particular record which is present in the table a so basically that particular data is a invalid data or an inconsistent data because it does not have any meaning let me just draw it and let you know so basically there are two tables table a and table B these are having some uh attributes and these are also having some attributes so basically there is a roll number there is a course ID and course name and basically this is a this is a course table and this is a student table so it is having student ID roll number number student name so basically RW number is acting as primary key here and RW number is acting as foreign key here and foreign key is basically differencing to the primary key here now consider that there are R number one 2 and three here I am also giving R number 1 2 and three now what if I add one more record in this particular table R number four now this particular table course table is taking a reference from the student table right and now we have added a new particular record with which is having a ro number four course ID as something and course name as something so this particular RO number four does not exist in this student table now so what it will reference to because consider that there are three people in a class now I have allotted of uh fourth person a particular course and a particular course ID but the fourth person does not exist in the class so does it makes any sense no right so basically there is data inconsistency which is there so what referential Integrity con does is it ensures that the values in a foreign key column match with the values corresponding to the primary key column in the another table so it makes sure that R number one is there R number two is there and R number three is there so it basically makes sure that the foreign key values then the primary key values remain same or remains consistent I guess this is the fourth one so the fourth constraint is key constraint it is the simplest constraint so basically it ensures uniqueness for the primary key so what does this key constraint does is ke it makes sure that there is at least one primary key which is existing in the table so there could be like many keys right uh what consider that there is a table student table now we are having student ID student roll number and student phone number phone number is also something which can remain unique for every student student ID is also something which will remain unique for every student student roll number is also something which will remain unique for every student so B basically key constraint makes sure that there is at least one attribute or at least one key which is uh there present in the table which will be serving as a primary key so it ensure the uniqueness for the primary key now the fifth one is the check constraint so what does this check constraint does as I told in the previous slide ke we put a check for the age ke age should always be greater than zero if the age is greater than zero only then uh go ahead and insert the data in the database so check constraint basically checks for a condition that each row in a table must satisfy if the condition is not met the insertion or the update of the row is rejected so consider that if we are giving age as minus5 which is not passing this particular constraint so basically this particular data is rejected and we can't insert this particular data in the database consider there is already existing data where age is 11 now I update this particular data to minus5 so it the check constraint will check if the age is greater than zero if not it will not perform this update operation now the sixth constraint is the null constraint it determines whether a column in a table can have null values or not so basically uh this null constraint uh is given to some optional fields in the database so consider that there is a student table now in that particular table we have a section called a student email so there could be a possibility that many students don't have email many student may have email so that particular column is an optional column so what happens ke if we give that particular null constraint so what it will do is it will verify that if this particular column is a optional column or can accept the null value so if we give a null constraint it will automatically fill null there so basically if we left that particular attribute as empty it will take that value as null so basically it is like to make sure or to provide an ADD additional check ke there is a email attribute or there is a email column which many students may have email many students may not have email so you can go ahead and put null value in that particular attribute there shouldn't be any case where we are inserting the values and we are not able to insert it because the email section we are leaving it as blank now I guess this one was the sixth okay this one is the seventh so unique constraint now unique constraint ensures that the value in a specified column or a combination of columns are unique across the table this constraint prevents duplicate values from being inserted into specified columns maintaining data consistency and integrity so basically you have heard now primary key is a attribute which is unique plus not null so what does this unique means unique means now whenever we are inserting any values it is unique so consider that there is a table student table every time I'm taking this student table example so basically there is a student ID right and this is acting as a primary key for the student table so consider that for one person I've given the student IDE is 01 for one person I've given the student IDE is 02 now for the next person I can't give the student idea 01 because it will then uh not take into consideration this particular unique constraint so whenever we give this unique constraint to any particular attribute or any particular column it makes sure that if 01 value is inserted it is not inserted next time so there won't be any duplicate values so basically this constraint prevent the duplicate values from being inserted into specified columns make maintaining data consistency and integrity so 01 if inserted cannot be inserted next time so basically unique means unique values will only be inserted every time new values would be inserted none of the two values can be inserted which are same now the eighth constraint is default constraint so what does this default constraint mean as the name suggest default so uh consider if if you inserting values into your table right so if there is no value for a particular field or for a particular column so there would be some default value which would be inserted for that particular field or that particular column so basically it ensures a default value for a column which is used if no other value is provided so consider that uh there is a field called as Adar number okay so for the students who are having Adar number can go ahead and enter their Adar number but for the students who are not having their Adar number I want uh them to have uh no Adar so basically for the students who are having the Adar number they can go go ahead and insert their Adar number but for the students who are not having their Adar number I want a default value to be inserted that they are having no Adar so basically default values come comes into picture in this case what will happen that student a will try to insert his or her data now whenever the Adar uh field needs to be inserted or the Adar data needs to be inserted student will leave it as blank because they don't have any Adar and a default value called as no AAR would be inserted in that particular case so what is super key so before knowing what is super key I would like to re- revise some concepts of primary key and candidate key so consider that there is a table of student okay so basically consider that there is a student schema now in this particular schema there would be some attributes or columns so consider that there are attributes such as student ID student name student phone number and student AAR card okay so basically this is the student schema now in this particular student schema we need to know what is the candidate key and the primary key now what is candidate key candidate key is basically attribute or set of attributes which can uniquely identify records in a table so any attribute which could help us to uniquely identify the records in a table is called as candidate key so basically for the candidate key let's have a look through on the schema one by one so the first attribute in the schema is student ID now does student ID qualifies to be a candidate key yes it qualifies because student ID is something which can uniquely identify records in a table if I give a query or if I make a query based on student ID you give me the details of that particular student whose student ID is 001 so it will give me the details of that particular student whose student ID is 001 and none of the students would be having the same student ID so it is kind of uniquely identifying records in the table so student ID is a perfect option for the candidate key so what I'll do is I'll mention it in the candidate key set now second is the student name so uh there could be a possibility now that two people or two students are having the same name consider that there are two students in the class and they both are having the name as Abhishek so basically if they both are having the name as abishek there is a possibility that uh if I make a query based on student name I could get some details of another abishek but I want the details of abishek whose student ID is 002 but there is a possibility I can get details of abishek whose student ID 003 so because of this case we discard this particular student name from being a candidate key now the third one is student phone number again phone number is also something which can uniquely identify records in the table like uh if I give the phone number of a particular student so it may give me all the details of that particular student and phone number is something which can't be same for every person and we can give this as a possible option for candidate key I'm not talking about primary key but it can be a possible option for candidate key so student phone number is also something which can be a possible option for the candidate key now the next one is student Adar again adhar is something which is unique for every student so we can give it as a possible option for our candidate key so student adhar is also in the candidate key set now the next key is the primary key so basically there are two differences between uh candidate key and primary key so basically candidate key is something which uniquely identifies records in the table but in case of primary key primary key is a key which comes from a candidate key or is a key which is derived from the possible options of candidate key also primary key is something which should always be unique and which shouldn't be null so basically if these two constraints unique and not null is present in a particular column or in a particular attribute it qualifies to be a cand uh primary key so basically there are three candidate Keys here we have seen now among these which can be a primary key so student ID again whenever any student takes admission they have the student ID or the student registration number generated so it will be unique for every student student and it is obvious that every student who is taking an admission is having a student ID so student ID is always unique Plus student ID is never null so student ID can be a primary key now coming to student phone number now consider that there are many students who don't have phone number or who can't give their phone number like we are going into the '90s era but there could be a possibility that students can't give their phone number or there could be a possibility that there are siblings in a class who are having the same uh like same father and due to the same father they would be having the same phone number so again student phone number is something which can at times remain unique but at times can't remain unique so student phone number is something right now we won't be uh giving a possible option or considering a possible option for primary key so for now I'm discarding student phone number from the primary key now again the third attribute is student Adar student Adar is also something like uh many student may not have their Adar card number generated or Adar card me so there could be a possibility that some people might have adhar card section as null so basically as primary key something which is unique plus not null so AAR card is also something right now we can't consider in the primary key so from these particular discussions we have come that student ID is something which qualifies for a primary key candidate key a key which uniquely identifies all the records in a table primary key a key which uniquely identifies all the record in a table but it is unique plus not null now coming to the main topic that is super key so basically what happens now in Super Key super key is basically a set of attributes which uniquely identify records in a table now why Super Key came into picture so consider that there is a candidate key okay so there is a candidate key uh Sid okay for now let's consider only one key so in candidate key student ID is there now super key is basically a super set of candidate key super set means ke super key if there is any combination of super key or any composite Keys which are present there would always be a candidate key so uh whenever we are adding more attributes to the candidate key it becomes a Super Key so you can understand in this way ke primary key is something which is derived from the candidate key like from all the possible option we select the best option to be the primary key and in Super Key we consider all the attributes of the candidate key or some of the attributes of candidate key plus there are some extra attributes which is also added but candidate key is something which is always must in a Super Key so if we are making any super key or combination of super keys or composite keys there should always be one candidate key so what happens in super keys can consider that right now this is also called as super key so what is this is called as minimal minimal super key since there is only one attribute we can call it as minimal super key so what is minimal Super Key minimal super key is basically called as candidate key so whenever there is minimal or there is minimum attributes which are present and the attribute reflects that of candidate key it is called as minimal Super Key now super key is something which is having a candidate key and then we can have some more attributes from our particular schema or from our particular table so basically candidate key is having all possible attributes which can uniquely identify records in a table super key is something which is taking into consideration the candidate key apart from candidate key it is also taking some extra attributes into picture to make that particular combination so what will happen here is key candidate key is student ID now Super Key minimal Super Key student ID but if I want to make super key I can also make a combination of student ID and student name so basically this can act as a super key for me so what it will do is can give me the details of a person whose student ID is 001 and whose student name is R so it will fetch me all the records all the details of that particular student whose student ID is 001 and student name is reti so basically it is also a set of attributes which is helping us to uniquely identify records in a table but super key is something there can be much more attributes which is like not needed really to identify records in a table but super key is something which will always have at least one candidate key so basically it is a set of one or more attributes that can uniquely identify a tuple in a relation super set of any candidate key is called a Super Key a Super Key becomes a candidate key if it is minimal that is no proper subset of it can uniquely identify a tupple now let's see one small example won't extend the video much so let's have a look at small example uh it's kind of a small numerical you can say for now so let me just rub it very quickly till then again I'm reiterating uh candidate key is the set of attributes which uniquely identify records in a table there could be one or more attributes from all those attributes we choose the best option and that is a primary key which is unique plus not null and super key is a combination of set of attributes which have at least one candidate key so these was these were the meanings about all these now uh consider that there is a employee schema okay so there are many employees E1 E2 E3 tillan now consider that we we have given that in this particular schema even is the candidate key so I need to know that how many super key can be be possible how many combinations of Super Key can be possible so basically we have a employee schema in that particular employee schema there are n number of employees for now I'm not defining the number n there could be eight there could be 18 there could be 800 there could be much more so we are taking n into consideration so there are n number of employees in a company or uh whatsoever you think so there are n number of employees for that n number of employees there is one candidate key that is E1 now in uh since we have one cand ke we need to find that how many super keys are possible how many combinations of Super Key are possible now let's start so basically you guys might have read about probability so what will happen there are two possibility of E1 either E1 can be a part of combination either E1 can't be a part of combination either E2 can be a part of combination either E2 can't be either E3 can be or can't be either e n can be or can't be so right now E1 is the candidate key now when whenever we are making a Super Key from that so E1 is a candidate key so E1 E2 can be a possible combination E1 E3 can be a possible combination E1 en can be a possible com combination even needs to be there every time because as I told that super key is something which is having at least one candidate key so at least one candidate key needs to be there so there can be multiple combinations from this right and every every E1 E2 E3 can have two uh two types of like they can have two combinations either they can be there or they can't be there so E2 can be there or E2 can't be there so there are always two possibilities for that so if we calculate it from here 2 2 2 2 2 till n so it can be called as 2 to the power but again E1 is something which is remaining like is evident in all the com combinations right so E1 is also there E1 is also there E1 is also there if I'm doing E1 E6 E1 is always there so E1 is something which is always there so there is no possibility that e E1 will never be there there is only possibility that e will always be there so what we do is ke after that the final remains is ke 2 to the^ n minus 1 can be the Super Keys how it is 2 to the^ n minus 1 so basically every E1 E2 E3 E4 till has a possibility that it can be there it can't be there it can be there it can't be there but one of them is the candidate key so when one of them is the candidate key the possibility of not being there is vanished so there is only possibility of being there so we do it 2 to the power n and minus 2 that was 2 to the^ n minus 1 so basically 2 to the power n refers to all of the possible combinations and eliminating one combination from this is 2 the ^ n minus so now the first question comes into mind is what is er model and why like we are learning ER model so let me just explain you from a very small or basic example consider that you are a developer now you have to uh make an API okay so you have to make all the API uh all the calls which are present in that particular API all the database calls and everything so basically there could be an API in which there are some clients which are being called some database queries which are being done some database calls which are done so basically an API have many calls okay now you uh your team leads come to you and explains you okay this API is doing this this this and finally giving the result so you are having a request body and you are getting a response body now what happens is ke team lead comes and tell you about all these at that particular moment of time you remembered okay uh this particular thing is being called then there are some clients being called and there are some database queries which are being happened or database calls which are being happened and and then we are getting the final response now consider after 3 days you forgot about one client or you forgot about One DB call or consider that there are some changes which is happening and you are not still pretty sure that what all things you were doing at the very first and now you need to do some changes as well so what thing you can do at that particular time so at that particular time what you can do is when your team lead is explaining you just jot it down in pointers and make a lowlevel design of that particular API so what you will do is you will make a design of that particular API okay the API is getting some request it is validating some request and then it is calling some clients from there it is fetching some data then it is calling the database and after all these we are building the final response so basically lld diagram at that particular point would save a lot of time of yours because you would be pretty sure about ke what all things are happening and also you can ask your team lead ke uh please review my lldd diagram and uh is my understanding about the API correct or is there any changes needed or uh whenever your team lead suggest some changes you can just go ahead and make the changes in the lld diagram so you can see now diagram or design is some somehow like making things so much easy and somehow also saving our time right so in the same way like a very basic example of Maggie so consider that you are a uh you are making Maggie for the first time now you need some instructions that how to make a Maggie so whenever you see that Maggie packet you see in the background there is like in the back there is some pictures which is given and there are some instructions which is provided okay then tear the plastic and then boil the water and then put the Masala and then the noodles and stir it for 2 minutes so there are some instructions which is being provided there are some images which is being provided you just follow that and you are like good to go to make a Maggie okay so basically what happens think whenever you are following any design or any diagrams it makes makes task very much easy for you to implement ultimately what what you want to do at the very first point so uh in the entity relationship model what happens is er model basically help us in designing a flowchart or the diagrams or everything which is needed for our uh like entities relationship and what all things are being happened now considered let's take an example of Instagram so in Instagram there are many features present there adding a story uploading post and much more things so consider that today I told you that implement the feature of uploading the post in Instagram so there are many steps which are being followed first you select the PCT uh click on the post uh plus icon then you select the picture and then you go ahead and see if you want to apply some filters and much more things so there are many steps which are being involved for uploading a photo in Instagram so all these steps if documented in a very great way or in a very good way it is diagrammed and designed it would be very easy for you to understand the overall API of uploading the post and also it would be very helpful for you to implement that particular API so in the same way ER models makes our task easy so now what is er model ER model basically stands for entity relationship model now as the definition suggest entity relationship what is entity any object or anything which is having some physical existence is called as entity for example consider person person is an entity example student student is an entity so basically anything or any object which has a physical existence is called as entity now what is attributes so basically the characteristics of that particular entity is called as attributes so you might have heard this term schema in the last set of videos so what is schema consider that I need to give student schema so what I'll mention is I'll mention the entity name and then I'll provide all the attributes such as student ID student name student rle number so in the same way it is uh this is a schema of student this is a student schema so in this particular student schema student is the entity uh student ID student name student role number is the attributes and now coming to the third thing that is relationship now I have given many examples where I have taken two tables first one is student table and second one is a course table which was having a primary key foreign key relationship between them so in that particular videos I also told that student is having some relationship with the course so basically student and course have a relationship student is taking this particular course for uh that particular class or that particular standard and that particular role number so basically a student is taking this particular course so basically there was a relationship between student and course table that student is taking or op op in or studying that particular course so in relationship what happens is can we Define it in a diagrammatic way so what will happen is there is a student database now there is a course database and now what is the relationship between student and courses the student studies course so basically we give student in rectangular format and study like the relationship in the diamond format so what happens is ke student is now studying a course so basically entity relationship model is ke we Define the relationships between the entity that is studies and entities are present here and attributes are basically the characteristics of entities to attribute can be student ID which we give in ellipse then student name and much more things so basically this is the basic funa of er model so let me just clear the screen and let's go one by one okay so okay so introduction to AR model entity things or objects is called as entity example person now attributes properties of entities or characteristics of entities called as attributes such as names age student ID and much more things relationship is Association among the entities that is works for or studies or like much more things now the entity relationship model stands as a prevalent conceptual modeling approach within the realm of the database design its primary role is to offer a visual representation of a databased architecture by illustrating the entities their respective attributes and the interconnections between them so what is happening is it is basically a virtual representation of a database so the database is very huge now in that particular database there are some tables which is having some relationships in between them so what will happen you will just design that particular database so consider that there is a student database in that particular database there are many table student table course table then uh fee details and much more things now it will Define that what are the relationship between these particular entities in the process of database design the ER model holds significant importance aiding in the develop M of an efficient and systematically structured database schema so as I told you if I am having an lld diagram I can design I can implement the API very quickly if someone who is very new to that particular API and don't know anything about that API if I give him the lld diagram him or her they can implement the like uh API very easily so basically lld diagram or visual represent or designing is something if we hand over to anyone it will like make the process very easy the designing of the database uh when it's done it we can go ahead and implement the database we can go ahead and know about the database what all tables are there and much more things so basically it is somehow making our task very easy now in the ER model as I told that ER model starts for entity relationship model now there is entity there is attribute and there is relationship now there are types of entities as well strong entity and weak entity we'll be uh knowing in the coming videos now in the attributes also there are many attributes like simple composite single valued multivalued stored derived composite so basically about all these attributes we would be again knowing uh in depth in the next set of videos I'm just letting you know that there are like entities also divided in some subtypes attributes is also divided into sub subtypes and relationship is also divided into some subtypes relationship or also called as cardinality is also there one to one many to one to many many to one and many to many now these are the symbols which is basically used in the ER model so as I told consider that there are two entities so firstly I'll uh give the schema so I'm giving the schema for student and course now student schema has student ID student name and course schema has course ID course name so what is this this is basically entity so what I'll do is ke according to the symbol entities repr represented by rectangle so I'll give the name student now again course is also one entity so I'll give it in rectangle shape course and now attributes are represented in ellipse so attributes are nothing but the characteristics so we'll give the attributes student ID student name and then the attributes for this course ID course name and now at the very last we give the relationship among them so from the diamond it is given and the relationship is study so basically in this way we designed the ER model this is a very basic ER model design we would be knowing in much more depth about some complex database designs as well but uh this is just a small example that how we are designing everything from entity to attributes to relationship so basically this is the student schema this is the core schema and whenever we have this particular schema we can go ahead and design our entity relationship model or design the visual representation of that particular model so there are much more things like line is like attribute to entity relationship then double eclipse is multivalued attributes and double rectangle is weak entity as I told here that there are many subtypes of attributes and entities so we would be looking about that in the next set of videos now uh this is a normal example of er model as I explained earlier as well so there is an entity called as Professor there is an entity with the name student now there is a relationship between the professor and the student that is teaches so basically relationship is teaches now student may have some characteristics or may have some attributes so that attributes is represented using eclipse and the attributes are ID name and subject so these are the attributes this is the entity this is the entity and this is the relationship so basically uh in the last slide I also explained about this particular example of student and course in a similar way there is example of student and uh Professor so this was all about ER model in this particular video let me just re- revise from the very Basics so er model stands for entity relationship model entity relationship model helps us to uh give a visual representation of our database so that designing of database when it becomes easy the implementation of data this also becomes easy so er model is entity relationship model entity is basically any object or anything which has a physical existance uh relationship is relationship between the entities and attributes is basically the characteristics of the entities like student ID student name for a student table and course ID course name for a course table now again entity and relationship have some subtypes also attributes also have some subtypes so about all those types and about all the types of entity and relationship we would be having a look on next video basically it is providing a visual diagram to us which would help us to implement the database very easily and very effectively so what is an entity an entity is something from The Real World like a person place event or idea that has some physical existence now each entity has specific features or traits that can describe it now consider that I am taking an example of person so person is an entity because it is like a real world object which has some physical existence now person may have some characteristics which could be person name Person age uh person uh address and much more things right so all these characteristics are called as attributes of a person so that is told here each entity has some specific features or traits that's that describes it so basically person name can describe it person age can describe that uh the person is having this age the person address can describe that the person lives here so there are some special features or there are some traits which particularly Define an entity that is called its characteristics or attributes now there are two types of entities first one one is a strong entity and second one is a weak entity so let's have a look on that so types of entity first is the strong entity second one is the weak entity here I have given an example of person entity and dependent entity so what is strong entity from the word you can see now strong entity is something which is strong right so a strong entity is basically an entity which does not depend on any dependent or does not have any dependence on other entities so basically it can exist alone so let's take an example consider that we have taken an example of person entity here so why person entity is called a strong entity so person entity itself can Define all the attributes of the person like the name the age and much more things so it's not dependent on other entities okay here you get the details of okay Raj is a person who is having an age as 20 and the phone number is this the Adar card number is this and much more things you can know here so it is independent it does not depends on other tables or other entities to gather information or like it can independently exist so basically a strong entity is something which can independently exist it does not depends on other second thing is strong entity is an entity which is having a primary key uh now coming to the weak entity now what is weak entity now consider that there is a person table right and in the weak entity I've given the dependent table so basically person has some dependence consider that there is a person who has some dependence like uh his mother his father his children and much more things now if the person table is not there would you be able to know that okay there is a section called as mother and the mother name is given but whose mother is this so if the person table is not there you won't be able to know that whose mother whose particular mother or whose particular person mother is this so basically dependent table is something which is kind of dependent on the person table because person table is somehow like um the dependent table is somehow gathering information from the person table and this particular table is solely dependent on this table that the parent is this uh the wife is this or the children is this let's not confuse you let's go ahead and have a look on the definition first and then again we will learn from a example so basically types of entity strong entity a strong entity is an entity that has has its unique identifier that is primary key and it's not dependent on any other entity for its existence within the database strong entities stand alone and have their own set of attributes example person now in the weak entity a weak entity is an entity that does not have a primary key of its own it relies on a related strong entity known as owner entity for its identity the weak entity existence is defined finded by being related to the owner entity now example is dependent now let's understand the strong entity and weak entity in detail so consider that there are two tables so first is the student table and second is the course table student has taken so it has course ID course name it has student ID student name and student age it also has the student ID so do you remember in last set of videos we learned more about primary key and foreign key relationship so basically there are two tables one is a student table one is a course table basically student ID in the course table is a foreign key which is taking reference from the primary in the student table now what happens you consider that there are two entries first one is RTI second one is RAM and the age is 20 21 and the course ID here is 01 02 course name is physics po name is maths the student ID is 1 and two now from these two tables it's evident a person or a student whose role number is one has taken the course name as physics and course ID 01 a student ID uh a student whose ID is two has taken a course name maths and is having a course ID as two so from where do we get the details who is role number one and who is RO number two from this particular student table so student is an example of strong entity and course is an example of weak entity let's understand how so basically student uh student table can exist independently it doesn't needs to gather information from some another table ke okay for rle number one what is the student name or what is the student age it can exist on itself and also the second thing is can this particular table is having a primary key this is a foreign key so basically there are two things which are needed for a entity to be a strong entity first one that the entity should exist alone if there are any uh any hindrance in another tables it shouldn't affect this particular table so it can exist alone the second thing is the table always should have a primary key so all these two things are verified in this particular student table so student is a strong entity now coming to the course table so basically course is somehow having a foreign key primary key relationship with student so it is called as a weak entity because again I told now there is one student whose RO number is one and has taken course name as physics and course ID 01 but what if this table is not here so would you be able to find okay role number one who is the person who is role number one or who is the person whose student ID is one would you be able to find KY to who is the student who is having the student ideas to so this table can't exist independently and it it also doesn't have any primary key it just have a foreign key which is taking a reference from the student table where student ID is acting as a primary key so basically it can't exist alone and it doesn't have a primary key so it is called as weak entity basically strong entity is represented by one rectangle and weak entity is represented by two rectangle and whenever there is a relationship between a strong entity that is student and a weak entity that is uh course the relationship among them is defined bya two diamonds studies so this is student which is a strong entity so a single rectangle course which is a weak entity so two rectangles so basically this is the way we represent uh entity relationship between strong and weak entities attributes in dbms now what is attributes so I told that entity is something which is basically having a physical existence so basically uh whenever I'm taking an entity example consider person so basically person is an entity now person may have some characteristics such as uh person name Person age person address and much more things so these are the characteristics of person which we generally called as attributes so basically these are called as attributes now in attributes also there are some types of attribute about which we would be learning in this particular video so types of attribute so the very first attribute is a simple attribute as the name suggests something which is very simple or like simple attribute is something which can't be further divided so a simple attribute is an atomic and cannot be divided any further example first name so consider that there is a student right so student would be having name as an attribute and name can further be divided as first name last middle name and last name so basically these all three first name middle name and last name these are the attributes which are called as simple attributes because they can't be divided further name can be divided further the name attribute can have more attributes such as first name last name middle name in such a way like address attribute can have Street City PIN code and much more things so in the same way name attribute can have further attributes but the further attributes such as first name middle name last name cannot be further divided also there is one more attribute you can take it an example is H so AG is also an attribute I've given the student ages is 18 now what kind of further modifications or further division it needs it needs nothing right so basically simple attributes are the atomic attributes which cannot be divided further so simple attribute is an attribute which cannot be divided further and for your information attribute will represent it using Eclipse so we can say first name is a simple attribute now coming to the another attribute that is composite attribute so going to the same example so there is a student so there would be attributes such as name attribute such as address so name is again an attribute which can be further divided so it could be first name last name middle name address can also be further divided into Street City pin code so basically these attributes which can be further divided are called as composite attributes so composite attributes is made up of several smaller part of attributes where each part represents a piece of a whole attribute in simpar terms it is composed of attributes which can be divided further so name is an attribute which can be divided further address is an attribute which can be divided further so these attributes are called as composite attribute example name which could be first name last name or middle name now the third attribute is single value attribute from the name itself it's clear that these values or these attribute have a single value so basically a single value attribute is an attribute that holds a single value for each entity so consider that uh again there is an attribute age there is an attribute student ID or there is a attribute uh consider course ID so all these attributes would only have a single value so age is consider 18 student ID is 1 2 2 3 or C ID 012 so these attributes can't be divided further and they have single value so basically they don't have multiple values they have only single value considered that student phone number so there could be multiple values for phone number consider you are giving your father phone number your mother phone number or your local gu phone number so phone number is something which can have multiple values but age is something you can't say now a student is 18 and 21 at the same time right so age is something which is a single attribute now again student ID student ID is something which is unique for every student so you can't say ke uh my student ID is 1 122 3 and 122 4 so it's not possible right so it would always have a single value so basically a single value attribute is an attribute that holds a single value for each entity example h now next attribute is multivalue attribute as from the single attribute it's clear single attribute is something which is having a single value now multivalued attribute is something which is having multiple values or can have multiple values So a multiple multivalued attribute in a database is an attribute that can hold multiple values for a single entity example address so uh like uh you have filled so many forms right so in so many forms you can see or in the diary itself whenever we take admission into any school in the diary itself you can see there is two uh two fields for address one is permanent address second is residential address so basically address is an attribute which can have multiple values uh consider that permanent address and residential address so basically attribute is something which can have uh this address attribute is something which can have multiple values so basically an attribute which can hold multiple values is called as multivalued and an attribute which needs only single value or can hold only single value is called as single valued so basically in multiple uh multivalue attribute we represent the attribute using two circles so address can be represented in this way now next attribute is stored attribute so attribute that is stored as a part of database record so in stored attribute it is an attribute which can be stored consider date of birth so date of birth is an attribute which can be stored right it's so date of birth is something which you can store and you can give to the system now coming to the next attribute that is derived attribute so a derived attribute is derived from other attributes within the database like age is derived from data of BU so right now I told you about stored attributes so date of birth was something which is which was a stored attribute so we stored the value of this attribute in the database so it is called as stor attribute now from this date of birth consider that there are many employees in my company and they have given their date of birth and I want to know the age of that employees so from the date of birth itself we can know the age of that particular person so basically age is a derived attribute taking reference from date of birth so derived attribute is something we represent through dotted Eclipse so age is something which is being derived from date of birth consider in case of salary also so in salary there are multiple parts so first is base second is the stocks third is the bonus so using all these attributes we derive the total salary just a second so we derive the total compensation that is TC so basically TC is something which is getting derived from other components such as base uh stock and joining bonus so basically total compensation is something which is a derived attribute and it is being derived from base joining bonus and much more multiple components so we can say that as a stored attribute so the next attribute is complex attribute so complex attribute is an attribute that is made up of multiple smaller attributes so whenever we made attributes from smaller attributes it is called as complex attribute consider an example of address so basically an address it is a composite attribute because it can have attributes such as Street PIN code and city and at the same time address is also acting as a multivalued attribute because address can be of two uh like can hold two values first one is permanent address and second is residential address so basically residential and permanent are the two values it can hold and it is a complex attribute because it uh it is is a composite attribute because it can be further divided into simpler attributes so uh there is one more attribute that is a key attribute so basically key attribute is something related to uniquely identifying records in a table so basically a key attribute is an attribute which helps to uniquely identify records in a table and it's always unique so key attribute is something which is always unique so consider that uh in this particular case of student let me just write it here so student there can be multiple attributes student name student age student ID so again student name is something like two people can have the same name student age is also something like two people can have the same age but student ID is something which is always unique so it acts as a key attribute and whenever uh there is a key attribute because it is acting like unique it is acting like unique identifying all the records in a table we represent the key attributes using a small line inside the eclipse so basically uh let me just re revise about all the attributes symbols okay so basically attribute is represented using Eclipse now there is a derived attribute which is uh represented using dotted Eclipse now there is a key attribute which is represented using eclipse and inside there is a line and then there is a multivalued attribute which is represented using double Eclipse so this is a simple attribute this is a derived this is a key and this is a multivalued now let's see at the term what is the types of relationship so basically like uh types of attributes and types of entity in types of entity we got to know more about strong entity and weak entity in the same way here also strong relationship and weak relationship exist so let's see that what is strong relationship and what is weak relationship so first we'll strong start with the strong relationship now what is a strong relationship a strong relationship exist when two entities are highly dependent on each other and one entity cannot exist without the other so basically a strong relationship is established between two person when they are inseparable right so in simpler terms that when two people are inseparable they have a strong relationship and when they can be separated somehow they have a relation but they can be separated is called as weak relationship so in this case strong relationship is when an entity is highly dependent on another entity and cannot exist without another entity that is called a strong relationship now here I have taken an example of customer and order so okay so basically there is a customer and there is a order now uh every customer places some order right so every order is placed by a customer now in customer there would be some attributes such as customer ID customer name customer address and much more right and Order Also may have some uh attributes such as order uh description order ID and much more okay so what happens is ke for every customer there is a order right so for every customer for every customer ID there is a order which exist in this particular table now what will happen when I delete this customer table so there would be some customer IDs present but these customer IDs does not exist because the table does not exist so in the very starting of the video I explained about primary key foreign key relationship so basically in this customer table the attribute CID is acting as a primary key and in this order table CID is also present and it is acting as a foreign key which is taking a reference from the primary key of another table that is the customer table so they have a relationship established between them now what if I I delete this customer table so all the customer details would be gone all the customer IDs would be gone gone now here from this customer ID this table is taking reference from this particular table but since this customer ID is deleted or this customer table which is having a customer ID is deleted it won't be able to take a reference so they both are dependent on each other so basically the one which is having a primary key is called as parent and the one which is having a foreign key which is taking a reference from its parent is called as child so basically here the child has a foreign key here the parent has a primary key the child is having a foreign key which depends on the primary key of parent so if the parent is deleted the primary key of parent is deleted then the child won't be able to take any reference from the parent and it will uh result in the referential Integrity uh rules breaking I made a video on the same that how the rules are breaken in referential integrity and how we can achieve that referential Integrity is also there so referential Integrity rule would be broken so in this way our relationship couldn't be established so this is called a strong relationship strong relationship means something which is inseparable so when two entities depend on each other for their existence is called a strong relationship Whenever there is anything which happens to one table it affects the other table now the second is the weak relationship again I told ke strong relationship is something where things are inseparable it it couldn't be separated but in Weak relationship we can try to separate them it won't affect too much okay so a weak relationship on another hand exist when two entities are related but one entity can exist without the other so whenever there is a use case when one entity can exist without the another entity that is a weak relationship let's understand from an example so here I have taken two entities the first entity is order the second entity is order item now order is having a order ID as primary key order item is having a order ID as foreign key which is taking reference from the order table now order item also have a order item id which is a primary key in this order item so basically consider that this is a order item table and this is the order table now order table has order ID order name order description and order item is having order item id o i ID so just make it o i ID order item id order ID which is basically taking a reference from this table which is called as foreign key in this table and consider order item name okay so now this particular order item ID is acting as a primary key here so basically order ID is a primary key in the order table which is a parent table an order item id has order item item id as the primary key sorry for confusing with the words so order ID order ID is a primary key in order table and order item ID is the primary key in order item table so basically this is also having a primary key this is also having a primary key now there could be chances now you place a order and order item details and everything is attached to that particular ular order but order item is something which can exist independently as well like there might be some products in uh backlog or there might be some products which is not yet bought by you so there are are order items so basically order item is something which can exist independently even if there is no order table so a weak relationship is a relationship where the two entities are related but one entity can exist without the other so basically order item can exist without order but yeah at the time of making order whenever a customer places the order the order item are attached to that particular order but before placing of their order the order item can exist independently so this is weak relationship strong relationship when things are binded can can't be uh separated uh weak relationship things can be separated but they somehow have a relationship between them now what is degree in dbms so a degree in dbms refers to the number of attributes or columns that a relation or table has so basically the number of attributes your entity is having is called as degree it's degree so consider that there is a customer table now customer may have some attributes customer ID customer name customer uh Adar details so the degree is three so basically the number of attributes or the number of columns in a relation or in a table is called as degree now here is the type of degree so degree is one the name uh we told it as is a unary degree and a relationship with a single attribute is called as having a unary degree or degree one now degree two is called as binary degree and a relationship with two attributes is called as binary degree now uh degree with three is called as stary degree and a relationship with three attributes is called as tary degree a degree of n is n array degree and a relationship with more than three attributes is n degree where n is greater than three so consider that there are two entities Let's uh make a schema of person and customer now this person schema may have some characteristics such as person name Person age and this customer may have customer ID customer name customer address now to calculate the degree for this particular entity and this particular entity what we do is we calculate the number of attributes so here it is 1 2 so basically it is is two so it belongs to Binary degree now in customer table there is customer ID customer name customer address so 1 2 3 so basically the degree is three and it is called as tary degree so in this way we calculate the degree now null value so in dbms a null value can occur for various reasons not needed information Sometimes some details are asked but they don't apply to everyone for instance asking for a spouse name for someone who isn't married so basically what is null value in dbms so uh you might have seen many places or whenever we create some tables we give that this can be null or this can't be null so uh some of the attributes we give that this can be null or this is optional so consider that student is uh filling Adar card details or pan card details it's not possible that each and every student would be having a pan card so we can't make that particular column a mandatory or we can't make that particular column not not null because null values can exist in the same way there is some not needed information so basically consider that you are being asked your spouse name but you aren married you are a single person so you won't fill any data so that particular data would be filled with null value now here are the instances that why null value basically is used or what could be the simple use cases why the null value exist so the uh first use case is not needed information so whenever there is a not needed information we can use the null value now second is K the don't know the answer every now or then we are asked a question but we don't know an answer yet so you may have dealed this in day-to-day life that you are asked a question and you simply blank out because you don't know the answer so in that particular case also null value can exist so there are some hypothetical questions which are being asked ke do you think uh bird can fly walk cry eat at the same time so again it's a very lame example but again there are some questions about which you don't know the answer so you can put it as null so basically uh null value can come in that place as well so the third thing is for God to fill in like when you are filling out a form and you accidentally missp putting in some important information so what happens now whenever we are filling a form there are some uh Fields marked with asteris that these particular fields are required field but there are some fields which are not marked with that so what values would be filled for that particular field so uh their null value can exist so sometimes you are being asked that uh uh what previous internships you did but you didn't did any internship so in that case you uh make that value or make that feeli null like you leave that so null is automatically put into that so basically on the types of uh degree or on the basis of cardinality there are four relationships so what are the relationships first one is one to one second one is one to many third is many to one and fourth is many to many so in this particular video we would be knowing in much more detail about one to one relationship and then there would be a dedicated videos about all those relationship so basically starting from one to one relationship so before starting I would like to Reise some older concepts of yours so why are we studying ER model or why are we studying relational model and how is it all related to wql and much more things so basically what happens now from the very beginning we read about database schema so there was a database schema in which we basically used to give the entity name considered person and then we used to provide all the characteristics or you can say attributes such as person ID person name personage in the same way we uh do for other entities as well now what happened key from the database schema we designed an ER model as to design an ER model we need some data like what is the entity name now what are the attributes of the entity as well as relationship and much more things so we designed the ER model using this now this ER model considered this ER model is designed now on basis of this ER model now what we do is ke from that ER model we derive a relational model model so in relational model what we do is key relational model so in relational model basically the visual representation which we get we break it into tables so basically tables are drawn in ER model uh relational model now for all these tables we need to do some coding to make some tables like to create tables to insert data into tables and much more things so that is done using SQL so basically using SQL we create insert update and do much more operations on the data now coming to one and one relationship so what happens in one and one relationship each row in one table is associated with one and only one row in another table and vice versa so basically consider that there are two entities entity one is student let me just change the color and entity two is course now student is having a relationship with course that is enrolls so student is enrolled in a course now this particular entities is having some attributes such as student ID student name and age this particular entity is having some attributes such as course ID course name and course Professor now in this particular entity S ID is the primary key and in this particular entity course ID is the primary key now these two entities have a relationship among them that is enrolls now basically can you see that enroll is also having an ATT attribute so what happens now enroll is having a attribute such as enrollment date so enrollment date is present as an attribute for a relationship table so what happens can this particular table whenever we draw table for the relationship is called as Junction table or associative table now coming to the doubts which would be coming in your mind now the very first doubt you would be having in your mind is key we were having a primary key for relationship and the relational models right so why do we need an extra table for a relationship because ultimately we were stablishing relationship of primary key and foreign key between different tables now what was the need of introducing a relation table in the very first case so basically uh this relationship table or relation table is introduced because consider that uh there are uh as I told that there are four relationships one to one one to many many to one and many to many so in many to many relationship what happens now ke generally what happens ke in this particular ER model what happens ke there is two entities and one relationship so there would be three tables in those three tables we generally find out the primary key and we just reduce that three tables into two but what happens in many to many relationship now the tables can't be reduced right now you won't be understanding these terms uh again I would reiterate this terms after the many to many relationship video but the first use case was that and the second Second Use case was what if the relation among two entities have an attribute of its own so basically as you can see this enrolls is having an enrollment date as an attribute now the enrollment date can't be present in the student table as well and in the course table as well because again it doesn't make sense to uh make the enrollment date or uh introduce the enrollment date field in student table or the course table so basically enrollment date is something which is an attribute of the relationship itself so for that also we need separate table so uh basically as you can see that since there are two entities what we are doing is can now we are breaking this ER model into relational model so what we do while breaking so there are entities entity one entity two so for th uh those separate entities what we will do is we will draw a table so basically this is a student table and this is the course table so basically student table is having Fields such as student ID student name and student age course table is having Fields like course ID course name course Professor now course ID is having C ID as primary key because it is uniquely identifying all the records in a table now student is also having a student ideas primary key again it is also uniquely identifying all the records in a table now the third thing which comes is the relationship table so basically this table is this one so basically this is a enrolls table so basically in this table what happens is ke we mention like see as an individual student is an entity right course is also an individual entity so from this table we are knowing okay student uh S1 is having name as RAM and age as 14 here also we are knowing the course ID is C1 course name is physics and course Professor is Sor of but are we able to know the relationship among these two in primary ke foreign key relationship what we used to do is in the table uh like in one table there was primary key and in another table that primary key was present as a foreign key which was able to uh like grab the relationship or was able to make the relationship between these two tables but right now you can see that Sid is present here C is present here but Sid is not present in the course table so there are no relationship between these two tables so just to establish a relationship we introduce the relationship table so in the relationship table what we do is can we first write all the p uh primary key of the student table that is student ID which is acting as a foreign key here now the primary key of the course table that is C ID which is acting as a foreign key here and then the attribute uh of this particular relationship table that is Eed dat enrollment date now student ID is given here course ID is given here e dat is given here now this one table we know that primary key is student ID now for this table also we know the primary key is C ID but for this table what would be the primary key because again uh Sid is also something which is uniquely identifying records in the student table C is also something which is uniquely identifying records in course table now among this which could be the possible primary key so among this any of one could be the possible primary key Either Sid or C any one of them could be a possible primary key because always for one student there is one course and for one course one student is being enrolled so one to one relationship what happens is ke only for one particular student there is one course or VI Versa only for one course there is one student which is enrolled so basically uh the student won't repeat ever the course won't repeat ever so any of them either student ID or C ID can be a part of primary key so basically the very first question arises is in the relationship table which is the primary key so in one to one relationship any of the attribute which is serving as a primary key in any of the entities can be the possible primary key for relationship table now the second question arises in our mind is can we reduce this table so there are three tables first one is for student entity the second one is for relation table relationship table or enrolls tables and the third one is for course table so so basically there are three tables can we normalize or can this table be reduced so the answer is yes the tables can be reduced how these tables can be reduced so consider for now I am considering Sid as a possible primary key now you can see Sid is also present here S ID is also present here now S1 S2 S3 the values are not repeating S1 S2 S3 the values are not repeating and for now like any of them either S ID or CID any of them can be assumed as a primary key for now I am assuming Sid as a primary key so basically what we can do is we can combine these tables into one table and this table would be as it is so what happens when we combine uh Sid s name sh that is a student table and S ID C ID Ed that is of relationship or the enroll stable so basically S ID is present here which is common among both of them s name is here s age is here C ID is here e date is here and then this particular table is here so basically earlier we used to have three tables now we used to have two tables let's re- revise all the concepts from the very starting now what is one to one relationship so one to one relationship is established whenever one row or each row of one entity is associated with one row or each row of another entity so basically one to one relationship means each row of one entity is associated with each row of another entity and vice versa now in one to one relationship what happens is there is two entities and there is one relationship among them now for all these three we draw separate table so basically ER model is now brok into relational model so in relational model we draw tables so basically we draw a table for all these three entity one relationship one and entity 2 now in all these three tables we have uh first table is the student table the second table is the course table now student and course table stands as an individual entity but when we want to establish a relationship between the student table and course table we introduce the relationship table in the relationship table we add the primary key of student table we add the primary key of the course table which is acting as a foreign key because again it is referencing to primary key of another table and this one is also referencing to primary key of another table along with that we add the attributes if there are present for the relationship table now what happens is ke the first question which comes into mind is what would be the primary key of the relationship table so basically from uh first table that is student table we get the Sid as primary key from the second table that is course table we get the CID as primary key but in the relationship table what would be the primary key so any one of them either uh student ID or course ID can act as a primary key now the second question which comes into mind is can we reduce these tables because again there are three tables and uh the relationship table is having a primary key from existing student table also uh existing course table also so can be we combine those table or can we reduce the tables so the answer is yes we can combine or we can reduce the tables again we can combine those tables uh like consider in relationship table for now we are considering student ID as the primary key so we can combine uh relationship table with the student table having student IDE as a primary key if we are taking course IDE as primary key then we can combine course table and the relationship table which deduces our tables from 3 to two so basically this was all about uh one to one relationship among different entities right now we are reading about ER model so er model basically means entity relationship model so the relationship between two entities and the visual representation of that or you can say the designing of that is called as ER model now as the name suggest entity relationship so there would be some relationship between different entities now what is entity any living thing or any living object is an entity now they would be having any uh they would be having a relationship between them now entities is having relationship among them consider there is an entity a and there is an entity B consider the entity a is customer consider the entity B is the order it makes now there would be a relationship between customer and orders what could be the relationship customer place order so place is a relationship between these two now there are some mapping constraints which are present when we establish a relationship between two entities so what is this mapping constraint mapping constraint are think like One customer can place only one order that is one to one mapping constraint One customer can place many orders that is one to many mapping constraint so basically the relationships or the connections or how these entities are being mapped in the relationship is called as mapping constraint and there are various types of mapping constraints such as one to one one to many many to one and many to many so today we would be knowing all about one to many so I guess without any further delay let's get started with the lecture so one many relationship a database model where one entity on one side of the relationship is associated with multiple entities on the other side it is called as one to many relationship so basically what happens uh in a database model when one entity is associated with many other like consider that there is one record which is associated with many other records in the uh other side or you can say in the other entity then that is is called as one to many relationship so let's see from an example and understand from an example so there are two entities first one is an author entity entity E1 and second entity is the book entity that is entity E2 now author reads book reads is the relationship between these two entities now there are certain characteristics of entities that is called as attribute so here are attributes such as author ID author name and author age here are some attributes such as book ID book name and book type now in this author ID is the primary key in this book ID is the primary key now here the relationship is also having an attribute that is called as booking date or publishing date like author publishes books so what could be the publishing date so basically these attributes are called as descriptive attributes so whenever the relationship is having an enti uh having an attribute that is called as descriptive attribute so here there are two entities a relationship between two entities uh first entity is having some attribute or some characteristics second entity is also having some attributes and characteristic there is one relationship that is also having an attribute such as publishing date or booking date now what happens in real life is now whenever we desire design a database or whenever we have been given some requirements and we design a database so what happens is the first step is we get the requirements these are the requirements second is ke we get the schema so basically schema like person and the attributes or characteristics of person such as person name Person age Etc now from this schema we draw the ER model that is basically the visual representation of data and now after ER model there comes a relational model that is basically from this visual representation we implement it in tables and to do it physically we use a language to use the uh to use uh to do the physical implementation we use a language that is called as SQL so this is the format which goes ahead so now I have the requirement I have the scheme I have drawn the ER model now I'll turn the ER model into relational model that is into tables so how I'll form the tables so I'll pick the first entity entity even I'll draw the table for author now for the author I'll mention all the characteristics so basically characteristics are given in the columns so author ID author name author AG now I'll fill some data in here now here it is given that author ID is the primary key so I'll mark author ID as the primary key so basically this is the table for the author uh entity now coming to another entity that is book entity so this is the book entity and this is the author entity so in the book entity also now I go ahead with the characteristics I give them in in the columns book ID book name book type now I'll provide some random random data for all these as of now and then since primary key is book ID so book ID is something which would be unique for every record here also author ID is something which will remain unique for every record now this table is done this table is done now I'm coming to the relationship table that is reads table so what will be there in the relationship table so basically relationship table is something now which is establishing a relationship between two entities this entity can alone tell me details about about the author this entity can alone tell me the details about the books but I don't know now which author has published which book so basically in the relationship table what happens is the relationship which is defined or which is established between two entities we mentioned that so how the relationship established you may have learned about primary key and foreign key relationship if you haven't I have uploaded a video on the same so you can go ahead and have a look so basically I'll give the primary key of the author table here I'll give the primary key of the The Book Table here and the descriptive attribute of uh relationship table that is B date or B this is not B type this is B dat so this is B dat so I'll give the descriptive attribute I'll give the primary key here and I'll give the primary key here now these both would be acting as a foreign key as I told now what is foreign key foreign key is a key which take reference from primary key of another table basically establishes a relationship between two tables so foreign key establishing a relationship so in the relationship table that is read table I am taking a foreign key which is directly pointing towards the primary key of the author table and then B ID is a foreign key which is directly pointing towards the primary key of The Book Table so basically they are establishing a relationship so the very first question which comes in mind is what would be the primary key in the relationship table because in the author table a ID was acting as a prime AR key in The Book Table B was acting as a primary key but in the relationship table which among these two would act as a primary key so basically what happens that this is a one to many relationship one to many relationship means he one author can publish many books so one author can publish many books so basically A1 is a author which can publish B1 book A2 is a author which can publish uh B2 book A3 is an A1 is again an author which can publish B3 book so as I told now one to many so one author can publish many books I either he or she can publish B1 B2 or B3 now Author 2 can publish B4 B5 B6 so one author can publish many books but one book is published by only a single author so if there is B4 it is published only by A2 if there is B1 it is published only by A1 so one author can publish many books but one book is published by only one author so what happens is ke author ID is something which can be repetitive like author one can publish B1 book author one can again publish B3 book author 2 can publish B2 book so what happens is you can see now there is duplicacy or you can say A1 A1 is repeating two times for first time A1 is repeating for B1 second time A1 is repeating for B3 so A1 is something which cannot uniquely identify the records in the table because it is not unique it is coming two times maybe it can come three or four times so what we do is can generally in the many side the primary key always lies so what is the m side books is the Min side so one author can publish many books so one author can publish B1 B2 B3 then other author can publish B4 B5 so basically one author can publish many books A1 can publish B1 and B3 so book ID is something which is unique but author ID is something which is not unique so book ID is the primary key in case of the relationship table so you can like just think in this way primary key always lies in the mini side so whenever there is a mini side the primary key would be lying only there so book ID is the primary key now the second question which comes into mind can we reduce the tables so let's see about this so this is the author table this is The Book Table and this is the reads table just now we knew that b ID is the primary key in the read table now author ID is the primary key here and B ID is the primary care so yes the answer is yes we can reduce the table how we can reduce the table so you can see now in this particular reads table and in this particular book table the primary key is same B ID is a primary key here and B ID is also a primary key here so what we can do is we can combine these both tables and we can make one single table so author would be a single table that is one table and uh B uh Book Table along with read table can be a second table so basically from three tables we have reduced to two tables so when we will combine these two tables what we will do is ke first we will give the primary kid that is B ID B1 B2 B3 now we will start with the attributes so B name is here B type is here now a ID is here and B date is here so basically the combination of these two can give me a table and B ID is something which would remain unique for uh both the tables so B ID will be coming one and then these a ID B date B name and B type would be there so basically from three tables we have reduced to two tables so just summarizing so one to many relationship means whenever one entity is associated with many records in the other entity that is called as one to many relationship now in one to many relationship in the relationship table primary key always lies at that side where there is a uh mini relationship so basically Whenever there is 1 to n uh consider that there is a customer and it has a relationship with order one to n so where there is the n side that is in the order side the primary key will always lie there now the second thing is can we reduce the table yes we can reduce the table because again in the relationship table primary key is some something which is uh common in the relationship table as well the entity table which is on the other side so we can combine those tables so from three tables we can reduce to two tables as I explained about one to many relationship it's just a reverse of that but we would be discussing about some normal Concepts like what would be the primary key would the table be reduced if the table are reduced how many tables are in the final uh response and many things so without any further delay let's get started so many to one relationship let me just re- revise one to many relationship once again so consider there is an entity E1 that is having a relationship with entity E2 in a one to many fashion so what happens in one to many is even can be Associated like one record in even consider uh book so book can be associated with many authors A1 A2 A3 now book B1 is associated with many authors book B2 can also be associated with A4 A5 A6 so when we simplify it you can see B1 is associated with A1 B1 is again associated with A2 B1 is again associated with A3 so basically one book is associated with many authors so this is one to many relationship now say in the case of B2 we can see B2 is associated with A4 A5 A6 now again it is one to many relationship now in many to one relationship it is just the reverse of the same so in many to one relationship what happens is ke many authors can be associated with one book so it's like author A1 author A2 author A3 can be associated with one book that is B1 now author A4 author A5 author A6 can be associated with one that is B2 so basically it's a reverse of one to many relationship so many to one is just a reverse of one to many relationship now let's understand from the definition so a database model where multiple entities or records on one side of relationship are associated with a single entity or record on another side that is called as me to one relationship so let's understand from an example so in the example you can see that there is a entity employee that is E1 there is an entity Department that is E2 now E1 is having some characteristics such as e ID e name eh that is also called as attributes E2 uh E2 is also having some attributes such as Department ID Department name Department type now E1 is having e ID as the primary key E2 is having D ID as the primary key now according to this many employees just let me draw it here so many employees can belong to the same department so whenever you are working in a company there is a department like such as uh Development Department there is an HR department there is some other departments so many uh employees can work in the development department many employees can work in the QA Department many employees can work in HR department so uh many employees that is n can work in single Department that is one so when we simplify this we get E1 is working in D1 E2 is also working in D1 just a second E3 is also working in D1 so you can see that E1 E2 E3 that is many employees is working in the same department so let me just write it here E1 E2 E3 all are working in D1 department now we draw the tables for uh employee consider that this is a table for employee we draw the table for Department this is the table for Department we draw the table for relation so this is the table for relation now the relationship uh relation table would be having the primary key of uh employee and the department so it is having the primary key of employee that is considered Eid and it is having the primary key of Department that is D which is now acting here as a foreign key these both now the very first question arises what would be the primary key in the relation table so just think what could be the primary key in the relationship table so here from the diagram you can see that this is from the employee and this is from the Department table now these both are presents now you can see that employee E1 E2 E3 so employees are unique so that is uh what this means is can employee can uniquely identify records in a table consider any attribute of employee so it can uniquely identify records in a table Eid is something which can uniquely identify all the records in a table but when I'm coming to Department that is D ID so one Department would be having one Department ID considered that soft engineer is having e as Department ID HR is having HS Department ID so here you can see that every employee is working in E department so whenever I'm making a query in the database using ke okay give me the employee who is working in E department so again it will give me many employees but if I make a query key okay employee give me the details about employee even so it will give me the specific details about that employee even but whenever I'm making query using the department ID it will give me like any random employee right so what we do is we make this Eid as the primary key also you can uh like remember in such a way Whenever there is a mean relationship on whichever side that entity primary key is the primary key in the final table so basically M side is always having the primary key so in the M side that is Eid now the second question is there would be three tables now can we reduce these three tables again the answer is yes we can reduce the three tables because Eid is the primary key here and Eid is also the primary key here so two tables are having the same primary key so we would just combine these two tables so we would combine the employee and work and Department would be one table so now three tables are deduced to two tables so many to many relationship as the word suggest many to many means this particular entity would be also having many uh Records here and this particular entity would also be having many records here so let's understand with the definition and then we will jump in the example and discuss more Concepts on this so a database model where multiple entities records on one side of relationship so consider that E1 and E2 so multiple entities and record of one side of relationship are associated with multiple entities or record on another side of relationship sorry uh consider this as C1 okay so there is two entities E1 and C1 so this is C1 C2 and C3 so uh where multiple entities are record on one side of relationship are associated with multiple entities or records on other side of relationship so that is called as n to n or many to many relationship so let's understand from an example so consider that there are two entities student and course so according to this ER diagram many students can opt many courses so basically there are many student consider Ram Raj Rahul for now I'm only taking three students so ramraj Rahul are the students and the subjects which are present in the school are Hindi English and maths now coming to ram ram can either opt Hindi can also opt English and can also opt maths Raj can also opt English or maths Rahul can also opt Hindi or maths so basically Hindi is being opted by Ram Hindi is being opted by Rahul so you can see now F in first go Ram is opting Hindi English and maths and in the second go Hindi is being opted by RAM and Rahul so uh at the first go we can see that there is a one to many relationship at the second go you can see many to one relationship so when they are combined one to many or to one so it results into many to many relationship now here you can see there are two entities student and course student is having some attributes or characteristics such as student ID student name and student age here student ID is given as primary key so right now we are seeing that what requirements we are given so all these things are given to us so student is having attributes student ID student name student age course is having attributes course ID course name and course Professor uh relationship is also having an attribute uh such as enrollment date now they are having a many to many relationship among them student ID is the primary key for the student table course ID is the primary key for the course table now this is the visual representation of the DB now we will draw it in the form of tables that is the relational model now first we will do for the student table so student is having student ID student name and student age I've have given all the details and student ID is the primary key I've provided that so student that is a base table I have drawn now here for entity2 course is the table so course table is here now cours is having attributes such as course name course ID and course Professor so course ID course name course Professor course ID is given as primary key so this I have drawn as a primary key now for the relation table I am having an attribute as enrollment date so for now just consider that I have given only this attribute in the relation table now what happens is now from this particular table I getting details about what is student ID what is student name what is student age from this particular table I'm getting details about what is the course ID what is the course name and what is the course Professor but I'm not getting the exact relationship because see entity relationship what happens is can we establish relationship between entities now in these two entities which individually exist we have to establish a relationship and to establish a relationship what we do is can we pick the primary key from the first entty table we pick the primary key from the second entity table and in the relation table we mention both the primary keys so from the primary key we can know okay there is an employee even who is uh from Department D1 there is an employee E2 who is from Department D2 so all those details we can know from the relation table so here I have given the primary key of student table that is Sid here I have given the primary key of the uh course table that is C now since uh this primary key uh this key is uh kind of taking reference from the primary key of another table so this is called as foreign key this particular key is also taking a reference from another table so this is also a foreign key now the very first question which arises in our mind is if for this one to we are sorted for the student table or the base table we are sorted S ID is the primary key for Co table also we are sorted that c ID is the primary key but when there is a relation table what would it be the primary key in this particular case so in this particular case what happens now ke I have told you that primary key always lies in the many side but here to both are many like the relationship is many to many so where the primary key would like so as I told now this is a many to many relationship many students can opt many courses and many courses are opted by many students so there is a many to many relationship so student S1 can opt for course C1 student S2 can opt for course C2 student S3 can opt for course C3 again student S1 can opt for course C3 again uh student S2 can op the C3 course so you can see now what is happening is Sid is also something which is kind of repeating so you can see S1 is repeated here S1 is repeated here S2 is repeated here S2 is repeated here and here also C1 is here C3 is here C3 is again repeated C3 is again repeated so there is repetion yeah I do agree that in the student table student idea was acting as a primary key and in the course table course ID was acting as a primary key but in this particular table we can see that there is a repetition in the student ID as well and in the course ID as well as many students can opt many course and many courses can be opted by many students so what we do in this particular case is can we make student ID and course ID combined as a primary key so why we are focusing more on primary key so whenever we are we are having a primary key now the query becomes very easy so if you are having a primary key you can just give that particular primary key and you can make a query key give me the details of student whose student ID is uh a BC or 1 2 3 or anything so in this particular case again if I give the student ID is 1 123 so student ID 1 123 has also opted C1 course student ID 1 23 has also opted C4 course so student ID is not something which can act as a primary key again C ID is also something which cannot give me uniquely identified records so what I do is can combined student ID and course ID in this particular relationship table to be a primary key so that if I query using student ID and course ID I can get the details for a particular student I can get the student name who has uh who has student ID as S1 and who has course ID as C1 I can get the student name who is having the student ID as S2 and course ID as C3 so I can get to know about all the courses student has opted and what all students are present there like the query becomes much more uh easy and useful whenever we are having a primary key so uh the first question was What would be the primary key so in this particular case the primary key would be the combination of both foreign keys or the primary keys from both the table now the second question which comes into our mind is can we reduce these tables so uh in one to one one to many and many to one relationship with were able to reduce the table because in two tables the primary key was same but here you can see S ID is the primary key here you can see C ID is the primary key but here S ID and C ID sorry it's not B ID C so S ID and C ID are combinely acting as a primary key so the answer to this question is no be reduced so the answer is no the tables can't be reduced so the total number of tables would be three and the primary key would be the combination of foreign keys or you can say the primary key from E1 entity plus the primary key from E2 entity so since we have completed all the mapping constraints let's just re- revise once again in a very quick go that how what are all this one to one one to many many to many and many to one relationships so let's start from one to one relationship in one to one relationship what happens if the records in the first entity is associated with the records in second entity in one to one manner that is one record in one entity would be associated with one record of uh one record in entity 2 so consider that there is a person and there is a pan card so for each person there would be one pan card so person P1 is having a pan card as C1 person P2 is having pan card as C2 and person P3 is having a pan card as C3 so this is one to one relationship the very first question is what would be the primary key of relationship table so primary key can either be the one from the E1 table or primary key can either be the one from E2 table so any one of the any one of them can act as a primary key now the second question is can we reduce the tables so the answer is yes we can reduce the tables and we can combine the tables the two tables uh like the relation table and the table which is having the primary key same as the relation table can be combined and three tables can be modified into two tables now the second relationship is one too many so whenever one record in the entity is associated with many records in another entity that is called as one to many relationship so consider person and mobile number so one person P1 can have mobile number like like can have many mobile numbers so one person P1 is having a mobile number as M1 and one person P1 is also having a mobile number as M3 now P2 is having as M2 so this is called as one to many relationship now again the same question what would be the primary key of the relationship table so the primary key would always lie at the mini side so mobile number is the Min side so a primary key would always be in the mobile number side so primary key would be the one which is acting as a primary key in the mobile number site now second question is can we reduce the table so as of now we have three tables person has mobile so the first table base table then the second table then the third table relation table yes we can reduce the table so tables can be reduced so primary key would be Li lying at the mini side so we can combin this has and mobile into one and person would be one so basically there would be two tables after reduction now the third one is many to one now many to one again many books can have a a single author so B1 is also having author as A1 B2 is also having author as a A1 B3 is having author as A2 so in many to one again what would be the primary key of relation table so the primary key of relation T table again the primary key which lies in the mini side that is the primary key in The Book Table would be the primary key in the relation table again can we reduce the tables so there are three tables author sorry book written by author so primary key right now is lying inside the book so we can combine this book and uh written by that is this relation table and we can combine it into one so there would be one table this and there would be one author table so two tables so we can reduce the number of tables now the last is many to many relationship again uh the example is student and course one student can opt many courses many courses can be opted by many students so again this is a many to many relationship the first question is what would be the primary key of relation table so the primary key of relation table would be the primary key of student table plus the primary key of course table so there would be a combined or that is also called as composite key that is two primary Keys now second is can we reduce the table so the answer would be no we can't reduce the table because again uh there is a composite key uh there is a composite primary key so since composite primary key is existing and for different entities there is only one primary key so we can't combine the table so reduction of tables is not possible so why we are knowing about this participation constant ER relationships entities attributes and much more things so what happens now ke consider in a very vague way you have been given an API to design so what you will do the very first thing is you will know the requirements ke what are the request of your API what would be the responses of your API and much more things now second you would be asking for a lld diagram that is a low-level design diagram okay your API is internally calling this particular clients and this particular manipulations are done inside so you will ask for the lld once you get the lld diagram you would just implement the code and then the API would be working in the similar way what happens is can whenever we are designing any database we first get the requirements for the database that what are the like entities in the database what would be their characteristics and much more things once we get all the entities the primary key the attributes or the basic requirements we go ahead and uh draw the ER model using that entities then establish a relationship between entities and draw all about the characteristic the relationship and much more things now once we are done with the ER model that is the visual representation of our API what we do is can we go ahead and draw the tables for that that is the relational model so we draw the tables for all that particular design or all that particular visual representation we had now for that particular tables to show in our laptop or to show in our database what we do is can we use a programming language for the same that is equal so here also what we are doing is since we are knowing more about ER model and as I told in the very end of this ER model uh series or you can say in the very end of this ER model topic we would be designing an uh model for Instagram so basically whenever we are designing such a huge uh database like Instagram is having such a huge database or any social media or any delivery platform which is having such a huge database they have many things like they tend to use some of the best practices they tend to use or they tend to do the code reusability they avoid the data inconsistency and much more things so here also comes into the picture the participation now what is the participation constraint let's go and understand so from the definition participation constraints in ER model define whether every entity in one group must be connected with at least one entity in another group or or if the connection is optional so what happens in the participation constraint as you know that in ER model we basically deals about entities and their relationship consider that there are two entities they are having a relationship among them now what kind of relationship they are having we have learned about what kind of relationship they may be having strong relationship weak relationship how they are internally mapped we have learned about mapping constraints one to one one to many many to many and many to one now in this this particular video we are knowing about what is the participation of that particular entities so if two entities are together in a relationship how they are participating is each record in one entity is participating with another record in uh present in another entity so what kind of participation so basically from the participation constraint you can understand from the word itself how entities are participating in the relationship we deal about that in the participation constraint so whether every entity in one group must be connected with at least one entity in another group or if the connection is optional so there are two types of participation constraint one is total participation and second one is partial participation so partial participation is called as optional and total participation is this in which one entity in another group must be connected so must be connected is the total participation and optional is the partial participation so let's learn about these two participation so the first participation is the total participation so what happens in total participation in total participation constraint each entity in a participation set must be associated with at least one entity in the related entity set so what it says is each entity in the participation set so This Is the participation set and this is the the related entity set when we are seeing from the Department point of view so whenever we are seeing from the Department point of view Department Is the participation set and employees in the is the entity set now here you can see there are two entities employees and Department employees having some attributes or characteristics in which Eid is the primary key department is also having some attributes and character characteristics in which department ID is the primary key now you can see here I have given a single line but here I have given two lines so basically these two lines means the total participation so what it says is the employee Works in a department every Department would be at least having one employee consider that there are many uh engineering department HR department sales department and much more consider today I'm making one more Department XY Z so if there there are no employees in this department does this department makes any sense so in the same way that in each department there would be at least one employee so department is having a total participation with employee that in each department there would always be an employee but it's not true that each employee would be working in a department there could be some more employees which doesn't work in a department they just come on a contract basis or something like that so there could be a possibility that every employee is not associated with department but every Department must have a employee in the same way you can also take an example of this relationship considered that there is a customer who borrows loan so there are two entities loan and customer and borrow is the relationship now every customer borrows a loan so consider there are loans L1 L2 L3 so L1 may be associated with one customer L2 may be associated with one customer L3 may be associated with one customer but there won't be any loan which is not associated with any customer how come there is a loan for which there is no customer right so loan would always be having a total participation with customer but for customer there might be some customers who are not taking loan who are not having any loans so customer can exist individually or can have a partial or optional participation that not every customer needs to have a loan but every loan is somehow associated with one customer so in the partial participation in partial participation constraints entities in the participating entity set may or may not be associated with entities in the related entity set so if we are seeing from the employees point of view this is the participating set and this is the Associated entity set or you can say related entity set entity set now not every employee from the participating set should be associated with related uh related entity set so not every employee should be present in uh all the Departments or a particular Department every Department should have an employee but not every employee should be a part of any uh Department in the same way every customer can borrow loan or loan is something which is associated with every customer but there may be some customers who don't wish to borrow loan right so in this example not every customer is borrowing loan some customers are borrowing loan some customers are not but each loan is associated with one customer because there can't be any loan which is not associated with any customer so these extended ER features comes into picture now because what happens is sometimes when we are drawing the ER model or when we are drawing the entities there might be a possibility that the structure becomes so complex there is no code reusability there is some data inconsistency which is also occurred so to get rid of all these to lesser the complexity to increase the data consistency and much more things we come with the extended ER features so let's see about this so again the question is why do we need we design ER model for relationship between entities now in the real world the data May exhibit some hierarchical relationships and the eer that is extended entity relationship model provides the mechanism to represent this relationships accurately which helps in code reusability ensuring data integrity and consistency and lowering the complexity so uh in the real world consider that there is a person now person may have some attributes such as name age now this person may be acting a different roles at different platforms or different areas so this person may be a student so student may have details such as student ID student uh Adar card or something like that or student subject now this person may also be when he or she is like uh doing some online shopping or doing some uh taking some orders or giving some orders may also be acting as a customer for any of the website so when the person is customer it may have customer ID customer order detail and much more thing so what is happening now there is one entity person which is now being overburdened with all the attributes such as name age now there is student Adar student subject student ID customer ID customer order ID so what happens in this case now if they just split it into different subgroups such as customer and student and now the attribute which is common among both that is name so name stays with the person just a second name stays with the person some attributes such as age which is also common for person customer and student so it Remains the Same but when we are coming to customer there are some distinct attributes which only customer have student doesn't have so such as customer ID so customer ID stays with the customer and for student student subject so in this way what is happening now we are subgrouping the entities into different entities so uh these kind of things like hierarchical relationship which is being established so you might have seen in inheritance that there is a super class and there is some subass so in inheritance what happens is the super the sub class or the child class inherit all the properties present in the super class in the same way the person is having name and age which is now inherited with customer and student but now student and customer also have their distinctive attributes such as student ID and customer ID so basically in this extended ER features we would be seeing three features first one is specialization second one one is aggregation and third one is generalization let me just give you a overview about all these three then we would be separately looking about all these three in details in next set of videos so in specialization what happens as I told that person maybe person may have some overburden attributes because person may be acting as a customer person may be acting as a employee person may be acting as a student so person entity all alone may be having many attributes so what we do is can we subgroup group person enti uh entity into different entities such as person may be subgrouped into customer uh employee student so that the attributes are not overburdened to the person and also customer employee student may have their distinctive attributes so that is called a specialization in this we do a top- down approach and it follows the concept of inheritance now coming to the second one that is aggregation now AG agregation from the word it means aggregating something so what happens in aggregation is now sometimes there are some relationship which is tary relationship so more than three entities are involved or n relationships in which more than three to four or five many entities are in involved so when there are involvement of more than two entities or there are involvement of more than degree two then what happens n the uh structure becomes very complex so when the structure becomes very complex what we do is can we add aggregate the higher level entities and then we establish a relationship between two entities so in aggregation what we do is we do abstraction of the higher level entity into one entity and then we establish the relationship again if you're not understanding no worries we would be looking in depth about all these in the next set of videos now in the generalization what happens so in generalization consider that there are two entities first is the saving account second one is the current account now the saving account and current account may have have some attributes which is common among saving account and current account so why not to make a generalized attribute that is account which would be having account number and account name which is present in the saving accounts as well and current account as well so basically in specialization uh we are just identifying the subgroup entities in generalization using that subgroup entities we are uh guessing the generalized attribute generalized entity now what is specialization so as explained in the earlier video what happens is you consider there is an entity person so let's take an example of entity person now person is a employee as well when it's working in a company a student as well when it's working in uh or when it's studying in a college or school and is a customer as well when he or she is doing some online order or online buying so person acts as an employee student and cust customer now what happens is ke person is having some attributes such as name age now coming to customer customer may have some attributes such as customer ID customer order details now coming to student student may have student ID student subjects now coming to employee employee may have employee ID salary and much more things so what is happening now this person entity is getting overburdened with many attributes so what we do is if we split or we subgroup the person entity into different sub entities such as employee student and customer and the attributes which are same in all these three that is name and age stays with the person and the distinctive attributes which is not common among employee student and customer such as employee ID student ID and customer ID is provided to them them so what happen specialization is ke specialization in ER model is like categorizing entities based on the common features a super type group of entities with shared attributes and relationships while subtypes have their own unique attributes that is e ID S ID and C ID and the share attributes are name and age so a super type group entities with shared attributes and relationships while subtypes have their own unique attributes and relationship ship it's a way to organize data efficiently it is a top- down approach so as you can see now person is being subgrouped into employe and student so it is a top- down approach it is basically following the inheritance way that there is a super class and there are some subclass which is inheriting properties from the super class so let's understand from an example so here it is a person okay I just missed the last line we have a is a relationship between the super class and the subass so person is the super class an employee and customer are the subass and there is a relationship there is a is a relationship between person employee and customer so person is a employee as well as customer now person may have some attributes that is age and name which is common among employee and customer but employ employee ID employee salary and customer email and customer ID is something which is distinctive so in the super type all the attributes remain shared which is like shared in the child classes all also or the sub classes also and in the subass there are attributes which are distinctive so this is specialization basically in specialization what we do is can we subgroup the entities into different groups like person is subgrouped into employee and customer uh person may have some attributes which which is common between employees and customer but employees and customer may have some distinctive attributes so generalization generalization is like finding things that are alike and putting them into a bigger group to represent what they have in common it helps making things simplers and organized now uh in specialization what we were doing is ke considered there is a person now we were subgrouping the person into customer employee and consider student now in generalization what we do now can consider that we have this subgroups student and employee now they may student may have some attributes like uh name age or something like that employee may have some attributes as well so what we do is can we make a higher level of entity that is person which would be kind of uh having the common things in student and employee so in specialization we were identifying the subgroup entities and in generalization we are uh identifying the generalized entity so it is a bottom up approach as student and employee together are forming a person so it is a bottom up approach we have is a relationship between the subass and the super class so this is the super class and this is the subass so let's understand from an example so here in the example you can see there is electronic device so consider that I have two entities first one is mobile phone and second is laptop now mobile phone may have some attributes and laptop Also may have some attributes so consider mobile phone is having an attribute such as battery uh mobile phone may have memory then it may have mobile ID and it may have the mobile type in the similar fashion laptop may have laptop ID laptop serial number again laptop also would be having an attribute such as memory and battery now you can see memory and Battery memory and battery is an attribute which is common in both of these mobile phone and laptop and it is a general attribute of an electronic device so what we do is can we make a generalized entity that is electronic device which would be now extending battery as well as memory and we remove this battery and memory from here and we remove this battery and memory from here as well so what we did is if we generalized some of the attributes which was common in the sub entities so this is what we are doing in this diagram as well ke there is a electronic device laptop and mobile is a relation is having a relationship with the electronic device as it is a bottom up approach electronic devices now having memory and battery and laptop have their distinctive attributes such as laptop serial number laptop ID Mobile ID and mobile type so this is generalization so basically in the specialization what is happening in the specialization uh we have an entity and we provide some subgroup entities which have some distinctive attributes in generalization what we do there are some uh subgroup entities which are having some common attribute so we make a higher level of class or we do abstraction of a higher level of class which would be having all the common attributes or common uh characteristics these two would be having so there is one more thing in extended ER features first one is attribute inheritance and second Is the participation ation inheritance so in attribute inheritance what it says is can both specialization and generalization exhibit attribute inheritance what is this he considered there is a person who is having some attributes so employee and student who is inheriting person would be having the same attributes so it inherits the same attributes in participation what it says is if parent is participating in some relationship so child would also be participating in that relationship so considered person is a parent and employ and student is a child so if parent is participating in any relationship employee and student would be participating in the same now there is one more feature of extended ER that is extended entity relation that is aggregation now let's understand what aggregation is all about so aggregation is like stacking things on top of each other to create a structure it is used to create a hierarchical structure in data modeling showing how a higher level entity is composed of lower level entities so basically in aggregation what happens now can we may we have heard about relationships and types of relationship like binary relationship tary relationship and more like if more entities are involved then there are more relationships so what happens now whenever there are more than two entities which are being involved there is a complexity which is increased very much so when the complexity increases it's very difficult to understand the ER model as well so what happens can whenever there is uh ER model which is extending the degree to or extending or being a tary relation or more than more complex than that what we do is if we generally create a hierarchical structure showing how a higher level entity is composed of lower level entities so what we do is if with that lower level entities we make a higher level entities and try to generalize or try to make it in such a way ke it again uh comes in a entity to entity the relationship so this may sound confusing right now let's understand from an example first so abstraction is employed to view relationship from a more General perspective focusing on a higher level entity so we've basically used the abstraction concept and we make the lower level entities as one entity which is a higher level entities and in that higher level entity there is a relationship among different entity so this is the uh this is the ER model which is present before aggregation so there is an employee which works in a department is also having a job and now this employee also manages a department because this employee is a manager so consider there is a company now in company there are many employees some employees are developers some employees are QA person some employees are HR person and there is a manager who manages a particular Branch or a particular Department in a company now that particular man manager is also serving as a employee that particular manager is also having a job that particular manager is also managing the department so what is happening here is the employee is working in a department is also having a job and now employee is managing the department that is called as manager so you can see that there are many entities involved and this ER model is kind of complex so what we do in aggregation is can we combine these lower level entities into a higher level architecture so in a higher level what we do is can we segregate all the lower level entities into one complex architecture so we segregate all the lower level entities into high level architecture now what it shows is ke employee Works in a department is having a job and employee manages as it is a manager so basically what we are doing is we are segregating all the lower level entities into a higher level architecture and then we are establishing the relationship so this whole is treated as entity one and this hole is now treated as entity 2 so there is a relationship between entity 1 and entity 2 that is entity one manages entity 2 so basically manager manages the department u in which manager is also working as an employee and having a job so in aggregation what happens is whenever there is a relationship or whenever there is a ER model in which the degree is extending to what happens there is a comp complex architecture so just to break down that complex architecture into some simple architecture what we do is with that lower level entities we combine all the lower level entities into one higher level architecture and then we establish the relationship as we establish between two entities so steps to draw an ER model till now we have learned all the things about ER model like what are entities types of entities strong weak then types of attributes complex composite multivalued then coming to the relationships based based on cardinality or degree that is tary binary and much more based on mapping constraints that is one to one one to many many to one and many to many then about total participation and partial participation then extended ER features all of things we have known so uh we would be knowing about how we can draw an ER model so the very first step is recognizing the entities now consider you have given a problem statement that you have to draw an ER model for minra app so you have have to identify all the entities which are there so the very first step is recognizing all the entities such as if you are drawing an uh ER model for Library so there would be some Library Department there would be some uh book type there would be an entity of book there would be an entity of uh details there would be an entity of uh all the details of when you are publishing the book when you are returning the book and much more things so there would be some entities so you need to identify all the entities now the second thing is when you have identified all the entities now you need to know all the characteristics or all the attributes of that particular entity consider again taking that Library example there is a book so book may have book ID book author book issue date book uh submission date and much more things so we need to specify the characteristics or identify the attributes now the third step is discover connections and relationship also constraints like mapping and participation now we need to discover the relationship that library has books so there is a has relationship that library has books now there are some mapping constraint that what uh it would be the relation one to one one to many many to many or many to one what would be the participation constant either is it a total part participation or is it a partial participation now in the fourth we are defining the connection types that how entities are connected or cardinality again based on degree or the mapping constraints we identify that if it's a one andone relationship one to many many to one many to many total part participation and partial participation now in the fifth way what we do is now we construct an ER model now we are ready to construct an ER model we got the entities we got the characteristics that is attributes we got the relationship among entities also we got that what kind of relationship they have what kind of participation they have what kind of mapping they have like we got all the details now we can go ahead and design the ER model for the same so construct an ER that is entity relationship diagram now the sixth step is annotate relationships and attributes so there may be a possibility that there is a derived attribute which would be represented like this there may be a possibility that there is an attribute which is a primary key which would be represented by this there may be a multivalued attribute there may be a composite attribute so we have to annotate the relationship and attributes the seventh step is review and refine the model so again you can use that extended ER features whenever you are seeing that the complexity is increasing you can use that extended ER features that is specialization aggregation and generalization now document the model so you can also go ahead and document the model that what all things you have done like you can document that library has a relationship with books books has a relationship with the details or books has a relationship with students who are taking the books like these so you can uh document all the relationships which books have which library has with student has in a proper documented format now you can validate that document with the stakeholders that uh is my understanding correct that there is a on toone relationship the The Entity is having three attributes among which one is the composite attribute and uh the relationship is one to one or one to many like this and the 10th step is implement the database schema so now you can go ahead and implement the database schema or you can go ahead and uh formulate the relational model or formulate the tabulated model for the S before moving forward I would like you guys to know what Instagram is so yes it's a lame question because 99.99% of the people would be knowing about Instagram but just for the people who are not knowing or just to give you a short revision about it so Instagram is basically a social media platform where you upload your picture where you upload images videos stories have friends like followers then you follow your friends which is called as following then you upload your uh profile picture then you have some bio and there are much more things which is there in Instagram so Instagram is a social media platform that allows user to share photos and videos now what all things are there in Instagram or what all things we can do on Instagram so the first thing is create our own profile so everything starts with creation of a profile so we create our profile then we add a profile picture and some details like your bio that where you are working right now or if you are a musician you can me mention that that you love playing music or singing or you love playing guitar and much more things you can mention now the third thing is connection with your friends or connect with your friends so basically on Instagram whenever you are done with the profile file creation and whenever you have uploaded your picture and some bio about yourself then you can start connecting with people you can upload a post you can like and comment on different post share stories and much more things are there so why right now I explaining about this is because I want you guys to have a basic idea about how Instagram functions what all things we can do on Instagram on basis of this we would be formulating an ER diagram now let's start with all the steps which are needed to draw an ER diagram so the steps which I told you in the last video we would be going step by step and we would be formulating an ER diagram so there the step one was recognizing all the entities so uh here the entities are user profile so user might be having a profile I told firstly what happens is user create a profile so there is a user profile which is created so user profile is the first thing now when the user profile is created he or she will upload the profile picture add some details about them and then we'll start connecting with friends so the second thing is user friends so the second entity here is user friend now the third entity is uh we have created a profile we have connected with our friends now we would like to upload some photos or videos so the third is user post the fourth entity is user loging so whenever you go to any social networking platform like Facebook LinkedIn Instagram so there you get a login page where you enter your username and user password and then you are redirected to that particular uh social media platform where you can see your profile and timeline as well now the fifth entity is user likes so if you upload your post there might be some people who would be liking your post if you are connected with some of your friends you would also be liking their post or commenting on it or sharing it on different social media platforms or sharing it on your story and much more things so these are the five entities as of now I have taken these entities into consideration because again if I increase the number of entities the ER model diagram would be very complex and it's not imposs to include all the entities all the attributes in the same model or in the same diagram so as of now we are seeing a template which we can follow for a ER model of Instagram so these five entities are right now recognized as the entities which we can use further in the ER model now the second thing is specify entity characteristics or attributes now we have specified that what all entities are there like user profile user friends user login user post user likes now we need to identify what are the attributes or what are the characteristics of that particular entity so first we'll start with user profile so in user profile there is a user ID there is a username there is an email and there is a profile pick now user ID is serving as a primary key because it can uniquely identify records in a table the second is username which is a composite attribute so composite attribute what it means he username can also be further divided into sub attributes like user first name user middle name and user last name email is a single valued attribute profile picture is a single valued attribute do is a stored attribute stored attribute again is something which is stored and derived attribute is something which we derive from the store attribute so here user ID is the primary key usern name is the composite attribute email is a single valued attribute profile pick is a single valued attribute do is a stored attribute and age is a derived attribute now coming to entity number two that was user friends now user friends have these attributes such as follower ID follower name and user ID now you can see user ID you have seen that user ID in the user profile as well right and it is present here as well so there is some kind of relation which is present between user profile and user friends so if a primary key of one table is present in another table and referencing it that is called as foreign key which we have learned in the last videos so we would be uh having a good look on this uh in the ER model diagram right now considered that user ID is right now acting as a foreign key which is referencing to the primary key of the user profile now uh user friends is having a follower ID which is serving a primary key for this particular table now follower name which is a single valued attribute and user ID which is also a single valued attribute now the third entity is user post now user post is having a post ID a caption about the post or if you post any image then there would be a caption image video likes count and time stamp the time at which you have uh uploaded your picture or the time at which you have posted your picture or videos so post ID is acting as a primary key for this particular user post table caption is a single valued attribute image is multivalued because you have seen that sometimes in one post there are many images so there could be many images which could exist in single post so that is why it is a multivalued attribute that is one attribute may have multiple values or multiple things so video is again a multivalued attribute likes count is a single value attribute it would be numbers like 1,000 2,000 time stamp is also a single valued attribute now coming to the fourth entity that is user login now user login is having a login ID login username name and login password now in this the login ID is serving as a primary key the login username is a single valued attribute and the login password is a multivalued attribute so coming to the fifth attribute this is fifth is the user likes so user likes is having a post ID and user ID so here post ID is serving as a primary key and user ID is a single valued attribute so now you would be seeing there are some of the attributes which are being repeated in some of the tables like user ID is also repeated post ID is something also which is repeated in the user post and user likes table so again there is a repetion of attributes because these attributes are somehow serving as a primary key in one of the table and in other table to establish the relationship they are serving as a foreign key so what foreign key does is ke foreign key help us to establish a relationship between two tables uh when we go forward in the video you would be having a more better understanding so for now just you can understand from this way if you're seeing some repetition of attributes in different tables so there could be a possibility that one table is having a relationship with different tables so in that different tables there is a attribute which is present which is serving as a primary key in table a and right now is serving as a foreign key in table B table C or table D now the step two discover connect connections relationships also constraints like mapping and participation now we have to discover the connections and linking or the relationship between them as I told like right now only now what happens is we use the primary key to establish a relationship between two tables now we have also uh learned about the relationships like types of relationships based on cardinality or mapping constraint that is one to one one to many many to many and many into one so on the basis of that we will now establish the relationship between those entities so the very first step was to identify the entities The Next Step was to identify the attributes or the characteristics of all those entities and the third step is to establish the relationship between the entities to uh know the mapping constraints like how they are mapped with each other one to one one to many many to many or many to one now here the first relationship is user profile will have user friends so n number of profiles can have n number of friends now the second one is user profile have user post that is one user profile can have n number of post so that is one to n relationship that is user post will always be Associated to user profile therefore there is a total participation I also explained about types of participation you can have a look on the earlier videos and then you can come and have a look on this particular video so the third one is user profile has user login now one user profile always have one user login so consider that there are two profiles which is created one I have created one my sister has created again my sister would be having different user name and different password I would myself be having different username and different password so there is a one toone mapping now the fourth is user profile has user likes so one user profile can like many post like like there are many friends of mine so I'm liking every post uploaded by them so one user profile can have number of likes like many number of likes so user likes will always be Associated to a user profile therefore there is a total participation now the fifth is user friends have user post so user friends can also upload some post right so user can consider that there are multiple user profiles user profile one user profile 2 user profile 3 user profile one and user profile 3 are friends in like they both are friends so user profile one can also upload many photos user profile 3 can also upload many photos so user friends may have user post that is one to uh n relationship that one user friend can upload many post so it will also be Associated to a user profile therefore total participation so uh why this total participation term is coming every time so what happens now there is a user friend right so if there is a user only then a user friend would be existing if there is no user then user friend is associated with whom right so user friend is existing only when there is a user which is existing so therefore there is a total participation now user friends has user login so user friend can also have a user login again it would be in a one to one manner because one user friend can have a one user login another user friend would be having another user logging so it is one to one fashion now seventh one is user friends has user leges so user friend can also like other uh photos can like their own photos can like other friends photos as well so that is one to1 relationship and again here user likes will be Associated to a user profile therefore total participation so again if there is no user profile which is existing then user likes doesn't makes any sense so there should be at least one profile which should be existing so that we can count the user likes now this is the ER model of Instagram uh I know it is a bit complex but let's understand from the very beginning I'll make sure that you understand each and everything and even if you don't please watch the video again and the steps to design an ER model video as well because uh that video is also very important video in terms of understanding again there are terms like total participation strong entity weak entity mult mul valued attribute composite attribute that wouldn't make any sense if you don't watch the earlier videos so first watch all the earlier videos and then you can come here and then have a look on the year model of Instagram so let's start so let me just switch it to this one okay so we will start with user profile now user profile is an entity user profile would be having username user ID email profile file pck do and H so here I have mentioned it so the user profile is having user ID usern name email and profile pick now uh user ID is serving as a primary key so we have underlined this email is a single valued attribute profile pick is a single valued attribute age is a derived attribute and do is a stored attribute so in this way we represent the stored and derived attribute and here username is asking uh is serving as a composite attribute so when there is a composite attribute it is an attribute which can be breaked into subp parts so username is now breaked into first name and last name so this is about the user profile now user profile has some relations so the very first relation is user profile have user post the second relation is user profile has user likes the third relation is user profile has user login so first start with user profile has user login so now user profile has user login every user would be having only one loging details so there is a one to one relationship now user login is having some of the attributes such as login ID and login name login ID is here serving as a primary key now coming to the second relation user profile have user post so user profile have user post so user profile one user can have multiple post right so there is a one to n relationship between them and in the user post here you can see there are some of the attributes such as post ID image timestamp video and caption now caption here is uh working as a single valued attribute video here is right now a multivalued attribute why so because multivalued attribute is a attribute which can have multiple Valu so there could be multiple videos for a single user right so in the timeline you can see for a particular user you can find multiple videos and multiple images so here video is working as a multi valued attribute image is also serving as a multivalued attribute Tim stamp is a single valued attribute and post ID is here serving as a primary key so we have made it underline now coming to the third relation user profile has so user profile have user friends now you you can see that I have made it two rectangles why so because here the user friend is a weak entity so we have read about strong entities and weak entities why user friend is a weak entity and why user profile have user friends is a weak relation because uh if there is no user there wouldn't be any user friends right so it all depends on user if there is no user there won't be any user post there won't be any uh user likes there won't be any user logging or something like that so for now just to make you or to give you more clarity about weak and strong entities and weak relationship I've used this here just for an example right so uh when you are asked to draw an ER model in the interviews you can go ahead with the basic template only but when they ask you to specify everything like the strong entity weak entities total participation partial participation then you can go ahead and point out everything that this is a weak entity and you can give an explanation why this is a weak entity so again user profile and user friends have a end to end or many to many relationship because many user profiles can have many friends same way many friends can have many user profiles so here user friends is having a user ID and follower name now you can see user ID which is present here as well and here as well here user ID is working as a primary key in user profile table and here user ID somehow establishing a relationship between user profile and user friends so it is acting as a foreign key which is helping to establish relationship between user profile and user friends now user profile have user post uh this I have explained so this relationship is explained this relationship is explained this one is explained now coming to this relationship so now user profile has user likes so again uh a user profile can like many post or can have many post which can be liked by a particular user so that is one to many relationship now user likes is also having one user ID which is serving as a foreign key which is helping to establish relationship between user profile and user ID and user like is also having a post ID as a primary key now again user post can also have user friends like a user friends can also have user post so there is one to n relationship between user friends and user post user friends can also have a user login so there is also a one to one relationship between user friends and user login and uh I guess yeah so user friend can also have a user likes so there is also one to n relationship that is one friend can have many likes so there is one to one relationship between them so this is all about the ER model of Instagram again it is very complex to understand but right now I have taken very less ID entities and very less attributes to make you understand it at a very clear picture if you're asked in an interview to draw or design an ER model of consider Facebook consider LinkedIn or consider threads so you can use this particular ER model as a template but always think about all the important entities which you shouldn't Miss because again there are many entities and you can't take all the entities all the attributes and draw an ER model you have to pick some of the few of the entities which are important according to you few of the attributes and you have to draw an ER model also do take care to follow all the design patterns like if there is a multivalued attribute there would be two circles if there is a derived attribute there would be a dotted Circle if there is a weak relation then there would be two diamonds if there is a weak entity then there would be two rectangular box so always make sure to mention all these because all these things would really help you and the interviewer as well to understand that you have a very great knowledge about ER model and DPMS so we read about ER model in the last set of videos now here we would be knowing much more about the relational model now why we are knowing about all these models how it is helping us and why we should be knowing about relational model tables relation and much more things so what happens now you are given a requirement consider you are given a requirement that you have a banking system okay so now what you will do is you firstly you will draw the ER model for the banking system now secondly you will convert this ER model into relational model so in the ER model we basically deal with the visual representation and in the relational model we deal with the tabular representation and when we are done with the relational model we will choose a software using which we can insert all the datas do some manipulation on that data or perform some crud operations so this is how the flow goes now in this particular video we are learning about relational model so what is relational model it it is a way of organizing data into tables now what happens is can consider there is a banking system now for that banking system I have given a visual representation of that backing system using all the entities all the attributes now from that visual representation what I'm doing is I'm using that visual representation to convert it into a Tabler format so basically conversion or organizing data into the form of tables is called as relational model now there are some terms which are mostly used Us in the relational model the first one is table which we called as relation in the relational model the second is row which we called as tle in the relational model the third is column which we called as attribute in relational model the fourth is record which is each row in a table the fifth one is domain which is the type of value an attribute can hold sixth one is degree which is the number of columns in a relation and seventh is cardinality which is the number of t understand from an example so this is a table now the table would be having some rows and some columns so the columns are called as attributes in the relational model the rows are called as tle and each row is called as record now the table itself is called as a relation now domain so consider that this is the attribute which is name now name can only have character values consider this is the attribute which is age so now age can only have integer values so we are giving the domains of both of the attributes now the sixth is the degree degree is the number of columns in a relation or attributes so you can count 1 2 3 so the degree here there is three and cardinality is the number of tles or the number of rows that is 1 2 and three so cardinality is also three in the ER model cardinality basically means the mapping constraint that was one to one one to many many to many and many to one relationship but in the relational model cardinality basically means the number of doues and degree basically means the number of columns now what is relational model all about so relational model is all about data being organized into tables establishing relationship between tables using foreign key as I explained earlier maintaining the data Integrity that set of rules should be there that uh if uh there is a attribute which is called as age in that attribute I shouldn't fill the value as AB BC so there should be some Integrity constant which should be present that there is a domain that is integer only integer values are accepted here if I insert other values apart from integer it will give me an error and then the fourth one is a flexible and efficient way to store data which is using the SQL and to retrieve data so these all four things combines gives us the information about relational model let's have a look on what all are the things we take care in the relational model so the first thing is maintaining the Integrity constraints like domain entity and referential integrity now consider that there is is a table person now person is having attributes as name age and date of birth now there could be a possibility that someone inserts a wrong value in the age consider ABC so there are some Integrity constraints which make sure that we don't insert any data apart from the domain now the second is the value should be Atomic that can't be divided further so uh whenever we give the attributes or whenever we provide the attributes in the relation model that all the values should be Atomic it shouldn't be that I am giving a multivalued attribute in a table so if I'm giving a multivalued attribute consider that there is a usern name which is a multivalued attribute so while making the table I shouldn't give it as username what I can do is I making the table and here I'll give the user first name here I'll give the user second name or middle name and there I'll give the user last name and the then the other attributes which means that all the values should be Atomic that it can't be further divid now the third is each row must be unique and here the keys comes into picture that is candidate super and primary so so converting an entity relationship that is er model into a relational model involves several step so let's start with step step one step one is identifying the entities so first list down all the entities like the strong entity and the weak entity in the entity video I told you about the strong and the weak entity so you can go ahead and watch that particular video uh it would be I guess like it would be 10 lectures behind so you can have a look on that for uh your convenience I'll give the link in the description itself so uh here you can see that there is a ER model of a person person which is having a relationship with address now the person is having some characteristics or attributes that is ID name and age and here ID is acting as a primary key for the person table now person is a strong entity coming to address so address is having attributes such as City flat number and street here address is a weak entity why address is considered as a weak entity because considered that there could be a situation that there is no person so if there is no person or there is no existence of person does address plays any role in a similar way like there is student and there is a course if there are no students who would be taking the course or who would be studying in that department so basically address here is serving as a weak entity and person here is serving as a strong entity now when there is a relationship between strong and weak entity that is called as weak relationship which is indicated by Double Diamond and whenever there is a weak entity it is indicated by dou double rectangles so what happens is when there is a strong entity we mention all the attributes of the entity to uh formulate into a tabular format so basically person would be a table which would be having columns like ID name and age where ID is serving as the primary key but in case of address which is a weak entity what we do is since strong entity and weak entity are establishing a relationship between them so I've told you earlier what happens is whenever we need to establish a relationship between two entities we use the foreign key concept what does foreign key does is the foreign key is a key which helps to establish relationship between two tables it serves as a primary key in the table a and it serves as a foreign key in the table B so whenever table a and table B wants to have a relationship between them what they do is if table a is having a primary key it took that primary key and make it a foreign key in table B so that table a and table B has the same attribute which can help to form a relationship between these two tables now in address table what we are doing is here mentioning the primary key which is from table person then we are giving all the attributes such as flat number Street and City here flat number is acting as a primary key generally in Weak entities there is no concept of primary key because again The Entity itself is weak but there is a unique identifier and we called it as primary key so here ID plus flat number both would be acting as a primary key because ID here is acting as a foreign key which is referencing to the primary key of another table and flat number is acting as a primary key for this address table so basically there is a composition of ID and flat number that is why it is called as a composite key and this composite key is serving as a primary key for the address table so when ever we would be making a uh table for both of these entities strong and weak in the strong entity we would be giving all the attributes along with the primary key in the weak entity we would be giving the attribute which is a foreign key which references to the primary key of strong entity table along with that we will mention all the attributes and the primary key for this table would be a combination of the primary key of this table and the foreign key of this table so now the step two is identifying the attributes now again I told you that attributes can be of many type like stored derived single valued multivalued composite so whenever there are such type of attributes in ER model how we will go ahead and design the design it in a tabular format so first thing what we will do is we will differentiate the entities when we differentiate the entities per entity there are some attributes or there are some characteristics for that entity so consider that uh this is the ER model where we are talking about employee and and department so they have a relation that employee Works in a department now employee is having a composite attribute that is name which is further divided into first name and last name employees also having a multivalue attribute that is phone number so one employee can have two phone numbers primary or secondary and here ID is serving as a primary key uh then there is a department which is having Department ID as the primary key for this particular table and Department name as a common attribute or a single valued attribute so let's take the case of name which is right now serving as a composite key so what we will do is ke Whenever there is a okay just a second I guess I have named it wrong so this would be a composite attribute and this would be a multivalued okay so coming to the composite attribute so consider that this name is a composite attribute now whenever we want to draw a table for this employee what we will do is we will mention this employee now we will start mentioning the attributes that is ID now for this uh composite attribute what we do is we mention all the composite attributes because again uh in relational model what I have told you can value should always be Atomic there shouldn't be any value which is not Atomic there should be only Atomic values which can't be divided further so so here uh the last name and first name we are giving as it is employee first name employee last name so we have eliminated this attribute name with employee last name and employee first name similarly if there are any more composite attribute we will eliminate that particular attribute and we will mention all the sub attributes now coming to the multivalued attribute that is phone number now in phone number what we will do is there would be a table with all these things ID employee name employee last name and everything along with that there would be another table because in multivalued attribute what happens is we are saying that one employee can have different number so consider that I'm formulating this in a tabular format so there is a employee ID and there is a phone number okay so consider that there are employee IDs one and two now I'm saying if one is having a number 919 and one is also having a number 929 so again I can't put the attributes like this because this row should have only one value so either it will lead to the duplicacy that I'm again duplicating employee ID and here I am giving 929 rather than here or else what I can do is I can make a separate table where I can give the employee ID and the phone number so here what happens is ke this table will remain the same uh with ID employee first name and employee last name but for the multivalued attribute what I will do is I'll make a new relation with the primary key which is present present here and the attribute which is a multivalued attribute so there would be a new table for the same now the step three is the key selection choose the primary key for each table for some it can be in a form of composite key as I told in this example of weak entity where the primary key is in the form of composite key that is composition of keys now the step four is if entities have a relationship break it down and reduce the number of tables if possible so uh you have seen in the last video where we made an ER model for Instagram so there you have seen that there were many relations between user post user profile user friends so basically there are one to one one to many many to many and many to one on this I have made a video that uh what happens that if there are two tables which is having one to one relationship so can we reduce that tables if the tables can be reduced where the primary key would exactly lie so again if there there are two entities and they have a relation between them there would be three tables first one would be entity one table second would be the relation table and third would be the entity two table and what happens was ke entity two table or the relation table combines sometimes sometimes entity one relation entity one table and relation table combines so about this I have made a dedicated video you can have a look on that as well so whenever there is a one to one relationship there would be two tables and primary key can lie on any s so consider that there is a relation between employee works for department so when there is a one to one relation so there would be two tables for employee and department and third table for relation now consider that there is a onet toone relation so there would be a employee ID which would be acting as primary key here there would be Department ID which would be acting as a primary key here so for the relationship table able to deduce what we do is can we combine these two tables or these two table any of the table we can combine and we reduce it to one table and there is one table so basically uh three tables are reduced to two tables now when there is one to many relationship so whenever there is a one to many relationship what happens is the primary key always lie into the mini side so relation table and the mini table always combines and the uh this table Remains the one and these two table combines into one so there is again two tables where primary key lie on the mini side now when there is a mini to one relationship just reverse of this uh two tables and primary key can lie on many side when there is a many to many relationship three tables would be there because again this table may have some attribute which is associated with this table and this table Also may have some attributes which is associated with these tables so there is no common thing between them so there would be a three tables and primary key always lie in the relation table which would be a combination of primary key from this particular table and primary key from this particular table so what is intention intention defines what kind of data can be stored basically the data type and the relationships between them so whenever we discuss about what kind of data that can be stored in a table and what kind of relationships table can have in between them that is called as intention now this is basically the blueprint or the definition of the database structure so basically in the definition of database we mostly tell that what kind of tables would be there what would be the data which would be present in the tables basically the data type the constraints the table would be having so it basically tells us about the database structure now it doesn't change frequently and its permanent definition of the database structure so it doesn't change frequently because consider that if we have a huge database of employee now now in this employee database we might be having a employee details table employee details table and one about employee previous work history table so employee work history table now in these certain tables there is like very less addition of new columns or you can say new set of attributes which are being introduced so there is not a kind of permanent change which happens very frequently so that is why it is told that it is a permanent definition because the changes are not very frequent yeah maybe there could be a possibility of adding one more or two more new attributes or column but that doesn't occurs very frequently it's very rare so that is why it is called as the permanent definition of database structure now it includes the very first thing table definition so what table definition is basically the name of tables they are columns and the data type allowed in each column so in a database you can have multiple tables what is database database is basically collection of data and tables is basically an intersection of attributes and Tes or you can say rows and columns so here there could be multiple table T1 and T2 so what is this particular table name along with what are are the data types of the data which is being stored then what are the constraints which are provided to this particular data that all things we discuss in intention now the second thing is constraints so constraints are basically the rules that governs the data such as primary key foreign key and data validation rules so constraints basically allows that if this particular data is being stored does it follow this particular rule of a primary key constraint doesn't it the column shouldn't hold any duplicate values because it is having a primary key constraint if it is having a Nal constraint it shouldn't take any null values so that type of validation rules are performed now the third one is relationship between the tables so there could be a relationship between the table like foreign key primary key relationship where in one table is having a shared column with another table uh there is one foreign key which is present in one table and there is one primary key which is being referenced by that foreign key in another table so there is also a relationship which is established between two tables of databases now here is an example so here we have taken an example of a customer table so this is the table name these are the table attributes or you can say column table columns these are the data types of the attributes or the table columns so you can say data types so this proves our first point that it includes the table definition that is name of table they are column and data types allowed now the second thing which you can see here is a constraint which is a primary key constraint there is a rule on this ID column that ID should always hold unique as well as Nal values it can't hold any duplicated values because of this primary key constraint so it also proves our second point that is it includes constraint now the third one is Rel ship between tables since here we are discussing only about one table we don't know that if there are more tables in the database which is existing so for now I haven't given any foreign key or primary key relationship but consider that if there are two tables there could be a possibility that a primary key in first table can be acting as a foreign key in second table establishing a foreign key primary key relationship between the tables so in this way a relationship is also defined so intention basically consists of table name the constraint it has the data type it has the column name it has basically the structure of the database or the structure of the tables which is present inside our database it is the intention in database so let's see what is extension in database the extension is the actual data that is stored in database at a given instance in time so whenever we see the actual data which is stored in database at a given time that is called as extension basically the data which is stored in tle or rows at a given instance of time when there are more tles added the data can change so consider at at a time T1 I am looking at my employee table in this employee table I can see there is ID name and department and there are entry of three people Rahul absara and abhimanu now company hire new individual so whenever they will hire new individual the tle or the row would be filled with new values now if I see my table at time T2 I can see that there are four entries in my table now so our entry for Aditya is newly added at time T2 so at time T1 I was seeing then there were only three people consider after 5 days if I am seeing I can see that there are four people now in that particular employee table consider that after 10 days if I'm seeing the table I can see that there are five entries in the table so Raj is also added newly so at particular instance of time the data which is present in the database is called as extension in database so extension in database is not permanent because there would be more number of employees who would be added there would be some employees who would be also leaving the company so the extension doesn't remain permanent but intention is kind of permanent because in that we basically Define the table structure or the table definition so extenstion is basically the actual data which is stored at a given instance and time intention is the table structure or you can say table blueprint now before learning about rdbms let's learn about database and database management system so what is database database is basically collection of data so whenever we have a collection of data we call it as database now what is this database management system it is a software application to manage our data or you can say to perform crud operations on our data now consider that we have a lot of data in our database now we need to manage that data basically whenever we want to do some Creation in the data some updation in the data some insertion in the data or some deletion in the data so for managing all those crud operation we need a software which will help me to manage my data which is present in the database so that is dbms consider that there is a user now user wants to manage a database so it will use a software application to manage that database and that particular software application is called as dbms now databases are of two type first is relational database and second is non- relational database now what are the differences between them so relational databases basically use table to store data so whenever we are using tables to store our data in databases we call it as relational databases the example are MySQL Oracle and marad DB now what is non-relational databases so whenever the data is not stored in tables we call it as non-relational databases the example is mongodb so they could be stored in key value pair or some different thing but they are not stored in the form of tables so relational databases are the database which is stored in the form of tables non-relational databases are the database which basically follow some other pattern like key value pair or some other pattern to store the data so just now we learned about relational databases now what is a database database is basically a collection of data in that particular database there could be multiple tables T1 T2 what is relational database relational database is a database in which data is stored in the form of tables also the tables which is present inside the database can have a relationship between them so that is why it is called as relational because the tables inside the database can establish a relationship between them so this is relational databases now to perform crud operations or to manage data of the relational database we need a software so that software is called as relational database management system so whenever we use a software to manage data of relational databases we use this relational database management system so these database structure data into organized table that have some predefined connections or relationships between them data manipulation and querying are performed using SQL so we use SQL that is structured query language to perform any kind of data man population or query in our data which is present in our database so we use this as a programming language to perform any kind of cred operation so here if you see there is a user now user is using a software application so in terms of relational databases we use rdbms now an example of rdbms is MySQL so basically MySQL is a software which help us to perform the crud operations and SQL is the programming language which we use to do some manipulation or querying in the data so MySQL is the rdbms and SQL is the programming language which we use to perform the queries now this is the database on which we perform the query so this was all about relational database management system in one word relational database management system are the softwares which help us to manage the data which is present in relational databases now in relational database data are stored in the form of tables and they have some connections or relationships between them so now normalization is quite important in terms of semester exams but it is also asked in interviews as well like tell about normalization what are the types of normalization what is denormalization so this is a important topic so don't skip this video always have a clarity about what normalization is what are the types of normalization in terms of interview point of view so let's understand about normalization so normalization is a process in which we organize the data to reduce rency that is duplicacy of data and improve the data consistency that is same set of data is present across each databases so it involves dividing a database into two or more tables now what is normalization consider that there is a table of employee which is having employee details such as employee ID employee name employee Department name employee Department ID and employee department phone number now there is a table of employ which is having all the details such as ID name Department name Department ID and department phone number consider you enter the details of first employee so employee ID is one name is reti Department name is it Department ID is 01 and department phone number is considered plus 91 something now again you are asked to insert details of second employee who is in the same department so you go ahead and insert the detail of the second employee so here employ ID would be two the name would be considered Raj the department name is it the department ID is again 01 and the department phone number is the same which is given of of now here can you see that this department name Department ID and department phone number is something whenever we insert any details of the employee who is in IT department is getting repeated so here also we are repeating it Department ID Department name here also we are doing the same thing considered that there are bunch of employees who are in IT department so we have to do this repetion each and every time whenever we are inserting any of the employee details who is working in IT department so what happens here is now you consider that if you want to update something that the department ID is considered now 02 so you have to go ahead and update for each and every employee separately so it is kind of of increasing the duplicacy in the database because same set of data is getting inserted each and every time and it is a duplicate data so what we do here is we introduce a concept of normalization which says that if you are facing any duplicacy of data or any inconsistency of data so what is data consistency and how this data can be inconsistent consider that uh the department ID is 02 now for it so you updated it here you updated it here considered that there are n number of employees who are working in IT department and if you miss out to update for any one of the employee it will show the department ID as 01 for that employee but that employee is working in IT department so that would be a inconsistent or you can say incorrect data so that is why we can see that whenever we make a table which is having like details of employee ID employee Department details as well we can see that there is a data duplicacy as well as data inconsistency or the data consistency is very less so because of that we introduced the concept of normalization now what is data rency and consistency and why it's important so whenever there is a same set of data repeated at each and every time it results in the duplicacy of data that is the same set of data it01 which is getting repeated each and every time so which is resulting in the duplicacy of data now row level duplicacy can be removed by using primary key for Unique values now there are two types of duplicacy which happens one is column level and one is row level so here you can see that for certain columns Department name Department ID and department phone number these all values are getting repeated for some certain number of columns so this is called as column level duplicacy level duplicacy now coming to row level duplicacy so in Ro level duplicacy what happens consider that there is ID and there is employ EMP name so here you give the ID as one the name as consider RTI again you are giving the ID as one and the name as raj again you are giving ID as one and name as Rahul like for employee it won't happen but consider for school database or for college database there could be a possibility that there are two people who are having the same name so how you are going to differentiate between that two people because again ID is something on basis of which we are differentiating the name so if I'm giving R number number one to Rahul Kumar and R number one to Rahul Raj as well so how I'll differentiate that which Rahul is this Rahul Kumar or Rahul Raj so that is why we introduced the concept of primary key we will make sure that all the values which is present in the ID column if we are making it a primary key is unique as well as Nal so whenever we make sure that this is unique and Nal what will happen that the ID is one for REI now the idid can be anything apart from one for Raj and ID can be anything apart from one for Rahul so this particular thing is now sorted because now we are getting unique values and in terms of ID I can find that which person is this like if I say that ID is two I can surely say that this is Raj if I say ID is three I can surely say that this is Rahul so basically on basis of ID we are somehow eliminating the duplicacy which was happening in each and every record for ID being one so in this way we uh removed the row level duplicacy but whenever we are encountering any column level duplicacy for that we take the help of normalization now whenever we have some data or some set of columns it leads to different anomalies or you can say inconsistency or error that occurs when manipulating or querying the data in the database so as I told consider that if you want to update Department ID so maybe you updated for each and every value but some of the values were left so there is a data inconsistency consider what happens is there is a new set of employees who come to our company and all these employees have left so if I delete the data of RTI and Raj we will lose the details of the department name Department ID and department phone number because I don't have any separate table where I have all the details like if it is a IT department what is the department ID and what is the department name and consider that if I want to somehow insert some data then again it will be same duplicacy which will happen for each and every employee for whom I am inserting the data like the same thing it01 and phone number would be repeating for them so that leads to anomalies now what are the anomalies first is the insertion anomaly second is the updation anomaly and third is the deletion anomaly also it increases the size of database with the same data now again the same set of data is getting repeated each and every time so it is increasing the size of database because every time I have to give it Department name and department phone number each and every time so somehow it's increasing the size of our database it's increasing the data duplicacy or you can say the redundancy it is causing data inconsistency as well now these are the anomalies which happen whenever we have some rident or you can say duplicate data and inconsistent data now let's learn about each and every anomaly and understand that how this anomaly occurs so let's learn about very first of the anomaly that is insertion anomaly it occurs when it is difficult to insert data into the database due to absence of other required data now what does this means consider a very lame example that there is a student who took admission in a particular school now student is going to take admission in class six but right now he doesn't know that he's going to be in class 6 a 6B 6 C like in which section student is going to get admitted he doesn't know he only know that he's taking admission in class six now in 6A there are different set of teachers who are teaching in 6B also there are different set of teachers in 6 C also there are different set of teacher now again this particular student doesn't know that which particular teacher would be teaching him or her and again the class teacher would also be different for each of the sections so all these details the student who has just taken an admission doesn't know but we want to insert the detail of the student in our student database so for all these fields like what is the section what is the teacher name what is the class teacher name we have to keep it as empty or null because right now we don't know that what are the values or who are the person who is going to teach what is the section in which student would be admitting in so here also I've have taken an example that consider you want to add a new department but there is no employee in the department yet so consider that in our company there is a new Department which is being introduced there is it and HR department but now there is a supply chain department now for the supply chain Department this is a very new Department which is being in introduced so I know the manager name of this particular Department I know the salary of this particular department but as of now there is no employee who is working in this particular department so I have to keep all these values as null and I have to only insert the department uh values because right now in this particular table we are having all the details of the department as well as all the details of employees but right now since this is a very new Department none of the employee is assigned to this particular department so for now these all values would be n so this is called as insertion anomaly when it is difficult to insert data into the database due to absence of other required data because consider that if ID is a primary key I can't keep ID as n right primary key what it says is if a attribute or a set of attributes is declared as primary key it will always be unique as well as not null but here we have to insert null value because right now in supply chain Department there is no employee who is existing so it will violate the rule of primary key that is why an insertion anomaly is caused whenever we have a big or you can say huge database where we are storing the details of each and everything now the second is dation anomaly now it occurs when we delete data it removes the other valuable data so consider that if you're deleting the data of any of the employee it removes the other valuable data which we need for new set of employees who are joining the company so consider that right now all all the employees have left the company so what it will do is it will delete the entire data which is present for all the employees now it has deleted the entire data but wait a second while deleting the entire data we are somehow losing the data of department manager and salary because we have deleted all the data which was present in our table now we don't know that what is the department what is the manager of that particular department and what is the salary because we don't have any other table where we have the details of Department the man manager who is of that particular department and the salary details so somehow while deleting the data which is present in the table we are losing the set of valuable data which we require because consider that there is a new employee who has just joined the company now for that particular employee I know the name age and department but I don't know the details of manager and salary because it was present for the earlier employees but for that particular employees have already deleted the data which was present so I won't be knowing that if the person has joined the HR Department who is the manager and who is the salary so whenever we delete data it removes the other valuable data so consider if you delete all the record in the table you will lose the track of Department their manager and salaries now the third anomaly is updation anomaly it occurs when changes to data require multiple updates so whenever we are changing any set of data and it require multiple updates to be done because that particular data is present at multiple places so whenever we are changing any data that require multiple update then the updation anomaly happens consider you want to change the salary for people who are working in HR department you need to update it at three places so here you can see that there are three people who are working in the HR department and for now the people who are working in HR department have got an increment and now their salary is been increased to 1,200 now we want to update at all the places where the HR department is present with the salary but right now we are only dealing with data of five employees but in general or in real life scenario there are always a bunch of employees who work in a company so whenever you want to update the salary of employees who are working in HR department it will require a lot of effort because that particular data would be present for lot of employees who are working and consider that by any chance you miss to update salary of one of the employees so it will show incorrect data that is data inconsistency would be there so it leads to updation anomaly basically we have to do multiple updates of the data where the data is getting changed so that is why updation anomaly happens so how normalization help us here using normalization we can divide the employee table into two tables first table is employee table and the second table is Department table so let's see from here here you can see that department manager and salary is something which is getting repeated for each and every employee so what it we did was we broke the table into two subtes so the first table would be having details such as employee ID employee name age and department and the second table would be having details such as employee Department employee manager and employee salary so let's see so here we are having two tables employee table and Department table wherein employe table is having details such as employee ID name age and department and now from this uh we can identify that which department the employees and from the Department table we can fetch in the details such as Department name Department manager and Department salary so we have broke the table into two parts so that we can reduce the redundency or data inconsistency which is being Ed now the first question which would be coming to your mind is here also in the department column we are seeing duplicacy the IT department is getting duplicated two times the HR department is getting duplicated three times now normalization doesn't guarantee you to remove the entire duplicacy or entire data rency what it says is it will lower down or it will reduce the data rency or duplicacy which is present in the table so normalization doesn't guarantee you to remove the entire duplicacy but it guarantees you to reduce the duplicacy or the redundency which we have now here you can see that the duplicacy is being reduced because now I just need to provide a department name for any of the person who is joining my company so let's see about all the three anomalies we discussed how normalization is helping us to reduce the insertion anomaly deletion anomaly and updation anomaly now consider that if there is a new employee who joined my company so I can fill in the details of employee ID employee name employee age and for now I can keep the department as null and whenever the employee is assigned any Department all the department details is present here so there is no duplicacy which is present for the employee there is no null values which are being given to the primary key which is present here we are only giving the department Asel because right now I don't know which department the employee belongs to but whenever the employees is assigned a department I'll just fill in the department details and from this particular table I'll get all the details of the department in which the new employee would be working so insertion anomaly is reduced here now coming to the deletion anomaly consider that you are deleting all the data which is present in our table but still you have all the valuable information which you want because Department table is still there so you can know that if a person is in IT department which is the manager and what is the salary of that particular person even if you delete the entire record which is present in the employee table still you sustain the department information or the valuable information which is present there so deletion anomaly is also taken care or reduced now coming to the third that is updation anomaly so consider that if you want to update the salary of the HR people you just know need to go to this department table and you just need to update it here so there is a only single update which you need to do earlier you need to do it at multiple places because it was present in this particular table but now since it is divided into two tables you just need to update it at one place and it will start reflecting for each and every employee now coming to the types of normalization so basically there are three types of normalization the very first is first normal form or 1 NF then second normal form and the third normal form the bcnf or boy code normal form is a advanced version of the third normal form so we would be learning about each and every normal form in detail we will understand that how these normal forms are helping us to reduce the data redundency so in simple terms you can say normalization help us to reduce the data rency or duplicacy which is present in our data it doesn't guarantees to remove the entire duplicacy or rency of data but it guarantees to reduce the redid dency which is present in our data so what is this denormalization this is the opposite of normalization so whatever things we do in normalization we just do the opposite in denormalization it inv calls intentionally introducing some Rudy into a well normalized database schema to improve query performance now in normalization what we used to do is we used to reduce the data rency which is present in our table consider that there is a table of employee which is having employee ID employee name employee age as well as this department details such as employee Department name Department ID Department salary now in this particular table we used to encounter some data dat rency or duplicacy because of rows as well as column so Ro level duplicacy was make sure introducing the concept of primary key we used to make a attribute such as ID as primary key and now there couldn't be any null or duplicate values which is present in our ID column so row level duplicacy was reduced now for column level duplicacy we encountered that there were some columns which are having the same details like the department manager and salary Whenever there is a IT department and whenever there is a HR department it used to remain same for the set of employees who are having the same department now for that what we used to do is we used to normalize the table and we used to break the table into two subtes or more tables so that we can reduce the column level duplicacy which we were encountering but in denormalization what it says is we intentionally introduce some rud dency into a well normalized database schema to improve the query performance now in normalization we used to break the tables into subtables two or more tables so this was the earlier table which was present now there are subtes to reduce the data rency now this is a employee table this is the department table and this is the salary table consider I want the detail of a employee who is having ids2 and I want the details of its Department as well as his salary so I want all the employee details I want all the department details I want all the salary details for an employee is is having IDs 2 now for that I have to make query into this particular table this particular table and this table as well and as the table increase the queries also increase now we have to make different type of joints to get some data from the Department as well as salary table so because of that our query is not very much optimized or it takes a lot of time to fetch from each and every table because there could be a possibility that the data is present at the very last of Department table the is present at the very first of salary table and because of that we encounter some issues like the query is taking a lot of time now the query if it's being used in an API the API is taking a lot of time our SLA is increase so because of that we can encounter them some time issues some speed issues and much more things so because of that we introduced the concept of denormalization that we are intentionally introducing rud deny but if all the data is present into the same table the query time would be very less so consider if you wish to find the salary of Rahul so to find the salary of Rahul first we need to find the department of Rahul so first we have to make the query into the employee table to find the department and once we get the Department of Rahul that is it then again we have to make a query in this department table to fish the salary of rul so you can see that we are making multiple queries so multiple queries can increase the time can reduce the speed and our API can take a lot of time to provide us the result result so what are the benefits of denormalization first one is faster queries so it can reduce the need for complex joints between tables during queries which can eventually improve the speed of retrieving the data and it can give the data very fast now the second benefit is the queries would be simpler because there are no joints which are being involved there are no three or four tables in which we are making queries so the queries would be very less complex it can simplify the queries by allowing them to be executed on a single table instead of requiring joints across multiple tables so in normalization we used to break a single table into multiple tables now we need to make queries into these tables so because of making queries into different tables the time also increases and the queries also get complex in denormalization we used to combine all the tables into a single table even if we know that the data rency can occur but still we are combining it into a single table and because we are combining it into a single table the time always reduces and the queries are also simple so they are not complex queries now with advantages there are always disadvantages so let's see the disadvantages so first disadvantage is increase data redundency as I told that we introduced the concept of normalization to decrease the data redundency but since in denormalization we are again combining all the table into a single table which is we are breaking the normalized table into a denormalized table so we can say that the data redundency has increased now the second is less data consistency because if we are combining everything in a single table consider that if I need to update the salary of a person who is working in IT department and if somehow I miss to update for any of the employee the salary would be different for both employees who are working in IT department so that would be a data inconsistency now the third is denormalization can make the database schema less flexible ible for future changes like adding modifying new data elements so we learned about the insertion ofdation and deletion anomalies so that can occur because of denormalization we can't go ahead and add any of the data of any of the new employee who has joined the company because right now I don't know the department manager and salary details of that particular employee or consider that there is a new Department supply chain which is introduced in our company for now there are no employees who are present in supply chain and since ID is a primary key we can't make it as null and we need to insert a data but right now we don't have any data so these type of issues can happen whenever we denormalize the table but the only Advantage is it makes the queries faster and it simplifies the query now as the term suggest functional dependency so whenever there is a kind of dependency which is present in form of any function we can call it as functional dependency you might have heard about the terms such as equations or functions in maths now if there is a function given y = to FX that is y is a function of X where FX is = x + 2x + 1 so if I know the value of x I can determine the value of y so what I'll do I'll just put the value of x here so that would be 1 + 2 + 1 that is 4 so here if I know the value of x I can determine the value of y so Y is a function of X so we can say that Y is functionally dependent on X because whenever we know the value of x we can find the value of y now in functional dependency it describes the relationship between the attributes in a relation so attributes you can say as columns and relations you can say as table so whenever there is a table consider that this is the table the table name is r or we can say it is a relation where we have two attributes X and Y we can say columns so if Y is functionally dependent on X it means if I know the value of x I can determine or find the value of y so a functional dependency is a constraint between two set of attributes in a relation from a database so it's not important that it will always happen between single single attributes there could be a set of attributes which could be functionally dependent on some set of attribute so consider that in a table there is a primary key now primary key can either be a single attribute or can be a set of attribute so if RW number is something which is being repeated for each each or every person in a combined Branch like CSC EC so there could be a possibility that in CC also a person is RO number one in EC Branch also there is a person with role number one so what we will do is we will take a composite attribute we will combine two attributes to make it as a primary key or a unique identification key using which we can find the details of that particular person or that particular student in a college now for a relation table R if there are two attributes X and Y then we can say the functional dependency is X determines y or we can say Y is functionally dependent on X where Y is called as dependent and X is called as determinant so X is called as determinant because if we know the value of x we can determine the value of Y and Y is somehow dependent on the value of x so if I know the value of x I can find the value of y consider in a normal table that if there is a raw number and there is a name so if I know the r number of any person I can tell the name of that particular person so R number is kind of a determinant and name is kind of a dependent and name is functionally dependent on Raw number because if I know the value of R number I can determine the value of name so attribute Y is functionally dependent on attribute X so Y is functionally dependent on attribute X or we can say x determine y now if x is equal to 1 we can find the value of y the same example which I show here that if we know the value of x we can find the value of y here as well now functional dependency X determines Y X Y is a subset of the relation so if there is a table or there is a relation then X and Y is always a subset of that particular relation here I'm talking about subset but what subset exactly is so let there be two sets A and B now a is having value 1 2 and 3 and b is having value 1 2 3 4 and 5 now a is a subset of B because every element of a is also an element of B so we can say that a is a subset of B because every element of a one one is also present here two two is also present here three three is also present here so a is a subset of B Because all the elements which is present in a is also present in B but Vis Versa is not true because four and five is not present in a so we can say that a is a subset of B because every element of a is an element in B now here there is a table employee ID employee first name and employee last name so here there are some of the functional dependency which is provided so first is that employee ID will always determine employee first name so let's see if employee ID can determine employee first name so if I know the employee ID as one is there any employee ID with one existing in this particular relation no now uh in correspondence to one what is the employee first name that is re so if I know the employee ID I can know the employee first name so we can say that employee first name is functionally dependent on employee ID or if I know the employee ID I can find the employee first name so you can also say that in functional dependency the x is kind of a unique identification key unique identification key so basically this is a unique identification key which help us to identify or determine or find the value of y when we know the value of x so for this employee ID also there is no two which is present in this particular column so the value would be Rahul for three there is no three which is present in this employee ID column so we can say the value would be surj so we can say that employee ID is determining employee first name or employee first name is functionally dependent on employee ID so employee first name is functionally dependent on employee ID in the same way employee last name is also functionally dependent on employee ID now here you will say that you have written the functional dependency but how will we identify that if there is a table or there is a relation what are the functional dependency which are existing so the first way to determine that is that if there is X which is determining y x can always be a set of attributes and Y can also be a set of attributes so we can also say that employee ID and employee first name both are determining employee last name so X would be this set of attribute which is employee ID and employee first name in the same way we can also say that employee ID is determining employee first name and employee last name so here Y is also a set of attribute so this thing first we need to understand that X determining y x can always be a set of attribute and Y also can always be a set of attribute now how we will know the functional dependency in a given table now according to functional dependency definition if there is a relation r x determines Y where X and Y are the attributes of the relation and X can be a attribute or a set of attribute y can also be an attribute or a set of attribute and Y is functionally dependent on X now here can you say that X or the one which is a determinant is always a primary key so can we say that X is a primary key the answer is no it's not always true that X will always be a primary key this is a unique identification key but it's not a primary key it can be a primary key but it's not important for X to be a primary key it should always be a unique identification key now how do we find that that if there is a x which is present or if there is a attribute which is present is acting as a determinant or not so as I told that it is not uh always true that it will always be a primary key so there could be a possibility that there is some duplicacy in this employee ID colum so again the employee ID is one the name is considered Ria and the last name is sing so here you can see now employee ID is having two ones which is present in the table so it is not unique so primary key violation happens because this particular employee ID or this particular attribute doesn't have unique values now if we want to now see that if this employee ID determines employee first name is true or not for this particular table what we need to do is okay if there are two tles or you can say two records and the value of x is similar for both of the records then the value of y should always be similar so that these are functionally dependent so if there are two tles T1 and T2 and if T1 dox is equal to T2 dox that is this is equal to this then T1 doy should always be equal to T2 doy for the functional dependency to exist so let's see is T1 dox equal to T2 dox 1 is equal to 1 so this is true so let's see if t1. Y is equal to T2 doy or not so t1. Y is reti and t2. Y is Ria so is t1y equal to T2 doy no so now we can't say that employee ID determines employee first name because consider that if I provide the employee ID 1 what would be the value of why it will return because right now one is having the value as re and one is also having the value as Ria so now employee ID is not determining employee first name but what if here the value is return as re so now is the employee ID determining the employee first name yes because one is always corresponding to only one value one is not corresponding to two values one is always corresponding to only one value so this is the criteria which we use to follow to find the functional dependencies which are present in our relation so if there are two tles who are having the same value such as like the same record is present in that particular two tles then we should always check the value which is being determined or which is functionally dependent on that value so if there is deploy ID which is having values such as one and one then we need to check that what is the corresponding value uh to this one because there could be a possibility that this one is giving me RTI and this one is giving me Ria so one is having multiple values one should always hold single value because this is a unique identification if I say that one is also giving me RTI one is also giving me Ria so the unique identification does not exist X shouldn't be a primary key it can or it cannot be but X should always be a unique identification so this is called as functional dependency so whenever we encounter that if there is a employee ID column which is having unique values or where there is a primary key we don't need to check for all those things because if it's a primary key it will always determine some unique values only but if there are some duplicacy which is present in this employee ID then we need to check this condition that for given two tles if the value of x is similar the value of y should always be similar if it's not similar then it's not functionally dependent or the functional dependency does not exist I know this can be a bit confusing but when we will learn about normal forms that would be clear more and more for now you can just understand that in functional dependency there is a relation and then there are some attributes one attribute is functionally dependent on another attribute it basically means that if I know the value of x I can determine the value of y x and y can be a set of attributes X is not always is needed to be a primary key it can or it won't be but X should always be a unique identification key that is for one value of x there should always be one value of y there shouldn't be a multiple values of Y now there are some properties of functional dependency or we can also call it as inference rules now what are those properties so the very first property is reflexivity now what is this reflexivity so if there are two attributes X and Y where Y is functionally dependent on X and and X determines y we can see that if Y is a subset of X then X determines y or X determines X now how this comes X determines X so here I told that Y is a subset of X so Y is always having some values which is present in X so y will always have the value X so we can see that X determines X so a particular attribute can always determine itself and it can determine y if Y is a subset of X so X determines X always holds true in terms of the reflexivity property because Y is a subset of X so y would always be having values which are having X so X determines X always holds true now the second property is augmentation what does this means that if x determines Y and if we are augmenting Zed here then x z should always determine y z for any Z so consider that there is a employee ID which determines employee name now if I augment or add something so if employee ID I add a employee phone number so employee ID employee phone number both together can determine employee name and employee phone number so I can see that if something is added at LHS and the same thing is added at rhs then there would be a functional dependency which will exist between this combination now the third one is transib so what this transitivity says us if x determines y so if x is a attribute which determines Y and then Y is a attribute which determines Zed then X is a attribute which will always determine Zed so if x determines Y and and Y determines Z then X will always determine Z we don't need to check for this dependency if this exist or not if x is a attribute which determines y and Y is an attribute which determines Z then we can say that X will determine Z as Y is common between them so this is called as transitivity now the fourth one is union now what union says is if x determines Y and X determines Z since LHS is common in both the cases we can say that X will determine y z so since X determines y x also determines Z so since m employee ID determines the employee first name and employee ID determines the employee last name then we can say that employee ID can determine employee first name as well as employee last name so there is a union which happens whenever the LHS is equal but the vice versa is not true if I say y z determines X I can't say that y will determine X and Zed will determine X this is wrong because again y z is is something which is a combination which is helping me for The Unique identification or this is a unique identifier or a key so if the both of these key are helping me to determine one attribute I can't say that a single attribute can determine this particular attribute because the composite version of this is helping me to determine the attribute so if x determines Y and X determines Z we can say that X determines y z but we can't said that if y z determines X Y will determine X and Zed will also deter X that is wrong and that is not true now the fifth rule is Rule of decomposition so if x determines y z we can say at X determine Y and X determine Zed which is the same which we learned in Union so it's just the reverse of Union so if x determines y z we can say x determine Y and X determine Zed so the determinant can never be broken determinant can never be broken if it's a set of attributes it can't be broke into single attributes and determine something because the set of attribute is helping in the unique identification not the single single attributes right so this can't be broken the rhs can be broken the dependent can be broken but the determinant can't be broken now what are the types of functional dependency so there are two types of functional dependency one is Trivial and the second one is non-trivial there are more but basically now we need to know about these two only trivial and non-trivial so let's see see what is Trivial so functional dependency X determines Y is Trivial if Y is a subset of X so it says that if Y is a subset of x x can determine Y and X can also determine itself that is X so this particular dependency is always valid we don't need to go ahead and check in our table because X can always determine X employee ID can always determine employee ID if I say that employee ID is one find the employee ID in the table I can always find find the employee ID because I know the employee ID is one here so X will always determine X this is a valid dependency this doesn't needs to check that if there are some employee IDs which are present if again there are some employee IDs which are present because we are seeing in the same column or you can see in the same attribute itself also since Y is a subset of X Y will be having values or the elements which is present in X so we can say x will determine X so we can also say it as X determines X now consider that here there is a dependency given where employee ID and employee first name is determining employee ID now this is why and this is X now in y we have employee ID and in X also we have employee ID so we can see that Y is a subset of X because the element which is present in y is also present in X so we can also say that employee ID determines employee ID and employee ID employee first name determines employee ID now this is Trivial because employee ID is a subset of employee ID and employee first name so we can say that trivial dependency exist whenever X intersection Y is always y so whenever we are doing an intersection between them so we are doing an intersection between employee ID and employee ID and employee first name so in intersection we used to provide the common which is present between them so in employee ID employee ID and employee first name employee ID is the common one so we give the value as employee ID for a result so X intersection y always gives us y y is employee ID so here we get the employee ID so this is the trivial dependency now what is non-trivial dependency a functional dependency X determined Y is non-trivial if Y is not a subset of X so Y is not a subset of X basically which means that if there are some uh values which is present in y or if there are some attributes which is present in y it's not necessary for that attributes to be present in X so here if you can see X is having employee name and Y is having employee ID so employee ID is not present in employee name so Y is not a subset of X so these dependency needs to be proved because so right now I am saying that employee ID is getting determined by employee name or employee ID is dependent on employee name but is this true like we have to check that if this is valid or not in trial what used to happen is X determines Y and Y is always a subset of X so y always contains some element which is there in X or Y is always having some attributes which is in X so this is always true but when X determines Y and Y is not a subset of X then we need to prove that point okay if employee name is determining employee ID I can check from my table if this functional depend dependency is present or not present so a functional dependency X determines Y is not trieval when the Y is not a subset of X so if there is X as employee ID and Y as employee first name we can say it is non non-trivial because employee first name is not a subset of employee ID so employee first name does not have any element which is there in employee ID so here if we do X intersection y we get five because X intersection y does not give us anything because there is nothing common between employee first name and employee ID so it will give me f or it will give me empty now what is this attribute closure or closure set as the name suggests that it will give me a set of attribute but what is it exactly so let's see attribute closure help us for identifying candidate Keys checking for functional dependencies and in normalization so whenever we need any kind of help in finding the candidate Keys which is present in our relation or the super keys and whenever we need any help in checking the functional dependencies present in our table we use the attribute closure so whenever there is a attribute X it can be a attribute or you can also call it as a set of attribute so whenever there is a attribute or a set of attribute the closure set of this particular attribute is denoted by the plus sign and it gives me the set of all the attributes which can be determined by this particular attribute X so closure of any attribute is denoted by plus sign and it gives me all the attributes which are present in the relation which can be determined by X so here x is an attribute or set of attribute which gives me all the attributes in a relation which can be determined by X so consider that there is a relation in which there is a functional dependencies X determine a and there is one more functional dependency X determine B so since X is determining a and X is determining B if I find the closure of x according to the definition it should give me all the attributes which can be determined by X so that would be a and b so A and B would be the closure set of X so X closure gives me all the attributes which is present in the relation which can be determined by X so let's see a practice question on how we can determine the attribute closure or closure set on some of the attributes which is present in a relation so consider we have a relation r with attributes such as a b c d and and E and there are some functional dependencies which are given as such a determines b b determines c c determines D and D determines e now this a determines B says that that if we know the value of a we can find the value of b or B is functionally dependent on a so these all things have been taught in the functional dependency video so if you're not understanding this you can go ahead and watch that video first and then come to this video now how we can find the closure set of some of the attributes which is present in this table so let's see so the very first step is now according to the rule of reflexivity all the attributes can determine theirself so according to the rule of reflexivity it says if Y is a subset of X then X can determine y so since Y is a subset of X Y would always be have all the elements which is present in X so we can also say that X can determine X we can replace y with X because y would be having all the elements which is present in X so we'll just use the rule of reflexivity and derive some of the functional dependencies that is a will determine a b will determine b c will determine c d will determine d and e will determine e so all the attributes can determine themselves according to the rule of reflexivity now the second step is now according to the rule of transitivity if a determines B and B determines C then we can say that a can also determine C c as B is common between them so whenever a determines B and then B is a attribute which determines any other attributes then a can also determine C so since in the question we have some of the functional dependencies present so let's use this functional dependency and let's use the rule of transitivity to derive some more functional dependency which will be helpful for us to find the closure so let's see for a so here it is given a determines B and then B determines C so since B is common between them can we say with the rule of transitivity that a will determine C yes we can say so the first functional dependency which we derive is a determines C now B is determining C and C is determining D now C is again common between them so we can say B will determine D so B will determine D is the second dependency now C determines D and D determines e again D is common between them so we can say that c will determine e so c will determine e is the third dependency which we got now since we have got three new functional dependency and these are also existing so let's see if there are more dependencies which can come so since here we can see that a determines C and here is there any c present yeah C determines D so we can say a determines C and C determine D since C is common between them then a will determine D so a determine D is another dependency now since a determines D let's see that if there is any functional dependency with d yes so D determines e so we we can say that a determines d d determines e so a will determine e so a determine e is also a functional dependency now here e is present so is e determining any of the dependency no so these will be all the dependencies of a now coming to B so B determine D is there any D determining any of the attribute yes so D determines e so we can say since D is common between them B determines e now coming to e is there any e which is determining anything no no so these will be the dependencies of B now coming to C so C determines e and since e doesn't determine any of the attributes so this will be the only functional dependency for C now coming to the third step now according to the rule of Union if the determinant is same we can combine the dependent so according to the rule of Union if x determines a and X determines B we can combine the dependent since the determinant is same so we can say x will determine AB so since we have all the functional dependencies with us using the rule of reflexivity and transitivity let's see that how we can find the union so for a since a determine B A determine C A determine d and a determine e using transitivity Rule and a determine a using reflexivity rule so a will determine all a b c d e in the same way we find for b c d and e so B will determine c d EB c will determine d e c d will determine e d and e will determine only e so here the position doesn't matter we can also write it as b a c e d like in any manner we can write it's just that all the dependent should be present so the step four is we have to find the closure set of attribute so what it says is whenever we are finding closure of any of the attribute or the set of attribute it contains all the attributes or all the set of attributes which can be determined by the attribute for which we are finding the closure so here a closure will contain all the attributes which can be determined by a so since here we have find all the functional dependencies and here we have find all the attributes which can be determined by a so here you can say a can determine a b c d and e so a closure will have a b c d and e as mentioned here so a closure will be having a b CDE e in the same way B closure will be having this C closure D closure e closure so here you can see that we are finding the closure of set of attribute so whenever we need to find the closure of set of attri attribute what we do is firstly we write all the attributes which can be determined by a so that is a b c d and e and then we write all the attributes which can be determined by B that is b c d e but that is already present in the set so we don't need to duplicate or repeat it so this is the attribute closure of ab+ it will be having all the attributes which is present in the relation so it will give me all the attributes which can be determined by a then all the attributes which can be determined by B so combined it gives me a b c d and e now since we learned about attribute closure in the last video we would be using that attribute closure and finding super keys in our given relation or in our given table now let's find the candidate key Super Key Prime and non-prime attributes so what is super key super key is a set of attributes whose closure contains all the attributes given in a relation so basically super key is attribute or you can say a set of attribute so X is a Super Key it can be a single attribute or it can be a set of attribute whose closure contains all the attributes which are given in a relation so consider that there is a relation or there is a table in that particular table attributes basically means the columns so consider that there are three columns a b and c and if the closure of X contains all a b and c then this is qualified to be a super key so whenever a closure of any of the attribute or set of attribute contains all the attributes which is present in a relation we can call that attribute or set of attribute a Super Key now a key combination of all possible attributes which can uniquely Identify two tles so super key is also a key which can uniquely Identify two turbles a key can be a combination of attributes or can be a attribute now how to find the super key so there are certain steps which we need to follow to find the super key so let's see so the very first step is we have to identify all the attributes so the first step is identify all the attributes which is present in our table so consider that right now it's a b and c so we have identified all the attributes now the second is we have to analyze the functional dependencies and find the closure so how we used to find the closure is consider that if we are finding a closure of a so we have to see that what all attributes does a determines so consider that a determines B A determines C A determines D so closure of a would contain B C D and from the reflexivity property a can also determine itself because according to the rule of reflexivity an attribute can determine y whenever Y is a subset of X so what does this means Y is a subset of X basically y will have all the elements which is present in X so can we replace this y with X here yes we can do so we can see that an attribute can determine itself using the reflexivity property so a can determine a so we can say the closure of a contains all the attributes which is present in our table so this can possibly be a Super Key so we have to analyze the functional dependencies like a determines b b determines c c determines D any of the functional dependency and then we have to find the closure now we have to generate the power set so right now I'm saying that a is my super key but super key can be a attribute or can be a set of attribute so AB can also possibly be a Super Key AC can also be a Super Key consider BC can also be a Super Key so we need to find out that what all attributes or set of attributes can be the Super key so for that we generate the power set in that power set we get all the attributes or all the possible combinations which can be of super key and then we determine that if that possible combinations closer is giving me all the attributes which is present in the relation or not so if it's not giving it's not a super key if it's giving then it's a Super Key so if a has n attributes the power set of n will be having 2 to the power n subsets so consider that here x is having three attributes so what would be the power set of X so that would be 2 to the^ 3 that is 8 so power set of X would be having total eight sets so total eight combinations and in that combinations we can check that which particular combination or which particular single attribute qualifies to be a Super Key then the final check is check for Super Key property so we have to check for the Super Key property so from here we have generated all the subset consider a subset a b c we can say AB AC BC we have generated all the power subsets now for these power subsets we have to take the closure of all these part subsets and we have to see that if the closure determines all the attribute or if in the closure all the attributes are present which is there in a relation if it is there then that particular set can be a Super Key if it's not present then we will discard start this from the final result so for each subset in the power set check if it can uniquely identify each dle in the relation so let's solve a practice question where we will be finding all the super keys so here the relation is given as r a b c and the functional dependencies are given as a determines B and B determines C so these are the functional dependencies which are provided and this is the relation which is provided along with all the attributes so what was our step one we have to identify all the attributes so to identify all the attributes we can see that there are three attributes in a relation so we will just note it down a b and c so in step two we have to analyze the functional dependencies and find the closure so here you can see that we have been provided with two functional dependencies a determine B and B determine C so this is provided let's derive some of the functional dependency so since a determines B and B determines C can we say since B is common between them a will determine C from the property of transitivity so we can say that a will determine C is a property which we have derived or is a functional dependency which we have derived now we have derived a determine C now each attribute can determine themselves so we can also say a will determine a b will determine b and c will determine C apart from that we can't find any other functional dependency so these are the functional dependency which we have calculated and these were the provided ones now from this functional dependenc if we find the closure of a we have to write down all the attributes which a determines so a can determine C so we will write C A can determine a so we will write a and a can also determine B so we will write B so the closure of a will contain c a b so here you can see that a closure has c a b which is also the attributes which is present in our relation so can we say that a is a Super Key yes we can say that a is a Super Key because a closure determines all the attributes which is present in our table that is a b and c now B closure so B closure will contain B and C and it does not determine a so there won't be any A and C closure would be only having C so B closure and C closure does not qualifies to be a Super Key this particular thing you can also do after the generation of par set or you can do before the generation of paret I'll tell you that why before the generation of paret this is useful so the closure of a gives or determines all the attributes in the table so we can say it's a Super Key now the third step is how do we find all the super keys so for that we have to find the power subset so we have to find the power set of a b and c so since I told that the power set of any of the given set is 2 to the power consider that this set is X so it's 2 to the^ X so here it will be 2 to the^ 3 so here it will be eight so the par set of this particular set would be having eight elements now let's understand about power set so power set is the set of all subsets of a given set including the empty set as well as the set itself so consider that there is a set x x is having elements such as a and b now in this if we calculate the power set of X it will be having set of all subsets so basically it will be having set of all subsets of a and b including the empty set as well as the set itself so set itself is AB m set is this which is having no element and the subset will be a and b so the power set of x equals to A would be having these four elements now the power set of X is denoted by 2 to the^ X so we can see that the power set of X would be 2 to the power x which is 2 to the power number of elements that is 2 to the^ 2 which is four now let's see if there are four so 1 2 3 and four so the power set of X is having four sets now let's take a simple example the same example which I explained above so the power set of X would include the following subsets one is the empty set this one one is the single element set that is a and b and one is the full set itself that is AB so the power set PX would be PX is equal to 5 which is a empty set then a b and ab in this way we can calculate the power set of Any Given set so the power set of a BC would be having first ly five or you can say empty set then we will be having single elements so a b and c then we can have the combination so we can say AB AC then BC and then we can say the entire set itself so that would be a b and c so here you can calculate that there are three elements so it will be having 2 to the^ 3 that is eight sets so if we calculate here so 1 2 3 4 5 6 7 8 so we have got eight sets overall now to calculate all the super Keys what we will do is we will take the closure of all those eight sets so let's take a closure so first is this empty set so the closure of empty set wouldn't give anything so it's not a Super Key second a we calculated that a is a Super Key after taking the a closure so we can say that it is a Super Key as it closure determines all the attributes in a relation now the second is B for B also we calculated that b doesn't determine a so B does not have all the attributes which is getting determined in the relation so B is not a Super Key again c c only have C in the closure so C is not also a Super Key now the next is AB so for ab do you need to determine the closure and then conclude that it is a Super Key or not if you remember in the first step we calculate the closure of the single attributes that was a b and c and from that we found out that a is a Super Key B and C were not a super keys so since a is a Super Key can we say that if any attribute is augmented with a that will also be a Super Key because if I take a closure of ab a closure will only contain all the attribute which is present in the relation so if we augment anything with a that will also be a Super Key right let's take a closure of ab so if we take a closure of ab we can say that a determines a b and c and b will DET mine B and C which is already present here so we can say that if anything is augmented with a Super Key that also becomes a Super Key so we can say that AB is a Super Key since a is already a Super Key so adding B still keeps it a Super Key so we can say AB is a Super Key now coming to AC the same thing that a is always a Super Key so if we augment anything with a that will also become a Super Key so AC is also a Super Key since a is already a Super Key so adding C still keeps it as a Super Key now coming to BC neither B neither C both of them are not a super keys so we have to take the closure and we have to find out that if the closure of them gives us a Super Key or not so if we take the closure B gives us b c gives us c b does not determine C either C does not determine even B or C so BC closure does not gives me all the attribute which is present in our table so we can say that BC is not a super key as B determines C but does not determine a now coming to A B and C again since a is already present here if we augment anything with a that will be a Super Key so we can say it as a Super Key as a is already a Super Key so adding B and C keeps it as a Super Key so we can say that there are four super keys for the given relation that is AB AC ABC and E now consider that right now we were dealing with only three attributes so calculating the power set was easy but consider that someone asked you to find the super keys for a given relation where there are n number of attributes would you go ahead and find the power set and then find the closure it would be a very tedious task so for that we have a formula so to find the maximum number of Super Keys we can use the formula which is 2 the^ N minus K where K is the candidate key with K attributes that is considered that K is a key which is having a k number of attributes and it is a candidate key and N is the total number of attributes in the given relation so using this formula we can find out the number of Super keys but we should be knowing that what is the candidate key so in the next video we would be learning on how we can find the candidate keys in a given Table after that you can use this formula to find the super key when there is one candidate key we can see that it is 2 to the^ n minus one since K is the candidate key and there is only one key present here so we can say it is 2 to the^ n minus one when there are two candidate keys so for the first candidate key it will be 2 to the^ n minus 1 for the second candidate key it will be 2 to the power n minus 1 and then in these both candidate key there could be occurrence of both the candidate Keys together so for that we will be subtracting 2 the^ N minus 2 that is the combination of both the candidate Keys now what is a candidate key so a candidate key is basically a Super Key whose proper subset is not a super key so let's understand term by term what is a Super Key so an attribute or a set of attribute is considered to be a Super Key if its closure gives all the attributes which is present in our relation so consider that there is a relation or there is a table in which the attributes are a b and c and if the closure of a attribute or a set of attribute gives us all the attributes which is present in our relation these are considered to be a Super Key now what is this proper subset so consider that if we are having a set which is having elements such as a and b now if we want to take the subset of this so it will be having five a b and ab in proper subset what it says is it should have all the elements except the element for which the subset we are taking so it should be having all the elements it should be having five or empty set it should be having a it should be having B but it shouldn't be having s that is AB so if we are taking a proper subset of a given set A and B it should be having individual A and B but not AB because that is already present in s so here we can say that proper subset of s is all the elements which is present in s except the elements which is present in the set s itself so all the elements of a are also the elements of B so all the elements of considered that this is a set a so all the elements of set a are also the elements of set B and and set B has at least one element that is not an A so in a if we take the subset of this so it would be a b ab and five so at least AB there is one set which is not there in B so we can say that b is a proper subset of set a because B has at least one element that is there in set a but not in set B so it has all the elements which are there in set a but there is only one element which is there in set a but not in set B so this is called as proper set so we can say that whenever we are calculating the proper subset of a given set it has all the elements which is present in the set except one element which is the set itself so now coming back to the definition of candidate key so it says a Super Key whose proper subset so consider that AB is a Super Key right now and the proper subset of ab is a b and five is not a super key so how we can find the super key we have to take the closure so we will take the closure of all three and if the closure of all three are not super Keys we can say that this is a candidate key if any one of them tends to be a Super Key we can't say that this is a candidate key so first we have to find out the Super Key then we have to take the proper subset of Super Key then we have to find that if the proper subset is a Super Key or not so for that we will take the closure and when we take the closure we will know that if it is determining all the attributes of a given table and if it's not determining we can say that this particular is not a Super Key and if it's determining we can say that this is a Super Key and if any one of the proper subset is a Super Key we can say that AB is not a candidate key I know it might sound confusing but let's see from a practice problem and then you will get a Clarity on how we can find out the super key and the candidate key in a given relation now there are two things you need to know before proceeding ahead with finding the candidate key first is prime attribute and second is non-prime attribute let's see what are these so an attribute that is a part of candidate key we call it as Prime attribute so consider for now AB is our candidate key and in our relation there are three attributes a b and c so we can say that A and B are the prime attributes as they are part of candidate key and non-prime attribute are an attribute that is not a part of candidate key so since there were three attributes Utes and two of the attributes were part of candidate key so we can see that c is a non-prime attribute and a and b are the prime attribute since A and B are there in candidate key and C is not there in candidate key so how we can find the number of candidate key here are some steps we should follow to find the candidate keys so the very first step is we have to take the closure of the entire attribute set so consider that in our relation there are three attributes a b and c so what we will do is first we will take the close of the entire attribute set now secondly we will discard the dependents if the determinants are present so what are dependence and determinants consider that there is a functional dependency a determines B so we can say since a is determining B this is determinant and since B is functionally dependent on a we can say that this is dependent so in Step B what we have to do is we have to discard the dependents if their determinants are present so since B's determinant is a and a is already present here so what we will do is we will discard B from here so we will discard the dependents if their determinants are present now after discarding the final combination you get is a candidate key if its subset does not have a Super Key so what we'll do is first we'll take the entire closure of all the attributes and there we can find out that the closure will contain all the attribute of a given table because we are taking all the attributes closure so it will be having all the attributes so this is a Super Key now we have find out that there is a Super Key from that super key what we will do is we will go to the functional dependencies which are provided and there we will see that if any dependent having a determinant is present here or not if the determinant of any of the dependent is present then we will discard the dependent so here we have discarded B now we have left with AC so can we say that AC is a candidate key right now no because we have to check if the proper subset of AC that is a and C is a Super Key or not so what we'll do here is we will take the closure of a we will take the closure of c and we will see that if it is a Super Key or not if it's a Super Key then we can say that this is not a candidate key if any of one of them is a Super Key and if both of them are not a Super Key we can say that AC is a candidate key so right now we are assuming that AC is a candidate key so we will mention A and C in the prime Atri attribute as the last step mentioned mention them in the prime attribute now in step four we will check that all the functional dependencies and we will see in the right hand side if there is a attribute which has a determinant present in the prime attribute if yes mention that as well in the prime attribute and replace the dependent attribute with the determinant and check its candidate key so right now we have found out that Prime attributes are A and C so we have to see that if a or C are lying in the right hand hand side of the functional dependency so right now we have only one functional dependency where a determines B and none of the Prime attributes lies in the right hand side but consider that if you have a dependency such as B determines C so here you can see that c is a prime attribute and C lies in the right hand side so what we can do is right now we have calculated that AC is a candidate key we can replace the dependent with its determinant so right now AC is our candidate ke what we will do is since C is the dependent and B is the determin minent of C we can replace C with b and we can check that if AB is a candidate key or not so in this way we can find out all the combinations for which we can check that if they are candidate gears or not if no Prime attribute is available in the right hand side of functional dependency we can say that there are no more candidate key and the one key we made after discarding the dependent and checking for the super key is the only candidate key so in this case A and C and the functional dependency was a determines B since there were no dependents which were present in the right hand side which were in the prime attributes we can say that only AC is the candidate key but when we added some additional functional dependency where B determines C and C is a dependent so we can replace the dependent with its determinant where AC can be replaced by ad where C is replaced by B and we can find out that if AB is a candidate key or not so let's solve a practice question where we will find the candidate as well as super key for a given relation R A B C D and the fun functional dependencies are given as follows so let me just write it here so there is a relation r a b c and d and the functional dependencies provided are a determines b b determines c c determines D and B determines a so let's see that how we can find the candidate as well as super key so let's find the super key so to find the super key firstly we will identify all the attributes so all the attributes present are a b c and d now in the second step we will analyze the functional dependencies so we will Analyze That A determines b b determines C from this we can say a will determine C now B determine c c determine D since C is common we can say B determines D now B also determines a and a determines b b determines a so a determines a is also a functional dependency this is also the rule of reflexivity can say B determine b c determine C and D determine D these are all the functional dependency now what we will do is we will find the closure for the single attribute so firstly we'll find the closure for a b c and d and we will see that if they are super keys or not so let's find so firstly we'll find the closure for a so a closure will be having a since a determines a so we can say a closure will be having a for sure then a closure will be having B since a is determining B now a is determining b b is determining C so a is also determining C so we can say C is also there now a is determining b b is determining c c is determining D so we can say B is determining d and a is determining B so a is also determining D so we can say d is also there now let's calculate for B so B closure would be having B now B determines C so let's write C and C determines D so we can say B will determine D so will write D and B also determines a so we can write a so the B closure will be having b c da a now let's take the C closure so C determines d c will determine itself and c will determine D and then none of them so C closure will be having C and D let's find the D closure so D is determining nothing so we can say d will determine only itself so from here we can see that a closure and B closure are having all the attributes which are present in our relation or table so we can say that a is also a Super Key and B is also a Super Key since C and D closure does not have all the attributes so we are discarding them so from here we got to know that A and B are super Keys now we have to find the power set of this so let's find the power set so power set of a b c d will be having 2 to the^ 4 that is 16 sets now among that 16 sets if there is any a which is in any set that will be a Super Key if there is B in any set that will be a Super Key so right now we will not go ahead and find the power set and then calculate the closure of that particular power set and then we will find out the number of Super keys in the last video I told you about a formula where we find the number of Super Keys using 2 to the^ n minus K where n is the number of attributes and K is the attributes which is present in the candidate key so if we find the candidate key we can find the super key and right now we know that A and B are at least a Super Key right now we don't know that if a b b c CD are the super keys or not but for now we know that A and B are the super keys so let's find the candidate key so for finding the candidate key first we have to take the closure of the entire set so we'll take the closure of the entire set that is a b c d so a b c de closure would be having a b c d because each attribute will determine itself using the rule of reflexivity so we can say that this is a Super Key so now in the step two we have to discard the dependents if the determinants are present so we have got this key as a b c d now in this we have to discard the dependents if the determinants are present so the functional dependencies which are provided to us are a determines b b determines c c determines D and B determines a now these are the functional dependencies which are provided to us and also we can also say using the rule of transitivity a determines C and B determines D since B is common between these two and C C is common between these two now here we have to discard the dependents if the determinants are present so let's start so here B is the dependent and a is the determinant both are present so we can discard the dependent that is B so now we are left with a c and d now coming here C is the dependent and B is the determinant C is present but B is not present so we will not take this into consideration coming here D is the dependent and C is the determinant C and D both are present so we can discard the dependent that is D so we are left with AC now coming to this functional dependency a is the dependent and B is the determinant but since a is only present here we will not look into this functional dependency now coming to this C is the dependent and a is the determinant A and C both are present here so we can discard the dependent that is C now coming to this functional dependency B determines d d is the dependent and B is the determinant any of the B and D is not present here so we can ignore this so after step two we are only left with a now after carding the final combination you get is a candidate key if its subset does not have a Super Key so we have to take the subset of a so subset of a would be five now F closure does not gives me anything so this is not a super key so we can say that a is a candidate key because the proper subset of a does not gives me a Super Key so we can say a is the candidate key now what we have to do is we have to mention them in Prime attribute so we will make a prime attribute and here I can mention a so in the fourth step what we will do is we'll check for all functional dependency and see if in the right hand side there is a attribute which has a determinant present in the prime attribute so what we have to do is in the right hand side we have to see that if a is present or not if a is present then mention at this in the prime attribute so we have to mention that particular determinant in the prime attribute and then we have to replace this dependent with that particular determinant and check if it's a candidate key or not so what we have to do is we have to check in the right hand side if a is present or not if a is present in right hand side of any of the functional dependency we have to replace a with the determinant and we have to mention that in the prime attribute so for now we can see that there is only one place where a is in the right hand side and there is a determinant of a that is B so what we will do is we will mention that in the prime attribute and then we will replace a with b and follow the same step and see that if it it's a candidate key or not so let's see so let's take a proper subset of B so the proper subset of B is five and if I take the closure of five this is not giving me a Super Key so we can say that b is also a candidate key so here b and a both are candidate key now for B we have to see that if B is present at the right hand side of any of the functional dependency yes B is present in this functional dependency but a already is a candidate key we have already seen so we have to do nothing because now B is not present in any of the functional dependency in the right hand side so if no Prime attribute is available in the right hand side of functional dependency we can say that there are no more candidate key and the one key we made after discarding the dependent and checking for the super key is the only candidate key so right now we can say that A and B are the only candidate keys in this particular relation so this is how we find the candidate key so here we can see that there are two candidate Keys now for Super Key we have a formula 2 to the^ n minus K where n is the number of attributes and K is the number of attributes in the candidate key so let's see that how we can find the number of Super Keys when we know the candidate key so here the candidate key is a and b now if I calculate for a I can see that it will be 2 to the ^ n minus K so n is 4 and the number of attribute in candidate key is 1 so we can say it's one so it would be 2 to the^ 3 now coming for B it will again be 2 the^ N minus K so n is 4 number of attributes that is a b c d and then K is 1 because we are only calculating for B so it will be 2 ^ 4 minus 1 that is 2 to the^ 3 so for a we are having 2 to the^ 3 for B we are having 2 to the^ 3 but consider that we are calculating for the combination where a b both are there and both are the candidate keys so what we will do is when we are calculating for both of the combination there is a b c d and here if I say that A and B both are candidate key so only CD can have a combination with AB because if AB is present anywhere that would be a Super Key right so we have to calculate only for CD so we can say that here since two attributes are candidate key so in 2 to ^ n minus k n will be 4 but the number of attributes which is present in candidate key is 2 so we can say it would be 2 to ^ 4 minus 2 it would be 2 to the ^ 2 so we have to just subtract that so it will be 2 the^ 2 minus so it will be 8 + 8 - 4 that is 12 so we can see that this is having 12 super keys and two candidate keys so in this way we find the super key as well as candidate key in a given relation now before starting with first normal form let's just re- revise about normalization so consider that there is a table now table would be having some rows as well as columns there could be a possibility that some of the rows have duplicate values or there could be a possibility that some of the columns also have duplicate values so from this we can conclude that there are two levels of duplicacy first is a row level duplicacy and second is a column level duplicacy in a given table now row level duplicacy can be eliminated using primary key primary key makes sure that there is a unique identifier which uniquely identify each row in a given table so we can eliminate the row level duplicacy using primary key now coming to the column level duplicacy so column level duplicacy is not eliminated using primary key so what we do is we divide the table into two or more tables so that the column level duplicacy is reduced and this is what normalization is so normalization is basically division of a given table into two or more subtes so that we can reduce the data duplicacy or you can say data redut dency and also maintain the data consistency along all the tables now coming to the first normal form so first normal form is the first step in the normal normalization process which help us to reduce the data redundency as I told that normalization is oftenly used to reduce the data rud deny or you can say data duplicacy and first normal form is the first step in the normalization process which help us to achieve that now what it says is every table should have Atomic values that is there shouldn't be any multivalued attributes which is present in a table now what is this multivalued attribute so consider that there is a attri attribute or a column phone number now one given person can have multiple phone numbers like I can also have two phone numbers or three phone numbers so we can say that phone number can have multiple values so we can say a given attribute whenever it holds multiple values that is a multivalued attribute so to ensure that a given table is in first normal form these are some set of rules a given table should follow so the first rule is atomicity which says that attributes should always have single value that is there shouldn't be any multivalued attribute which is present in our table if in our table there is a multivalued attribute we can say that our table is not in first normal form now coming to the second set of rule that is uniqueness of rows so we should always make sure that each row should be uniquely identifiable that is there should be a primary key which should exist in a table so that there is a unique identification key in our table now let's see about each and every set of rule and let's see that if in a given table if it's not in first normal form how we can make the given table in first normal form so the first rule was atomicity it says that each column should contain only indivisible Atomic values meaning each attribute should hold only a single value there shouldn't be any attribute which should be holding multiple values so here we can see that there is a table in which we are having columns as ID person name and Order and here we can say that ID is having sing single values person name is also having single values but when we see the order column we can say that there are multiple values which is present in the order column for a given person so we can say that order is a multivalued attribute because order is having multiple values so we can say that this particular table is not in first normal form since it is having a multivalued attribute now let's see that how we can achieve atomicity or how we can make sure that our table is in first normal form so there are three ways in which we we can make a table in first normal form so the first approach is what we can do is if there is a multivalued attribute we can repeat the other attributes twice or Thrice depending on the values which is present in the multivalued attribute so that attribute can hold only single value so here what we can do is we can repeat the values in the ID and person name column twice since we can see that there are two values for order for some of the entries so we can repeat it twice to store single value of the multivalue attribute order so what we will do here is we will write down all the columns or all the attributes which is present in our table and then we will see that which is the multi valued attribute we will leave that particular attribute and apart from that attribute all the attributes which are present we will repeat according to the values which is present in our multivalued attribute so here you can see that for Raj there are two orders so we will repeat one Raj twice so that we can have single value for this particular order column so first we will write write one Raj and then we will write the first order that is muffin and then we will write one Raj and then the second order that is sugar same we will do for REI but since RTI is only having a single order so we will write RTI only for once to RTI muffin and then Rahul is also having two orders so we will write three Rahul sugar and three Rahul egg so now here we can see that this particular column order which was earlier holding multiple values is now only holding single Valu so we can say that the multivalued attribute is eliminated and and there are only single values which is present in this table so we can say that this particular table is in first normal form now what would be the primary key in this particular table so here you can see that for a given ID the person name is getting repeated twice for one there is Raj again for one there is Raj so we can't say ID and person name would be a primary key let's see that if ID and Order can be a primary key or not so here you can see that there is id1 and then the order is muffin here there is id1 and then the order name is Sugar so here we can see that there is no repetition so we can say that ID and Order combinedly act as a primary key for this particular table now let's see the second approach so in the second approach what we can do is we can make new columns for each multivalue which is present so consider here the order is having at Max two values so what we can do is we can make different columns first we can make it as order one and second we can make it as order to so that it can store all the values which is present in order so we will make the table as ID person name then we will make the column as order one and then second column as order two so we will just fill the data so for one Raj there is one time muffin and the order two is sugar so we will fill one Raj muffin sugar then coming to reti so for reti there is only one order so in order one we will fill muffin but since there is no order two or there are no two orders we will be filling value as null null basically means empty now coming to the third for Rahul there are also two orders so for the first order we will will be entering sugar and for the second order we will be entering egg in this approach if you see according to the values which is present in the order we are making new columns but consider that if there are nine orders which are present would you be making nine order column order one order two till order 9 that is not a feasible case because for each and every order you need to fill null as a value for re there could be more person in this particular table who are having only one order so for them also you need to fill null so this is not a approach which is always suggested but since you can see that this particular table there is no multivalued attribute so we can say that it has converted the table into first normal form but this is not a suggested approach now coming to the primary key of this particular table so we can see that ID is something which is unique for each and every Order each and every person so the ID would be acting as a primary key here now coming to the Final Approach in Final Approach what we will do is we will divide the table into two table first is the student table and second second is the order table so we'll see that order is the multivalued attribute so what we will do is we will divide the table into two table first table would be having ID and person name second table would be having order but we need to maintain that this particular order belongs to which particular person or which particular ID so we will be breaking it into ID as well as order so there would be two tables first is having ID and person name second is having IDE and order so we will break the table based on the multivalued attribute now here you can see that there is ID and person name and ID is unique for each person and ID can uniquely identify each person so we can say that ID is acting as a primary key here and here you can see that there is a relationship which is established between two tables because this particular table tells me that corresponding particular ID is having which order and here it tells us that what is the name of a person corresponding to their ID so we can see that there is a relationship which is established and this ID is taking reference from this particular ID which is present here so we can see that this is a foreign key as it is taking reference from the base table so we have divided the table into two table base table and the referencing table in the base table there is a primary key which is acting as a foreign key in the referencing table now here you can say that order is now having only single values it is having all the IDS which is corresponding to the given order and this particular table has now been converted into the first normal form so this was the last approach which we can follow and this is kind of a best approach which we can follow because we oftenly divide the table and we can say that the data redundency is also less yes I do agree that in this particular ID column we can see some of the duplicate entries but in this particular table we are not seeing any duplicacy and in this particular table ID and Order both are acting as a primary key so ID and Order both can together help me identify unique values and here ID can help me identify unique values so there is some level of duplicacy because normalization doesn't guarantee to remove the entire duplicacy but the duplicacy is reduced in comparison to this case now before starting with second normal form let's just re- revise about first normal form so according to First normal form in a given table there shouldn't be any multivalued attribute so basically there shouldn't be any column which can hold multiple values the values should always be Atomic that is there should be always a single value there shouldn't be multivalued attribute present in a given table now coming to the second normal form so relation is in second normal form if it satisfies the following conditions so the first condition it it should always be in first normal form and the second condition is it should not have any partial dependency which means no nonprime attribute is dependent on any part of candidate key now candidate key is basically a unique identifier which help us to uniquely identify records in a table what is non-prime Atri attribute so we learned about prime attributes and non-prime attribute so consider that in a given table there are three attributes a b and c and ab is our candidate key so the attributes which are a part of candidate key lies in the prime attribute and the attributes which are not a part of candidate key lies in the non-prime attribute so according to this there shouldn't be any non-prime attribute that is dependent on any part of a candidate key now here we learned about the this term partial dependency so let's understand what partial dependency exactly is so what is partial dependency and when a partial dependency is there in a table so a partial dependency is there in a table when the LHS is a proper subset of candidate key and rhs is a non-prime attribute so whenever you are given any question you are provided with all the attributes which are present in the table then you are provided with the functional dependencies like this particular attribute is determined this attribute or B is determining C so these kind of functional dependencies are present in our table now according to partial dependency definition we have to see if LHS is a proper subset of candidate key and rhs is a non- prime attribute if these exist then we can say that our table is not in second normal form because there is a partial dependency so as the term suggest partial dependency you can understand it in this way that a particular non time attribute is partially dependent on candidate key because it says a proper subset so if a proper subset of ab is to be considered so it will be a and b it won't include a in the set because that is a subset not a proper set so whenever we talk about proper subset it will only contain A and B and not AB so whenever there is a partial dependency a part of candidate key is determining a non-prime attribute so since a part of candidate key is determining we we can see that there is a partial dependency because a part is determining there is a dependency and there is a non-prime attribute which is getting partially determined so we'll see about partial dependency in the next set of slides but right now you can conclude that if a given table is not in first normal form also if there is some partial dependency we can say that the given table is not in second normal form so what is a non-prime attribute as I told that non-prime attribute is an attribute that is not part of a candidate key now here you can see that there is a table in this particular table we have customer ID we have order ID and we have order name so we have order ID and according to the order ID we have the order name and here we have the customer ID of a customer who has place this particular order now coming to this particular table we have a candidate key as customer ID and Order ID combination so Prime attribute would be the one which is a part of candidate key that is customer ID and Order ID and since now order name is left so order name will come in non-prime attribute because it is not a part of candidate key so in this relation you can see that order name is somehow dependent on order ID for its value so if order ID is one the order name is muffin if order ID is two the order name is Sugar so order name is somehow dependent only on the order ID it's not dependent on the customer ID because if I know the customer ID I can't see the order name before even knowing the order ID so because of that the order name is having a dependency on order ID but here we told that customer ID and Order ID both are acting as a candidate key and here a part of candidate key is determining a non-prime attribute so we can say that there is a partial dependency so according to order ID we provide the order name and Order name is determined only by order ID and here customer ID order ID together are acting as a candidate key but here only part of candidate key is determining the non-prime attribute so we can say that there is a partial dependency this particular table is not in second normal form so how can we make the table in second normal form or how can we normalize the table so as I told that normalization is basically breaking of tables into two or more subtables or you can say decomposition of table into two or more subtables so that the duplicacy or data redundency is reduced also the data is consistent so what we will do is we will divide this particular table into two tables so now the question which would be coming to your mind is how we will even divide this table what all attributes should be there in the first table in the second table or if there are three tables how to divide this particular table so what you can do is firstly let's consider this table so let's name the table as a here the table is B and here the table is C now in a the candidate key is customer ID plus order ID and we have order name which is kind of dependent on order ID so if we know the order ID we can get the order name so what we will do is we can see that order ID is some something which is common between the non-prime attribute and the candidate key so we will break the table on the basis of order ID and we will try to have order ID in the next table as well because in this way we won't lose the track of which particular customer has ordered which particular order so we will divide the table into two or more subtes and here the table is divided into B and C and here the table is having customer ID and Order ID and here the table is having order ID and Order name so corresponding to the order ID we have the order name and here the customer ID has the order ID corresponding to which we can get the order name from the second table now here can you see that in this particular table we have the candidate key that is customer ID plus order ID but coming to this particular table what should be the candidate key here so here you can see that order ID is also getting repeated order name is also getting repeated so can we see that order ID and Order name combined would be a candidate key yes we can say that so we will have order ID as well as order name combinedly as a candidate key so now you can see that when the table is divided into two or more subtes we have seen that now order name is directly dependent on order ID there is no other candidate key which is present and this is also a prime attribute this is not a non-prime attribute because right now this is also a part of candidate key so we can say that now there is no non-prime attribute which is getting determined by a part of candidate key so in this way we can normalize the table now coming here you can see that order ID is present here and in this table as well in table B and in table C now here you can see that there is a relationship which is established so here the customer tells that this particular order ID I have ordered give me the order name so you can see that there is a relationship between two table which is being established and it is established on the basis of order ID so this particular order ID is taking reference from this table that is B table so we can say that order ID here is acting as a foreign key which is helping me to establish the relationship between these two tables so let's solve a practice question in which we will be provided with some attributes we will be provided with some functional dependency and we have to say that if the given table is in second normal form or not so let's see so consider that there is a relation R which is having a b c d as attributes the functional dependencies which are provided are a b determines c a b determines D and B determines C now in this relation find if this is in second normal form or not so let's see what we will do so the very first step is we will identify the candidate key in this given relation so how to find the candidate key we have already discussed in one of our video so you can go ahead and watch it and then come to this video so for candidate key what we will do is firstly we will list down all the attributes which is present in our table secondly what we will do is we will check for all the dependents if the determinants are present here if it's present then we will discard the dependents so here the dependent is c c is already present so AB is the determinant so we can discard C now it's a b d now coming to the next functional dependency D is present here and since AB is already present here we can discard D so now coming to the next functional dependency here C is the dependent and B is the determinant but since dependent is not present we can't discard B so at the last we are left with AB so what we will do is we will take the closure of ab and we will see that if it's determining all the attributes which is present in our table so a can determine itself B can determine itself from the property of reflexivity B can also determine C so we can write C AB can also determine D so we can write D so AB can determine all the attributes which is present in our table so we can say that AB is a candidate key and we can add it in the prime attributes now in The Next Step there could be more candidate key so for that what we will do is we will see that if AB is lying in any of the rhs because if AB is someone's dependent and there is a determinant which can determine AB we can repl AB with that or ideally A or B with that so let's see if a b or AB is present in the rhs so here it is C here it is D here it is C so there is no a b or AB present in the rhs so we can say that there will be only one candidate key for this particular table and that is AB now here we have found out that AB is the candidate key here the step two we will check for the partial dependency to tell that if this given table is in second normal form or not so for that there should be two rules rules which should be followed so first is LHS should be a proper subset of candidate key and here we have found out that AB is the candidate key so if we take the proper subset we get a and b so we have to check that if LHS is a proper subset of candidate key in a given functional dependency and if rhs is a non-prime attribute so since AB is a candidate key we can say that AB lies in the prime attribute and the rest attribute which is not a part of candidate key we can say it lies in the non-prime attribute that is CD if these two exist we can say that there is a partial dependency and table is not in second normal form but if none of the dependencies having any partial dependency we can say the table is in second normal form so these were the functional dependency which were provided to us this is the candidate key that is AB so the prime attributes are AB the non-prime attributes are CD so let's check for the first functional dependency so we have to first check if LHS is a proper subset of candidate key or not so AB is a candidate key but there is no proper subset proper subset of ab is a and b but it is combinedly present so since there is no proper subset and since there is a and condition so we won't check for the second condition AB is not a proper subset it is a subset of ab so we can say that this particular functional dependency doesn't have any partial dependency now coming to the second functional dependency so again you can see that there is AB present so there is not a proper subset of ab which is present subset of ab is present so we can also set that this particular dependency is also not having any partial dependency so coming to the third functional dependency that is B determines C so here in the LHS you can say that b is a subset of ab or you can say that b is a subset of candidate key and according to these rules if LHS is a subset of candidate key we need to check for the second rule and if second rule also applies there is a partial dependency so we'll check for rhs and rhs is C which is a non-prime attribute and here according to this rule rhs is a non-prime attribute and LHS is a proper subset of candidate key then there is a partial dependency so we can say that this particular dependency have some partial dependency because of which this particular table is not in second normal form so from this we can conclude that this particular table is not in second normal form and also we have analyzed the dependency and we saw that one of the dependency was having some partial dependency so that is why the table is not in second normal form now according to the first normal form there shouldn't be any multivalued attribute or there shouldn't be any attribute which has multiple values According to second normal form there shouldn't be any partial dependency which should exist in a table now let's see what third normal form says so according to third normal form it should be in second normal form like the table should be in second normal form second is it shouldn't have any transitive dependency which means that no nonprime attribute should be transitively dependent on a candidate key so what is this transitive dependency so transitive dependency occurs when nonprime attribute is dependent on another non-prime attribute so whenever there is a nonprime to non-prime dependency we can say that there is a transitive dependency let's understand transitive dependency in more depth so consider that I have been given a project now for that particular project I need some details I need some books so I'll go to a library a now that particular Library borrows book from from Library b so somehow you can say that for my project X I want some books from library a but Library a is somehow borrowing some books from Library b so Library a is dependent on B for the books and I am dependent on Library a for the books so you can see that there is some transitive dependency which I am having with Library b because if the books are not present in Library b it will not reach to library a and if it doesn't reaches to library a I won't be getting that books so this is called a trans transitive dependency when I'm not directly dependent on something but indirectly dependent on something so in this way we can say a partial dependency or a transitive dependency occurs in a table and whenever there is a transitive dependency in a table we can say that that particular table is not in third normal form now there are two ways in which we can determine if a given functional dependency is following the third normal form or not so if there is a transitive dependency there would be a non-prime to non-prime dependency also if you want to check that if there there is no transitive dependency so we can check for these two rules that is if x is determining Y is a functional dependency then either X should be a Super Key or candidate key or Y should be a prime attribute that is a part of candidate key so if any one of these holds true we can say that this functional dependency doesn't have any transitive dependency so if there is no transitive dependency X will always be a part of super key or candidate key and Y will always be a prime attribute because consider that here x is determining Y and consider that Y is determining some Zed and since Y is a prime attribute and using the rule of transi we can say that X will determine Z so X is determining Zed using a prime attribute there shouldn't be any case where Y is a non-prime attribute and using that non-prime attribute X is getting determined by Z so this uh determining Factor should always be a prime attribute or we can say for the rule of transitivity to exist the dependent should always be a prime attribute and since X is determining y x should always be a part of candidate key or a Super Key I know this might sound confusing but now you can remember it in this way that there shouldn't be any transitive dependency in the given table or in the given functional dependency and how we can identify that there shouldn't be any non-prime to non-prime dependency that if x determines Y is there as a functional dependency X and Y both shouldn't be non-prime attributes either X should be a candidate key or super key or Y should always be a prime attribute so let's understand from an example consider that there is a relation a b c d with functional dependency a b determines C and C determines D find if it is in third normal form or not so we need to check that if there is any transitive dependency and for the transitive dependency check we need to know that for this particular table what are the non-prime attributes so finding the non-prime attributes is very easy when we know the candidate because all the attributes which are not part of candidate key lies in the non-prime attribute so let's find the candidate key for this given table so firstly what we'll do is we will Lo down all the attributes which is present in our table then we will check that for a given dependent if its determinant is present and dependent is present or not if its determinant is present we can discard the dependent so here we can see that c is the dependent and ab is the determinant C is already present here and if we have AB it can always determine C so we can discard C from here so for the next fincial dependency we can see that d is present D is the dependent and C is it determinant so if the dependent is present we can discard the determinant but since C is not present here we can't discard anything but if you see closely to this functional dependency it says that AB determines C and C determines D so can we say that AB will determine D using the rule of transitivity so we can say that if AB is present it can already determine D so if AB is present it can already determine D so we can discard this as well so now we are left with AB now we need to take the closure of ab to see if it determines all the attribute which is present in our table so a can determine itself B can determine itself AB will determine C and C will determine D so we can say that AB is a candidate key now we need to see that if any of this A or B is present in the right hand side of any of the functional dependency if it's present we can replace and find out more candidate key if it's not present then we can say that this is the only candidate key so let's C so in the right hand side of the first functional dependency it's C in the right hand side it's D so we can say that there won't be any more candidate key so AB is a candidate key here so we can say that AB is a candidate key here now in the next step we need to check for the transitive dependency if there is any transitive dependency we can say that the given table is not in third normal form if there are none of the transitive dependency we can say that the given table is in third normal form only if the table is in second and the first normal form so always keep this thing in mind that for a table to be in third normal form it should always be in second normal form if it's not in second normal form we can't even say that the table is in third normal form so from here we have find out that AB is the candidate key let's find the prime and the non-prime attribute so Prime attributes are the one which are the part of candidate key that is AB and non- Prime are the one which are not a part of candidate key that is CD so in this particular table we have found out the candidate key we have found out the prime attribute and we we have found out the non-prime attribute now let's see that if there is any non-prime to non-prime dependency existing in the table or not so there are two functional dependency for the first functional dependency AB determines C so is AB a non-prime attribute no neither of a nor of B are a non-prime attribute and is c a non-prime attribute yes C is a non-prime attribute but since AB is not a non-prime attribute we can say that there is no transitive dependency as AB is a candidate key or a Super Key now coming to the next functional dependency C determines D now here C is a part of non-prime attribute so the first condition is agreeing that there shouldn't be any nonprime attribute in LHS now coming to rhs D is also a part of non-prime attribute so rhs is also having a nonprime attribute so there is a non-prime attribute which is determining a non-prime attribute so we can say a transitive dependency is existing because C is not a super key or candidate key or D is a prime Atri rute and a non-prime to non-prime dependency is existing where a non-prime attribute is determining a non-prime attribute see Prime attribute can determine a non-prime attribute non-prime attribute can determine a prime attribute Prime attribute can also determine a prime attribute but there shouldn't be any dependency where a non-prime attribute is determining a non-prime attribute so till now we have discussed on this nonprime to non-prime dependency but do you even wonder that why this particular dependency if exist in a table we say that table is not in third normal form for so consider an example that there is a table now in this particular table we oftenly find the primary key or the candidate key because that act as a unique identifier so consider that there are three columns a b and c so here a is acting as a key Either you can say primary key or candidate key now why do we even need key in a table so basically key help us to uniquely identify records in a table if I know the value of a I can tell the value of B and C but consider that there is a case where I know the value of B would I be able to tell the value of C or a consider that here the value of B is 1 and 1 and here the value of C is 4 and 5 so if I tell you that the value of B is 1 tell me the value of C so if you look here for one it is also having the value as four for one it is also having the value as 5 so would the value of B help me to find the value of C no it would not help me right so for that purpose only we have a key we can say candidate key Super Key primary key in a given table so that we can uniquely identify records if I know the value of a I can tell the value of B and C for that particular value of a so for that particular purpose we have a candidate key and when there is no candidate key or no Prime attribute or Super Key which is determining something we can say that we won't be able to determine anything because now the dependent values can be different so for the dependent values to remain same we need to have a candidate key or super key as a determinant because it will help me to identify the values so that is why there shouldn't be any non-prime to non-prime dependenc because there should always be a determinant which should be a candidate key which can help me to find the value of dependent so the very first question which would be coming to your mind is why do we even need to learn about Bo code normal form if you have already learned about third normal form and you are saying that this is a refinement to the third normal form so what was the issue in third normal form so if you remember according to third normal form if there is a dependency X determines y x should either be a Super Key or a candidate key or Y can be a prime attribute so because of this or we were encountering some anomalies and some data rud deny let me explain you why so considered there is a relation R which is having attributes as a b x and y in this particular relation are B and Y are prime attributes and X is a candidate key so consider there are two functional dependency X determines y a determines B so in this since X is a candidate R key we can say that it follows the third normal form rule so this particular functional dependency is in third normal form now coming to this dependency here a is neither a candidate key or super key but here B is a prime attribute so because of this we can see that this particular functional dependency also follows the third normal form rule but here a wasn't a candidate key or super key because of which there was some data rud dency or duplicacy which was there and it was causing some certain anomalies to be present in our table now because of that the boys code normal form was introduced so that we can add some refinement to the third normal form now according to boys code normal form or bcnf a relation should be in third normal form second for a given functional dependency X determines y x should always be a candidate key or super key and should only determine non-prime attributes so according to the boys code normal form it says that there shouldn't be any or condition X or the determinant should always be a candidate key or super key so that there is no data r or the data redundency is reduced so let's understand from an example consider that there is a relation R which is having attributes as a b c and d and there are some functional dependencies which are provided so find if this particular relation is in bcnf or not so what we will do is first we will identify the candidate key so let me just write down all the attributes which is present in our table and then we will see if the dependent is present here or not and if its determinant is also present here or not if it's present then we can discard the dependent so C is the dependent and its determinant is AB so since C is present AB can determine C so we can discard C now AB b d is present now coming to this functional dependency D is the dependent and ab is the determinant D is also present and ab is also present so we can discard the dependent and now AB is present now there are no functional dependencies so what we will do is we'll take a closure of ab so it will give me a b c and d and there is no proper subset of ab which will give me all the attributes so I can say that AB is a candidate key so AB is the candidate key here now as part of second step we have to check for the candidate key or super key in LHS so these are the functional dependencies so coming to the first functional dependency since AB is the candidate key and ab determines C we can say that LHS AB is a candidate key so it follows the boys code normal form now coming to the second functional dependency that is AB determines C since again AB is a candidate key so this also follows the bcnf rule so we can say that this particular relation is in bcnf let's just re revise some older Concepts and then we will switch to the decomposition so consider there is a relation R now this particular relation R has some rows has some columns and has some data present in it consider that there is a data redu densy or you can say data duplicacy which is present in this particular table or this particular relation so what we will do is we will normalize the relation so what we do in normalization is we break or decompose the given relation into two or more sub relations so that the data redu deny or data duplicacy is decreased so we have broken it into R1 and R2 now this particular decomposition can be of two types first is a lossy decomposition and second one is a lossless decomposition which we will be knowing in this particular video so in normalization we generally break or decompose the table into two or more subtes now consider if there is a relation R lossy decomposition occurs when a relation R is decomposed or broken into two or more relation but the data is lost so basically in this kind of decomposition the data is lost and the original relation R can't be reconstructed by joining these decomposed relation so if there is a relation R which is broken or decomposed into R1 and R2 and consider that if I want to find some data which is present in R1 as well as R2 I perform a join operation between them and after performing the join operation I get R3 so according to the definition of lossi decomposition R3 would never be equal to R which was our base table so some data is lost and some data may be repeated as well so the data which is present in R3 is not equal to the data which is present in R basically data is not preserved so there are two rules for decomposition to be lossy the first rule is some data from the original relation R is lost after decomposition so R3 is not equal to R second is join of the decomposed relation R1 R2 till till RN if there are n number of relation is not equal to the original relation R so after getting decomposed and Performing the join operation the resulting relation is not equal to the base relation or you can say the relation R which was the original table so let's understand lossy decomposition from an example so consider that there is a relation R which is having attributes as a b and c so this is the relation R which is having attributes a b and c so what we will do in Step One is we will decompose the relation based on any attribute so we can choose any attribute and we can decompose the table based on that attribute consider that we are choosing B so we'll decompose the table into ab and BC so for now let's use b as the common attribute decomposed relations are R1 R2 R1 is having a and b and R2 is having B and C and the value Remains the Same so a is 1 and 4 a is 1 and 4 B is 2 and 2 C is 3 and 6 so all the values remain the same it's just that we have broken the table vertically from B and B is the common attribute which is in the relation one as well as in the relation two now step two is let's perform a natural join between R1 and R2 so what is this natural joint join is basically a cross product plus some condition so whenever we perform a cross product and then we provide some condition and on basis of that we filter the data we perform joint now coming to the Natural joint so what happens in natural joint is we do the cross product and then the condition in natural join is that the attribute which is present in relation one should be equal to the attribute which is present in relation two so on basis of this we will filter out the data so let's perform a natural joint between R1 and R2 so what we will do is first we'll do a cross product so for the cross product the first row of R1 will be cross product with both the rows of R2 then the second row of R1 will be cross product with both the rows of R2 and then we will filter the data based on on the condition so what we will do is first we will note down the values of R1 that is 1 and two now 1 and two will be cross product with two and three of R2 and then 1 and two will again be cross product with 2 and six now coming to 4 and two so 4 and two will be cross product with 2 and three and again 4 and two will be cross product with 2 and six now what we will do is we will follow the condition that the common attribute should be equal so R1 of B should be equal to R2 of B so this is a a b and this is b c so let's see if R1 of B is equal to R2 of B yes so this will be in our final result coming to this R1 of B is equal to R2 of B yes so this will also be in our final result coming to Third R1 of B is equal to R2 of B yes so it will be also displayed in final result coming to the last one R1 of B is equal to R2 of B yes so this will also be displayed in the final result so the final relation we will get after the join is 1 2 3 1 2 6 4 2 3 and 4 to six now this was our original relation which has 1 2 3 4 5 6 and this is the relation after we perform the natural joint so here you can see 1 2 3 which is present here as well but coming to 456 it is not present here so we can see the data is lost and we can also see some additional fields which is present here so we can clearly say that R3 is not equal to R because some data is also lost and some extra data is present so this is a lossy decomposition so we saw in the lossy decomposition that our data was also lost and there was some extra set of data which was also present but now we have to make sure that even if the decomposition happens the data is not lost so that is a lossless decomposition so whenever we see a lossless decomposition it basically means whenever the decomposition happens and if there is a join operation which is performed between both of these relations or the decomposed relation we don't lost the data the data is preserved so let's see that how we can ensure that the decomposition is a lossless decomposition so the first pointer is divide or decompose the table on the basis of candidate key or Super Key present in the relation so that there is no duplicacy so as we can also see that in the lossy decomposition there was some duplicacy there was some extra data which was present so we have to make sure the attribute on basis of which we are dividing the table should either be a candidate key or should be a Super Key so that this unique identifier will help me to eliminate the duplicate data now coming to the second pointer for a decomposition to be loost cess first is R1 Union R2 should be equal to R so whenever we do a union between the decomposed table it should always result into the original table now the second one is R1 intersection R2 should be equal to the common attribute so consider if our relation is broken down into R1 and R2 and R1 is having AB as the attribute and R2 is having BC as the attribute so whenever we do a intersection between them it should result into the common attribute which is present between this relation so R1 intersection R2 should result into the common attribute third pointer is to ensure that a decomposition is lossless a common approach is to use the dependency preservation property now we will learn about this dependency preservation property in next set of videos but for now you can keep these two pointers in mind so that a decomposition is not lossy it's lossless now coming to the lossless decomposition so consider that there is a relation R so in lossless decomposition it ures that when a relation R is decomposed or breaked into two or more relation no data is lost that is the original relation R can be again reconstructed by joining these decomposed relation so if there is a relation R which is decomposed into R1 and R2 and whenever we perform a natural join or a join between them if we get R3 so the data which is present in R is equal to the data which is present in R3 so the data is preserved and we get the original Table after performing The Joint operation so there are two rules for a decomposition to be lossless first one is all data in the original relation R should be preserved after decomposition and second is join of the decomposed relations is equal to the original relation so let's understand from an example for the lossless decomposition so consider there is a relation R having attributes as a b and c and the candidate key here is given as a so what we will do in the lossless decomposition is we will divide the table on the basis of the candidate key and that would be a common attribute so let's decompose the relation based on the candidate key or super key of given relation so the decomposed relation would be R1 which will be having a and b and R2 which would be having a and C since a is the super key or candidate key so this would be a common attribute now this are the relations R1 and R2 so let's perform a natural joint between them now whenever we perform a natural joint between two relations what we do is we do the cross product among two relations and then we perform a condition between them that is the common attribute in R1 should be equal to the common attribute in R2 so first we'll do the cross product so first this row will be multiplied with all these rows so 1 2 is Multiplied with 1 3 then again 1 2 is Multiplied with 4 and six now coming to the second row so four and five will be cross product with 1 and three and then again four and five will be cross product with 4 and six now let's check for this condition where R1 of a should be equal to R2 of a so this is R1 of a and this is R2 of a so R1 of a is equal to R2 of a yes so 1 2 1 3 will be in the final result R1 of a is equal to R2 of a no so this should be discarded from the final result R1 of a is equal to R2 of a no so this should also be discarded from the final result R1 of a is equal to R2 of a yes this should be present in the final result so if you see the original relation it has 1 2 3 4 5 6 and if you see the relation after natural joint it also has 1 2 and 3 and four 4 5 and six so the relation which we get after performing a natural joint on the table is same as the original relation so in step two let's perform a natural joint between R1 and R2 and whenever we do R1 natural joint R2 we get the original relation back so consider this is a relation R3 so R3 is equal to R because all the data which is present in R is present in R3 so that is why this is a lossless decomposition as the word suggest dependency preserving decomposition so whenever we are having decomposition or whenever we are in a process of having decomposition if the functional dependency before the decomposition and after the decomposition are preserved or maintained we call it as dependency preserving decomposition so dependency preserving decomposition ensures that the functional dependencies are preserved or maintained after decomposing a relation into two or more smaller relation so it makes sure that the functional dependencies are preserved before the decomposition as well as after the decomposition now here consider an example so consider a relation R which is having attributes as a b and c with functional dependencies as a determine B and B determine C find its dependency preserving when it's divided into relation R1 which is having a and b and relation R2 which is having B and C as the attribute so here we have a relation a BC which is now divided into two relation R1 and R2 where R1 is having AB as the attributes and R2 is having BC as the attribute now we have to see the functional dependency which was there before the division or before the decomposition is preserved or maintained or not now coming to the first relation that is R1 so it is having attributes As A and B now if we want to form a functional dependency using these attributes what can we form is a can determine itself B can also determine itself these are trivial dependency or we can say the property of reflexivity now a can also determine B these functional dependency we have derived now coming to the trivial dependency we generally don't care about reval dependency because it always holds true so for this we don't need to look at now coming to the is there any functional dependency which is present here which is also here so we can see that a determines B is there before the decomposition and a determine B is also there after the decomposition so we can say that this particular functional dependency is preserved using this particular decomposition table now coming to the second table that is R2 which is having attributes as B and C so the trivial dependencies could be B determine b c determine C but we don't need to take care of trivial dependency so coming to the non-trivial one so it could be b determin c so among these functional dependency let's see if there is any dependency which is preserved even after decomposition so you can see b determin c is here as well and here as well so before and after the decomposition b determin c is preserved so in this particular table BC b determin c is preserved so both of the functional dependencies is preserved so we can say that the decomposition is dependency preserving because the functional dependency a determine B and B determine C are preserved in relations R1 and R2 now let's see one more example so that the concept is clear so consider there is a relation R which is having attributes as a b c d and the functional dependencies are a determine B A determine c c determine D find if its dependency preserving when divided into R1 a b c and R2 CD coming to the first relation that is R1 which is having attributes as a b and c so since this R1 is having attributes as a b and c there could be some functional dependencies which would be present so first what we will do is we'll take the closure of a so if we take the closure of a it will give me a b c and d all the attributes coming to the closure of B it will only give me B coming to the closure of C it will give me C and D so from here we can say that a can determine a A can determine B A can determine C A can determine D so we can make the functional dependency as a determine b and a determines C now coming to b b can only determine itself so we will discard it coming to C so C can determine itself and C can determine D but there is no D present in this particular relation so these two would be the functional dependencies which would be for this particular relation and coming to the functional dependency which was present before so we can say that a determine B is a function dependency which is preserved here coming to a determine C is also a functional dependency which is preserved here so we can say that for the first table a b c a determine b and a determine C is preserved now coming to the second table that is R2 which is having C and D now from c and d c can determine C and C can determine D so there would be only one functional dependency C determine D and now if we see to the functional dependency which was present before the decomposition there is a CED determin D and after decomposition also CED determined D is there so C determine D is also preserved so the decomposition is dependency preserving because the functional dependency a determine B and B determine C are preserved in R1 and R2 so if you want to find that if a given relation is having dependency preserving decomposition or not what you can do is you can note down the relation and then you can find out the decomposed table of that particular relation for the original relation you can note down the functional dependency for the decomposed relation you can find out the functional dependency using the closure method where you can find the closure of individual attributes and when you have find the closure of individual attributes you can know which all attributes that particular closure can Define and then you can derive some functional dependency based on that once you have derived the functional dependency you need to check if the functional dependency which is derived after decomposition and if the one which was present before decomposition is preserved or not in this way you can find out if a given relation or if a given functional dependency is dependency preserving or not now what is fourth normal form so a relation is said to be in fourth normal form if it satisfies the following condition so the first condition is it should be in bcnf that is boys code normal form second is it shouldn't have any multivalued dependency now what is this multivalue dependency so multivalued dependency X determines y x determines Zed in a relation R XY Z implies that for each value of x there are a set of values of Y and set of values of Zed that are independent of each other so according to multivalue dependency if x is having a multivalue dependency on y so for every value of x there would be multiple values of Y or if x is having a multivalue dependency on Zed so for every value of x there would be multiple value of Z so let's understand from an example consider that there is a relation student which is having student ID student course and student phone number now one particular student can have multiple course one particular student can also have multiple phone number numbers so let's see from this relation so here you can see that the student ID is one but the course he has taken is maths and the phone number is 23 again the student ID is one the course he has taken is science and the phone number is 123 now again coming to the student ID as one the course he has taken is maths but now the phone number is 345 so we can say for a student ID 1 the course is maths and signs and the phone number is 1 2 3 and 345 so you can see for a given student ID we are providing four entries now again coming to student 2 so student 2 has taken Hindi and English and the phone numbers are 678 and 910 so here you can see that there is so much of redudant data so let's see that how we can decompose the table and get rid of this redudant data so this was our base table or original table now it has been split into two tables and the common attribute between them is student ID so what we have done is we have split the table into student ID and course and then student ID and phone number now here you can see that student ID is only having two entries and the course is mentioned for that particular student ID and now coming to the second table it has happened in the same way that the student ID is now mentioned only two times and the phone number corresponding to the student ID is mentioned so you can say that the data redu deny or data duplicacy is reduced here and since we have decomposed the table we have often normalized the table so this now fifth normal form or we can also call this project join normal form that is pgf so a relation is set to be in fifth normal form if it satisfies the following condition first is it should be in fourth normal form second is the decomposition should be lossless now what is this lossless and lossy decomposition so we have already learned about lossy and lossless decomposition in last set of videos you can go ahead and have a look but just to re- revise let's have a look again so consider that there is a relation now this particular relation have some redent data so according to normalization we normalize or we decompose the table into two or more subtes so that the data dcy is less now this particular decomposition of relation can be of two type lossy and lossless now in lossy decomposition we often lose the data or data is lost or data is not preserved and in lossless decomposition the data is preserved even after decomposition so data is preserved so consider that if we have divided the relation or decomposed the relation into R1 and R2 and if we are performing a join operation between R1 and R2 which is giving me R3 so according to lossless R3 would be equal to the original relation that is R so all the data which is in R3 would be equal to the original relation but in lossy decomposition R3 wouldn't be equal to R because in lossy decomposition we often loss the data so the decomposition should be lossless for a relation to be in fifth normal form now lossless decomposition it ensures that when a relation R is decomposed or break into two or more relation no data is lost and the original relation R can be again reconstructed by joining this decomposed relation that is R3 is equal to R for the lossless decomposition let's understand from an example so consider that there is a relation R which is having attributes as a b and c and the candidate key is a so often in lossless decomposition we decompose the table on the basis of candidate key and make it as a common attribute between both the decomposed relations so Step One is let's decompose the relation based on the candidate key or super key of the given relation so decomposed relation are R1 ab and R2 AC so this was our or original relation which has a b and c and now it's decomposed to a b and a c now whenever we perform a natural joint between R1 and R2 so natural joint is basically a cross product plus some condition the condition is the common attribute in R1 should be equal to the common attribute in R2 on basis of which we have divided the table or we have decomposed the table so after doing a natural join we see that R3 or you can say R1 natural joint R2 is same as the original relation so all the data 1 2 3 4 5 6 is preserved in this particular relation as well so step two let's perform a natural joint between R1 and R2 and whenever we do a R1 natural join R2 we get the original relation back that is lossless so we can say that this particular table or this particular relation is in fifth normal form because the decomposition is lossless and it is also in fourth normal form so how to find the highest normal form of a given relation so the step one is we have to identify the candidate key for the given relation using the functional dependencies which are present and the closure method now the step two is we have to find the prime and non-prime attributes for the given relation so Prime are basically the ones which are part of candidate key and non-prime are the ones which are not the part of candidate key now the step three is we have to check for the normal forms one by one according to their rules so all the normal forms have some specific rules we have to see that if the functional dependency corresponds to the given rule or not now here you can see that there is a box which I have drawn first is first normal form second is 2 NF third is third normal form and fourth one is bcnf so it says that if a given relation is in bcnf it is always in third normal form second normal form and first normal form if a given relation is in third normal form it will always be in second and first normal form if a given relation is in second normal form it will always be in first normal form and if a given relation is in first normal form then it's in first normal form so if if any relation is present if we check if the given relation is in bcnf or boys code normal form we can say that it is in third normal form second normal form and first normal form if a given relation is in third normal form we can see it is in second and first if a given relation in second normal form we can say it is in first normal form so this is the box or this is the pattern which it follows if a given relation is in bcnf we can say that it follows all the three normal forms so let's find out that how we can find the highest normal form for a given relation using this problem statement generally we should start with bcnf because if a given relation is in bcnf we can say that it is in third normal form it is in second normal form and it is in first normal form so if we start with bcnf it would be very easy task if we start with finding the first normal form then we need to find the second third and fourth as well but if we start with bcnf and if a given relation is in bcnf we can say that it is in third second as well as first but here I'll be starting starting with finding the first normal form second third and bcnf because I want to explain about each and every normal form but whenever you get question always start with bcnf so that you can find out that if a given relation is in bcnf or not if it fails then go for third normal form if it also fails then go for second and if it also fails then go for first but it's better to start with the highest normal form so let's start so the first step is we have to find the candidate key for the given relation so to find the candidate key first we note the on all the attributes which is present in our table then we iterate to the functional dependency and we check if the dependent and determinant is present if both of dependent and determinant is present here we can discard the dependent because it can eventually be determined so BC is the dependent and a is the determinant both are present so we can discard BC so we are left with a now coming to this functional dependency C is the dependent B is the determinant neither of them is present coming to this B is the dependent a is the determinant a is present but B is not present so we can ignore this now coming to this AB is the determinant C is the dependent a is present but B and C are not present coming to this a is the dependent and B is the determinant a is present but B is not present so a is a possible candidate key so let me find the closure of a so closure of a gives me a provides me a then a gives me B then a gives me C and then okay so a b c are all the attributes which are present in our table so a closure give me all the attributes which are present in our table now we have to see that if a lies in the right hand side of any of the functional dependency so we can see that a lies here so we have to take the closure of b as well because it could also be a possible candidate key so let me find the B closure so B can determine itself B can determine C and B can also determine a so B closure can also determine all the attributes and proper subset of them are neither a Super Key or a candidate key so we can say that A and B are candidate keys so candidate key here are A and B now in the second step we have to find the prime and non-prime attributes Prime are the one which are the part of candidate key so we'll mention AB here non- Prime are the one which are not the part of candidate key that is C now third is we have to check for the normal forms one by one according to their rule again I'm reiterating that we should always start checking from the bcnf because that is the highest normal form and if a given relation is in bcnf it is in third second and first normal form so all always check from the highest normal form here I'm starting with the lowest normal form because I want to discuss on each and every normal forms and show you that how we can say that a given relation is in given normal form so let's start with the first normal form so a relation is in first normal form if it contains only Atomic values that is there shouldn't be any multivalued attributes like a attribute which is having multiple values you can say phone number so if a attribute is having multiple values we say that this particular relation is not in first normal form but here since we are using a standard relational model so we can say that it is already in first normal form now coming to the second normal form so second normal form a relation is in second normal form if it is in first normal form that is already true and every non-prime attribute is fully functional dependent on every candidate key of the relation that is there shouldn't be any partial dependency and when partial dependency occurs when LHS is a proper subset of candidate key and rhs is a non-prime attribute so if this holds true we can say that the given Rel has partial dependency so it's not in second normal form so we have a and b as the candidate key if we take the proper subset of A and B that is five basically empty because there is no proper subset of A and B now coming to the rhs is a non-prime attribute so we know that C and D are the non-prime attributes so let's check for each and every functional dependency the very first one is a determines BC since a is a candidate key and not a part of candidate key we can say there is no partial dependency because if it fails here we don't need to check for the second condition now coming to B determine c b is also a candidate key not a proper subset of candidate key so no partial dependency coming to Third a is again a candidate key so we don't need to check for the second condition coming to Fourth AB both are a candidate key so no partial dependency as AB is a combination of candidate key it is acting as a Super Key now coming to B determine a again B is a candidate key it's not a proper subset of candidate key so we can say there is no partial dependency so we can say that the given relation is in second normal form we didn't check for the second rule because the first rule was holding false for each and every functional dependency and if there is a false and if we do and with any of the false it gives me false now coming to the third normal form so a relation is in third normal form if it is in second normal form and there is no transitive dependency which is existing so we have to check that if there is a relation X determines y x is a Super Key or a candidate key or Y is a prime Matrix rute if this is true we can say that the given relation is in third normal form so this particular rule basically says there shouldn't be any transitive dependency so let's check for each and every functional dependency so here a determines BC a is a candidate key so no transitive dependency B determines C B is a candidate key no transitive dependency a determines B A is a candidate key no transitive dependency a determines C so A and B both are candidate keys and when we put a and b together that is a Super Key because candidate key is a minimal super key so A and B together acts as a Super Key and X is a Super Key so there is no transitive dependency here as a is the combination of candidate Keys it's super key now coming to B determine a b is again a candidate key so there is no transitive dependency so we can say that this particular relation is also in third normal form now coming to the fourth one that is bcnf so a relation is told to be in bcnf if it follows the third normal form and for every functional dependency X determines y x is so super key or you can say candidate key so let's see for each and every functional dependency so a determine BC a is a candidate key so it is in bcnf B determine C B is a candidate key a determine B A is a candidate key A B is a Super Key and B determine C B is a candidate key so we can say that the given relation is in bcnf as well so the highest normal form for the given relation is bcnf so we have already learned about normalization types of normal forms and much more things now let's see that how we can normalize a table so in normalization we generally break or decompose the table into two or more subtables now how would that decomposition happen how would we know that we have to decompose the table and how we should decompose the table so let's see the steps to normalize a table so the very first step is we have to write down all the attributes of the table candidate key Prime and non-prime attributes and start analyzing with the functional dependency so in the question we would be provided with a relation and their functional dependency we have to find out the candidate R key prime non- prime attributes and we have to start analyzing the functional dependency so the second step is for the table to be in first normal form table should have Atomic that is indivisible or you can say single values and have a primary key for the table to be in second normal form there shouldn't be any partial dependency so when partial dependency occurs is when LHS is a proper subset of candidate key and rhs is a non- prime attribute this should be false for the table to be in second normal form now coming to the fourth step that is for the table to be in third normal form there shouldn't be any transitive dependency that is LHS must be a candidate key or rhs should be a prime attribute that should be holding true now coming to the fifth step for a table to be in bcnf LHS must be a candidate key or Super Key now coming to the sixth step if it fa at any of these steps like second third fourth and fifth where we are finding about first second third and bcnf then we have to decompose the table on a common attribute which is a candidate key so that the decomposition is lossless that is data is not lost so let's understand from a practice problem where we have provided a relation we have been provided with a functional dependency and we have to see that if the table is normalized or not if the table is normalized we will check for the higher normal forms if it's not normalized we will decompose it and then again check for the higher normal form so we will check till BC enough that if the table is normalized or not so the step one is we have to find the candidate key Prime attribute non-prime attribute and start analyzing the function dependency so to find the candidate key first we will note down all the attributes of the given relation then we will iterate with the function dependency and we will see if the dependent and determinant are present or not if both of them are present then we can discard the dependent because it can be determined so the first functional dependency is a determine b b is the dependent and a is the determinant both are present so we can discard the dependent so now we are left with e CD Now now coming to the next functional dependency B determines C so C is the dependent and B is the determinant but B is not present here so we have to leave this functional dependency now coming to where C determines D so D is also present here and C is also present here so we can discard D now we are left with AC so from here you can see that a determine B and B determine C so can we say that a will also determine C from the rule of transitivity so we can see that a determines C and A and C both are present here so we can discard the dependent that is C so we are left with a and if we take the closure of a it will give me a it will give me b b will give me C and C will give me D so we can see that a is a candidate key and now we have to see that if a is present at the right hand side of any of the functional attributes no it's not present so we can see that a is the candidate key so here candidate key is a prime attribute are the one which are part of candidate key so a is here and non Prime are the one which are not a part of candidate key so that is BCD so in step two since we have find out the candidate key Prime and non-prime attribute we have to check for the first normal form so since we are assuming that our relation is in standard relational model it is already in first normal form so here we can see all the values are Atomic only because it is a standard relational model now coming to the step three that is we have to find for the second normal form so to check for the second normal form we have to check that if there is any partial dependency present or not if it's present then it's not in second normal form if it's not present then we can say it's in second normal form so coming to the first FAL dependency that is a determine B A is already a candidate key and the proper subset of candidate key is pi so we can say that there is no partial dependency as a is not a proper subset of candidate key and B is non- prank so false and true gives us false there is no partial dependency now coming to B determine C so B is not a proper subset of candidate key and coming to C so C is also a non-prime attribute so LHS must be a proper subset of candidate key and rhs should be a non-prime attribute so this is true but this is false so false and true gives us false coming to the third functional dependency C is not the proper subset of candidate key so we can say LHS is not a proper subset of candidate key D is non-prime attribute so this is false and this is true so false and true gives us false so this one is also not having any partial dependency so we can see that the given relation is in second normal form now let's check for the third normal form so for third normal form there shouldn't be any transitive dependency that is LHS must be a candidate key or rhs must be a prime attribute this should be true so let's check so first is LHS is LHS a candidate key yes so we can see there is no transitive dependency as LHS is a candidate key and this is an or so this is true so we don't need to check for this now coming to this functional dependency is LHS a candidate key no so we have to check if rhs is a prime attribute is rhs a prime attribute no so we can see there is a transitive dependency as LHS is also not a candidate key and rhs is non- primat attribute now coming to this particular dependency is LHS a candidate key no is rhs a prime attribute no so we can say there is a transitive dependency here as well now we have found out that there are two transitive dependencies which are present in two functional dependency so we have to decompose this table so we have to decompose this table a b c d into three tables because here we can see that there are two functional dependency in which there is a translative dependency so one would be divided in such a way that there is BC and one would be divided in such a way that there is CD and the rest would be left here so that is a determine B so it will be divided into a b c and CD so now the relation is divided into three AB BC CD where BC and CD were having some transitive dependency before decomposition and ab was not having any transitive dependency now the table is divided into three relation that is R1 R2 and R3 now again we have to check for the third normal form so coming to this relation this was already in third normal form so we don't need to check because a determined me was not having any transitive dependency coming to this relation where we have BC where B is determining C so we can say that for this particular relation B is acting as a candidate key as B is determining C so now B is candidate key and according to thought normal form LHS must be a candidate key so we can say that now there is no transitive dependency coming to this table that is CD now in this particular table C determines C is the functional dependency and now C is determining D so we can say that c is acting as a candidate key so we can say now candidate key is present in LHS so there is no transitive dependency so after decomposition the transitive dependency is removed now we have to check for bcnf but now since the table is decomposed into three tables so we have to check for three of them individually so let's check for the relation one that is AB so a will determine b and a is the candidate key here so since a is the candidate key or super key so R1 is in vcnf now coming to the second relation that is BC where B is acting as a candidate key and the functional dependency is b determin c so since B is a candidate key or super key so R2 is in bcnf because according to bcnf LHS must be a candidate key or Super Key now coming to Third relation CD where C determines D is a functional dependency and C is acting as a candidate key so we can say that this one is also in pcnf so now all decomposed relations R1 R2 R3 are in bcnf so in this way we normalize relation or a table we generally decompose the table or relation whenever we find out that it's not following a certain normal form now consider that if you are given two functional dependency set set a or you can say relation a is having some functional dependency relation B is also having some functional dependency and we have to check the functional dependency which is of relation a and relation B are equivalent or not or have a equivalence relationship or not so for that we use the concept of equivalence of functional dependency so what is functional dependency a functional dependency X determines Y where X is the determinant and Y is the dependent and Y is determined by X holds on a relation R if for any two tles T1 and T2 in R so consider there is a relation R which is having some rows or you can say tle which is T1 and T2 so consider if there is any attribute X and if T1 of X is equal to T2 of X then for any attribute y T1 of Y would be equal to T2 of Y so according to the functional dependency it basically help us to know the dependencies among different attributes of a table what is the determinant what is the dependent how it is getting determined and much more things now coming to the equivalence of functional dependency so when we can say that two functional dependency set are equivalent so two set of functional dependency consider first set is f second set is G are equivalent if the following conditions hold so the first condition is f implies G basically it means F covers G so every functional dependency in G can be derived from F so consider if there are two functional dependency of f and g and there is a functional dependency in F that can be derived in G then we say that this is equivalent and same implies with G as well so G implies F every functional dependency in F can be derived from G so every functional dependency in F can also be derived by G then we can say that these two relations are equivalent so if both conditions are true then we say that f and g are equivalent so consider there are two relation f and g which is having some functional dependency consider here it is a determine B and here it is B determine a so in the equivalence we check that if this particular functional dependency and this particular functional dependency are equivalent among each other so for that first we will see that if F can cover G then we will see that if G can cover F and if both of them holds true then we can say it's equivalent we will understand more from the example so these are the steps on how we can find if two functional dependencies are equivalent or not so the step one is we have to compute the closure of both of the sets so consider if there are two sets of relation f and g so we have to find the closure of f and g basically all the attribute closure which is present there now the step two is we have to ensure that every functional dependency in set one is in set two closure so consider if we have two relation f and g and we have functional dependency as a determine B and here we have the dependency as B determine a so we'll take the closure for them so for f closure we will have the closure of A and B and for G closure again we'll have the closure of A and B so what is the closure of these two so now here a closure give us a and b and here B closure gives us only B coming to this functional dependency a closure gives us a only and B closure gives us b and a so we have found out the closure of both of the sets now we have to find that every functional dependency in set one present in set two closure so what we will do is we have to see that if this a determine B holds true for this particular equivalence relation so what we will do is we will go to the G closure and we will see for a A can only determine a a can't determine B so we can say that this particular relation are not equivalent consider if this hold it true then we have to see that every functional dependency in set two is having in set one closure so for every functional dependency in set two that is a and b we have to see this particular closure which is present in the last set and then we have to see that if this functional dependency is holding true or not if you're getting confused don't get confused we will see for this from a example now the step four is if both the subset check pass then set one and set two are equivalent because the set one functional dependency is holding true for set two closure and set two two functional dependencies is holding true for set one closure so let's understand from an example consider that there are two functional dependency one is f and one is G and these are the functional dependency a determines b b determines C and in the G it is a determines C and A determine B so we will follow the steps and then we will compute if these are equivalent or not so the step one is we have to compute the closure of both the sides so here we can see that there are three attributes a b and c and here also there are three attributes a b and c so we will we will find the closure of all the attributes in F so first we'll find the a closure so a can determine B so there will be a B and B can determine C so it will be C so a closure will be having a b c now coming to B closure B can determine itself so b b can also determine C so it will be BC now coming to C closure so there is nothing with C is determining so it will only determine itself so it will have these now coming to the closure of G attributes so a closure will have a then a can determine C A can determine B now coming to B closure B closure will be only having B because there is no b as a determinant coming to C closure C can only determine itself because there is no c as a determinant so we have found out the closure for a b c for all these two sets now we have to ensure that every functional dependency in set one is in set two closure so consider for this functional dependency a determines B we have to come to set two and we have to see that if in particular a closure do we get b or not then we we can say that this particular one is equivalent so let's see so in a closure we can get b so we can say that this particular dependency holds true for the equivalence relation now coming to B determine C so we have to check for the determinant that is B so we have to check the B closure here so here B closure is only having b b closure is not having C so we can say that this particular functional dependency is not holding true for this case so for now we can say that every functional dependency in set one is not present in set two closure now let's see the the reverse so here the functional dependencies are a determine C and A determine B the determinant here are a so we have to check for a is a determining C yes we can see that a is determining C so this one is holding true is a determining B yes we can say a is determining B so this these both are holding true but this one is not holding true so we can say that f and g are not equivalent because B determines C is not implied or covered by G so what we have to do is first we have to find the closure then we have to do a cross so what we have to do is if we have to check for any functional dependency in G we have to check for the closure of F and if we have to check for any functional dependency in F we have to check the closure for G so that we can conclude that these relations are equivalent now what is this minimal cover of functional dependency and why do we even need it so it is a simplified version of the original set of functional dependencies it help us to remove redundant functional dependency so consider if we have a functional depend tendy a determine b b determine C and A determine C so here we can see from the rule of transitivity we can conclude that a will determine C so do we need to have a redundant functional dependency which tell us about this no right so we can remove the Redundant functional dependency because from the existing functional dependency this particular functional dependency could be derived so it help us to remove the Redundant functional dependency coming to the second point it reduces the complexity of functional dependency so lesser the functional dependency the complexity is also reduced so we can say that it help us in reducing the complexity third is it ensures that there are no unnecessary dependencies which can lead to anomalies in database operations such as insertion deletion and updation so from this functional dependency consider a determines B if a is a candidate key Super Key then there are very less anomalies but if a is a non-prime attribute then there are many anomalies which are introduced in the database so it ensures that there is no unnecessary dependencies and the anomalies are also lesser now let's see that how we can find the minimal cover of a functional dependency so Step One is we have to decompose the functional dependency that is rhs if there is X determines AB then it can be return as X determine a and X determine B so that we can know that which all functional dependencies are redundant so from the rule of decomposition we have learned that if in rhs there are two set of attributes or a combination of attributes that can be decomposed in a X determine a and then X determine B but it doesn't happens with the LHS because LHS is a part of candidate key or key which determines this particular attribute dependent can be broken down but determinant can't be broken because that combination is determining this particular dependent so we can broke the dependent so here A and B is broken into X determine a and X determine B now coming to step two so we have to remove the Redundant functional dependency now how we will find that which fun functional dependency is redundant so first is make a new functional dependency set excluding the one you feel is redundant so consider if there are three functional dependencies which are present A B and C for now you can consider this or you can consider this as well a determine b b determine C and C determine D so what we will do is consider right now I'm feeling that this particular functional dependency is redundant so what I'll do is I'll make a new functional dependency set which will be having only B determine C and C determine D now second step I'll find the closure of LHS from the rest of the functional dependency and see if it determines all the attributes of table so what I'll do is I'll find the attribute closure of this particular LHS a closure and then I'll see if this is getting determined from these particular functional dependency which is existing if this happens then we can exclude this functional dependency if this a closure does not have the attribute which is getting determine then we can say that this one is not redundant so if yes you can remove that if no then jump to the next one so now we can go to B determine C we can make a new functional set which is having a determine B and C determine D and then we can take the closure of B and we can see that if from these two functional dependency B is determining C or not if it is happening then we can exclude this if it is not happening then we have to include this now the step three is we have to remove the unnecessary attributes from LHS so earlier we removed the unnecessary attribute or you can say we have decomposed the attributes of rhs now we have to also remove the unnecessary attributes from LHS consider if there is AB determining X so we have to see that if any of the attribute is unnecessary like this alone can determine all the attributes in the functional dependency so this could be ignored if this alone can determine all the attributes in the given functional dependency set then this could be ignored so we have to see that if the determinant is a Super Key it can be reduced to a candidate key so consider if AB is a Super Key so candidate key is basically a minimal version of super key so we have to see that if this version of Super Key can be minimal and we can get the candidate key so we can see that if B alone can determine all the attribute or if a alone can determine all the attribute and then we can remove this so candidate key is basically a minimal super key so let's understand from an example so consider we have to find the minimal cover of the functional dependency a determines BC B determines C A determine B A determine C so let's follow the step so the step one is we have to decompose the functional dependency rhs basically we have to decompose the dependent where if x is determining a we can write it as X determine a and X determine B so let's see if there is any combination which is present in the rhs so yes here we can see that a is determining b c so we can write it as a determine B A determine C now coming to here so rhs is not having two attributes so we can skip this coming to here dependent is not having two attributes we can skip this coming here there are two attributes or combination of attributes but it is present in LHS and we have to see for rhs so rhs there is single attribute so now the functional dependency set would be a determine B A determine c b determine C A determine b and a b determine C but here you can see that a determine B A determine B is occurring twice so we can remove that as well because this is just a duplicate functional dependency so the final one will be a determine B A determines c b determines C and A determines C so the step two is we have to remove the Redundant functional dependency for this we have to make a new functional dependency set excluding the one you feel is redundant so we'll go one by one first we feel that a determine B is redundant so I'll write it a determine B for now we are thinking is redundant so we'll make a functional dependency which would be excluding this so if I exclude this I'll be left with a determine c b determine C and A B determine C this is my new functional dependency set now we have to find the closure of LHS from the rest of the functional dependency and see if determines all the attributes of table if if yes you can remove that if no jump to the next one so first we will find the closure for this LHS that is a so a closure here will give me a determine C so c will be there and nothing else a can determine itself so a closure is giving me a and C but since a closure does not have all the attributes we shouldn't discard this since a closure is not giving me all the attributes we shouldn't discard this because right now it's not identifying all the attribute now we are considering a determine C is the Redundant one so we will have this a determine C so the new functional dependency set would be a determine b b determine C and A B determine C now we have to find the closure for the LHS that is a determines C so a closure now here a will be giving me a a will be giving me B and B will be giving me c so now a closure is determining all the attributes which is present in the table so a determine C can also be determined from a determine B and B determine C so since a closure is having all the attributes and we can discard this so we will be discarding this from the final functional dependency set so now we are left with only a determine b b determine C and A determine C now coming to Third B determine C so now for B determine C since we have discarded this we will be only having two functional dependency a determine b and a determine C so a determine B A determine C now we'll take the closure of the LHS for the functional dependency which we are discarding so B closure will be having only B so since B closure does not have all the attributes we shouldn't discard this if B closure would be having all the attributes then it would definitely Define but since it is not having all the attributes this particular dependency can't be discarded so we will not discard this coming to the final functional dependency that is AB determine C so for ab determine C we will discard this and we will have new functional dependency set as a determine B and B determine C so a determine b b determine C we are having so we'll take the closure of LHS that is AB and ab closure gives me a B and B will give me c so since a closure is having all the attributes we can discard this as well so we will discard this also from the final result so from the final result we can see a determine B and B determine C is the minimal cover for this particular functional dependency so in this way we find the minimal cover so here you can see that we don't need to go to step three because we have to remove unnecessary attributes from LHS but in LHS there is only one attribute so we don't need to go for step three where we are removing unnecessary attri so first we will start with re- revising some older Concepts what older Concepts we are revising here are databases database management system types of databases now why SQL is coming into picture and much more things so firstly we will start with databases what is database so database is basically collection of data now consider an example of a student database now what do you think in this student DB what all things would be there so there would be data related to the student right so there are some data which is related to the student now coming to dbms what is dbms dbm is a software application which is used to manage our data so in the student database there are some data which is present now what if I want to do some manipulation in that data consider that I am a student my age is given there as 19 but tomorrow is my birthday and I am being 20 tomorrow so I want to update my age from 19 to 20 so what I'll do I'll do some manipulation I'll do some query which will be helpful in updating that data into the student database so dbms comes into picture there now it's understanding how a user interact with DB or you can say database DB is a short form which is used for database and I would be using DB uh so much time in the video so please don't get confused DB stands for database now here is a user now user wants to interact with database but would the user be able to interact with database directly just think once no it won't be able to interact with database directly because again as you have learned that if we want to interact with computer or if you want to interact with machine we need to interact with them using the binary language or the binary codes but we don't know that for a what is the binary code or for B what is the binary code so we choose a programming language we do the coding in that programming language and that is then compiled to the machine code and which is understandable by the computer so in the same way if a user want to interact with database he or she would be needing a software layer or a software application which would be helpful in decoding all the things student want to do a query or a user want to do a query and that would be finally executed on the database so basically user goes through a software lay or you can say a software application is being used so a software layer here is being used so user add some queries in that software layer or in that software application and then from that software application user can query into database do some manipulation and different things so here what happens is there is a user he or she will use a software application now this software application may be using some programming language language and using this programming language we will make some queries which will give us the required data or update or insert the required data now coming to databases so database is a collection of data databases are of two types first is relational database and second is non- relational database in SQL mostly we deal with the relational databases that is databases which is in a tabular format so relational databases are databases which use tables to store the data so relational database mostly use the tular format to store all the data if there is a student database that would be having a table which would be having all the details about the student now the uh examples of relational databases are MySQL Oracle and Maria DV coming to non- relational databases so non- relational databases are also called as no SQL databases or no SQL databases now what is non-relational databases data databases in which data is not stored in tables so in this database that is relational database data is stored in form of tables but in non- relational databases data is not stored in form of tables there might be some hashing techniques or there might be some storage optimization techniques using which the data is being stored and the most famous example of this is mongod DV now we are starting with SQL but the very first question be why we are reading SQL or why we are knowing about SQL what is the use of SQL so we need a language to interact with databases as I told that there is a user he or she is using a software application and using that software application he or she is interacting with database now this software application would be needing a language you can see a programming language using which we can query into the database so we need a language to interact with databases so we use SQL to interact with databases and do some crud that is create read update and delete operations on the database now you might have heard the term MySQL and right now you're hearing the term SQL so what is the basic difference between MySQL and SQL so let's understand MySQL is basically a relational database management system that uses SQL as a query language so what is MySQL MySQL is basically a relational database management system that is a software application which use SQL that is structured query language for querying purpose so SQL is a programming language which databases and MySQL is a software or rbbs which is using SQL as a query language so this is the basic difference between my SQL and SQL now in the further videos we will be knowing about the history of SQL how we can make queries using SQL how we can install SQL in our system how we can make some connections how we can install the server how we can install the workbench and much more things so firstly we'll start with the history of SQL where this SQL originate from who made this and you have also heard the word SQL many people call it SQL many people call it SQL so what is the reason behind that so esql was originated in 1970s from IBM research on relational databases so basically on relational databases there is a quering language which is used or there is a programming language which is used that is called as SQL which is structured query language now it started as SQL so SQL stands for structured English query language so earlier it was named as SQL which stands for Structured English query language but later it was renamed to squl due to some trademark issues so many people call it as SQL many people call it as SQL sometimes I also call it as SQL sometimes I also call it as SQL so both are the same things it was just because of trademark issue the name was changed so earlier the name was Structured English query language and now the name is structured query language now let's start with what is SQL so SQL stands for structured query language SQL is a programming language that is used to communicate and manipulate data in the databases so let's consider an example of a student database so there is a college in college there are many students now consider that one students get shifted from one place to another so he or she may needs to update their address in the student database so that updating or that manipulation of data is done by SQL now SQL helps user in performing the crowd operation that is create read update and delete operations on database now let's understand how SQL actually help us so SQL allows user to perform a variety of task related to databases now the very first point is retrieving of the data extracting precise information from a database through queries so one can use certain queries to extract some information about a student so what happens in class if we usually go to the class teacher or the class Monitor and we ask that uh tell me the details about a person whose role number is 42 I want all the details of that particular person so he or she would be able to give me but on a very large scale if I ask someone to give me all the details about an employee whose employee ID is 1 2 3 so he or she needs to make a query into the database and retrieve all the information and provide it to me now the second one is manipulation of data or manipulating the data so adding modifying or removing records within a database can be also done bya SQL so adding some data consider a new student take an admission so his or her data needs to be added modifying consider a student is shifted from one place to another so his or her address need to be modified and deletion consider a students leave the college so his or her data needs to be deleted now the third point is defining the data so creating and adjusting the structure of database including tables views and indexes so there might be a possibility that we need to create some new databases we need to adjust some values or some views or indexes in the database so that also we can do via SQL now the fourth and final one is controlling the data so managing databases access by granting or revoking permissions so again if there is a database of student you can't allow anyone to make a query into the student details there might be some permission which would be given to a person that yes you can at least access the student data you can at least access the teacher data so there are some permissions which is provided to an individual and there are some permissions which is also removed from a particular individual when he or she leaves the institution so all these controlling of data is also done bya SQL so this was all about what is SQL how SQL helps us in the next particular video we would be starting with the installation of SQL first we would install the server and then we will install the visual tool which would be really helpful for us to make the queries so before starting with the MySQL server and MySQL workbench I want you guys to know a basic concept so in the last video I told that there is a user and if the user wants to interact with database he or she will use a software application using which he or she can interact with the database and in this software application he or she can internally use a language which could be very easy for a user to interact with the database now in the last video we talked about SQL so SQL is a query language that is called a structured query language which is helpful in crud operations that is create read update and delete operations in the databases and we also talked about MySQL so MySQL is a software or we can say MySQL is a relational database management system relational basically means whenever the data is stored in the form of tables so MySQL is a relational database management system which uses SQL that is structured query language for quering purpose now uh have you ever thought okay we are talking about the user who is making some calls to the DB but where this DB is stored where the DB physical existence lies so DB is somehow stored in servers so the first MySQL server here comes into the picture so basically we need a server where our databases would be stored so firstly we will install the MySQL server so database server where data is stored managed and exist so we will first start with installation of MySQL server and then we will proceed ahead with the MySQL workbench now what is MySQL workbench so my isql workbench is a visual tool which is used for database design development Administration and management it provides a user interface to interact with the my school server now we have set up a server in that server our database like now how we can make some queries where we can write the queries so we need a UI to write that queries right so there are two ways in which we can do so so first is command line whenever we have uh established a server connection we can use the command line to make databases do some cred operations on the databases but if you want a very neat and clean way in a UI you are giving queries and you can see that tables are being created some data are being inserted so we can use a visual tool for the same so in this particular video we would be learning about the MySQL server and MySQL workbench like all about the installation process of the same so firstly we will install the server so first what we need to do is we will go to the myos schol official website that is https wwm.com then we will go to the downloads then we will select the MySQL Community version at the bottom of the page we will choose the MySQL Community server we'll select the version and we will click on download and then we will follow the instruction set the root password why this root password we need to set so whenever you establishing a connection on the server you need to provide a password for that connection so whenever you are making a new connection like you are making 10 or 11 new connections so you need to give that password to the server for you to make a new connection so this password would be asked while creating a new connection so let's see from the website itself so this is the website for the MySQL so here you can see you can find this downloads tab you can click on this download tab and here at the very bottom you can see MySQL Community GPU downloads that is the community version download now here you can find the community server as well and the workbench as well the server and the UI where we will be writing the queries so we will first click on the myl community server right now I'm using a Mac OS if you're using Windows the configurations May differ so you can see the configuration of your system and download accordingly so I'll just download this uh DMG file so I'll just click on download and I'll click on Note H just start my download so it will just start my download earlier I have already downloaded this high schol server so uh this is the procedure you need to do and then when you are about to install it it will ask you for some permissions you can just accept that permissions and you can provide a root password which would be helpful when you are establishing a connection and in the same way you can go back and you can download this mys workbench so here also you can give the operating system and OS version and here you can click the download button so both of these things would be downloaded on your personal laptop or computers so this is the way we can install MySQL server and MySQL workbench on our personal PCS so I already have mys workbench let me just show you how it looks so here you can see that myol workbench has open here we can put some queries uh here are some Management in stance and Performance Tools here you can see context help and Snippets and here you can see the action response and everything from the next video we will try to create some databases and tables inside the databases so SQL commands are divided into different categories based on their functionalities so according to the functionality SQL commands are divided into different categories let's have a look so the first one is DQ commands that is data query language commands so from the word itself it's very clear data query language so any command which is helping us to do some data query that commands comes into the dql commands the second one is data manipulation language commands so any command which is helping me to do some data manipulation like inserting some data deleting some data updating some data in the database so all these commands are helping me to do some data manipulation so that is why they are coming under the DML commands the third one is data definition language commands so again from the word s it's very clear data definition so any command which is helping me to define the data to define the structure of the database or to define the schema of the database all those commands comes into the ddl commands the fourth one is data control language commands now again from the word itself it's very clear data control so any commands which is helping me to give some control to the data like accessing the data revoking the permission from accessing the data or granting the permission to access the data all those commands comes into the DCL command the fifth and final one is transaction control language commands that is TCL commands so any commands which help me during a transaction like consider that I'm withdrawing money from ATM or I'm making a online payment so all those commands which comes into picture while doing a transaction in a database comes into the TCL commands so these were all the categories of commands SQL commands based on their functionalities now let's look about each and every command in detail so the very first command is data query language commands that is dql command now dql is used to retrieve the data from the database so any command which is help helping us to fetch the data from the database or retrieve the data from the database that comes into the decoil command here you can see command which is used is Select so consider that I want to get the details or I want to fetch the details of a student who is in class two whose role number is three so uh what I'll do I'll make a database query in which I'll use the select command and in that I can Fitch all the details about a student who is in class two and having a r number as three so this select command would help me to fetch the data or to get the data from the database the second one is data manipulation that is DML command so ml is used to manipulate data stored in the database so again the same example consider that there is a college database in that college a student takes an admission so we will insert the data of that particular student consider that that student is promoted from semester 1 to semester 2 so that we need to update in the database so updates comes into picture there and consider that student has graduated from the college so we need to delete the data of student from our database College database so we will be using this delete command for the deletion purpose the third one is data definition language command that is ddl command now ddl is used to define the structure and the schema of the database so the schema of the database basically means like whenever we provide a schema of the database we give an overview like what is the database name what all attributes or columns are there in the database what is the primary key and Etc things so we basically provides a structure or a schema of the database so the commands which we can use is create create usually helps us to create tables or create databases alter command alter command is used to modify an existing database or modify an existing table drop command drop command is basically Ally used to delete the entire table from the database now trunk it trunet command doesn't delete the entire table it deletes the data which is present in the table and rename command is used to rename a table so all these commands comes into the ddl command which is indirectly or directly affecting the schema or the structure of the database the fourth one is DCL commands that is data control language commands now DCL deals with the control and security of data within the database commands are Grant and revoke so Grant we are granting some permission revoke we are revoking some permission so again we are taking the example of the same College database now in the college database there would be student table there would be teachers table there would be some staff table there would be principal director all those details in that particular tables now I being a student I can't see the teacher details or the staff details I can only see the details about myself teacher can only see the details about the student so we Grant some permission or some security is there so that we can control the access of data so teacher can access the student data student himself can himself or herself can access only their data so such type of commands which help in that purpose like controlling of the data or security of the data comes under the DCL that is granting and revoking the final command is the TCL command that is transaction control language command now TCL is used to manage transaction within a database the commands which comes into picture here are commit roll back and save point now why this TCL command comes into picture so you have seen most of the time that whenever we are doing an online transaction we do the online transaction we pay the money we give our pin the money is somehow deducted from our bank account but the transaction is not completed so in that case what happens is can money is credited back to your bank account within three or four working days so all those things all that transaction which is happening inside a database the commands which are helping us to do that transactions comes under that TCL commands so this was all about the types of SQL command in this particular video I hope you like this video I thought to start with the creation of database But first you need to know what does this create command means in which category does this create command lies so that is why I thought to cover these types of SQL commands first and then proceed ahead with other videos so before starting let's re- revise some older topics as well so what is database database is basically the collection of data now database is divided into two types first is the relational database and second is the non- relational database now what is relational database relational database are the databases in which the data is stored in the form of tables and all the tables have some relation between them there is some interrelated data what is the non- relational databases so a database in which the data is not stored in the form of table rather it is stored in the form of key value pairs or something else so this is the basic difference between relational and non relational database as of now we would be dealing with the relational databases so consider a scenario there is a user now user wants to interact with the database how a user can interact with a database so user can't directly interact with database what a user can do is a user can interact to the database using a software so so using a software a user can interact with database now what this software is called this software is called as dbms that is database management system so any software which is helping us to manage our data is called as database management system now I told that we are dealing with the relational databases so we would be using rdbms that is relational database management system for our purpose so example of rdbms is MySQL which we would be using as a software now we have got the software but we need to make some queries into the database like if I want to do some Insertion I want to do some deletion I want to do some update in the values so I have to tell the database okay this is the value I want to insert this is the value I need to update this is the value I need to delete so for that purpose we use SQL that is structured query language so it is basically a programming language programming language which help us to make some queries into the database like consider that there is a new student which is coming into my college so all the details about that particular student would be inserted into the database consider that there is a student who has left the college so all the particular data related to that student would be deleted from the college consider that there is a student who has got his address changed so that particular field would also be updated so all these operation like the manipulation operations like insertion updation deletion we can do using this SQL programming language now coming to the database design so what is this database design and how is this important so consider a use case that I have been given that I have to design a database for student as of now I know that I have to design a database for student but do I know that if I designed a database for the student what would be the tables inside that particular database as of now I only know that there is a student database I have to create that student database but do I know that what all tables would be there in that particular database what all domain constraints would be there for that particular table domain constraints you can understand in this way okay there is a field called as name there is a field called as age so age would be taking some integer values name would be only taking character values age is something which should never be null so some rules should be there so I don't know that what constraint should be there then again I don't know about the primary of foreign keys so Keys help us to uniquely identify records in a table so I can uniquely identify a record for a particular person in a table so I don't know about all these things the constraint the keys the tables only thing which I know is I have to create a database so in the database design what we do is whenever we are given a use case that we have to create a database we are also provided with the schemas so what is schema so whenever we are giving any table name or the database name followed by all the attributes which is present there we called it a schema so here you can see that there is a student schema right with all the attributes which is there is student name student role number here you can also see that there is a teacher schema which is having all the details about the table name that is teacher the characteristics or the attributes that is table name and uh teacher ID and here you can see that we are taking the database as school so we have taken the database as school school DB we have taken as of now in the school DB there are two tables first is the student table second is the teacher table now when we create a table there are multiple number of rows and multiple number of columns so these are called as rows and these are called as columns but in databases we call columns as attributes or characteristics so basically attributes are the characteristics of a particular entity like consider that there is a student database now that particular student database is having some of the tables like student course or student address details so there are two tables in that student database course and address details so both of them would be having some of the attributes like course is having some of the characteristics such as course ID course name like all the things about the course and the address would also be having all the details about the address like Street uh flat number pin code everything right so all the attributes or the characteristics which is present we insert in the column and all the particular record about that particular student is inserted in the rows so basically these all are the characteristics or the attributes and this is the table name so you can see s name student name student role number teacher name and teacher ID are part of attributes or the characteristics of that particular entity or that particular table so now we are clear that we have been given a college database or a school database in which there are two tabl student and teacher now in that student table there are some attributes in that teacher table there are some attributes so we have done a basic designing of our database now let's uh move ahead with the creation of database so whenever we are creating a database we create a database in a server so what we do is first we establish a server connection to create a database so once we have established a server connection we can create databases now the first question which will arise in your mind is can we create only one database in one server or we can create multiple database in one server so the answer is we can create multiple databases in a single server uh with a different name yeah so the name shouldn't be same with a different name we can create multiple databases in a single server so consider that this is a server one in that server one there are two databases database 1 and database 2 so there are two databases which is created as of now in server one now in databases also the second question is in a database can we create only one table or multiple table so the answer is we can create multiple tables in a single database so you can see that there is a school database in that particular School database there is table one which is Course and there is table two which is fees and in this patient dat Hospital database there is a table which is patient so uh in a single server there could be multiple databases in a single M uh single database there could be multiple tables so this happens while creation of database so when you are you have established a connection in your server you can go ahead and create the database in that particular database you can create some tables as well so there is no restriction on the amount of creation of databases or the amount of creation of tables now let's start with the creation of database so there are some steps which we should follow while creating a database let's have a look on them so the first step is choose chose a dbms that is choose a software as I told earlier that if a user needs to interact with database he or she needs a software so we would be choosing a software as I told earlier that we are using relational databases or we are dealing with relational databases as of now so we will be choosing a rdbms and that is my school for now now the second one is connect to the server using command line or a graphical user interface so now I have installed the software I have the software now I need to establish a connection in the server where I would be making the databases so that I can do in two way either I can go to the command line and establish a connection or I can establish a connection using GUI or user interface which I am having in my PC so uh mostly the command line is not covered here so you can go ahead and have a look on all the Articles which is presented how on the command line we can establish a server connection we can create a database or insert the database the commands remain the same but just there are two three more steps extra so the third one is create a new database so there is a command we need to execute for creating a new database in the UI or the user interface which we have downloaded for executing all the SQL queries now the fourth one is once the database is created you can use the use statement to create tables in the databases so again going back as I told that in a server there could be multiple databases so how the server would know that if I want to create a table in which particular database I want to create a table so for that case what we do is if we use the use statement use followed by the database name once I execute this particular query my server will be known that okay in this particular database now what all actions are being done is being done in that particular database like insertion deletion updation anything so I can use the use statement to tell the server as of now I'm working on this particular database and the fifth and the last step is create tables and insert data so before moving forward with the SQL commands I just want to let you know that SQL commands are super easy to understand because SQL commands are very similar to the English statements consider that uh if you want someone to create a picture of yours like create a drawing of yours what you will say can you please create a drawing of mine so you say create a drawing right in the same way if you want to create a database in SQL you say create database followed by the database name so it's just like the simple English language which we use in dat today life and whenever I say someone that create a drawing of myself or create a picture of myself I'll just end the statement with a full stop here we end the statement with the semicolon so it's just like a statement which is ended by a semicolon so to tell the server or to tell the uh database that this particular command is being executed and the next command is in next line or whenever the next semicolon is found out so we use the create database statement to create a new database so we generally use the create database followed by the database name statement to create a new database as I told again it's very similar to the English language like cre a database so create database these commands are not case sensitive so what does this case sensitive means you consider that if I am executing create database followed by a database name consider student if I am executing this command in upper case and if I am executing this command the same command uh what is happening okay so create database student so if I am executing this command in upper case or in lower case both will give me the same result so this is not case sensitive like we can either use the smaller cases letters or the upper cases letters so for now let's go with the upper cases letter because there would be a notion we would be following for all the particular queries so let's follow the uppercase one so we will use this particular command that is create database database name so let's go to our UI and let's learn that how we can create a database so I'll be opening my MySQL workbench so here you can see in MySQL workbench by default there is a connection which is established but I want you all to learn that how we we can establish a new connection as well so we'll just click on this plus icon once the plus icon is created we'll give the connection name just give it as SQL for now and here we can give the password which was asked while we were installing the my schol workbench and server so I'll just provide the password here and once I have provided the password I can click on okay so you can see a new server connection established here so once I'll open This Server Connection now here you can see that there are many tools which is present so let me just familiarize you with all the tools which is present and then we will go ahead with the query so here you can see that there is an Administration Tab and here you can see that there are some of the instances and management status which is present so this basically deals with our server connection if you want to make a new connection if you want to end that connection and other things so there is a schema tab in this schema tab you would be seeing all the databases you have created all the tables you have created the primary key the foreign key the constraint everything in the schema tab by default you can see that there is a sys schema which is already present this is of MySQL workbench so basically the database administrators have this already created to uh see the performance how the performance is going there is a performance schema also present here which is present in this sys so we'll not touch this sys we'll just create a new database here and here you can see that there are some icons so this icon would help you to create a new SQL file so if you want all the queries to be in new file or if you are creating new file or if you are creating multiple databases or working with multiple databases you can create new files and work on that particular database here you can see that there are two run commands like if I am writing any query I have to run it right so for that particular query if I have to run it there are two tools so the first tool runs everything which is present in the file like if there are 16 or 17 SQL statements it will execute all the SQL statements which is present and the second one is run the selected one so if I select any of the SQL statement that only would be executed not the entire file so let's start with our first query to create a database so I'll simply give the statement create database followed by the database name as of now let's give it school and I'll just execute this line on selecting it and I can use this particular run button so here you can see that there is a success so a database with the name school is created but you won't be able to to see it here so to see it here you have to do a refresh and once you refresh you can see the database with the name school is created as of now there is no tables in that particular database because I have just created a database so in this way we can create a database now U if you see here I have also written it also to avoid errors we can use this command create database if not exist database name so why is this needed create database if not exist so let me just show you so I have written this command create database School a database with the name school is already created into my system consider I'm running this command again so what it's showing it's showing me an error that a database with the name school already exist so what we do just to avoid errors because errors are something which is like nightmare for developers so just to avoid errors what we do is we put a additional check that if not exist so create a database if it does not exist so we will use this query create database if not exist and we'll give the database name now if you run the same query you will see that you are not getting an error rather you are getting a warning message that already this particular database exist so if you want to create tables in that particular database you can use that particular database so right now we are not seeing an error we are just seeing a warning so it's better to add this additional check while creating a database he create a database Whenever there is no existing database with the same name so create a database if not exist database name so this was all about the creation of database now let's see how we can delete the database so we use the drop database statement to delete a database dropping a database means deleting the entire database including all the tables so dropping a database means you consider that you have a database of student and in this particular student database you have two tables first is the course table student course table and second is the student address table so once you use this drop database command so what will happen it will delete the entire database including the all the tables which is present in this particular database all the data which is present in this particular tables so it will delete the entire database all the objects all the values which is present in that database so this command is not usually suggested and if you are a developer I would surely say that please avoid these commands and don't ever do this command or don't ever execute this command in the prod database because like that would be a nightmare for you so always avoid this command but since we want to know how we can delete our database this command is necessary to delete our database so the dropping means deleting the entire database including all the tables in the data all the other objects within it so drop is a ddl command that is data definition language command now these commands are not case sensitive as I told for the create command so the command for dropping a database is drop database followed by the database name so let's see about this command as well so as of now I have already created a database with the name school so let me just delete this database so I'll do drop database followed by the name followed by the database name just this so you can see that we have got a success so this database is deleted from our schema so here you can see that the school database does not exist now again in this particular slide you would be also seeing that I have given also to avoid errors so do we get errors while deleting the database as well so the answer is yes there could be a possibility that in the server there are many database you forgot that which database you have deleted and again you are running the same command to delete that particular database which is already deleted so it will give me an error so what we do is we write the command drop database if exist so the database should be existing only then delete the database if the database is not existing do nothing so drop database if exist the database name so let me just show you again so I have already deleted the school database let me again just delete the school database because I'm not aware that what all databases are there in my server so by mistake I have deleted the school database and again I'm deleting the school database so if I again execute this command you can see I'm getting an error because this particular database I have deleted just 2 minutes back but I don't remember that I have already deleted this database that this could happen like if you have deleted a database one week ago and after one week you don't remember that if I have deleted that database or not and you run the same query or consider that you can also run the same query for a database which is not existing in the schema so as of now consider that there is a teacher database which is not existing in the schema and if I run this particular command also it will show me an error because this particular database does not exist in the schema So to avoid such errors what we do is we include this if exist Clause so that it will check that delete the database if it exist in the server so we will use this for the school only we will use the same command so drop database if exist and here I give the command as school so let me just run it again so here you can see that we are not getting an error rather we are getting a warning message that the student database does not exist it's already deleted so in some way we are avoiding the errors we are just getting a warning messages now let's see that how we can use the database so as I told that once we have created the database there could be many databases in the server so so I have to tell the server that if I have to create any tables or I have to insert any data which database I am inserting to so for that we will be using the use statement so use followed by the database name we use the use statement to use a database these commands are not case sensitive and the command is used followed by the database name so let's see so again what I'll do is I'll create a database let's create a database college so I'll execute this statement so it's success I'll just do a Refresh on so here here I can see a college database which is created now what I'll do is okay I'll do just use and I'll give the database name that is college followed by a semicolon and once I run this query this query is also executed with a success so now in this database only we can perform all the actions so this is the use of U statement now let's see the next command now let's see how we can see the database so showing a database we use show databases statement to see all the databases which is present in the server and as I told earlier that in the server there could be multiple databases now I want to see that what all databases are there in my server so what I'll do I'll just execute this show databases statement which will show me all the databases which is present on my server so let's use this command as well so we will just do show data bases and I'll just execute this command and here you can see that all the databases which is present in my schema is shown now again as I told that sys performance schema is something which is related to mySQL workbench the DB administrator use it to analyze the performance and everything but here you can see the database which we created College is already shown here this was all about creation deletion seeing all the databases in the server in the next video we would be doing the same for the tables like creating the tables inserting the data into the tables deleting the tables and seeing all the data which is present into the table the last video what we did was we created a database database followed by the database name let's consider school and then we used the database to create the tables or insert the data now third step we do the table creation so let's see how we can do the table creation so we use the create table statement to create the table in a DB so once we have used the database we have told the server that this is the database in which I want to create tables I'll use this create table statement to create the tables in the database now what is the command to create the same so we give the create table followed by the table name and then we provide all the columns which should be there in the table so again the table is a intersection of rows and column so columns tell me what all value should be there for a particular record okay so consider for now we are taking the school database now in the school database consider that there is a table student so for that student table there would be some columns there should be some rows so student may have characteristics such as student ID student name student age so there are some characteristics or attributes which the student would be having so we will provide all the attributes all the characteristics in the column now the second one is data type so whenever we create a variable in programming what we do is we give the data type followed by the variable name like this in a so it tells me that a would only accept integer values in the same way we provide the data type for all the particular columns in the database because there could be a possibility that if I don't provide the data type for S ID someone can insert XY Z into the Sid which is not a valid uh student ID someone can insert 1 2 3 4 XYZ at the rate which is again not a valid student ID so I tell that this particular student ID will only be accepting values of the particular data type so we provide the data type now the third thing is constraint so what is constraint so constraint is basically a set of rules which we provide to our attributes so basically whenever we are giving all the attributes we provide that these are the constraints which are there for that particular attribute now in the constraint there could be many things like not null so if there is a not null which is provided to any of the attribute value or any of the column that particular column couldn't have any null values it needs to have some value so why this constraints are given because it helps us to eliminate the duplicate data and the data which is misleading or incorrect data so the insertion of incorrect or duplicate data is hindered whenever we provide the constraints so creating a table so create is a ddl command that is a data definition language command now here the example is given you can give create table followed by the table name let's consider a table name as employ here you can provide the First Column that is employee ID the data type that is int and then the constraint that is primary key again the second column name followed by the data type that is Ware the third column which is salary and followed by the data type that is int again uh constraints are not something which is mandatory to provide you can provide or you you can't provide like it totally depends on you if you want like some unique values some Nal values in the particular col again right now you won't be understanding these terms like primary key what is Vare what is in so as of now just forget all these just remember that to create a table we give the command create table followed by table name and we provide all the columns which should be there in that particular table so let's just execute this command in our SQL work so this is my SQL workbench let me just start with creating a database then I will create the table inside that particular database so let's just execute the command to create a database so it would be create database followed by the database name let me give it school a missing okay so let's just execute this command so you can see that this command is successful let me just refresh it here so a database with the name school is created now I'll just let the server know that I am creating all the datas in this particular database so I'll just use school and I'll just execute this so now use school is executed now I can create all the tables all the data in this particular database now let's start with the creation of table so I'll just give create table follow by table name let's just take the table name as course and then I'll provide all the columns which should be there in the course so let's take C ID horse ID and I'll provide the value as int let's take course name and I will provide the value as Vare and I'll give the limit for the number of characters that should be 50 so let's just execute the statement so here I have created a table with the name course which is having columns such as C ID and having the data type as int uh course name having the value as Vare so let me just execute this so you can see that there is a successful execution of this particular statement when you will do a refresh here in the tables you can see that one table with the name course is created and the columns which is present in this table is C ID and C name which is the course ID and course name so course ID would only be taking integer values and course name would only be taking the character values so this is the way we create the table in our databases now since we have created the tables in the database is how we can insert the values in that tables so inserting values into the table so insert is a DML command that is a data manipulation language command now we use this particular command to insert the values into the database so that is insert into we'll give the table name followed by all the columns in which manner we want to insert the values so if you have provided a data like Raj here so it will insert Raj here and if you have provided the address as pun it will insert pun here so if you don't provide the column name it will insert in a sequential manner into the all the columns but if you want to insert in like a different fashion like if you want to insert the first value into the column one and the second value into the column three and the third value into the column two so you need to provide the column names here so uh in whatever fashion you are providing the column names it will insert the values in that particular fashion only and here you can give the values value one value till value n now here we can see the example so here we are inserting values into the employee table we have created so we'll use insert into the table name employee and then we will give all the columns employee ID employee name employee salary and then we will provide all the values we need to insert like one Raj the salary is 1,200 the employee ID is two the name is Rahul the salary is 1100 the employee ID is three the name is re and the salary is 1100 so in this way you can insert the values into the particular table and you can provide all the values which needs to be inserted let's see how we can insert the values into our course table which we have created just now so we'll just execute the command insert into we'll provide the table name that is course and then we will provide all the columns first one is C ID second one is is C name and then we will provide all the values to be inserted so the first value let's insert the course ID as one and the course name as physics let's insert the second ID as two and the course name as maths and let's just execute this okay just there is a typo so it would be values so let's just run this command so once you run this command you can see this success so all the values have been inserted with the first course ID is one the subject name as physics the second course ID is two and the course name is maths so in this way we can insert the data into our table now let's see how we can see all the values which have been inserted into our table so we created the database we used the database in that particular database we created tables we inserted some data into that particular table now we will be seeing that how we can see all the values in that particular table so to see all the specific values of a column we can either use the select statement followed by the column from the table name so it would be select the column name from and the table name so the table name is and the column name is employee ID so if I want to see only the employee ID details I can just use the select the column name from the table name and here to see all the values from the entire table we can use select star from employee so whenever I'll execute this statement select star from employ it will show me all the records which is present in the table so let's use this particular statement so what I'll do is I'll use select star from and I'll give the table name as horse and I'll just execute this so here you can see that a table is created with C ID course ID and course name where the values are one for physics two for mats so in this way you can see all the values which is inserted into your table now as I told that you can see all the databases which is present in your server in the same way we can see all the tables which is present in our database so there is a command to see all the tables which is present into our database so we can use show followed by tables so show tables will provide me all the tables which is present in the database so let's see how we can see all the tables which is present in our datab datase so we'll just use this show followed by tables and we'll just end it with a semicolon so in this way we can see all the tables which is present in our current database so here you can see that there is only one table which is present in our schema that is course so in this way we can see all the tables which is present in our database so here we are taking an example of Instagram database so let's create a database for Instagram in this we would create the database we would create the table we would insert the data into the table and we'll see all the data which we have inserted into the table so before moving forward let's understand some basic concepts so there is a server on which we generally create our databases now on a server there could be multiple databases like DB1 db2 tilted dbn here DB stands for database now in this particular database there could be multiple tables like T1 T2 T3 in this also T4 T5 and this as well till TM so what we understood is in a single server there could be multiple databases and in a single database there could be multiple tables so the very first step is create a database so we'll execute this particular query that is create database now here we are using this if not exist Clause why this Clause is needed there could be a possibility that in a server since there are many databases there could be a possibility that two databases is having a same name or we are giving the same name and a database with the name already exist so in this way we will get an error so just to avoid that error and get a warning message instead we use this if not exist Clause so it basically makes sure that create a database only if that particular database does not exist on our server so this is create database if not exist and followed by the database name so let's just see our MySQL workbench and there we would be executing this query and learning how we can Implement all the things practically and create a database followed by table and then see all the data which is present in the table so this is the my school workbench UI here you can see all the output and here we giveing the query so it is create database if not exist and then we'll give the database name that is Instagram e and we'll just execute this particular query so once I execute this query I can see a success here but in this schema tyab I can't see my database so for that I'll just do a refresh all so once I do the refresh all I can see a database with the name Instagram DB is already created for now there are no tables as we have not created any tables but a database with the name Instagram DB is created now let's see the next step so in the step two we would be using the database to create the tables now coming to the same example so in a server there could be multiple databases so a server needs to know that if we are creating table in which particular database we are creating a table so to let the server know we use this use statement so we'll give the use followed by the database name that right now I using this particular database for creation of tables insertion of data into the tables and much more things so let's just go to the SQL workbench so here we'll be giving the command use followed by the database name that is Instagram DB and we'll just execute this particular query so here you can see the success so as of now whatever tables we create would be created in this Instagram DP or database now let's see the step three so the step three is the creation of tables into the database so here is the query for the creation of tables as of now we are taking two tables the first table is the user table and the second table is the post table now in this particular query we give create table again here also we give an additional check what if a table with the name post already exist so create table if not exist user so if there is no table with the name user only then create a table which is named as users so now here we provide all the columns or you can call it as attributes or the characteris of the table so the First Column is user ID the second column is username and the third column is email then we provide all the data types that what all values this particular column can hold so here we are giving the integer value here we are giving the Vare or we can say character values and here also we are giving the character values so in the third argument we usually provide the constraint so here we are saying that this particular user ID is now having a key constraint that is a primary key constraint that means this particular column user ID Can Only Hold unique values and not null values so a primary key is a key which helps help us to uniquely identify all the records in a table so if a column is declared as a primary key so it can't hold any duplicate values it should always be unique and it should always be not another in the same way we are creating the table for the post the query is almost same here we have column as post ID user ID and caption with the data type as int here also int and here we are giving as Vare and here also we are giving a primary key constraint for the Post edited the post ID will always be unique the user ID will always be unique so let's just execute it in the SQL workbench so let me just copy this command and execute it in the SQL workbench so I'll go here and I'll just paste it and I'll just do a run so here you can see a success is shown in the output window but here right now you can't see the table so for that you have to do a refresh all so once you do the refresh all it will show a table with the name user which is created which is having columns as user ID username and email now let's do for the second table as well we will just copy this and we'll just paste it here and we'll just run the query so here also you can see a success report that a table with the name post is created now we'll just do a refresh all here as well so here you can see a table with the name post having column such as post ID user ID and caption is created now in the next step we would be inserting values in this table so in the step four we would be inserting the values into the table so this is the query we need to execute to insert the values into the user as well as the post table so we'll just give insert into followed by the table name that is users and then we will provide all the columns that is user ID username and email and then we will provide the values so so one would be inserted into the user ID re would be inserted into the username and email would be inserted ABC gmail.com so it follows the same pattern which is given here the insertion so in the same way the two and three would also be inserted and in the same way for the Post also insert into table name that is post then we'll provide all the columns that is post ID user ID and caption and here in the values we will provide all the values which we need to insert so let's just execute this query in the S work so let me just copy it and paste it here and then I'll just execute this particular query so here you can see a success report is generated again I'll do just a refresh all so as the data is inserted we can't see it here there's a special command to see all the data which is present in the table which we will see in the step five so let's do the same for the Post table as well and I'll just run this query so you can see the success so as of now my database is created I've created two tables inside my database that is users and post I've inserted some data into the users and post table now let's see if all the data is inserted into the table or not so in the step five you can see all the tables that is present in the the database so first we'll give the query use followed by the database name which will help the server to know that the next command which is being executed is being executed for the Instagram TB and then we'll give the show tables command so let's see so I'll just give use followed by the database name that is Instagram DV and I'll just give a semicolon so the execution is successful and then I'll leave show tables so this command will show all the tables which is present in inside this database so I'll just execute this query so here you can see that there are two tables post and users which is present in this particular database so in the step six we would be fetching all the values in a specified table so for the first table we would be executing select star from users and for the second table we would be using select star from post so select star help us to fetch all the records which is present in the table so let's go to the myl workbench and execute this queries so we'll be just executing select star then from and then we'll give the first table name that is users and I'll just execute this query so here you can see that all the data which we have inserted is here that is 1 2 3 RTI Raj rul and the email and when we want to fet the data for the other table we will be using the same statement just we will replace the users with the post so select star from and here I'll be given post so let me just execute this query so here you can see 10 1 102 10 03 and all the caption and user ID is present so in this way we create a database we use the database then we create the table in that particular database we insert the values in that particular table again we see all the tables which is present in our database and then we see all the data which is present in both the tables so before let starting with the data types in SQL let's just understand what was the need of introducing data types in SQL so consider an example of a company so in a company there could be many employees E1 E2 till till till so there could be n number of employees as of now I have told that I have to feed the data for each and every employee in the employee table which is having columns or attributes as name and age so I'll start feeding the data of each and every employee in this particular EMP employee table so consider the first employee is Amit who is having an age of 27 the second employee is Raj who is having an age of 28 so first what I'll do I'll feed the data for Amit so I'll feed the name as Amit and age is 27 now in the second I'll feed the data for Raj but while feeding the data for Raj by mistakenly I feeded 28 in the name and Raj in the age so there was a reverse order in which I feeded the data so what will happen whenever I make query give me the name of all the employees whose age is 27 so what will happen in the 8th it will find out there is one employee with the age 27 but the second employee is having Raj which is not a valid value which should be there in age like no one's age can be R right so this is kind of an incorrect data so it causes a data inconsistency so what we do whenever we do a creation of table so the command for creation of table is create table followed by table name which would be employee as of now and whenever we will create the columns for the same so what we will do is we will give name and then we will provide the data type that this particular type of data a column can store store that is the main reason of introducing data type so we will give name then we'll give Vare so Vare is basically used for storing the string values and when we will give for H we will provide it as int so it will make sure that name is only having Vare values and H is only having integer values so whenever we will insert data into the table while insertion only if we feed wrong data in the columns it will give me an error so data types are basically used to specify the type of data that a column can store so there are numerous types of data types first is the numeric second is the character or string third is the date and time fourth is the Boolean and fifth is the binary now in the numeric data types there are many type of data types integer small end big end decimal float double so these all data types help us to store the integer values or the numeric values in the character Instinct there are three data types character Vare and text these all help us to store the string value or the character values in the date and time there is date time date time time stamp so all these data types are used on the basis of their use case but this help us to store the datea and time in Boolean there is a Boolean to store the true or false values in binary there is a binary where binary block to store the binary values that could be zero or one so let's see about each and every data type in detail and let's understand that where the use cases of such data types occurs so first start with the numeric data type so the very first one is int so it is used for storing whole numbers without decimal points so whenever we want to store a whole number without a decimal point consider the age so we always say that age of a person is either 16 years or 17 years we never say the age is 16.5 years right so whenever we want to store a data which is a whole number we use this integer value now it is having this particular the range in which all the data could be stored and it is a signed integer what does the signed integer means it means that it can also store the positive as well as the negative values so the positive and negative values both can be stored in this particular int data type second one is B in so big in is also used for storing whole numbers but it store large whole numbers so the limit here was less but here the limit gradually increases because it store large whole numbers so whenever we want to store a value which is very large right so we use this big so the third one is float so float is basically used for storing the decimal numbers so whenever we want to store the value which is in decimals we use the float data type now the fourth one is double so the double is used for storing decimal numbers but again in the float the range was less but in double the range becomes double so if you want to store a value like 17.5 you can store it in float but if you want to store a value like 17.55 5555555 so you can store that value in double so it gives more precise value and it gives a less precised value so if you want to store in a less precised value or in you can say a roundoff number you can store in float but if you want a very precise value you can store it in double so basically float and double both are used to store decimal values int and begin both are used to store the whole number values it's just the range which gets increased so the fifth one is decimal decimal is basically used to store some values in which we provide that this is the Precision I want in that particular value this is the scale to which the value should be so it is used for exact numeric representation p is the Precision and S is the scale so if I want a value which is having four digits after the decimal so it can help me to get that particular digit so here you can see there is a command for creating a table and providing each and every data type for each and every column in the table so in this way we provide the data type while giving the column name while creating the table so whenever we are creating the table we will provide the column name and then we will provide the data type like what value the column would be holding so by default all the numeric data types can have negative as well as positive values as I told about the int so int can have positive as well as negative values this restrict the range so if we know there is only positive values which is stored we use the unsigned attribute so what we do is we consider age so we know that age would always be a positive value it won't be minus 17 years right so I know that age would only hold positive values it can't hold negative values so what I'll do whenever I'll Define the age or whenever I'll provide the data type for age I'll just put this unsigned attribute after int which will help us to increase the range so what it will do it will increase the range to 256 characters so earlier the range was very less but now my range is increased to 256 characters for example salary can never be negative or age so salary or age can never be negative so we provide this attribute unsend with SA is that this particular ID or this particular age or this particular salary would be only holding positive values it can't hold any negative values so it help us to eliminate that negative range and add it to the positive range now let's see about the character data type so there are three data types here c v cat and text so let's see about the C data type so car basically means character so whenever we are storing any characters we can use this C data type now here n basically means the size of string so whatever would be the size of string we would be giving here so whenever we want to store any fixed length of character string we use this car so the range is from 0 to 255 character that is a to z values whenever we want to store we can use this car data type now what does this fixed length of character means so whenever I'm giving a column name as SC what it will do is he consider that I given the size as 50 so it will allocate or Reserve 50 blocks of memory so 50 blocks of memory is allocated or reserved for name so whenever the first name is feeded consider the first name is Raj so I feeded Raj so what will happen that these memory spaces are wasted consider for second name RTI so I feeded re now these memory spaces are being wasted so these all memory spaces are being wasted and it's not utilized so it's kind of not a good practice to use car rather we use Vare now what is Vare so V here basically stands for variable and car basically stands for character so whenever we want to store variable character or variable length character strings we use Vare now what will happen Vare so consider that I've given name Vare 50 so whenever I give name Vare 50 it will not go ahead and allocate a fixed length of 50 characters what it will do whenever I'll insert the value consider re so it will go ahead and it will insert re and all the rest spaces wouldn't be occupied so it basically inserts the value in a dynamic fashion so the memory allocation is very good because none of the blocks of memory is wasted but in C data type what happens that because it is a fixed length it will go ahead and allocate 50 blocks of memory and in that 50 blocks of memory even if you are using four blocks the is 46 blocks are wasted so that is why we usually prefer using vat because it is for variable character string so whenever we will provide any value it will take up that particular value and rest all blocks wouldn't be allocated so the memory consumption is good the third one is text so variable length character scks with no specified limit here you want you have to give a limit here also you have to give a limit because it can hold only 0 to 255 characters but if you want to store more characters or there is no limit to the character string you are storing so you can use the text so this is the way we can use this Vare care or text data type create table table name followed by the column name and here we can provide the data type so the third one is date time data types here the first one is date the the second one is time and the third one is date time or time stamp date is basically used for storing the date values in this format that is year month and day the second one is time which is used for storing time values that is hour minutes and seconds the third one is date time or time stamp which is used for storing date and time values so it will give year month and day followed by the hours minutes and seconds so the command which we can use is create table table name and then we can give this created time stamp as the column name and here we can provide the data type as time stamp so it will store the values in the format of year month day followed by the time that is R minute seconds so this is basically used for storing date and time values so the fourth one is Boolean data type in this Boolean data type there is only one data type that is Boolean so Boolean is basically used to store a true or false value so consider that you are a person you want to see that if you are eligible for Vote or not so if you are greater than 18 you are eligible to vote if you are less than 18 you are not eligible to vote so you are making a column is eligible to vote or not so in that particular column there would be only true or false values so in that particular use casee we can use this Boolean data type so in the same way we can use this create table followed by table name and when we are giving the column or when we are defining the column we can Define the data type as Boolean so the fifth one is the binary data type now in this binary data type there are three data types binary V binary and blob that is binary large object so the binary is basically used for storing any fixed length of binary data so binary data is zero or one so whenever I'll give binary and the limit as one so it will only store zero or 1 in the same way V binary basically variable binary is used for storing variable length of B binary data it is the same what we saw for car and Vare so car will only store fixed length character data Vare will store variable length of character data so even if I'm giving binary and the limit as two I can store 0 1 0 0 1 0 1 1 like without even considering about the memory what is being used now the third one is blob that is binary large object it is used for storing large amounts of binary data it is also variable length so the command which we use is while creating the table create table table name we give the the column name data and here we provide blob that is binary large object which could help us to store the large amount of binary data so this was all about this video I hope you had a good understanding about the data types in depth and now you understood that why while creating the table we were using the data types what are the use case of data type where a particular data type can be used so before starting with keys in SQL let us understand what keys exactly is so here I have taken an example of employee table so in this employee table there are some columns such as ID name age phone number which are also called as attributes for the characteristics of the table and here I have feeded some data in the rows which is also called as tle in dbms now here I feeded the data for employee 1 employee 2 and employee three so ID is one name is Raj age is 27 phone number is given ID is two name is Rahul age is 27 phone number is given ID is three name is again Raj age is 27 and the phone number is given now there should be a unique identifier or a unique attribute which could help me to identify records in a table or can distinguish between two records or two tles in a table so basically employee one and employee 2 can be distinguished on a single factor that is called as key so keys are basically a unique identifiers or we can call it as attribute or a set of attributes which help us to uniquely identify records in a table so in this particular table ID is something which is unique for every employee like 1 2 3 so we can't see some duplicate values it is unique for every employ and it can help me to distinguish between two employee like employee is Raj so the ID is one this for the second Raj the ID is three so it can help me identify records in a table now the second attribute is name so as you can see name is not unique for everyone two persons can have a same name here also you can see employee one is also having name as raj employee 3 is also having name as raj for the age also age can be again same for different people phone number phone number can be different for different people so here we can see ID is also serving as a key as well as phone number is also serving as a key so ID and phone number can help us to uniquely identify records in a table now coming to types of keys so there are two types of key first one is primary key so a primary key is a unique identifier for each record in a table so primary key is basically a unique identifier for each record in a table so here the key was ID and phone number now you will see that according to your definition key and primary key both sound similar so what is the basic difference between key is and primary key so a primary key is always unique plus null so what does this n null means so null means that particular column or that particular attribute cannot have null values so it cannot accommodate null values so here if we see id id cannot be null for any person because ID is something which is generated whenever the person is onboarded into the company so ID can never be null and ID will always be unique for a person so we can say ID is a the primary key but coming to phone number so phone number would be there for each and every person but there could be a possibility that a person doesn't have any phone number or there could be a possibility that the person's phone number is not updated in the database but still the person is onboarded so phone number is not something which would be always not null it can have null values at the very start of the onboarding maybe the values are updated after the onboarding but it can have null values so as of now ID is something which is unique as well as not null so it is unique for each and every employee and it can't accommodate null values so that is why it is called as primary key it ensures that each row can be uniquely identified and exist within the table now what is foreign key a foreign key is a field in a table that refers to the primary key of another table it establishes a relationship between the tables so as of now we are dealing with the relational databases so what is database database is basically collection of data in relational databases we deal with the interrelated data now in database there could be many table so there could be table one table two table three but as of now we are dealing with the relational databases so all these tables should have a link or should have a relationship between them so to establish this link foreign key help us because in this particular table and in this particular table we establish a link using the foreign key so foreign key help us to establish the link between the two tables so let us see about primary key and foreign key in more depth so primary key a primary key is a key which uniquely identifies record in a table as I told earlier it ensures that each tle or record can be uniquely identified within the table so there is a ID which is serving as a primary key which uniquely identify each records or tles in the table table so it is always unique plus not null so as I told earlier that primary key is something which would be always unique and not null it can't have duplicate values it can't have null values so ID would be always uh unique for each and every employee who has onboarded in our company and ID won't be null because if any employe is getting onboarded in our company the ID would be generated for that particular employee so this is primary key so the second key is the foreign key so a foreign key is a field in a table that refers to the primary key in another table so basically a key or a field which refers to the primary key in another table is called as foreign key so consider an example there are two tables student and subject this is having all the details about student this is having all the details about the subject opted by the student so it is having R number name and Hometown and it is also having R number name and subject now this particular table is having R number as the primary key and this is the student table so the student table wants to have a relationship with the subject table because the subject table tells that what subject a particular student has opted so we want a relationship between the subject and the student table so what we do is ke to establish the relationship the foreign key basically refers to the primary key in another table so in this particular table the primary key is RW number so let's see that is there any attribute which is kind of referencing to this particular table so that will act as a foreign key so here you can see there is a roll number which is kind of referencing to the same R number which is present in the student table so this will be acting as a foreign key which will be referencing or which would be taking values from the student R number so in this way we can establish a relationship between two tables so this R number is called as foreign key and this R number is called as primary key this is called as foreign key because this is referencing to the primary key of another table so a relationship between two tables are established on the basis of the foreign key now there are two things here you can see base or reference table and referencing table so let's understand what is this base table and what is this referencing table so reference table is a table which is having a primary key so whenever there is a table which is having a primary key that is called as reference table or base because this is the table which is referenced by another table which is having foreign key so that is why this is called as referenced or the base table second table is the referencing table so this is called as referencing table because this is having a foreign key and it references to another table so table which is having primary key is called as reference table a table which is having a foreign key is called as referencing table so the very first question which would be coming to your mind would be why we are reading about constraints data types and keys at the first place so do you remember I told you a query for creating a table in the very start of the videos that was create table followed by the table name and then we used to provide the column name then the data type of the column and then the constraint of the column so as of now you would know that why we need to provide the data type so that any inconsistent or irrelevant data is not feeded into our system now the second one was the constraint which was kind of optional you can provide constraints to a column and you can't provide constraint to a column it totally depends on your use case so constraints basically Define the rules or the condition that must be satisfied by the data in the table so consider that when you are creating a table so at that particular time you are giving a column name you are providing the data type and you are providing a constraint considered primary key so this particular column would be a primary key or this particular column would have not Nal values so we are giving this constraint so whenever we would be inserting data if we insert data which doesn't follow this rule or condition would be discarded and we would be seeing an error that this particular data can't be inserted because right now it is violating the constraint which we have given so basically whenever we are giving a rule or a condition to that particular column or that particular attribute in a table we call it as constraint so common constraint include uniqueness of the data nullability check and the default value Etc now here are some constraints which is present so the very first constraint is the unique constraint so unique constraint basically ensures that a value in a column are unique across the table so Bic whenever we are providing this unique constraint to any of the column in the table it ensures that that particular column would only hold unique values it can't hold any value which is duplicated or duplicate values can't be stored in that particular column so let's see from the myol workbench there we would be creating a database and then we would be Crea multiple tables in which we would be seeing about each and every constraint so this is my myle workbench let us first create a database so we would be creating a database for colge so we would just give this command create database college and we would just execute it so we have executed it has done successfully let's just refresh it here and here we can see a college database which is created as of now there are no tables we would be making new tables for every constraint so let's just tell the server that right now I am using this particular database to make the tables so I'll just give use followed by the database name and then I'll execute this query so this is also successful now all the tables which would be created would be created inside this college database now let's first see the unique constraint example so we would be right now seeing the unique constraint example we'll just comment this out and let's create a table so we'll create a table student in which we would be giving columns so while creating the tables always make sure that the table name is always in small letters it can't be in capital letters it will throw an error so we are creating a table student in this particular table we are giving some columns so as of now we are giving phone number and we would provide a data type for this and we will provide the constraint that is unique so we'll just execute this query and here you can see a success so once I'll refresh it I can see a table with the name student is created which is having a column phone number now since I have given this unique constraint to this phone number column so it shouldn't hold any duplicate values so let's just insert some values into this table and check if the unique constraint is working or not so we'll just do insert into and then we'll give the table name that is student followed by the column name that would be phone number so I'll just copy this I'll paste it here and then we would be inserting the values so let's just insert some values so let's insert the first value as 1 2 3 Let's insert the second value as 456 and let's insert the third value again as 1 2 3 to check that if the unique constraint is working or not so let me just execute this query so here you can see that we are getting an error that duplicate entry 1 to 3 for the key student phone number so we are giving the duplicate entry and since we have given that it will be only holding unique values this particular statement can't be executed so what I'll do I'll just remove this duplicate value and then I'll try running this query so I've removed the duplicate value vales all the values are unique let's just run this query again so once I run the query after removing the duplicate values you can see that I'm getting a success so basically unique is somehow making sure that my particular table doesn't have any duplicated values now let's see for the next constraint that is the notal constraint so notnull constraint basically ensures a column cannot have null value so basically notnull constraint makes sure that if a column is provided it shouldn't have or it shouldn't store any of the null values so let's see about this also in the MySQL workbench so let's see for the not null constraint so we'll just mention notal constraint and we'll just comment this out and we'll just create a new table so let's create a table student one and let's just leave some columns for the student one so let's give the First Column as eight which would be holding integer values and as of now we are not giving any constraint to the AG let's give another as doll number and it would be also storing integer values and let's just put the Nal constraint here so let's just execute this query and you can see a success let me just refresh it here so here you can see a new table with the name student fun is created now let's just insert some values into the table so we just do insert into student one and here I'll only give one column name so that in the next column null value is automatically inserted so I'll just give here age and I'll just give the values and here I'll give the value as 27 and I'll just execute this query so what I have done is right now I am only inserting values into the age I am not inserting any value into the r number so let me just execute this query so here you can see I'm getting an error field R number does not have a default value so it says that right now field R number doesn't have any default value so it is getting a null value and as of now you have told that raw number can't have null values so this query can't be executed but when I make this age comma RW number and when I insert some value for the RW number as well consider one and when I run this query it would be successfully run because right now I am giving a value to that R number column so it is not getting any null values so this is how we can ensure the Nal constraint let's see about the other constraints as well so the third constraint in the list is the check constraint so check constraint basically enforces a condition to be true for each row so basically check constraint is kind of like you are making a check that if you're inserting any values into this particular column there is a check which should be true so consider that if you are inserting age of a person in a particular table so you have to only insert the age of a person if he or she is greater than 18 so that you can make a voter ID for that particular person so let's see from the myl workbench so this would be for the check constraint I'll just comment it out so let's again create a new table create table student 3 and we'll just provide the columns so we'll just give age but will have integer values and we'll just give a check constraint to check age is greater than 180 only then insert the values otherwise don't insert the Valu so we'll just execute this particular query so query is executed here if you do a refresh you can see a student 3 is also created now in this student 3 table we will insert the values so insert into student three and here we will give the column name that is H and now we will insert the values so let's insert so uh here I have given the constraint that the age should always be greater than 18 let's give a age Which is less than 18 let's give the age as 13 and let's just execute this query to see that if the constraint is working or not so I'm executing the query so here you can see that we are getting an error that the check constraint is present on the student three age column so we can't uh insert a value Which is less than 18 and let's run the same query after giving a age which is greater than 18 21 let's just run this query so you can see a success that this particular age is already inserted because this is greater than 18 so this is how the check constraint work let's see for the next constraint so the next constraint here is the default constraint so default constraint basically provides a default value for a column if no value is specified so basically you remember that in the last example when we were inserting the data into the columns if you're not providing any column name null is automatically being inserted in that particular column so if we want to avoid that null if we want a default value which should be there consider that you are a student and you are studying at a school if you forget to provide that school name in your database that would automatically take the school name so let's just uh see about the default constraint as well so default constraint basically means if no value is provided the default value will be automatically inserted so let's see for the default constraint so we'll just create a table so create table student 5 and here we would be giving the column names so let's just give the First Column name as school name and it will take Vare values because it is a character string so it will just take 50 characters and here I'll provide this default constant so default would be XYZ like as of now I'm taking the school name as Xyz and then I be providing next column as AG which would be taking integer values so let's just execute this query so you can see that we are getting a success now let's just insert some values into this table so insert into student 5 and then we will provide the column so as of now I'm not not providing the school name because uh it will uh by default take the default value so I'm just giving for age so I'll just give age and in the values I'll just give 19 for now we just execute this query so you can see that I'm getting a success on executing this query so let me just see if the table is taking the default value or not so I'll just do select star from student 5 so it will show all the data which is present in student 5 and I'll just execute this query so here you can see that the school name XY Z is already taken by default so I haven't entered any of the school name it has taken the school name by default so this is how the default constraint works so if we give the default constraint it will take the default value if none of the value is specified if you specify any value it will take that value but if you don't specify any value it will take the default value so the next constraint is the primary key constraint now primary key constraint basically enforces the uniqueness of values in one or more columns so a primary key basically enforces the uniqueness that two tles can be identified uniquely Whenever there is a primary key present so primary key is always unique as well as Nal both the unique and the Nal constraint together is applied in the primary key so when you are providing any column as primary key it is by default unique It Is by default normal so let's see about the primary key so this would be primary key constraint so we will see for two things first is the uniqueness and second is the not so first we'll create a table again so we will create table and we'll give the name as student six uh don't get confused that why I am creating so many tables it's just for you to have a proper understanding about each and every constraint in depth so that is why I'm creating multiple tables we can do this in the same table as well but again that could be a bit confusing so let's just give some column so we'll give H int and then we will give roll number int and let's just give roll number as primary key and let's just execute this query so you can see we are getting a success for this query now let's just insert the values so first we will see if it is holding the uniqueness or not and second we will see that all the values are not null so let's see for the uniqueness first so we'll just insert into again we'll give the table name that is student six and then we will provide the column so the First Column is age and the second column is roll number and then we will give the values so let's give the first value as let's give the age as 12 and roll number as one and then we will give another age as 13 roll number as two and here we have to check that if it is following this unique thing or not so let's just give a duplicate value so we will give age as 14 for a student and again the r number is two and let's just execute this query to see if it is taking care of the uniqueness or not so here you can see we are getting an error because we have told that once a column is declared as primary key it will always hold a unique and the Nal value and for Nal Also let's execute the same query and do some changes so we have to uh make this roll number always notal so let's just not give any roll number here and let's just insert only one value in ag so let me just execute this query so here you can see we are again getting an error because for now RW number is having a null value and raw number is asking for a default value because primary key can never be null now the last constraint is the foreign key constraint so foreign key constraint basically enforces a link between two tables by referencing a column in one table that is primary key in another table so in foreign key what happens is foreign key is basically helping us to establish a link between two tables so foreign key links two table to have a relationship between them so there are two tables table one and and table two table one is having details about the student and table two is having the details about the course or the subject now table one is having ID which is serving as a primary key as of now so if we want to establish a relationship between the student and the course table what we will do is we will search for this primary key if it's present here or not the attribute which is like kind of referencing here so we'll search for the same attribute here so we can see that there is a same attribute which is present in the course table as well so it will act as a foreign key and it will reference to the primary key of the student table so in this way our relationship is established please take care this thing in mind that one table would be having only one primary key but can have multiple foreign keys so let's just see about the foreign key constraint so we'll see foreign key constraint now for the foreign key let's create a table first so create a table with the name course that would be having some course details such as course name and we'll give it as Vare 50 and then we want to establish this course table with the student table now the student six table is having age and roll number so let me just provide a roll number here so it would be roll number and that would be taking integer value now at the very last I'll just establish a relationship between this R number and the r number which is present in the student six table so what I'll do I'll just provide foreign key RW number I'll just mention it inside the brackets for in key R number references I'll give the table name of which we are taking a reference that is student 6 and then I'll provide the column name that is roll number and okay so I have provided the foreign key and I have provided that which particular column here would be acting as a foreign key and then I have given this references so there's a small typo and I'll just fix it so let me just execute this query so once I execute this query I can see a succcess so basically a table with the name course is created which is having a relationship with the table student 6 the student 6 primary key that is R number is acting as a foreign key here and there is a link which is being created so before starting with foreign key let's just re- revise some older Concepts so in Keys we learned about two types of key the very first one was the primary key and the second one was the foreign key now what is primary key primary key is a key which uni identifies all the records or we can say rows of a table now consider that there is a employee table now in this employee table we have some attributes such as employee ID employee name employee salary employee address now in this particular table we are treating ID as the primary key so we have feeded the details of employee 1 then employee 2 employee 3 followed by all the employees which is present in the organization now if I want to identify employee one from rest of the employee would this ID be helpful to me so the answer is yes the ID would be helpful for me to identify employee one among all the employees which are present because primary key says that if we are declaring any of the key as primary key it is always unique as well as Nal so what does this means uniqueness here means that ID cannot have any duplicated values so employee one and employee 2 both can't have the ID as one it is not allowed when we are declaring ID as the primary key so ID cannot have duplicated values the second one is not n so ID cannot also hold any null values because again if I am holding ID as null here so it won't help me to like differentiate between all the employees because for employee 2 the ID is null so null values are not allowed and duplicated values are not allowed whenever we are assigning any attribute or we can say set of attributes as primary key so primary key help us for Unique identification of all the records which is present in the table now let's move to the foreign key so what is foreign key foreign key is a key which help us to establish relationship between two tables so whenever consider there is a database and as of now I'm taking School database as example so in the school database there would be multiple tables first one would be the student table second would be the course table third would be the teacher table and so on now the student table and course table have a relationship between them so the course table basically says that which particular student has opted which particular course so this course tables helps me to know that if a student has opted a course of let's say course code as 100 so what are the course details like what is the course name who is the course teacher and much more things and then and this teacher table also have a relationship between the course table so basically the course table tells that this particular teacher is going to teach that particular course so somehow we are we can see that there are some relationship which is established between different tables which is present in our database so foreign key help us to establish a relationship or we can say link between two tables so whenever we want to establish a relationship or link between two tables we use the foreign G concept now let's see the example which is present here so there are two tables first one is student and second one is course so what is the first we will do we'll identify the primary key of both the tables so here you can see that ID is something which is unique for each and every student so here ID is acting as a primary key now coming to the course table here you can see that course ID is unique for each and every course so here we can make course ID as primary key okay so here course ID is acting as a primary key here ID is acting as a primary key now you can see that this particular ID tells about the student ID that for Rahul the student ID is one for Raj the student ID is two and for RTI the student ID is three now in this particular ular table if I add one more column which is of ID like which is you can say roll number like consider this as roll number student roll number so if I add a same column here student roll number so I can know that okay a student with rle number one is having a course ID 100 is opted Hindi as a language or as a subject and the teacher who is teaching is Ram so basically this particular ID column is helping me to establish a relationship between these two tables because from here I can see that okay the ID is one so here if I come the ID is one the name is Rahul so ID one name Rahul has opted Hindi as a course or as a subject and the teacher who is teaching is Ram so a relationship between these two tables established so this is called as foreign key so foreign key is a key which references to the reference table and act as a primary key in the reference table so whenever there is a foreign key which is present in another table it is kind of acting as a primary key in the table to which it is referencing or to which it is establishing a relationship so as of now course table establishing a relationship with student so there is a key which is present which is kind of primary key in another table so this key is acting as a foreign key because this key is helping me to map all the details which is present in the course table to the student table so there is a relationship which is established between table T1 and T2 which is student and po so whenever a table which is referencing to another table that is called as referencing or child table so whenever we are having a foreign key in a table that table we can call it as a referencing table or child table now what is this child table so you might have heard this parent child inheritance that child always have some properties of parents or child inherited some properties of parents in the same way here child table inherit some properties of the parent table and whenever there is a foreign key which is present in child table it is referencing to one of the table that is called as reference table so whenever a table is being referenced it is called as reference table or we can also say that it is called as base table or we can say that it is called as parent table so we can name it as base referenced or parent table and the table which is having foreign key and which is referencing to other table is called as referencing or child table now foreign key help us to perform operations related to the parent table such as joining TBL are ensuring referential Integrity now what is this referential Integrity consider that there are two tables and they have a foreign key relationship between them or they have establish a relationship between them this is also having a column as ID and here also we are having column as ID which is acting as a foreign key here and which is acting as a primary key here consider that in this ID if I update ID from 1 to two so this particular two should be updated here as well to maintain the data consistency because consider that someone makes a query here and someone uses the same query for here that give me all the details of a person whose ID is one or give me all the course details of person whose ID is one so here one is not existing so here it it will says that okay you are making a wrong query because one is not existing but here it will give the detail so basically data is kind of inconsistent so we need to maintain the data consistency that if anything is updated here or consider deleted here that should be done same in the another table or we can say the child table so if any of the update or delete happens in the base table that needs to be done in the child table so that is called as referential Integrity basically maining the Integrity of data the tables which is having a relationship between them now the query to any column or attribute as foreign key so we give create table and then we give the table name so consider that there are two tables the first table we are calling as base table and the second table we are calling is child table now this table is already existing and this table we are making it new now this particular table has base ID consider name and other parameters and here base ID is acting as a primary key this particular child table is having its course ID and now it's having a base ID which is acting as a primary key in another table so this is a foreign key which is referencing to the primary key of another table so we'll give create table followed by the child table name then we will give all the attributes which are present here so Child ID then we will provide the data type that this attributes would be taking only these values so we will provide int and here C ID is acting as a primary key so we will uh provide this primary key constraint as well then we will provide the base ID and then all the values which is being accepted by the base ID that is integer then we will give this foreign key like we will tell the database that this particular column is going to be my foreign key so I'll provide this foreign key name and then I'll provide at which column in the child table we want to be a foreign key that is base ID so I'll provide the base ID and then here I'll provide references I made the base ID as foreign key but I have to tell the database okay this particular ID is being referenced as foreign key but which table it's referencing to so I'll give this references and then I'll give the table name that is base table name and then which column this foreign key is referencing to that is base ID so in this way while creating a table we can declare the foreign key so let's see from the MySQL workbench so here I am creating a database of school so I'll just execute the command so I've created a database of school I'll just do a refresh all so here a database of school is created now I'll create a table student which will be acting as a base table as of now so I'll just run the command okay so we are getting an error no database selected so why we are getting this error we have created the database school but I haven't told the server that if I want to create create the table in which particular database I want to create the table so no database has been selected so we need to execute this use command so this will tell the server you okay now all the operations which are going to happen will happen in this school database now you can see we have got a success now again we will run this create table student and here you can see we have got a success so once I do a refresh all here in the tables I can see a table with the name student is created which is having columns as ID and Name ID is acting as a primary key and name in is another column now I creating a table course which is a child table which will be having foreign key which will be referencing to the primary key of the student table so what I'll do I'll just give course and then I'll give course ID integer and here in this particular table course ID is acting as a primary key so I'll give primary key and then I'll provide the ID which is coming from this particular student and it is taking integer values and then in the last line I'll provide that ID is a foreign key so I'll provide ID here and then I'll provide that which table it's referencing to so ref refences references and then I'll provide which table it's referencing to so it's student so I'll provide student and then I'll provide the column or the attribute which it's referencing to that that is ID and then I'll just execute this particular query so you can say I've got a success and here I'll do a refresh all so here you can see that two tables are created first one is student and second one is course so course is having ID as a foreign key which is existing in the student table which is acting as a primary key there so now let's see about cascading in foreign key so just now I explained about referential integrity that if there in there is any update which is happening in the base table same should be happening in the child table or if there is any delete which is happening in the base table same should happen in the child table as well so cascading are a set of rules which dictate what action should be taken automatically when a referenced Row in the parent table is modified or deleted so whenever there are two tables first one is the parent table second is the child table so whenever there is any kind of insertion or deletion which is happening in the parent table same should happen in the child table as well as they are having a relationship via foreign key so there are ways in which we can achieve the same to maintain the referential Integrity so there are three ways to maintain the referential Integrity first one is Cascade so if a row in parent table is updated or deleted all the related rows in the child table will be automatically updated or deleted so cascet says that if I give Cascade command what it will do that if any of the attribute here or any of the value here is updated or deleted same will happen in the child table the second one is set null so if a row in the parent table is updated or deleted all the corresponding foreign key values in the child table will be set to null so consider that in the ID I have updated the value from 1 to 1 so the same shouldn't be replicated here either what it will do that ID is updated from 1 to 1 a so it will set a null value there saying that this particular value is now being updated and now for now we have set the value as null here so foreign key values in the child table will be set to null now the third one is restrict on no action so what it does it blocks the modification or deletion of a reference Row in the parent table if related row exist in the child table thus maintaining the referential Integrity so if I provide this command at the last of creation of table what it will do you consider that there is a ID which is here and the same ID is present here which is acting as a foreign key so what it will do that it will not allow any kind of updation or deletion happening in this particular ID table because it will somehow affect the ID which is present in this particular table that is the child table and it is acting as a foreign key so it will basically block the modification or deletion of the reference Row in the parent table so it will just block the modification of the ID which is present in the reference table now how we can achieve the cascading in forign so these cascading action helps to maintain the Integrity of data across related tables in the database now there are two ways in which we can achieve this cascading first one is on delete Cascade and second one is on update Cascade so what does this on delete Cascade does so the on delete cascet Clause indicates that if a row in a parent table is deleted or all the corresponding rows in the child table will be automatically deleted as well so it says that if I am writing the query in which I am referencing a attribute as foreign key if at the very last I mention this on delete cascet it will make sure that any of the data which is deleted in parent table will be deleted in the child table as well what is onupdate casket so the onupdate casket Clause indicates that if a row in the parent table is updated all the corresponding rows in the child table will be automatically updated so it says that if there is any kind of changes or any kind of updation which has happened in the parent table the same would be reflected in the child table so while creating a table at the very last we can provide this on update cascet which makes sure that if any of the value which is uh updated in the parent table that is the base table the same should be replicated in the child table as well thus maintaining the referential Integrity so before starting with the update command let's just realize or understand what is the importance of update command or how is this update command even coming into the picture so what is SQL SQL is basically a programming language which help us to perform any crud operations on a data now what are these crud operations so crud stands for create read update and delete now whenever we want to perform such operations on our data we use SQL and there are some special commands in SQL which help us to perform all these operations so for the create we have a create command in SQL which help us to create any database any table for the read we have a select command which help us to show the data or the data which is present to make a query in the data then update we have the update command in SQL and then for delete we have a delete command in SQL so using all these command we can do manipulations in the data basically perform the cred operations now in this particular video we would be touch basing more on the update command so before starting with the update command let's just create a sample database in that sample database let's just create a table and fill in some details into the table then we would be updating some values or we can say a record in a table and see that if the values are being updated or not so before making any of the database or any of the table there are some requirements or some steps we should be following so the very first step is make a database for a company XY Z so we have given a requirement that we have to make a database for a company named XY Z so what we will do we will first run this particular query where we give create followed by the database and then we provide the database name that is XY Z so this is the very first step we perform now here it will create me a database with the name XY Z in our server so in the server there could be multiple databases for now it is uh creating a XYZ database now the second command is use XYZ so as I told that in a server there could be multiple databases now I want to execute some queries so how would the server know that if it's being executed in this particular database or this particular database so we keep this command use XYZ which helps the server to know that if any operation or any queries are being performed it would be performed in this XYZ database so we will be hitting this particular query then the second requirement is now in that particular database we would be creating an employee table so to create an employee table we would be executing this query we'll give create table followed by the table name that is employee and then we will provide all the columns which we need in this particular table basically you can say as schema of the table or the characteristics or attributes of this particular table so we will give the column name followed by the data type basically what all values the column will be holding so ID can either hold string values integer values Boolean values any values so we will be telling that ID would only be holding integer values so whenever a person wants to insert a string value or a buan value it will throw an error because we have told that ID would only be storing in values and then we give a constraint so what is constraint constraint is basically a set of rules we provide to particular column so we would we are providing a constraint primary key which says that this particular ID field will always have unique as well as not null values so it means that ID can't hold duplicate values ID also can't hold null values and in the same way we will give column name followed by the data type the constraint is kind of optional so we will again give the column name followed by the data type column name data type column name data type and column name data type in this way we can create an employee table in the XYZ database now the third requirement comes in where we have to fill the details into the table basically insert some data into the table so for that we will execute this query where we will give insert into followed by the table name that is employee and then we will provide the order in which we want to insert all the values so basically it gives the order like firstly the value would be inserted into ID second value would be inserted into name third value would be inserted into age fourth into Department fifth into City and sixth into so whenever here we give the values we can provide multiple values followed by a comma like if I want to enter details of multiple employees so I can enter the details of employee one then I can give a comma and then I can enter details of employee two employee three employee four employee 5 now in the values the one is basically stored in the ID as this is the manner in which we are inserting the data Rahul is stored in name 25 is stored in age it is stored in Department Mumbai is stored in city and 1500 is stored in salary for the very first record we can say or the employee one record now in the employee two the same thing happens employee three employee four employee five so here we have feeded among five details of each and every employee including their ID name age Department City and salary so we have created a database we have used that database we have created a table we have inserted some values into the table now we want to see if all the values are inserted into the table or not so the very fourth requirement is see all the data in the table so let's see from the MySQL workbench let's execute all these queries and create a database with a table employee so that we can perform any operations on that particular table so I'll go to my SQL workbench so here you can see that I have already written all the queries just to save time but I'll be executing the queries one by one and would be explaining that how these queries are even working so the very first thing was to make a database with a company XY Z so I'll give the command create database followed by XYZ and then I'll just run this so here you can see that I've got a success but in the schemas tab you won't be able to see anything so you have to just right click and do a refresh all so once you do a refresh all you can see a database with the name or a schema with the name XYZ is created when you open it you would be seeing that there are no tables no views nothing here because we have only created a database as of now we haven't done any operation now the second operation is use XYZ again we uh use this use XYZ or use followed by the database name to tell the server that if there are two schemas Sy Ys or XYZ we want to execute all the operation on this XYZ schema now the second one was to make an employee table in the XYZ database so we will just hit this create table then we give this table name and then we provide all the columns which we need in this particular table we'll just run this query and here you can see we have got a success but here you won't be able to see anything so you have have to just again go and refresh all so here you can see in the tables our employee table is created which is having all the columns as ID name age Department City and salary now we have to fill some details into the table so I'll be just executing this query which inserts data into the table followed by the given order and then the values which we need to insert into the table so I'll just run this and here if I do refresh all I won't be able to see the data which is present here so to see the data that if the data I've provided or if the data I've inserted is inserted correctly or not or if the data is present or not I'll just hit this particular query which is Select star from employee now this particular query select star from employee help us to see all the data which is present into this employee table basically the Asic here means all so select all from employee so select all the data which is present in the employee table so we'll just hit this query about the select we will be looking more on to the next set of videos but for now you can understand that here we are trying to see all the data which is present into the table so here you can see ID name age Department City salary and all the data which we have feeded is present here now let's go to the update command so the update command in SQL is used to modify existing records in a table now consider that my name is RTI I ordered something from swiigy I gave my name there but my mistake I wrote it as re e e TI rather than R TI now my name is displaying as re TI but my name is Ri so I raise a complaint to their customer care and I tell to correct my name so they will ask me that what is the corrected name so I'll provide my corrected name and I'll provide the name which is right now present so basically I somehow updating the value here of name from re re TI to Ri so basically update means whenever we are modifying any existing data which is present inside the database consider you have provided your age by mistakenly someone feeded incorrect age so you can ask that particular person to go ahead and update your correct AG in the database so basically update help us to modify any records or any values which is present into our table so the query for update is this update then we give the table name and then we provide here set basically means you have to update this particular table and you have to set the column name to this particular value so basically if I am updating my name here what I'll do I'll update I'll give the table name I'll set and then I'll provide the column name as name I'll provide the value which is need to be set so the value which needs to be set if there are more values which are incorrect we can provide it using comma separated way and then I'll give the condition okay I've given the name is equal to re you have to set in this particular table but where I have to set this particular name so I'll provide the condition where name is equal to re e TI so I'm telling my database that go ahead and update the table with the table name this set name equal to R like the updated value and if there are more values I can give and I'll tell my database you have to update the name as re where right now the name is equal to re ti so in this manner the update query mostly works now let's see some examples of this update query some practice question and then we will go ahead in the my schol workbench and execute this queries so the very first practice question is write a query to update the salary for all employees in the HR department to 50,000 so so basically for HR department now there has been an increment which is applied to all the people who are working into the HR department so rather than going ahead and manually correcting all the salary it's better to go ahead and execute a query which will update all the salaries of the people who are present in HR department to 50,000 so what the query would be I'll give update then the table in which we created employee and then we will give the set salary equal to 50,000 so this is the updated value which I want to set so I'll set the salary equal to 50,000 and then I'll provide the condition or the Clause where Department equals to HR so go ahead update the employee table where department is equal to HR and set the salary as 50,000 so let's just go ahead and execute this particular query into our my workbench so let's just execute that particular query so what we will do we'll give update and then we will give the table name that is employee and then we will provide set and the value which we need to update salary equal to 50,000 and then I'll provide the condition that where I need to update this so where Department equals to HR and I'll just execute this particular query so here you can see that while executing this query I've got an error unknown column salary in the field list so basically it's a typo and I'll just correct it and I'll just execute it again again I've got a error so what this error says you are using a safe update mode so what is the safe update mode so let's learn about about this safe update mode so what happens ke right now we are creating some databases we are creating some tables we are doing update into the table we are deleting some tables we are deleting some databases but in a normal scenario this doesn't happen or in a real world scenario this doesn't happen because there are companies who are having huge databases which are having databases of employees workers their salary details their personal details and much more things so whenever we are performing any update or the delete command that could be harmful because there might be some apis which would be depending on the data which is present into the database so whenever we are updating any values or whenever we are deleting any values we have to make sure that we have turning off the safe mode which means we are telling okay I know that I am updating the value okay I know I'm deleting the value please turn off the safe mode so for that we will just execute this query that is set SQL safe updates equal to zero so I'll go here so I'll set SQL save updates equal to zero and whenever I want to revert this I'll execute this query and I'll just provide here as one and I'll just execute this query so this query is successful now let's just execute this query of update and now it's successful so now we want to see that if the update has happened successfully or not so we will just see all the employee details I'll just run this command and here you can see the department is HR and the salary has been updated to 50,000 so earlier the salary for the HR department was 2,000 now the salary has been updated to 50,000 so let's go to the second practice question write a query to update the name of an employee from ra a AJ to R A so basically a employee name as I told that I have given my name as re e TI but my actual name is R ti so I want to update that value in the same manner we have to update the name of an employee whose uh right now name is r a AJ to r AJ so for that what we will do we will give that update followed by the table name that is employee then I'll give the set which basically sets the value or set the updated value so I'll give name equal to Raj which is the updated value and now my database wants to know that where you want to set this updated value so I'll provide the condition where name is ra a a so in this manner we can update the name from raag to R A so this is all about the update command in this particular video we would be learning about the delete and the select command in the next set of videos so the delete command in SQL is basically used to remove records from the table so it's not like that it removes a value or it removes a data from the table it entirely deletes the record which is present in the table so records here basically means the rows of a table so whenever we want to delete an entire row we use this delete command so the query for this is delete then we give and then we provide the table name from which table we want to delete and then we give the condition that what we need to delete so consider that I want to delete all the records of a person whose name is RTI so what I'll do I'll just put this delete from table name and then in the where I'll provide the condition where name is equal to RTI so it will delete all the records of mine from the database so let's just see from the practice question and then we will go to mySQL workbench and execute the queries so the very first practice question is write a query to delete all the records from the employee table where department is HR so I want to delete all the records which is present into our table for the people who are from the HR department because I'm making a separate database for IT department separate database for HR department separate database for Consulting department and much more things so what I'll do I'll just give this query delete from and then I'll give the table name which is employee then in the condition I'll provide that from where I want to delete so I want to delete the department equal to HR now what it will do you consider that this is my table and this is the department and these are all the details consider the department here is it it is HR it is again it and it is again HR so it will find all the HR Department which is present in my table and it will delete just all the Departments which is having the name as HR so it will delete all the department which is having the name as HR it's not like that it will only delete one row it will delete all the rows with the name HR so let's just go to myol workbench and see how the delete works so let's use so we'll give delete from and then we will give the table name that is employee and then we will provide the condition where Department equals to so now here we have only one our department so let's use the IT department because here we are having two it departments so we will be seeing that how it is deleting all the records which is present into our table with the Department as it so I'll just give it and I'll just execute this particular query so this query is a success now let's just use this select star from employee to see all the records and here you can see that we can't see any of the record with the name Department name as it so now you can see that whenever we are deleting anything and if we are providing the department as it it will search in the entire table with the Departments and as ID and it will delete all the Records who are having the department name as it it's not that it's only deleting one record it will delete all the records with the Department name as it now let's see the second practice question so we have to write a query to delete the record of an employee having the name as raj so here we are deleting the record of an employee who is having the name as raj so what query we will write we'll give delete from and then we will give the table name that is employee and then here in the condition we will provide where name and then we will provide the name as raj so let's just exec this query as well so I'll just close this and I'll use delete from and then I'll give the table name as employee and I'll give where name equals to and I'll give Raj and I'll just so the Raj name is RJ and I'll just execute this so you can see that I've got a success again I'll just hit this particular query and here you can see that I can't find any person with the name Raj so whenever it will find any person with the name Raj it will delete all the records which is present into that particular table with the name Raj so in this way delete command works so whenever we want to retrieve data from our table we use the select command so select command is a dql command that is data query language command it is basically used to retrieve data from the database so whenever we want to get or we want to retrieve some data from the database we use the select command now we can provide specific columns from which we want to retrieve data either we can retrieve all the data which is present into our table so there are two queries which we can use first one is Select then we provide all the columns which we want to see or which data we want to see so we'll provide the column name column one name column two name and then we will provide from and then we will provide the table name like the table name from which we want to retrieve the data so it will retrieve the data present in a specific column in a table then there is another query which is Select star from table name so this star basically means all the columns which is present into our table so the star basically means all so we whenever we want to see all the data which is present in our table we use the select start and then we provide the table name so it helps us to retrieve all the data which is present in our table so let's just see the example of Select so consider the first example where I want to only see the name and age of an employee from the employee table so I'll use select and then I'll provide the column names from which I want to see the data so first one is name second one is age and then I will provide the table name so the table name is employee and then I'll just execute this query so this is a success query and here you can see that I can only see the name and age so this employee table is having more columns but as of now I've told that I want to only retrieve the data from the name and age which is present in the employee table so basically it help us to retrieve data from some specific column if you want to retrieve the data like the entire data which is present in this particular table so we give select star which is basically pronounced as all and then we give from and then we provide the table name which is employee and whenever we execute this we can see the entire data which which is present in all the columns so basically you have seen that in the earlier videos also we were using this particular command select start from which was helping us to see all the details or all the data which is present into the table so select command help us to retrieve all the data or some of the data which is present into the table so let's understand about we Clause its importance how it help us to filter data and much more things so without any further Ado let's get started so whenever we want to filter the data we use this wear Clause now wear Clause helps us to filter the rows based on a specified condition now what does this means so consider that I want a detail of a person whose age is 25 or I want all the details of a student who are having marks greater than 90 so basically I'm giving a condition that the age should always be greater than or equal to 25 or the Mark should always be greater than or equal to 90 so whenever I'm providing any kind of condition to filter some of the data because consider that I'm saying that I want the details of a person so it will send me all the details or it will show me all the details of all the person who are present in that particular table but where I put up some condition like a should be 25 now what it will do it will go one by one and check all the records and wherever it will find age equal to 25 it will return that particular result and show me that particular result so I am somehow giving some condition to get some filtered set of data so in that way we Clause helps us you have seen in the earlier videos as well that I was using the we condition along with update along with delete sometimes along with select also we use the we condition so we condition or wear Clause is oftenly used whenever we want to apply any condition to our data so here is a query on how we can use the work Clause so consider that I am trying to fit some of the columns from a given table with a particular condition so what I'll do I'll provide the select command then I'll provide all the columns from which I'm fetching the data then I'll provide from I'll provide the table name from which I'm fetching the data and then I'll provide the where and then I'll provide the condition that what is the condition on basis of which I want all these columns to be filtered so here is an example so here I I am kind of fetching or filtering out all the data of a employee whose age is greater than 20 so what I'll do I'll just do a select which will make sure that all the data is selected so basically till here I am having all the data which is present in my table from table employee so this is the table employee now here there is a condition where age is greater than 20 consider there is a age column in this particular table employee and in this age column we have ages such as 18 20 25 so now what will happen here whenever I'll give where age is greater than 20 it will go record by record and see here is the age greater than 18 no so discard this value it won't be shown in the final result now here is the age greater than 20 it is 20 but not greater than 20 so this will also be discarded here is the age greater than 20 yes so it will be shown in the final result so in this way we use the wear Clause let's see from an example as well so this is my my school workbench I have already created a table employee and I have already feeded some data in that particular employee table now here I'll be using this we condition to filter out all the employees whose age is greater than 25 so what I'll do I'll just give select star from and then I'll give the table name that is employee and then I'll provide the condition where age is greater than 25 so firstly I'll see that what all data is present in my current table so I'll just hit the select star from employee and after hitting I can see that all the data which is present in my table I have actually after the next set of videos I have feeded all the data again because we are seeing about the SQL queries and we need much more data to perform the queries so now I'll just execute this query and here you can see that there are only two people who are having age greater than 25 and I can see all the details of that particular person whose age is greater than 25 so basically wear Clause is helping me to get the filter data like on the basis of condition I can get a filter data which would be really helpful for me to execute some of the complex queries so if you remember in the very start of the lectures we discussed about types of SQL commands so there we learned about five types of SQL command the very first one was dql the second one was DML the third one was ddl the fourth one was DCL and the fifth one was TCL now what is dql so dql basically stands for data query language command so whenever we want to make any query into our data or whenever we want to fetch the details from our database we use this dql command now the second one was DML command that is data manipulation language command now data manipulation language command is basically used whenever we want to manipulate some data like whenever we want to insert some data whenever we want to update some data whenever we want to delete some data basically doing manipulations on the data the third command was the ddl command that is data definition language command now data definition language command mostly deals with the definition or the schema of the data basically like creating the table creating the database uh doing some modification in the database doing some modification in the table so whenever we are dealing with the schema or the definition of the table we use this ddl command now the fourth one is DCL command that is basically data control language command now in this data control language command we set some controls on our database so in that case DCL command is used the fifth one is TCL command that is basically transaction control command so whenever we are doing some transaction and we need some control on that transaction we use this TCL command now in the eql command we have already learned about the select command in the DML command we have already learned about the insert update and delete command in the ddl command we have already learned about the create and drop command so in this particular video we would be learning about the alter command and then we would be learning about the trunk gate and the rename command now what is Alter command so alter is a ddl command that is used to modify or change existing database objects such as table indexes or constraints basically doing some modification in the schema so whenever we want to do any kind of modification into our database object into our definition or into our schema we use the alter command so consider that right now I am having a employee table in my employee database now in this particular employee table I am having three columns but there comes a requirement where I need to add one more column to this employee database so this particular addition of column is done using the alter command consider that there is one more requirement which comes that you have to change the column name from employee ID to ID so this particular change is also done using the alter command so whenever we want to do any kind of modification or changes in our database table schemas we use this alter command so let's see all the things that alter command can help us do so mostly it is used to modify the schema so whenever we want to do some modification in the columns like addition of new column deletion of column modification of column and much more we use the alter command so let's see how the alter command is used the queries and then we will go to the MySQL workbench and execute all the queries so the very first use case is adding a column as I told that alter command basically help us in doing any modification in the schema so what is the schema so whenever we provide all the column names or the characteristics of our table we call this schema so whenever we want to add a column basically doing some modification in the schema we use the alter command so the query for adding a column is Alter table then we provide the table name and then we provide this add and then we provide the column name which column we are adding then the data type of that particular column and if we have any constraint or not we provide this so whenever we used to create the table we used to provide all these values like the column name data type and constraint in the same way whenever we are adding a column we provide all the properties like column name data type and constraint and we provide this alter command followed by the table and then we provide the table name in which we want to alter the data so let's see from the MySQL workbench how we can add a column in our particular table so here you can see that we already have a database with the name XY Z and in that particular XYZ we have a table called as employee now in this particular employee table we would be adding one more field that is employee date of birth which is not existing as of now so what we will do is we will give this alter and then we will give the table provided by the table name that is employee now we'll add a column dob so we'll give add and then we will give the column name that is DOB then we will give the data type that is Vare and let's give the character limit as 20 and then we will provide the constraint so if we execute the query just now what it will do that it will create a doob column name but all the values at that doob column name will be null so if you want any default value to be there you can give a default constraint so we can give default and here we can give the value as NP that is not present so if we run this particular query what it will do it will first go it will alter the table employee it will add a do column and then it will give the default value as NP wherever null is present so let's just execute this query so once you execute this query you can see a success and when we will try to see all the details of this particular table you can see that a do is created with NP NP NP NP NP because all the values for now is null so uh it has taken the default value that is NP now let's see the Second Use case of alter command that is drop a column so whenever we want to drop or delete a column we use this alter command so here you can see we have given the query as alter and then we provide the table followed by the table name and then we provide the drop command then we give the column which we want to drop and then we provide the column name so let's go to my SQL workbench and let's just execute this query so for now we have created this do column let's just delete only this particular column so first I'll give alter and then I'll provide table and then I'll give the table name that is employee and then I will provide the drop command and then I will provide column saying that I want to drop the column and then I will provide the column name that is d o now let's just execute this query so you can see the query is successful let's see that if it has been deleted from our particular table or not so we will just execute this query and here you can see that we can't see any do field so this particular column do is deleted whenever we use this alter command followed by the drop command now the third use case is modify the data type of an existing column so whenever we want to do some modification in the data type of a existing column which is present we use this alter command so so for that we use this modify Clause so the modify Clause is oftenly used with an alter table statement in SQL it allow us to change the definition or the properties of an existing column in a table so whenever we want to change the definition or the properties of a column in table we use this alter command along with the modified Clause so here you can see the query so the query is Alter table then we give the table name like which table we want to do modification and then we provide this modify command and then we provide the column name like in which column we want to modify and then we provide the new data type like which new data type we want to set for that particular column so the a command modifies the column name to a new data type so let's go to my MySQL bug bench and let's see how it works so for now let's just modify the data type for age let's make age as barcat so what we will do we will give alter and then we will provide table and then we will provide the table name that is employee and then we will provide this modify and then we will provide the column name that is age and then the new data type so the new data type for AG is Vare three so let's just execute this query so you can see that we have got a success so for now the data type for this particular age column has been changed to Vare now the fourth use case is change the name of an existing column so whenever we want to change the name of an existing column like in earlier use case we saw that how we can change the data type of a column in this use case we can note that how we can change the name of that particular column so the change command is oftenly used with an alter table statement in SQL it help us to change the name or data type of a column within a table so whenever we want to change the name or change the data type of a column in a table we use this change along with the alter command so the query is Alter table followed by the table name and then we provide this change then we provide the old column name and then we provide the new column name like from old column name to the new column name like what is the new column name you want to give and then if there is any new data type for that particular column we provide in this way so the above command changes the old column name to a new column name and also its data type so the old column name is changed to new Colum colum name and the new column name has a new data type if the new column name doesn't have a new data type you can give the data type of that particular old column name only so let's go to myo workbench and see so let's just modify this age column name to employee age so let's see how we can do so we'll give this command alter table followed by the table name that is employee and then we will provide this change and then we will provide the old column name that is H and then we will provide the new column name that is employee Ag and if there is any new data type else we need to provide the data type of this age column only so that is Vare three and let's just execute this query so once you execute this query you can see a success so let's see if we are able to see this in our table or not so let's run this select star from employe and here you can see that the age column name has now been modified to employee age that is EMP AG so in this way using the alter command we can change the column name as well so this was one of the way in which we can rename our column there is one more way in which we can rename either our table our column our constraints and much more that is using the rename command so the rename command is used to change the name of an existing database object such as a table so whenever we want to rename the table name column so whenever we want to rename the column name index or constraint whenever we want to rename the constraint name so the query for the same is Alter table then the table name and then we provide this rename and then we provide like which thing we want to rename like table column constraint anything and then we provide the old column name like here we are renaming the column so we will provide the old column name and then we provide this two like basically you want to rename the old column name to the new column name so we provide two and then we provide the new column name the above command renames the old column name to the new column name so let's see from the MySQL workbench so what we will do now we will revert this employee H to H so what we will do is we will give this alter table followed by the table name that is employee and then we provide the rename and then we provide what we want to rename that is our column so we will provide column and then we provide the old column name so that is EMP H and then we provide this two and then we provide the new column name so we will give this H so let's just execute this query so you can see that we have go a success and when we execute this command select star from employee to see all the data present in our table so you can see that now this EMP has now been renamed to H so in this way we can rename our column name table name or constraints so what is this rename command rename command is used to change the name of an existing database object such as a table column index or constraint so whenever we want to do any kind of changes in any of the database object like table column index or constraint we use this rename command so as the name suggest rename so whenever we want to rename or whenever we want to give a new name to a table a column or a constraint in SQL we use this rename command rename command comes under the ddl command that is data definition language command so the data definition language command basically deals with the data definition the data Properties or we can say the database schema so whenever we are doing any changes in the database schema database definition or database properties so there are many use cases of the rename command like renaming a table renaming a column or renaming a database so let's see about all these one by one so the very first query is table renaming so whenever we want to rename a table what is the query to do so so first we will give this rename command and then we will provide what we want to rename basically we want to rename the table so we will give table and then we will provide the old table name and then we will provide this two and then we will provide the new table name basically this query means can rename the table table from the old table name to the new table name so the above command renames the old table name to the new table name so let's see from the MySQL workbench that how it is happening so let's rename this employee table to the employees table so what we will do is we will give this rename and then we will provide what we want to rename so we will provide this table and then we will provide the old table name that is employee and then we will provide this two and then we will provide the new table name that is employees and we will just execute this query so you can see that we are getting a success but here we are still seeing this employee so we just need to do a refresh all in the schema tab so once you do a refresh all you can see that in this particular XYZ database we have a table with the name employees so if you try to uh see all the details of the employee table you won't be able to see because right now we have renamed the employee table to the employees table so whenever we want to see the detail of employee table if you run this particular query that is Select star from employee you will see a error because right now the employee table is not existing in this XYZ database because we have renamed the employ table to employees and whenever you give the new name that is employees and if you run this query here you can see that you can find all the details so in this way we can rename any of the table now the Second Use case is when we want to rename a column so to rename a column since it comes under the schema so what is schema schema is basically all the properties or the attributes or the characteristics of table which is displayed by the column so whenever you want to do any kind of changes in the schema we use this alter command so we give this alter and then we provide the table and then we provide the table name in which we want to alter the the data and then we provide this rename command then we provide what we want to rename that is column and then we provide this old column name and then we provide this two and then we provide this new column name like we want to go ahead we want to alter some data in that particular employee table and we want to rename a particular column to a new column name so let's see from the myql workbench so let's just rename this name column to employee name that is EMP name so we will give alter and then we will provide table and then we will provide the table name so for now we have modified the table from employee to employees so we will give employ and then we will provide rename and then we will provide what we are renaming that is column and then we will provide the old name that is name and then we will provide two and then we will provide the new name of the column that is EMP name just execute this query and here you can see that now the name has been modified to EMP name and here we are getting a success so whenever you will try to fetch all the details or see all the details of the table so here you can see now the name has been renamed to EMP name so in this way we can rename of the column in our particular table now the third use case is whenever we want to rename our database so we give this rename then we give database and then we provide the old database name then we provide this to and then we provide this new database name now in this particular renaming of database there are many security risk involved because we can't go ahead and rename any of the database so there are some security requests and protocols which needs to be accepted before renaming any of the database from the old database to the new database so it mostly depends on the server to server that if the server allows renaming of database or not so what is truncate command this command is used to remove all the rows from the given table leaving the table empty but preserving its structure so it basically means that whenever we have a table and there are some data which is feeded into our table a b c d e f g hii and whenever we give this drop table name command so drop table name command what it does it basically deletes the table from the database then we give this delete command so delete command basically deletes the data on a given condition then this truncate command comes into picture so what trun command does it truncate command clears all the data which is present in our table but it preserves the structure of the table basically you can see that table is there that is a empty table all the data inside that particular table is cleared using this trunade command so let's see from the MySQL workbench how this trunade table works so here we already have a XYZ database we will create one more table in this particular XYZ database we will try to truncate or delete all the data which is present in our table and then we will see that if our table is preserved or not or if the structure of table is preserved or not so we will just cre create a table with the name salary details and in this particular table we will provide some columns so let's provide the First Column as salary int and second we will provide increment let's just give this as a int so let's just execute this query so once you execute this query you can see a success and when we will go here we'll do a refresh all here you can see that two tables are created first one is employee table and the second one is the salary details which is having salary and increment let's just feed some data into this particular table so we will give insert into and then we will provide the table name that is salary details and then we will provide the manner in which we want to feed the data so first we will give salary and second we will give the increment and let's just provide the values and here we will start giving the values so let's just provide the first value as 1,200 and the increment is 6 % and the next salary is 1,500 and the increment is 4% let's just execute this query so here you can see that we have got a success so let's see if all those details are feeded in our table or not so we'll give select star and then we will give from and then we will provide the table name that is salary details and let's just execute this query so here you can see that all the data which we gave is feeded here so now let's see that how this truncate command is working so what we will do we will just truncate this particular table so whenever we truncate this particular table it says that all the data which is present inside the table would be deleted but the structure will remain preserved so we'll give truncate table and then we will give the table name that is salary details and let's just execute this query so here you can see that I've got a success if I go here and I do a refresh all I can still see the salary details table is here it means the data is only deleted the the table is still there so let's see if all the data is deleted or not so here you can see that there is no data which is present in salary and increment so in this way truncate table command works it basically deletes all the data which is present in our table but it preserves the structure or it preserves the table only the data is deleted so firstly let's start with the truncate command so truncate command is basically used to remove all the rows from a table what does this means so consider that there is a table employee and in this employee table we have some rows we have some columns so what truncate command will do truncate command will clear all the rows or all the datas which is present in our table which will make the table empty but will preserve the structure of the table so there would be a table but that particular table would be empty there would be no rows in that particular table all the data would be deleted so it basically removes all the rows from the table the command for the trun is truncate table and then we provide the table name now the next is the delete command so the delete command is basically used to remove some specific rows from a table based on a given condition so whenever we want to delete a specific row on a given condition like delete or remove all the rows where the AG is greater than 20 so whenever we are providing some specific condition it executes the delete operation and it deletes the entire row so the command for the same is delete from table name and then we provide where condition so it basically deletes some rows on the basis of condition but the trunet deletes the entire rows like all the rows which are present in our table the third one is drop command so the drop command is used to completely remove the table so it not only deletes the data it also deletes the entire table so it removes the existence of table if in a database there is a table and if we use the drop command command for that particular table that table would be deleted there would be no existence of that particular table so the command for the same is drop table and then we give the table name so if this is a table employee in this particular table if we are using the truncate command it will go ahead and delete all the particular data which is present in this particular table and it will delete all the rows which is there in the table but it will preserve the structure of the table basically the schema of the table would be preserved if we are using the delete command it sees that if this particular rows specify the condition if this particular row specify the condition it delete this particular row but if this row doesn't specify the condition it leaves this particular row and if this specifies the condition it deletes this row so it deletes the rows based on a specified condition the drop command entirely deletes the table so it doesn't only deletes the data which is present in the table it entirely deletes the table so this was the basic difference between trunet delete and drop command in SQL so what does this distinct keyword means distinct basically means unique so whenever we want any unique values we use this distinct keyword so distinct keyword is used with select statement to retrieve unique values from from a column or a combination of columns so whenever we want to retrieve some unique values from a given column or a combination of columns we use this distinct keyword now let's see from an example consider that there is a table of employee which is having three columns first one is ID second one is name and the third one is City so let's just feed some data so ID is one name is Ram city is Pune ID is two name is Ram city is Mumbai ID is three name is Radha and the city is again Pune so we have made a table we have entered the detail of three employees and now we want to see that how this distinct keyword is working so consider that right now I want the distinct values from the city column so what it will do it will go to the city column it will start fetching the values so the very first value is pun now it has nothing to compare with because it is the very first value so it will print Pune in the output now Mumbai is not existing in row one so Mumbai is also unique value because it is not existing in the upper values so we will print Mumbai also in the output now coming to the third row that is Pune so Pune is already existing in Row one not in row two but in row one so this value would be discarded so we would be only seeing Pune and Mumbai in the output so it gives us the distinct value for the city column now consider that we want a distinct value in a combination of columns consider that we want to see distinct values in name and City so what we will do in the output first for Ram and Pune there are no any values to compare so it will give RAM and Pune in the output now coming to the second row it will see that is there any combination of RAM and Mumbai together present in any of the above rows so it can find the name as RAM but the city is Pune so there is no combination with the name RAM and Mumbai so it will print RAM and Mumbai now and now coming to the third column so it will search for the name as RHA and city as Pune so it will see in row two and Row one is there any name of Radha existing along with the city Pune so there is no combination of Radha and Pune so it will print Radha and Pune as well so in this way we can either get the distinct values from the combination of column or from a single column so to get the value from a single column we use this query that is Select and then we provide this distinct keyword then we provide from which column we want the distinct value and then we give from and then we provide from which table we want this distinct value so select distinct then the column and from table name when we want to have a combination of distinct values so we give this select distinct and then we provide all the columns from which we want the distinct value or the combination of columns and then we provide from and then from which table we want the distinct values so let's see from the MySQL workbench that how this distinct keyword is working so here let's just create a database with the name company let's just create a table with the name employee insert some details into that particular employee table and let's just use this distinct keyword so to save the time I have already written the query so we will just execute this create database followed by database name which will create a database of company in my schemas tab so here you can see a database with the name compan is created now I will execute this use company which will tell the server that all the operation now needs to be performed in this particular database now I will create a table employee in this particular company database so here you can see a success once I do a refresh all here I can see in table our employee table is already created now let's just fill some details into this employee table so we will execute this insert into command and here all the details have been feeded now let's see that if all the details are feeded correctly or not so here you can see that ID name age Department City salary all the details have been feeded for five of the employees now let's use the distinct command so I want to see the distinct value of Department in this particular employee table so I'll give the query as select distinct then I will give the column name that is department and then I will give from and then I will provide the table name that is employee so it will give me the distinct value of this particular department so let me just execute this query so once I execute this query you can see that I'm getting all the unique Department names that is it HR marketing and finance so in this way we can see the distinct value from this particular column that is Department let's see some distinct value from a combination of columns so I want to see a distinct value select distinct and the column from which I want to see the distinct value to get together is age and department so I'll give department and then I'll give age and then I will provide from and then I'll give the table name that is employee so let's just execute this query so once you execute this query you can see that it HR it marketing and finance and with the it here is the age is 25 with the it here the age is 27 so you can see that in the department we can see that it is repeated twice but when we see the combination of department and age that is it and 25 it and 27 there are no any other combination existing with the same so in this way we get the combination of distinct value for two columns so what is operators in SQL so whenever we want to perform any operations on the data we use operators so consider that there is a table in that particular table there are many sets of data so whenever we want to perform any operation on that particular set of data we use the operators now operators are of various type let's see about each and every types of operator so the very first operator is arithmetic operator now in this arithmetic operator we have addition subtraction multiplication division and modulus now let's see an example of arithmetic operator consider that my table is not updated from the last one year and in this particular year there are some people who are about to retire so I'm writing a query in which I'm checking the people whose age + one is equal to 60 so here I have written select star from employee where H + 1 equals to 60 so it will give me all the details of a person whose age is equal to 60 so in this way we can use the arithmetic operator we can also use the subtraction we can also use the multiplication we can also use the division now here comes the modulus now what is modulus modulus basically gives us the result of the remainder so whenever we are dividing any two numbers like whenever we are dividing 2 by 4 so we get remainder as zero so this is the modulus now the second operator is the comparision operator In the comparison operator we get this equal to not equal to greater than less than greater than or equal to or less than an equal to so let's see from an example I want to see the details of all the employees whose age is greater than 20 so I'll use the select star from employee where AG greater than 20 so here I have used the comparision operator and here I getting the details of all the person whose age is greater than 20 I can also use this age equal to 20 if I want the details of all the person whose age is equal to 20 or I can also use age greater than or equal to 20 which will also include the 20year old employee now the third operator is The Logical operator now in The Logical operator we have three operators so the very first is and the second is or and the third is not now and operator basically combines two condition and return true if both of the condition are true so consider that we have given two conditions that AG is greater than 20 and city is equal to Pune so it will give the output only when it finds the age which is greater than 20 and the city which is equal to Pune for a particular employee so here you can see an example select all from employee where city is equal to Pune and H is greater than 80 so consider that there is a table having h and city now in age we have some values as 18 20 25 29 and in city we have Pune Mumbai Pune and Pune so what it will do it will match for both the conditions so first it will see where the age is greater than 80 and city is Pune so for the very first row is the age greater than 18 no so if one condition is discarded it won't see for the other condition now for the second row is age greater than 18 yes is City equal to pun no so this one is also discarded now for the third row is age greater than 18 yes is c equal to Pune yes so it will show 25 Pune in output now for the fourth row is H greater than 18 yes is City equal to Pune yes so it will show all the details of this particular employee as well so it will show all the details of this employee and this employee now the second operator is or operator so it combine two condition and return true if either is true so if age is greater than 80 but city is not equal to Pune it will return all the values if city is equal to Pune and age is not greater than 18 it will also return that values so consider in the same table so for the very first row is age greater than 18 no is CT equal to pun yes so it will show the details of this particular employee now is age greater than 18 yes so it will not check for the second condition so it will show the details of this particular employee now is age greater than 18 yes so it will show the details of this particular employee as well is age greater than 18 yes so it will not see for the third value because the first value is getting corrected so age is greater than 18 the first condition is evaluating as true so it doesn't needs to see the second condition now for the not it reverses the result of a condition return true if condition is false so consider a condition where I want only the details of a person who are not in it or HR department the persons who are in other department I want only the details of that particular person so we can use the not operator there so here you can see a query select star which means all from and then we provide the table name that is employee and then we provide it here where and then we provide Department here we provide not and here we provide a in operator about which we would be discussing in further slide and here we have G given all the department in which we don't want the particular employee to be so if a employee is not in it or HR department give me all the details of that particular employee so it will give me all the details of that particular employee whose department is not in it or HR now what is this in operator so in operator basically checks a value matches a list of value or not so in this in operator we provide some list of values this list of values can either be in this particular Department column or can not be in this particular Department column so basically it checks that if in this particular Department column if these values are existing or not if these values are existing return the record of that particular employee if these values are not existing then don't return the uh record of that particular employee so it basically select star from employee where Department in it or HR so it returns all the employees details whose Department are in it or HR so let's see about all these operators from myol workbench so here we have a company database in that company database we have an employee table so let's see for The Logical operators so let's see for the and operator so for the and operator we will give select star from and then we provide the table name that is employee and we provide the condition where AG is greater than 20 and department is equal to it so give me the details of all the employees whose age is also greater than 20 as well as the department is ID so let's execute this query so once we execute this query we can see that we are getting the details of all the employees whose department is it and the age is also greater than 20 so in this way we can fetch all the details of a particular employee in which the age is greater than 20 and the department is also it now let's just do some manipulation in the same query so we will see for the or operator so here we will see the query for the or operator so we will be using the same query and in the place of and we will be using or so give me the details of all the employees whose age is greater than 20 or the department is it so it will search for all the employees whose age is greater than 20 either the department is ID so let's just run this query so once we run this query we can see that we are seeing much more details this time like we are seeing the details of all the five employees because for all the five employees the age is greater than 18 so it's not seeing for the second criteria that that is Department equal to ID on the basis of age is greater than 18 it is giving me all the results now let's see for the not operator so for the not operator we will give select star from employee and then I want the details of all the employee where Department not in either it or HR so give me the detail of all the employees where department is not either it or HR so let's just execute this query so here you can see that I'm getting the details of all the employees whose department is neither it or HR we are getting the department for marketing and finance so it will basically give me the details of all the employees whose Department doesn't lies in this particular list so in operator basically checks that if in this particular list are there any Department which is existing here or not so if we are using in operator let's see for the in operator how it works so in operator so for the in operator what we do is we give this command select star from employee and then we want the details dets of all the employees whose department is it or HR so whose department is having values either it or HR now you'll say that why are we even using this in operator we can use this or operator we can provide department is equal to it or department is equal to HR or department is equal to marketing yes we can provide it here but here it's very easy to provide because we can provide list of values we can also provide those values which are not present even in this department column so uh it makes us very easy to compare between the list of items and the item which is present in our column so let's just execute this query so here you can see that we are getting the employee details for all the employees whose department is either it or HR or basically the department which lies in this particular list so whenever we give not in front of in it basically makes sure that give me details of all the employee whose department is not in it or HR so it basically reverses the result which we get in using an operator so now the next operator is is n is not null operator so basically is null operator checks for the null values is not null operator checks for the not null values so whenever we want to check for any null or not null values we can use this is null and is not null operator so here you can see a query where we are checking that uh give me the details of all the employees where department is not null so give me the details of all the employees where there is no null present in the department column so it will give me the details of all the employees so let's see for the not null operator or null operators so so here we will see about the not null is null and not null operators so give me the details of all the employees where department is not null so let's just execute this query and here you can see that we are getting the list of all the employees where department is not null for now there are no null values which is present in department but you can understand it in this way that if there are any null values for any particular record or any particular employee it will not show that particular result now let's see the next operator that is the bitwise operator so there are two operators in bitwise first one is and and second one is off so in bitwise operator what it does it it basically converts the integer value into bits and then perform any of the operation either and or on in this particular bits so uh for now bitwise operators is not something which is very concerning to us so for now we are skipping the query for this because it's not very used but you can understand that in bitwise operator we convert the integer into bits and then we perform any of the operation like and or or on the bits itself now the next operator is the like and the Wild Card operator now what is this like and wild card operator like operator is used to search for a specified pattern in a column so whenever we want to search for a specified column like give me the details of all the employees who are having double A in their name give me the detail of all the employees whose name start with it so whenever we are trying to search for a pattern we use this like or Wild Card operator it uses Wild Card operators for matching patterns so this like operator basically use the Wild Card operators for matching patterns now the very first Wild Card operator is the percent sign which basically matches for any sequence of zero or more characters the query is given as select star from employee where name like so here you can see the like operator is given and here we are provided a and percent so what does this mean so it basically means give me the detail of all the emplo whose name starts with a and can have many more characters after their name so consider that a person is having a name as AB a person is having a name as Aman A person is having a name as aush so all these uh employee names we can see because these all employee names start with a and have zero or more set of characters after that so basically like search for a specified pattern and Returns the value whenever it matches any of the pattern which is given here so if I give R and percent so it will give me the details of all the employees whose name start with r and can have more characters in their name either it can be zero either it can be one either it can be two or either it can be many so RTI will also qualify with for this Ram will also qualify for this Rahul will also qualify for this because the number of characters after R does not matters because it is given as percent so percent basically replaces all the characters and it will find that all the names start with r so these qualify for this particular query now for the second wild card we have underscore so it matches for any single character so here percentage matches for any set of characters but if we are giving underscore for it means that there should be only a single character so here you can see a query where I'm getting all the details of employee where name like and we have given a single character and a so give me the details of all the employees whose second character in the name is having a so first character can be R can be a can be B can be C anything but the second character in the name should always be a so it basically matches for a single character now let's see from a MySQL workbench and understand that how it's working so let's use for the like operator so we will use the like operator when we are using the wild card as percent let's fetch all the details of employee whose name starts with a so we will give select star from employee and then we will give where then we will provide name and then we will provide this like operator and inside the inverted comma we will provide the character for which we are searching and then if there can be any number of characters or not so we'll just execute this query and once we execute this we can see that we are getting the details of all the employees whose name is starting with a it doesn't matter that how long the name is it doesn't matter that how many characters are there after a but they are having the name as a in the very start now let's see for the like operator using the underscore wild card so we will give like operator when using a underscore wild card so let's get all the details of a person who is having the second second letter or second character as a in their name so select star from employee and then we will give where and then we'll provide name and then we will give the like operator and here we will leave the first character first character can be anything and then we will give the second character as a and then we will give this percent sign that after the second character there can be many characters so we will just execute this query so once you execute this query you can see that we are G getting the details of two employees Rahul and Raj who are having a as the second character in their name it do doesn't matter what is the first character it doesn't matter that how many more characters are there after a we are getting the details of all the employees who are having a as the second character in their name now the next operator is the between operator so between operator basically checks if the value is within a range of values so consider that we have given a range of values if a values lie between this range or not so here you can see that we are trying to fetch all the details of a person whose salary lies between 1200 or500 so select all details from employee where the salary lies between 1 1200 and 1500 so let's see from the MySQL workbench so we will see for the between operator so let's fetch the details of all the employees whose salary lies between 12200 to, 1500 employ where salary between 1,200 and 1,500 so we'll just execute this query so here you can see that we are getting the details of two employees whose salary is 1,500 so basically this between operator is an inclusive operator basically it means that it will search for an employee who is having 12200 salary as well and it will search for an employee who is having 1,500 salary as well and then uh any salary which lies in the range so it includes this also and this also so what are clauses in SQL Clause basically means condition so Clauses are like tools or condition that help us to make queries more specific or decide what data we want to fetch so whenever we want to fetch some data which is specific to some of the condition or specific to some of the Clause we use the Clauses in SQL so here we have mentioned all the type of clause which are there in SQL so the very first one is wear clause which we know that which is used to filter out data now the second Clause is the group by Clause the third Clause is the having Clause the fourth Clause is the order by clause and the fifth Clause is the limit clause for the group by and having Clause we will learn about this after aggregate function because this works on a aggregated set of data but for where order by and limit we would be learning in this particular video only now the query for using a clause is we give select and then we provide if we want to give any kind of condition on a given row then we provide from then we provide the table name and then we provide the clause and then we provide the condition so whatever is the clause and whatever is the condition perform all these on these uh particular columns now the very first Clause is the wear Clause now wear Clause is basically used to filter the row based on the specified condition so the query for the same is Select column from table and where condition so let's uh assume an example where I want to see or fetch all the details of a person whose age is greater than 20 so we are filtering out all the employees whose age is greater than 20 so we will give select star that is all from employee where age greater than 20 so it will give me the details of all the employee whose age is greater than 20 from a table employee where there could be multiple employees with the age 25 26 18 17 and much more now the second Clause is the limit Clause so the limit clause in SQL is used to restrict the number of rows returned by a query so consider that I'm writing a query for giving me all the details of a person whose age is greater than 20 but I want only three of the employees whose age is greater than 20 or let's just understand in this way considered that there is a school now in that particular school there are five students who have scored above 90 but I want the details of only top three people who have scored above 90 so what I'll do I'll just use this limit clause which will put a limit to the result which we have got so this query retrieves the first n rows from the table so whenever we provide a limit n it will just give me the N rows from the table consider we provide the limit for two rows so it will only return me the two rows or three rows then it will only give me the three rows so here n can be 1 2 3 anything according to your condition or according to your use case now the query for the same is Select column 1 column two or any of the column or if you want all the details you can use the star then from then table name and then here we provide limit and then we provide the number of rows like how many number of rows we want consider that we want to only see the details of two employees so what we can do is Select star from employee and we can provide limit and we can provide two so it will give me the details of only two employees from all the employees so let's see from the MySQL workbench so consider a condition where we want to only see the details of two employees so what we will do is we will give select star from employee and then we will give the Clause that is limit and then we will give the condition that is two so give me the details of only two employees so let me just run this query so here you can see that we have got the details of only two employees so in this way limit Clause work so here we can provide the value either 2 3 4 5 according to your use case basically limits sets the limit to The Returned results so consider that if I want to see the details of all the employee it will return me the details of five employees but in that particular five employees I want to put a condition that give me the details of only two employees so limit sets a limit on all the values which is returned now the next Clause is the order by Clause now the order by Clause is used to sort the results in either ascending or descending order so whenever we want our results to be sorted in either ascending or descending order consider I want to see the details of all the employee whose salary is highest from lowest so we can use this order by Clause Now by default it Returns the result in ascending order so if we haven't provided the order it will by default return the result in ascending order so this query retrieves the first nend rows from the table now the query is Select and then we provide if there are any columns from which we want to see the data and then we provide from and then we provide the table name and then we provide this order by clause and then we provide the column and then we provide either ascending or descending so basically we provide the order by and we want the order by to be performed on this particular column and we want the results to be filtered in either ascending or descending order so here you can see an example select star which basically means all from the table name employee and then we provide the Clause order by and then we provide the column in which we want the order by Clause to be executed that is salary and then we provide the manner or the fashion in which we want to see the result that is descending so it will basically give me all the employee details with the salary in the descending order so let's see from the myql workbench so here we will be seeing about the order by Clause so we will use the select star from employee we want to see the details of all the employee who is earning the salary from the highest to lowest so we will select star from employee which will give me the details of all the employees and then I will put a clause order by and then I'll provide from which column we are we want to order the details so we will give Sal salary and then we will provide that in which manner we want to see the salary that is in descending order so let's just execute this query so once I execute this query here you can see that we are seeing the salary in the descending order like the one who is earning the highest is at the very first and the one who is earning the lowest is at the very last if we don't give any manner like ascending or descending it will by default take the ascending so let's see without giving any order so here you can see that by default it is giving me the results in ascending order so this is all about the order by clause in SQL now let's do some practice question so the very first question is write a SQL queries to fetch the details of employees having ID as one so we have to write a SQL query where we have to fetch the details of employee who is having ID as one so we will write select and then we will give all and then we will provide from and then we will provide the table name and then we will provide the wear clause and then we will provide ID and then we will provide a comparision operator and then we will provide one so give me the details of all the employees where ID is equal to one so here we are seeing the use of wear Clause now let's go to the next question so the next question is write a SQL query to fetch the details of all the employees who are having ID as one and C as Mumbai so give me the details of all the employees who is having ID as one and city as Mumbai so here we will give using this query select star from employee where ID equal to 1 and because we are seeing that ID is also one and the city should also be Mumbai so both the condition should be true so ID equal to 1 n c equal to Mumbai now the next question is write a SQL quy to fetch the details of employees who are having salary greater than 12200 and the city as Mumbai so we want to fetch the details of all the employees who are having salary greater than 12200 and the city as Mumbai so what we will do is we'll give this query select star which basically means all from employee so it will fit all the details of this employee table now on the all the details we have to perform some condition so where salary should be greater than 1200 and City should be equal to Mumbai so this is how we are writing this query for this particular practice question now the next practice question is write a SQL query to fetch the details of employees who are not from Mumbai so we want the details of all the employees who are not in Mumbai or not from Mumbai so we will give this select star from employee which will fetch me the details of all the employees then we will provide this wear condition and we will provide City not in so basically not in make sure that in this particular list whatever thing is given is not present in the city column so if this particular data is not present here it will return me the details of that particular employee so City not in and here we provide Mumbai now the next practice question is write a SQL query to fetch the details of employees having the maximum salary so we have to write a query to fetch all the details of our employee who are having the maximum salary so we'll give select start from employee so here we'll get the details of all the employees and then we will provide this order by clause which basically makes sure to give the results in a certain order and then we will provide which column we want to order that is the salary so we will give the salary column and here we want the maximum salary so we will provide the order as descending so in the descending order we'll get the maximum salary as the very first record now the next query is write a SQL query to fetch the detail of two employees who are having the maximum salary so here we have to break the problem is we have to fet the detail of only two employees who are having maximum salary so for the maximum salary we can use the order by Clause followed by the descending order on the salary column and for the two employees we can use the limit Clause so what we will do is we will write the query select star from employee and then we will try to fetch the maximum salary so we will give order by and then on which particular column you want to order that is salary and then in which manner you want to get the details of salary that is descending and then we will limit that particular result which we get from here to two employees so in this way we can get the details of two employees who are having the maximum salary so this was all about the practice question and Clauses in SQL we will learn about group by and having clause in next set of videos so what does this aggregate means aggregate basically means collated so all the functions or all the methods which is helping us to do some manipulations or do some calculations on a collated or collected set of data that is called as aggregated function so let's see the definition so aggregate function performs some operation on a set of rows you can say collection of rows and then returns a single value summarizing the data these are used with select statements to perform calculation now let's understand from an example consider that you have a employee table with you and now in this employee table you have some columns such as ID salary employee name now there are many employee data which are feeded inside the system for now consider that we have feeded three employee details employee E1 employee E2 and employe E3 now if we want any kind of manipulation or any kind of value from the given set of data or from the collated set of rows we uh use the aggregated function now what kind of value we would be Desiring so consider that I want to find that what is the maximum salary a person is getting from all the employees so we can use the max function which is present in aggregate function if I want to know that what is the minimum salary our employee is getting uh in the company so we can use the minimum function what if I want to know the average salary company is given to a employee so we can know the average salary by cating all the data which is present in the room and doing manipulation on all the salary which is present there in the same way we can know the total salary using the sum function also we can count how many employees are there using the count function so as you can see that this particular minimum function will first go to employee E1 it will see that what is the data present it will take the data consider the salary is 12200 now in the employee E2 it will go and see if the salary is less than 1200 if it's 1300 it will ignore this then it will go to E3 it will see if the salary is less than 1200 it's 11100 so now it will ra this 1 12200 and have 1,100 in the output now it will go to the fourth column see if the salary is less than 11100 so it's, 1500 so it will ignore this so the final output we will get is 1100 so the minimum salary of a employee in this particular employee table or in a company is 1,00 in the same way it can calculate the maximum value when it wants to calculate the sum of entire salary it will just uh add the salaries of employee E1 E2 E3 E4 and it will get the total salary which the company is giving to the employees now there are many types of aggregated function as I told here min max average salary sum so let's see about them so the first one is Count which basically help us to count all the rows which is present in our table the second one is sum which is basically used to sum all the numeric values which is present in our table or in our column the third one is average which gives us the average of a particular aggregate or collated set of rows the fourth one is minimum which gives us the minimum value in a collated set of rows the fifth one is maximum which gives us the maximum value in the collet set of rows and the sixth one is group concat which is basically used to concat two groups now let's see about each and every aggregated function one by one so the very first aggregated function is Count now what is count it counts the number of rows in a table or the number of non-null values in a column so consider that in my table there are some columns and I want to count that how many people are there who are getting salary so the salary details for each and every employee is feeded consider it is a b and c here so it will count one two and three so it will result the value as three that three employees are there in the company who are getting a salary if there is a null value which is present here like employee has joined the company recently but it it hasn't been paid yet so for this it will ignore this value and it will only give the three values so it counts the number of rows in a table or the number of non-null values in a column so basically in a column if there are any nonnal values it counts the value and Returns the output so the query for the same is Select then we give the count and then we provide in which column we are providing this particular aggregate function and then we give from and then we provide the table name that is employee so this will tell us the number of employees in a company so we are uh giving a count on the name so basically it will count all the name of employees and it will tell me okay in your company there are X number of employees who are working so let's see from the MySQL workbench that how this count aggregate function is working so for now we will learn about the count function so now what count function will do is let's see that what all details are there in our employee table so we will just execute select star from employee to see all the details now here you can see that there is ID name age Department City and salary now I want to count the number of employees in my company so what I'll do is I'll give this command is Select and then I'll provide the aggregate function that is count and then I'll provide that which particular column I want to count so I can get the count of employee using the ID name age Department City salary any of the columns but for now let's take the name column because name is something like all the employee would be having a name so let's calculate from the name column only so we'll give name select count name and then we will provide from and the table name from which we are trying to find the count employee and let's just execute this data so here you are seeing that we are getting the count as five so we have feeded the details for five of the employees and we are getting that in your company there are five employees who are existing now let's see the second aggregate function that is sum so what is sum sum basically calculate the sum of all the values which is present in a numeric column so whenever there is a column which is having numeric values we can use the sum function consider salary so this adds up all the number which is present in the list so if in the list of all the rows which is present inside a column it adds up all the salary and gives us the desired salary or the total salary so here you can see we have provided a query where we are giving select and then we are providing the aggregate function and then we are providing the column on which we are uh taking the aggregate function that is salary and then we are providing from and then we are providing employee so this particular query will give me the total amount company is paying to its employee so it will tell me the total amount which the company is paying to its employee so that the company can make their budget so let's go to the mysl workbench and see how the some aggregate function is working so we will just do select and then we will give sum the aggregate function and on which particular column we want the sum so we will give salary and then we will give from and then we will give the table name that is employee so let's just execute this query so here you can see that we are getting the total sum of all the salaries which were present in the salary column so this works the same way on how we are trying to fetch the details from the table it's just that while fetching the details like while fetching any of the column we are providing an aggregate function to get a collated data or to get a collated result of all the rows which is present inside our column or all the records which is present in a single column now let's go ahead with the third aggregate function that is average now it computes the average of all the values in a numeric column again for average also we need a column to be numeric it can't hold any Vare or string values it needs to have a numeric value and whenever we want the average of all the numeric values we can use this average function now it finds the average or the middle number of the numbers in a list so consider that company wants to know that what is the average salary they are giving to the employees so they can use this average function which can tell you okay this is the average salary a compan is giving to their employees or this is the average fees we are getting from the students you can take that example as well so here you can see the query where we are getting select and then we are giving the aggregate function that is average then we are providing the column on which we are doing this aggregate function that is salary and then we are giving from and then we are providing the table name that is employee now this query will tell the average amount company is paying to its employee so let's see the average function as well so we will see for the average function the average aage salary company is giving to its employees so we will give select average and then we will provide the column name that is salary so always make sure that these uh functions like salary sum it works only on the numeric columns so you can't use that in a column which is having Vare or string values so average salary and then we can give from and then we provide the table name that is employee so let's just execute this query so here you can see we are getting the average salary a company is paying to their employees so let's look at the fourth aggregate function that is minimum so minimum help us to find the smallest number in a list so whenever there is a list and we want to find the minimum value or the minimum salary uh company is giving to its employ we can use this minimum function in the same way we can also use a maximum function which tells us the maximum value in a particular column so this minimum function tell us the minimum value that is min n tell us the minimum value and MX that is maximum tell us the maximum value so here you can see the query we have given select and then we provide the aggregate function that is minimum and then the column on which we are providing this aggregate function that is salary and then we provide from and which table name that is employee so this will tell the minimum salary company is paying to its employee and in the maximum we do the same query it's just that minimum is replaced by maximum so we give select Max and then we provide the column name that is salary and then we provide from and then we provide the table name that is employee so this will tell the maximum salary company is paying to its employees so let's go to the mysl workbench and see how it's working so the next aggregate function is minimum so we will give the query as select minimum and then then we will provide the column name that is salary and then we will provide from and then we will provide the table name that is employee so let's execute this query so once you execute you can see that you are getting the minimum salary as 1,500 let's just verify 1,00 is the minimum or not so let's see all the details of this employ table so here you can see that the salar is 1500 2,000 2500 2400 and 1500 so500 is the minimum salary which is present in our employee table and in the same way we can find the maximum salary as well so we have to just replace minimum with maximum that is MX so we'll just replace minimum with maximum and we will just execute this query so once we execute we can see the maximum salary is 2500 let's just verify from our table details also that if the maximum salary is 2500 or not so if we run this query we can see that there is 1500 2,000 2500 2400 and 1500 so from here also we can verify that 2500 is the maximum salary which a employee is getting so while we were learning about Clauses in SQL I left these two Clauses Group by and having claes so let's know that why I left both of that Clauses and let's see that how are they helping us so what is this group by Clause so whenever we want to group data we use the group by Clause so this Clause is used to group rows that have same values into together it helps to organize data into groups so that they can do calculations like finding totals averages for each group so in the last particular video of aggregated function we learned that if we want to perform any operation or any function on some cated set of data we use the aggregated function consider that there is a salary column in my employee table if I want to know the minimum salary among all the particular rows which are present in my table we can use the minimum function if I want to know the maximum salary we can use the maximum function which will see in all the rows and give a single result on this collated set of rows now how this group by Clause help us so consider that for now we were finding the salary the minimum and maximum salary for all the employees but consider that there are some departments in the employee so one is the IT department one is the HR department one is the marketing department now what if I want to know the minimum salary in in the IT department or the maximum salary people are getting in the HR department it we have two employees E1 and E2 in HR we have two employees E3 and E4 in marketing we have three employees E5 E6 and E7 so earlier what it used to do in aggregate fun it used to see for all the employees E1 E2 E3 E4 E5 E6 E7 and used to provide us the minimum and the maximum salaries but now what will happen that it will see only in a group of data like only in the IT department there are two employees among the two employees give me the minimum salary or among the three employees in the marketing department give me the maximum salary so you can see that how we are working on a group of data so this can be achieved using the group by Clause now the query retrieves the first and rows from the table so let's see the query so the first is Select and then we provide the column name on basis of which we are grouping all the rows so basically here we are grouping the rows on the basis of department so we will provide department on like basically the column name on basis of which we are grouping all the things now then we will provide the aggregate function and then we will provide the column on which we are providing the aggregate function function like I'm grouping all the fields based on department now in the department they are grouped into ITR and marketing and now in the department we are finding this minimum or maximum using the salary so salary is basically the column on which we are using the aggregated function in which we are trying to get the collated data and then we are also grouping the uh all the values on basis of the department so basically we provide the aggregated function then we provide the column two that is salary and then we give from and then we provide table name and then we provide this group by clause and then we provide the column on basis of which we are grouping the elements that is column one so here you can see that an example is given here where I'm selecting department and then I'm giving the aggregate function average and then I'm providing on which column I using the aggregate function that is salary and here you can see that I've given a as so basically what as does is it will calculate the average salary and it will create another column with the name average salary and it will show all the details which is present here and then we give from and then we provide employee and then we provide the group by clause and then we provide the column on basis of which we are grouping the elements this is how the group by clause work if you are still not understanding that how the group by Clause work let's just understand it again so let me just clear all the data which is present here and we will then see that how this group by Clause is working so let's take an example consider that there is a table of employee now in this employee table we have department and salary for now I am only taking two columns just to make it a bit simpler and then here are the details of some of the employees so one of the employee is in IT department the next employee is also in it Department one is in HR one is in marketing let's take one more so that is also in HR and now the salaries are 1,00 1200 1100 1500 1100 now what this particular query will do so what it will do it will select department now it will select the department column so it will select the salary column as well now what it will do it will Group by the department so what it will do it will make the group of department so the very first group which will be present will be of it now it is having 700 as salary and 12200 as salary for two of the employees then it will make a group of the HR department basically the similar values will be together so it it both are similar so that will be in one group now HR are we finding any HR so HR is also present here so we have two values for HR as well first is 1100 second one is also 1100 now the next one is marketing is there any group for marketing present no so there is only one employee in marketing that is 1,500 so we have formed three groups it HR and marketing and we have G the respective salary of all these three groups now what it will do now it will perform this aggregate function which is average salary so what it will do it will find the average salary between these two employees and it will give a single result of the average salary for IT department then it will perform the aggregated function on these two groups and then it will provide the average salary for the HR department now it will do U like there is a single element so it won't do much of the thing so it will just provide the average salary of the marketing department which will be 1,00 only so in this way we can find the average salary per department so in this way we are trying to group The the data and in this way we are trying to aggregate the data and perform some aggregated functions on the data so let's see from the MySQL workbench then it would be more clear from there so let's go to the mysl workbench so let's see that how Group by Clause is working so what I'll do is I'll give the command select and then I'll select Department because I want to group them on the basis of department and then I will give that what I want to do the aggregated function on so basically I want to do the aggregated function on salary I give this average salary and then I'll give from and then I'll provide the table name that is employee and then I'll provide the group by Clause Group by and then I'll provide the column name on the basis of which we are grouping the elements so we are providing as department now in the query if you remember I provided this as and then I've provided a new name that is average salary so let's see that what it will do so I'll provide as and then I'll provide a average salary column like a new column name so let's just execute this query so here you can see that we are getting Department as it HR marketing finance and here you can see that a new column with the name average salaries is having all the values of the average of it the average of HR department the average of marketing and the average of Finance so in this way this as function works so the next one is the having Clause so the having Clause is just like the wear Clause but the main difference is it works on aggregated data so wear Clause can work on non-aggregated data but having Clause is something which only works on an aggregated data or collated set of data so it is used with the group by clause and it helps to filter groups based on a given condition so consider that if we want to give some condition during grouping of the elements we can use the having Clause earlier whenever we want to provide any condition we were using the we Clause but whenever we are providing any condition on a collated set of data or aggregated set of data we use the having Clause so here you can see the query so we give select and then we provide the column on basis of which we are grouping the data then we provide another column on basis of which if we want to group the data on basis of two columns so we provide both the columns and then we provide the aggregated function and then we provide the column three or like the column on which we are aggregating the data and then we provide this from and then we provide the table name and then we provide this group by clause and then we provide like on which columns we are grouping so column one and column two and then we provide this having clause and here we provide the condition so whenever I want to provide any condition uh during Group by clause or in aggregated function we use this having Clause now here you can see that we have given an example where what we are doing is we are selecting the department and we are taking the average salary as salary so basically we are grouping all the Departments and we are taking the average salary from all the Departments so from here we give the table name that is employee here what we are doing is we are grouping all the rows which are present in our columns into a single coated groups like it is having one group HR is having one group Finance is having one group basically all the similar type of elements in one group and then here we are giving a having an average salary is greater than 1500 so here we are providing a condition so what it will do it will first group the Departments so it will group the department into different departments like it HR and finance now for each and every Department it will find the average salary average salary and average salary and at the last it will check that if the average salary is greater than 1500 or not if the average salary is greater than 1500 it will show this particular result in output if the average salary is not greater than 1500 it will not show the given result in output same goes with the HR department and same goes with the finance department so let's see from the myol workbench that how this having Claus is working and how it is helping us to provide conditions so we will give having clause so here what we are doing is we are cating all the given rows of the column Department into some single groups and in that particular groups we are trying to find the average salary after finding the average salary of each group we are checking that if the average salary is greater than 1,500 or not so let's see how it works so we'll give select and then we will give department and then we provide the aggregated function and then we provide the column name in which we want the aggregated function that is salary and then we provide this as average salary to show it in a different column then we provide from and then we provide employee and then we provide how we want to group the data so Group by and then we provide the column name that is department and then here we provide the Clause having Clause so having and then we provide the condition so here we have renamed the average salary as ajs l a r y so we will use this particular column name and we will just give average salary is greater than 1,500 and let's just execute this query so once you execute this this query you can see that we are getting only the department of it HR and marketing with the average salary as 2,000 2,000 and 2,400 so all the average salaries which are present in this particular column are greater than 1500 what if we we don't give this having clause and we see that what is the average salary per department so if you run this query so you can see that there is a finance department also which is having an average salary as 1,500 but we are not able to see the finance department in this particular query because we have given a check that average salary or a condition that average salary should always be greater than 1,500 what if I give it as greater than or equal to, 1500 so let's see if we are able to see the finance department now or not so if I run this query here you can see that we are seeing the details of the finance department Also let's see all the Departments who is having average salary greater than 2,000 so we will be only seeing one result so let's see so here you can see that we are seeing only one Department that is marketing that is having average salary greater than 2,000 so this is how the group by and the having Clause work having Clause is mostly used with the aggregated function and it's just like the way Clause we provide the condition in the having Clause Group by Clause is mostly used with the aggregated function whenever we want to collate all the rows into a particular group who are having the same values so consider in Department if there are five it Department we can group all the IT department into one single group like uh if in a school database there are many classes class one class 2 class 3 we can group class one into one group class two into one group class three into one group and then we can see that what is the average fees class one is giving what is the average fee Class 2 student are giving what is the average fee class three student are giving now in the next set of video we would be see seeing about some practice question which would be helping us to get ourselves familiar with the group by order by having and limit Clauses so uh when I was teaching about this having Clause many people had a doubt that why are we even knowing about this having Clause like what this having Clause is doing having Clause is basically helping us to filter out data based on a given condition so was the we Clause then what was the need of having Clause so what is the wear Clause we Clause is a clause which is basically used to filter rows from the result based on a condition applied to a row before aggregation so whenever we want a filter data based on a condition from a table we use the we Clause but wear Clause is always used before aggregation now what is this aggregation so aggregation or you can say aggregate functions are the functions which work on some collated or collected set of data and returns a single value based on some manipulations like if we want to find the maximum salary if we want to find the minimum salary among all the employees we can use the aggregate function so aggregate function mostly works on a collated or collected set of rules so whenever we want to work on some collected or collated set of rows we use the aggregate function and here it is saying that where Clause is clause which should always be used before the aggregate functions it means that we should always be using it on an individual rows not some group of rows or collected rows now what is having Clause so having Clause is a clause which is used to filter rows from the result based on a condition applied to a row after aggregation so whenever we have formed a group such as like there is a group of IT department people there is a group of HR department people there is a group of marketing department people now in this particular groups if we want to provide any condition to filter out some data we use the having Clause so wear Clause is mostly used before the aggregate functions and having Clause is mostly used with the aggregate function now where Clause is mostly used with the select update and delete SQL commands whereas having Clause is mostly used with the group by clause and the aggregate function now what we do is we form some groups on that particular groups we perform some aggregate functions and this aggregate functions returns us a single value and on that particular value we perform any condition using the having Clause so having Clause is mostly use with the group by Clause along with aggregate functions now the query for the we Clause is Select and then we provide star which basically means all and then we provide from and then we provide the table name from which we are making the query and then we provide this where followed by the condition in having we mostly give select and then we provide the columns on which we are grouping the data then we provide the aggregate function and then the column on which we are performing the aggregate function then we give from and then we provide the table name on which we are performing the having clause and then we provide the group by and then the columns on which we are grouping the data that is column one and column two and then we provide this having and then we provide the condition so having Clause mostly works with the group by clause and the aggregate functions whereas we Clause mostly works with the select update delete commands we Clause is oftenly used whenever we want to filter out some data based on some condition before the aggregation happens whereas having Clause is mostly used to filter out data based on some given condition after the aggregation happens so this was the basic differences between where and having Clause so the very first practice question is write a query to find the total number of employees in each City so what we have to do is we have to find the total number of employees which are present in each City so let's just break the question and and then we will see how the query works so first we have to find the total number of employees so to find the total number of employees here we can use the aggregate function so in the aggregate function we can use the count function which basically counts the number of employees or counts the number of rows which are present so this will help me to find the total number of employees now the second sub part is in each City so what I have to do is I have to find the total number of employee in each City so there could be multiple City like Mumbai Bangalore Hyderabad and much more now I have to find the total number of employees who are present in each City so there could be a possibility there are two or three employees who are living in the same city so what we will do is we will here use the group by Clause so basically this Clause will help me to group all the data which is present in Mumbai which is present in Bangalore which is present in Hyderabad and then in these group of employees we will count all the employees which are present in this particular cities so what we will do is we will give this select and then we will provide the column on basis of which we want to group the data that is City because here it is given in each city so we will give City and then we will provide the aggregate function count and then we have to provide the column name on which we want to count so so we can either count on the basis of Name ID uh salary and much more things so for now we will use the name and then there is as and then there is a temporary column name or an alas name for this particular column so what it will do is this count name will provide me a result or a value and that particular value would be shown in this number of employee so it is kind of acting as an alas for a particular column name now then we will provide from and then we will provide the table name from which we want the specific results and then we will provide the group by clause and then we'll provide the column name on basis of which we want to group the data so so this will help me to find the count of employees and this will help me to group all the employees on a particular City so these both together will help me to find the count of employees who are in each City now let's see from the MySQL workbench that how this quer is working so to understand all those query I've already created a company database inside that company database I've already created an employee table and in this particular employee table we would be performing all the queries so let's just see what are all the details which are present in this employee table so we'll just execute this query and here you can see that I feeded the data of almost five employees with their name age Department City and salary now the very first practice question is we want to find the total number of employees in each City so for that we'll give the query as select and then we'll provide the column name on basis of which we want to group the data that is City and then I'll provide the column name on which I want to perform the aggregate function basically count the total number of employees so I'll give name and then I'll provide an alas for this particular column name as number of employees and then I'll provide Group by and then I'll provide the table name so from employee and then I'll provide the group by clause which will help me to group the cities into some subgroups so I'll give Group by city so let's just execute this query so here you can see that we have got the city and we have got the number of employees who are there in each City so for Mumbai there are two for Pune one for Surat 1 and for indor 1 so this particular query will help me to find the total number of employees who are present in each City now let's see the next practice question write a query to find the maximum salary of employees in each City in descending order so we have to find the maximum salary of employees in each City and then we have to order it in descending order so let's just break this particular question into some sub questions and then we will write the query so first what we have to do is we have to find the maximum salary of employee so to find the maximum salary of employee we can use the aggregate function Max and here we can provide the column on basis of which we want to aggregate the data that is salary now the next set says that in each City we have to find the maximum salary of employee in each City so to get the group of cities we can use the group bye Clause so here we'll use the group by clause on city which will help me to get all the subgroups of city or all the cities into some similar subgroup so let's see the query so here in the query we have provided select and then we have provided the column on basis of which we want to group the data data City and then we have provided an aggregate function Max on the column on which we want to get the aggregated data that is salary and then we have provided an alas for this column name as Max salary then we provide the from and then we provide the table name from which we want this particular data and then we provide this group by clause and then we provide the column name on which we are grouping the data data City and then we provide the order by Clause followed by the column name on which we want to order the data so I've missed it here so the column name would be Max salary because I have already created a Max salary column name which is having all the maximum salary from the particular group so we'll provide the column name as Max salary and then we will provide the manner in which we want our data that is descending so let's see from the MySQL workbench so here we want to find the maximum salary of employees in each City in descending order so what we will do is we'll give the query as select and then we'll provide the column name on basis of which we are grouping the data that is City and then I'll provide the aggregate function and then I'll provide the column on which we are aggregating the data that is salary and then I can provide an Lees for this that is as let's give it as Max salary and then I'll provide the table name that is from employee and then I'll provide the group by Clause so Group by and then I'll provide the column on which we are grouping the data dat a city and now we want to see all our result in descending order so we will be using this order by Clause so we will use order by and then we can use this particular column name because it has all the aggregated set of data for each city so we would be using Max salary and then we'll provide the manner in which I want to see my results so select then the column name on basis of which we are grouping the data then the aggregate function on the column name on which we want the aggregated data such as maximum salary and then we can provide an alas for that particular column then we'll provide the table name then we'll provide the group by Clause followed by the column name on basis of which we are grouping the data then we can use this order by Clause to get our particular result in descending order so here you can see that we are getting an error the reason behind getting this error is in the earlier query we haven't ended the query so will provide a semicolon and you can see the error is gone now now let's just execute this query so here you can see we are getting all the groups of city and here we are getting the maximum salary in all the groups and the maximum salary is sorted in descending order so this is how we can group the data and get the result in some specific order so let's see the next query so the next query is write a query to display the department names alongside the total count of employees in each department sorting the results by the total number of employees in descending order so what we have to do is we have to display the department names so we have to display the department names which are present in our employee table so we'll use the group by Clause now alongside that we have to display the total number of employees in each department so we have to tell that if there are three Department it HR and marketing now in this particular Department how many employees are there so for that we can use the count aggregate function to get the count of all the employees who are present in each department and then we have to sort the result of total number of employees in descending order so we have to sort the result of this total number of employees in descending order so we can use the order by CL so whatever result we get from this count aggregate function on some specific group of departments we have to order the result on basis of that so whatever is the result from this count we have to order our results on basis of that so we have to use the group by clause for the Department name then we have to use this count aggregate function to find the total number of employees and then we have to order our results based on the result we get from count for each particular department so very first we will provide the select command to make some query and then we will provide the column name on basis of which we want to group our data so basically it's Department names and then we'll provide the aggregate function and then we'll provide the column on basis of which we want to perform this aggregate function so here we want to find the total number of employees or total count of employees so we'll use the count aggregate function and then we'll provide a column name on which it will count all the total number of employees in each department and then we'll give an alas for this as total employees then we'll provide the table name that is employee and then we'll provide the group by Clause followed by the column name on basis of which we are grouping the data that is department and then we'll provide the order by clause and then we'll provide the particular column on which we want to order our data that is total number of employees and then we'll provide the manner in which we want to order our data that is descending order so let's see from the MySQL workbench we'll give the command as select and then we want to group Department into subgroups and then we will provide the aggregate function that is we want to count the total number of employees and then we'll provide the column name on basis of which we want to perform our aggregated function and then we'll provide an alas for this that is total employees and then we'll provide the table name on which we want to perform these operation that is employee and then we will provide the group by Clause followed by the column name on which we are grouping the data that is department and then we will provide the order by Clause followed by the column name on which we are ordering the data that is total number of employees so that is total EMP and then we will provide the manner in which we want our data that is descending so let's just execute this query so here you can see that we are getting all the department that is it HR marketing and finance and here we are getting the total employees in each department now here you can see that all the result has been sorted in descending order like it is having two employees so it is at the very first and then all other departments are having one one employees so they are sorted on basis of that let's see the next practice question write a query to list the Departments where average salary is greater than 12200 also display the department name and the average salary so we have to write a query to list all the Departments where average salary is greater than 1200 so firstly we have to list all the Departments so we'll be using the group by clause for the same and we'll be grouping the data on the basis of department so we have group the data we have list all the department then we have to find the average salary greater than 12200 so then we have to find the average salary for all the Departments so we can use this avj function from the aggregate function which will help me to find the average salary for each department so it will give me the value of average salary for consider it HR marketing department now there is a condition that we have to find the details of employees who are having average salary greater than 1200 so from here we'll be getting a result and here we'll be using the having Clause as we are providing a condition to filter our data so we'll be using the having clause and with the having Clause we'll provide the average salary greater than 12200 that is result of average salary for each particular Department should be greater than 1,500 so we have to display the department name as well as average salary so let's see the query so first we'll give the select command to make a query and then we'll provide the column on which we are grouping the data that is department and then we'll provide the aggregate function and then we'll provide the column on which we want to aggregate our data that is salary so here you can see that we are uh doing some condition or performing some condition on the average salary so we have to find the average salary first and then we'll provide an alas followed by the column name for which we are providing an Alas and then we'll provide from and then the table name and then we'll provide the group by Clause followed by the column name on which we are grouping the data and then here we'll be using having Clause because having Clause is mostly used with the aggregated set of data so here we have already aggregated some set of data and here we want a condition that is average salary is greater than 12200 so we'll provide the having clause and then here we'll provide the average salary and here uh sorry it's by mistake return return is 5,000 so the average salary should be greater than 12200 either here we can provide this avj salary or we can use the alas name that is average salary as well so in this way what it will do is it will group the department into some sub departments or subgroups that is it HR and marketing then it will find the average salary of all the employees which are present in it average salary and for HR and for marketing and when we have got the average salary for all the groups then we will perform the having Clause that is having and then we'll provide the condition that is average salary should be greater than 1,200 sorry here also I have by mistakenly told that average salary should be greater than 1500 so it would be 1,200 so we have to find the list of departments where average salary is greater than 1 12200 so let's see from the MySQL workbench so we'll just write a query so we'll give select and then we will give the column name on basis of which we want to group the data that is department and then we'll provide the aggregate function so basically we want the average salary so we'll use average and then we'll provide salary and then we'll give an alas that is aage salary and then we will provide the table name so from employ and then we'll provide the group by Clause to group our departments so we'll provide Group by and then department so our department have been grouped now we want to provide some condition to the group data so we'll provide having and then we'll provide the column that is average salary and then we'll provide the condition that is greater than 1200 so show me the department of all the employees who are having average salary is greater than 12200 so let's just execute this query so here you can see that you can see four departments it HR marketing and finance and here you can see the average salary that is greater than 12200 greater than 1200 greater than 1200 and greater than 1200 so this was all about the practice question in this particular video this practice questions are very important so try to practice this try to break the questions into sub question and try to make query from the sub question so here you can see that I provided a table in which I have provided the rank in which we should be using all the particular commands and then we have provided the commands and then we have provided the use case for that particular command so it's not possible that you are providing a condition to any of the column or any of the set of rows before even telling the MySQL server that these are the columns on which I want to provide the condition so where can never happen before the select command so first command is the select command so select command is basically used to retrieve data from the database so the very first thing what we do is we first retrieve the data from the database then now the next is from command which help us to identify the table now in a particular database there could be multiple tables so I need to tell my database that from this particular database I want this particular table the third one is wear clause which help us to provide any condition or filter the row based on some specific condition so we have retrieved the data from the database we have provided the the table from which we are retrieving the data then we can provide the conditions on that particular data which we are retrieving then the fourth one is Group by clause which basically works on the aggregate function so if we want to perform any aggregate function we can use this group by Clause after wear why we are using this group by Clause after wear because wear is mostly used before the aggregated function and having is mostly used after the aggregated function so using the group by Clause we can group the rows that have the same values based on some aggregate function and then we can use this having clause which help us to filter groups based on some condition so wear Clause help us to filter rows based on some condition whereas having Clause help us to filter groups based on some condition and then at the sixth number we have the order by Clause so we have retrieved the data we have identified the table we have filtered some rows on the table we have grouped the rows we have filtered some group on some basic condition and then we want to sort the result either in ascending or descending order so we can use the order by clause and at the very last is the limit we have retrieved the data we have filtered the rows then we have grouped the data then we have filtered the groups then we have sorted the result now I want to limit the number of rows which are result in our final result so this is the general order of SQL commands which we follow while making any of the queries in SQL so what is joins in SQL as the name suggest join so basically we are joining something to get a desired result so joints are used to combine rows from two or more tables based on a related or shared or common column between them so whenever we have two or three tables who have a related or a common column between them like uh consider an example of ID so the ID column is present in the student table the course table and the course details table as well so that particular ID column is a shared or a common column between all those three tables so we can just join them and get all the related details we want from all these three tables there are commonly four types of joints so the very first one is inner joint then there is a outer joint which consist of left joint right joint and full joint and then there is a self joint and then there is a cross joint now in these particular tables you can see there is a student table and then there is a course table in the student table also we have an ID column in the course table also we have an ID column so since they both have a common or a shared or a related column we can perform join operations on them to get the details of name age course ID course name for a particular student now as I told that there is a shared or common column between these two tables so there would be a doubt which would would be coming to your mind is whenever there is a common column between two tables we establish a relationship using foreign keys so is foreign key important for performing joints so the answer is joint can be performed based on any column that establish a relationship between two tables not just foreign key constraint so it's not necessary so it's not necessary to have foreign key present in one of the table even if there is no foreign key but there is a column which is kind of present in another table as well we can perform the join operation so foreign key is not a must have if uh two tables are having a foreign key relationship we can perform join on them if there is no foreign key present in any of the table still we can perform joint operation on them because uh we only need a shared or a common column between two tables now let's see on the types of join so the very first join is the inner join now as the name suggest inner join so basically we are trying to fetch all the inner details from two tables so there is table one and table two that is a and b now in this particular table a we are calling it as left table the table B we are calling it as right table so whenever we perform inner join among any two tables A or B we get the common values between them in the inner joint so basically the values which are present in left table as well as the values which is present in right table we get the value as result whenever we perform the inner joint so here you can see that there are two tables student and course so if we want to perform any inner joint among them what it will do is it will search for the common column so the common column is RW number now in that particular common column it will find the values which is common among both of the tables so one is there any value of one here so it would be discarded then uh two is there any value of two here yes so we will be printing two Hindi along with two Rahul whenever we perform an inner joint and then three there is a row with the value as three so we will will be printing three repe along with the subject as English so in this way we get the common values which is present between left table as well as the right table now the second joint is the left joint or we can also call it as left outer joint now in the left outer joint what happens is if we get all the values which is present in left table along with the values which is present in left and right both of the table so basically we get all the values which is present in left table so consider for now student is the left table and course is the right table so we will be getting all the values which is present in left table that is 1 2 and three and we will print the name for all the three and and then we will come to this particular table so here we can't find the r number one so for now null would be assigned to that particular person RAM and then for two we can get Hindi and then for three we can get English so mostly we will be first taking all the values of the left table and then we will be seeing that in this particular left table what are the values which are common in the right table and we will be taking that now the third one is right join or right outer joint so it is kind of similar with the left outer joint there is just one difference that in this particular joint we take all the values from the right table along with the common values between the left and the right table so if this is the left table and this this is the right table we will be taking all the values which is present in the right table and then we will find the common values which is present in the left table and then we will display all the particular details but in the right table you can see a r number four who has opted maths but here you can't find the r number four so for that particular column we will fill null in the name so mostly in the left and right outer joint whenever it doesn't find any values in the next column it just fill the null value now the fourth join is the full joint or full outer joint in this particular joint we take all the values of left table right table along with the common values between them so all the values which is present in left table would be taken all the values which is present in right table would be taken and all the values which is common between them would be taken so if there is two tables left and right so we will take all the values which is present in student table we will also take all the values which is present in course table now for the course table the values which is not present in student table we will fill as null and for the student table the values which is not present in the course table we will fill as null so here C name would be null for RO number one and here name would be null for R number four now the fifth join is the self join or we can see that whenever we perform join on the same table that is called a self join so consider that there is a table student and if we want to perform a join on the same student table we can use the cell joint for the cell join we would be learning more in the further videos for now you can understand that whenever we are performing any join operation on the same table we use the cell join now the sixth one is the cross joint so in the cross joint what happens is can consider that there are two tables A and B so what happens here is if there is any Row in the a table it will go ahead and do a cartisian product with all the particular rows present in the B table then the second row of the a table would do the cartisian product with all the rows which is present in the second table and then the third row will go ahead and do the cartisian product with all the rows which are present in table B so what happens in crossjoin is now R number one and RAM would form a pair with ro number two Hindi then with r number three English and then with ro number four maths then RO number two will go ahead and form a pair with ro number two Hindi RO number three English and RO number four maths in the same way RO number three will go ahead and form the pair with r number two R number three and R number four so there is a cartisian product or there is a cross joint which is happening that one particular particular element of a given table is going ahead and doing a cross product with all the elements or all the rows which is present in table B so that is why it is called as a cross joint and in the cross joint the number of rows in the final table is M into n so consider that in the student table there are M rows and in the course table there are n rows so the final table would be having M into n that is 3 into 3 N9 rows so what is inner joint inner joint help us in getting the rows that have matching values in both the tables according to the given joint condition so whenever we want the values which is matching on both the tables we use the inner joint so consider that there are two tables A and B whenever we want the values which is present between both the tables that is this particular value we use the inner joint now here you can see that there are two tables customer and Order and here there is one column which is common between both the tables that is ID so what we need to find is in both of these tables customer and Order give me the values which is present in customer as well as order table so let's see is 101 present in the order table no so for now this is discarded then 102 is 102 present in the order table yes so this is the value which would be returned in our final result then it will check for 103 is there any value with the 103 existing in the order table yes so we will be returning 103 as well so it will give me all the values which is matching between both of these tables so the query for the same is we give select and then we provide all the columns which we want to see the data among both the tables then we provide this from and then here we provide the table one that is this particular table customer table and then we perform this inner joint and then we provide the table two name that is order and then we provide on and then we provide the condition on basis of which we are performing The Joint so the condition is table 1 do column name so this dot column name basically refers to a column which is present in table one so table 1 do column name should be equal to table 2 do column name so basically the column which is similar between both the tables perform the inner joint on that particular table now here you can see that at the first I have given the table one and in the second I have given the table two so can we reverse this order so for inner join we can reverse the order because ultimately we are focusing more on getting the Val which is common between both the tables so even if table two is on the upper side and table one is on the lower side it doesn't affects our result but when we go to other type of joints we have to maintain the order in which we want to fetch the data so let's see from an example so uh this is the query which Returns the rows where there is a matching ID in both the tables so what it will do it will give select and then it will provide star so it will get all the columns which is present in both of these tables and then we will provide from and then we will provide the table one name that is customer and then we will perform this inner joint and then we'll provide the table to name that is order and then we'll provide on which particular columns these values needs to be in ajoin so for customer we are using the column as ID and for order we are using the column as ID so in both of these tables ID is the similar or a common or a shared column so on ID we are performing the inner join and we want to see all the details of uh particular customer as well as their orders so whenever we perform this particular query we will get the result as this so here you can see that among all the IDS which is present in customer and Order table the ID 102 and 103 three are common among both the tables so we'll get the details for 102 and 103 then we'll get the name which is present in table one and then we'll get the ID which is again present in table two and then we'll get the order name that is fruit in the similar way we will get for 103 re 103 is the ID which is for the second table and then the order name as ball so if we want to eliminate this ID which is being repeated twice we can provide the column name specifically from which we want to fetch the data so here we can provide ID name and Order name but if we provide star it will fetch all the columns which is present in table one as well as table two so let's see from the MySQL workbench so here to perform the queries let's just create a e-commerce database in that particular database we would be creating two tables one is the customer table and the second one is the order table so I've already written all the queries just to save time so but I'll be executing all the queries just now so here you can see we are executing this create database e-commerce so we'll just execute this query we have got a success here if we do a refresh all we can see a database with the name e-commerce is created which is right now having no tables so we'll then tell the MySQL server that we want to create all the tables inside this particular data so we'll just execute this query use Ecom and then we will create a table with the name customer which is having attributes such as ID and name then we will fill some data into this particular customer table so let's just fill the data and then we will see that if all the datas are filled or not so let's see so we have provided the details of five employees we have provided their name as well now let's create a audit for that again we will tell the myos server that in this particular database we want to create the table so we will execute this use followed by the database name then we will create the table for the orders so here we have got a success here if I do a refresh all so in the tables you can see that we have created two tables first is the customer and second one is the order so let's just fill some details in the order table as well so we'll just execute this query so this is a success and then we will check that if all the details are filled in our order table or not so we'll just execute this query so here you can see that we have filled the details for three of the orders along with their ID now we want to perform a inner join on both of the tables now both of the tables have a common column between them that is ID which is present in the customer table as well as the order table so let's perform the inner join basis on ID and then we will try to fetch all the particular details which are there in customer like ID name and then in order like ID order name for all the values which are common between both of the tables so let's just write the query select and then we will give star and then we will give from and then we'll get the table one name for now we can give any of the table but let's just take the customer table as table one and then we will give the inner join and then we will give the table name on which we want to perform the inner joint that is order and then we will provide the condition on which we are joining that is on customer do ID which basically tells that in this particular customer table we are fetching the ID column is equal to orders do ID because this is the shared column between customers as well as order so let's just execute this query so on executing you can see that we are getting the details of only three of the IDS that is 2 three and four which was common among both orders as well as customer now we are getting the name then again we are getting the ID from table two and then we are getting the order name if it doesn't want to see this replicated column so let's just give the query here as customer do ID so this will give me the customer ID this particular dot is basically used to refer to a column which is present in this particular table then we will give orders do order name and then we will give this customer dot name so what this will do is this will give me the ID from customer table name from customer table and Order name from the orders table so let's just execute this query so here you can see that we have removed that replicated column that was ID so here you can see that you are getting the ID you are getting the order name and you are getting the name so in this way we perform the joint we basically get all the details from both the tables using the common of the shared column between those table in inner joint we basically focus more on the common values which is present in both of the tables so left outer join is a part of outer join now it is used to fetch all the records from the left table along with the Matched records from the right table so consider that we are having two tables A and B and a is the left table and B is the right table so in the left order join we get all the details of the left table along with the values which is common between A and B table so we get all the records from the left table along with the Matched records from the right table so we get this entire detail using the left outer joint now if there are no matching records in the right table null values are returned for The Columns of the right table so if there is no matching record which is found in the right table consider that in the left table there are records as 1 2 and three and in the right table there is only two and three so for the left table it will take all the records 1 2 and and three but there is no one which is present in the right table so for that the values for the right table will be filled as null or the columns which is present in the right table will be filled as null so here you can see the query so we basically have select and then we provide all the columns which we want to show in the final result and then we provide from and then we provide table one so here table one is the left table we need to maintain this order because eventually we want all the details of the left table if we reverse the order we will get all the details of the right table so we need to maintain this order so we'll give from and then we will give the table one and then we will give the left joint and then we will give the table two so basically we are performing a left join on table one which is taking all the details of table one and then the match details between table one and table two and then we will provide the condition on which table 1 do column name is equal to table two do column name so perform the left order join on table 1 and table two on the basis of the common column which is present between table one as well as table two so what is the left table the table specified before the left join keyword is called as the left table that is table one and the table which is specified after the left join keyword this is the right table so table one is the left table and table two is the right table now let's see how it is happening so there are two tables customer and order so here customer is the left table and order is the right table now in the left outer join what will happen it will take all the values of the left table and then the common values between the left as well as right table so firstly it will take all the values of the left table that is 1001 1002 and 1003 so it will take 10012 and 1003 then it will find the common values between these two tables so here is id101 present here no ID 10 01 is not present here so for now for order table we will fill the null values for ID 101 now is ID 102 present here so yes the ID 10 02 is present here so we will take the value as 102 and fruit so we'll take the value is 102 and fruit now is the ID 103 present here so yes the ID 103 is present here so it will take the ID as 103 and the order name as ball so it will take ID 103 and Order name as ball so for the ID 101 it didn't had any of the entry in the table two so it fill null value for all the columns of the table two so let's see from the MySQL workbench that how it is happening so here we performed the inner Jo now let's perform the left outer joint so we will just keep select we'll use the same tables customer and the order table so we'll provide select and then for now let's see all the details so we will provide star and then we will provide the table name from customer and then we will provide the join like type of join so we'll give left join and then we'll uh provide the right table name so the right table name here is orders and then we will provide the condition so we'll give on customer. ID is equal to orders do ID so this is the condition on basis of which we are performing the left joint basically this particular column and this particular column is a shared column and they have the equal values so let's just execute this query so here you can see that we are getting the ID as one name as Rahul and here in the ID section for the right column we are getting null and null so basically the values which were not present in the right column we are getting as null and null then for the ID 2 there is a value which is present in right table so we are getting all the values for ID3 there was a value for id4 there was also a value for id5 there there was value only in the left table but there was no value in the right table so it is null and null in this way left outer joint performs so the right join or right outer joint is basically used to fetch all the records from the right table along with the Matched records or the common records which is present between the left and the right table so consider that there are two tables A and B A is the left table and B is the right table so in the right outer join we get all the details which is present in the right table along with all the common values or common records which is present between both the tables so we get all the details of of the right table along with the common values which is present between the left as well as the right table now if there are no matching records in the left table null values would be returned for The Columns of the left table so consider in the right table we have IDs as 1 2 and three in the left table we have IDs as 2 and three so for the right outer joint it will take all the details of the right table but here you can see that one is not present in the left table so for the left table columns it will fill null values now let's see the query so the query is Select and then we provide the columns which we want to see in our result and then we provide from and then we provide the table one and then we provide which type of joint we are performing that is right joint and then we give the table two name and then we provide the condition on basis of which we are doing The Joint that is table one column name should be equal to table two column name so left table is the table which is given before the right joint and the right table is the table which is given after the right joint so table two is the right table and table one is the left table so let's understand that how this particular right join is working so consider that there are two tables customer and the order table order is the right table and customer is the left table now in the right outter joint we get all the details of the right table along with the Matched values between left and right table so it will take all the values of the right table that is 102 103 and 104 so it will take one2 one3 and one4 along with all the values such as fruit ball and utensils so here you can see fruit ball and utensils now it will find the common values between these two tables so is 102 present here yes it's present 102 and rul so it will go ahead and fill the details of 102 and rul is 103 present here yes it's present so we'll fill the details of 103 and REI is 104 present here so 104 is not present here so will fill the values as null and null now let's see from the MySQL workbench that how it is working so it works in a similar fashion of left outer joint it's just that we get the details of right table rather than the left table so we'll give select and then we will provide star and then we will provide the first table name that is the left table name that is customer and then we will give the joint type that is right joint and then we will provide the right table name that is orders and then we will provide the condition on which we are performing The Joint so that is C customer do ID is equal to orders do ID so let's just execute this query so here you can see that we are getting the ID 234 we are getting the name ofar abhimanu adya now for the left table we are getting the ID as 234 and we are getting the order name as fruit ball and utensils all the details which were present in the right table were there in the left table so we are not seeing any of the null values so it is kind of giving me the common as well as all the values which are present in the right table so in the earlier videos we learned about left joint and as well as right joint now what happens in left and right joint so consider that there are two tables so this is basically a v diagram so there are two tables A and B A is called as a left table B is called as a right table in the right join also let me just draw a v diagram A and B A is the left table and B is the right table now in the left joint we usually get all the details which is present in the left table as well as the common details which is present between the left as well as the right table so if we I want the details of the left table as well as the common details between left and right table we use the left join now in the right join basically as the name suggest right so we get all the details of the right table along with the common details of the left and the right table so basically when I want the details of the left table along with the common details between left and right table I use the right joint and when I want the details of the left table along with the common details between left and right table I use the left joint now what is full joint so full joint basically Returns the matching rows of both left as well as the right table and also include all the rows from both the tables even if they don't have a matching rows so full join basically is a combination of the left joint as well as the right joint so in the left joint we get this particular area in the right join we get this particular area so let's name the area as C so in the left join we get a plus c and in the right join we get B plus C so basically in the full joint it is a combination of left joint as well as right join so we will get a + C + B + C now here I'll get all the details of a I'll get all the details of B and the common area between them that is C but here you can see that c is repeated twice so C is also occurring in the left joint C is also occurring in the right joint so is it like we will see the details of C twice so basically that doesn't happen I'll tell you the reason in couple of minutes but we usually get the details of a as well as b as well as C in the full outer joint now if there is no match null values are returned for the column of missing table so consider in the left table we have a column called as ID now in this ID we have one and two in the right table also we have a column ID but in this column we have only two and three so here you can see that for one there is no entry in the right table so if there is no match which is found we usually fill the null value now how we would achieve the full join in SQL so basically in the right join we were using the right join keyword in left join we were using the left join keyword so is it like in the full join we would be using the full join keyword let's understand so in MySQL the Syntax for a full joint is different compared to other SQL databases like postgress SQL or SQL Server so in my SQL to make a full join the query is slight different from other SQL databases so what is the difference my SQL basically doesn't support the full join keyword directly so we use a combination of left join right join and the union keyword to achieve the result so basically in MySQL we can't use the full join keyword so what we do basically the full join is a combination of left join as well as right join so we use the union keyword between them now the question which would be coming to your mind is what is Union and how it is helping us to achieve full outer joint so Union is basically a concept which comes comes in math wherein if there are two sets A and B and whenever we do a union between A and B it give me all the values which is present in a along with all the values which is present in B and then the values which is present in a as well as B without any duplicates so it eliminates the duplicates so this is the answer for the last thing where we discussed that full join is basically a combination of left joint as well as right joint in left joint we had a plus c in right joint we had B plus C so in the final result we were not getting C twice so the reason behind not getting C or this particular area twice is because we are using Union and Union basically give us all the details of A and B eliminating the duplicates so full joint is basically a combination of left joint as well as right joint now here is the query for the same so firstly we'll write the query for the left joint and then we'll write the query for the right joint followed by a union between them that is this so first we give select and then we provide the columns which we want to see in the final result then we provide from and then we provide the left table name followed by this left joint keyword and then we provide the right table name and then we provide a condition between which we are joining two tables so table 1 do column name is equal to table 2 do column name and then we provide this Union keyword and then we provide the right join that is Select followed by The Columns then from then the left table name followed by right join then the right table name and then the condition on which we are performing the right join so basically this is left join Union right join which will give me full joint so let's see from the myql workbench that how this query is working so here we have created a database Ecom in that particular database we have two tables customer and orders so we will be seeing about the full joint on these two tables only so here we have written some query for the left join which we learned in the last video as well as the right join now for the full join we need to provide a union between the left join query and the right join query so firstly let's see what all details are present in both the tables so first to see the customer table I'll be running this query select star from customer which will give me all the details all the columns which is present in the customer table so that is ID and name now let's see for the orders table so we'll run the queries select star from orders so here we can see that we have ID and Order name so in the full outer join what will happen is first there will be a left join between the customers and the orders table then there would be a right join between the customers and the orders table and then we'll provide a union in between them to perform the full outer joint so let's write the query so firstly we will write the query for the left joint that is Select and then the columns so right now we'll see all the columns and then we will provide from and then we'll provide the table name that is the left table name and and then we'll provide the left join followed by the right table name that is orders and then we will provide the join condition so on customer do ID is equal to ERS do ID now we will provide the union symbol so here we'll provide the union and then we will write the query for the right join so we'll give select and then here we'll provide star to see all the columns which is present in the right table then we will provide from and then the left table name that is customer followed by the right join and then the right table name that is orders and then we'll provide the join condition so we will give on customer. ID is equal to orders do ID this should be orders so this is the final query which we have made for first we have provided the left outer join query then we have given this Union keyword and then we have provided the right outter join query so let's just execute this query so here you can see that we are seeing all the details of the left table as well as the right table and the common thing between them so you can see that 2 3 and four these were common between left as well as right table so we are getting all the details uh ID name and Order name for the ones which were not common between the left and right table that is one and five for them we are getting ID as null and null or name as null and null because they were not present in the orders table so if there are no matching rows between two tables it provide the value as null there so this is the final result we get for the full outer join now as the name suggest cross joint so what we do in join we basically combine two tables so we combine two tables now what we do in Cross so cross is basically something we can say as a cross product so whenever we are performing any cross product between two tables that gives me a cross joint or that is the result of the cross joint now let's understand what is cross joint so basically in cross joint it combines each row of the first table with the every row of the second table so consider that the customer table is the first table the order table is the second table now according to definition each row of the first table is combined with each row of the second table so firstly we will get the result as one1 Ram with one fruit and two ball and then for the second row again it will combine with each row of the second table so it will be 102 Rahul with one fruit and one two Rahul with two ball so basically there is a cross product which happens between these two table and what we get in the cross join is we get the result of the cross product so consider that in the customer table if there are M rows consider it is 1 and two and here also the number of rows are 1 and two so for now we are considering variable so consider that there are M rows in the customer table and N rows in the order table so the product or the result of the Cross join is M cross n that is for this particular table it would be 2 cross two that is four so let's verify so firstly first row of the customer table would be cross joined with the first and second row of the order table so first result would be 101 Ram with one fruit and again 101 Ram with two ball then for the second row it would be 102 Rahul with the first row of this table that is one fruit and then again one2 Rahul with the second row of this particular table that is two ball so this would be the final result of the cross joint now here you can see that we are getting 1 2 3 4 so here we are getting four rows and if we do M cross n then m is the number of rows for the first table and N is the number of rows for the second table so here 2 cross 2 gives us four so basically it results in a new table where the number of rows is equal to the product of number of rows in each table that is M cross n now let's see the query for the same so here you can see the query so first what we give is Select statement and then we provide the columns which we want to see in the final result so here we have provided star which basically means all so we want to see all the columns which is present in the first table as well as the second table because join happens between two tables only now then we will give from and then we will provide the table one name and then we will give this cross joint and then we'll provide the table two name so it will give me a product which would be the cross joint between two tables table one and table two which would be having number of rows as table one rows into table two rows that is M into one so 2 into 2 that is 4 so this would be the final result of the cross joint let's see from the myol workbench that how cross joint happens and if we are able to get this result or not so let's see how cross joint happens in the customer as well as the order table so firstly let's see what all details are there in the customer table so we'll just hit select star from customer which will give me all the details in the customer table so there are five IDs with the name so it is having five rows and then let's just execute the order table as well so here there are three IDs so basically there are three rows so we will get 5 into three that is 15 number of rows in the final result so let's just do a cross joint so for the cross joint let's just use the existing tables which are present here the customer and the orders table and then we will see that how the cross join is even happening so firstly we'll see all the details of the customer table so we'll hit the select star from customer which will basically give me all the details of the customer so here you can see that there are almost five IDs and there are name of that particular IDs and here you can see that there are five rows so the first table is having five rows now coming to the second table that is the orders table we'll run the query so here we can see that there are three IDs present so there are three rows so 5 into 3 is 15 that means the final product or the final the final result we get after the join would be having 15 rows so let's do the join so first we will give select and then we'll provide the columns which we want to show in our final result so for now we want to see all the column so that we understand that how the join operation is even happening and then we will provide from and then we'll provide the table one name that is customer and then we will provide this cross joint keyword and then we'll provide the table two name that is orders so select star which will give me all the columns then I'm providing the table one name that is customer and then I'm providing Pro join and then I'm providing the table two name so mostly it will have M cross n that is 5 into 3 15 number of rows so let's see from the final result if we are getting 15 rows or not so I'll just execute this query so here you can see that we have got a cross join of both of the tables and let's see that how many rows are there so let's count 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 so the final result is having 15 15 rows and here you can see that ID 1 1 1 is repeated 222 is repeated because it is going and cross joining from the each and every row of the second table so basically whenever each row of the first table is cross joined with each row of the second table we get the result so that is M cross n number of rows that is 5 into 3 15 so as the name suggest join what is join basically whenever we want to join two tables we use joint now what does the self join means so whenever we are performing join operation on itself it is called a self joint now that may sound confusing but let's understand that how self join works so a self join in SQL is a type of join where a table is joined with itself it is a type of inner joint now whenever a table consider that there is a table a which is having some data and the column is ID name age so whenever this particular table a is joined with itself so again there is a table that is the same table a only with the same columns and same values so whenever we are joining the first table with itself it is called a self join so in this particular join what will happen table a will join with table a only so there is a self join with will happen now the very next question which would come to your mind is why do we even need to join a table from itself only why do we even need that like join is mostly performed on two tables so why do we even need to join one table from itself only so let's see this example this will make a bit Clarity and this will give you the reason why we are joining one table with itself so here you can see that this is a student table which is having details of the student ID the name and this one is the mentor ID so basically there is a group of student now in that particular group of student there is a mentor for each particular student and that particular Mentor is also a student so that is also provided the student ID so here you can see that for the very first row we have given the student ID as one for Ram and RAM is having no Mentor now for the second row the student ID is two for Rahul and Rahul is having a mentor who is having student ID as one so where the student ID is one it is for Ram so for Rahul Ram is the mentor now again coming to this third row here the student ID is three the name is RTI and she is also having a mentor as one one is Ram so Ram is the mentor for RI now coming to id4 that is Ria and Ria is having the one who is having student ID as three as Mentor so RTI is having student ID as three so R is the mentor for RIA so in this cases for now I have decoded it but if the table is too large if there is like very much of data or there is a huge data set in that case we can't go ahead and decode from the table itself that who is the mentor for which particular student so in that case what we do is we self jooin two tables and from the first table we fetch the student name and from the second table we can fetch the mentor name and can do it Vis Versa also so in this way we can know the student name as well as the mentor name who is assigned to the student where the student ID is always equal to the mentor ID because student ID is having all the details which Mentor is having so here you can see that I've have drawn a hierarchy chart so in the hierarchy chart the very first student is Ram now Ram is the mentor for Rahul as well as RTI so if you see here Rahul is having Ram as Mentor RTI is also having Ram as mentor and now for R reti is the mentor so here you can see that there is a hierarchy which is formed between the mentors as well as the student so here the cell joints plays a picture now if we go here the query for the cell join is we give select and then we provide all the columns which we want to display in the final result then we provide from and then we provide the table name and then we provide an alas for the table name so why do we even need to provide an alas so join is basically performed on two tables so if we give the same table name before or after join it can result in error here you can see that I'm joining a with a only but if I provide an alternate name for both the table it won't result in an error and it can give me the result so that is why we provide an alias which provides an alternate name for the table so this is an alternate name it's not like it is creating a new table it's just an alternate name for the table so it will provide an alternate name as T1 for the first table and then we will give join so whenever we perform self join it's not like we give a keyword at self join we only provide the join keyword whenever we are doing the self join and then we will again provide the table name and then we will provide an alas for the table name that is T2 so there will be T1 and T2 which is having almost the similar details only because it is the same table it's just that we are joining it so we are making two tables and we are joining the same table with it itself only then we'll provide the condition so we have provided the condition on t1. column name equal to t2. column name so whenever you find t1. column name equal to t2. column name do a self join now here T1 and T2 are aases for the table used to distinguish between the order of the rows so basically whenever we want to distinguish between two tables between their rows or something we can provide an alas now here you can see the query which I have written to find the mentor name as well as the student name now here we are providing select and then here we are providing S1 so what is S1 so S1 is basically an alas which is provided for the student table only so whenever we provide an alas for any of the table we can use the columns or access the columns using the dot so here we are accessing the column of S1 that is the student table only so S1 do name as Mentor name so we are providing an alas for this S1 do name that is the mentor name so first table would be having the mentor name and then we are providing s2. name as name so S2 is again an alas which is provided for the second table so for the second table s2. name is referred as name so we will get a final result where we will get the mentor name and the name then we will provide from and then we will provide the table name then we'll provide an Alas and then we'll provide an alternate name and then we'll provide the join keyword for the self join and then again we'll provide the table name on which we are joining and then we'll provide an alternate name for the same table name and then we will provide the condition so here the condition is where S1 dos ID so basically this one so when S1 do S ID is equal to s2. Mentor ID so whenever S1 do S ID like one is equal to the mentor ID give me all the row so what it will do is it will check if one is equal to this no if one is equal to this yes so give me Ram if one is equal to this yes give me Ram if 1 is equal to three no don't give me RTI so in the same way it will perform for 2 three and four now let's see the final result so here in the final result we get the mentor name as RAM for RTI the mentor name is RAM for Rahul and the mentor name is RTI for RIA let's verify here so for RIA the mentor was RTI for RTI the mentor was RAM for Rahul the mentor was RAM and for Ram there is no Mentor so this is the final result which we get now if you're still getting confusion that how this cell join is even happening so let me just explain again so what is join join basically combines two table and give us the details now in the join what happens is he there is a cross product which always happens and then we provide the condition on that cross product which gives us the final result so in join what happens we are combining two tables so whenever we are combining two tables there is a cross product which happens and then it eliminate all the pairs based on some condition so here we have a condition s1s ID is equal to s2. Mentor ID so let me just refer it as mid so let's draw the table which we have so what we will do whenever we are performing cell joiners first we will find the cross product so to find the cross product we need to understand that what kind of join this is so this is a self join so it will get joined with itself only so there is one more table which is having exactly the same details as this table so this is the mentor ID and then they are having the same details 3 4 Ram Rahul RTI Ria and then it's null 1 one and three so let's just perform the cross product so in cross product what happens is each row of the first table is cross joined or co-joined with each row of the second table so basically there will be a pair which will be made which will be having the first row of the S1 and all the rows of S2 so the very first set which we will get is one ram null which is joined with one ram null two Rahul 1 3 RTI 1 and four Ria three now again for the second row we will do the cross product so it will get joined with 1 2 3 and four so the second row is two Rahul and one which will be joined with one ram null two Rahul 1 3 RI 1 4 Ria 3 now again for the third row it will be three r 1 which will be again joined with 1 Ram null two Rahul 1 3 RTI 1 4 Ria 3 now the final one would be four Ria 3 so it will be four Ria 3 with one ram null two Rahul 1 3 RTI 1 and four Ria three so these are the four set which we have got set a set B set C and set D so here in the cross product we have got four sets which is kind of each row of the first table is cross product with each row of the second table now cross product is done now we need to apply the condition so here the condition is S1 do S ID is equal to s2. M ID that is Mentor ID so S1 do S ID is this and s2. M ID is this so is 1 equal to null no rejected is 1 equal to 1 yes so this will appear in final result so this will be the one which will appear in the final result now is 1 equal to 1 yes so this will also be appeared in the final result so is 3 equal to 1 no so we'll just discard this so from here we have got one ram null two Rahul 1 1 Ram null 3 r 1 now let's come to the second set so this is the S ID and this is the m ID so is 2 equal to null no is 2 equal to 1 no is 2 equal to 1 no is 2 equal to 3 no so from set B we have got none of the pair now let's go to the set C so is 3 equal to null no is 3 equal to 1 no is 3 equal to 1 no is 3 equal to 3 yes so basically here three is the student ID and here all these fields are the mentor ID so it is basically the S1 details and it is basically the S2 details so from here also we have got a set that is three Re 1 along with four R three now coming to the four set so here is four equal to null no is 4al to 1 no is 4 equal to 1 no is 4 equal to 3 no so from here also we have got no sets so here you can see that we have got 1 2 and three so we have got three rows in the final result and here also you can see that we have got the three rows in the final result so in the final result we are showing S1 do name as the mentor name and s2. name as the name or the student name now let's figure it out so here S1 do name is Ram so the very first Mentor name is Ram who is the mentor of Rahul and RAM is again the mentor of reti now the third set is three RTI 1 with four Ria 3 so RTI is the mentor of Ria so basically we are getting Ram the mentor of Rahul Ram the mentor of RTI and RTI the mentor of Ria let's go to the final result so Ram the mentor of RTI Ram the mentor of Rahul and RTI the mentor of Ria so in this way we get to the final result I know the video is extending too long but this is a very important concept and if you understand this you can solve any of the joint problem and you can understand that why this particular result is coming and how it is coming so basically whenever you do a cross product with along any condition you can get the result of the specific joint now let's go to the my workbench and see how the cell join is happening so for the cell join we will be making a school database inside that school database we will be making a student table and inside the student table we will be filling all the details of the student ID the mentor ID and the name so let's just create it so just to save time I have written all the commands so firstly we'll create the database so we have created the database let's just do a refresh all so here you can see a school database is created now I'll tell the SQL Server that all the commands needs to be executed in the school database so we will use this you School command so here it is a success now we'll create create a table student in the school database we'll be having student ID name and Mentor ID so here it is a success let's just do a refresh all so here you can see in the tables we are getting the student which is having column such as student ID name and Mentor ID now let's just insert the data into the student table so this is Success now let's just see that if all the data have been inserted correctly or not so here we have got one ram null two Rahul 1 3 r 1 and four Ria 3 now let's just apply the joint first we will give the select command and and then we will give the column which we want to show so for now we want to only show the name so we will give it as name now we will give from and then we'll provide the first table name that is student and since we can't perform join on the same table name we will just use an alas for the first table name that is S1 and then we will give this join keyword for self join and then we'll provide the second table name that is student and then we will give as S2 and then we will provide the condition so the condition is where S1 do S ID is equal to S2 do Mentor ID so wherever you find the student ID is equal to the mentor ID just do a self jooin so that we can get the details of the student as well as their Mentor so let's just run only these much query and see that what we are getting so here you can see that we are getting an error why we are getting an error so here since we have provided an alternate name for the tables so we can't just give it as name because it won't know that from which table you are using the name because name is present in S1 as well as S2 so for now let's just use S1 do name and s2. name now let's just execute this query and see so here we are getting name and name which is having ram ram reti and Rahul RTI and Ria so here we are getting all the mentors name and here we are getting all the student name so we just need to modify the query a bit because here also we are getting the name and here also we are getting the name so let's just provide an alias for this particular column and for this particular column so that we get the result in a desired format so let's just name it as s Mentor name and let's just provide a alternate name for this s student name or you can say name so let's just execute this query and now here you can see that we are getting Mentor name and the student name so the student name is Rahul and the mentor for Rahul is Ram the student name is RTI the mentor for RTI is Ram the student name is Ria and the mentor for RIA is RTI so in this way we can get the final result of the sell join where we can get the details of the mentor as well as the student the most common example which is used for the self join is for the employee table where we find that the employee ID Remains the Same for the manager as well as their employees so in that case also we can use the self jooin now as the word suggest exclusive so exclusive basically means whenever we are excluding something and join basically means whenever we are combining two tables so whenever we are combining two tables if we are excluding something that is used in exclusive joints now what are these exclusive joints so exclusive joints are used when whenever we want to retrieve data from two tables excluding the Matched rows between these two tables now let's go to the outer joints so in the outer joint I explained about three types of joint first one was left joint second one was right joint and third one was full joint now what happens in the left joint consider that if there are two tables A and B A is the left table B is the right table so in the left joint we used to get all the details which is present in a along with the common details which is present between A and B similarly with the right joint if there are two tables A and B where a a is the left table B is the right table we used to get all the details which is present in the right table along with the common rows which is present between right table and the left table in the full joint we used to get all the details which is present in the left table along with all the details which is present in the right table and the common rows between them but in the exclusive joints we basically exclude this area so we don't get this area we only want this particular area which is having the details of a only this particular area which is having the details of b or only this area which is having the details of a as well as the details of B so here also you can see that there are three types of joint the very first one is the left exclusive joint the second is the right exclusive joint and the third is the full exclusive joint so here the left exclusive joint is same as the left joint it's just that in the left joint we used to get the common or the Matched values between A and B but here we are excluding this values again in the right exclusive joint it is same as the right joint but in the right join we used to get all the details which is present in the right table along with the common details which is present in right as well as left table but in the right exclusive joint we only get the details which is present in the right table we exclude the ones which is the Matched rows between a as well as b or left table as well as right table now in the full exclusive joint again it is similar with the full outer joint but in full outer join we used to get all the details of left table all the details of right table along with the details which is matching between left table and right table but here we are excluding this particular area so now let's learn about each and every type of joint and let's see the query which we are using for these exclusive joints so the very first one is the left exclusive joint so whenever we retrieve records from the left table excluding the ones matching in both left as well as right table so we are retrieving the record from both the table A and B where a is the left table B is the right table so we are getting all the details which is present in the left but we are excluding the ones which is present in both the tables or ones which is having the mased rows so consider for now we are performing the left join only so how we'll perform it consider that this customer is the left table and the order is the right table so in the left join what happens is first it will return all the details which is present in the left table and then it will find any matching values so consider that join condition customer. ID is equal to order. ID so the condition is whenever customer. ID is equal to order. ID perform the join operation so the join table would be having all the values so the first one would be ID name and then it would be ID and Order name from the order table so let's go to the fairy first row so uh since it is a left join we need to print all the details or all the information or all the rows which is present in the left table so 101 Ram would be printed now it will find that is id101 present here no id101 is not present here so we will null and null for it now we'll go to id12 so is ID 102 present here yes ID 102 is present here so we'll fill 102 Rahul and here we'll fill 102 with fruit now it will go to ID 103 so is ID 103 present here yes ID 103 is present here so it will print 103 with 103 ball so this was the result we used to get in the left joint but in left exclusive joint what happens is we are excluding the ones which are matching between both of these table so what are the fields which are matching between both of these table that is this 102 and 103 so 102 and 103 are matching between both of these table so we have to exclude this and we have to just print this in the final result so how we can get this particular row so here you can see that whenever there is no matching row which is present in the right table we get the value as null as there is no matching field which is present there so here what we will do is first we'll write the query for the left joint so we will write select and then we'll provide the columns which we want to show in the final result then we'll provide from and then we'll provide the left table name then we will provide left join and then we'll provide the right table name then we'll provide the join condition so table 1 do column name is equal to table 2 do column name and then again we will provide the condition to exclude the matching rows so the condition to exclude the matching rows can be where table 2. ID is equal to null or where table two. name is equal to null so we can provide the condition where table 2 do column name is null so whenever we provide is null it will only return me this row and it will eliminate all the matching rows because whenever there is a matching row there would wouldn't be an inal value when it would NL value whenever we don't find any matching row so that is why with the left join query we write a we condition which help us to remove the Matched rows between left table and the right table now the second one is the right exclusive joint so whenever we retrieve records from the right table excluding the ones which is matching both in the left as well as the right table now the query for the right exclusive joint Remains the Same as the right join it's just that we will again put a we condition and now this time it will be table 1 do column name is because in right join we print all the details which is present in the right table and the matching which is present in the left left table so consider for 102 it find the matching data for 103 it will find the matching data but for 104 it won't find any matching data so it will print 104 utensil null and null so here table 1. ID would be null table 1. name would be null so that is why here we have provided a condition table 1. column name is null so the query is Select and then we provide columns then we provide from and then we provide the left table name then we provide the right join keyword then we provide the right table name then we provide the join condition on table 1. column name equal to table two do column name and then we provide this we clause which will help me to eliminate the matching rows between these two tables now in the full exclusive joint whenever we retrieve records from the right table and the left table excluding the ones matching in both left and right table we get the full exclusive joint now in full outer join what we used to do is we combine the left joint as well as the right join query using a union so why we use Union because in SQL there is no full outer join or full joint so we use Union to combine the details of the left joint as well as right joint which will give me a full outer joint and this Union also makes sure that the m rows between the left table and the right table doesn't occur twice because there could be a possibility that in the left joint we are getting all the details of the left table along with the common Row in the right join we were getting all the details of the right table along with the commons one so if we are doing a union of left join with right join this particular area can occur twice but Union make sure that this particular area doesn't occur twice so first we'll provide the query for the left exclusive joint then we'll provide a union and then will provide the query for the right exclusive joint so in this way we can get the full exclusive joint so let's see from the myol workbench how this is happening so we'll just work on the exclusive joints so let me just write it exclusive joins now there are three exclusive joins so the first one is left exclusive join the second one is right exclusive join and the third one is full exclusive joint so let's see first for the left exclusive joint so the query for the same would be select and then we'll provide the columns name which we want to see so for now we want to see all the columns so we will provide star and then we'll provide from and then we'll provide the left table name that is customer and then we'll provide left join and then we'll provide the right table name that is orders and then we'll provide the condition on which we are joining so on customer. ID is equal to orders do ID so this is the query for the left joint so let's see that what this query returns and then we'll see that how exclusive join is making a difference so here we are getting all the details of the left table and for the right table the details which were not existing is marked as null and then we are getting the details of the values which are matching between the left table as well as the right table so wherever ID is matching between left table and right table we are getting that details as well and since it was a left joint we are getting all the details which were present in the left table now let's just add a condition so we have to add a condition where table two that is orders do ID is null so it will make sure that give me all the details where orders. ID is null so whenever there is no matching rows we can see that the ID is coming as null for the orders table so it will return me the details of that particular person who doesn't have a matching rows in the right table so let's just execute this query so here you can see that we are getting only two entries where ID is null for the orders or the right table so basically it excludes all the matching rows which is present in the left as well as the right table now for the right joint the query would be select and then we want to see all the columns so select star and then we'll provide from and then we'll provide the left table name that is customer then we'll provide the right join and then we'll provide the right table name that is orders and then we will provide the join condition where customer. ID is equal to orders. ID now this is the query for the right joint so let's see that what all things are returned here and then we can see the difference between them so let me just execute this query so here you can see that we are getting 2 3 4 and here all the rows are matching in between both of the tables so here we are getting 234 and the entry for 234 is also existing in the order table so whenever we would be running the exclusive joint we won't be getting any data here all the IDS are matching in the right table so let's see for the right exclusive joint so we'll provide a condition where table one do column name is null and we just remove this so let me just execute this query so as I told that we are not seeing any dat because all of the data were matching in the left table so since left table and right table both had all the common sets which were present in the right table we are not seeing any data now let's just execute full exclusive joint so for full exclusive joint first we will use the left join and then we'll perform a union between them and then we'll provide the right join just remove this and let's just execute this query so here you can see that ultimately we are getting all the details of the left exclusive join only we didn't got any data so here we are getting one5 Rahul Raj and here the ID is null and the order name is null so before moving to the union operator let's just re- revise some older Concepts where we were using the union operator so what happens in the left joint basically if there are two tables A and B if a is the left table B is the right table in left join we used to get all the details which is present in a along with the details which is common between a and b is the common details between the left table and the right table so let's name this area as C so we used to get a plus c now in the right joint if there are two tables A and B where a is the left table and B is the right table in the right join we used to get all the details which is present in the right table along with the common details which is present between the left and right table so here it will be B+ C now in the full outer joint what used to happen we used to get all the details which is present in the left table all the details which is present in the right table along with the common details which is present between the left as well as the the right table so here we used to get a plus b plus C now in SQL there is no full outer join keyword there is a left join keyword there is a right join keyword but there is no full outer joint keyword so in that case we use the union operator so for full outer joint what we did was we combined the left joint and right joint together using a union between them so it combines all the result which is present in the left joint along with all the results which is present in the right joint so this and this both were combined to get this but if we perform a union between the left joint as well as the right joint so the left joint used to give us a plus c and the right joint used to give us B plus C so here we are getting a here we are getting B but here you can see that we are getting C twice so that is what union is helpful for Union basically gives us all the values removing the duplicates or you can say without the duplicates so whenever we are performing Union between any of two queries it help us to remove the duplicates or it help us to eliminate the duplicates so it will only print C once so we get the result which we wanted for the full outage one so Union help us to achieve results or achieve the combination of results between any two or three queries and it help us to remove the duplicates so here if you can see Union operator in SQL is used to combine the result of two or more select queries into a single result set and give unique rows by removing the duplicate rows so as I said consider that if there are two queries q1 and Q2 which are the select queries so if we perform a union between these two queries it will help me to give a single data set and in that single data set there would be no duplicates so duplicate GS won't be there so there are some things which one should keep in mind while using the union operator so the very first one is each select command within the union must retrieve the same number of columns so consider that there are two queries q1 and Q2 and we are performing a union between them so if we are selecting some columns here to show in the final result the number of columns which we are putting here should be the same in query 2 as well so if we are giving one column here consider select ID here we should also give one column the number of column should always be same between the two select queries on which we are performing the union now the second is the data type of the column in corresponding positions across the select statement should match so consider in this select statement we are selecting ID and in this select statement also we are selecting ID so both of the ID should have the same data type there shouldn't be any mismatch of the data type like this ID is a Vare or this ID is a int we can't perform Union in that case so these columns which we are putting here to select or to see the result should always have the same data type the third one is column should always be listed in the same order across the select statements so since we have to maintain the data type we have to always maintain the order because if the order is not sync we may get the inappropriate or a wrong result or we may get an error so we have to always make sure that we maintain the order we have to always make sure that the number of columns we are mentioning in the select queries on which we are performing Union should be same and we have to also make sure the data type of the column should also match with each other on the specific order now let's see that how this Union operator works so firstly we will give select and then we will provide all the columns which we want to see the details and then we will give from and then we will provide the table one name and then we will provide the union and then we will give select and then again we will give columns and and then we'll provide from and then we will give the table two name so basically there are two select queries this is the first select queries S1 this is the second select query S2 and we are performing a union between them making sure that all the columns in S1 is equivalent to all the columns in S2 all the data types of the column matches from S1 to S2 so we are performing a union which will help me to give a single result set for these two select queries so consider that this is the table one and this is the table two and between them we are performing a union so table one is having a column such as ID table two is also having a column ID it is also holding integer values and this is also holding integer values for now so uh for the first query if we execute select ID from table one so what it will do it will give me all the IDS which is present in table one so it will print one so this is the final result so it will print one then it will print two and then it will print three now there is a union symbol so basically all the things which we have got from here or all the result which we have got from here needs to be combined with the second select query so the second select query says that we have to provide the column ID of the table two now let's go to table two so here in the table two you can see the first row is two like the ID is two but two is already present in the final list and what union does is Union removes the duplicates so this two won't be printed in the final result it would be discarded because we have applied a union between these two queries now coming to the second row three so three is also printed in the final result and we don't need any duplicated values so we will be discarding this as well now coming to four is four present in the final result no four is not present in the final result so we can print four so this is the result we get after applying Union on these two tables so let's see from the MyQ workbench that how it is happening so here we already have a Ecom database and in that Ecom database we have a customer table we have an ERS table so let's just first select and see that what all IDs are present in the customer and the orders table and then we'll perform the union to see if duplicated values are being removed and if we are getting a combined data set so let's just first see the ID which is present in the customer table so we'll give select ID from customer and let's just execute this query so here you can see that we are getting the ID details so it is 1 2 3 4 and 5 so from the customer table we are getting the IDS as 1 2 3 4 and 5 let's see the IDS which we are getting from the orders table so we will write ID and then we will give from and then we'll provide the table name that is orders so let's just execute this query as well so here you can see that the IDS are 2 three and 4 so 2 three and 4 is something which is present in customers as well as orders table so let's see that if we are getting the duplicated value in the final result or a unique value in the final result so we'll just provide a Union between them and we will execute the query so I just need to remove this so let's just execute this query and here you can see that we are getting only the ideas 1 2 3 4 and 5 so we are not getting any duplicates and we are getting the idas which is present in the customer as well as the orders table so like the union operator we have a union all operator in SQL so let's just understand that how this Union all operator help us so Union all operator in SQL is used to combine the results of two or more select queries into a a single result set and give all the rows by not removing the duplicate rows so in Union we used to combine the select queries and remove the duplicates but in Union all we only combine the query we don't remove any duplicates so we don't take into consideration of any duplicates or something so we just combine the query but in Union we combine the query as well as we remove the duplicates now let's see the query on how we can use the union all operator so firstly we'll give select columns from table one so this this particular query will help me to fet some columns from the table one then we'll give this Union all operator then we will give select then the columns from table two now this particular query will help me to give all the columns which are mentioned here from table two and we are performing a union all operator between them so this query 1 and query 2 will give me a combine result but there would be duplicates since Union all doesn't take care of the duplicates so let's see from an example so consider that this is table one and this is table two and we are performing a union all operator between them so what will happen for not table one is having an ID column table two is also having an ID column so we can perform a union all operator so firstly it will execute the query one which is for table one and then it will execute the query two followed by the union all operator so firstly the query for table one would be executed so we want to see all the IDS which is in table one so firstly one would be printed then two would be printed and then three would be printed then it will go to table two so the first ID in table two is two which is already present in the final result but as I told that Union all operator doesn't take sces about if there is something which is present here because it doesn't removes any duplicate so two will again be printed then there is three three is also present in the final result but it doesn't take care of the duplicates it just combine the results which is present in table one and table two so three will also be printed and then there is four in table two so four will also be printed so we print the data which is present in table one column as well as the data which is present in table two column without even considering of removing the duplicates so duplicates can be there so let's see from the MySQL workbench that how this Union all operator is working so here we already have the query for the union so let's just copy the same and we will replace Union with Union all and let's see that what we are getting in the final result so here you can see that we are getting 1 2 3 4 5 and 2 3 4 is again coming even if it's like duplicated but since we are using Union all in Union all we can see the duplicate values so what is this SQL subquery inner query or nested query so SQL subquery is a query which is nested within another SQL statement so consider that there is a SQL statement q1 and inside this q1 there is one more query Q2 that is acting as a inner query we call this particular query is subquery which is helping me to perform operations on q1 based on the data which we are receiving from Q2 so whenever we want to retrieve data based on the result of another query we use the nested queries so consider that Q2 give me a result R2 and based on R2 we are doing some filteration on q1 so it is helping me as a subquery and it is helping me to give the details now why do we even need the subqueries so consider that you are working in a company XYZ now companies told you that the average salary which we give to our employee is 12,200 now consider the next year company hire more 50 employees right so the average salary can either increase or decrease as well now do we need to calculate the average salary each and every year whenever a new employee is on boarded or whenever a set of employees is on boarded we don't need to do that right so what we will do is we will write a query to find the average salary and then we can tell he you can use this particular uh query anywhere where you want to find all the employees who is earning more than average salary where you need to find all the employees name employee details you can use that particular subquery everywhere because that will give me the dynamic value or the value which is at present it will give me the dynamic value it won't take the value as 1200 as static value it will give me the dynamic value whenever a new employees is unboarded the value would be updated so in the same way we use the subquery because it helps me to get the dynamic value and it helps to update the data at the real time so we don't need to update our query each and every time we write a self-sufficient query like select average salary from XYZ so what it will make sure is whenever there is new employee which is added in our database it will update the salary accordingly the average salary consider if earlier it was 12200 now it can be 12250 so it will be updated accordingly now here you can see a Blog diagram where I have given an outer query and inside this there is a inner query so this inner query is Q2 this outer query is q1 the result which we are getting from Q2 is R2 and based on R2 we are performing some logic in q1 so in this way the nested query works now how we can use the subqueries so subquery can be used in multiple ways the very first way is subqueries can be used with Clauses such as select insert update or delete to perform complex data retrieval now here you can see that we can use it with the Clauses such as select insert update or delete so let's see that how we can use so here we have written the query so we keep select and then we provide columns and here we can provide a subquery which will help me to find another column in which there would be some manipulation which would be already done in the subquery and which I can show in the final result and then I can give from and then I have to provide the table name from which we are fetching the data now let's see the another way in which we can use the subqueries so subqueries can be used with wear Clause to filter data based on the condition so we can use the we clause and we can filter the data based on some condition so let's see the query so here you can see we are giving select and here star basically means all so it will give me all the columns which is present in the table then we will give from and then we'll provide the table name then we'll give the we clause and here we provide the column name on which we are doing the manipulations or the filteration then we provide the operator like greater than less than equal to in operator or other operators and then we give the subquery so this is the query two which gives me some result and on based on this result we are performing some operation so we'll see the example one by one for each of these ways but for now I'm just explaining that how we are using this in each way now the Third Way is subqueries can be also used in the from Clause so we can also use subquery inside the from Clause so let's see so let's see the query so here we are giving select and here we are giving star which basically selects all the column then we are providing form and inside this form we are using the subquery and then we are providing an alternate name for the result we are getting from the subquery as alternate name so let's see from examples that how we can use the subqueries inside the select from and wear Clauses now let's understand from example how we can use the subqueries using the wear clause so the very first problem statement is find all the employees who have salary greater than the minimum salary so we have to find all the employees who is having salary which is greater than the minimum salary which is present in our table so we have to break the problem into two steps first is we have to find the minimum salary and then we have to find all the employees who is having salary greater than the minimum salary so let's see first that how we can find the minimum salary so first we'll give select and then we'll give an aggregate function minimum which will take all the values which is present inside the column and we'll return the minimum value so we'll give the column name as salary and then we'll give from and then we'll Pro the table name that is employee so this will give me one result that would be the minimum salary among all the employees now the second query is to find all the employees having salary greater than the minimum salary so this we have already calculated now we have to find all the employees who is having salary greater than the minimum salary so we'll give the query select and then we want to show the employee name as well so we'll give name and then we'll give salary and then we'll provide from and then we'll give employee and then we'll give the we condition where the salary which is given here is greater than the subquery which is this minimum salary so here we can replace the subquery with the the query which we have written here and we can get the salary which is greater than the minimum salary or you can say R2 so in this way we can find all the employees who is having salary greater than the minimum salary so let's see from the myo workbench so we have to find all the employees who is having salary greater than minimum salary so we already have a company database and in that we have a employee table so let's first see that what all details are there in the employee table so here you can see we have ID name age Department City and employee salary so let's just find the employee salary which is greater than minimum salary so firstly we'll find the minimum salary so for that we'll give select and then we'll give the aggregate function Min and then we'll provide the column name that is salary and then we'll give the table name that is from employee so let's just execute this query and see that what it is giving so it is giving me 1,600 which is the minimum salary among all the salaries which is present in the table now let's find all the employees who is is having salary greater than the minimum salary so what we'll do is we'll give select and then we want to show the employee name and then the salary column and then we'll give the table L that is from employee and then we'll give the wear clause and we'll give the condition where salary is greater than and here we will replace it with this subquery so here we are getting the minimum salary as 1600 and here we'll replace it with this and we'll just execute this so here you can see that we are getting the name and the salary so is 2,000 greater than 1600 yes is 2500 greater than 1600 yes is 2400 greater than 1600 yes so we are getting all the employees name along with their salary who is having salary greater than the minimum salary so let's see another example find all the employees who is having the minimum age so we have to find the employees who is having the minimum age so first what we will do is we will find the minimum age which is present in our table and then we will compare that consider that if the minimum age is 18 is the employee having the age as 18 is the the employee having the age as 18 is the employee having the age as 18 in the same way we will see for all the rules and we will show the details of employee who is having age as the minimum age so firstly we will break the problem so first we'll find the minimum age and secondly we'll find the employee who is having the minimum age so how we can find that so first we need to find the minimum age so to find the minimum age we can give the query select Min age from employee so this will give me a minimum age consider R2 now I have to find all the employees who is having the minimum age so I'll give the query select name and I want to see the age as well so age from employee and here in the subquery I'll give where age is equal to the subquery so it will be replaced by this query because this is giving me the minimum age so it is giving me the result as R2 so it will be basically R2 and this subquery would be replaced by this in this way we can find all the employees who is having age as minimum age so let's see from the myol workbench so we have to find all the employees who is having their age as minimum age so firstly we will find the minimum age so to find the minimum age we'll give the query a select min and we'll give age and then we'll give the table name from employee so let's just execute this query so here you can see that we are getting the minimum age as 24 now let's find all the employees who is having age as 24 so we will then calculate all the employees who is having ages minimum age so we'll give the query as select name of the employee age from table name is employee and then we'll give the condition where age is equal to minimum age and basically this query is helping me to find the minimum age so I can replace the minimum age with this so we'll give this and we'll just execute this query so there is only one employee who is having age as the minimum age if there were two or three employees who were having the age as 24 that data would also be shown here so let's understand from example of using subqueries in the from Clause so the first question is find the employees who is having age greater than minimum age so earlier we using the wear Clause but here we'll be using the subquery inside the from Clause so firstly we'll find the minimum age and then we'll find all the employees who is having age greater than minimum age so let's see how we can do that so to find the minimum age the query is Select minimum age and here we are providing an alas or an alternate name for the same that is min age and then we'll give from and then we'll give the table name as employees so in the second step we have to find the employee which is having age greater as minimum age so we'll give select and then here we have used EMP do name so EMP is basically a short name we have provided to this employee table and we can use dot to select all The Columns which is present here so we can use empname and then we can give from employee EMP and here we can replace it with the subquery that is the minimum age so we'll replace the subquery with this and we can give it as subquery and here we'll give where EMP do so basically EMP is the short name so employee. AG is greater than what we are getting from subquery so subquery do minage so here we are having minimum age so we'll use subquery do minage and here we are having age as the column so we will be using age so from here we'll get the result as minimum age and with a result consider R2 and here we'll use the result which we got from this query to do a filteration so let's see from the MySQL workbench so first we'll calculate the minimum age so we can use the query as select minimum and we can give it as age and then we can provide an alas to use that particular result somewhere else also so we'll give as and then let's provide it a name as Min age and then we have to give the table name so from employee so let's just execute this query and see what it is giving us so here you can see that we are getting a minimum age as 24 so here you can see that it is replaced by the alternate name which we have given else it would show Min age so we have replaced it with an alternate name that is minimum age so let's find all the employees who is having age greater than the minimum age so firstly we will use select and then we'll give what we want to select so firstly we want to show the name and the age and then we'll use from and then we'll give the table name that is employee so for now we are giving a short name for the employee table so that we don't have any confusion so here we'll give a short name for employee that is EMP since we have provided a short name we have to access the column such as empname and EMP Doh and then here I'll replace the minimum age from the subquery so since I am also using this particular result in my from so I have to use the subquery also so I'll just use the subquery which will help me to find the minimum age so I can also provide an alias for this as Min age query so I have selected EMP do name that is employee name EMP do AG that is employee age from employee table and here I've provided a short name for it and we are also selecting minimum age so we are giving from employee table as well as this particular table and then I'll give the where conditions so where EMP Doh is greater than this Min query dot Min minimum age query Dot Min age so let me just explain this so this particular would give me a result where there would be a minimum age and it would be the value which is the minimum among all the employees now this particular query select EMP do name Will select the name EMP do AG will select the name from the employee table only because EMP is the short name we have given to the employee table and then we also want to make query in this particular table so we'll give a comma and we'll give the query which will give me the minimum age of the employee and I'll give an alas for this so that we don't have any confusion so we'll provide an alas as minimum age query now we have given the condition where EMP do age so basically this table in this table find all the age and see the other table like this particular query gave me a table with the name Min age which is having one value so check if employee. AG is greater than minimum age query. minage so from this select the Min age and check that if the employe age is greater than Magee or not so let's just execute this query so here you can see that we are getting the name and age of all the employees who is having age greater than the minimum age so the minimum age was 24 so everyone you can see is 25 26 27 25 so all are having having age greater than the minimum age so let's understand from an example of using subqueries in the select statement so we have to print the employees with average age and the age of all the employees so we have to print the average age and age of all the employees so basically in the final result we'll be getting something like this where this would be replaced by the average age of this particular age column consider it's 23 and here we have to give all the age of employees like 24 25 and here it will be only 23 to compare that if the age is 25 what is the average age in the entire employee table so for this we'll again break it into two steps the first is find the average age the second is print the employees age and the average age so let's see how we can do that so firstly we'll find the average age that is Select average age and then we'll provide from and then we'll provide the table name so this will give me the average age of employee now we have to print the employee age along with the average age so we'll give select and then we will replace the subquery here because this is giving me the average age so we'll give an alas as average age and then we'll select age and then we'll give from and then we'll provide employee so in this way we can print the average age as well as age for the employee so firstly we find the average age so for that we'll use select average and then we can give age and then we can give the table name from and then we can give employee so let's just execute this query so here you can see that we are getting the average age as 25.4 so now let's see all the employees who are having age and average age in the result so we'll give select then we are selecting age then for average age we can replace it with this particular query I know this might sound weird that why are we even using this we can just give average age and we can provide an alas so I'm just explaining that how we can use the select query inside the Clauses and there might be more complex problem where you'll get the gist that why we are even using subqueries and how it is helping us to make the problem simpler so we'll select age and then for the average age we'll replace it with this query and we'll provide an alas for it as average age and then we'll give from and then we'll give the table name as employee so let me just execute this query so here we are getting age and here we are getting average age of all the employees so with the age we are getting the average age which is for the entire table so in this way the SQL subquery works you will see more complex problem where we are using the subquery concept and it will help to break down that particular complex problem into simpler problems now finding the nth highest salary of a person in a given data set this question is like mostly asked in the interviews it can be asked in the interviews of Amazon Google Etc like this is the most asked question and this is like one of the the most important question as well so let's find the steps that how we can find the nth highest salary and then we'll see the query for the same so here we have to find the nth highest salary in a given data set now n can be either 1 2 3 till till till any natural number n now if we are asked to calculate the first highest salary so that we can do very easily we can use the commander select and then we can give Max aggregate function and then we can give salary and then we can provide the table name from consider employee table name so this will give me the maximum salary or the first first highest salary which is present in the employee table but consider that someone ask you to find the second highest salary in that case what you will do you'll just write the same query select then Max and then salary and then you can give from then the table name employee now this query will give you the first maximum salary or the first highest salary but I want to find the second highest salary so what I need to do is I need to eliminate the first highest salary then the most maximum salary will be the second highest salary so I'll just give aware condition where salary is not equal to so this particular operator basically means not equal to and then I can replace it with the first query so this first query gives me the maximum salary or you can say the first highest salary so give me the maximum salary which is not equal to the first highest salary so this will give me the second highest salary now consider you are being asked the third highest salary so the query will get complex and complex so we have found a query which can be very helpful to calculate the nth highest salary of a person and that is a very simple query don't need to do this complex operation or make many subqueries you can use that particular query and that will make your work easy so let's see the steps to find the nth higher salary so the step one is select the column which you want to show in the final result that is salary so you have to first select the column which you want to show in the final result now step two is order the salary in descending order so you have to order the entire salary in the descending order so the first highest appears at the first position the second highest appears at the second position the third highest appears at the third position so that you can get the math at the first now step three is now the value of n could be anything 1 2 3 till any natural number n so we have to make the query in such a way so that whatever be the value of n it can provide the accurate or the correct result so the step four is so at the end of the query we will provide a limit so that on the data set which we have got after ordering this particular salary in descending order we can fetch the nth highest one so first what we have done is we have selected the salary column to show in the final result then we have ordered the salary in the descending order so the first highest comes as the first the second highest comes as at the second the third highest comes at the third and then we will use this limit clause which will help me to give the first highest second highest or third highest so let's see how we can use this so firstly let's discuss about the limit CLA so the limit CLA is used to restrict the number of rows returned by a query so whenever we want to restrict the number of rows which is returned by a query we use the limit Clause consider that we only want to see the details of top three student in a college or in a school so we'll use the limit Clause there which will restrict it to only top three people so here we have two types of limit one is the variation of the limit loss so first is limit and then we give n so it helps to retrieve a maximum n number of rows from the beginning of the result set so whenever we provide limit three so it will return the three rows from the beginning of the final result now there is one more limit MN so here M basically means the number of rows which we want to skip from the beginning and N is the number of rows we want to fetch after the skipping so consider if there are five rows 1 2 3 4 five so if I give the value of M as 2 and n as 1 so what it will do it will skip the two rows so it will not show one it will not show two and then n is the number of rows which we want to show in the final result so it will only show one row if the value of n would be two it would show three and four in the final result if the value of n would be three it will show three four and five in the final result so basically m is the number of rows we are skipping and N is the number of rows we are showing after the skipped ones so limit MN helps us to retrieve a specific range of rows where m is the number of rows to skip and N is the number of rows to fetch so basically it helps to give us a rows in the particular range so let's see the query for the same so firstly we'll give select and then here we'll provide the distinct keyword because there could be a possibility that there are two person who are having the same salary 1 12200 and 1200 so in that case that can give us incorrect result so we'll provide the distinct keyword which will make sure that we are getting only distinct salary and among that distinct salary or among that salaries which are unique we are getting the nth highest salary so we'll give distinct and then we'll provide salary and then we'll give from and then we'll provide the table name then we'll provide the order by clause which will make sure to order all the salaries in the descending order so we'll give the first highest salary in the first second highest salary in the second third highest salary in the third and like this then we'll provide the limit clause and then here will provide M and N basically m is the number of rows which needs to be skipped from the beginning and N is the number of rows which we want to show after being skipped after being skipped so here the value of M is n minus one and the value of n is one so the value of n is one because we always want to get only one result or only the nth highest salary so the value of n would always be one the value of M is n minus one because consider that we want to find the first highest salary so in the first highest salary we don't need to skip any of the the rows so here if we give 1 1 - 1 is zero so in that case we are not skipping any row and we are giving the first highest salary consider the value of n is two so here if we see M that is n minus 1 so it will be 2 - 1 that is 1 so it will skip the first row and then the value of n is 1 so it will give me the second row that is the second highest salary so let's see from the mys workbench that how we can find the nth highest salary so let's find the fourth highest salary so we'll find the fourth highest salary so for that we'll write the query as select and then we'll give distinct and then we'll give salary and then we will provide the table name that is from and then we'll provide employee and then we'll provide this order by Clause to order them then the column which we want to order that is salary and then the manner in which we want to order that is descending so firstly let's see that what is the result of this and then we will calculate the nth highest or the fourth highest salary so let me just execute this so here you can see that we are getting the salary as 2500 2400 2,000 and 1500 so we are getting all the distinct salary there is no duplicates and we are getting the salary in the descending order now let's just calculate the fourth highest salary so we will give limit so first is n minus 1 so 4 - 1 is 3 and then n is 1 so we'll give one and we will just execute this query so here you can see that we are getting the fourth highest salary as 1,500 so in this way we can calculate the N highest salary you can replace the number n with any of the natural number you are being asked to and this is the most simple query which you can use and get the result now as the word suggest stored procedure so whenever we are storing some kind of a query in a procedure we call it a store procedure so let's see these are the programs that can perform specific task based on the stor query so you might have heard about functions in programming so how this functions were useful consider that if we want to find minimum age of a person we used to create a function give the function name and write all the logic inside that function and wherever in our code we required to find the minimum age we can reuse this particular function in the same way we create a stored procedure we give that stored procedure a name and then inside that we write a query and wherever we want to use that query we can use this procedure name so it is basically a collection of pre-written SQL statements grouped together under a specific name so procedures can be created in two types one is when we are passing some params in the procedure and one when we are not passing any params in the procedure that is parameters are empty so let's see the query on how we can create a procedure so we give create and then we give the procedure keyword then we provide the procedure name and if there are any pars we can provide else we can leave it empty then we give this begin which tells that now the query is beginning and then we provide the query and then we provide this end which basically tells now the query has ended now the procedure with the name procedure name is created now whenever we need to call this we can use this particular query that is call and then we give the procedure name and then we terminate it so basically call can be used to call the procedure and create procedure can be used to create a procedure so let's see an example where we are using a stored procedure without parms so here we are trying to create a procedure where we get all the order Det details so we'll give create and then we'll give procedure and then we'll give the procedure name if there are any parms we'll provide but since it is without param so we'll leave it as empty then we'll give begin and then we'll provide the query that is Select start from orders which will give me the entire order details and then we'll provide end and then to call the procedure we'll use this call and then we'll provide the procedure name followed by the termination so in this way we can call the procedure and in this way we can create a procedure so let's see from the MySQL workbench so first we will create a proed procedure to get all order details so let's create so we'll give create procedure and then we'll give the procedure name get order details and since there are no parms we'll live it as it is then we'll give begin to tell the query is beginning then we'll provide the query that is Select star from orders and then we will give this end to tell the query has entered now here you can see that we are getting some errors so what could be the reason behind it so if you remember that whenever we write any SQL query if we want to terminate the query we give this particular symbol now here what it is happening is we have provided the query and we have terminated it here only so it is treating this particular thing as a query so this begin is not able to find end because it has been terminated here only so what we do in this case is we provide a delimeter so what delimeter does is whenever we provide delimeter with any symbol it considers that symbols as a form of termination and it will not consider this particular symbol as a termination so that will remove my error so let's use this delimeter d e l i m i t e r and then we'll provide a symbol as a delimeter for now I have provided this symbol as a delimeter so here you can see that the error has gone but since I provided this symbol AS delimeter it will not consider here also termination it will not consider here also termination so what I'll do is I'll just remove this termination here and I'll just provide this delimeter so for now it is treating this entire query as a single query now since we have changed the Del meter there could be a possibility that in the further queries we have to provide this only so we'll just change the delimeter back to normal once the query is done so we'll just give this as the delimeter so now the delimeter is changed as back to normal so let's just execute this query so here you can see that we have got a success now we want to see that if that particular procedure is created and what all details we are getting so we'll just use call and then we'll give the procedure name and if there are any parms we'll provide else we'll leave this as empty so let's just call this so here you can see that I'm getting the ID and the order name basically all the details which were present in the order table I'm getting here so in this way we can create a procedure and in this way we can call the procedure so let's see another example where we want to return the details of order by ID now this is an example of store procedure with parms so the query for the same is we give create then we give procedure then we provide the procedure name and then we give the column name and then we provide the data type now we give begin then we provide the query select start from orders where ID is equal to the ID which is provided here and then we provide this end keyword and to call this we basically use this call and then we provide the procedure name and then we provide the ID for which we are searching so what is views in SQL a view is a virtual table in SQL so consider that there is an employee table now this employee table is having details such as employee ID employee password employee name employee address now there are some people of the company who is making ID card for each and every employee so should we give the access to that particular people to access this employee table because this is also having employee password so this is a data breach right so we can't provide the access for this employee table to the people who are creating the ID card so in this case what we do is we give a view of this particular table so in this view we provide ID and name along with address which is needed to create the ID card but password is something which is not needed to create the ID card and also it is a secure data so we can't provide access or authorization for this particular table what we do is we create a view and the people who are creating ID card can now use this particular table it is a virtual table so can use this particular table to fetch the information and create the ID card so it helps in providing a filtered view of data for security purpose so let's see how we can create a view so we give this create and then we give view then we provide the view name and then we provide an Alas and here we provide all the columns from the base table which we want to show in the view so it basically specify the columns which should be included in the view so it helps in data abstraction security and simplifying the complex queries so if we are having a view table if we don't need some of the columns so we can just have a view table and we can do any kind of manipulation on that particular ular view table it is also helping in data abstraction because it is hiding the password from the ID people and it is also helping in the security purpose so since view is just like a virtual table so all the things which we perform on table can be performed on views so to see all the data in the view we give select star from view name and to delete the view we give drop View and then we check that if this exists or not and then we provide the view name so all the things which we are performing on a table we can perform on the views also so let's see from the MySQL workbench that how we can create a view and how it can be used so let's just create a view so we'll create View and we'll give the name as employee View and then we'll provide an alas so we'll provide as and then we'll give the details which we want to show in the view table so first is ID second is name and third is City and then we'll give from and then we'll give the table name that is employee so here you can see we are getting a success now the view is created now on this employee view we can perform any operation so consider that I want to see the details of employee ID so I'll use this employee view table so I'll give select ID and then I'll use from and then I'll use this table name that is employee view so let me just execute this query so here you can see that I'm getting the ID details so view has basically reduce the size of my table and also it has only the valid details which is needed for the ID card department to create that ID card now what is this case and if used for so whenever we want to perform any conditional logic in our queries and on basis of that we want some values we use this case and if statement so let's see so case allows you to perform conditional logic within a query so whenever we want to perform a conditional logic in our query we use this case now it can be used with both select as well as update statement to evaluate the condition and return the specific values based on those conditions so if there is a condition C1 it will return the value R1 if there is a condition C2 it will return the value R2 So based on some specific condition if we are getting some specific result we use the case in SQL now consider on the basis of day number you have to print the day if the day number is one you have to print Monday if day number is two you have to print Tuesday and so on so how you can use the case statement here so let's go to the query so we'll give case and then we provide this when and then we provide the condition so here we can give the condition as day number is equal to 1 and then we provide this then and then we provide the results so when day number is one we provide it as Monday now coming to next statement so we will give when and then the condition two is day number is equal to two and then the result is Tuesday so in this manner we can provide for all the days but consider if someone provides the day number as nine so this is a invalid case because because we have only seven days so we can provide it in L statement that else if none of the day number matches then we can provide the result as invalid so we can provide the invalid here and then we can end our case so it just acts like a switch statement which is present in our programming so we can use the case like that now case can be used with select as well as update statement so let's see the use cases so the very first question is categorize the student on the basis of percentage to top pass and and fail in a new column category so you have been provided with a student percent and then you have to categorize this percentage on the basis of top pass and fill so consider if a student achieves a percentage greater than 90 it lies in the Top If the percentage is between 89 to 34 it lies in the pass if the percentage is less than 33 then it lies in the field so we have to categorize the student we have to show all these values in a new column called as category so let's see that how we can do so we'll give the query as select and then all the columns which we want to show in the final result that is student ID student name and percentage and then we'll provide the case so first case is when the percentage is greater than 90 the student will be having top second is when the percentage is between 89 to 34 then the category will be pass and last case is when the student is having less than 33% so we can provide that in else block so we can give else fail and then we can end this case but now we want to show all these categories in a new column or you can say alternate column category so we'll provide an alias and we will provide here category so it will show all these results stop pass and fail in the category so and then we will provide from followed by the table name that is student so in this way we write the query for the case when we are using the select statement now let's see the use case of case with the update statement so consider that there are some student who have got some Grace marks now earlier the student grades were A+ a b B+ but now some student have got some Grace marks so update their grades where it's a update it to A+ and wherever it's B update it to a so we have to update the grade of the student whenever we encounter a we have to update it to A+ whenever we encounter B we have to update it to a because they have got some Grace marks so let's see how we can use case here so we'll give update followed by the table name that is student then we provide this set that go ahead and set that particular value and then we'll provide in which column we want to set the value that is grade and then we will provide this particular case now when the grade is equal to B then go ahead and update it to a and when the grade is equal to a then go ahead and update it to A+ so this case will give me the values based on if the grade is a or if the grade is B go ahead and update it to A+ as well as a and then we can end the statement so it will go ahead and update this particular value for this particular column whenever we encounter a it will be updated to A+ whenever we encounter B it will be updated to a so let's see the use case of if so it is used to return one two values depending on whether a condition is true or false it is not supported in many DBS but it is supported in myos schol so the query is we provide if and then we provide the condition like consider day number equal to 1 now then we provide the True Value and if this is not true if this condition is not true then we provide the false value so if day number is One update or select this particular value if day number is not one go ahead and select or update this particular value so let's see its use cases so first is categorize the students on the basis of their percentage to top pass fail in a new column category it's the same question so here if the percentage is greater than 90 so it is a top student If the percentage is between 89 to 34 it is a past student and if the percentage is less than 33 so it is a fail student so now we have three categories or we have three condition but using if we can only provide one condition on basis so C1 either we can give the result as R1 or R2 but we have three condition here so how we can use this so we'll use nested if so we will use if inside if and using this we can make the query so let's see so first for these two cases we will give it an if and then we will cover the third case because if the percentage is greater than 90% it will not come into this block but if the percentage is not greater than 90% it will surely come to this block so let's see so first we will give the inner block where we will give if percentage is between 89 to 34 then give as pass else give as fail so if this particular condition is true provide the value as pass L provide the value as fail now this particular if block will take care of these two condition now coming to the final condition so what we can do it we'll give select Sid name percentage all the columns which we want to see in the final result then we will provide if and then we'll provide percentage so if the percentage is greater than 90 go ahead and give the Top If this fails the percentage is not greater than 90 so it will lie in this particular range then execute this inner riff so what it will do is when the percentage is greater than 90 it will go ahead and give the value a stop if the percentage is not greater than 90 then it will go ahead and check in these particular two condition that it lies in 89 to 34 or if it is less than 33 and here it will check if it lies in 89 to 34 then it is pass if it does not lies in this as well as this then this is fail so in this way we use the if inside if or you can say nested if and then we provide as because we want to show it in a new column category so it will provide an alternate name and then it will create a category and then we can provide from and then we can provide the table name that is student now you may be thinking that case is very much easier than using IF but if you use the if the time complexity would be lesser than case so in if the time complexity is very less so the queries run very faster but when you use the case the time complexity is a bit more than if so the queries take time to run now let's see the next one that is if with update statement so we have to swap all the F and M values that is change all the F values to to M and VI versa so consider that there is a table where we have updated the wrong male and female so we have to swap the value of f with M and M values with f with a single update statement and no intermediate temporary tables so here we need to swap the values it's kind of updating the value into our table so let's see the query so first we'll give update and then we'll provide the table name that is employee so go ahead and update the employee table and then we'll provide the set set the value in the gender column and the condition is if gender is equal to M set the value as F and if the gender is not equal to M then set the value as M so this is the true when this particular condition satisfy this is the false value so if this particular condition satisfy then set the value as F if this particular condition does not satisfy then set the value as M so it will go ahead and find if m is there it will swap with f if f is there it will swap with M so consider if this is the gender column and in the gender column we we have considered three rows where it is M F and M so first it will go to this row so it will come here set gender equal to if gender is equal to m is gender equal to M yes so we have to update the value to F so now it will give me F this particular conditional statement so it will go ahead and update the value as F here now it will again come to the second row it will check that if the gender is equal to M no the gender is not equal to M it's equal to F so it will come to the false value and it will update it to M so it will go ahead and update it to M now again it will come to this particular row and it will see if the gender is equal to M yes so it will go ahead and update it to F it will give me the result as F so it would be updated as F so in this way this particular if conditional statement works now let's start with top SQL interview questions so the very first question is we have to write a SQL query first to create a database company second to create a table employee in it and third is we have to delete or drop the database so it's kind of a revision of how we create the database how we create a table in the database how we delete the database so let's see so first is create a database company so the command for it is first we give create and then we give database and then we provide the database name that is company now the second is create a table employee inside that particular company database now in the SQL Server there are multiple database consider this is DB1 this is db2 so we need to tell the SQL Server that I want to create a table in this DB1 so for that we use this particular command use and then we provide the database name so it tells the server to create the table inside this particular DB datus company now let's see how we can create the table so we give create table followed by the table name and then we provide all the columns which would be present inside our table so these are the columns name after the column name we provide the data type of these particular columns like employee ID would be holding integer values first name will be holding vcat that is character values last name would be holding vcat that is character values now in the third place we provide the Integrity constraints if there are any so here we have provided that employee ID is acting as a primary key here we haven't provided anything and here also we haven't provided anything so we basically provide the column name the data type and then the Integrity constraint now the third is delete the database company now we have to delete or remove the database from our SQL Server so what we can do is we provide the command drop which basically means delete and then we provide database and then we provide the database name that is company so in this way we can delete the database from our SQL Server now let's see the next question so we have to write the SQL query to First create a table employee second insert data into the table employee third update the salary for all the people in HR department to 20,000 and fourth delete the data for employee having employee ID as one fifth delete the entire table so there are five things which we have to do as part of this question so let's start with the first so we have to create a table employee so again we'll give the command create table followed by the table name that is employee then we'll provide all the columns so here it is employee ID employee name employee department and employee salary then we'll provide the data type so employee ID will be holding integer values employee name would be holding string or character values department will be holding character values and salary would be holding integer values then we provide if there are any Integrity constraint so here we are saying that employee ID is a primary key which basically means that employee ID will always hold unique as well as non-null values so this is the way how we create a table now the second is we have to insert the data into the table so we have created a table now the next step is we have to insert the data into the table so let's see how we can insert data into the table employee so we give the command insert and then we provide into and then we provide the table name that is employee if you want the data to be inserted in the same order you don't need to provide the order in which you want the data to be stored but if there is a different order like first you want to store employee ID and then you want to store the value of Department followed by name then you need to provide the order so this is a optional thing if you want the entire data set to be stored in this particular manner you don't need to provide it but it's better to provide because eventually we would be knowing that if employee ID is at the first place so we have to give a integer value if name is at the second place we have to give a character value followed by department and salary so here we provide all the columns in which manner we want our data to be inserted so the First Data would be inserted in employee ID the second in name the third in department and the fourth in salary so again we provide values to provide the values which we need to insert in these particular columns and then we provide the values so now one is inserted in employee ID re is inserted in name it is inserted in Department M and 30,000 is inserted in salary in the same way we provide for the second value that is 2 Rahul HR and 15,000 so in this way we have inserted values in our table now the third is we have to update the salary for all the people in HR department to 20,000 now we have created a table we have inserted data into this particular table now we need to find a department having the name as HR and corresponding to this particular Department we have to find the salary call and we have to update the salary everywhere we find the department as HR so what we do is we provide this update command and then we provide the table name and then we give this set so set basically means go ahead and set this particular value so it will set the value and we have to set salary as 20,000 and then we provide the condition that where you want to set the salary as 20,000 so we provide where and then we provide the column name in which we want to set it and then we provide it as HR so update the employee table set the salary as 20,000 where department is equal to HR that is what our question was update salary for all people in HR department to 20,000 now the fourth is delete the data for employee having employee ID as one so we have to delete the data for a employee who is having employee ID as one so what we have to do is we have to give this delete command then we have to provide from and then we have to provide the table name that is employee and then we have to provide the condition like where you want to delete this data so where employee ID is equal to 1 if you only provide this it will go ahead and delete the entire set of data which is present in the employee table but when we provide the condition it will go ahead and find the employee ID 1 and it will go ahead and delete this particular Row from our table now the fifth query is we have to delete the entire table so for deleting the entire table again we use the drop command so we use drop table followed by the table name that is employee if we want to delete a database we use drop database is followed by the database name now consider that you don't want to delete the table you just want to delete the entire set of data which is present in our table so for that you can use delete from employee which I told in the last slide as well that if you use only this particular command it will go ahead and delete the entire data set it won't delete the table but now your table won't be having any data now let's see the next question so we have to write a query to find the total number of employees working in the IT department so we have been provided with a table we have have to find the total number of employees who are working in the IT department from here you can see that we can tell there are two employees who are working in IT department but in real life the database is very huge so we need to write a query to find the total number of employees who are working in the IT department now to find the number of employees or the total or you can say count we use a aggregate function that is count so count is a SQL aggregate function that Returns the total number of rows in a specified table or query so count what it does it it counts all the rows which is present in our table so if I do a count star it will go ahead and count the entire set of rows which is present in our table so it will tell me that there are five rows which are present in our table now it count all the row regardless of whether they contain null values or not even if there are any null values present in one more row which is having only n values it will go ahead and count that as well so it's not like it will ignore the null values it will also count the null values Now using this count star we can find the total number of employees who are working in IT department so let's see so what we will do is first we will select the table so we have given select now we need to provide countstar which will go ahead and count the number of rows which is present in table so right now it is five so it will count five then we give from and then we provide the table name so this will give me the result as five so right now the count star from employee of this particular table gives me five rows now we need to find the number of employees who are working in only it Department here it is giving me the count of entire rows which is present in my table but I only want the rows which is having Department as ID so that I'll provide in the condition where department is equal to it so whenever I provide this condition countstar will go and then see that which all department is having it and it will just count that so the count star will then return me two so here you can see that if I do just a count star for a given table it will return all the rows but if I have a specified condition considered that I want to know for HR department so I'll replace this department it with HR consider I want to know for marketing so I'll just replace it and it will give me the count of all the employees who are working in the HR department marketing department or it department now the next question is write a query to find all the employees that have their name starting from R so we have to find all the employees who are present in my table who have their name starting from R so here we can see that there are two people who are having names starting with her that is Rahul and Raj but in real life the databases are so huge and there are lot of set of data which is present so we oftenly write a query to fetch our given condition now here the condition is the name should start from R so do you remember about that like operator so like operator help us to return any pattern or any matching values so like it is used to search for a specified pattern in a column if you want a pattern like name starts with r but ends with t so for these particular type of patterns we use this like operator now like operator is oftenly used with person percentage and underscore for searching patterns so let's see so here we have to find all the employees who have their name starting with r so what we will do is first we will select the entire table then we will give from here Aster means select all the rows and then we provide the table name that is employed then we give where and then we provide this column name on which column we want to provide this like operator that is name and then we provide this like operator so that is R followed by percentage now what this query says is go ahead in this employee table fetch all the columns all the rows and there is a condition that go to the column name and find the name who is having r as the starting character but this percentage says that the rest of characters can be anything consider if you want to find people who are having r i in their first name so we'll give RI followed by percentage so it basically says that RI should be the first or second character and rest of the characters can be anything so basically it makes a pattern for us and we have to go in our table and find for this particular pattern where I get r i in the first name and it will go ahead and search in the entire table now let's see some scenarios where we can use the like operator so consider that I want to find the name which starts with a so I'll give like a and followed by percentage which means that after a there could be any set of characters can have any values in the next we have to find the name that contains AR inside it so we have given two character that should be contained in any name so at the first there could be any characters at the last also there could be any characters but the name should be having AR inside it so we will give like percent which makes that there should be n number of characters before AR then percentage which says that should be n number of characters after AR and then we give this AR now here I have said that there could be n number of characters but what if I want only limited set of characters or what if I only say that my name has only five characters or search for a name who is having only five characters and having r at the start or r at the end so that type of question we can also deal using the like operator let's see the next pattern where we have to find the name which starts with a and have exactly five characters in the name so there should be only five characters in the name and the name should start with a we have to find this particular pattern so for finding this we would be using this underscore which basically matches the number of pattern so am person says there could be n number of characters but this underscore says that there should be only one character which is present if I have given underscore so I'll just give like a and then I'll provide four underscore because it says that the name should start with a and the name should only have five characters so in this way I can find the name so I guess there is a small typo here it should be a followed by 4ore which matches the criteria that the name should start with a and have exactly five character so let's see the next pattern where name has a as the second character so I have to find the name of all the person or all the employees who have a as as the second character in their name so let's see so if I just give a underscore it will consider one character so I can say underscore a so it will tell that go ahead and find all the names who is having first character as anything but second character as a and then there should be n number of character so it would be like Then followed by underscore for first character then a for the second character and uh percentage for the rest of the characters so let's see the next question we have to write a query to find find the unique salaries in the employee table so we have to find all the unique or you can say distinct salaries in the employee table for this we would be using the distinct keyword so distinct keyword is used to retrieve unique records from a table and we have to find the unique salary so we'll give select and then we will give distinct followed by the column name on which we want the distinct value and then we will give from and then we'll provide the table name so this will give me distinct salary from this particular salary column now the next question is write a query to find the second highest salary a table so we know the query to find the first highest salary date that is Select Max salary and then we give from and then we give the table name that is employee so here Max is an aggregate function which works on a column and gives the maximum value of that particular column or attribute now this particular select Max salary from employee will give me the maximum salary which is present here so let's see what is the maximum salary so that is 2500 but we need need to find the second highest salary now the second highest salary here is 2400 not 2500 so how we will find the second highest salary what we can do is we know the first highest salary from this particular query so we will again write a query and we'll say where Max salary is not equal to 2500 then it will give me 2400 so is it sounding confusing uh don't worry let's see the query first so what we will do is first we'll write select Max salary from employee where salary not equal to and then we have written a subquery so first this particular subquery would be executed so what is the subquery is Select Max salary from employee now what is the max salary here that is 2500 so this is our query after executing the subquery now we have to find the max salary from employee where salary this means not equal to so not equal to 2500 so we have to find the maximum salary here with salary is not equal to 2500 so let's discard this 2500 from here and let's find the maximum salary this is 2400 and 2400 is not equal to 2500 so we can say the second highest salary is the one in which we exclude the first highest salary so in this way we can get the second highest salary so max gives us the aggregated max value from a column now let's see a query to find the nth highest salary in a given table so we know how to find the first highest salary we know how to find the second highest salary but we have to find the nth highest salary where n can be any natural number 1 2 3 4 any natural number till n now if we want to find the third highest salary we would be then finding the second highest salary the first highest salary and we would be excluding it from the third highest salary so that is not a suggested way so that is why we need to make a query where we can only give the value of N and we can get the N at highest salary consider if value of n is five we can get the fifth highest salary so for that what we will do is first let's discuss about order by and limit Clause so order by Clause is basically used to order the column either in descending or ascending order and limit Clause given by m andn it helps to retrieve a specific range of rows so if we want a specific range of rows we use limit M comma n now here m is the number of rows which we need to skip from the beginning so consider if m is given as two so we need to skip two rows from the beginning and N is the number of rows we want to fetch after skipping so after skipping this two rows what are the number of rows which we want to fetch so consider I want to fetch three and four so I can give the value of MS2 and ns2 so it will skip two rows and it will give me 2725 now consider if I give the value of n as 1 so it will only give me 27 so in this way this mnn works now let's see the query so first what we do is we select the salary now here we have provided distinct because we need to find the fifth highest salary but there could be a possibility that 1 12200 is twice 15500 is twice so we need to find the distinct salary and among that distinct or you can say unique salary we need to find the N highest salary consider first second or third highest salary so we have used a distinct for this column salary so it will distinct the values or it will give me unique values of salary then we provide from and then we provide the table name sorry it would be employee here and then we give this order by clause and then we give the column name on which we want to order the value so order by basically orders the salary in ascending or descending order so we need to find the highest so we will be ordering it in descending order which basically means order the salary in descending order so what we will do is first we'll get the distinct salary so let's take the distinct salary that would be500 2,000 2,500 2,400 and again, 1500 is repeated twice and we are taking the distinct salary so these would be the salaries now what we have to do is we have order by in descending order so what we will do is we will order this in descending order that would be 2500 2400 2,500 now what we need to do is consider that if I want this particular salary that is the second highest salary so for this if I want to put a limit what I'll do is I'll skip one row from the starting and then I'll get the first row after skipping so the value of M would be 1 and N would be one consider if I want the third highest salary so the value of M would be two because I need to skip two rows from the beginning and the value of of n would be n so if you see the value of M is always nus 1 so that is 3 - 1 that is 2 so whatever is the value of n we are just subtracting one from that so we can say the value of M would be n minus one and the value of n we always want only one row so that would be one so it will be limit n minus 1 that is the value of n N1 is the value of n so in this way we can get the nth highest salary you can like use this query for any of the highest salary 6 7 eight any of the nth highest salary now let's see the next question we have to write a query to find the top two highest salaries from a given table so we have to only find the top two highest salary so how we can do that first we have the salary column and in the last slide you learned that we can use this order by Clause to get the maximum salary at the first so we'll use the order by clause on this salary column it will order all the value according to the descending order consider 1 2 3 and now we need to fetch One and Two from this particular list so what we can do is we can give select salary and then we can provide the table name from employee and then we can order the salary in the descending order basically the column name and then the order in which we want to order and then here we can give limit M and N so m is the number of rows which we are skipping but here we want to find the top two so we are skipping nothing so we can give it zero or we can just ignore it and we need the value of n that after skipping what are the rows which you want so we want two rows we can give limit two so in this way we can find the top two highest salary in a given table now let's see the next question so next question is write a query to calculate the total salary and average salary in a department so we learned about aggregate function and how it works on an aggregated set of value so we can use the aggregate function sum here and average here to find the total salary and the average salary so sum if applied on this particular salary column so it will just calculate 1500 + 2,000 + 2500 plus 2400 is 1500 and it will give me the sum or the total salary and if I do the average it will just perform a average here and it will give me the average value so sum and average both will be giving me only one value because it is working on an aggregated set of data so now here I want to find the Department's total salary and average salary and here you can see that there are multiple departments it Department HR department marketing and finance so we need to group these particular departments as well so let's see the query for the same so what we will do is we will select the department and we need to find the total and average salary so we'll be giving some salary and average salary and here we are using an alas so alas is basically an alternate name so it will just do the total of salary and it will give a alternate column total salary where we would be having the result of this total salary consider X and in the same way it will provide an alternate column in the result and it will give me the average salary but these columns are not created it's just an alternate or you you can say a temporary column so I'll get Department I'll get the average salary I'll get the total salary but now I want each department total and each department average so I'll be using this group by Clause Group by Will Group all the department accordingly so it will group it HR Finance marketing into subgroups and for that particular groups we'll get the average salary and we'll get the total salary again for finance we'll get the average salary and the total salary so consider if there is a column order in which we have kurkur dairy milk and Maggie and we want to know that what is the total amount of all the sales which has happened for kurkur for Maggie and for dairy milk so what we can do is we can group them accordingly and then we can find the total sales and then the average sales for them so in this way we find the total salary and average salary for a particular department so the next question is write a query to find the rows where a department has null values so if we don't provide any value for a department for a particular record or you can say for a particular data entry it fills a null value there if we don't provide a notnull constraint so we need to find all the rows where a particular column or you can say department has null values so there is a operator called as isnull which we can use so we'll give select and then we need to find all the columns so we'll give star from and then we provide the table name that is employee then we'll provide the condition where the column name here it is department and then we provide this isal so basically what it does it it goes in the department and it find if there is any null value present here or not if there is any null value found in any row it will go ahead and return that particular Row in the final result and all the details of that particular row so let's see the next question we have to write a query to find the duplicate rows in employee for the given column department so this is my employee table in this particular employee table I have to go to this particular column department and I have to see that which all department is having duplicacy so here if you see the department is it here and here as well so can we say that there is a duplicacy for Department call in these two IDs 1 and three yes we can say now coming to HR so HR is not getting duplicated anywhere marketing it's not Finance it's not but again it's a small table but there could be a huge table or huge data sets so for that we have to write a query now what we can do here is first we need to find all the Departments according to their group so we need to find that if there is any duplicacy in IT department in HR department in marketing department and in finance department so we need to find according to the Departments if there is any duplicacy or not so what we will do is we will apply a group by clause on our department column so that it groups the data accordingly now we need to find that if these particular groups are having the count greater than one if they are having the count greater than one it means that there are some duplicate values which are present if I say that it department is having only the count as one so it department is only present one time if I said if it department is having the count as two so it department is getting duplicated and that is what we have to find the duplicate rows so wherever count is greater than one we can say that there is a duplicacy now how can we find this particular count so we can use this count star Now using this count star it basically counts all the rows which is present in our table so right now count star for this particular table can give me the value as five but I only want the count for the department so consider if I give a condition where department is equal to it so it will only count the rul who are having the department as it so if I count it is one and two so then the count star will be giving me two but here I want for all the groups of department for it HR marketing and finance so what I'll do is I'll apply this count star on this particular group and then I'll check that whenever the group is having the count greater than one then we can say that there is a duplicacy so the query is Select then we need to select the department on which we are applying the group buy then we give the count star and then we provide from and then the table name and then we provide the group byy clause which will group the department according to HR marketing finance and it and then we provide a condition having so having we have used here because we have used the aggregated function so having countar greater than one so we'll just find the count star for each consider for HR it's one for marketing it's one for finance it's one and for it it's two the countstar is 1 one one and two for them and now I need to find that wherever count star is greater than one there is a duplicacy so we can say that it department has a duplicacy now if you're not understanding about all these things I'll really suggest you just go ahead and watch a comprehensive oneshot tutorial which is uploaded on my YouTube channel so that at least you get clear on these terms and then you can come to this video to practice some questions so now let's jump to some theoretical question so first question is what is SQL now SQL stands for standard query language it is a standard language which is used for managing and manipulating our databases so whenever we need to do any manipulation like any crud operations in our database so what is crud operation crud operation is basically creating reading updating and deleting so whenever we need to perform any crud operations in our database we use SQL now the second question is what is the difference between delete and trunk it so delete removes the rows from the table based on a condition but truncate remove all the rows from a table so if we want to remove a specific Row from a table we use this delete command but if we want to remove the entire data set which is present in our table we use the trunet command now delete can be rolled back because it contains all the logs but trunk it can't be rolled back because it doesn't lock the individual rows and it can't be roll backed now the next question is what is Union and Union all so Union combines the result of two queries and remove the duplicate rows so whenever we perform Union between two tables A and B so it will just remove the duplicate rows which is present and it will give me this particular data and this particular data whereas Union all combines the result of two queries and include all duplicates so if there are two queries A and B it will give me the result of a it will give me the result of B and it will also include the duplicacy which is present between them so Union combine the result of two queries and remove the duplicate rows whereas Union all combines the result of queries and give the duplicate rows as well now next question is what is store procedure so a store procedure is prepared SQL code that you can save and reuse so whenever we create a procedure we can use it anywhere in our SQL queries so that we don't need to type a same query again and again consider if I want to find the max salary of a person in many of the queries so I'll just create a store procedure and I'll be using that store procedure in number of queries so that we can save it and we can reuse it as well now coming to the next question what is the difference between care and where care so is used whenever we have a data of fixed length so if I know that name would only be having five characters like all the names which is inserted in our employee table would be only having five characters then I can use car and I can give five but when I know that they should be having a variable length consider email email of a person can be having variable length some can have 50 characters in the email but some can have 100 characters also in the email so for that use case we use Vare which is used when we have data with variable length so even if I'm giving Vare and consider if I'm giving 20 if my email is having 22 characters it will just extend itself so it's a dynamic way of storage and you can say that car is a static way of storage now coming to the next question that is explain the types of joints in SQL so the very first join is inner join so what inner join says that if there are two sets a and b or you can say two table A and B it returns all the records that have matching values in both the tables so the matching values lies here consider I'm naming it as C so inner joint returns me all the matching values which is present in a as well as B so it will return me c now coming to left outer joint so left outer joint returns all the records from the left table and the match records from the right table so it will return all the records which is present in the left table that is a and it will return the match records from the left as well as right table that is C now coming to right outer joint so it returns all the records from the right table and the mashed records from the left table so it will return all the records from the right table and then the mashed records of the left and right table so that is B+ C now coming to full outer joint so it returns all the records when there is a match either in left or in the right table so it will return all the records if there is any match between the left or the right table so it will give me records from this left table the right table and then the records which are matching between them that is a plus b plus C now coming to cross joint so it Returns the cartisian product of two tabl so whenever we are performing a cross product between two tables that is all the elements of table one is getting cross product with all the elements of table two that is table B then we say it as cross joint and coming to self join so cell join is a join where a table is joined with itself so whenever we are performing join between two tables who are having the same data set we can say that this is a CJ now coming to next question what is null in SQL so null in SQL is basically used whenever we want to encounter or whenever we want to save any null values so it is used to handle null values in SQL now coming to next question what is a foreign key so foreign key is a key that helps in establishing a relationship between two tables so if there are two tables A and B so foreign key help us to establish relationship between two table and foreign key is a key which take reference from the primary key in the base table so you can say that foreign key help us to establish a relationship and foreign key also take reference from the primary key in the base table so it uniquely identifies a row of another table so foreign key is a key which takes reference from the base table so it is also called it as referencing table and the table from which it is taking reference is called as reference table or you can say base table and foreign key in a given table can also act as a primary key can also not act as a primary key so it is not important for a foreign key to act as a primary key for another table it just take references from primary key of table table a and it establishes a relationship between two tables now what is primary key so a primary key is a unique identifier or you can say a unique key which uniquely identifies records or you can say rows in a given table so if we have different rows in a given table and if we want a unique identifier that can help me uniquely identify record in a table so that is a primary key so we can see a primary key is a unique identifier or key which uniquely identifies all records in a given table or in a given relation now there are two constraint for a key to be a primary key that it it should always be unique so there shouldn't be any duplicate values here and it should always have Nal values so there couldn't be any null values here so if we are declaring any attribute as primary key it should always be unique it should always be not null and it should uniquely identify all the records or all the rows in our table now the next question is what is the difference between where and having Clause so where is used to filter records before any groupings are made so consider if we are grouping anything if we are grouping the department M into it HR and we want to know that for that particular groups what are the total employees what is the total salary so before grouping the data if we want to filter the data we use the wear Clause but if we are grouping the data and if we want to perform some filter or some condition we use the having Clause so having Clause is used to filter records after groupings are made or you can see basically when whenever we are using aggregate function like group by we can use this having Clause so having Clause is used after grouping the data and where Clause is used before grouping the data and both are used for filteration or you can say providing some condition now coming to next question what is views in SQL so views are a kind of virtual table in SQL so whenever we are creating a virtual table for security purpose consider that there is a huge table of employee and I want to create ID card for these particular employees but do the people who are making ID card needs to know that what is the salary of this particular employee no so these are some data which needs to be remained with us only so we'll just provide a view of of this particular table who would be having a new table or you can say a virtual table which would be only having employee name and employee ID which would be required by the department who are making ID cards so we are just hiding some of the details which is unnecessary or which is like secure which doesn't needs to be known by the department who are making the ID cards so views are a virtual table in SQL now what is default constraint so whenever we want to provide any default value for a given column we use this default constraint so whenever we need to fill a Colum with default or you can say fixed values we use default like set the default salary as zero where age is null it should be salary is null so whenever I'm not entering any value for the salary column and wherever salary is getting as null we will set the default value as zero so salary won't be having any null values if there is any null values or if we are not entering data for that particular field or you can say that particular record we can set the value as zero for them now next question is what is an alas command in SQL so alias are temporary names which are given to a table or column which is just a temporary change that is table name does not change in the original database consider if I am having a salary column in my employee table which is having some records and I need to find the total salary of all the employees so for that we can use an alternate name while calculating the total salary so we can use sum of salary to calculate the total salary and then I can use an Alas and then I can provide it as total salary so if I use this in my final result I'll be creating only one table which would be having only one column that is total salary and it will be having the total salary which I have calculated from here consider X so this is just an alternate name there is no changes to the database no changes to the table name it's just an alternate name or you can say a temporary name which we are giving for any calculation which we are providing in any of our columns or set of columns now first we'll start with how we can think on what SQL Clause operator function to choose in given scenarios or given condition so the very first scenario is when we want to have a data retrieval so whenever you want to retrieve some data from the database it is oftenly suggested to use the select statement because select statement is used for retrieving data from one or more tables so whenever you want to retrieve some attributes or some data from the database you can use the select statement now coming to the second scenario that is data filtering so whenever we want some data to be filtered consider based on some condition or consider based on some of the logic so we would be using all these so first is we Clause so wear Clause is used to filter records based on some specific condition so whenever there is a table and in that particular table there are some attributes as well as tles and if you want to filter some data based on some condition we can use this wear Clause now coming to and or and not operators so these operators are oftenly used whenever we want to combine two or three condition consider that I want the data of all the person whose age is greater than 80 and gender is equal to male so when ever we want to Club two conditions or multiple conditions we use this and or not operator now coming to between so whenever we want to do a search based on some specific range consider that I want the details of all the employees whose age lies between 18 to 50 so for this particular range if I want to do a search I can use the between operator now coming to in so in checks whether a specified value matches any value in the subquery OR list so we have a specified value and it that if that particular value matches in the particular list which is present here or in the subquery which is present here now coming to like so whenever we have any pattern matching problems consider that we want the employee details whose name start with a we want the employee details who have a as the second character in their name so for all those questions we use this like operator so it is used for pattern matching we use it with percent as well as underscore where underscore represents a single character and percent represent the before or after characters now coming to the next scenario that is aggregation on data so whenever we want a single value for multiple rows we use this aggregation so what are all these aggregations so first is average it Returns the average value of a numeric column so if there is a column in a given table and if we want the average of that particular column we use this average consider if there is a salary column and I want the average salary it will go ahead and find the average for the entire set of rows which is present here now coming to min it Returns the minimum value in a column like consider minimum salary coming to Max it Returns the maximum value in a column so if we want the maximum salary we can use this coming to sum it Returns the total sum of the numeric column so it goes ahead and add all the records or all the data which is present in this salary table and it will give me the total sum now coming to the count so count counts the number of non-null values in a specified column so consider if there is a column salary now salary has some values a b c and consider one value is null because there is no value so count will go ahead and count the number of rows but it excludes the null value so it will give me the output as 1 2 and three so whenever I performing count on the salary column it will give me the output as three because it will go ahead and count the number of rows which are having nonnull values now coming to count star so count star counts the total number of rows in a table including the rows with null value so if I'm using count star it will go ahead and count all the rows like it will include null as well as nonnull values so it will give me four as the output so count will exclude the null values count star will also include the null values now coming to the next scenario that is grouping and filtering of groups so whenever we want to do some grouping and whenever we want to do some filtering based on that groups so we use this group by and having so what is this group by used for so whenever we want to group rows that have the same values in a specified columns we use the group by so consider here there is salary a b c and consider there is one more salary a now here we can see that a and a is repeated twice like for the salary column there are two A's which is present right so we can group them in a single group then we can Group B then we can Group C like in Department we used to group Department basis on it HR marketing so Group by is basically used that whenever we want to group some data which is present in some specified column now coming to having Clause so having is basically a condition which is applied on the Group by clause or you can say which is always applied to an aggregated data so where is applied whenever we want to filter data based on some condition when the aggregation hasn't happened but when the aggregation has happened we use the having clause for filtering the data so having Clause filter the groups based on some specific condition so we have formed the groups using the group by Clause now we want to filter on the basis of some conditions so we will be using having Clause now coming to the next scenario of sorting of data so whenever we want to sort our data in ascending or descending order we use this order by so order by sorts the result set by one or more columns so if there is a column considered salary and if there are some salaries present considered one rupees 2 rupees 3 rupees we can sort these salaries based on ascending and descending order using order by by default the order by uses the ascending order so if we have to give for descending order we have to say that the order should be descending so we have to give it explicitly now coming to the next scenario that is data retrieval from combination of two or more tables so consider that there are two tables student and student course details now I want some data from this table as well as this table so I have to join this table so that is why join is used so what happens we can join these tables to F some data from this table as well as this table based on a specific column which is common between them so there are some joints inner joint left join right joint full joint which combine rows from two or more tables based on related columns So based on some related columns it combines the rows and give me the result now coming to the next scenario that is conditional logic so in where we were filtering the data based on some condition but how we can create the condition so for creating the condition we use this case and if so whenever we want to create some condition we can use this case and if so case perform conditional logic within a query using when then and else and if Returns the value depending on whether a condition is true or false so if we are using this if it Returns the value based on some condition so if this condition is true it will return the first value if this condition is false it will return the second value so this is how we use the if and case we oftenly use with when and then so we give when and then we provide the condition and then we give the result so it is then and the result and then we end it when it's done so this is the way we use the case and this is the way we use the if let's see that how we can solve SQL question or what is the approach we should follow so the very first step is understand what the question says so we need to understand that what the question exactly says like if the question is asking for some retrieval of data if it's asking for aggregated result or joining tables or performing some updates or deletes so we have to go through the question and we have to figure out that what specific condition it needs to be accommodated there now coming to step two check the data type constraints primary key foreign key and the relationship between the tables so if there are multiple tables we have to check the foreign key and the relationship between those table if there is a single table or consider if there is a table we need to check the data type of given columns or attributes the constraints if there are any present the primary key which is for that particular table so we have to check for all those things now coming to step three we have to use the appropriate SQL Clauses and functions so as discussed in the last set of slides that if there is any data retrieval we can use select if there is any filtering based on some condition we can use where if there is any grouping we can use Group by if we need to do filtering on the groups we can use having so in the same way we need need to know what are the appropriate SQL Clauses or function we can use here now coming to step four ensure appropriate indexes on the column in We join and order by Clauses so whenever we are using this We join and order by Clauses we have to make sure that we are performing the operations based on the indexed column only so indexing help us to have the results very fast and it increases the query time if there is no indexing present it will go ahead and scan the entire database so that will take a lot of time right so the increases its time whenever there is no indexing present but if there is indexing present the data retrieval is very fast so these are the questions which we would be discussing I'll provide the links in the description so you can go ahead and watch out the questions and then go ahead and solve it once so first question is swap salary second is duplicate emails third is employee earning more than their managers fourth is not boring movies and fifth is class more than five students so let's start with swap salary so what is the question so we have to write a solution to swap all F and M values that is change all F values to M and VI Versa with a single update statement and no intermediate temporary table so there is a salary table which is given which is having column such as ID name sex and salary and what we have to do is we have to change M to F whenever we found M and we have to change F to M whenever we found f so we have to basically do a swap for M to F and F to m in this particular salary table so take 2 minutes and think that how we can approach this question and then we would be solving this problem so let's start with solving the problem so what is given here it is given that we have to swap these values M with f and f with M apart from this there is one more thing which is given that we have to do an update and it would only be a single update like there shouldn't be any multiple updates involved the third given thing is that we don't need or we shouldn't make any temporary tables so temporary tables is not allowed so here can you see that we are forming some kind of condition that whenever we are encountering M swap it with f whenever we are encountering F swap it with M so here we are forming some small kind of condition so can we use this if and case here since we are making a condition yes we can use so how we can use is we'll use if set X is equal to M go ahead and update the value as F and if the X is not equal to M go ahead and update the value to M so would this work let's see so it will come here is x equal to M yes so go ahead and update it to F so it will go ahead and update it to F now coming to this is x equal to M no so go ahead and update it to M so it will go ahead and update it to M now coming to this is x equal to M yes so go ahead and update it to F so it will go ahead and update it to F now coming to the last row is sex equal to M no it's F so go ahead and update it to M so it will go ahead and update it to him so here you can see that it has swapped and updated all the values so we can use this if for forming the condition and we have to update this particular table so we have to form the query in such a way that we have to update this table that is a salary table and what we have to do is we have to set the sex based on whatever value this condition is giving me so in this way we can form the query for this particular question we are going ahead we are updating the salary table we are setting the value of six based on a condition that if SE is equal to M set it to F if it's not equal to M then go ahead and set it to M so in this way we can perform this particular query let's go ahead and solve it from lead code and let's see that if the solution is working or not so here we have to update and the table name here is salary so we'll just pick this so salary and then we have to set the value in the column six where if 6 is equal to M then go ahead and set the value as F if this condition is false then set the value as M so if the sex is M that is male then go ahead and set the value to F that is female if it's not male then go ahead and set the value as male so this is the final query which we have made so let's just execute this query and see if it's running or not so it has run successfully for the test case which was provided here so let's just submit the solution and we'll see that if it is getting accepted or not so it has accepted so this is how we can swap the salary so coming to the next question that is duplicate emails so this is the table person table which is having ID as well as email in the output we have to provide the email which is duplicated or which has more than occurrence so write a solution to report all the duplicate emails note that it's guaranteed that the email field is not null so email field would not have any null values now we have to return the result table in any order so there could be a possibility that there are two emails which have more than one occurrence so we don't have any order in which we want to return the result like if B has two occurrence and if a has three occurrence we have to return a first or B first so there is no ordering logic involved here we have to just return the email in any order so you can take a 2 minute pause here and you can think that how we can approach this question then we will start solving it so let's solve it so what is given so it's given that we have to find the duplicate email so that is all the emails who have occurrence more than one time in the given table now it is also given that email wouldn't have any null values and the third thing which is given is we can return the result in any order so there is no ordering object involved now we have to find the occurrence of email right so here you can see that there are some emails which is getting repeated twice so why not to group the emails so what we can do is we can group the emails in multiple groups like according to the same values we can form the group like there could be a group of a there could be a group of B there could be a group of c and all these are emails so why not to create group of those emails and then go ahead and count the occurrence of that email so we'll group all the emails and then we will go ahead and count the number of occurrence of that email so it will go ahead and count the number of rows which is present with the email as a with the email as B and with the email as C so would that work yes that would work so what we will do is first we'll go ahead and group the emails so on the basis of values it will be grouped into three or four or many subgroups right now after it has been grouped into subgroups what we will do is we will go outad and count for an individual email that what is the occurrence of this email then what is the occurrence of this email based on the groups only we are counting so we only need to perform this count logic once so what we will do is first we will group the emails and then we will go ahead and count that how many occurrences of a is present in this particular group how many occurrences of B is present in this group how many occurrences of C is present in this group so what we will do in the query is first we will select email which we have to show in the final result and then it would be from and then the table name is person then we'll perform a group by on the email and after grouping the email I'll give a condition that whenever the count of the email which is present in this aggregated group is greater than one go ahead and print that particular email in the final result well go ahead and count the occurrences of all those emails in this particular group and it will provide me all the emails who is having count greater than one so if a is occurring once B is occurring twice and C is occurring Thrice so we would be seeing B and C in the final result so this is how we can solve this particular question so let's see from the lead code so we will be giving the query as select and then the column name is email so let me just copy from here select email and then we will give the table name that is from and the table name is person so person it would be from and then we will give the group by so it will be group by and then we'll provide the column name on which we are grouping so that would be email so we have formed the email groups now from that email group we have to filter all those emails who are having their count as greater than 1 so this is how we can form the query so let's just execute this query okay so it is accepted and it has run all the test cases so let me just submit it so here also the solution is accepted so this is how we can find the duplicate emails in a given group of data so coming to the next question employees earning more than their manager so we have to write a solution to find the employees who are earning more than their managers so there is an employee table which is given in which we have ID employee name employee salary and manager ID so let me name it as M ID so if you consider a scenario of a company so every employee would be having some employee ID like I would be also having some employee ID my manager would be also having some employee ID my director will also have some employee ID so all the employees would be having some ID so that is mentioned here all the employees names are mentioned here all the employees salaries are mentioned here and in this manager ID we provide the manager ID for this particular employee so consider if the first employee is Joe the salary is this and the manager ID is three so we'll go ahead and see that which is three in this ID column so that is Sam so the manager for Joe is Sam now coming to two that is Henry the salary is given and the manager ID is four so what is four in this particular column that is Max so will give Max here so max is the manager of Henry and Sam is the manager of Joe and coming to Sam and Max there are no managers because they themselves are manager so here you can see that this is the way we can figure out that who is the manager for this particular employee right now what we have to do is we have to find the employees who are earning more than their managers so we know all the employees now we know their managers as well from the manager ID now we have to find out all the employees who are earning more than their managers so how we will find it so just just take a 2 minute pause think on the approach which you can think and then we'll go ahead and solve this particular problem so let's start solving so what we will do is we are given with a table which is having employee ID employee name employee salary and manager ID so here you can see that the manager ID is given like 3 4 null and null so right now I don't know that for the employee consider Joe who is the manager like I'm going ahead and manually writing Sam but there could be a database which is having like huge set of data so for that data I won't be going at and manually seeing the name and writing it here right and again I need the manager salary as well so here I'll be needing Sam salary and here I'll be needing Max salary so what we will do is we will figure out a way in which this particular manager ID displays me all the manager details right so this particular manager ID displays me the manager name manager salary manager personal details as well so what I'll do is I'll perform a join operation here now how I'll perform a join oper operation here so here you can see that there is a hierarchy which is getting formed right so here Joe is having Sam as the manager Henry is having Max as the manager and Sam and Henry are the employes so there is some hierarchy which is getting formed so for all these type of questions where we can see that there is some hierarchy getting formed and some sort of data is dependent on other set of data we use the join and here we will be using the self join so why we would be using the cell joint because here there is only one table and we have to somehow figure out the manager details from this manager ID itself so what we will be doing is we will be performing self joint that is we will be joining this table from itself so that whenever this table gets joined with this table like itself only we will get the manager detail so how we will get the manager detail so consider that there are two tables for now E1 and E2 although these tables have same set of data but consider that this is the employee table and this is the manager table now I need all the manager details so what I'll do is I'll join this table with this table and the condition of join would be that even. manager ID is equal to e2. ID so e2. ID is the manager ID which is acting in the manager table so what we have to do is we have to replace this manager ID which is present in even1 or we have to do a join condition based on a condition where e1. manager ID is equal to e2. ID so we can replace one with all the details and we can replace four with all the details like replacing here doesn't mean that we are replacing any data but we will get all the details so we'll perform a join operation here so that we can get the manager details and then we can perform the operation that where E1 do salary that is employee salary is greater than e2. salary that is manager salary so we'll perform a join operation here so how we will do it so we'll give select and then what we need in the final result is employee name so we will give even. name because right now we are performing a self join and in cell join we are performing it on the same table so we can't give the same table name right so we have to provide an alternate name for this particular table so we are giving e1. name and then we will give from employee even and then we'll give the self join and then I'll give employee E2 that is right now a manager and this is the employee table and then I'll give the condition on which I'm joining that is e1. manager ID is equal to e2. ID so that if e1. manager ID is three here so we can go ahead and populate the details for three and if e1. manager ID is four here so we can go ahead and populate the detail for four so three is Sam and four is Max so we can populate their details here now what what we have to do is the condition is where E1 do salary that is employee salary is greater than e2. salary that is manager salary so we have to check for employee salary which is greater than manager salary so we are doing a sell join here because there is some kind of hierarchy and relationship formed here again we are doing a sell join because here we only know the manager ID but we need to know the manager details manager salary details name and everything so that is why we are self joining so that we can get the manager detail from the other table now here we are naming it as E1 and E2 because we are performing the sell join on the same table we can't give the same name whenever we are performing the cell joint so we have given E1 and E2 now this is how we can perform the cell joint if you're getting confused here I have uploaded a tutorial on self jooin in my YouTube channel you can go ahead and have a look so that all the concepts of the self jooin is clear once you understand the cjin this question is a cakewalk so let's just solve it from lead code so what we will do is first we will select even. name and then the table is from employee E1 and then we'll perform the join operation with employee E2 and then we will give the condition on even dot let me pick the column name from here manager ID ID is equal to e2. ID and then we'll give the condition where E1 dot salary that is employee salary is greater than E2 do salary that is manager salary so we'll give the select even. name we want name then from this employee table even and then we are joining it with the employee table only so we'll give E1 and E2 then we will perform a query based on e1. manager ID is equal to e2. ID and we have to fetch the salaries where the salary of employee is greater than manager salary so I guess the table name here is employee so let me just replace this with employee and let's just run this query okay so we are getting wrong answer okay so here you can see that we are getting the wrong answer the reason behind it is in the output we are getting the table name and name but expected output is we want the table name as employee so what we will do is we will just provide an alas so we'll provide as employee so it will give an alternate name to this e1. name or name so let's just run this again so here you can see that now it has run successfully so this is how we can go ahead and check our errors and then modify the query as it is so here the error was that it wanted the name for the table to be be employee but it was displaying as name so that is why the error was coming so this is how we can solve the question of employee earning more than their manages now coming to the next question that is not boring movies so here we have to write a solution to report the movies with an odd numbered ID and a description that is not boring so we have to get all the movies who are having odd numbered ID and then the second thing is they should be having a description which is not equal to boring so I want to fetch all the movies who are having the odd number ID and the description is not equal to boring so return the result table ordered by rating in descending order after that we have to return the table ordered by the rating in descending order so this is what is given in this particular question so again take a 2 minutes pause think that what we can use here and how we can approach this question and then we will be solving it so so let's solve this question first we need to think that how we can find the odd numbered ID so odd number ID here is 1 3 and five so how we can find this IDs so whenever we do a modulus of any number with two and if it gives me the remainder as one we call it a odd number so here we would be using the inbuilt mod function which is present in es schol where we can provide the column name on which we want to perform the modulus operation then we can give the value that is two that we want to perform modulus on two and then we can compare that if the remainder is equal to one or not so using this we can get the odd numbered IDs now coming to description so description should not equal to boring so we should go to this description column and we should check that if the description is not equal to boring or we can also use this operator that is not equal to now coming to the next part that is we should order the result by rating in descending order so let's see that how we can form the query for the same so we'll give select and Then star because we want all the details which is present in the input table then we will give from and then we'll give Cinema and then we will give the condition where so the first condition is mod of ID and 2 is equal to 1 and the second condition is and description is not equal to boring and then we have to order the result so we'll be using order by and then we'll give the column name that is rating and then we'll give the order that is descending let's go to the lead code and write this particular query and see if it is a accepting solution or not so first we will give select and then we will give Star since we want all the results in the output then we will give him from and then the table name so that is Cinema so let me just copy this Cinema and then we will give the condition where the first condition is mod of ID comma 2 is equal to 1 and the second condition is description let me pick it from here only so description is not equal to and then the value is boring we give boring and then we will order the results so we'll use order buy and then we'll give the column name that is rating and then the order that is descending so let me just run this query so here you can see that the query is accepted and has run all the test cases so let me just submit it so here you can see that the query has been accepted so this is how we can find the not boring movies now coming to the last question that is classes more than five student so we have to write a solution to find all the classes that has at least five student at least means either greater than or equal to five so we have to find all the classes who are having at least greater than or equal to five student so this is the course table which is having student as well as class all the student names are given and all the classes given now we have to find the class which is having more than five students so take a 2minute pause think that how we can approach this question and then we will go ahead and discuss the solution so this is kind of a same question which we solved in the duplicate email so what we have to do is first we have got the classes as well as students so what we will do is we will form the group of all the class so we'll group the class and after we have grouped the class we will count the number of students so once we have group the class we'll count the number of student and whenever the count is greater than or equal to file we'll print it in the final result so it was very easy what we have to do is first we'll group the class so we'll group the class according to the value so there will be a class maths there will be a group of class English biology in this way there will be multiple groups now in all those groups there would be a students who are enrolled in these particular classes and then we can count the number of students in this particular groups and we can see that wherever the count is greater than or equal to five we have to return it in final result so let's see how we can form the query so first what we will be doing is we will be selecting class and then we'll give from and then the table name is courses and then we will be grouping Group by class so we have formed the group of the class then we have to give a condition having count of student count greater than or equal to 5 so this is how we can write the query for for the same first we will be selecting class then we would be grouping these class and then we would be counting the number of students which is present in this class so if the count of student is greater than or equal to five we will be returning those classes in the final result so let's see from lead code how we can solve this so first what we will be doing is we will be selecting class and then the table name is from courses so let me just copy it from here from courses and then we'll be giving the group buy Group by and then we'll give the column name that is class so then we'll give the condition having then we'll give count and then we'll provide the column name that is student greater than or equal to five so this is how we can form the query for the same select the class from the courses table group the classes and then count the number of student in those groups and if it's greater than or equal to five return it in the final result so let's just run this query so here you can see that it has accepted and run for the test cases so let me just submit this this is how we can approach a SQL question now the word transaction may be familiar to many of you consider that I want to transfer some money to my friend and once the payment is successful I often get the messages transaction is successful consider that I'm ordering something online and once the payment is successful here again I get the message as transaction is successful so you can understand it in this way that transaction is basically a collection or combination of some database operations like read write commit roll back which is used to perform a specific task so transaction is a logical unit of work that comprises of one or more database operations like read write comit roll back to perform that particular unit of work so consider there is a person a who wants to transfer 50 rupees to person B so this is a transaction which is happening here now transaction have read as well as write operations and then there are commit and roll back so it would be learning about commit and roll back in next set of slides but let's learn about read and write operation so read operation involves retrieving or fetching the data from the database so whenever we are retrieving or fetching some values from the database we call it as read operation it is often denoted by R now coming to WR operation so a right operation in transaction involves modify ing the data in the database so whenever we need to modify or update the data in the database we use this right operation so it is denoted by W so let's come back to this example again now a wants to transfer 50 rupees to B so what are the things we need so first we need what is the current bank balance of a consider that if a is having only 20 rupees would he be able to transfer 50 rupees to B no so we need to fetch the current bank balance of a so first we will do a read operation on a which is fetching the current bank balance of of a from the database so consider that right now A is having 100 rupees so we have fetched the current bank balance of a from the database now we have to perform this arithmetic operation where we will be deducting 50 rupees from A's current balance so that would be 100 minus 50 that is 50 rupees now A's current balance is 50 rupees so we have to update this value in our database but before updating we need to know that if this particular amount has been transferred to b or not consider that we have updated the value of a but at some some point B does not receive 50 rupees so there will be data inconsistency so what happens is we do a right operation we do a modify operation but this particular right operation goes ahead and update the value 50 in the transaction logs or you can say a shared memory so before commit if there is any operation which happens in a transaction always go to the transaction log or log records so this value would be updated in the log records now coming to B again we need to know that what is the current value or current balance of B so we'll do a read operation on B so it will give me the current bank balance of B consider 50 rupees so we have got the current bank balance of B now we need to add 50 rupees to B's balance so we'll do arithmetic operation so it will add 50 rupees to current B balance that is 100 rupees now we need to update this value as well in the database so we will do W of B this will be W of a so it will update the value to 100 rupees again this will go ahead and get saved in the transaction logs we are not saving or updating the value in the database yet now we know that all the operations have been successful the arithmetic operations and everything have been successful then we will perform a commit operation commit says that if all the operations have been successfully done then go ahead and update the value in the database so commit will read everything from the log records and once log records see the commit it will go ahead and delete all the log records and it will get updated in the database so this is how the transaction happens so here also there is a example considered we are using the swigy app we are ordering something we go to the payment page we enter the bank details and we get the OTP there could be two scenarios one there is some network issues or failure second there is no network failure so when there is no network failure the order is done the payment is successful and the transaction is complete but once there is a network failure which is encountered there could be two cases one the amount is deducted from your bank account second the amount is not deducted from your bank account so there is a roll back which comes into picture which says that if at any point there is any failure which is encountered in the transaction before commit what we do is we roll back it to its original state so that if there is any amount which is deducted you will get a message that you will be getting credited this particular amount in your bank balance within 7 days or within 24 hours because that is a roll back step which is applied so if you are entering your OTP and some amount is deducted from your account but still the order is not completed or the order is not done you will get that particular amount back in your bank balance or you will get that particular ular amount refunded so consider a example of a banking application where a customer Ram wants to transfer 100 rups to sham so let's see all the steps which we discussed here only but let's see how these steps execute so the step one is we have to begin the transaction the step two is the application will fetch or read the current balance of ram since Ram wants to transfer 100 rupees to sham so we'll fetch the current bank balance of ram so that would be read of ram now the step three is the application will calculate the New Balance after the transfer so that would be uh current balance of ram minus 100 rupees so consider right now Ram is having 200 rupees so we have to deduct 100 rupees from current bank balance of ram that would be 100 rupees so we have performed the arithmetic operation now the step four is we have to update it in the temporary storage or transaction locks that is W of ram that is right of ram so why we are updating it in the temporary storage or uh transaction locks because consider that if we are deducting something from Ram balance this particular amount should be transferred to Sham if at any point while transferring there is a failure which has happened so we need to take care that if the transaction is successful only then go ahead and update in the database before that update it in the transaction logs so that we have logs of everything but we are not updating any inconsistent data in the database now the step five is the application will fetch and read the current bank balance of sham then step six is the application will calculate the new balance of sham after the transfer consider sham is having 100 rupees so after the transfer for sham is having s + 100 that is 100 + 100 that is 200 rupes now the step 7even is we have to update it in the temporary storage or transaction log that is W of sham since we are modifying the data now step eight is if all the updates are successful at all these steps everything is successful and there was no failure and there are no errors commit the transaction to make the changes permanent so we have to perform a commit operation at the end of transaction so that all the changes are permanent and it's updated in our DB so it will go ahead and update in our DB logs are maintained till the occurrence of commit after that log files are deleted and database is updated so before the commit all the log files and everything is maintained but once it encounters commit it deletes all the log file and it goes ah and update in the database now the step nine is if an error occurs during any step roll back the transaction to revert the changes made within the transaction that is roll back so consider at any step from step one to step seven there is any issues which we have encountered or the transaction has failed because of network failures data failures or things like that so what we have to do is we have to perform a roll back so that everything is reverted back to its original state and there is no data inconsistency which is present in our database so roll back is often introduced whenever we encounter error or any issues at any point of the transaction so this is all about the steps involved in the transaction so considering the last example let's learn about transaction state so this was the transaction log for the last example first we begin the transaction then we read the value from Ram then we do the arithmetic operation then we write in Ram then we read the value of sham we do the arithmetic operation we update the value of sham then we do commit so that all the data is pushed into the database if everything is successful and we perform roll back if we encounter any issues still here so the case one is where all the operations are successful and we are updating the data into the database so the very first step is the active state so the active State occurs that whenever the transaction is begin and we start performing the database operations at that particular moment the active State occurs so here you can see that before commit whatever is the operation which is being performed we say it as a partially committed State because if at this point there is any failure encountered we roll back the entire transaction or if at this point there is a success AED so we commit the transaction so we call it as partially committed State now coming to commit so this is a successful State we can say now we have come to a successful State and now we can update the data into our database and then after roll back there is a completed State the transaction is completed now coming to case two where we encountered some failures during the transaction so again when we are reading the value it's the active state after the begin statement whatever operation we are performing is the active state if before the commit operation operation whatever operation is getting performed if it fails somehow then we call it as a failed State and then commit state is called as canceled or roll back because we don't commit we rather roll back so if there is any issue which is encountered at this stage we come to roll back if not then we come to commit so we will cancel or roll back and then the transaction is completed even though it's failure but the transaction has been completed now we again need to do the transaction so these are all the states which are involved in a transaction let's learn about concurrency control so concurrency control ensures that multiple transaction can run concurrently without compromising the data consistency so if there are two transaction T1 and T2 it ensures that T1 and T2 can run concurrently or parall without compromising the data consistency that is data should be similar for both the transaction there shouldn't be any data inconsistency so consider example where there is a banking system where two transaction are happening concurrently or parall so is giving 100 rupees to Sham and Sham is giving 50 rupees to Ram so the data should be consistent for both the transaction because if Ram is giving 100 rupees to Sham we have to deduct 100 rupes from Ram's current balance and if sham is giving 50 rupees to Ram we have to deduct 50 rupes from Shams bank balance so these two are happening concurrently and as part of the same values so we can say that the data should be consistent as part of this concurrency control so if there are two transaction T1 and T2 and if as part of t T1 also we are updating some value and if part of T2 also we are updating some value the data should be consistent it shouldn't be a case that if we are updating some value here then we are going here and reading the same value and then updating the new value it shouldn't be the case the transaction should be isolated of each other so the uh if there are any concurrent or parallel transaction that should happen without any hindrance to the data consistency so there are some techniques which are oftenly used to manage the concurrency control first is locking second is two-phase logging and third is time stamp ordering so we can use these techniques to manage the concurrency control in our database now what are these aset properties so asset properties are the properties which ensures that the transactions are processed reliably and accurately even in complex situations like system failures or network issues so if we encounter any complex situations like system failures network issues while having a transaction it makes sure that the transaction is accurate and reliable so asset properties are the properties which make sure that our transaction is processed reliably and accurately now coming to the acronym asset so a stands for atomicity which means that either execute all the operations or none of the operations should be executed coming to see that is consistency which says that read should fetch upto-date data and write shouldn't violate any Integrity constraints now coming to I that is isolation so one transaction should be independent of other transaction that is they should be isolated now coming to D that is durability so the committed transaction should remain even after a failure or crash so if we update the value in the database that should remain even after we fail any failure or crash so let's learn about each and every in depth now coming to a that is atomicity so it ensures that a transaction is treated as a single unit of work either all operations are completed successfully that is commit or none of them are applied that is roll back so as I told in the earlier videos as well that if at any point there is any failure which is encountered in the transaction before the commit we often perform the roll back that is we revert back it to its original state so it says that either all operation should be completed or none of them should be applied so if there is a transaction considered there is a transaction begin we read a value from a we update the value of a and then we perform the commit if at any point here if the transaction fails because of some Network failures or other issues we have to perform a roll back so we will perform a roll back and it will go back to its original state and if at any point there is no failures then we perform the commit and the data is updated into our DB so this guarantees that the database remains in a consistent State despite any failures or interruptions during the transaction it ensures that our database remains in a consistent State because consider that if I have updated any value into our database and if there are some more operations which are being performed on the same data then there should be inconsistency which will be present now consider example so consider Ram is transferring money to Sham the transaction must deduct the amount from Ram's account and then added to Sham account as a single operation if at any moment or at any part this transaction fails while transferring amount from round to sh example due to insufficient funds System error network error the INRI transaction is rolled back ensuring that none of the account is affected partially so if there are transaction which is happening between two accounts RAM and Sham and if we are transferring any amount of money from Ram to Sham if at any point there is any failure which is encountered because consider maybe we are transferring 100 rupees to Sham and Ram's current balance is only 50 rupees so we are encountering an issue because Ram is having insufficient balance so we should roll back this transaction and it should come to its original state so let's learn about consist consistency so consistency ensures that first read operations retrieve consistent and up to-date data from the database and second right operation ensures that the data modification maintain database constraint such as foreign key relationship unique constraints so that the data remains accurate so consistency says that the data should be consistent now whenever we are performing any read operation of any of the data consider we are reading the value of a so it should show me the up to-date data like the last updated value of a should be shown while doing the read operation and coming to the right operation so if I'm doing any right operation on the a so it should ensure that the data modification maintain database constraint so if there is any constraint which is applied consider that it is a primary key so I can't update any duplicate value in it right so these constraint should be maintained and these constraint should be taken care while updating any value in the database so it guarantees that the database remains in a consistent state before and after the execution of each transaction so it ensures that our database should be in a consistent State before and after execution of any of the transaction so consider a is transferring 10 Rupees to B so what we need to do first we'll fetch the current value of a so the current value of a is consider 50 rupees now we need to perform the arithmetic operation where we need to reduct 10 Rupees from a so that would be 50 minus 10 that is 40 rupes so we will write the value of 40 in a now we need to fetch the current value of B so we'll fetch the current value of B consider 20 rupees now we need to update the value of B so B will be having 10 Rupees extra so that would be 20 + 10 that is 30 rupees now we have to write this particular value in B that is 30 rupees so before the transaction if you see a was having 50 rupees and B was having 20 rupees so 50 + 20 gives us 70 now after the transaction if you see a a is having 40 rupees and B is having 30 rupees if we again do the addition it is 70 so you can see that data is consistent before as well as after the transaction so consistency basically ensures that the data should be consistent if we are reading any value from the database it should give me an up to-date value if I'm writing any value or updating any value in the database I should follow the Integrity constraints so that the value which is being updated is not a wrong value or doesn't violate any of the integrity constraint now consider example consider you had 100 rupes in your account but you want 50 rupes cash so you transferred 50 rupes to a person X and he gave you 50 rupes cash now before the transaction you are having 100 rupees in your account now after the transaction again you are having 100 rupees 50 rupees you have in your account and 50 rupees is the cash which you got from the person next so you can see that the data is consistent before as well as after the transaction now coming to that is isolation so it ensures that if there are two transaction one and two then the changes made by transaction one are not visible to transaction two until transaction one commits so if there are two transaction which is happening consider on the data a only there are two set of transaction happening so as part of first transaction we are increasing the value of a by 10 and as part of second transaction we are decreasing the value of a by 10 so while the transaction is reading the data the dbms ensures that the data is consistent and isolated from other transaction so these two transaction should be isolated from each other this means that the other transaction cannot modify the data being read by the current transaction so consider if T1 is the current transaction T2 can't be performed until or unless T1 is committed or all the operations are done successfully only then T2 can go ahead and read the updated value which is being updated here so until it's committed or rolled back so if this transaction is Comm subed or if there is any roll back which is performed we have to wait for this transaction to complete only then T2 can go ahead and read the value of a and perform its operation so here is an example consider a is having 40 rupees in the DB so transaction One is updating the value of a to 50 rupees transaction two is reading getting or fetching the value of a so if transaction one is committed according to transaction two the value of a would be 50 rupees as in transaction one we are updating the value of a to 50 rupees so now 40 would be updated to 50 and since this transaction is committed now T2 can fetch from the current value that is 50 rupees now if transaction one is in pending or running State according to transaction 2 the value of a would be 40 rupees because still the transaction one is not completed so if we read the value of a it would be 40 rupees only because the right operation has not been completed it's in pending or running state so the value of a would be 40 rupees so you can see that there is data inconsistency that is why it said that that if there are two transaction which is happening we have to wait for one transaction to be completed or committed before starting the second operation which involves the modifying the same data which transaction one is also modifying so two transaction should be isolated of each other so let's learn about D that is durability so it ensures that once you save your data that is commit a transaction it stays saved even if the system crashes or there is a par failure so consider you saved your data into the database and immediately after that there is a system failure or there is a system crash that particular data would be saved in your database that particular data won't be lost so your data is always safe and won't disappear after you save as committed transactions are not lost so if you commit a transaction that could never be lost even if there is any system failure or any network issue if your transaction is committed the data is saved it's not lost so most gbms use a technique called as right ahead logging that is W to ensure durability before modifying the data in the database the dbms writes the changes into a transaction log which is often stored on a disk and in a sequential manner this ensures that if there is any failure event the database can recover to a consistent state so how a transaction takes place so consider that if there is a transaction where a is transferring some amount to B so what a will do a will fetch the current value then a will do some arithmetic operation and then after doing the arithmetic operation a will update its value so once a update its value this particular log is saved in the transaction log so when we do write of a it is not saved into the database it is rather saved into the transaction log and transaction log is deleted once we encountered the commit so using this transaction log we can recover our dbms to a consistent state so consider example if you're transferring 100 rupees to your friend and there is a sudden power outage or system crashes right after the transaction is committed the changes the transfer of 100 rupees will still be saved in the database when the system is backup both your account and your friend account will reflect the updated balance so once the system is backup it will show the updated amount to him as well as his friend so this makes sure that even if there is any failure everything is getting saved into our database and we have transaction logs to monitor each and everything at each and every point of transaction so let's re- revise About aset Properties so a stands for atomicity which tells that either all operations should be executed or none of them should be executed C stands for consistency which says that if we are performing any read operation the data should be up to date if we are performing any write operation or update operation we should be following the Integrity constraints to update the value now third is isolation which says that if there are two transaction they should be isolated of each other that is first transaction should commit before the second transaction start now coming to durability it says that if there are any commit changes in our database that should be reflecting that should be saved even if there is any system crash or network failure which has happened now before starting with isolation level let's just understand about isolation so isolation says that if there are two transaction T1 and T2 which is running parall on concurrently you can say then these transaction should be isolated of each other that is if there are any operations which is happening in T1 should be isolated of operations which is happening in T2 now this is what isolation is now what is this isolation level so isolation level is the extent to which these operations are isolated of each other now whenever there is a read or WR operation happening in T1 how much it is isolated with read and WR operation happening in T2 so that is what isolation level is it is the extent to which the isolation in the operations happens now why do we need to learn about isolation level so in systems where multiple transactions are executed concurrently concurrently you can say par like there are threats on which the transactions are getting executed so isolation levels manage the extent to which the operation of one transaction are isolated from those of other transaction so the extent to which operation of one transaction are isolated to those of other transaction that is isolation level and we need isolation level because in systems there are sometimes multiple transaction which happens so we need to know the extent to which if there are multiple transaction happening what is the extent to which their operations are isolated of each other now isolation level help us to prevent common transactional anomalies so there are some anomalies which happens while transaction and isolation level help us to prevent them now what are these anomalies so the first animaly is dirty read now dirty read happens whenever we are reading uncommitted data from another transaction so consider that there are two transaction T1 and T2 and as part of T1 I am writing some data in a but as part of T2 I am reading some data of a so as I have written some data into a this particular data is updated in my internal memory so if the value of a was 10 I've updated the a value to a + 10 so now a value would be 20 and if I'm reading a then I'll be reading 20 not 10 because it is updated in the internal memory it's not updated in the database yet because we haven't committed this transaction but it's updated in the transaction locks or you can say internal memory and what if this transaction fails at some point so if the transaction fails we do a roll back and then a value would be updated back to 10 but here I have read the value of a to 20 so this becomes irrelevant so that is why dirty read happens whenever we are reading any uncommitted data from another transaction now what is this non- repeatable read so non- repeatable read happens whenever data changes after it has been read within the same transaction so consider that as part of T1 I am reading some data as part of T2 I am updating that particular data and as part of T1 again I am reading the same data so here if the value of a was 10 if I updated the value of a to 20 here if I again read the value of a it will come as 20 so during the read operation I can see that first read operation gave me 10 but second read operation gave me 20 so the data changes happened and after it has been read within the same transaction So within the same transaction if there are two read operations which are happening and if in the next transaction there is any right operation which has happened the values would be changed now coming to Phantom read so Phantom read says that new rows are added or removed by another transaction after a query has been executed now consider that there is a employee table in that particular employee table right now there are two records of employee E1 and E2 now consider if I'm doing a get query here right now I'm getting two records but consider if a new employee enters this particular organization so I'll add that particular employee details as well in my table now again if I do a get on this particular table it will give me three records so you can see that the records has been changed again consider that if E2 decides to leave the organization so we'll delete e2's entry from our DB or from our table then again if we do a get then we will again get two records so you can see that whenever there is some insertion or deletion happens the get or the fetching of values or finding of values gives us different set of Records so new rows are added or removed by another transaction after a query is executed it causes is the Phantom read whenever we are reading any uncommitted data another transaction dirty read happens and whenever there is some data changes which happen in the same transaction that is called as non-repeatable read so these are some of the anomalies which are taken care as part of isolation levels now consider that if there are two transaction which is happening read as well as write operation so there could be four possible combinations where if transaction one is executing and transaction two is executing what are the operations they would be persisting so the first one is transaction one can read value transaction two at the same time can read value now coming to the next possible combination transaction one can read value transaction two can write the value as well now coming to the third combination where transaction one can write the value and transaction one would be reading the value coming to the fourth one where transaction one is also writing the value and transaction two is also writing the value since transaction one has read and WR operations and transaction two also had read and WR operations we kept one as constant and then we switched between the different operations which were present here again we kept right as constant and then we switched between the different operations which is present here so these set of operations can happen while two transaction is happening so what is isolation level it determines the degree to which the operations in one transaction are isolated from other transaction so if there are two transaction T1 and T2 and if there are some set of operations which is happening between these two Transaction what is the extent to which this operations are isolated of each other now here we can see that there is a diagram on how a transaction happens so consider that if there is a application as part of application there could be multiple transaction so there is two transaction T1 and T2 now T1 can also have some operations and T2 can also have some operations so what we do whenever we perform any operation in any of the transaction we go ahead and save it in our transaction logs we don't go ahead and save it in the database directly because if there are multiple transaction happening there could be a possibility that there is some failure which is encountered and some of the transaction fails because of that we don't go ahead and directly update in the DB we go ahead and save it in the transaction locks or you can say in the internal memory and once the transaction is committed we can say now it is ready to get saved in the database we delete the transaction locks and we go ahead and save that particular into our DB so this is how a transaction takes place now let's learn about anomalies in more depth so the first animaly is dirty read so reading the data returned by a transaction that has not yet been committed so let's understand from an example consider we are doing some changes into this a and right now the value of a is 10 as transaction T1 we are updating the value of a to 20 updating a to 20 and as part of T2 we are just reading the current value of a so right now the value of a is 10 we updated the value of a to 20 as part of T1 as there is a right operation and as part of T2 we are reading the value of a right now the a value from 10 it is is updated to 20 so we will be reading 20 but consider that at some point this transaction fails T1 fails so whenever a transaction fails there is a roll back which says that revert it back to its original state so we have to revert back all the operation and we have to again go ahead and revert the value of a which we updated to 20 to 10 now the value of a is updated to 10 but as part of T2 we have read the value of a and right now we know that the value of a is 20 but here the value of a is 10 as this particular transaction at some point failed so you can see that this particular data or this particular read operation which we have performed is irrelevant because now this particular data is irrelevant because in our database the value of a is 10 so whenever there is a transaction T2 which reads the data which is returned by transaction T1 and if T1 fails it becomes irrelevant because right now when we are doing a read operation from T2 it is reading the incorrect or data which is not present so you can say a steale data so it's reading a steale data and it is performing all it operation on the steel data so whenever there is a right read happening we call it as dirty read now let's learn about the next animaly that is non-re repeatable read so it says that reading the same row twice within the transaction and getting different values because another transaction modify the row and committed consider again we are doing some redite operations on a so as part of T2 what we are doing is we are updating the value of a again to 20 and as part of T1 we are reading the value of a and doing some operation operations you can say reading the Value Plus doing some external operations that we are not sure right now doing operations so what happened as part of T1 we read the value of a so that is 10 as part of T2 we read the value of a again it is 10 we write the value of a so now a is updated to 20 so it will be 20 and then we commit the changes that is this 20 is now saved into our database until this point it was saved into our transaction locks or you can say internal memory but whenever we encounter this commit it is saved into our database so right now the value of a is 20 so consider that because of some issue the T1 transaction stopped and it again began and now again it is starting reading the value of a now here if it do a read of a it will give me 20 as the 20 is updated in our database but here if we read the value of a it was 10 and on this 10 we were about to perform some operations but right now we need to perform the operations on 20 so you can see that if there are multiple read which is happening in same transaction and if another transaction commits some value or write some value then there is a non-re repeatable read which happens so consider if T2 modifies the data which T1 is already reading and if T1 continues the transaction the data will be changed so here the data was 10 and here the data was 20 T1 stopped in between for some unknown reasons and if T1 again started it will read some changed data so here the value was 10 but here the value has been updated to 20 because another transaction read the same data and committed on the same same data so whenever we are having some multiple reads in one transaction and because of another transaction the multiple reads are giving different values that is called as non-repeatable read now coming to the third animaly that is Phantom read so getting different set of rows in subsequent queries within the same transaction because another transaction inserted deleted rows and committed the data so the same example consider that there is a employee table right now we have two employees present in our table first what I'm doing I'm fetching the name of the employees so right now I'll get only two values for the name of employees now consider that there is another transaction T2 as part of which we are inserting some data into our DB or we are inserting new employee details E3 who has recently joined the company so we have inserted the value of e3 now names will be giving me three values so again if I fetch the name it will give me three records and here it was giving me two records so you can see that here I was getting two records but here I was getting three records because another transaction came and inserted a new set of data here again there could be a deletion as well considered that if E2 left the organization so as part of T2 I can go ahead and delete the entry of employee 2 as well and again if I fetch the names I'll get the only two values so you can see that there is some discrepancies in the records which we are getting while fetching because some other transaction came and inserted or deleted some of the records from our table so this is the Phantom read now we learned about isolation level we learned about animales but let's learn about types of isolation level so there are four types of isolation level which help us with these anomalies so the first one is read uncommitted the second is read committed the third is repeatable read and the four is serializable so let's learn about each and every one of them so let's learn about the first isolation level that is read uncommitted so it is the lowest isolation level where transaction can see uncommitted changes made by another transactions so if a transaction can see uncommitted changes made by another transaction that is read uncommitted isolation level so as you can see from the word also it says that read uncommitted so one transaction can read uncommitted changes if a transaction T1 is writing a value to a table T2 can go ahead and read that particular value before T1 commits so if there are two transaction T1 and T2 if T1 is writing some value to a particular table T2 can go ahead and read that particular value even if T1 is not committed that is why it is called as lowest isolation level so here you can see that there is a right read problem which is happening because of which it doesn't takes care of dirty reads the dirty reads is still there in this particular isolation level non-repeatable reads is also present here because again I can go ahead and read that particular value after some point in T2 and it will give me another data Phantom read is also here because as part of this transaction we are not waiting for this transaction to commit so we can go ahead and as part of T2 we can insert some datas or delete some datas from a particular table now coming to the next level that is read committer so it says read the value only when it is committed so it ensures that any data is read during the transaction is committed at the moment its rate so if there are two transaction T1 and T2 and if as part of T1 I'm writing some value to a and as part of T2 I'm reading some value of a I can only perform this read operation whenever this particular transaction is committed and the data is saved into our database so if T1 has done some right operation T2 can only read the data when T1 has committed so here you can see that after the commit I'm reading the data so there is no chances of T1 getting failed so this read write problem is taken care here so there is no dirty read which happens here now coming to non- repeatable reads non- repeatable reads can happen because consider here I'm reading a data and again in this transaction T1 I'm writing something and again I'm reading the data so here and here the data would be different so non- repeatable reads can happen now coming to Phantom reads Phantom reads can also happen because what if transaction T2 comes and insert some new record into the table so that is why Phantom read will always happen and non- repeatable read can also happen now coming to the third that is repeatable read so it ensures that if one transaction reads a row it will see the same values for that particular row during the entire transaction even if other transaction modifies the data and commit if transaction T1 reads the value transaction T2 cannot go ahead and modify the value until T1 completes so how this read and read problem was happening consider as part of T1 1 and T2 T1 I was reading some value as part of T2 I was writing some value but because of some issues T1 stopped and after some time again it started so if I read the value here and if I read the value here they were different but according to repeatable read if a transaction reads a row it will see the same value of row during the entire transaction even if other transaction modifies the data and commits so even if T2 commits the data or modifies the data T1 will always read the same data which it read during the start of the transaction so because of this dirty read is stopped non-re repeatable read will also not happen because it says that if there is any modification done as part of other transaction that should wait until transaction T1 is complete but it says that T2 can go ahead and insert some new rows so because of this Phantom read is still existing here but dirty reads and non- repeatable read is taken care now coming to the next transaction level that is serializable so it ensured that there is a Serial transaction execution so that there is a complete isolation so whenever there is a Serial transaction execution that is if there are two transaction T1 and T2 T2 should wait for T1 to complete so if transaction T1 is executing T2 must wait until T1 is complete so if transaction T2 is waiting for T1 to get completed it can't go ahead and insert any new row because T1 is still in progress it can't go ahead and read some particular value or make modification to that particular value because again T1 is in progress and it can't go ahead and read some particular value because again T1 is in progress so there won't be any dirty reads because there is no read WR anomalies or WR read anomalies because T1 needs to be completed before T2 gets started there is no non-repeatable read because again T2 has to wait for T1 to complete and then only it can perform any read operation now now coming to Phantom read that will also not happen because T2 can't go ahead and insert any new row until T1 is completed so T1 should be completed for T2 to start so there should be completion of T1 before T2 so that is why serializable has the most extent of isolation now what is a schedule so schedule refers to the sequence in which a set of concurrent or you can say multiple transactions are executed you can also say it as a sequence in which the operations such as read write commit and abot of multiple transactions are getting executed so consider if there are two transaction T1 and T2 as part of D1 we are doing some read operation as part of T2 we are doing some right operation so the time order sequence in which these operations of multiple transactions are getting executed that is what a schedu l now it is really helpful to ensure data consistency and integrity since it tell us that what is the sequence in which the operations are getting executed it is very helpful in maintaining the data consistency and integrity of database consider if there are some transaction T1 T2 till till till TN then the possible number of schedule is n factorial so if there there are two transaction the possible number of schedule is 2 factorial now here if you can see there is a schedule SC1 where we have two transaction T1 and T2 we have mentioned all the operations which are happening in these two transaction including the read as well as write operation now here you can see that we are getting a time order sequence like first T1 started its read operation then there was a context switch then T2 started its execution then again there was a context switch then T1 committed the data then again there was a Contex s and T2 committed the data so we can know the time order sequence or the sequence in which the multiple operations of different transactions are getting executed now here you can see that in the schedule we can see the commits so if commits are present in the schedule we call it as a complete schedule if commit statement is not present in the schedule that is changes are not saved into the database we call it as incomplete schedule so let's see in more depth so incomplete schedule is a schedule where not all transaction have reached their final state of either commit or abort so final state in any transaction is either commit or you can say roll back so if the transactions succeed we commit all the changes into the database if transaction does not succeed or face any network failure or system failure we roll back all the changes so whenever some of the transaction in a schedule does not reach its final State we'll call it as incomplete schedule and when they reach we call it as complete schedule so here you can see that there are two transaction T1 and T2 T1 performed some read read as well as WR operation then there was a context switch then T2 performs some read as well as WR operation then there was a commit which was done for T2 but there was no commit which was performed for T1 so we can say that this is an incomplete schedule because T1 hasn't reached to its final State and is still in progress so whenever any part of transaction which is a part of schedule which hasn't reached to its final State we call it as incomplete schedule now coming to complete schedule so a complete schedule is one where all transaction in the schedule have either committed or aborted basically have reached their final state so here if you see there are two transaction T1 and T2 T1 started its execution and reached its final state so T1 is already in its final State coming to T2 T2 started its execution and reached its final state so here both of the transaction T1 and T2 are in final state so we can call it as a complete schedule so basically if the transaction in a schedule has reached its final State we call it as complete schedule if they haven't reached it final State we call it as incomplete schedule now coming to the types of schedule so the first one is serial schedule the second one is concurrent or non- serial schedule thirdd is conflict serializable fourth is view serializable fifth is recoverable sixth is irrecoverable seventh is cascad less eighth is cascading and Ninth is stck schedule so let's learn about each and every schedule in depth so coming to the serial schedule so a Serial schedule is one where transaction are executed one after another we can say it like if there are two transaction T1 and T2 then t T1 should commit to completion before T2 starts so according to serial schedule if there are two transaction T1 and T2 so T2 should only start when all the operations of T1 are committed or either saved in database or we can also say have reached their final state so once they have reached their final state only then T2 can start else T2 can't start so if you see the schedule here there are two transaction T1 and T2 T1 started its execution read a write a and then there is a commit so T1 has reached to its final State now only T2 can start before this T2 can't start so there is a Serial execution first T will complete all its operation then T2 will start its operation and complete it then T2 started and here T2 also completed so you can say that T2 starts only after T1 is completed committed or reached its final State now here you can see that there is a Serial execution which happens like first transaction T1 will be completing then only T2 will be starting that is why it is known as serial schedule because it has serial exec ution of transactions so let's see the advantages and challenges which is faced in the serial schedule so coming to the first advantages it follows the asset properties that is transactions are isolated from each other so in the serial schedule what happens is if there are two transaction T1 and T2 T1 needs to perform all its execution only then T2 can start so we can say that these particular transactions are isolated of each other any operation of T2 can't go ahead and hamper any operation which is getting performed in T1 so there is a level of isolation which is maintained between T1 and T2 because t1s all execution are done only then T2 Starts Now the second point is it maintains consistency so consistency is obviously maintained here because T1 is committing all the changes into the database once it's succeeding so even if we start T2 and even if we perform some operation on the same data item all the data has been updated into the database so there is no data inconsistency which would happen because there won't be any r right right right right read conflicts which would be occurring so we won't be going ahead and updating any invalid data in our database T1 has committed all the changes T1 has successfully updated it in the database and then only we are performing operations of T2 so let's see the challenges first challenge is since there is a poor throughput that is number of transaction completed per unit time and the memory utilization is also poor that is why it is not suggested as it can be inefficient so consider in the serial schedule if there are two transaction T1 and T2 T2 needs to wait for T1 to get completed but consider T1 Take 5 minute to get completed so T2 can only start after 5 minutes so if you see the throughput that is number of transaction completed per unit time is very less that is why there is a poor throughput and memory utilization is also poor because if T1 is executing all its operation T2 is sitting ideal and CPU core is only able to succeed all the T1 operations not the t21 so T2 is sitting ideal and CP fers are also not getting utilized to its Max so we can say the memory utilization is also poor the second is since weight time is high less number of transaction are completed now T2 needs to wait for T1 to complete and T1 is taking 5 minutes so the wait time is very high in 5 minutes in a real life scenario there should be thousand or more than thousand transaction which should be done but here in that particular time only one transaction is getting completed so because of all these reasons it is suggested not to use the serial schedule even if it has a higher consistency but the throughput is very low the number of transaction getting completed per unit time is low memory utilization is low or you can also say the weight time is very high so because of all those things serial schedule is not suggested now coming to the second schedule that is a non- Serial or you can say concurrent schedule now from the name it's clear non- serial so there is no serial execution so a non- Serial schedule is one where multiple transaction can execute simultaneously operations of multiple transaction are alter alate or interlift so what is this alternate or interlift so here if you can see there are three transaction T1 T2 and T3 here T1 started its execution then there was a context switch T2 started its execution then again there was a context switch and then T3 started its execution so all these transaction are starting their execution simultaneously so these are interleaved or you can say alternate execution we can say it like if there are two transaction T1 and T2 T2 doesn't need to wait for T1 to commit it can start at any point so if you see from example T2 or either T3 can start their execution they don't need to wait for T1 to get completed that is what a concurrent shedu is so here T2 didn't waited for T1 to commit now here you can see that at later Point T1 is committing its changes but T2 and T3 have started their execution so the weight time is very low now coming to the advantages and challenges first is better resource utilization because at the same CPU code T1 is also starting their execution T2 is Al starting T3 is also starting so resource is getting utilized at its Max second is wait time is not involved because T2 doesn't needs to wait for T1 to get completed one transaction doesn't need to wait for running one to finish so the next is throughput is very high that is the number of transaction getting completed per unit time because T1 T2 T3 all are starting at some instant of time and they are not waiting for other one to complete so it is starting at this particular point it is starting at this time it is starting at this time so at some time touble Dash we will be able to get all these transaction getting completed so the number of transaction getting completed per unit time would be more now coming to the challenges so first is consistency issue may arise because of non-s Serial execution it requires robust concurrency control mechanism to ensure data consistency and integrity now in non- serial execution what happens if there are three transaction T1 T2 and T3 as part of T1 we are reading some data item as part of T2 2 we are writing some data item as part of D3 we are reading some data item so we have read the data item a then we have written or updated some value of data item a then again we have read the value of a but consider at some point this T2 fails so this particular transaction T3 has read the value which was there in T2 or which was updated from T2 right but this particular transaction failed so there won't be any update happen but as of now the T3 has read the value which was updated here so this particular value becomes invalid and there is data inconsistency which happens so that is why there are some concurrency control mechanism which make sure that these particular things doesn't happen and serializability concept is also there for this so we can use serializability and concurrency control mechanism to ensure consistency so that none of the invalid data is updated or there is no inconsistent data which is present in our database so coming to the third schedule that is conflict serializable schedule so a schedule is conflict serializable if it can can be transformed into a Serial schedule by swapping adjacent non-conflicting operation now what are these conflicting and non-conflicting operation so consider if there are two transaction T1 and T2 we can perform some operations on them consider there is a read operation on T1 read operation on T2 read operation on T1 write operation on T2 write operation on T1 read on T2 and write in T1 and write in T2 so here if you see if we perform read operation and T1 and T2 both so they are reading the same data item although but they are reading the same value right they are not updating anything they are reading the same value so there is no issues here but coming to here if any transaction we are reading some value and at part of next transaction we are updating that particular value so there will be a read write conflict coming to this so if at part of one transaction we are writing some value or updating some value and as part of another transaction we are reading that particular value so there will be a conflict coming to the same right right if we are writing some value part of one transaction and then again writing some value of part of another transaction so there will be a conflict because there could be a possibility that we are reading some value and here we are updating some value but at some particular point this particular transaction fails so if we are reading the value again we will be reading inconsistent value so these all operation can cause inconsistency you can see that whenever there is a right operation involved it can cause inconsistency so we call these pairs as conflicting pairs because of these there could be some conflicts which can arise there could be inconsistency in data which can arise and this pair is non-conflicting because even if we are performing read operations as part of multiple transaction there is no issues so here you can see the conflict pair is read WR WR read right right when performed on the same data item but there could be a possibility that as part of T1 I am reading the value of a but as part of T2 I am writing the value of B so here the data items are different so these are also a non-conflicting operation so if we go to to the non-conflicting pair read read when performed on the same data item read read when performed on the different data item WR right when performed on the different data item since we are performing on different data item so there would be no consistency issue because we are not going ahead and updating the value of B we are going ahead and updating the value of a and we are reading the value of B so there won't be any issues so let's come back to the conflict serializable shedule so as part of conflict serializable schedule what we do is we take the concurrent schedule which change its execution from nons serial to serial so that the consistency issue which was coming in non- serial execution or you can say in the concurrent schedule is encountered or taken care so what we do here is we find a conflict equivalent how we can find a conflict equivalent by swapping the adjacent non-conflict Pairs and in that conflict equivalent we see that if by swapping we are able to achieve a schedule where there is no conflicts so coming to this schedule if we see the non-conflicting adjacent pair so T1 has read of a T2 has read of a so this is a non-conflicting pair because we are performing only read operation on the same data item coming to T2 and T1 again read of a write of a this is conflicting coming to here WR of a right of a again conflicting and then right of B so here we can see that there is only one non-conflicting pair so what we have to do is we have to swap these non-conflicting pairs and then we can get the conflict equivalent and then we can see that if that conflict equivalent has any conflicts or not for now we won't be looking much more depth into this particular schedule because we have a dedicated lecture on conflict serializable schedule so here you can see that ra of T1 and ra of T2 is non-conflicting RA of T1 and W of T2 is conflicting having read write conflict and W of T1 and wa of T2 is conflicting because they have right right conflict so the fourth schedule is view serializable schedule now it is also part of serializability so serializability is a method which is used so that we can encounter the inconsistency issue which was coming in the concurrent schedule as part of serializability we do a conflict serializability and a view serializability so we would be learning about all these in next set of lectures so view serializability ensures that the database State seen by the transaction in a concurrent schedule can be replicated by some serial execution of those transaction so in view serializable schedule or you can say view serializability we are making sure that if there is a concurrent schedule they have a Serial execution so that the consistency issue is encountered now whenever we find a cycle in our conflict graph we don't know if our schedule is serializable or not so we use the view serializability here so serializability is used to encounter the inconsistency issue which was coming in our concurrent schedule now as part of serializability there is conflict and view serializability in Conflict serializability we draw a conflict graph now if this particular graph has any cycle we go to the view serializability to check if this schedule is a serializable schedule or not if there is no cycle we can say that this is a serializable schedule if there is a cycle we go to the view serializability and check for some conditions for a view equivalent if all these conditions are met we say that this particular schedule is a serializable schedule if not we say that this particular schedule is not serializable now all these things may be sounding confusing to you but don't worry we would be talking about each and everything in depth in next set of lectures for now you can only think that view serializable schedule is a edle which is view serializable so uh a schedule is view serializable if its view equivalent is equal to a Serial schedule execution so whenever a schedule is view serializable its view equivalent is equal to a Serial schedule or serial execution so whenever there is a Serial execution of a view equivalent which we have found out for a schedule we call it as a view serializable schedule so coming to the next schedule that is recoverable schedule so a recoverable schedule ensures that if transaction reads data from another the transaction it should not commit until the transaction from which it read has committed so consider if there are two transaction T1 and T2 and T2 is reading some data which is updated by T1 so T2 shouldn't commit until the time T1 commits so T2 should always wait for T1 to commit only then T2 should commit if it commits before and what if at some point this transaction fails this particular operation will read some invalid data because as T1 failed there was a roll back and this particular operation is nullified now so this data is invalid so we have to wait for the transaction from which we are reading the data to be committed so that we commit the correct or you can say the consistent data so this helps in maintaining the Integrity of database in case a transaction fail so if at any point T1 fails we will be able to recover T2 because T2 hasn't committed all the changes into the database it's present only in the transaction logs now coming to the sixth status irrecoverable schedule and IR recoverable schedule allows a transaction to commit even if it has read a data from another uncommitted transaction so if the transaction is uncommitted it allows another transaction to commit the data this can lead to inconsistency and make it impossible to recover from certain failures so what if transaction T1 fails at some point and we have committed the data based on what we have read from the updated value of T1 which is not updated into the database because the transaction has failed so this will have a invalid data and that particular invalid data would be committed or changed into the database so it will cause inconsistency in the database because we are updating some invalid value or the value which is not consistent into our database so the next schedule is cascading schedule this schedule happens when the failure or abot of one of the transaction causes a series of other transaction to also abot so consider if there are three transaction T1 T2 and T3 T1 has started its execution T2 also started and T3 also started at some point T1 failed so here you can can see that there was a right of a which was present in T1 and T2 read the same data which was updated as part of T1 but T1 failed so this also needs to abort and this also needs to abort because we won't be updating any inconsistent value or we won't be reading any inconsistent value which is not updated in our database so there are multiple aborts which are happening so here you can see T1 writes to a so T1 writes a data item to a T2 reads it so T2 reads the uncommitted value of a which is return return by T1 now if T1 fails and aborts T2 must also abort because it has read an uncommitted value which is from T1 and this particular value is also read by T3 so T3 also must abot now there are some issues first is the performance degradation because multiple transaction needs to be roll back so there were some transaction which started but because of one transaction failure there are multiple roll backs which is happening so there is a performance issue second improper CPU resource utilization because we use the CPU resources to perform these three transaction but because of the failure of one transaction all the transactions have to fail because they have read some uncommitted changes of that particular transaction now coming to the next schedule that is cascad schedule so it ensure transaction only read committed data such that the abot of one transaction does not lead to the abot of other transaction that have already read its uncommitted changes so it makes sure that if any transaction is reading any value it should always read a committed value it shouldn't read a value which is not committed when a transaction has already committed all its changes to the database and if we are reading the committed changes there is no issues which will occur here because these are all the changes which are saved into our database and there is no chance of failure which occurs after commit because this is the final state so this particular read operation won't have any inconsistent data so T1 writes to a T1 has written some value to a and T2 reads from a so T2 reads the committed value of a because it has been saved into the database in uring that there is no right read problem which is happening so in the cascading schedule there was a right read problem which was happening but here it is not happening and T2 does not read any uncommitted data because this data is committed so there is no cascading orts in this particular schedule but here it says that one should only read committed data but what about the right operation so they haven't told anything about the right operation they have only told about the read operation that one should always read the committed data but what if there is a right right problem which can come right so there are some issues first is the right right problem is encountered because it has only told that it can read committed data but not anything related to right operation second is performance overhead is there because again this needs to be committed so this particular transaction can only read after it is committed so it needs to wait for this to get committed coming to the last schedule that is strict schedule so it ensures that transaction is not allowed to read as well as write a data item that another transaction has written until the first transaction has either th committed or aborted so it makes sure that there is no read or write operation performed until that particular transaction from where we are reading or writing the data has been committed or aborted basically has reached its final state so it prevents the cascading aborts so what will happen in T1 and T2 so T1 needs to complete all its operation only then there could be any read as well as write operation which would be performed so the right right issue which was coming there or right right conflict which was coming there is resolved now because it can only write a data or it can only read a data once the transaction is committed so T2 cannot read or write the value of a until T1 has committed this ensures that T2 only sees the committed value of a so this is how strict schedule prevents the cascading Awards and make the consistency at its peak so I was getting so many queries on concurrent and parallel schedule people were thinking that concurrent and parallel schedule are the same but there are some differences between concurrent and parallel schedule so let's learn about them so first let's go through the the definition so concurrent scheduling manages multiple task at the same time task can llap in their execution period but do not run exactly simultaneously consider if there are three transaction T1 T2 and T3 now T1 can start at any instant T T2 can start at any instant T Dash and T3 can start at any instant touble Dash so here you can see that all of these transaction their execution May overlap or you can say at the same time not all these three transactions are starting but coming to parallel schedule parallel scheduling run multiple tasks simultaneously using multiple course or processor so in parallel schedule there are multiple course or you can say processor which helps the transaction to run parall at the same instant of time so all these three starts at instant of time T so each task is executed on a separate core or processor at the same time so all the three task are executed at the same time while in concurrent schedule they can start at any St of time now coming to the execution so it is achieved on a single core processor through context switching where the CPU rapidly alternates between the task creating the illusion of simultaneous execution so what happens when T1 starts and when T2 starts at any instant T Das there is a contact switching which happens between T1 and T2 then again for T2 and T3 there is a contact switching which happens which makes it as alternate or you can say concurrent execution but coming to parallel it requires a multicore processor or multiple processor which each core handling a different task concurrently so all these three cores will be handling different task but they would be handling it concurrently so all these three cores will run at the same time they are running on the different cores all the transaction and each core will handle different set of task now coming to example so consider an example where multi-threading on a single CPU core where thread takes turns in the CPU now there are three threads T1 T2 and T3 three what will happen they will not run on different processor or course they will only use this single CPU core so first T1 will go and start its execution then there will be a context switch then T2 will go and start its execution then there will be a context switch then T3 will go and start its execution so again there is a context switch which is happening between the threats or you can say between the transaction because they are utilizing the same CPU core but coming to the parallel multi- threading on a multi-core CPU where threads can run concurrently on different courses so consider if there are three cores and there are three threads these three threads can run concurrently on different cores so T1 can run on this particular C1 can run on C2 core and T3 can run on C3 core so they don't need to wait for their turns they have the CPU core and they can go ahead and execute their threat there only so this is the basic difference between concurrent and parallel schedule so if someone ask you if concurrent and parallel schedule are the same it's not the same there are some differences between the concurrent as well as parallel shedule now if you remember in the schedule lecture we learned about serial as well as concurrent schedule now what are these so in serial shedule all the transaction have a Serial execution in concurrent schedule all the transaction have interleaved or you can say alternate execution now there were some advantages as well as disadvantages for serial as well as concurrent schedule now coming to serial schedule the advantage was it follows the asset properties so the consistency was maintained here the disadv advantages was there was very low throughput like the number of transaction completing per unit time were very low the weight time was very high and coming to resource utilization that was also very low now in concurrent schedule the advantages was the throughput was very high like number of transaction completing per unit time the weight time was very low the resource utilization was very high but the consistency was low or the consistency wasn't maintained so because of multiple advantages we use concurrent schedule everywhere but there was one disadvantage that was consistency so it was not folling the asset properties because of this consistency we introduced serializability and some concurrency control mechanism which makes sure that even if the schedule is concurrent it follows a Serial execution so serializability ensures that the concurrent transaction yield results that are consistent with some serial execution that is the final state of the database after executing a set of transaction concurrently should be the same if the transaction had been executed one after another in some order so serializability makes sure that if there is any concurrent schedule and if we are serializing that particular schedule so s Dash would be having a Serial execution so even if s Dash is formed from a concurrent schedule we make sure that s stash follows a Serial execution so that the consistency is maintained now in case of concurrent schedule consistency issue may arise because of non- Serial execution because of which we use the serializability concept now coming to ser seral schedule we don't need to use serializability because the execution is already serial now in serializability there are two types of serializability first is conflict serializability and second is view serializability so how do we know that this particular concurrent schedule is serializable or not so first we need to check for conflict serializability followed by view so in Conflict serializability we check that if there is any cycle which is detected in a conflict graph if a cycle is detected we go to the view serializability and we check that if the view equivalent follows some condition if it is followed we say it is serializable if it is not followed we say it's not serializable if the cycle is detected we go to the view serializability if the cycle is not detected we say that this particular schedule is serializable so we first need to check for conflict serializability if no cycle is formed we can say that that particular schedule is a serializable schedule or that particular schedule is a conflict serializable schedule if the cycle is deducted we need to check for View serializability and if in the view serializability also some conflicts arises or if the condition is not meet we can say that that particular schedule can never be serializable or can never have a Serial execution now how do we form the conflict graph so conflict graph is basically formed on the basis of nodes as well as edges so how we form the graph the conflict graph the nodes is represented as the transactions in the schedule and edges is represented as conflicts in the schedule and we need to detect if the graph has a cycle or not now in a Serial schedule we don't need to form the conflict graph because there are no conflicts if you see here all the execution of transaction one is getting completed only then transaction two is starting so there will be no edges because edges represent the conflicts but here if you see there are no conflicts so we can say that there won't be any conflict craft for a Serial schedule now coming to the concurrent schedule so here there are two transaction T1 and T2 so we need to represent it using the node so it is T1 and T2 now coming to the execution so here if you see it starts with T1 then there is a context switch then there are some execution in T2 then again there is a context switch and then again there is execution in T1 so if we need to draw the conflict graph for this we can see that there are two edges and there is a cycle which is detected in this particular graph so T1 goes to T2 and then again T2 goes to T1 so there is a loop or you can say cycle which is detected in this particular graph so concurent schedule does not always have a cycle so it's not always possible that a concurrent schedule will be having a cycle it can have a cycle it can't have a cycle if it has got a cycle we need to see for the view serializability if it doesn't have a cycle we can say that it is conflict serializable because of which it is serializable so a concurrent schedule can be conflict serializable meaning that it is equivalent to some serial schedule of transaction and its conflict draft does not have any Cycles so if there are no Cycles we can say it is conflict serializable that is it is serializable if there is any graph we need to check for the view serializability now since a cycle is detected we need to serialize them so we use the serializability here first we use the conflict serializability to detect the cycle using the conflict graph and then we use the view serializability to check if the schedule is serializable after a cycle has been detected so in this way we use the serializability concept now why do we need to serialize them so to avoid the consistency issue which may arise because of non- Serial execution so in the non- serial execution we can have some consistency issue and we don't want our transaction to be inconsistent because of which we use the serializability concept apart from serializability we also use some concurrency control mechanism of which we will be talking in the next set of lectures so coming to the types of serializability there are two types of serializability conflict and view in Conflict serializability we check that if the conflict graph has any cycle or not in view serializability we check that if a view equivalent is following some conditions or not we'll be learning about all these as well in the next set of lectures so before starting let's just re- revise the molder concept so what was serializability serializability is a property of a schedule where the outcome is equivalent to some serial execution of transaction so why do we need serializability so in concent schedule There Was a non-s Serial execution of transaction because of which there was some consistency issues which were coming into our database so to encounter this consistency issue we had serializability as well as some concurrency control mechanism now as part of serializability we make sure that if there is a schedule which has concurrent executions or you can say interleaved execution we'll try to have a Serial execution of that particular schedule so that we can use the concurrent schedule and can also encounter the consistency issues now what is conflict serializability a schedule is set to be conflict serializable when one of its conflict equivalent is serializable so basically if a schedule can be transformed into a Serial schedule by swapping non-conflicting operations then the schedule is conflict serializable so when do we say a schedule is conflict serializable so ideally there are two methods which we can use first is what we can do is we can swap the non-conflicting operations that is the adjacent operations and we can find a conflict equivalent schedule now for this conflict equivalent schedule if there are no conflicting operations present after swapping all the non-conflicting operations we can say it is conflict serializable second is using the Precedence or you can say the conflict graph so in the conflict graph we see that if the conflict graph has any cycle or not if it has cycle we can say it is not conflict serializable if it doesn't have cycle we can say it is conflict serializable so let's learn about first the conflict equivalent and then we will go to the Precedence graph so conflict equivalent if a schedule S1 is formed after swapping adjacent non-conflicting operations or pair in a given schedule s then S1 and S conflict equivalent so if there are two schedule s and S1 and S1 is formed after swapping the non-conflicting operation of s then we can say that these particular schedules are conflict serializable now what are the conflict and non-conflict pairs so conflict pair are read right WR read WR right when performed on the same data item what are non-conflict pair so they are read read when performed on the same data item read read when performed on the different data item write WR when performed on the different data item so let's see so why these are non-conflict pair consider if I'm reading a data item a and then as part of another transaction I'm reading the data Item B so there is no conflict right because we are only reading the value we are not reading any modified value or we are not updating any value we are only reading the value so it will not cause any consistency issue because of which it is called as non-conflicting coming to here so we are again reading the same data item but again it won't cause any conflict or consistency issue coming to here so we are writing data item a and we are writing a data Item B so we are writing into different data items as part of transaction T1 and T2 so these are also non-conflicting because if I'm writing to data item and again I'm reading to that particular data item only this could be conflicting but these are not conflicting now coming to this one where in transaction T1 we are reading the data and in transaction T2 we are writing the data but the data items are different here we are reading from a and here we are writing in B so again if the data item are different there is no conflict if the data item is same if only there is a right operation involved there would be a conflict else there would be no conflict now coming to the conflict pair we are reading a data item a and then we are writing some value to that particular data item a so there is a read write conflict again we are writing to data item and then we are reading it consider after some time this particular transaction fails so we are reading some invalid data because if it fails it will abort and roll back and it will come back to its original value but here we have read the updated value value so it will have a invalid value that is why it is a conflict pair now coming to right right where we are writing on the data item again we are writing on the data item as part of transaction T2 these all pairs are the conflict paays where we are performing any right operation in any of the transaction on the same data item these are the non-conflict pair because if we are performing these operation there is no inconsistency issue which is encountered in our database so how to achieve a conflict equivalent schedule so when a schedule can be transformed into a Serial schedule by swap adjacent non-conflicting operations conflict arises when two transaction assess the same data item and at least one of them is a right operation so whenever one of them is a right operation and if there is any operation which is getting performed on the same data WR operation read operation then we can say that there is a conflict which is arising now why we are only swapping the non-conflict pairs and not the conflict ones so if we swap the conflict pairs the order of execution if it was read of a write of a the result of values may change as first we were reading a and then writing or modifying a but now it will be writing into a and then reading the modified value so consider this was before uh changing the conflicting operation and this is after changing the conflicting operation so it would be T1 of w and T2 of RA so here if the value of a was 10 it reads the value of a so it would be 10 it start the value of a that would be considered a + 10 so it is 20 now here it is writing the value of a so a would be a + 10 so that is 20 and now it is reading the value of it that is 20 so if you see that here the value of a while reading was 10 but here the value of a while reading is 20 so if we switch the conflicting pairs there could be a chances of data inconsistency because the result which we were getting earlier and the result which we are getting after is different so uh the modified value result might change if we change the order of execution so let's solve a question where we have to find the conflict equivalent for a given schedule S1 so this is the schedule what we have to do is we have to find the non-conflicting pairs and we have to swap it then we have to see that again if there are any non-conflicting Pairs and then again we have to swap it until the time we don't get any non-conflicting pairs so let's see so here the read is happening on X here the right is happening on X and read is happening on X so there is the same data item so there is a right read conflict coming to here so there is a read in X and there there is a readen y so these is non-conflicting operations so we will just mark it like this that these both are non-conflicting operation coming to here so there is read in y and then there is WR in y coming to Here There is a right in y and then there is a read in y so there is a read right conflict so first is find the adjacent non-conflicting Pairs and do a swap so we have found the adjacent non-conflicting pairs so we have to swap them so RX will come here and r y will come here so after the swapping we have got RX w x r y then RX has come here then W Y and R Y now again we need to see that if there are any non-conflicting pairs so this is RX then there is WX then there is r y and then there is rx so this is again a non-conflicting pair now coming RX Wy so this is also a non-conflicting pair and coming here so there is r y so for this pair we have already swapped but here we haven't swapped so we have to swap RX here and Wy here since we are reading the X and we are writing on y so the data item are different that is why it is a non-conflicting operation so after swapping this the schedule we get is rx WX r y and this is being swapped to here and this is being swapped to here so it will be Wy then here it will be RX and r y now let's see the schedule again so it's RX WX r y Wy RX r y so here you can see that right is happening on the Y data item and read is happening on the X data item so there are no more conflicts which is left in this particular sh schedule but what if there is a schedule and I found the view equivalent of that particular schedule but there are still some conflicting pairs which is present in that schedule so that particular schedule can't be a conflict equivalent schedule for a given schedule S1 and we can also say that it's not conflict serializable now this particular method we don't use very often because if the schedule is very large then there would be a lot of complexities that is why we use the Precedence graph method or the conflict draft method now how to check whether a schedule is conflict serializable or not so conflict occurs when two operations from different transaction assess the same data item and at least one of them is a right operation so we use the conflict graph and precedence graph here so conflict graph or a precedence graph is a directed graph which is used to determine the conflict serializability the notes represent the transaction the edges represent the conflicts between the transaction so we will be drawing a conflict graph where the nodes will be representing the transaction there will be a directed graph and the edges would be representing the conflicts between those transaction so let's see how we can draw the conflict graph so conflict graph has node edges and cycle now node each transaction in the schedule is represented as node in graph so if there are two transaction T1 and T2 we represent T1 and T2 as the node in the graph now coming to edges an edge from transaction TX to Ty denoted TX Ty is added if an operation of TX conflicts with any operation of Ty so if in TX or you can say T1 if there there is any operation consider read of a which conflicts with some operation which is present in T2 then we represent the edges or we can say V represent the conflicts so TX operation precedes Ty operation in the schedule so TX operation will always precede the tyy operation in the schedule now coming to the cycle detection so schedule is conflict serializable if and only if the conflict graph is a Cy that is there is no cycle in the graph if there are no Cycles in the graph it means that the schedule can be serialized without violating the order of conflicting operations so if there are no Cycles in the graph we can say that that particular schedule is conflict serializable that means that that particular schedule is serializable but if there is any cycle we have to go to the view serializability which is another type of serializability so let's see that how using the conflict graph or precedence graph we can tell that if a particular schedule is conflict serializable or not so check if the given schedule is conflict serializable or not so there are three transaction T1 T2 and T3 and there are some operations which is getting performed on data item a as well as data Item B so there are two data items and there are three transactions so let's see so the step one is we have to find the conflicts in the schedule how we can find the conflict is first if we are seeing for any transaction T1 we have to look in T2 and T3 for any conflicts if we are checking in T2 we have to look for T1 and T3 for any conflicts and if we are looking for T3 we have to check for T2 and T1 now what are the conflicts so there could be a read write conflict performed on the same data item there could be be a right right conflict performed on the same data item there could be a right read conflict performed on the same data item so if we are checking for any right operation in a given transaction we have to check for write as well as read and if we checking for any read operation we have to only check for WR operation so let's see so the first operation is read of a so we have to check that if in T2 or T3 there is any right of a so let's see in T3 there is so there will be a read write conflict where there would be a conflict between T1 and T3 on a now coming to the next operation that is read on a so let's see if there is any right of a yeah it is present in T1 so there will be a read write conflict of T2 T1 on a and let's see in T3 yes there is present so there will be a read write conflict on T2 and T3 on a now let's come to this data item that is right of a so let's see is there any read of a as well as right of a so is there any read of a present no is there any right of a present yes it's present so we can say that there will be a uh ww conflict between T1 and and T3 we are not checking for the older operations because them we have already discarded or we have already find out the conflicts so we are only looking for the operation for which we haven't found out any conflicts so there will be a right right conflict which would be present between T1 and T3 on data item a now coming to this one right of a is there any read of a or right of a present no it's not present now coming here right of B is there any read of b or right of B present yes it's present so it would be T2 to T3 right read conflict on B now coming here read of B there won't be any conflicts so these are all the conflicts which we have found out in the schedule now the step two is we have to find the notes so the notes are all the transaction T1 T2 and T3 so we have found out the notes step three is we have to find the edges and the conflicts so conflicts we have already figured out now we have to find the edges so there is a read write conflict which is happening on T1 and T3 on the data item a so on T1 we are performing a read of a and on T3 we are performing a right of a so here the value of a is getting updated but there is a read which is getting performed before even updating the value so there will be an hge from T1 to T3 because T1 reads A before T3 writes a now there would be an hge from T2 to T3 because of read right conflict there will be an hedge from T1 to T3 because of right right conflict T2 to T3 because of readr conflict and T2 to T1 because of read write conflict so here you can see that some of the ages are getting repeated T2 T3 T2 T3 so we don't need to write for the repeated edges so we can just discard one and we can only use one of the H and here also there is T1 T3 which is getting repeated twice so we can only use one H because we have already identified that there is a conflict so there will be only three edges T1 to T3 T2 to T3 and T2 to T1 now we have to draw the graph so first we'll draw all the notes so that is T1 T2 and T3 now we have to form the edges so there is an edge from T2 to T1 so this is the H there is an H from T1 to T3 so this is the H and there is an hge from T2 to T3 this this is The Edge so these are all the edges but can you see that if there is any cycle formed or not so there is no cycle formed so since the graph has no Cycles we can say that this particular graph is conflict serializable so in the step five we say the same if the graph is cycle it is not conflict serializable or serializable if not let's find the serial execution of transaction so since it has no cycle it is conflict serializable means it is serializable so if a graph is serializable or if we can say a schedule is serializable then we can find the serial execution that how the serial execution will happen or which particular transaction will start first and followed by others so let's see so let's find the serial execution of transaction so we have to find the possible combination first so there are three transaction I told that the number of possible schedule when there are three transaction is three factorial or whenever there is n transaction that is n factorial so 3 factorial is 3 into two that is six so these are all the possible combination where first T1 comes and then T2 T3 then T2 comes then T1 T3 then T3 comes then T2 T1 so these are all the possible six combination so what we have to do is we have drawn the graph now we have to find the IND degree of the graph so what is the IND degree ingree is the number of edges that is directed to that particular node so we have to see that this is the node and how many edges are directed to this particular node so if we see here the ingree for T3 is 2 the ingree there is no Direction so there is zero and the ingree for T1 is 1 because there is one directed HED here there is two directed hedge and here there is no directed HED so we have found out for T1 it's one for T2 it's 0 and for T3 is 2 so once we find the IND degree we have to find that particular node where the IND degree is zero so that would be the first one in the serial execution so in T2 the IND degree is zero that is the less conflicts are there in T2 so we would be having T2 as the first in the serial execution now we will remove T2 from this particular graph now here it is T1 and T 3 so now the ingree for T3 is 1 and for T1 is zero so now it will be followed by T1 and then it will be followed by T3 so this is how we find the serial execution of a conflict serializable graph so what we have to do is first we have to draw the conflict graph then in the conflict graph we have to check if there is a cycle or not if there is a cycle we can say that that is not conflict serializable and if there are no Cycles we have to find the IND degree for all the nodes which are present in the graph once we find the ingree we have to check that which particular node is having zero as the ingree so that would be the first one in the serial execution then we have to discard that particular note from the graph and then again we have to check the IND degree of all the other transaction and we have to follow the serial execution in that manner so the one possible equivalent serial schedule is T2 followed by T1 followed by T3 so all the executions would be happening first for T2 then T1 and then T3 so let's see if it is helping us to make a Serial schedule without any conflicts so there is T1 T2 and T3 3 so first T2 operations would be executed so that is read of a right of B so it would be read of a right of B then coming to T1 so it would be read of a right of a and then coming to T3 so that would be right of a and read of B so here we can see the adjacent conflicts which were present earlier are now gone so this is a conflict equivalent of this particular schedule which is present here now what was the need of this VC realizability so in concurrent schedule There Was a non-s Serial execution of all the transaction now since there was a non- Serial execution of transactions there was some consistency issue which was lacking in this particular schedule so just to encounter this consistency issue we introduced this serializability concept now in this serializability it makes sure that this non-serial execution get converted into a Serial execution so we find a equivalent schedule in which there is a Serial execution now there were two types of serializability first was conflict serializability and second was view serializability now in Conflict serializability we draw a conflict graph or you can say precedence graph in which we see that if the graph has any cycle or not if the graph doesn't have any cycle we can say that that particular graph or that particular schedule is a conflict serializable schedule which means that that particular schedule is serializable now coming to view equivalent schedule so whenever in this conflict craft there is a cycle so we don't know that if that particular schedule is serializable or not so because of that reason we go to view serializable schedule now in this view serializable schedule we find a view equivalent and in this view equivalent we check for certain condition and if this conditions are met we say that this particular schedule is view serializable that is why the schedule is serializable but if this conditions are not made then we say that view serializability is not there because of which the schedule is not serializable so serializability help us to tell that if a given schedule is serializable or not or can have a Serial execution or not so View serializability ensures that a database State seen by transaction in a concurrent schedule can be replaced by some serial execution of those transaction now whenever we find cycle in Conflict graph we don't know if our schedule is serializable or not so we use the view serializability here so whenever we find the cycle in the conflict equivalent graph we go to the view serializability to check if the schedule is serializable or not now a schedule is view serializable if its view equivalent is equal to serial schedule or execution so when ever The View equivalent of a given schedule is equal to having a Serial execution we say that this particular schedule is serializable now let's see the condition for a view equivalent schedule so for a schedule to be view equivalent it should follow the following condition now the very first condition is initial read values so if there are two schedule s and s- and s- is a view equivalent of this particular schedule s then an initial read of both schedules must be identical so for example consider if there are two schedules s and s-h if in a schedule s transaction T1 does the initial read for the data item a then in schedule s does transaction T1 should be only doing the initial read on the data item a so if in schedule s T1 is the first transaction which is reading the value of a in schedule s-h T1 should always be the first transaction which is reading the value of a that is if read of operation is being performed on any data item here it should be performed on the same in The View equivalent schedule now coming to the second that is updated read so in a schedule s if TI is reading B which is updated by TJ then in s Dash also TI should be reading B which is updated by TJ so consider here there is a read operation which is happening on a given data item which is updated by another transaction so consider here read of B is happening and here T2 is updating the value of B so T2 is updating the value of B and then the read of B is happening in T3 so the same should be happening in the other schedule or you can say the view equivalent schedule here if you see T2 is writing the value of B and here then T3 is reading the value of B so whenever there is a rewrite operation happening they should be same in both the schedules so that there is no consistency issue which is arised so if there is any update which is happening on any data item and after that there is a read getting performed so the execution of transaction in which they are getting performed should be same in both the schedule S and S Das where s Dash is a view equivalent of s now coming to the third that is final update so a final right must be identical in both the schedules if in schedule s transaction TI is the last to update a then in schedule s- the final right operation on a should be performed by TI it's kind of similar to the initial read condition in initial read we say that if transaction T1 does the initial read of a then in s d also transaction T1 should be doing the initial read of a that is if there is a schedule s and if there is a view equivalent schedule s-h there should be same initial read which is done by same transaction now here also it says that if there is a final right which is getting performed in any of the transaction T1 T2 and T3 on a data item X so the same transaction should be performing that in the view equivalent schedule so consider if the final right here is happening on data item a which is getting performed on T3 so here also the final right should happen on the data item a and it should be performed by T3 so this should be identical so there are these three condition which should be followed first is initial read second is updated read and third is final right so when these three condition are met we can say that this particular schedule or S Dash is a view equivalent of s so here is a question where we have to find the view equivalent of a given schedule so this is a schedule s and we have to find the view equivalent of this particular schedule one is we have to find if it is conflict serializable or not so we have to find if this given schedule s is conflict serializable or not so we will be drawing the conflict graph and in this conflict graph first we will be drawing the notes so the notes are all the transaction which is present so it would be T1 T2 and T3 then we would be drawing the edges so edges represent the conflicts so let's find the conflict so conflict is always read write write read and write WR when performed on the same data item and here you can see that there is are the same data item on a it is getting performed so let's see if there are any read WR WR right or WR read conflicts so let's see so first is read of a is there any right of a present in any of the transaction yes it's present in T2 and T3 so we'll just discard this and we'll just draw a line from T2 and then from T3 so let's go to the second that is right of a is there any read of a or right of a present in any of the transaction yes it's present in T1 and T3 draw an H from T1 to T2 and then T1 to T3 now coming to T2 so there is a w of a that is right of a is there any read of a or write of a getting performed yes it is getting performed in T1 and T3 so from T2 there would be a line to T1 and then from T2 there would be a h to T3 now coming to T1 right of a so is there any read of a or right of a getting performed yes there is a right of a so T1 to T3 there would be an H but it is already drawn so we won't be drawing it again now coming to T3 there is a right of a but is there any conflicting operation no all these values are already discarded so there are no conflicting operation so here you can see that from T1 to T2 and then T2 to T1 there is a loop which is being formed or you can say cycle is being formed so we can say that this particular schedule is not conflict serializable now we will be checking for view serializability so the step two is find the possible number of Serial schedules so how we can find it that is n factorial so here the transaction are 1 2 and three so it would be 3 factorial so what could be the possible combination so T1 goes to T2 goes to T3 it can be one of the possible serial execution then T1 goes to T3 goes to T2 then T2 goes to T3 goes to T1 then T2 goes to T1 goes to T3 and then T3 goes to T2 goes to T1 and then T3 goes to T1 goes to T2 so 3 factorial is equal to 6 so here there are six possible serial execution let's pick up this particular serial execution and then we would be seeing that if the view equivalent schedule which is formed with this serial execution that is T1 goes to T2 goes to T3 is equivalent to this particular schedule s so this would be S D so there would be T1 there would be T2 and there would be T3 now we want a Serial execution so first all the operations of the T1 would be completed that is read of a and then right of a now coming to T2 there is only a right of a now coming to T3 there is a right of a so let's go to all the condition which we told that if there are two schedule S and S Das they needs to follow this condition for them to be view equivalent so first one was initial read so let's see what is the initial read which is happening in this particular transaction s so here the initial read of a is happening on T1 so T1 is having the initial read in s now coming to s- T1 is again having the initial read on a so we can see that the initial read is same in S and S Dash coming to update read so let's see that wherever the value of a is getting updated who is reading the value of a next so here you can see that the value of a is getting updated here also here also but there are no reads which is present after that and here also the value of a is getting updated in transac section T1 then T2 then T3 but there is no read of a happening since there is no read performed after the update no need to check for the update read now coming to the third condition that is final update so let's see that what is the final transaction where the value of a is getting updated so here if you see T3 is the final transaction where the value of a is getting updated now coming to this particular s Dash T3 is again the final transaction where a value is getting updated so we can say that the final update is happening on T3 both the schedule s and s-h so we can say that since the initial read is same the final update is same and update read is not valid here because there is no read happening after the update we can see that s and s- both are view equivalent so if the view equivalent schedule matches the condition it is view serializable so we can say that this particular schedule s is view serializable because it view equivalent follows all the condition which is needed for a view equivalent schedule so this is View serializable and then we can say since it is view serializable this particular schedule is serializable able as well as it can follow a Serial execution of transaction so this is how we find the view equivalent of a given schedule so before starting with concurrency control mechanism let's learn about concurrency control so what is concurrency control it is a process of managing multiple user access and modification in data simultaneously in shared or multi-user database system now consider an example of IRCTC now in this IRCTC at a given time there are multiple users who are going ahead and booking ticket from themselves now here since there are multiple users who are going ahead and booking ticket from themselves we can call it a multi-user system now here this IRCTC database would be getting updated or Modified by multiple users so we can say that this particular database is a multiuser database or a shared database so for managing this multiple users and multi-user database IRCTC uses this concurrency control so it uses the concurrency control so that it can manage multiple user access and modification in data simultaneously in a multi-user database system now how it helps so the first one is data consistency so it ensures that the data remains accurate and reliable despite concurrent access so concurrency control makes sure data is consistent even if there are multiple user who are accessing the website or the database at the same time now coming to the second thing that is isolation so it maintains the isolation property of transaction so that the outcome of a transaction is not affected by other concurrently executing transaction now since there are multiple users who are doing transaction at the same time so consider user one is doing transaction T1 user two is doing transaction T2 and user 3 is doing transaction T3 now as part of this transaction we are doing some operations of read and write as part of this transaction also we are doing some read write operation as part of this transaction also we are doing some redried operation so there should be isolation which should be maintained between different transaction so that if there is any modification of data which is being made here this particular transaction doesn't affects from this particular read and right operations which is happening in transaction T1 so there should be isolation between these three transaction so that the operation of one transaction doesn't affect the operation of other transaction until or unless this particular transaction is committed now coming to the third pointer that is serializability so it ensures that the result of concurrent transaction is same as if the transaction has been executed serially so in the concurrent schedule or you can say in the concurrent transaction there is a non- Serial execution of transactions so because of this non- serial execution there is consistency issues which arises in our database so serializability makes sure that this particular non-s serial execution is converted into a Serial execution so that consistency issue is encountered so that our database follows the AET properties now coming to concurrency control mechanism so we had serializability using which we were telling that if a given schedule is serializable or not and there were view serializability conflict serializability which were helping us for the same then what was the need of this concurrency control mechanism so as as part of serializability we are only telling that if a given schedule is serializable or not but as part of concurrency control mechanism we use some techniques to make that particular schedule as a serializable schedule so here we are using techniques to make a schedule as serializable here we were only using techniques to tell if a given schedule is serializable or not so concurrency control mechanism are techniques used in database management system to ensure that the transactions are executed concurrently without leading to any inconsistency in the database so whenever there is a concurrent execution or you can say non- serial execution there are some consistency issues which arises in our databases so concurrency control mechanism make sure that this particular inconsistency is not happening in our databases now in serializability we check if a given schedule is serializable or not but in concurrency control we use certain techniques to make a schedule serializable so we use certain techniques to make this particular schedule S as a serializable schedule now why this particular concurrency control mechanism is needed so there are certain anomalies or there are certain conflicts which arises in our databases so first is lost updates so whenever two or more transaction update the same data simultaneously and one of the update might be lost for example if two user modify the same record at the same time the changes made by one user could override the changes made by other so consider that if there are two transaction T1 and T2 T1 is performing a right operation on a and T2 is again performing a right operation on a T2 commits so here the updated value of a is considered 10 here the updated value of a is considered 60 so here the value of a is committed at 60 but after this the T1 also commits so final value of a updated in our database would be 10 so you can see that there are some inconsistency which is arising and the changes made by one user could be override with the changes made by other user now coming to the second that is dirty reads so whenever a transaction reads data that has been modified by another transaction but not yet committed if the first transaction roll backs the other transaction will read invalid data so consider if there are two transaction T1 and T2 as part of T1 I'm doing a read of a and write of a as part of T2 I am reading the updated value of a so here I have read the updated value of a so consider the value of a here was 10 after update the value of a was 20 so here the value of a which was read was 20 now consider at some moment this particular transaction T1 FS so it will go ahead and roll back all the values it will go ahead and roll back the value of a to 10 but here the value of a was read as 20 now this particular value becomes invalid so that is why dirty reads happen now coming to the third one that is uncommitted dependency or you can say dirty rights so when a transaction modifies data that has been read by another transaction leading to inconsistency if one of the transaction roll backs it says that consider if there are three transaction T1 T2 and T3 as part of T1 I'm doing a update on a as part of T2 also I'm doing a update on a and as part of T3 I'm doing a write on a and consider that because of any reasons this particular transaction fails so since this particular transaction has failed it will roll back the value of a to its original value but here we haven't read the value of a so this particular transaction has done some modification in a and after this modification has been done this particular transaction is reading this value now this particular value is inconsistent because there has been a failure in T1 so because of the failure in T1 this particular value becomes invalid and because of that this particular value always become invalid so there is uncommitted dependency because the transaction haven't committed and because of the transaction haven't committed there are some inconsistency which arises in our database now coming to inconsistent retrievals that is non-re repeatable reads so it happens when a transaction reads the same data multiple time and get different value each time because another transaction is modifying the data between the reads so consider if there are two transaction T1 and T2 as part of T1 I'm reading the value of a as part of T2 I'm modifying the value of a and again as part of T1 I'm reading the value of a so the value of a which is read here and the value of a which is read here would be different so here you can see that as part of only one transaction if I'm doing two read operations I'm getting modified data so that leads to non-repeatable reads now coming to Phantom reads so it occurs when a transaction reads a set of road that satisfy a condition but another transaction inserts or delete Roo that affect the set before the first transaction complete this results in first transaction reading different set of rows if it re-executes the query consider if there are two queries q1 and Q2 as part of Q2 I am adding or inserting some rows in my DB as part of Q2 I am reading the number of rows or fetching the number of rows so if I do this Q2 operation once I get three rows and if this q1 operation is also executed at the same time it will go ahead and add one more row and after consider one second only if I am again doing this read operation I'll get four rows so you can see that there are different number of rows which I am getting because of the addition if considered that this is not addition this is deletion and it goes ahead and delete some of the rows so first it was three rows now it is two rows so here you can see that there is some discrepancies in the number of rows which I am reading while doing the query now coming to the some common concurrency control mechanism so the first one is log based protocol now as part of this we would be learning about two-phase locking strict two-phase locking and locking protocols coming to the next one that is timestamp based protocols so as part of this we would be learning about basic timestamp ordering and Thomas wres ruol the third one is optimistic concurrency control that is OC fourth one is multiversion concurrency control that is mvcc now from semester and interview point of view this log based and timestamp based Protocols are important so we would be learning about them in more depth about optimistic and multiversion we would be seeing about the definition and what they are exactly but we won't be going in more depth so here are some of the commonly used concurrency control mechanism the first one is log based protocol the second one is timestamp based protocols the third one is optimistic concurrency control and the fourth one is multiversion concurrency control so let's start with log based protocols so before starting with log based protocol let's just re revise the molder Concepts so in concurrent schedule There Was a non-s Serial execution happening and because of this non- serial execution the consistency was very low now for this non- serial execution we introduced the methods such as serializability and concurrency control mechanism as part of serializability we try to see that if a given schedule is serializable or not as part of concurrency control mechanism we make the schedule as serializable so here is the first concurrency control mechanism that is log based protocol so as the name suggest we are using some kind of logs so that we can achieve serializability and so that we can make a schedule serializable so here are some types of lock the first lock is binary lock so it is a simple mechanism where a data item can either be locked or unlocked if a thread tries to acquire the lock when it's already logged it must wait until the lock is released by the thread currently holding it so as part of binary lock we can lock or unlock a given data item a now coming to the next log that is shared and exclusive log so in shared log it allows multiple transaction to read a data item simultaneously but prevents any of them from modifying it so whenever we want to perform a read operation on any data item we can use a shared lock but we can't do any modification multiple transaction can hold share lock on the same data item at the same time so since it is used for the read operation and whenever there is a read read happening in different transaction there is no conflicts so multiple transaction can hold a shared lock on a same data item now coming to exclusive lock so it allows a transaction to both read and modify a data item when an exclusive lock is held by a transaction no other transaction can read or modify the data item so whenever we want to perform a read as well as write operation on a data item we can use a exclusive lock now whenever we are using a exclusive lock in one of the transaction in next transaction we can't use the exclusive lock on the same data item because there might be some read as well as write conflicts so in shared lock we are using it for read purpose and exclusive log we are using it for read as well as right purpose so whenever there is a right operation involved there might be some conflicts such as WR read conflict WR right conflict and read write conflict so just to avoid all these conflicts if there is one transaction which is acquiring a exclusive log we don't provide exclusive log to the next transaction so if there are two transaction T1 and T2 and T1 is having an exclusive log when T1 unlocks that particular exclusive log we can assign an exclusive log to T2 for the same data item so when it is unlocked we can go ahead and assign the lock but in shared loog if transaction T1 is having a shared lock on a data item a as part of T2 also we can assign a shared lck on data item a because there is a read read operation so there is no conflict but here since WR operation is involved there could be read WR WR WR right read conflicts so here you can see that there are two transaction T1 and T2 as part of T1 we are giving exclusive log we are performing a read operation on a write operation on a and then we are unlocking it after that we are providing a shared lock on B so here you can see that there are different data items so if there are different data items we don't need to wait for one particular exclusive lock to unlock or release itself we can provide any shared or exclusive lock to different data item it is only applicable when the data item is same so whenever there is a same data item we can say that there could be some conflicts but when the data item are different there won't be any conflicts so here we have provided a shared lock we are reading the value of B and then we are unlocking it so when we unlock any lock we can go ahead and provide any shared or exclusive lock in case of a exclusive lock so when a transaction acquires a shared lock on a data item other transaction can also acquire a shared lock on the same data item item so if there are two transaction T1 and T2 and T1 is acquiring a shared log as part of T2 we can again acquire a shared log enabling concurrent reads however no transaction can acquire an exclusive log on the data item as long as one or more shared logs are held so if there are two transaction T1 and T2 as part of T1 if I'm giving a shared lock on a I can't provide any exclusive lock on a as part of T2 until this particular lock unlock itself because again as part of exclusive lock I'm doing a read as well as WR write operation and as part of shared lock I doing a read operation so there could be a read WR conflict which could occur so there will be a RW conflict now when a transaction acquires an exclusive lock on the data item it has full control over the item meaning it can read and modify it no other transaction can acquire a lock on the same data item until its exclusive lock has been released so if there are two transaction T1 and T2 and if T1 is acquiring a exclusive lock on a T2 can't acquire exclusive lock on a until or unless this particular lock is unlocked so if there is a exclusive lock involved there won't be any shared lock or exclusive lock and if there is a shared log then there won't be any exclusive log there can only be a shared log so when there is a shared log there can be only shared log no exclusive log when there is a exclusive log there can't be any shared or exclusive logs so shared log can be present in any number of transaction for exclusive lock only one transaction should hold it at one time so while shared and exclusive locks are vital for maintaining data integrity and consistency in concurrent involvements they can also introduce significant challenges in terms of performance Deadlocks reduced concurrency and system complexity so although they are helping us to achieve serializability to some extent but there are some issues such as dead Lock reduced concurrency and system complexity now what are the drawbacks of shared and exclusive lock so the very first one is performance issue managing lock require additional CPU and memory resources the process of acquiring releasing and man managing locks can introduce significant overhead so here we are acquiring a lock of exclusive or shared and then we are releasing that particular loog so it can introduce some performance overhead because of which the performance issues can arise in our CPU as well as in our memory now coming to the next poter that is concurrency issues so exclusive log prevent other transaction from accessing log data item which can significantly reduce concurrency so in concurrency what we see is if there are two transaction T1 and T2 there could be some the leave transaction which is happening but if I am acquiring an exclusive lock any any one of the operation of the transaction other transaction can't go ahead and access the same data item until or unless the lock is released so coming to the next point that is starvation some transaction may be delayed if higher priority transaction consistently acquire logs before them leading to starvation where a transaction never gets to proceed consider if there are three transaction T1 T2 and T3 as part of T1 I acquiring exclusive lock it is happening at time t as part of T2 I'm acquiring a shared lock it is happening at time T Dash and as part of T3 again I'm acquiring a shared lock which is happening at Point touble Dash so here you can see that uh we are acquiring locks in different transaction but since in transaction T1 there is a exclusive lock and this lock isn't released yet so there won't be any lock which would be acquired in T2 and T3 and they will wait for T1 to complete consider that T1 completes at Time touble Dash there is a unlock happened at Time tble Dash and here shared log on a is being demanded so it will go ahead and give that particular log to T3 it will say that your wait time is over now you can acquire a log but T2 was waiting from the long to get the uh log for itself but it is now again waiting because there are some more higher priority operations which are coming into picture this is how starvation happens in transaction when transaction may be delayed if higher priority transaction consistently acquire locks now coming to Deadlocks so she an exclusive lock can lead to Deadlocks where two or more transaction hold locks that other transaction need so there could be some Deadlocks which could be formed because consider if there are two transaction T1 and T2 where T1 is acquiring exclusive lock on a now T2 comes in acquire exclusive lock on B this could happen because the data item are different now again T1 wants an exclusive lock on B so it needs to wait for T2 to get completed and consider that T2 again want the exclusive lock on a so it needs for T1 to get completed so here you can see that there is a loop which is getting formed and none of the transaction is ever completing and they are waiting for themselves so because of this the deadlock issue happens we'll be learning about deadlocks in more depth in next set of slide now coming to the next point that is irrecoverable so if transaction B commits after the lock is released based on a modified value in transaction a which fails after some time so consider if there are two transaction T1 and T2 as part of T1 I'm giving a exclusive lock on a I am reading the value of a I mod ifying the value of a and then I am unlocking a as part of T2 again I'm giving exclusive lock on a I am reading the value of a and I'm writing the value of a and then I'm unlocking it consider that this particular transaction T2 goes ahead and commit all the changes in the database now in the database all the changes have been committed and it has read the updated value here and on basis of that updated value it has performed the right operation but consider that at some point this particular transaction fails because nowhere we have told that there would be unlock happening when the transaction has committed all the changes we haven't said that so there could be a chances that there is some failure which has happened at some point of this particular transaction so it will roll back all the operation and all the changes which was done as part of this transaction but this particular transaction has read the value which was modified as part of T1 but now T2 is having a invalid value and that is already updated in our database so this particular transaction can be recovered but this particular transaction can't be recovered so there is IR recoverability now what is this deadlock so it is a situation when two or more transaction wait for one another to give up the locks so here you can see that there is a resource R1 which is assigned to a process P1 now P1 is waiting for R2 and R2 is assigned to P2 which is waiting for R1 so here you can see that there is a loop which is getting formed because P1 is dependent on R2 R2 is dependent on P2 P2 is dependent on R1 and R1 is dependent on P1 so there is a loop and there is a deadlock which is getting formed so we saw that in the shared and exclusive lock there were some drawbacks so because of this we introduced the two-phase Locking now what is this two-phase locking protocol this protocol ensures serializability by dividing the execution of a transaction into two distinct phases first one is a growing phase a transaction can only acquire locks but cannot release any this phase continues until the transaction has obtained all the lock it needs and coming to the shrinking phase so after the transaction releases its first lock it can no longer acquire any new locks during this phase the transaction releases all the locks so there are two phase growing phase and shrinking phase in growing phase they can go ahead and acquire any kind of lock they want and in shrinking phase they have to unlock all the locks and they can't acquire any lock so because of which the transaction can achieve serializability and consistency in the given schedule so let's see how it happens so here are two transaction T1 and T2 as part of T1 we are acquiring exclusive lock on so we can see that T1 is right now in a growing phase so it is going in a growing phase so there is a read of a write of a Happening Now transaction T2 comes but since T1 is right now in a growing phase and T2 is not in a growing phase there won't be any locks which would be assigned to T2 it will wait for this one to have in a shrinking phase and unlock all the locks now coming to Here There is a share lock acquired on B There is a read on B so till here there is a growing phase which is happening because the all the operations of the transaction are only acquiring the locks now there is a unlock of a which is happening which is for this exclusive lock and then there is a unlock of B which is happening which is for this particular shared lock so this particular State we can call as shrinking phase and this particular phase we can call as growing phase so now there is a growing phase of T1 and then there is a shrinking phase of T1 and since the shrinking phase of T1 is achieved we can go ahead and acquire a shared lock on a present here because right now it is unlocked so you can see that when a transaction acquires a growing phase it will go at and acquire locks in that particular growing phase it won't go to another transaction and give any kind of locks until or unless there is a shrinking phase which is happened for all the locks which is present here and then they can go ahead and give the shared lock or exclusive lock in another transaction which are waiting for them to get completed so in this way we can achieve the serializability and consistency because here you can see that first all the operation of transaction T1 is getting completed only then the t21 is starting so the T1 is getting completed first and then the t2 is starting so there is a serializability which is achieved here now let's see the advantages and disadvantage vages of 2pl that is two-phase logging so first one is it guarantees that the schedule of transaction will be serializable meaning the results of executing transaction concurrently will be the same way as they were executed in some serial order so if there are two transaction T1 and T2 and there are some operation which is happening concurrently consider read of a right of a in T1 then there is a read of a in T2 then there is a read of B in T1 and then there is a write of B in T1 so as part of 2 PL there will be two phases growing phase and shrinking phase so first it will start with the growing phase it will acquire exclusive lock on a there will be one more exclusive lock on B so it will acquire all the locks in the growing phase now there will be a shrinking phase where it will unlock all the locks it will unlock a and it will unlock B but since T2 has a read operation it will wait for this particular explosive lock to get released only then it can acquire a lock so the shared lock on a in T2 will wait for this particular exclusive lock on a to get completed or get unlocked only there the transaction of T2 will start so here you can see first the transaction of T1 is getting completed then only T2 is getting started so there is a Serial execution which is established so there is a serializability Now by ensuring that the transaction are serializable 2pl helps to maintain data integrity and consistency which is critical in environments where data accuracy is essential now coming to disadvantages deadlock starvation and cascading roll backs are still there so consider if there are three trans action T1 T2 and T3 as part of T1 we are requiring exclusive lock on a as part of T2 we are requiring a exclusive lock on a and as part of T3 we are acquiring a shared lock on a now consider that this particular has come to its shrinking phase and there is a unlock which has happened so this one was waiting for this unlock to happen so that it can acquire exclusive loog and this was waiting for this one to complete so that it can acquire a share log now consider at some moment of time this particular transaction fails so it will go ahead and roll back this particular transaction but since this and this transaction was dependent on the changes which was done as part of T1 so this will also go ahead and roll back and this will also go ahead and roll back so there will be a cascading roll back which would be happening because one of the transaction has failed and another transaction had some dependency on this particular transaction T1 now transaction must wait for the locks to be released by other transaction this can lead to increased waiting time and lower the system throughput so here you can see that as part of T2 we wanted to do a read operation but we need to wait for all all the exclusive locks and shared locks which has been assigned in this transaction to get released so that we can acquire any locks and we can proceed with our transaction so here you can see that the waiting time is more now coming to the third one in case of a system failure recovering from a crash can be complex because consider that if at some point this particular transaction failed and this particular transaction was dependent on some of the values which is present in this transaction so we can't go ahead and roll back the committed changes which we have done as part of other transactions so in shared and excl iive lock there were couple of disadvantages which is taken care in two-phase locking like serializability is achieved here concurrency is achieved here data Integrity is achieved here but there were some disadvantages like IR recoverability starvation Deadlocks and cascading aborts which is newly introduced is still persisting here so for this we have a stricter version of 2pl that is strict two-phase locking so what is the strict two-phase logging a stricter variant where exclusive logs are held until the transaction commits or aborts so as as part of exclusive log we do a read as well as write operation and as part of shared log we only do a read operation so what was happening is consider in one transaction there is a exclusive lock which is present there will be a right operation which would be present and because of this right operation if another transaction is reading anything which is modified here and what if it this fails there will be a invalid update into our database so because of which it says that the exclusive logs are held until the transaction commits or abot so this particular transaction should commit or abot only then the unlock of this particular exclusive lock would be happening so that if there is any modification which is made as part of a transaction T1 T2 shouldn't read any invalid value if it's a commit it will go ahead and read the valid value which is present in the database if this is a award it will go ahead and roll back to its original value so at this case there won't be any dirty read problems which would be happening so this helps prevents cascading roll backs where one transaction roll back causes other transactions to roll back so here uh we are only unlocking it or releasing the lock once the transaction is committed or aborted so there won't be any cascading roll backs which would be happening in different transaction because there were no strict rules for any of the log that when they can unlock them themselves but as part of strict 2pl we says that if there is any exclusive log it would only unlock itself once its commits or abort its operation so the advantages are it prevents the cascading aborts the second Advantage is it ensures strict serializability so there will be a District serializability which should be insured because there won't be any invalid data which is getting updated in our database so the consistency is more here now coming to the disadvantages so since right locks are held until the end of transaction other transaction may be blocked for extended periods since there is a exclusive lock which is happening in transaction T1 it will only unlock itself once it commit all the changes in the database so there might be some time which should be taken by transaction T1 to commit all the changes till then T2 would be waiting for a shared lock which needs to be acquired only when the T1 is unlocking the lock so once T1 is unlocking the lock only then T2 can acquire a Shar lock so the weight time will be more now coming to the next point that is transaction may experience longer weight time to acquire the locks so transaction may experience some longer wait time to acquire the locks now the third one is Deadlocks and starvation is still there so deadlock and starvation is still not encountered as part of strict 2pl because again consider as part of T1 we are having an exclusive log as part of T2 we are having a shared lock as part of T3 again we are having an exclusive lock as part of T4 again we are having a shared locks so these all locks needs to wait on each other to unlock so that they can start their execution so there still be deadlock which would be happening and a loop which would be happening because all the other transactions are interdependent on each other for them to be unlocked so here we can see that again there are some disadvantages which are still persisting so there is one more stricter version of strict two-phase PL that is rigorous two-phase PL so what is this two-phase logging so it is an even stricter version where all the locks shared and exclusive are held until the transaction commits so to PL it says that the exclusive lock should only unlock themselves when they have committed or aborted the changes but as part of rigorous 2pl it says that exclusive lock as well as shared lock should commit or abort the changes only then they can go ahead and unlock themselves so the lock are held until the transaction commits or aborts now what are the advantages since all the locks are held until the end of transaction the system can easily ensure that the transaction are serialized and can be recovered so since there are locks which is getting held in both exclusive as well as shared lock so there is a guarantee of serializability as well as recoverability now it prevents the cascading aborts and dirty reads what are the disadvantages so the performance bottlenecks are there increased transaction duration because earlier they were only hold on the exclusive block but now the hold is present on the exclusive as well as share lock until or unless they commit or abort so there is a increased transaction duration third point is deadlock and starvation is there so we can see that deadlock and starvation is something which is getting persisted for all the 2pl two-phase Locking stick two-phase locking regress two-phase locking so again there is one more locking protocol that is conservative two-phase locking so conservative two-phase locking or you can say static two-phase locking is a variant of a standard two-phase protocol that aims to to prevent Deadlocks entirely by requiring a transaction to acquire all the lock it needs before it begins its execution so what it says that all the transaction should acquire all the locks before even the transaction start its execution so if the transaction is unable to acquire all the required logs because some are already held by other transaction it wait and retries the transaction only starts execution once it has successfully acquired all the necessary logs so once a given transaction has acquired all the locks which is needed as part of operation which is present in the transaction only then it will start it execution until or unless then it won't started execution and it will wait so consider if there are two transaction T1 and T2 as part of T1 we are doing a read operation on a WR operation on a as part of T2 we are doing a read operation on B WR operation on B as part of T1 again we are doing a read operation on a WR operation on a as part of T2 we are doing a read operation on B and WR operation on B so before even the transactions start executing it will acquire all the locks so here it will need a exclusive lock on a it will need an exclusive lock on B so before the transaction start it will acquire all the locks so here T1 has acquired exclusive lock on a and exclusive lock on B so since T1 has acquired the exclusive log on a and exclusive log on B T2 can't go ahead and acquire any exclusive log because T1 has already acquired all the logs which is needed for T2 and T2 can't start its execution even if one of the log which is needed by T2 is not present right so first T1 will start all its execution only then T2 can go ahead and acquire any locks and start its execution so because of this there won't be any deadlock scenario which would be present because since a transaction never starts executing until it has all the lock it needs deadlock cannot occur because no transaction will ever hold some locks and wait for other so here T2 won't be holding any locks even though it requires exclusive lock on a and exclusive lock on B it needs to wait for this particular transaction to get completed only then T2 can go go ahead and start it execution and acquire the lock here T2 has not even started its execution then how it can go ahead and acquire a lock right so there won't be any deadlock situation which would be present here because T2 can't acquire any lock because all the locks have been acquired by T1 and it needs to wait for them so in this scenario deadlock cannot occur because neither T1 nor T2 starts his execution until it has all the lock it needs now coming to the next concurrency control technique that is timestamp based protocol so it assigns a unique timestamp so when Whenever there are two transaction T1 and T2 and they start at any instant t or you can say t Dash so it gives a unique time stamp to the transaction whenever they start its execution or their operations so every transaction is assigned a unique Tim stamp when it enters the system it is used to order the transaction based on their time stamp so we can order the transaction that T1 started first then T2 started or we can also order their operation that read of a started of T1 first then read of a of T2 started so all these operation and all these transaction we can give a time stamp so there are two important time stamps for each data item first one is read time stamp second one is write time stamp so the last time stamp of any transaction that has successfully read the data item that is RTS so consider if there are two transaction T1 and T2 as part of T1 I am reading a value of a writing a value of a as part of T2 I am reading a value of a so the last read operation on data item a happened on T2 so we can say that the last read operation happened in transaction T2 at particular time step T Dash so that is the RTS now coming to WTS consider that it is doing a update on a and here also it is doing a update on a so we can see that the last update on a has happened in T2 at time stamp you can say touble Dash so WTS of this is touble Dash and RTS of this is T Dash so we give the latest of the read and the latest of the right time stamp now transaction with smaller time stamp are called as old transaction transaction with larger time stamp are called as young transaction because consider that if there are two transaction T1 and T2 now T1 started at 700 p.m. and T2 started at 710 p.m. so we can say that this particular one would be having a larger time stamp and it would be having a smaller time stamp so we can say that this particular transaction is a old transaction and this particular transaction is a young or you can say a fresh transaction here are some rules for the time time based protocols which help us to tell that if there is a transaction as part of that transaction if there are any operation that should be executed or or that should be rejected so here is a RTS that is read time stamp of a WTS that is right time stamp of a so consider if the transactions are getting performed on a data item a so first one is check the following condition whenever a transaction TI issues a read operation so whenever there is a read operation which is issued by a transaction ti What should be checked so first one is the right time stamp of a should be greater than the time stamp of TI then the operation is rejected that is roll backed if the right time stamp of a is less than or equal to the time stamp of TI then the operation is executed and we set the read time stamp of a as the maximum of read time stamp of a and the time stamp of transaction TI now coming to the second pointer check the following condition when the transaction TI issues a right operation so the first one is if the transaction TI is less than the read time stamp of a then the operation is rejected that is roll back the transaction TI if transaction of TI is less than the right time stamp of a then the operation is rejected and TI is rolled back otherwise the operation is executed and we set the right timestamp of a to timestamp of TI now again I know that this particular rules would be sounding very confusing to you you won't be even understanding that what is happening here so I'll just give you a small trick which you can keep in mind so that you can know that if there are two transaction T1 and T2 then what all operation should be executed or rejected so I told you about old and young transaction how we distinguish between old and young transactions so consider if there are two transaction T1 and T2 and if the time stamp of T1 is less than the time stamp of T2 we can say that T1 is a old transaction and T2 is a young transaction now consider if as part of T1 and T2 we are performing some operation so since T1 is a old transaction we assume that T1 should be completed first only then T2 should be completed so there would be a Serial execution that T1 should be completed first only then T2 should be completed now consider that as part of T1 I'm doing some operations and as part of T2 also I'm doing some operations so here there are no issues because T1 is getting completed first only then T2 is getting completed but consider if there is a use case where T2 operation is starting first and then after T1 operation either read operation or write operation is happening although T2 started at a later point so whenever the older one has done all the operations and then younger one has started its operation and older one is getting completed there is no issues but when the younger one has done all the operations and then older one comes Ahad and does some of the operations then there would be a roll back so let's assume that there are two transaction T1 and T2 suppose the transaction T1 has entered the system at 700 p.m. and transaction T2 has entered the system at 75 so T1 is the old transaction and T2 is the young transaction now then T1 has a higher priority so it executes first and it enters the system first so T1 will be executing first and then T2 would be executing so it will be T1 goes to T2 that is a Serial execution where T1 operations is completed and then T2 operation is getting completed so how we can see that if there would be any roll backs which would be happening so if the younger one has done a read or right operation so younger one has done a read or right operation and older one wants to do a read or right operation then that is a roll back case if younger one has done any read or right operation and older one wants to do any read or right so there should be a roll back so you can just remember in this way that if younger one is performing any operation and then the older one comes in and perform any of the operation there should a roll back but if older one is performing any operation and then younger ones come then there is no roll back so here you can see that there are two transaction T1 and T2 T1 is old T2 is younger so T1 is performing operation T2 is performing operation no issues T1 is performing a right operation T2 is performing a read operation no issues T1 is performing a right operation T2 is performing a right operation no issues because we are expecting that T1 would be completed first as it has entered the system first and on the basis of priority T1 should be completed so this is how this time stamp based protocol works so you just need to remember that if the younger one does some transaction and after that the older one comes ahead and do some transaction they roll back but if the older one is doing any transaction and after that the younger one is doing there shouldn't be any roll back cases so this is all about the concurrency control mechanism now the first question which comes in mind is that why do we even need to learn about this database recovery management so it involves strategies and processes to restore a database to a consistent state after a failure or crash so when Whenever there is a failure or crash we need some methods for management so that we can recover our database now what are the types of database failure so the first one is transaction failure it occurs when a transaction cannot complete successfully due to logical errors or you can say system issues like Deadlocks so whenever there are some logical errors or system issues like Deadlocks we can face some transaction failure which could happen in our databases the second one is system failure so it occurs when the entire system crashes due to a hardware or software failure leading to loss of inmemory data we have seen at certain times our laptop get turned off automatically or our computer system get turned off automatically so there could be a system failure which could happen in our laptops or in our computers which could lead to loss in memory of the data so we need to recover from this particular failure now coming to the next failure that is Media failure so it occurs when the physical storage that is hard drive is damaged resulting in data loss or corruption so whenever there is a failure in a physical storage or you can say hard drives it results in the corrupting of data because of which there is a data loss now we need to recover from all these failur so what are the recovery methods we can follow so first let's see about the recovery phases so the first phase is analysis phase it identifies the point of failure and the transaction that were active at that time so it will identify that at what point the failure happened and what were the transaction that were active at that particular instant of time now coming to the redo phase so it reapplies the changes from the committed transaction to ensure that the database reflects all completed operation so whenever there is a failure which has happened as part of a transaction it goes ahead and roll back that particular transaction so as part of roll back it will go ahead and roll back all the operation which has happened as part of this particular transaction so it reapplies all the changes from the committer transaction as part of roll back it will go ahead and reapply all the changes from the last committer transaction which was successful to ensure that the database reflect all the completed operation now the third phase is the undo phase it revers all the effects of incomplete transaction to maintain the consistency so here in the roll back we are roll backing all the operations which needs to be performed as part of T1 so let's learn about the recovery techniques the first one is backup and restore so whenever we take the regular backups we ensure that the data can be recovered to the last backup which has been taken so full incremental and differential backup are the common types of backup now the second one is logging so we keep a record of all the transaction that is transaction logs the right ahead logging or wal protocol ensures that the logs are written before any changes are applied to the database so whenever there is a transaction happening if it does any read or write operation it is getting saved in our transaction logs and once all the changes have been committed to the database it goes ahead and delete the transaction log but if the changes are not committed to the database we have the transaction lock and using this we can recover our database now the third one is Shadow paging so what is Shadow paging it maintains two copies of the database pages one is the updated one and the other remains unchanged until the transaction commits so if there is one database D it will make a copy of that particular database D Dash and in that particular database D Dash we have all the lastar changes which were saved and we'll be doing all the operations on D now D Dash would be having all the changes which were saved at the last time so even if there is any failure occurred at D it can go ahead and recover all the data which has been lost as part of D's failure so these are all the techniques which we oftenly follow whenever we have any failure in our databases now what is this query optimization and why do we even need it so whenever we want to improve the efficiency of our query make it execute faster and consume fewer resources we use the query optimization techniques so whenever we want to increase the efficiency of our query make our query to execute faster and give results in faster time and whenever we want to consume some fewer resources of our system we use this query optimization technique so consider if there is a employee table and in that particular table we have some employee details such as employee ID employee name employee age and much more Fields now consider that this employee table has th records and in that th record I make a query that give me the details of employee whose employee ID is 990 so I want to fish the detail of employee whose employee ID is 990 so it will go ahead and it will do a search on the employee ID and it will see row by row that wherever Eid matches 990 it will return the entire result of this particular row but this query may take some time and consider that in real scenario our employee table has 1 lakh or 10 lakh plus records right so for that we need to make our queries to execute faster so that we can get the faster result that is why also we use the query optimization techniques so optimizing SQL queries is essential for for improving the performance of database application so whenever we want to improve the performance of our database application we need to optimize our SQL queries and we can use the query optimization techniques there so let's see what are the common techniques which we use so first one is use indexes efficiently so index the column frequently used in We join order by Group by Clauses to speed up the data retrieval now what is this indexing indexing is basically a technique in which we lower down the number of dis SES which was being used earlier so it lowered down the number of disk SS because of which the queries gives us the result in Faster duration of time for now if you're not understanding indexing don't worry we'll be having a dedicated lecture on indexing and types of indexing there the concepts would be clear but for now you can only understand that whenever we are doing any Group by we order by Clauses it's better to use the indexed columns there to get the faster result now coming to the second point that is Select only necessary columns so avoid using select star especially Only The Columns you need in your query this reduces the amount of data transferred and processed so most of the cases we use the select star to fetch some of the details but if we know that we have to fetch only some specific columns it's better to provide the columns rather than providing a select star which will go ahead and fetch all the details or all the attributes which is present for that particular employee or for that particular XYZ entity so we should take care that if we want only specific columns it's better to use that particular columns with the select statement rather than using the select star now coming to the third point that is optimize join operations so choose the right join type and use indexed columns in the join condition now what is join so basically in join what we do is consider if there are two tables A and B and I want some details from a as well as B table I'll perform a join operation between them on the basis of a common entities or you can say common attribute which is common between both the tables now it says that whenever you are performing the join operation always take care that you choose the right join type and second thing if you're joining on basis of some column always make sure that that particular column is a indexed column so that the number of disk s is lower down and we can get the queries result faster so we perform joint whenever we want some related rows of different tables and on the basis of parameter or on the basis of a related column on which we are joining that should be indexed now coming to the fourth point that is partitioning large TBL so for very large tables consider partitioning them to improve the query performance partitioning allows the database management system to scan only relevant partition reducing input output cost and improving the response time so it says that if your database is too big so partition that into smaller chunks and then make a query on that smaller chunks so that you can get the result faster will reduce the input output cost as well as the response time now coming to the fifth point that is cache the results so cache the results of frequently executed queries to avoid the Redundant calculations says if there is any query which is getting executed as part of different API calls so it's better to call a cache rather than calling a DB because calling to the DB may take more time but if the response is stored in the cache for consider X duration of time for the similar query it's better to call the C so that we can get the result faster and also we can avoid some redundant calculations so let's learn about physical storage and file organization so what is a storage device for storing the data there are different types of storage operations which is available so storage device basically help us to store the data now what are all the options which are available so first one is primary storage second is secondary and third one is tertiary now coming to primary storage so it is basically the main memory and the cachier memory it is fastest it is expensive and as soon as the system leads to a power cut or crash the data also gets lost so data is only stored in the system until or unless there is a system crash or power failure after that the data is lost now coming to secondary storage it consists of flash memory and magnetic dis storage which is nonvolatile nonvolatile basically means that it saves the result even after there is a system crash or you can say power failure so it stores the data permanently and this is volatile because it loses the data once there is a power failure or system crash now coming to the tertiary storage so it basically involves optical disc and magnetic tape it is used for data backup and storing large data offline so whenever you want to store large data you use this tertiary storage whenever you want to store the data permanently you use this volatile or you can say secondary storage and whenever you want to store data for some duration you can use this primary storage although primary storage is the fastest but it is also expensive now databases store data in files on disk so there are some disk which is present you can say hard disk in that dis there are some files in which the data is stored so each table or index May correspond to one or more files each file has a sequence of record so each file consists of some sequence of record now accessing data from Ram is much faster than accessing data from a hard disk or SSD so what happens is there is a CPU which access some data from the hard disk or from the SSD but CPU is very fast and this hard disk or SSD is very slow so it's better that CPU don't make a direct query to the hard hard disk it go to the RAM and RAM makes a query to the hard disk so that this particular process is streamlined so here you can see this is because Ram is designed for high-speed read and write operation data retrieval in Ram typically involve fetching data in nanoc seconds so in Ram you can fetch the data in nanc so CPU makes the queries to the RAM and RAM checks if it has the desired result if it doesn't has it goes to the hard disk it takes the blocks and it does the query checks if it has the desire results are not now Ram provides fast volatile memory for quick data retrieval so volatile here means that after a system crash or failure the data will be lost now data is accessed via addressable location and cachier memory enhances speed so the cachier memory enhances the speed and data retrieval is done based on the addressable location now what is hard disk so it provides a slower nonvolatile storage with mechanical components that impact the excess speed so since CPU can't do a on the hard disk itself or can't do a query on the hard disk itself it goes via Ram because Ram is very fast and hard disk is comparatively slow so data retrieval involves moving the read right head and waiting for the dis rotation so data retrieval basically involves moving the read right head and waiting for the dis rotation now when a program or application needs to access data it first check if the data is available in the ram if the data is not available in the ram it must be loaded from a slower storage device like hard disk or SSD index file and database management system are stored on the disk but are also managed in Ram to optimize the performance see that when we give query how we get our results back so here the query is fetch the detail of the student whose R number is equal to five so there is a student table which is present and I want to fetch the detail of a student whose roll number is five so how the query will be executing so firstly the student table would be present in the hard disk because hard disk is a nonvolatile memory so it will save the data even if there is a system crash or failure so it will save the data permanently so we'll store this particular table in the hard disk now table inside the table there are multiple records so we store this particular records in some blocks so there are blocks like B1 B2 B3 till till till BN so there are couple of blocks in our hard disk and in each block we store some data consider in this block we are storing from 1 to five R number then from 5 to 10 then from 10 to 15 in all these blocks we store all these particular records now what will happen once the CPU receives the query it will make a call to the ram it will say that I want the detail of a student whose rle number is five now Ram will call the hard disk and hard disk will give all the blocks one by one like first B1 is given then B2 then B3 and in this blocks it will search that if there is any student with r number five existing once it find the student with r number five existing it will take up all the details and it will give it back to the CPU and then we can get the design desired result so this is how it functions we use the ram because the excess is very fast and this is a volatile memory so it won't be staying so long like after the system failure or a switch this is how the query execution happens whenever we give a query it goes to the CPU now CPU makes the call to the ram ram makes the call to the hard disk each and every block is transferred one by one and it checks in the block that if the query satisfies when it checks that if the query has satisfied it give away the process result so how files is organized so here here you can see that there is a hard disk and there is a DB or you can say table now in this hard disk there would be multiple blocks B1 B2 B3 till till till BN now in this particular block B1 how much data of this particular table could be stored how we can find that so files are basically allocated on the hard disk in a contous blocks to reduce the fragmentation now number of Records stored in each block is equal to size of block divided by the size of so consider if there are 10 records here and size of each block is 100 so what we will do is we'll do 100 divided by 10 that is size of block divided by size of record so it is 10 so in each block we can store at least 10 records so this is how we find that in each block how many records we can store so records can be stored in two ways first is sorted way searching is fast second is unsorted way where searching is slow and insertion is fast so we can store the data in a sorted or unsorted manner in sorted manner the searching would be fast in unsorted manner the searching will be slow but the insertion would be fast so this is how we can optimize our query and organize the files in our system now the very first question which would be coming to your mind is why do we even need a indexing so let's take an example of a textbook so imagine you have a th000 page textbook and you want to search for a specific topic XYZ so you having a book in that particular book I ask you to search about a given topic XY Z Now how you can do that so first thing is whenever we have the index or the contents of the book we can go ahead and see that where that particular topic is present and we can go to the page number consider a case where you don't have the index which is present in the book now in that case what you will do is you will search each and every page one by one now there are thousand pages in the book so consider the time you would be consuming when you are searching for each and every page one by one so here indexing comes into picture so when the indexing is not present you need to manually search for each term in the book which could be frustrating and time consuming now the second case is when the indexing is present the index allows you to quickly locate each topic you can look up for XY Z find that which is page number where it is covered this makes it more efficient and let's time consume so you'll get a range of page numbers in that particular page number range you can just go ahead and search for that particular topic now here you can see that here you are hardly searching for two or three pages but earlier you need to search for thousand pages so you can see the search space has also reduced and the time consumed is also reduced so this is how indexing help us so indexing is a critical technique in database management system that significantly improves the performance of query operations by minimizing the number of disk s's index table is always sorted now what does this mean minimizing the number of dis asses so every data of us is present in our hard disk or you can say in our disk now in this particular disk we have our database now in this particular database there are some tables in that particular table there are some rows there are some columns and they are stored in the form of blocks B1 B2 B3 which I discussed in the last video now you need to go to each and every block to find a particular topic or a particular key now here you can see that when you have a indexing which is present which says that if you want to search for XY Z it's present in Block B2 so you'll directly go to block B2 and just search for that particular topic or that particular key rather than going to each block one by one you just need to go to one block so you can see that it minimizes the number of dis asses so the number of dis we are accessing or the number of blocks we are accessing is very much minimized now why do we need indexing so in the same way how we have used indexing in the book it help us to find specific records or data entries in a large table or large data set so consider if you have a large data set in which consider you have 10,000 rows now in this 10,000 rows you don't need to go ahead and search for each and every row manually rather you can go to the index table and search for a specific key and then pointing to that specific key you can go to the block pointer where that particular row is stored in the hard disk so you can go to that particular block so here you can see that you provide a search key and the data access in the index table now in the search key it is used to find the record and data access it contains the address where the data item is stored in the memory for the provided search key so basically we have an index table in which we have a search key and the block pointers or the references to that particular data whenever we are searching for any key it will come to this search key column it will search for that particular key then it will go to the blog where that particular card is present and then it will fetch that particular Block in the memory it will search for that particular value once it gets that it will go ahead and send us in the final result so the search key helps in finding what a user is looking for and the data access tells us where the record is stored in the memory it is basically a set of pointers holding the address of the blocks so all these blocks have some address and that is stored in the index table now how the indexing helps so it helps in improving the query performance indexes allows the database management system to locate and retrieve data much more quickly than it could by scanning the entire table so earlier what we were doing is we were scanning the entire table or you can say entire blocks in which all the records are present now we only need to go to this index table we need to search for that particular key which we are searching and then we need to go to the pointing block where that particular value could be present and then we only need to search for that particular block so earlier we were searching for each and every block now we only need to search for one or two blocks specifically now indexes can be used to optimize queries that sort the data that is order by or group the data that is Group by so as I told in the earlier slides that index table is always sorted so whenever we are putting any key which is present in this index table in the key column they are always sorted so this is a sorted data so whenever we want a sorted data or a grouped data we use index because that is very helpful so whenever an index is available on the column being sorted or grouped the dbms can retrieve the data in the desired order directly from the index eliminating the need for additional sorting operations so earlier whenever you want some sorted data based on some specific column you need to perform some additional sort operations but as the index table is always sorted the key present in index table is always sorted we can use this index table or we can use the column on which this particular table is indexed and that particular column if we use with the order by and group by Clause it will help me to get my data more fastly and efficiently now we have certain indexing methods like dense indexing where index entry is present for for all the records and sparse indexing where the index entries are present only for a subset of Records in the index so let's learn about dense indexing and sparse indexing like how we can store a particular key as well as the search pointers in our index table in different methods so first one is sparse index so sparse index is a type of database indexing technique where the index does not include an entry for every single record in the database instead it contains entry only for some of the records typically well entry per block so consider that in our database we have some columns where ID is 1 2 3 4 5 6 7 8 9 10 now what we are doing is from ID 1 to ID3 we are storing in Block B1 from ID 4 to id6 we are storing in Block B2 from ID 7 to ID 10 we are storing in Block B3 so what we are doing is we are only providing the first element of that particular blog in our index table so here in the index table I have stored all the first elements of different blocks and whenever I want to search for a value consider three I'll go to this particular index column I'll see there is a one present and then I'll go to here I'll see that there is four present so basically between 1 to four three would be lying so three would be lying in this particular block so it happens whenever our data is sorted so whenever we have a sorted data we can use the sparse index where we don't need to store the value or store the entry for each and every record which is present in our blocks rather we can store only the first element of the block and we can give the block point where that particular entry is stored in our database or in our disk so if we need to provide entry for each and every row which is present in our block it will make the index table a much more bigger table and then again we need to go through each and every entry and then only we can search for that particular data so it will also take more time than the sparse index in dense index we does the same we include the entry of each and every record which is present in our table in the indexing table so in sparse index we only give or provide the entry for you can say some specific or single record which is present in each block pointers so you can see a subset of Records but in dense index we need to provide an entry for each and every record which is present in our database table or the table which is present in our hard disk now which have an entry for every record so dense index have an entry for every record sparse index have an entry for only single records of each particular blocks or you can say it contains entry for only some of the records now it is used when we have a ordered data set so whenever we have an ordered or sorted data set we only use this particular sparse index if the data set is not ordered how can I say that I'll give one and four and if I want to find three I can go to this particular block right because the data is not sorted so when the data is not sorted we don't use spse index but when the data is sorted or ordered we use the spse index so if a table has th000 rows and it is divided into 100 blocks you can create a sparse index the index might have only 100 entries which each entry pointing to the first record in the block now it says that consider our table is having th000 records now these particular thousand records needs to be stored in the hard disk so how it will be stored it will be stored in each and every block now consider here it is given that our hard disk has 100 blocks so how many entries would be there per block that is number of Records divided by number of blocks so we can say that there will be 10 entries which will be stored in each particular block now here we can see that in each block there would be 10 entries stored till 100 blocks so there are 100 blocks which is present in our hard disk so there will be 100 entries which would be made in this particular index table and it would be having the entry for each of the first element which is present in the block so there will be 100 entries which would be present in our index table so you can say that each entry will point to the first record in each block now let's understand from this particular example that how the sparse indexing happens so consider that this is my student table now in this particular student table I have the student roll number and I have the student name so the r number is in a sorted manner 1 2 3 4 5 6 and we have provided the names for all the student now what will happen that this particular table needs to be stored in the hard disk so it will go ahead and store in the particular blocks which is present in the hard disk now in the block B1 we have 1 2 3 in the block B2 we have four five and six so per block we have three records which is stored in this particular hard disk so how we can create the index table so what we will do is first we will choose roll number as the index column so we have choose roll number as the index column now we need to provide the search key that is basically the roll number which is present here so in sparse index what we do is we don't go ahead and provide the entry for each and every row which is present in our table what we do is we choose the first element of the block and then we go ahead and provide the entry for that first element so first entry would be one and then we will choose the first entry which is present in Block B2 so that would be four so we have provided the roll number as the search key and here we have provided 1 and four now we need to provide the exess or the data reference where that particular data is stored so we'll provide the block B1 here as from 1 to 3 all the data is stored in Block B1 and then here we will provide block B2 as from four to six all the entries present in Block B2 so this is how we create the sparse index so how many entries could be there in the sparse index so it is equal to the number of blocks which is present so here you can see that there are two blocks which are present so there are two entries which is present in the sparse index table if there were 10 blocks present there would be 10 entries which would be present in my sparse index table so it is equal to the number of blocks the hard disk is having so how sparse indexing actually works so first is primary index sparse indexes are oftenly used with the primary index where the table is sorted on the index column the sparse index only includes an entry for the first record of each block or page so it only includes the entry for the first row of each block and page and it is usually done on the primary key of that particular table so that whenever we index the primary key that will be always sorted and we can easily find any data value which we are searching for now the second thing is searching so when the searching for a specific value the databases uses the sparse index to quickly locate the block where the record might reside it then searches within the block to find the exact record so how searching in the index table happens is consider I want to search for a entry where the roll number is three so I want the details of the student whose roll number is three so what it will do is it will first come to the index table so it will go to the index table or the sparse index which is present it will quickly locate the block where we can find three so here the search key is one here the search key is four so three would be lying in this particular search key so we'll go to block B1 we'll go to block B1 here we will pick that particular block and have it in our memory and in our memory we will go and search for this particular block B1 one by one so there is 1 2 and three once we have got three we will take that and we will return that into our final result so this is how the searching happens so here you can see that we only need to search for one specific block earlier we were searching for different blocks so the time complexity is also decreased so all the sparse index is helping us to execute our queries faster and get the results in faster duration of time minimizing the dis SES there are some disadvantages which is present for this par index now what are these so first is additional IO operations is involved so after using the index to find the correct block an additional search within the block is required to find the specific record so when we are searching for a specific key consider I'm searching for role number three if I'm going to the index table I'm searching the index table wherever I'm finding the search key I'm going to the data reference there and then I'm doing a search on the Block which is present so here you can see that there is an additional search which I need to do for that particular block so because of this additional search there is additional IO operations which is involved now the second thing is less efficient for Random Access so if queries often need to retrieve random non-sequential record a dense index might be more efficient so whenever we want to do some searches in a set of data which is unordered then we use the dense indexes spse indexes can't be used there because sparse index generally works on a ordered set of data because here we are only providing the entry for the first element which is present in our block right so here we can't provide any non-sequential or non-order data so whenever we want to perform any retrieval on a non-sequential or non-order data we use the dense index because dense index has entry for each and every record which is present in these particular blocks or in this particular table so in that case we can do any random access for a particular data item so coming to the use cases primary indexing on large tables so whenever we want to perform any primary indexing on large tables where the data is mostly sequentially restored we can use the sparse index because the sparse index helps us to fetch our queries in lesser duration of time rather than going to each and every block one by one and searching for data it's better to go to the index table of the sparse index and then search for the data and go to the pointer and fetch that particular value so now second one is range queries so sparse indexes can be affected for a range queries where the query needs to retrieve a range of Records rather than a single record so consider if you want to search for a specific range of record consider you want all the value are all the R numbers between R number one to R number six so what you can do is whenever you are performing any range queries you can use par index because here you only need to go to two rows or you need to only do two search operations right so here you can see that how fastly you can get a group of data or a range of data when you are using this pass index now coming to dense index so a dense index is a type of indexing technique used in databases where there is an index entry for each and every record which is present in our data file this means that the index contains all the search keys and corresponding pointers or addresses to the actual data records making it highly efficient for direct lookup so whenever you want to search for any random value in a non-ordered data you can just go to the dense index because dense index has entry for each and every record which is present in the table so you can just do a direct look up from there so it is used when we have an unordered data set so whenever you want to make an indexing in a non- primary key column where the values are also not unique the data is also unordered you can use the density index now consider a table with thousand rows now you create a dense index on a non- primary key column so it can have duplicate values so the dense index will be having number of non-key unique records each pointing to a specific row in a table so consider that there is a non-key colum on which you are providing the dense index and it has some repetitive values 18 18 18 19 19 20 20 so in the dense index the number of entries would be equal to number of unique non-key records so all the number of unique non-key records would be having an entry in the dense index table so this is how the entries would be made when there is duplicate data set which is present these are often useful in scenarios where random access to individual records is quite frequent so whenever we want to do a random access to individual records we can use this tense index so here you can see that again we have the student table and now we are providing indexing on the basis of column that is age so since age is a non- primary key column we can expect some duplicate values which would be present in this particular age column and here are the names of all the students so now all these particular data are present in the hardest so it will be divided into the blocks so each block would be having three rows so B1 would be having 18 18 19 and then B2 would be having 20 20 21 so all three records are placed in one block and these three records are placed in another block now how we will make the index table so as I told that index table would be having entries equal to the number of unique non-key columns so here are the unique values 18 then 19 then 20 and 21 so the search key or the index column on which we are making the indexing that is age would be having 18 19 20 and 21 and then we will provide the block pointers so first search key is 18 so where 18 is present 18 is present here 18 is present here and only block B1 so we'll provide B1 for 18 now coming to 19 so 19 is present in Block B1 so again we'll be given block B1 then 20 20 is present in Block B2 two times so we can provide B2 here and then 20 1 which is present in Block B2 so we'll provide B2 where so here you can see that the number of entries which is present in the dense index is equal to number of blocks unique non-key records so unique non key records are present in this search key in the dense index table now how a dense indexing works so in a dense index each index entry includes first is the search key the value of the indexed column the second one is a pointer or address to the actual record in the data file so where this particular actual record is stored this particular pointer tell us now when a query searches for a specific value the database uses the dense index to quickly locate the corresponding record now consider I want the details of all the student whose age is equal to 18 now although age is a non- primary key attribute but since we have indexed this particular column age it will give me the faster results so it will come to this particular index table which is a dense index it will search for 18 it has got 18 now it will go to the blog B1 it will go to the block B1 it will search in that particular block B1 wherever it fetches 18 it will take that particular data and it will return that in the final result so in this way we can search for any random data which is present in our table using the dense indexing what are the disadvantages of dense indexing so it requires significant storage space because it maintains an entry for every record in the table so since Parts indexing we were only storing the entry for each first element in the block but here we are storing the entry for each record which is present in our table consider here also we are storing only for non-unique record but again there are so many record which is getting stored here right so the storage is very intensive now coming to the next point that is maintenance overhead is there so inserting updating or deleting records require updating the dense index which can be costly in terms of performance especially for last year so consider in this particular table now Ragu has turned 20 so we have updated the value of ru's age to 20 here but we need to update it that in the index table as well because now it will be pointing to a wrong block pointer because of this these particular operations are very expensive so what what are the use cases of dense indexing first is primary indexing dense indexes are oftenly used for primary indexing when the table is small to medium size and quick access to individual records is required so whenever we want a quick access to individual records we can use this dense index because it has entry for each and every record which is present in our table now second one is exact matching queries so it is ideal for the situation where the queries frequently request for individual records based on a exact key match so whenever we want a exact key match that fetch the value of a person whose age is equal to 18 so whenever we were using sparse index we used to provide the first element of the block so we need to search for that particular block where the exact entry can happen but in dense index we can find the exact entry or exact record in the dense search key itself so we can find the exact record very easily now whenever a query is run the database engine checks the index to find the pointers to the road that contains desire data it then retrieves this rows directly without scanning the entire table so this is our index table it goes ahead and searches in our index table once it searches in our index table it goes to the block pointer where the data will be present it fetches the data and it gives us the final result rather than going to each and every block one by one we are reducing the block excess which we are doing in our hard disk now how indexing works so it takes a search key as an input and then returns a collection of all the matching records so consider if I'm searching for all the people who are having age 18 there could be multiple people who are having age as 18 so it will search for all the records where the age is 18 and it will return a collection of all the records now in index there are two columns the first one is the one which stores a duplicate of key attribute or a non-key attribute that is a search key so search key can either be a key attribute or a non-key attribute in our given table now from the table while the second one stores the pointer which holds the disk block address of the corresponding key value so in corresponding to each and every search key there are some block pointers which is stored now these particular block pointers point to the address that in our hard disk where this particular data for which we are searching is stored so in the hard disk all the data is stored in the form of blocks and we can provide the address of this particular block and this particular column so we have learned about indexing let's learn about types of indexing so there are mainly three types of indexing first one is clustered index second one is multi-level indexing and third one is non-clustered index now in clustered index we have two types of indexing first one is primary indexing and second one is clustering indexing now when primary indexing happens so when the key on which we are indexing is a prim AR key and the Order of the data is sorted we call it as primary index it basically follows the sparse indexing methods now coming to clustering index so when the key on which we are indexing is a non-key attribute but the order or the data is sorted we say that clustering index is present and this we follow the dense indexing since there is a non-key attribute which is involved but the order is sorted now coming to the multi-level indexing so whenever there is one more level of indexing in the index table we use inner and outer indexes so when whenever our database is so large or so huge the index table also becomes bombarded with entries so we perform one more level of indexing there we'll be learning about multi-level indexing in the next couple of slides so it is mostly used for large files now coming to the non-clustered index that is secondary index so whenever the key is a non-key or a key attribute and the order is unsorted so the data is not in a sorted Manner and the key on which we are performing the indexing can be a non-key or key attribute follow the secondary index there and we follow the dense index as a indexing method there now let's learn about each and every type in more depth distinguish the indexing based on the keys and non-key attribute now what they are exactly so key attribute is a unique identifier for each record it is oftenly used to distinguish one record from another so whenever we want to distinguish one record from another record consider if there are two records R1 and R2 there is a attribute which is present for R1 and R2 which can help me to distinguish between those two records so that is called as key attribute now coming to the non key attribute so all the other data in the record besides the key so all the other columns or all the other attributes beside the key attribute is called as non-key attribute now what is the single level indexing and multi-level indexing so whenever there is only one index table involved we can say that there is a single level of indexing present but whenever there are multiple index table involves like inner index outer index we can call as multi-level indexing so single level indexing is a state forward and works well for a smaller databases offering a direct approach to speeding up query performance whereas multi-level indexing is more complex but necessary for larger databases as it effectively manages large indexes by creating an additional layer of indexing thereby improving the data retrieval times so here an additional layer of indexing is created in multi-level indexing because the databases is very large and have a lot of data which is present in that so let's learn about primary index it enhances the efficiency of retrieving records by using their primary key values so here we use the primary key values of the given records now it lishes an index structure that associate primary key values with the dis block address now here this is the index structure where we provide the primary key of this particular table consider this is R number so R number would be an index and here we provide the pointers to that particular data where it is stored in this particular hard disk or in this particular blocks now this index is composed of a sorted list of primary key values with their corresponding dis block address so this is a sorted data of the primary key values and their dis block address now thereby accelerating the data retrieval by reducing the search time it is specially beneficial for queries based on primary Keys it is done on sorted data so whenever our data is sorted and we have primary key which is present in our table and whenever we want to index our primary key we use this primary index now here you can see that there is a search key and the data reference which is basically the data poed to the block which is present here and here we have a student table now in this particular student table R number is acting as a primary key so this particular data would be feeded in our hard disk so this particular table will be present in our disk for the first three records it will be stored in Block B1 for the next three records it will be stored in Block B2 and here we have provided the RW number the name and different set of data which is present in our disk now here whenever we are making the index table as I told that whenever we are using the sparse index we only provide the first element of the given Block in our index search key so here we are providing one for Block B1 and here we are providing four for Block B2 so here we have provided the address for that particular blocks now here SP index the number of Records in the index file is equal to the number of blocks so here we have two blocks so there are two entries which are present in our index table so this is our index table which creates an index structure that Maps primary key values to the dis block address so it Maps the primary key values to their corresponding dis block address let's understand from an example in a user table with user ID column as a primary key so here user ID column is the primary key a primary index on user ID can allow for quick retrieval of user records when you know the user ID so whenever we know the user ID we don't need to go ahead and search for each and every block for that particular user ID rather what we will do is we will go to the index table and when we know the user ID we'll search in the search key and wherever we find the block pointer corresponding to that we'll go to that particular block and bring that block in our memory and search for that particular values and get the details easily so primary index ensures that the database can immediately locate the row associated with a given user ID making operations like select update delete highly efficient so it make these operations like select update and delete when we know the user ID highly efficient now the next one in clustered index is clustering index so clustering index is generally done on a non-key attribute so whenever there is a non-key attribute as well as the data is sorted we use the clustered index so the data in the table is typically ordered according to the order defined by the cluster index mostly each index entry points directly to a row it is mostly used whenever we are grouping the data it is physically ordering the records in a table based on the index column so what happens here is ke consider this is the column H which is a non-key attribute but the data which is present in our age is sorted we can use this cluster index now in this particular non key attribute we can see that the data is sorted and age is a non-key attribute because of that we can see that there are some duplicate data which is also present now this particular table will be present in a hard disk so first three records would be present in Block B1 and then the next three records will be present in Block B2 now here we have provided the age on which we are doing the indexing which is a non key attribute so age here is 18 18 19 20 20 21 now here we'll be doing a dense indexing because here we can see that the data is sorted but there is a duplicate data as well as it is a non key attribute so we need to do a dense indexing here now in the dense indexing what we will do is we will only provide the entry for The Unique non key attributes we won't go ahead and provide entry ENT for 18 two times 19 one time again 22 times we'll only provide for The Unique entry so number of Records in the index file will be equal to number of blocks of unique non key records so here we have gone to the search key here we have provided the entry for 18 then 19 then 20 and then 21 and here we have provided the block pointers for that particular data which is present in our hard disk so whenever we want to search based on an ony column consider that I want the details of all my students whose age is 19 so what it will do is it will go to the index table it will search for the search key 19 it has found the 19 now it will go to the block pointer where it is present that is B1 now it will go to B1 it will search for the record 19 and then it will return either a single or the collection of data which is present in our hard disk or you can say in our blocks so let's understand from an example for a cluster index so consider that there is an employee table if you need to produce list of employees ordered by last name creating a clustered index on last name can make the queries faster so whenever there is a non key attribute there would be some duplication and whenever we want to perform any Group by operation or order by operation based on a non-key attribute we can use this cluster index because it can make the queries run faster now cluster index keeps the rows in the last name order reducing the need for the database to perform additional sorting when executing the queries now we have performed the indexing on the last name so what it will do is it will order the last name which will be present in our index table so we don't need to perform any additional sorting operations we can use the index table and we can perform the group by or the order by CL causes there it now coming to the multi-level index so multi-level index is an advanced indexing technique used in database management system to manage large indexes more efficiently so whenever there are some large indexes or there are large data which is stored in our index table we use this multi-level indexing now when a single level index becomes too large to fit into the memory multi-level indexing help us in breaking down index into multiple levels so it breaks down this particular index into multiple level so there is an outer index and there is an inner index which is present so it reduces the number of disk IO operations needed to search through the index what are the levels in the multi-level indexing first one is the first level that is primary index the first level is the original index where each entry points to a block of data or a page in the table so the first level consist of original index where each entry points to a block of data or page in the table now coming to the second level that is secondary index so if the first level index is too large to fit in the memory a second level index is introduced or created this index points to the block of first level index effectively indexing the index itself so consider that this is my index table what will happen that there will be one more level of indexing which will happen now this particular index table will be having some of the entries of this particular index table because here the data is sorted and there is a key attribute also present so we'll be following a sparse index and some of the entries will be stored here so here you can see that we are having an employee table now in this particular employee table we have employee ID and the different data of that particular employee now here the employee IDs are given and corresponding blocks of them are given here now we make the index table in that particular index table we are indexing on the basis of Eid so we'll provide this e ID in the index table and then we'll provide the pointer to that particular address where this data is stored so we'll be providing the Eid as e101 basically the first element of the block and then we'll providing the block pointer now coming to this block the first element is E1 51 so we'll provide B2 and e151 in the same way we'll provide for all the entries which is present in these blocks so here you can see that our index table is getting bombarded with a lot of entries and here I have only considered some of the data in real world there are lack and cod of data right so what we will do is we'll create a outer index and in this particular outer index what we will do is we'll group the data which is present in this index table and then for that particular group we'll provide the Eid and here the pointer to that particular group so we have divided it into groups and we have provided the first element of the group that is e101 then e201 and then e301 so for all these particular groups we have provided an entry and here we have provided a pointer to that particular entry so here you can see that we have introduced a new level of indexing and we have indexed the index table itself because the data was so large so this is how the multi-level indexing works now coming to secondary indexing so secondary indexing speeds up the searches for non-key columns in a database unlike primary indexing which uses the primary key secondary indexing focuses on other columns so whenever we have other column colums apart from primary key we can use the secondary indexing now it creates an index that Maps column values to location where the records are stored making it faster to find specific records without scanning the entire table now in the secondary index we basically work on the key as well as the non key attribute and the data is always unsorted so whenever we want to work on a data which is unsorted and it can either be a key or non-key attribute we use the secondary index so the data is mostly unsorted and it can be performed on both key and non-key attributes now here key attribute doesn't only mean the primary key there are multiple Keys which are present in our table considered primary key candidate key super key so don't ever consider that if there is a key attribute it is always a primary key it can be other attributes as well which is holding some unique values because of which we can find some data now the secondary index will be having two cases the case one is when the search key is a key attribute and data is unsorted and second is when the search key is a non-key attribute and the dat dat is also unsorted so let's learn about the first case when the search key is a key attribute and the data is unsorted so here we have selected age which is a non key attribute and the data is also unsorted here you can see 18 20 then 45 67 68 then 22 24 30 so the data is also unsorted and it is also a non key attribute so it is now stored in the blocks which is present in our hard disk let's understand that how the indexing will be done in this particular case so here we can see that AG is having unsorted data so we can use a dense index and in this particular dense index what we will do is we will provide an entry for each and every record which is present in our table we have to just make sure that that entry should be unique there shouldn't be duplicate entry which should be present in our index table there should be only unique entries which should be present so we'll go ahead and provide these particular entries in our index table but the best thing about the index table is that the index table is always sorted so it will go ahead and it will enter the data in a sorted manner so search key will be present in a sorted Manner and then there will be a data reference of the block pointers to that particular search key so here we have followed a dense indexing where the number of Records in the index file is equal to number of blocks of unique key records which is present in this particular case now coming to the next case when the search key is non-key attribute and the data is unsorted now here age is a non key attribute as well as the data is also unsorted so here you can see what is happening age is 18 18 then 20 then 67 then 22 then 22 24 and 30 here you can see that the data is also unsorted there are some dupc delate datas and it is a non key attribute now in this case how the indexing will happen so here we can see that the 22 is happening in Block pointer B1 as well as in B2 so how we will mention that in our index table so what we will do is first we will provide the entry for each and every unique non key record in our index table and whenever we find that for a unique nonke key record there is some entry which is present in B1 B2 or different blocks what we will do is we'll represent it in the form of a link list so what we will do is in the data reference column will provide B1 and then the next occurrence of this particular 22 in this particular block that is B2 so we'll provide it in a link list manner on in a lick list fashion so this is how we provide the search key which is always sorted in our index table and this is how we provide the data reference so here in the desk indexing the number of Records in the index file will be equal to the number of blocks of unique non-key records here we have discussed about almost all the types of cases when we have a key data but the data is unsorted when we have a key data but the data is sorted when we have a non key data but the data is unsorted when we have a non-key data but the data is sorted so we have discussed on all these cases now we will be discussing on how we can create indexes in our databases so how to create indexes so we can create indexing based on one column or multiple columns so let's see first we'll see that how we can create non-cluster indexes basically secondary indexes so when we want to create on one column so we give this command create index followed by a name which we provide to the index and then we provide on then the table on which we are creating the index and then the column on which we are creating the index so this is for one column on multiple column we give the same command create index followed by index name then on table name and then we provide the different columns in comma separated way so this is how we create in non-clustered indexes now when we want to remove an index we give this command drop index then the index name and then we provide on and then we provide the table name now coming to the clustered index so it automatically gets created with the primary key my SQL does does not support explicit creation of additional clustered indexes so my SQL does not support any additional creation of clustered indexes it automatically creates with the primary key itself so before starting with b and B+ trees let's just understand that why do we even need to learn about them so clustered and non-clustered indexes are Concepts that describe that how the data is stored and accessed in our database so it tells us that how the data is stored and how we can access the data but B trees and B+ trees are the data structure that actually Implement these indexes so the implementation of these indexes are done using B and B+ trees so knowing B trees gives you insight into how these indexes work under the hood so it help us to tell about the implementation of these indexes now understanding B trees helps you to understand that why certain queries perform very well and poorly based on the structure of the index So based on the structure of the index we can determine that why a given query is performing very poor or very R so for example how a b tree or balanced nature affects search times or why range queries are efficient with B tree indexes so the balanc nature of B trees help us to get our data retrieval very fast and it also help us to search for the range queries now B trees provide the balanced efficient structure that makes these type of indexes performant ensuring that the operations like search insert delete and update are done in logarithmic time so so all the crud operations like create read update and delete are performed in logarithmic type whenever we use B tree data structures as part of our indexes implementation so these makes B3 indexing crucial for optimizing database queries whether in a clustered or non-clustered index scenario so it really help us to get all those crud operations performed in the logarithmic time which is such a great time complexity and we can get our data very fast now what is this B trees so B trees is also called as a MV tree where M defines the order of the tree so we'll be learning about order of the tree next set of slides for now you can just understand that b tree also is called as MV tree where M represents the order of the tree so B tree are self balancing tree data structure that maintains sorted data and allows searches sequential excess insertion and deletion in logarithmic type so all the crud operations are performed in a logarithmic type also all Leaf nodes are at the same level in the B trees so all the leaf node or the last node are at the same level in the B trees now in B tree you can minimum have two children and maximum X children where X is the order of the given tree order is also represented using M but here I am using X for reference so X children now B tree is a generalization of a binary surge tree so if you don't know about binary surgery I'll suggest you to go ahead and have a look on what is a binary surgery because if you have a basic concept on binary search tree B tree and B+ tree would be really easy to understand now in binary search tree every node can have at most two children that is if this is a can either have zero children one children or two children in the B trees we can have at Max of X or you can say m children that is the order of the tree also here there would be only one key which would be present in each note but here there could be multiple Keys which is present in our notes now let's learn about the structure of a b tree so the first one is node a b tree is composed of nodes each containing keys and pointers to the child noes so this is a note which contains a key as well as block pointers which references to the child noes so these are the child noes and these are the block pointers which references to the child nodes along with the key we also have a data pointer now what is a data pointer so data pointer or record pointer is the one where the record is present in the secondary memory so data pointer or record pointer help us to know at what particular location our record is present in the secondary memory or the disk now the keys within a note are sorted in ascending order so all the keys which are present within a node are sorted in ascending order now root internal loads and leaves so the root node is the topmost node in the tree so the topmost node in the tree is called as a root node now coming to the second one that is internal nodes so internal nodes contain keys and the child pointers so these are the internal nodes after the root nodes which contains the key as well as the child pointers or you can say the block pointers so these are the block pointers now coming to the third one that is leaf node so Leaf node contains key and possibly point us to the record of other data so this Leaf node also contains key and the block pointers and these particular block pointers when there are no further nodes it points to the null so these are the keys which are present here and it points to the null along with the keys we have a data pointer which tells us where the record is present in our secondary memory or you can say disk now in indexing each key in a b Tre node typically represents a value or range of values an Associated pointer directs to a data block where the record is present corresponding to the key can be found so for example in a database the key might be the value in a column and the pointer might be direct location to the row or a set of rows in a given table so here we can see that all the nodes are having the same structure they are having key they are having the data pointer Associated to the key then they have a block pointer which corresponds to the address of their children's and here it is the root node after the root node all the nodes are the internal nodes and then at the last one we have the leaf node which also has key and data point now A B tree of Order X can have the maximum number of children a b tree can have is X that is the order of the tree so the maximum number of children any node can have is the x that is the order of the tree coming to the maximum number of keys so the maximum number of keys for every node is xus one now why it is x -1 so consider here the keys are provided K1 and K2 and here we have provided the block pointers so at Max I am seeing that this particular tree can have only three childrens so we'll have three block pointers 1 2 and three and here you can see that we have only provided two keys because there is three block pointers so we can say the number of block pointer is the maximum number of children the key can have or the order of the key and the number of keys is order minus one that is x - one now coming to the minimum number of keys so the root node can have minimum one key the other nodes apart from root can have ceiling of M by 2 minus 1 now what is this ceiling so ceiling tell us the upper value so consider if I'm dividing 8 by 2 so it is giving me 4 but consider I'm dividing 9 by 2 it is giving me 4.5 so it will take the upper value of 4.5 that is 5 and 5 - 1 it will give me four so whenever we want to find the minimum number of keys for root note it will always be one for other notes it would be sealing of M by 2 minus 1 now what are the minimum number of children for the root node we can have at most two children for the leaf node we won't be having any children because Leaf node is the last node in the tree and coming to the internal node we will be having sealing of M by 2 this is the minimum number of children uh internal node can have Leaf node will be having zero and root node will be having two the minimum number of keys in the root node would be one that is there would be only one minimum number of key the other nodes can have ceiling of M by 2 - 1 the maximum number of keys every node can have is x - 1 where X is the order of the so insertion in B tree always happens from the leaf node so you have to make sure that whenever you are inserting any value in the B tree it always happens from the leaf node it doesn't happens from the root node so we have to insert the value only from the leaf node if it overflows the value then we push it to the internal nodes or the root node but the value insertion start from the leaf noded so let's take a node of a binary tree now in this particular node we will be having a block pointer which contains the reference to the child node then we have a key and then we have a data pointer which contains the reference for the record in the disk so what we will do is this is the note now in this particular note how many block pointers can be there so the block pointers is equal to the order of the tree so at Max the order of the tree is consider three so there will be three block pointers so here there will be a block pointer bp1 then there will be a key K1 D1 then there will be again a block pointer bp2 then there will be a key K2 D2 and then so on there will be multiple block pointers as well as key and data pointers now consider that if someone provides you the block size the block pointer size and data pointer size how you can find the order of that particular tree so this is the the block size like this particular block has a size so that is called as a block size now this is the block pointer size and this is the key as well as the data pointer you can derive the formula for the same so here m is the order of the tree and the number of block pointers depends on the order of the tree if the order of the tree is three then there will be three block pointers if the order of the tree is five there will be five block pointers so we will multiply M with PB where m is the order of the tree and PB is the block pointer size now coming to the key as well as data pointer now key and data pointer are always one less than the order of the tree because there are some block pointers and there are some keys and data pointers and keys and data pointers are always one less than the block pointer so it will be M minus one that is order minus one into K is stands for key and PD stands for the data pointer size so we will add this key and data pointer side together and then we will multiply it with M minus1 that is order minus one and that should be less than the block size so here the number of keys node with M children can have maximum of M minus one Keys number of block pointers each node has M Block pointers pointers to the child node number of data pointers each key has an Associated data pointer so there are M minus one data pointers so the data pointers and keys are always M minus one that is one less than the block pointers and the block pointers are always the maximum of the order of the tree that X or M that is the order of the tree now let's say you have a block size B of 10 2 4 bytes you have a block pointer size PB as 8 bytes you have a data pointer size PD as 12 bytes and you have a key size K as 16 bytes find the order of the tree so you have to find the order of the tree so we'll come to that formula where we will multiply order of the tree with the block pointer size that is PB that is8 then we will subtract one from the order because the key pointers and data pointers are always one less than the block pointers so that is M minus one then we will add the key pointer as well as the data pointer that is 6 + 12 and that is always less than and equal to block size that is 1024 so here we can find the order of the tree is 29 so in this way we can find the order of the tree when all these values are provided to us so what are the steps to insert values into the binary tree so first one is start at the root and recursively move down to the tree to find the appropriate Leaf node where the new value should be inserted so as I told that insertion in the binary tree always happens from the leaf node so we have to find the leaf node where we can insert the value now second one is insert the value into the leaf note in a sorted order so we have to insert the value into our Leaf note in a sorted order if the leaf node has fewer than the maximum allowed keys that is order minus one this step is simple so consider that if I have to insert 1 two and three and this is my leaf node now this particular Leaf node doesn't have any data at all so what I'll do is insert one and then I'll insert two but consider the order of this particular tree is three so the maximum number of keys which can be inserted is M minus 1 that is order minus one so 3 - 1 is 2 so we can only insert two keys at Max in the leaf node but consider that if I have to insert three also then how the insertion will happen so if the leaf note contains the maximum number of keys after the insertion it causes an overflow so what we have to do is we have to split the nodes so divide the nodes into two nodes the middle key median is pushed up to the parent node so what we'll do is we'll find the median of this that would be n by2 so we'll find n by2 and we'll find that two is the median node so it will be pushed to the parent node and then once it's pushed to the parent node it can hold two elements to the left of this particular parent node we will be having one to the right of this particular parent node we will be having three so this will be a lesser value than two and this will be a greater value than the parent node so the left half of the original node stay in the place while the right half forms a new node the insert the median into the parent if the parent node also overflows after this insertion recursively the parent node and propagate the medium up the tree so the fourth one is if the root node overflows so consider the node in which I am inserting the data and because of this I'm pushing the data to my parent node like whenever I'm inserting the data into my leaf node if the leaf node is overflowing I'm inserting or pushing the data into my parent node but consider that the parent node also overflows and the parent node is the root node then what we should do in that case so which can happen if it already has the maximum number of keys split it into two nodes and the median becomes the new root so what you have to do is you have to split it again into the two nodes and then the medium becomes the new root so we can say that this increases the height of the B Tree by one so this will increase the height of the B tree because earlier we had only two particular levels but now we have three levels so let's see that how we can create a b tree of a given order and how we can do the insertion of the values into our B tree so create a b tree of order three and insert values from 1 4 6 8 10 12 14 and 16 so the maximum number of children a tree can have is equal to the number of block pointers which is equal to the order of the tree that is order of the tree is three now coming to the maximum number of keys a given note can have that is order minus one that is 3 minus 1 so 2 so the maximum number of keys a note can have here is two and the maximum number of Childrens a note can have is three so insertion in B tree happens from the leaf node and the values are also inserted in sorted order so the element in the left of the root would be having less than the root and the element in the right of the root would be having greater than root so if this is the root and any element which is inserted in the left of the root would be having lesser value than the root and the one which is inserted into the right of the root would be having a larger value than the root so step one start at the root and recursively move down to the tree to find the appropriate Leaf node where the new value should be inserted but this is a new tree which we are creating so we will be starting from the leaf node so we have to insert the value into the leaf node in sorted order so the first value is one I've inserted one the second value is four I've inserted four so if the leaf node has fewer than the maximum allowed keys that is order minus one this step is simple so this step is simple we have inserted one we have inserted four but here it is told that the maximum number of keys a node can have is only two now we have to insert six so how can we insert six so what we will do is in the step two if the leaf note contains maximum number of keys after the insertion it causes an overflow so split the notes divide the notes into two notes the middle key that is median is pushed up to the parent note the left half of the original node stays in the place while the right half forms a new Noe so 1 and four is already inserted in my node now I have to insert six but here the maximum number of keys a node can have is two so I have to insert six so what I'll do is I'll find the medium including the six so that would be n by two because the number is odd so the median would be four so what I'll do I'll push four to the parent note and then four will be created as a parent node and in the left of four I'll be having one and in the right of four I'll be having six so this is how we split the node and we push the median of the node to the parent node so here you can see that we have created a new node that is a parent node now in this node the left of four is having one and the right of four is having six because this value should always be less than the parent node and this value should be greater than the parent node Whenever there is a overflowing which happen push the median of the node to the parent node now we have inserted Ed the median into the parent node if the parent node also overflows after this insertion recursively split the parent node and propagate the medium of the tree but here the parent node has not overflowed so now we have to follow the step two again to insert other elements so we have inserted one we have inserted four we have inserted six now we have to insert 8 8 is greater than four so it will come into the right of four so we'll insert it here after six 8 is inserted now we have to insert 10 now again the same situation is coming where we are overflowing the data so because of which what we'll do so we'll push the median to the parent node and we'll create a new node in the right to insert 10 as 10 is greater than 8 so here we have pushed it to the parent node and here we have inserted 10 so to the left of four we are having one to the right of four we are having six to the right of eight we are having 10 now we have to insert 12 so we can insert 12 to the right of the 8 because it is greater than 8 so we have inserted 12 as well now we have to insert 14 but how we will insert 14 here the data is already overflowing so we'll send the median to the parent node but now parent node is also overflowing so we have to push the median element of the parent node to the root node so what we will do is we have pushed eight here now to the left of eight we are having four now four is having 1 and six to the right of eight we are having 12 now we are having 10 as the left of 12 and 14 as the right of 12 so let's understand from here what we have done is here we have pushed 12 to One Step Above So here 12 is here and four is here now here since there were three elements again which was overflowing so we have pushed the median 8 to one more above node that is a parent node so here we have pushed eight here now to the left of eight we are having four to the right of eight we are having 12 to the left of four we are having one to the right of four we are having six to the left of 12 we are having 10 and to the right of 12 we are having 14 so in step three if root node overflows which can happen if it already has a maximum number of keys split it into two nodes and the medium becomes the new root this increases the height of the binary tree by one so here we can see that the height of binary tree was having only two levels zero and one but here the height of tree has been increased so this is how we can do an insertion in our binary trees let's learn about the deletion in the binary key so in the insertion we were saying the maximum number of keys a given note can hold but in the deletion we need to see the minimum number of keys a given note should have because consider if I delete all the values which is present in our node so it will be violating the binary key rules so we have to search for the minimum number of keys which a node can have so here we are considering a binary tree of order four so the minimum number of keys is Seal of M by 2 minus 1 that is 4 by 2 - 1 that is 2 - 1 that is 1 key so when the order is four the minimum number of keys a note can have is 1 key so let's start so the step one is begin at the root and recursively move down the tree to find the node that contains the key to be deleted so we so we'll start from root and then we will search for the key which needs to be deleted now the step two is consider the case where the key is a leaf node so we have to consider a case where we have to delete a key which is present in a leaf node so first one is simply remove the key from the leaf node so what we have to do is first we have to search for the key which we need to delete that is 10 so we'll come here and we'll see the the root is 40 and 50 so the key that is 10 will be less than 40 so we'll come in the left and here we have found the 10 now here what we have to do is we have to delete 10 but we have to make sure that the minimum number of keys remains one so is the minimum number of key remaining one after deleting 10 yes so we can simply delete 10 so if the note still has the minimum required number of keys the deletion is complete so the deletion is because it still has the minimum number of keys which is required now coming to the case two where the key is in the leaf note but there could be a possibility that if I'm deleting that particular key the node is having less than the minimum number of required keys so consider here I'm deleting 20 so if the deletion causes the node to have fewer than the minimum number of keys proceed to the borrowing or the merging step so we have to follow a borrowing or the merging step now how we can follow that so here I have to delete 20 right but if I delete 20 the minimum number of key which is needed is one that would be violated so what I'll do is if the node has a sibling with more than minimum number of keys you can borrow a key from The Sibling the parent key between the node and The Sibling moves down through the node here I have to delete 20 what I'll do is I'll find The Sibling immediate sibling of 20 so there are no siblings in the left there are some siblings in the right now I see that if the number of siblings is having more than the minimum number of keys so the minimum number of key is one and the sibling is having two keys so we can borrow one key from this particular node a can borrow a key from node B so it can maintain the minimum number of keys so this particular borrowing happens via the parent node so what happens here we are deleting something which is in the left of the parent node so we'll be picking the smallest value from the parent node so here it is 40 and 50 so we'll be picking 40 we will be giving 40 here and then we will be deleting 20 and from here since parent needs to maintain the two keys because it has borrowed from The Sibling not from the parent so from the parent we will pick up the maximum value and we will go ahead and provide it here so now it will be 4750 here is 40 because we have deleted 20 and here it is 44 so the minimum number of keys is maintained here as well and here as well so there is a borrow which has happened between these two siblings via the parent right now here you would be thinking that why we are sending the smallest value here and why we are both in the largest value here so here we are deleting from the left node of the parent so left node always contain the smallest value so from here also we will be using the smallest value so that this particular root and parent node does not have a any unbalanced or unsorted way in which the data is stored so we will give 40 here and here we will pick the largest because here we are replacing the key from the right of this particular 40 right so from the right of this particular 40 if we are replacing the value we need to pick up the highest value so we'll pick 47 and we'll put it here now consider another case that the key is again a leaf node but when we are deleting a given value or a given key it can't even borrow from The Sibling because sibling also has the minimum number of key so consider that I have to delete 40 and I can't borrow from my sibling because sibling also has the minimum number of key which is required if I borrow from The Sibling it will be short of the key right so in that case merging happens so if borrowing is not possible that is the sibling also has the minimum number of keys merging the node with a sibling happens now the key from the parent that separates the two nodes move down into a newly merged note if this causes the parent to have two few Keys repeat the boring or merging process at the parent level so what we will do here is we will merge this 40 and 44 and from the parent node which is a common between these two keys that is 40 and 44 that is 47 will come down and perform in this particular merging so it will be 40 47 and 44 and then we can go ahead and delete 40 so what happens is mer the node with the sibling the key from the parent that separates the two nodes move down in a newly merged node so it will be 50 44 47 since we need to store our data in a sorted Manner and here it will be 52 and 59 so this is how the merging happens when the sibling doesn't have more than the minimum number of keys and this is how borrowing happens when the sibling has more than the minimum number of keys now coming to the next case when the key is an internal load in the last case we saw about the leaf node in this case we'll be seeing about the internal Lo so here we have to delete 20 now 20 is an internal node here so how the deletion happens so what we do is we replace the key with its predecessor the largest key in the left sub tree or its successor the smallest key in the right sub tree so here we have to delete 20 but the minimum number of keys which is required for a given node is one so if we delete 20 it will violate the binary tree rule so how we can delete 20 when 20 is an internal node so what we will do is we'll replace the key with its predecessor or success essor so we will replace it with its predecessor or successor what is predecessor the largest key in the left sub tree so we'll go into the left sub Tre and we'll find the largest key that is 10 and 11 so we'll replace 20 with 11 and we will delete 20 here we can replace it with 11 because the minimum number of keys which is required is one so here if there is 10 the minimum number criteria is matching so delete the predecessor or successor key from the corresponding subtree so we can delete this particular key which is a predecessor or successor to the this particular 11 now if this causes an underflow the node has few Keys proceed to the borrowing and merging step so if this particular causes an underflow we have to go to that borrowing and merging step now consider if we have to delete 11 and 11 is the like minimum number of keys a note can have is only one and if we delete 11 it will violate that property so we have to do that borrowing and merging step which we discussed in the leaf node in the same way it will happen here as well now let's learn about B+ Tre so a b+3 is an extension of B tree and is commonly used in databases and file system to maintain sorted data and allow for efficient insertion deletion and search operations B+ Tre is also a balanced tree meaning all the leaf notes are at the same level so in B+ Tre also all the leaf notes are at the same level it is a balance tree basically it is an extension to the B tree now here I am saying that b+3 is an extension to the B tree then what are the common differences between B Tre and b+3 so the key difference between b+3 and B3 lies in how they store the data and how the leaf nodes are structured so there are some differences in how they store the data and how the leaf node of them are structured so the very first one is in B3 all the actual data or references to the data are stored in the leaf nodes and internal node Only Stores the key so in b+3 what was happening was every node was storing key data pointer and block pointer the block pointer points to the children the key points to the value and the data pointer points to the address where the record is present in our hard disk now in this particular D plus3 what happens is in leaf node only we stored the key and the data pointer in other internal nodes we only stored the key not the data pointer so only in the leaf node we stored the key and the data pointer and there is only one block pointer which is present per node which points to the next Leaf node which is present in this B+ tree so in B tree what used to happen was there was a key there was a data pointer there was a block pointer and this particular block pointer used to point to null when it was a leaf node but in b+3 there is key and data pointer and then there is only one block pointer per node which points to the next node which is present in this Leaf now coming to the next point in a b+3 leaf notes are linked together in a link list fashion so they are linked together in a link list fashion and they use the block pointer for the linking purpose now each Leaf node can have only one block pointer which contains the address to the next Leaf node so this is how the leaf node looks it has key it has data pointer and it has block pointer which addresses to the next Leaf node which is present in this system and it follows a link list fashion during inserting the value in b+3 a copy of the key is always stored in the leaf node as I told at the internal nodes only have the key it doesn't have the data pointers where that particular record is present in our disk all the details are present in the leaf node only so what will happen that whenever we insert any value in the B tree the leaf node always have copy of that particular node in the leaf node in a sorted manner so here if I am inserting 30 and 70 in the leaf node I'll be having a copy of 30 and 70 because in the leaf node we have the data pointers in the internal nodes we don't have any data pointers we only have key now coming to the internal load so internal load do not store data pointer only keys and the child pointers so in the B tree what used to happen was there was a key there was a data pointer and then there was a block but here what happens is in the internal node there is only key there is no data pointer which is present and there are some block pointers which points to the child nodes so this is how the internal node is designed in b+3 so this allows more keys to be stored in each internal load leading to a lower height and more efficient operation now data pointer don't needs to be stored so the amount of size which data pointer was consuming is reduced so we can go ahead and insert more number of keys in B+ tree rather than b trees and this will help us to have a less height of the tree rather than b trees now what is the structure of B plus tree so the first is root node the top node of the B plus tree which points to the first level of internal nodes or directly to the leaf nodes if the tree has only one level so this is the root node which points to the internal nodes and if there are only two levels of nodes which are present then it points to the leaf nodes now coming to the internal nodes these nodes contain only keys and pointers to the child node this node only contains key and the block pointers or you can say the pointers to the child node it doesn't contains any data pointers it only contains the key so it will be K1 K2 K3 K4 and in between there will be some block pointers for this particular children's now coming to the leaf nodes so these note contains Keys as well as data pointers so the leaf node contains Keys as well as data pointers and there is only one block pointer which is present which points to the next Leaf node enabling quick traversal of Records so all the records is present in the leaf node only if we want to search for any record we have to just go to the leaf node and Traverse the leaf node and find that particular record what are the advantages of B+ trees so B+ trees have a balanced structure meaning all the leaf nodes are at the same level so all the leaf nodes would be at the same level this balance ures that the search operations require logarithmic time relative to the number of keys making it very efficient even for the large data sets so even there are large data sets we store all the data in the leaf notes so the traversal is very easy and we can find any data insertion deletion and like reading of the data is performed in the logarithmic time now coming to the second point the structure of B+ trees allows for direct access to the data since the internal nodes contain only the keys searching for a specific value can be done quick by navigating through the tree down to the leaf node where the data is stored so in the leaf node since the data is stored and the internal nodes only have the keys the leaf node have the key as well as data pointer and it also has a block pointer which points to the next Leaf node so it help us to get the data very fast and the traversal is also very easy now B and B+ trees both are used to implement indexes in databases so B tree and B+ tree both are balanced trees but there are some differences in the structure of B and B plus trees so in B tree all the nodes have the same structure there is a block pointer which consists the address of the child node then there is a key then there is a data pointer which points to the location where data is stored in the hard disk or secondary memory you can say and again there are some block pointers now coming to B+ 3 so there is some structural differences between the internal and the leaf node now in the internal node there is a block pointer which points to the child address then the there is a key only which is present there is no data pointer which is present in the internal node but when it comes to Leaf node it has a key it has a data pointer and again it has a block pointer which points to the next element or next node which is present in the leaf so basically there is a linkless structure which is formed in the leaf and in the leaf node only you can find out the data so let's understand from an example think of a b tree as a directory structure on your computer where folders contain both name and pointers to subfolder or files so consider that there is a directory which is present in your computer now there is a folder so there would be some name for this particular folder so this is the key of this particular folder now in this particular folder there would be one more folder or you can say child folder so we can say that this is the child folder now this particular folder is considered to be a node now this particular node is containing the key as well as the block pointer or you can say the pointer to the child which is present here so this contains the node as well as keys and pointers to the subfolders or the child folders now coming to b+g so imagine a library catalog where all book records are listed in a sorted link list manner which is leaf notes and the internal notes only contain pointers to guide you to the right part of the catalog so consider I want some books in The Comedy section so I'll go to this comedy section now in this particular comedy section I can get some books which are sorted in the link list manner so this particular comedy section is helping me to find out where all the books would be present and here I can find the books which would be present in the list manner so I can say that this is the leaf node and this one is acting as a internal node because it is telling me that where exactly these particular things are present now coming to the basic differences so the first one is data storage so keys and Associated pointers to the data are stored in all the notes so in B tree keys and Associated pointers are stored in all the notes in internal as well as Leaf node but coming to B+ trees all the actual data is stored only in the leaf node so the data pointer is only stored in the leaf node and internal nodes only contains keys and pointers to the child node so internal node we have only Keys as well as pointers to the child node so this is the block point that points to the child node so we can see that in B Tre all the nodes has the data pointers which is present but in B+ 3 the data pointers are only present in the leaf node now coming to the next point that is leaf node linking so there is no inherit link structure which is present between the leaf node so there is no link structure which is present between the leaf nodes in the B trees but coming to B+ trees leaf node are linked together in a link list manner this linkless structure allows for efficient sequential excess making range queries faster and easier since all the data is present in the leaf node we can start our searching from the leaf node and all the leaf nodes are interconnected with each other which has key and data pointer so it would be very easy to search for the data which is present in the leaf node so searching would be very first now coming to the search performance so excess time can be slower for certain type of queries because you may need to Traverse multiple level of trees to find the data so in B tree what happens consider if this is a b tree which is having some internal and some child nodes here consider if I want to search for a data there might be a possibility that I need to Traverse the entire data set which is present in this particular tree but in B+ tree what happens that since all the data is stored in the leaf node only we need to only Traverse this particular Leaf Noe or the link list structure which is formed at that particular Leaf node so Leaf nodes are linked together in b+g allowing for efficient sequential excess and range queries so it is very helpful for range queries because we need to only Traverse the link list which is present at the end of the tree now coming to the space utilization so since data is stored throughout the tree be trees might have lower space utilization in the nodes so since data is stored everywhere there would be very less space utilization because in a node you need to reserve a space for a key pointer then the data pointer and then the block pointer the storage of key and data pointers in a given node would be very less now coming to b+3 so b+3 typically have better space utilization because internal nodes are only used for Keys allowing more keys to be stored per note so here you have to store Key data pointer block pointer but in B+ T what happens you have to only store a key and then there are block pointer so since the data pointer is not stored here the size of the data pointer which is getting occupied here in the note which won't be needed here so here we can store more number of keys because there are no data pointers but here since we have a data pointer Associated to a key there is very less space and very less Keys which can be stored in a given note so these are some of the basic differences between B and B+ 3 oftenly B plus Tre is mostly used in some of the cases because the search performance is very good we can use it for the range queries again the way in which the data is stored is also very optimal because you only need to go to the last or the leaf node and search for your particular data rather than traversing the entire so the very first question which would be coming to your mind is why do we even need to scale our databases what is the use case behind it so let's just understand a normal architecture or a process of user sending a request to access the data present on the internet so right now we are having a device that could either be your PCS mobile or any computers now from this particular device you go to the browser you make a request consider www.fb.com google.com or anything so here we have taken www.example.com now whenever you provide this particular URL just to get the data from the server what we do is we need to provide the IP address so we need to fetch the IP address of this particular URL so how we can fish the IP address so if this particular URL has been hit by the browser like in the previous times or if the data is saved in the cash first we do a lookup on the cach and if it is present we provide that particular IP address if it's not present then we do a DNS lookup so it will check in the cache of the browser as well as operating system if the IP address corresponding to this URL is present or not if it's present it will return the IP address here and then device will take the IP address and do a connection with the server and fetch all the details but if the IP address is not present it will do a DNS lookup that is a domain name server lookup so it will pick the domain name and then it will provide the particular IP address so here we have got the IP address now using this IP address we make a request to the server because whenever we are accessing any website all the details like databases backend functionality static content Dynamic content relies in the server itself so we need to make a connection to the server and then send a request to the server so first we'll try to establish a connection with the server using the TCP and IP protocols once we have established a connection with the server we'll pick the IP address and we will send a request to the server now server is having databases static content Dynamic content which is basically the backend functionalities so server will process the request and then gives away the response in the form of HTTP status code along with the content now that particular content would be rendered and then it will be shown in our device now this is how the normal AR architecture of a user sending a request and then fetching the details works so as the data increases or the number of user increases the server also needs to increase its storage space so because of that reason what we do is the database which was present earlier in the server is now decoupled and made as a all alone entity so now we have a database as a all alone entity so now if the storage increases that could be accommodated in the databases so the request which is made by the user from the device will go to the server server will make the same request to the database as all the data which was present inside the server is now present in the database so all the request has went to this particular database and now this particular database will give me the result and server will give me the response again if you see this particular architecture consider if there is any crash which has happened at the server we won't be able to get the results right because there could be multiple users who are making the request and server can't handle that much load so there could be a crash in the server there could be also a crash in the database then again we won't be able to fetch our so this particular system is not scalable because if there are more number of users who are coming and making request we need to accommodate that request right we can't say that the server has crashed or the database has crashed that is a bad user experience so this system is not scalable as the number of user grows it will require the scalability in our systems so that is why scalability is needed so how we can scale our databases so there are two types of scaling first one is a vertical scaling and second one is a horizontal scaling now what happens in vertical scaling so in vertical scaling if there are one server right now server S1 is present so what it will do is it will increase the number of CPUs as well as RAM of this particular server so that it can accommodate more number of request so this is what happens in the vertical scaling but there is a extent to which we can increase the number of CPUs or number of Rams in our system that is why vertical scaling is mostly used in small businesses or where the traffic is not very much coming to horizontal scaling so if there was one server earlier in horizontal scaling we make more number of servers so there are more number of servers or instances which are made so consider if one server fails what will happen the other server will accommodate the request so in horizontal scaling we increase the number of servers or number of instances in vertical scaling we increase the CPUs sces or Rams so that it can accommodate more number of request but only to a certain extent so now coming back to the last example which we discussed so there was a device now in the device we open the browser we provide the URL which we want to fetch or the website which we want to fetch then for that particular URL we need the IP address so that we can go ahead and ask the server for the details for the IP address first we need to check in the cachier of our browser or operating system if the IP address is present if it is present we will return the IP address and then that particular IP address will be used to establish a connection with the server and get the details if the IP address is not present in the cache we used to do a DNS lookup that is domain name server lookup from here we get the IP address now the device using the IP address first will try to establish a connection with the server using TCP and IP protocols then we'll send away the request to the server now in the last example what was happening was if there is only one server which was present and if there are more number of requests which is coming to that particular server there could be a possibility that server won't be able to accommodate that particular load or that particular users so because of which there could be a server crash or failure so just to accommodate that we are doing a scaling of the server so now scaling we are doing the horizontal scaling so here we have horizontally scaled the server now there are three server S1 S2 and S3 in which what we have done is we have increased the server using the horizontal scaling so now the server have been increased so we can see now the crashing is accommodated here because even if one server crashes we have multiple other servers to accommodate the request but now user is sending the request there could be multiple request R1 R2 R3 by different user so how's the server will know or how the user will know that which particular server will be accommodating the request so for this we have a load balancer coming into picture now what the load balancer does is if there is any load which is coming to the server it will go ahead and see in which particular server the load is the least or which particular server has the less number of request it will just go ahead and accommodate that particular request to that particular server which is having the Lesser load so it just balances the load between the servers like if there are huge load which is coming to our website it will just go ahead and balance that particular load in different server so that the server crashing doesn't happens so we have used the load balancer here which can balance the request which is sent to our server so send request to the server having lesser load so that that is what load balancer does now we have sent the request to the server and load balancer is taking care of all the request but here earlier we had only one database now consider there could be a possibility that that particular database also crashes so for that reason also we need to do a database scaling so for that particular database scaling again we'll be using a horizontal scaling so we will be scaling our databases so that it can accommodate more number of request and even if one database crashes or fails there would be more number of database to accommodate the request now the scaling in databases happen in a different way what way it happens so basically it happens in a data replication way where in the database we have a master database and then a slave database so this is a master database or this you can call it as a slave or you can say agent database now the master database handle all the right operation with is coming like if someone is creating account signing in signing up so all the right request are coming to this particular Master database and in the agent of the slave database we accommodate all the read operations so we have two databases mostly one is Master database one is Agent or the slave database in agent database we accommodate all the read request in master database we accommodate all the write request now there is only one master database which is present in the scalable system but there could be multiple slave databases or the agent databases so here we have one master database and then there are two slave database now what happens if this particular Master database crashes so there are certain algorithms which make one of the slave database as the master database Whenever there is a crash in the master database now here we have a master database and slave databases Master uh accommodates all the write request and slave accommodates all the read request now how we will know that which particular request which is coming to our system will be going to which particular slave database because there are two slave database so if there is any read request coming how we will know that which particular request will be going to which particular database so again here also we introduce the concept of load balancer which tells that this particular request will be going to this particular slave database now this is how we are scaling our system all the crashes or the server failures or the database failures which can happen is accommodated now but you know that if we are just querying into our database it takes a lot of time and it is very expensive like a request is coming then it is going to the server server is making a query to the database so that takes a lot of response time and that is very expensive operation because of which we introduce caching so what caching does is caching reduces the response time because here we store uh the values in the format of key and value pair what will happen that whenever a device is making a request to the server server will first go ahead and search in the cache if the data is present because for some of the frequently used queries we can just go ah and cach that particular data because every time that query is made that particular data needs to be sent so it will go at and search if in the cache the data is present or not if it is present it will here only return the response and that will be rendered and shown in the device if it's not present then only it will go to the database and make a query and that particular data will be going to the cache and then we can see in the response so in this way we scale our system so that there are no crash no failures it can accommodate more number of user request and we can get our desired results in desired duration of time so this is how we can scale our system from zero to you can say lck or million of users now in the user Journey what happened first was the user action sending a request second was the browser passes the URL third was a DNS lookup to get the IP address fourth was establishing a connection with the server fifth was sending the HTTP request to the server sixth was server is processing the request seventh was browser receives the response eighth was displaying the web page and Ninth was caching the data so in this way the user Journey happens now the user sends a request by entering the URL or clicking a link the browser then translates the domain name into IP address through DNS lookup establishes a connection with the server sends an HTTP request and receives the response so this is how the user Journey was happening now the browser then processes this response renders the web page and display it to the user so we get the static and dynamic content from the server now it gets to be rendered and then it is displayed to the user the process involves multiple layers of networking data transfer and client and server interaction all working together to deliver the desired content to the user screen so everything works together and we get the desired result on our screen now scaling in database is a crucial Topic in development mostly when the application grows and the volume of data increases so whenever the application grows the volume of data increases or the number of user increases it's best to scale our system now there are some scaling techniques which are present first one is vertical scaling that is scaling up second one is horizontal scaling that is scaling out third is database partitioning fourth is replication fifth is sharding sixth is caching and seventh is load balancing so let's learn about each and every one of them in depth so the first one is vertical scaling as discussed in the last slides that what we do in the vertical scaling is we increase the CPU as well as the ram of our server so that it can accommodate more number of request but there is a extent to which only we can increase our CPUs as well as RAM so if there is a server we increase the capacity of instances of RAM and CPU so so that it can accommodate more number of request but only till a certain extent so vertical scaling involves increasing the capacity of single database server now in vertical scaling how we can vertically scale our system so first one is adding more resources so upgrading the server by adding more RAM faster processors or larger or quicker storage so whenever we add more RAM faster processor or larger or quicker storage we can scale our system this helps the server to handle more number of request and store more data now coming to the next pointer that is improving performance so tweaking the database settings optimizing queries and indexing the tables to make the better use of Hardware so we can tweak the database settings optimize our queries and index our tables to make the better use of our Hardware now coming to the third point that is upgrading to a stronger machine so moving the database to a more powerful server like switching from a regular server to a high performance Cloud instance so whenever we switch to a high performance Cloud instant we can do the vertical scaling and we can get our data very fastly and very quickly now why vertical scaling is also called a scaling up because here we increase the more number of CPUs as well as RAM so we scale up our system or the same server only in which we are increasing the number of CPUs as well as RAM now what are the advantages of vertical scaling so it is easy to set up because it usually doesn't need changes to the app or the database structure so we don't need to do any changes to the app or the database structure we only need to increase the CPUs as well as RAM so it is easy to set up now coming to the next point it is simple to manage since everything is kept on one server so since everything is present only on the one server we can easily manage each and everything we don't need to go to different servers to manage different things now coming to disadvantages first one is limited by the hardware maximum capacity as I told that there is only one certain extent to which you can increase the CPUs as well as RAM so there is a limitation now coming to the second point so it is expensive as highend Hardware can be costly so highend Hardware can be very costly because of which it is also very expensive now coming to the third point that is single point of failure so since there is only one server in which we are increasing the CPUs as well as RAM what if the server fails all the system will be go down right so if the server fails the entire database goes offline so if the server fails the entire database goes offline and we won't be able to process the request of different users and it will be resulting into multiple 500s or server not form now coming to the next one that is horizontal scaling which is also called as scaling out because here we are not scaling the resources of the server rather we are scaling the server so if there is one server earlier we are adding more instances or more servers after scaling so if this is server one server 2 server 3 and server 4 so horizontal scaling involves spreading the database workload across multiple server so whenever we spread the database load across multiple server we call this as horizontal scaling in terms of databases now this can be done in different ways first one is database replication replication is the process of copying the data from one server Master to one or more backup servers that is slave so I told earlier that in the database replication we deal with the Master Slave or you can say master agent architecture where mostly Master handles all the right operations and the slaves or the agent handles all the read operations so here Master Slave replication the master server manages all the right operations while the read operations are distributed among the slave servers or you can say agent servers so this setup improves the read performance and provides rency so it help us in improving the read performance of our system because there are multiple slave databases which is present or agent databases which is present which can handle multiple requests which is coming to our server that is read request now coming to the next one that is multimaster replication which is also a part of database replication in this multiple server handle both read as well as write operations increasing avability and the right capacity so here multiple server handles both read as well as write operation so that it can increase the avability as well as the right capacity so however it also introduces challenges in managing conflicts so since if the multiple server are handling read as well as write operation there could be some conflicts such as dirty read where read and write write read WR WR conflicts are occurring so because of this multimaster application there could be some conflicts which can arise in Master Slave replication basically there is a master which handles all the right operation and there is a slave which handle all the read operations in our database now coming to database sharding now what we do in database sharding so consider if there is one database which is present here which is having a table T now this particular table T is divided into different sharts so it divides the data between multiple tables in different database instances so now T is broken down into T1 T2 and T3 and all these table relies in different database Shard that is D1 D2 and D3 so it divides the data between multiple tables in different database instances so sharding involves partitioning the database into smaller more manageable pieces shart with each shart stored on a separate server so the database is divided into different charts D1 D2 and D3 which is having different tables T1 T2 and T3 which is having all the data which is present in the table T so there are two ways in which we can do the sharding first one is range based sharding in which the data is divided based on the range of a particular key such as data or user ID so if there is a key which is present on that particular key we will uh decide the range on which the data should be divided into different table like 1 to five is going to this table 5 to 10 is going to T2 then 10 to 15 is going to T3 so on the basis of range we divide the data among different tables now coming to the hash based charting so hash function is applied to the key example user ID to determine which chart the data should go to so we apply the hash function on the basis of user ID or user key so that we can decide that in which particular Shard which particular data should go into now coming to the next way that is caching now what happens in caching is we store the data of the most frequently Asked queries so it implements the caching layer to store frequently accessed data in the memory reducing the load on the database so we reduce the load on the database because consider if someone is accessing netflix.com and if someone is going to the movie stab so this is something which is happening like each and every time when someone is logging in so what we do is for that particular operation we store that particular data into our cache so that there is no DB operation which is happening because DB operation can take a lot of response time and is also very expensive while if we use caching we can get it in in very lesser response time now coming to the next one that is load balancing so distribute the database queries across multiple server using load balancer to prevent any single server from becoming a bottleneck so what the load balancer does is if there are multiple requests which are coming into our system R1 R2 R3 load balancer decides that which particular request will go to which particular server so that there is no one particular server which is being a bottleneck for anything so it decides that which particular request will be going to which particular server now coming to the next way that is partitioning so it divides the large table into smaller partition that can be queried independently improving the query performance so what happens that if there is a database server in that particular database server if we have a table T it will divide this particular table into different partition that is T1 T2 T3 in the same database server so that that particular smaller partition can be queried independently so it divides the data which is present in this particular T table into multiple table in the same DB instance so it divides the data which is present in this particular T table into multiple table into the same DB instance so that we have smaller partitions of table and the queries can result in a faster duration of time so this is how we can scale our databases now role based access control is a security system that controls that who can access a database or system based on their role in the organization So based on the specific role in a given organization we provide some excess control to the users now consider that there is is a team which is working on making ID cards for the employees now for that they will need the details of the employees like first name last name and different things so we provide an access to the database to this particular team now consider that this particular team is doing some read operations on the database that is okay because they need some user details but consider if this particular team is doing some right access or doing some modification in the database that is not allowed because this is a security breach so for that particular reason only we provide some exess so instead of giving permissions directly to each user the system creates role with the specific permission and user are assigned according to these roles now for example a database administrator might create roles like DB read for reading the data and DB write for modifying the data only people with the right role can read and change the information so we'll provide a DB read to this particular team so that it can read the details which is present in our database but we won't be providing access for the DB right now what is role so it is basically a set of permission which is associated with a job function example there could be admin there could be a manager there could be a developer in different organization so according to their job function we provide a different role to different users now coming to the permissions so these are the rights that are granted to perform certain actions such as read operation write operation delete operation so whenever we provide some rights to certain users to perform some certain actions like read operation write operation delete operation we give them permissions now now coming to users these are the individuals who are assigned one or more roles now coming to the advantages so it makes it easier to manage permissions especially in big systems so whenever we want to manage permissions especially in bigger systems or bigger mnc's we can use rbac now coming to the next pointer it lowers the risk of misuse by making sure users only have access to what they need for their role so if there are two user user one and user two if I've given the access for DB read user one can only perform read operations if if I have given the user to as DB read as well as DB write it can go ahead and do some modification as well as read the data so according to the role they are able to use the data they can't go ahead and misuse any data now coming to the third pointer that is it improves the security and help keep rules consistent across the system so it help us to increase the system security encryption in databases refers to the process of converting the data into a secure format that can only be read or accessed by someone with the correct encryption key so what we do is if there is a data D1 which is present in our system we will encrypt this particular data into a secure format like there would be some stars there would be some a b c there would be some equal to like some special characters some alphabet mixture of everything so we'll encrypt this particular data and then the person who is having the correct decryption key can only go ahead and decrypt this data and read this particular D1 so this is what encryption in database means so this helps in protecting sensitive information from the unauthorized exess since we have encrypted our data any person who is having the decryption key can only go ahead and read the actual data otherwise the person will be seeing the special characters and alphabet combination which doesn't makes any sense so we are securing our data from any unauthorized access or any hackers so for example an MNC might use encryption to protect their records in their database even if a hacker gains access to the database they wouldn't be able to read the data without the decryption key so even if the hacker have the access it will be only able to read this particular data not this data because this data needs the decryption key and which should be a correct decryption key now what are the types of encryption first one is at rest second one is in transit third one is column level and fourth one is full disk so let's learn about each and every one of them so first one is ADD rest encryption so add rest encryption protects the data stored in the database by encrypting it whenever it saved to the disk so whenever we are saving our database to the given disk or you can say secondary memory it encrypts the data whenever we are saving the database at that particular time only it encrypts the data this means that if someone gains access to the physical storage or the database files they won't be able to read the data without the encryption key so since while saving the data which is present in our database in the disk we are encrypting the data anyone who gains the access to our disk or our physical storage won't be able to read the data because the data which is stored in the disk is in encrypted format so examp example a Company encrypts employee salary record stored in their database if someone accesses the database files directly they see encrypted data like XY Z 1 2 3 at the rate hash instead of the actual salary figures so whenever we are storing the salary data in our disk we will encrypt that particular data so whenever someone tries to access this particular data they will be seeing this particular data not the real data because that requires a decryption key now coming to the next one that is in transit encryption so in Transit encryption secures data as it moves between the database and the applications or the user so whenever there is a fetching of data from the database which is happening by a user it tries to encrypt the data that time only so this is typically done using secure communication protocols like SSL TLS to prevents the E dropping or the tampering during the data transmission so for example when you send an email in transit encryption ensures that the email content is scrambled while driving to the recip server so whenever a user one is going to send a email to user so this particular data is encrypted while traveling from user one to user to or sender to recipent so even if it is intercepted it appears as a random characters like this and that is unreadable coming to the next one that is column level encryption so column level encryption encrypts specific columns within the database this is used when only certain pieces of data like credit card numbers or social security numbers needs to be protected leaving the rest of the data un encrypted for easier access so whenever you want to encrypt some highly valuable data which is present in our database you use this column level encryption because column level encryption only does encryption on some specific columns which is having some highly valuable data so for example a database holds user information with a column for Social Security numbers that is SSN this column is encrypted so an SSN like 1 2 3 4 5 6 7 8 9 might be stored at this particular way in in the database so that if anyone access this particular column they will be able to see this special characters and need a decryption key so that this particular data will be encrypted this is used whenever you want to encrypt some special column which is having highly valuable or highly risky data coming to the last one that is full disk encryption so full disk encryption encrypts the entire disk where the database is stored this ensure that all the data that is stored on the disc is protected not just the database but any files logs or backups stored on that particular disk so what we do do here is we encrypt the entire disk which is having the database some transaction logs some backup files so that if anyone has any access to the disk he or she won't be able to see anything like the database the transaction logs or any files which is present in the disk so for example a laptop which is used by an employee is encrypted if the laptop is stolen the entire disk is protected so whenever our laptop gets sto we can be assured that our entire disk is encrypted so no one can go ahead and access the data so and the thief would be only able to see encrypted data like this one instead of the readable files so if the thief who has stolen our laptop would be able to only see the data like this which is in an encrypted format and the thief won't be having the decryption key that will be only available with the user so he or she won't be able to fetch anything from our laptop so what are some of the common data masking technique and what exactly data masking is so data masking means hiding or changing sensitive information so it's protected from unauthorized exess this allows the data to be used for things like testing analytics or training without exposing the real data the goal is to create a data that looks real but isn't actually the original information now for example a bank needs to train it machine learning model to detect the fraudulent transactions to protect customers personal information the bank uses data masking to replace the real account numbers and transaction details with fake but realistic looking data so what we do is we replace the account numbers and transaction details with some fake data but that is some kind of a realistic data that is not the original data or that data which will be coming whenever we are doing a get query on our database which is present in the bank but that is kind of a fake data which is giving us a realistic look but that is not the original data so this way the models can be trained effectively without risking the exposure of actual customer data so consider if there is a ml model which we want to train now here we won't be providing the real data right we can't expose the real data to any machine learning models or any of the apis so what we do is we give some fake data which looks like a original data and on basis of this data we train this particular model so that whenever this particular model is implemented in real life scenario and whenever there is a original data which is coming to this particular model it acts in a way in which we want now coming to some of the common data masking techniques so first one is substitution so replacing sensitive data with random but realistic looking values for example swapping real names with random names from a list so what we have is we have a names list which is having all the real names which is present in our database so this is having all the real names which is present in our database but I want to do some API testing for which I need the names but I can't use the real names so what I'll do is I'll create a random list which is having some random names so we can use this random names for the API testing rather than the real names so for example a company's employee database containing social security number that is SSN to mask these the company replaces the real SSN with randomly generated fake SSN so consider if I have this particular SSN which is present in my database and for testing I want a SSN so what I'll do is I'll replace this real SSN with some fake SSN and I'll substitute some of the values from this real SSN with some random values so what I'll do here is this is my real SSN which is present and now I have to make some realistic or you can say a fake exis so that I can use this for testing so I'll substitute some of the values consider at two I am giving some random value n in three I'm giving some random value eight in four I'm giving some random value zero in five I'm giving some random value six so in this way I'll substitute it with some random values and create a fake xsn which can be used for my testing now coming to the next one that is shuffling so rearranging the values within a column so that the data remains realistic but it's not link to the original records so in substitution what we were doing is if we had any value which is present in our database considered that this was a SSN number which is present in my database I was substituting some of the values with some random values so here I was substituting consider one with any random value 9 two with any random value eight three as it is then four with any random value one five with any random value three then one then one with any random value zero and one so in this way I was creating a random but original looking data in shuffling what it says is consider if we have two columns name and phone number now for a particular name reti we had a phone number 1 123 for Raj we had 456 and for Rahul we had 890 now what we will do is we will Shuffle the phone number in the column which is present so that consider right now I have shuffled so now RTI is having 456 Raj is having 890 and Rahul is having having 1 2 3 so we have shuffled the data and now this particular data we can use because 456 is linked with Raj but right now I'm using 456 for reti so now for reti 456 is a random value so consider example a hospital has a list of patients with their birth dates to protect privacy the hospital shuffles the birth date among the patients for instance patient a birth date was 115 1990 which might be swapped with patient B's birth date that is 722 1985 so what we had done is if there are patient records which is present in my patient table I'm Shuffling the birth date of some specific patient to protect the Privacy so that other people can't come ahead and access my real name my real birth date and different things so we are just shuffling the data between the records which is present in our table now coming to the third one that is encryption so encrypting a data so that it is unreadable without the decryption key so we can encrypt the data so that it is unreadable without the decryption key now this can be used in the form of masking if the data does not needs to be human rable so for example a retail company encrypts credit card number in its database a number like 41111 might be encrypted to something like this one which is having some random characters alphabets uh special characters and much more things which can't be read without the decryption key so once we have the decryption key only then we can read this data now coming to the next one that is nulling out so replacing some sensitive data with null values or placeholders like X this can remove the original data but may reduce the usefulness of the data set so consider that I have my first name as reti Kumari so what I'll do is I'll use this reti here but I want to do some nulling out of the last name so I'll provide KU and then x x x x for the number of characters which is left so example an HR department wants to share employee records for analysis but needs to hide the salary information they replace the salary field with the null values or placeholders like xxxxx so in this way we can hide the salary information and can display the other details now coming to the next one that is number variance so altering numeric data by adding or subtracting a random value with a certain range so whenever we want to alter the data by adding or subtracting some value of a given certain range we use this number variance for example changing salary figur slightly to mask the data for the exact amounts so for example a finance department needs to protect the exact sales figure but still wants to share the data for the trend analysis they slightly alter the figures by adding or Contracting a small random amount for example a sales figure of $10,000 might be changed to $10,200 or $998 so that we are able to analyze the trends but we are able to mask the data as well we are not showing the original or the real data now coming to the next technique that is tokenization so tokenization is a technique used to replace sensitive data with non-sensitive equivalents called as token so what we do is consider if we have a credit card so we have some numbers 4 5 1 6 3 3 26 1 2 41 considered that this is a credit card number so what we will do is we will give some tokens for some of the digits of this credit card number so these tokens can be stored or processed without exposing the original sensitive data while maintaining a mapping to the original values when needed so whenever we want to maintain the mapping to the original values like consider that these particular values are replaced by the token and we want to know that what are the original values for that particular token so that is stored in a token vault so there will be a token and then the particular value for that particular token so example imagine a database that store customer credit card information to protect the sensitive data tokenization can be applied each original credit card number is replaced with a unique token consider TK nxy z123 now these tokens have no meaningful relationship to the actual credit card numbers so these tokens doesn't have any meaningful relationship with the actual numbers of the credit card but we provide this tokenization so that we can maskers sensitive information so this was all about common database masking techniques I hope you like this video so if you like this video please hit the like button if you're someone who is new to my channel can go ahead and watch out the tech content first and if you find it useful can go ahead and subscribe also if you have not followed me on my social media handles you can go ahead and follow the links are in the description till then take care keep learning keep growing keep smiling bye all