hi everyone good morning in this lecture we will study normal forms and also type of functional dependencies so let's start now so uh first of all let me tell you what is the source of this lecture uh what are the standard resources that we are following for this lecture so we will follow cod's original research paper okay so I told you that this relation algebra was given by cord right this this we have already SE this relational model this relational data model OKAY relational model or I can say relational data model so this relational model this was proposed by cord this relational model okay so this was proposed by cord proposed by code okay and one more thing that actually this code he wrote several research papers back to back okay so basically he wrote a series of research papers he wrote series of papers series of research papers so series of research papers he wrote in this series of research papers basically the first paper was about relational algebra uh about relational model the first was about relational model okay so in the first paper he he wrote All About relation model like everything that we know like like for example uh in relation model data is represented as a table okay you have rows you have columns you have domain you have uh key you have primary key candidate key Super Key okay so all the concepts the concept of null so basically every concept that we have seen in relational model those Concepts were described in this this paper okay in the first paper in the first paper all the concepts were described like Integrity constants okay like uh entity Integrity constant reference Integrity constant okay domain Integrity constant key key Integrity constant uh okay so these concept all these Concepts were described by this code by e code in this research paper in the first research paper then in the second research paper he described some more Concepts like normal forms okay so this normal form this concept was also described okay so like this so basically these Concepts like uh in this paper he gave the concept of normalization he gave the concept of he gave the concept of 1 NF 2 NF 3 NF 4 NF uh sorry uh not sorry 3 NF and okay so these these Concepts were given in this research paper Okay 1 NF 2 NF 3 NF okay these Concepts were given also in this uh in this same research paper these Concepts were also given like uh what is a partial dependency what is a what is a fun transitive dependency okay so what is a transitive f what is partial FD so these Concepts were also given we will study so all these Concepts we will study now in this lecture now let me tell you one thing so you can notice this was C's original research paper so we I will give you the screenshot of this paper okay for many uh for many Concepts like when we study partial dependency uh then I will give you the screenshot of the research paper uh original research paper uh like where this is defined similarly when we stud 2 NF I will give you the screenshot of the research paper where this is defined okay anyway so now let's move on so you can not this is the research paper this is by code this is the original research paper by code on uh on the normalization on normalization this was the paper okay so you can uh you can read all the concepts that we have already seen like we have seen the concept of functional dependency right so this is the con functional dependency concept was given by cord okay so this functional dependency concept it was given by code in this paper bcnf was not given in this paper bcnf was given in a in another paper in another paper bcnf was given in another paper Okay so there was another paper for bcnf okay anyway so there was another paper for bcnf okay anyway so basically you can notice the the concept of functional dependency we have already seen the concept of trivial dependency concept of functional dependency so these definitions these Concepts we have already seen now let's move on for example this concept we have seen right in entity Integrity constant right yes or no what is entity Integrity constant tell me what is entity Integrity constant what is that that is basically that in relational model every every table must have primary key yes or no in relational model in the relational model every table every relation must have primary key and this primary key cannot be null okay this primary key so one of the candidate key is chosen as primary key I told you okay so you can notice for every relation for each relation what we do so here you can notice that for each relation in the database one of the candidate key we choose we choose as a primary key and what is the difference what is the major difference between candidate keys and primary key what is that the major difference is that basically this primary key cannot be null okay this primary key cannot be you can notice that Nole is allowed to have undefined value for any primary key component okay Nole can have null value for no notle can have null value for any of the primary key attribute the other attributes the other attributes can have null value the other attributes can have null value but primary key attribute should not have null value okay so you can notice this was given by who gave this concept tell me who gave this entity Integrity constant who gave this so okay code gave this so you can notice this is the screenshot from the original paper of code okay this is the screenshot from the original paper of Corde okay about primary key about entity Integrity constant so every relation must have primary key and this primary key is basically one of the candidate key and this primary key cannot have null value okay very simple now let's move on now let's uh so let me tell you in this the all the sources of this lecture in this for this lecture we will follow we will see the I will put the screenshot of this original paper you can read of course what you can do after the class you can read those lecture notes that's what we do right okay so after the class you can read the lecture notes and in the lecture notes you can read the a screenshot of this code original paper also we will follow the nawate book The cor book and some University articles okay so this is the source for this secture now let's move now why I'm answering this a lot of sources like before starting the lecture why I mentioning this a lot of standard resources what is the reason the reason is this that whatever we study in this lecture many students many many many actually majority of gate asirs they have misconceptions in the many in many Topics in this lecture is this clear so many gate experience they are learning for the last many years for the last I can say maybe 20 years okay so for the last many years every year every year gate experience they are learning wrong Concepts misconceptions okay so in this normalization so we are going to learn it all and we are going we are going to learn it the right way okay so basically all these standard resources from all these standard resources we will learn okay so that is the reason I'm telling you uh before beginning the lecture I'm telling you all the extended resources that we will follow okay is this clear so before I start this lecture I want to request you one thing if you have already studied this normalization concept if you have already studied 2 NF 3nf bcnf uh from partial dependency full dependency transitive dependency if you have already studied these Concepts from some uh maybe somewhere else some non-extended resource then forget then stay ready to forget all those Concepts okay so basically keep your mind open because because a lot of your Concepts have a lot of your concepts are might be wrong okay so we will study all the correct Concepts from all these standard resources that I told you and also if you if you are the first timer if you are learning this normal form onef 2 enough 3 enough B enough if you are learning this for the first time then congratulations okay you are basically uh you are a lucky person to uh learn it the right way uh the first time okay so anyway because it is very hard for uh to forget all the wrong Concepts and then to then uh to learn the right Concepts okay it is very hard like it is not a easy thing because if some some concept you are learning in the wrong way okay and you are solving maybe 100 questions 200 questions using those wrong methods okay using wrong methods you are solving 100 questions 200 questions then it will become very hard to uh understand the concepts in the right way okay because already you are thinking that uh whatever I know whatever I understand that is correct okay so let me tell you that today this lecture will change a lot of your I can say perception about these poor resources okay all these resources which do not follow standard resources there are many coaching institutes and on the YouTube also you can find So Random teachers you can find so they don't follow standard resources they are creating their own Concepts okay or maybe they are learning from uh some poor resources and then they are teaching okay so anyway something like this happens I don't know what happens but whatever we will study we will follow these books okay let's start now so let's see the first topic that is prime attribute what is a prime attribute what is non Prime attribute so the definition is very simple that what is a prime attribute Prime attribute means this attribute appears in at least one candidate key there can be many candidate key yes or no in your relation you can have many candidate key so more than one one candidate key you can have one or more than one then in this situation what is a prime attribute Prime attribute basically means that an attribute which appears in at least one candidate key an attribute a is called Prime attribute if it is present in at least one candidate key if it is part of at least one candidate key and what is nonprime attribute nonprime attribute means it is not part of any candidate key okay so this is the definition very simple definition you can notice this is the definition from naate that an attribute of relation R is called Prime attribute if it is member of some candidate key okay and if it is not member of any candidate key then it is nonprime okay non Prime means it is not member of any candidate key now let's see some example consider this example your have relation okay so the relation scheme is given to you or you can call it relation SCH schema both are the same words you can call it relation schema or you can call it relation scheme both are same so this is a relation which has three attributes this is the relation schema and set of functional dependencies is given to you a determines b b determines C Now find Prime and non-prime attribute so tell me what will be the answer so for Prime and nonprime attribute you must find candidate key correct yes or no first you must find candidate key agree so first you must find candidate Keys okay so let's find candidate keys so here what will be the candidate keys in this in this you can notice a is not on rhs if you look at all the functional dependency so in any functional dependency you can notice this attribute a is not present on rhs right so this attribute a is not present on rhs you can notice since a is not present on rhs of any functional dependency so we can say that only a can determine a only a can determine a so a must be part of every candidate key yes or no because no one can determine a only a can determine a okay so you can notice a must be part of every candidate key now let's check it out a must be part of every candidate key let's check it out what is the closure of a what a can determine so you can notice a can determine a A can determine B A can determine B now this B can determine C now this B can determine C so you can notice that this a A can determine everything a plus a can determine everything basically I can say that a can determine the whole relation yes or no I can say I can say that a can determine the whole relation the whole relation it can determine so a can determine the whole relation so so a is so here you cannot so a is super key and a is and this is minimal and this is minimal so a is primary key okay so a is super key because a can determine the whole relation so a is super key and since a is minimal and since a is minimal so a is candidate ke okay so a is candidate key is this clear to everyone so you can notice your candidate key is a now remember a must be part of every candidate key this a this a must be part of every candidate key and this a is determining a must be part of every candidate key and this a can determine the whole relation so I can say that this a alone is enough yes or no a itself is enough so I can say the candidate key will be only a so only one candidate key you have so tell me what will be the prime attributes only one candidate key you have so what will be prime attributes or key attributes another name for Prime attribute is key attribute so you can call it Prime attribute you can call it key attribute key attribute means which is part of at least one candidate key Prime attribute is part of at least one candidate key so Prime attribute will be a and what will be non Prime attribute and what will be non-prime attribute non Prime attribute will be B comma C so these are the non Prime attribute is this clear very simple so Prime attribute is part of at least one candidate key non Prime attribute is not part of any candidate key okay so this is a simple question we have done this now let's see the next tell me about this one if you have this if you have this uh relation if your relation is a b c and let's assume you have uh a determines b b determines C and C determines a so tell me in this relation like these are the functional dependencies these are the functional dependencies then in this relation tell me what are the prime attributes what are the non-prime attributes so every attribute is a prime attribute because first you find the candidate keys so you can notice a is also candidate key B is also candidate keys is also candidate key so all of them are candidate key so you can notice number of candidate key that is equal to three okay so all of them are candidate key now you can notice what are the prime attributes so the prime attributes are those attributes which are part of some candidate key those attributes which are part of some candidate key so this is a prime attribute this is a prime attribute this is a prime attribute and what is a non key attribute or I can say non Prime attribute non Prime attribute that is n nothing okay so nothing is a nonprime attribute so all are prime attributes okay every attribute is so basically no non Prime attribute I can say here no non Prime attribute there is no non Prime attribute in this relation we don't we do not have any non-prime attribute okay so this is a simple idea what is a prime attribute what is nonprime attribute you can notice we can have many different candidate keys this type of screenshot has this type of screenshot this type of screenshot whenever you see these are taken from code paper Okay so this type of screenshot are taken from code paper is this clear all these type of screenshot that you will see these are taken from cod's original paper Okay this original paper you can find on internet or you can ask me I will send you okay so I will upload this don't worry but everything that is uh G relevant in this paper I I will I will take okay everything that is gate relevant in this paper we will I have already put in the lecture notes okay so anyway so this is the definition of prime attribute you can have many candidate Keys you can have several candidate Keys a relation can have uh more than one candidate key but you can notice any uh any attribute which is part which is part of at least one candidate key is prime attribute all other attributes are non Prime attributes okay now let's move on now let's see the concept the type of functional dependencies non-al functional dependency partial functional dependency full functional dependency and transitive functional dependency so these Concepts we need to see what is Trivial versus non-trivial what is full versus partial and what is transitive so let's start with the trivial versus non-trivial functional dependency what trivial means in any in any subject what trivial means hi everyone am I audible is everything fine like can you see the screen yaj is saying that screen is stuck okay so let's see this so let's see this one can you see the screen on the screen you can see this topic uh type trivial versus non-trivial can you read this trivial versus non-trivial okay okay okay so now let's see so what is the trivial what is when when do we say something is Trivial in any in any subject in any subject when do we say something is Trivial when it is always true or it is always false either it is always true or it is always false okay so trivial means something which always holds or never holds yes or no something which always holds something which always holds or never holds yes or no something which always holds or never holds something which always holds or never holds so this type of thing this is called trivial trivial means either it will always hold or it will never hold is this clear so this is called trivial now you can notice what is a trivial functional dependency trivial functional dependency means it will always it will uh it will present in every relation like for example a can determine a yes or no if I give you the value of a can you find the value of a tell me if I give you the value of a can you find the value of a of course very simple now tell me tell me tell me if I give you the value of ab can you find the value of a if I give you the value of ab if I give you the value of ab for example if I give you the value of ab like if I give you the value of ab then tell me what is the value of a then tell me what is the value of a what is the value of a so value of a will be two right okay so the value of a will be two very simple but so you can notice that this a b determines a this is trivial this is Trivial why why I'm calling it trivial because it will hold on every relation you don't have to apply your brain you don't need any extra information this is Trivial because it will be it will be it will be applicable it will be applicable on every relation in every relation this will happen yes or no in every relation you can determine if you have the value of ab then you can determine the value of a what about this if I give you the value of a then can you find out the value of ab then can you find out the value of ab you need more information right yes or no you need more information you need more information correct so this is not trivial so this is nontrivial this is nontrivial is this clear this is non-trivial because you need more information so this is not trival because it will not hold for every relation a is determining a that is not true for every relation that may be true may not be true for some relations it may be true for some relations it may not be true but this a determines a this will be true in every relation but a determines AB this may or may not be true depending on the relation is this clear what is a trivial functional dependency so I can say trivial functional dependency basically the definition is very simple the definition is like this that Alpha anything Alpha implies beta is Trivial if and only if Alpha is a subset of beta sorry uh beta is subset of alpha okay beta is subset of alpha is this clear so when I can say that Alpha implies beta is a trivial dependency when beta is subset of alpha like I told you a determines a this is trivial this is a trivial okay like a b c determines AB this is Trivial similarly a determines a tell me one very simple thing tell me if you know the value of ABC can you find the value of ab if you know the value of ABC can you find the value of ab of course so this is Trivial okay so these are the trivial functional dependencies trivial functional dependency means I can say Alpha implies beta is Trivial when can I say this is Trivial this is trival if beta is subset of alpha or I can say Alpha is subset of beta superet of beta Alpha is superet of beta okay is this clear now why do we call them trivial functional dependency why we call these trivial because they will hold for every relation okay because they are satisfied by all the relations you can very easily see because they will always hold for every relation okay so you can very simple this type of functional dependency if you have a functional dependency where this is LHS this is rhs so this is this is Trivial remember this is Trivial if LHS is superet of rhs LHS is a superet of rhs okay then we call it trivial because it will hold every time so tell me trivial dependencies are they interesting can they can they can they provide you anything uh anything anything important information the trivial dependency the trivial functional dependency can it provide you any any important information about the relation any significant amount uh any significant information about the relation can it provide no why because trivial functional dependency is true for all the relations yes or no whatever relation you take it is true like a determines a it is true for every relation a determines a that is is true for every relation so trivial functional dependency cannot provide you anything important any important information they cannot provide you so trivial functional dependencies we will never uh we will never basically consider okay is this clear so trivial functional dependencies are not important so trivial functional dependencies are basically unimportant or I can say not interesting these are not interesting because they are for all the relations so trivial functional dependencies we will not we will not care okay we will not care about the trivial functional dependencies because they will hold for all the relations now let's see what is non-trivial what is a non-trivial functional dependency if some functional dependency is not trivial then it is non-trivial okay a functional dependency which is not trivial is non-trivial so what is non-trivial functional dependency tell me what is nontrivial functional dependency what is non-trivial functional dependency n FD a functional dependency which is not trivial which is not trivial a functional dependency which is not trivial very simple okay very simple so you can notice this is the definition of non-trivial functional dependency a functional dependency which is not trivial okay now you can notice so these are the non-trivial functional depend depes let me I will write this nontrivial functional dependency in short I will write like this okay NT FD is this clear I will write like this non-trivial functional dependency so like for example if you have a relation let's assume you have a relation A B C D and in this relation if I give you this functional dependency like a determine C then you can notice this is not trivial right yes or no in this relation I can also give you trivial functional dependencies like if you want these are the trivial functional dependencies so what are trivial functional dependencies for example a determines a for example d d determines D for example DC determines C okay for example a determines a so these are trivial all these are trivial functional dependencies now what is non-trivial you cannot this is non-trivial functional dependency for example what about AB determines b d what about this is this trivial is this trivial is this trivial so this is not trivial this is non-trivial functional dependency okay what about AB determines BCD what about this AB determines BCD this is also not trivial so this is non-trivial functional dependency okay a determines B this is non-trivial a determines AB c d this is non-trivial so these functional dependencies these are non-trivial functional dependencies is that clear so these are your your non-trivial lities okay so very easy now let me tell you that can you notice one thing look at this non-trivial functional dependency look at look at this non-trivial functional dependency like AB determining b c look at this non-trivial functional dependency look at this observe this okay so you can notice this this contains to can I split this you know the split rule yes or no you know the split rule of uh you can you know this we already know this the split rule split and uh combined rule so split rule of split SL combined rule on rhs rule on rhs of fds for functional dependencies on rhs you can split also you can combine also on rhs remember on rhs you can split also you can combine also so for example if you have a goes to b c then this is same as remember this is same as this is same as two things okay a determines B A determines D is that clear so okay so remember you can combine also you on the rhs on the rhs you can combine also and you can split also on the rhs so this is your split Rule now anyway let's see here so look at this non trial functional dependency if you notice this is okay I can write it like this it is basically saying that a can determine B and ab can determine C and ab can determine C yes or no now you can notice this is Trivial right this is the trivial unin this is not interesting part this is the trivial FD or I can this is the trivial part of this FD yes or no this is the trivial part of this FD let's call it for example fd1 so I can say this is Trivial part of fd1 trivial part of fd1 is this clear trivial part of fd1 yes or no and this is the non-trivial part and this is the non-trivial part of fd1 this part is non-trivial part of FD D1 it is it is making this non-trivial this part is making it non-trivial but you can notice that this is the trival part of FD one and this is the non-trivial part of fd1 so you cannot this is not interesting right yes or no this this part this part is not interesting this part is not interesting but this part is interesting this part is interesting so you can notice that whenever you have this type of situation whenever whenever whenever you have in any non-trivial functional dependency in any non-trivial functional dependency if you have this type of situation like Alpha like for example Alpha a determines a beta if you have this type of situation if you have this type of non-trivial functional dependency then then tell me which is interesting here if you have this type of non-trivial functional dependency then you can just you can just consider this you can just consider this because okay this will happen right correct yes or no this functional dependency will imply this and this functional dependency will imply this sorry uh sorry Alpha a alpha a determines beta sorry Alpha a determines beta okay so you can notice this functional dependency determines this and this functional dependency determines this is this clear here so basically you can remove this this part this part which is on LHS this part of rhs which is already on LHS this part you can remove is this clear tell me tell me is this clear so this part of rhs which is already on LHS this you can remove because if you notice this is uninteresting Alpha a goes to a this is trivial okay this is Trivial so we will only consider this so this type of non-trivial functional dependency we will consider and actually there are some authors who Define like this let me tell you there are some authors and because of this reason because of the same reason can you notice that these two uh if can I tell me one thing if I have non-trivial functional dependency like this for example if I have this type of non-rival functional dependency a goes to B A determines B then this type of non-trivial functional dependency you can easily write like this that a determines uh I can say a determines AB yes or no you can easily write like this a determines AB because if a can determine B then a can determine AB because a already determines a this also we know okay so this split rule we know also what also another rule we know what is that another rule that is basically if Alpha can determine beta if Alpha can determine beta then then Alpha J can determine beta if Alpha can determine beta remember it's like if Alpha can beat beta okay if Alpha can beat beta then Alpha Zed of course Alpha Zed with additional power of course you can beat yes or no very simple so this if Alpha can determine beta then Alpha Z also can determine beta but this is not this is not true this is not true right this is not true okay this is not true so but but this is true but this is true that if Alpha can beat beta if Alpha can determine beta then I can say that alpha alpha can determine Alpha Beta yes or no this I can say I can say that if Alpha can determine beta then I can say Alpha can determine Al Al beta for example for example if Alpha can determine B for example if a can determine B then then this is Trivial okay then this is Trivial a can determine a this is Trivial so from these two I can say that a can determine AB okay this is Trivial so you can notice Alpha if Alpha can determine beta then I can say Alpha can determine Alpha Beta okay so and this is your you can also go in this direction you can also go in this direction by the split rule by the split rule you can also go in this direction okay anyway so very simple point that so if you have non-trivial functional dependency like this then you can also write like this and if your non-rival functional dependency like this you can also write like this agree did you notice that okay so this type of so if you have this type of thing for example if you have a b c determining C c d e if you have a b c determining CDE then I can write it AB b c determining de yes or no if you have ABC determining CDE then this is Trivial part this part is Trivial I can say I can say this part is Trivial this part is Trivial yes or no this part this part is a trivial so you can remove this part so you can notice this is a two-way okay very simple so that is the reason I saying that you can Define non-trivial functional dependency like this or you can Define non-trivial functional dependency like this both are equivalent definitions is this clear so you can Define like some authors the definition of non-trivial functional dependency you can Define it anyway because both the definitions are equivalent non-trivial functional dependency so let's see the definition one definition one what is the definition one anything that is not trivial yes or no anything that is not trivial so like for example I can say Alpha determines beta is non-trivial is non-trivial if and only if I can say that Alpha is not a superet of beta Alpha is not a super set of beta means it is not trivial so definition one says that just that it is not trivial yes or no so definition one says that non-trivial means not trivial so definition says that not trivial it simply means that it is not trivial okay and what is definition two what is definition two in the definition two basically what you can do basically you can if something is common LHS comma rhs if they have something common if they have something common then you can remove that common part from the rhs yes or no if you have something common if you have something common LHS comma rhs if they have something common then you can remove that common part from the rhs like here they have something common like here they have something common you can remove this common part from the rhs is this clear so like you can notice you can makes this note that in any non-trivial in any functional dependency in any functional or I can say non-trivial functional dependency in any non-trivial functional dependency okay if something is common like for example let's assume that let's assume Z is equal to Let's assume Z is equal to LHS intersection rhs means this Z is what this is the common part of this is the common part on this is the common part on LHS comma rhs of FD okay so if this is the common part then what we can do then this common part can be removed from the rhs can be removed yes or no then it can be removed from rhs so this is what I'm saying is this clear so basically I'm saying that if you have this type of FD like Alpha J determines J beta okay if you have this type of functional dependency then this common part this common part you can remove on rhs from rhs you can remove from rhs you can remove this common part you can remove this common part from the rhs you can remove this common part from the rhs okay you will get a equivalent functional dependency so these are equal this this is equalent this is equalent so this is the definition two definition two simply says that basically nothing common Alpha implies beta is non-trivial functional dependency it is non-trivial functional dependency if and only if if and only if first of all if and only if uh very simple if and only if Alpha intersection beta is five is this clear they have nothing common they have nothing common they have nothing common so Alpha determines beta this is non-rival functional dependency this is nonrival if they have nothing common Alpha intersection beta they have nothing common and tell me the definition one is this equivalent to definition two definition one is this equivalent to definition two yes they are equivalent definition one definition two they are equalent okay because if you have something common you can remove from the rhs this is what we have seen if something is common if something is common then you can remove that from the rhs like here if this Z is common you can remove this J from the rhs this Z you can remove from the rhs okay so is this clear the definition two definitions any of them you can use there is no problem there is no problem okay any of them you can use now what we are going to consider we are going to consider basically if you look at all the non so what we will consider we will consider non-trivial functional dependency also rhs containing only single attribute from now onwards what we will consider because if you have this type of basically now onwards what we will consider for all the concepts what we will consider in all the concepts consider in all the concepts that we study in in normal forms or I can say in normal form Concepts so this concept that we are going to see in normal form Concepts what we will consider we will consider only will we consider trivial functional dependency trivial functional dependency is not interesting that will hold for every relation so what we will consider we will consider non-trivial functional dependency first of all first of all we will consider non-trivial functional dependency okay remember we will consider non-rival functional dependencies and second second these non-rival functional dependencies only those basically we will we will split this non- trial functional dependenc so that rhs has only single attribute okay non-trivial functional dependencies with rhs containing single attribute okay is this clear so we will consider only non-trivial functional dependencies with rhs having single attribute what if rhs does RSS have multiple attributes what if what if rhs have multiple attributes like if RSS has multiple attributes then you can split then you can split okay then you can split you can split a goes to a determines B A determines C so these we will consider is this clear we will consider these these we will consider is this point clear to everyone like if you have a b c determines D then what I will consider basically if you have this then what I will do then I will do ab b c determines D AB b c determines e so basically on the rhs we should have single attribute so this type of non-trivial functional dependency we will consider is this point clear what we will consider we will consider non-trivial functional dependency we will consider with rhs having single attribute with RSS having single attribute if RSS does not have single attribute you can split okay tell me is this clear to everyone so we will consider non-trivial functional dependencies with rhs containing single attribute if rhs does not have single attribute we will split in all the concepts all all the concept that we study like uh we study partial dependency functional uh transitive dependency 2 NF 3nf bcnf all the concepts that we study in all the concepts we will consider the non-trivial functional dependencies where rhs has single attribute okay where rhs has single attribute non-trivial functional dependency with rhs containing single attribute because remember trivial functional dependency they will not change anything okay like trivial functional dependency will hold for every relation every relation contains trivial functional dependencies so trivial functional dependency cannot change anything cannot affect anything okay cannot affect the answer cannot affect the I can say the properties of the relation because trival functional dependency will hold for every relation so those are not interesting so what we will do we will consider only non-rival functional dependency okay with only with r s having single attribute if rhs does not have single attribute then we can split then we can split okay now let's move on now let's see the next concept that is partial functional dependency as full functional dependency and this is very intuitive concept let me tell you partial functional dependency partially dependent and fully dependent partially dependent and fully dependent okay so for example this is a very intuitive concept let's let's understand this intuitively like what is fully dependent fully dependent like for example if I say that this person let's assume I if I say that this person a is fully dependent on B comma C okay let's assume this is a children let's assume this is a child let's assume this is a child okay so this is your uh like for example let's assume this is child if this is fully dependent on if this is fully dependent on person B comma C then what it means tell me what it means then can I say can I say B can determine can I say then okay it is fully dependent on them remember it is fully dependent on person B comma C then what it means it means that b comma C they can they will determine a and and and and and can B determine a can alone B can alone B determine a alone B alone B cannot determine because this is fully dependent on person B comma C it is fully dependent on B comma C so you can notice BC will determine a b cannot determine a b cannot determine a and C cannot determine a is this point clear what fully dependent means what fully dependent dep means fully dependent for example here I can say that here I can say that a is fully dependent on BC a uh sorry here basically here I can say that a is fully dependent on BC if this type of situation happens then I can say that a is fully dependent on B comma C or I can say BC not B comma C it is fully dependent on BC okay so anyway this is just analogy thing like this is just an analogy this is not the concept this is just the analogy now let's see the definition the definition is very simple what is fully functional dependency full fully functional dependent fully functionally functional dependent fully functionally dependent we can call it full FD full functional dependency so when can I say like very simple definition I can say that this Alpha this Alpha determines beta this is full dependency it is a full dependency it is like okay like this B this beta is fully dependent on Alpha this beta is fully dependent on Alpha if and only if okay if you remove something from alpha if and only if if you remove something from alpha like Alpha minus a if you remove something from alpha then what will happen then it will not determine B yes or no okay for all a belonging to Alpha for all a belonging to Alpha what I can say I can say that if you remove something from alpha it will not determine beta is this clear tell me anyone has any doubt it will not determine beta it will not determine beta like if you remove something from alpha if you remove something from alpha then it will not determine beta another word another okay the same definition in another words the same definition in another words what I can say I can say that so the same definition is this clear tell me anyway the same same definition I can say that beta is fully dependent on Alpha this is full dependency okay this is full dependency what that means this is full dependency what that means that means beta is fully dependent on Alpha it is fully dependent on Alpha it is fully dependent on Alpha if and only if subset of subset of alpha proper subset of alpha cannot determine beta if if and only if proper subset of alpha proper subset of alpha cannot determine beta canot determine beta is this clear canot determine beta so if and only if any any proper subset any proper subset of alpha if you take some proper subset of alpha that cannot determine beta so we can say that this beta is fully dependent on Alpha is this clear tell me beta is fully dependent beta is fully dependent if if and only if if you take proper subset of alpha whatever proper subset you take then it cannot determine beta so I can say that for all a belonging to Alpha for all a belonging to Alpha I can say that if you remove this a from alpha then you cannot determine beta so this Alpha minus a cannot determine beta so this is the definition of fully functional dependency and what is the partial functional dependency the same way what is the partial functional dependency what you will say that what is the definition of partial functional dependency partial FD what is that I can say that this is partially dependent I can say Alpha is partially dependent on beta if there exist something something you can remove from Alpha if there exist something on Alpha such that you can remove for some yes some a you can remove and you can still some a you can remove something you can remove from here you can still determine beta is this clear basically now very this is very intuitive this is very intuitive that if you can for example if something you can remove and still you can determine beta then I can say beta is partially dependent on Alpha yes or no tell me yes or no so very simple this partial functional dependency this partial FD I am saying that this alpha or I can say beta is partially dependent when I say that Alpha implies beta is partial FD what it means it is partial FD what it means it means Al it means beta is partially dependent on Alpha it is partially dependent on Alpha okay if and only if some subset of alpha some proper subset of alpha can determine beta some proper subset of alpha some proper subset of alpha itself can determine beta so you don't need the entire beta so you don't need need the entire Alpha is this clear you don't need the entire Alpha is this clear you don't need the entire Alpha basically this is partial because you don't need entire Alpha this is partial because you don't need entire Alpha is this clear so some proper subset of alpha itself can determine beta so you don't need entire Alpha here you need entire Alpha in the fun in the full functional dependency you need entire Alpha using diagram let's try to understand before that let's take this example consider this example you have a relation a b CDE e and these are the functional dependencies tell me in the definition before before we see this tell me in the definition whatever definition we have seen did we use the word candidate key in the definition did we use the word candidate key in the definition of partial functional dependency and full functional dependency did we use the word candidate key I did not use so tell me if I ask you this question if I ask you this question tell me like for example my question some questions I'm asking you okay back to back some questions I'm asking you first question is CD determines e a partial dependency is this a partial dependency CD determines e is this partial is this partial CD determines e is this partial is this partial what is the definition when it will be partial just tell me just tell me just tell me when it will be partial when it will be partial just tell me when it will be partial it will be partial when C can determine e or D B can determine e so check check can C determine e check C+ check C+ what is C+ what is closer of C that is C what is D+ what is D+ d d can determine d d can determine a A can determine e so tell me can I say d determines e so you can notice D determines e right so you can notice D determines e so is this partial is this partial yes why because you don't need the entire CD because you don't need entire CD yes or no this is partial because you don't need entire CD to determine e is this clear so this is partial because you don't need entire CD to determine e so this is partial because because D can determine e so remember this is this is partial FD is this clear this is partial FD is this clear to everyone so this is partial tell me what about D what about D determines e what about this one what about this one D determines e is this partial is this partial this is full functional dependency this is full functional dependency why because you cannot remove anything from LHS okay why because you cannot remove anything from LHS because we cannot remove anything from LS okay we cannot remove anything from LHS is this clear because it is a single attribute you cannot remove anything from LHS okay so like this this what about next question what about this uh for example be BD determine C is this partial or full BD determine C is this partial or full is this partial or full this is not even a functional dependency it is not even a valid functional dependency it is not even a valid functional dependency is partial or full FD it is not even valid functional dependency it does not okay not a it is not a FD on this relation it is not a valid FD on this relation is this clear it is not a valid FD on relation R because if you find what is BD Plus if you find what is closer of BD BD can determine BD BD can determine BD D can determine a this D can determine a A can determine e okay so like this so you can notice this BD cannot cannnot determine C anyway so this is the concept is this concept clear tell me so like this you can check it out okay anyway this is the candidate key if you want to find the candidate key how will you find tell me how will you find the candidate key how will you find the candidate key you can notice this B CD these these attribute do not appear on rhs so they must be part of every candidate key correct you can notice B okay to find to find CK to find candidate key you can notice that attribute B comma C comma D are not on RSS yes or no are not on rhs of any FD of any non-trivial FD of any non-trivial FD so they must be part of every candidate key so they must be part of every candidate key so you cannot b c d must be part of every candidate key yes or no it must be part of every every candidate and you can notice this is this is alone this alone is itself uh uh alone is enough so this BCD this alone is enough now let's move on so what is the definition of this functional depend fully functional dependency definition we have seen partial dependency definition we have seen you can check it out from the naate this is n you can check it out okay so these definitions we have seen these these slides you can read and this is your original code paper this is the original paper of code I told you this type of screenshot these are from the original paper of code now let's see this example and this is the example given in this code paper in the paper of code this example is also given okay let's see this example so in this question what the question is asking so like for example let me ask you something like this uh tell me so this is the given these are the given functional depend depes these are the given functional dependencies what this means tell me what this means what this means like when I say like this see if I say like this Alpha if I say like this what this means this means that a can a can determine B B and B can determine a okay what this means remember this means that a can determine b b can determine a is this clear so this means a can determine b b can determine a a okay this is the idea so if I say like and this is the this is the original paper of code remember this is the original paper of code and this example is given in this paper anyway so you cannot this means that a determines B and B determines a okay so here what this means actually if you notice so let me tell you what this means so actually these fds if you notice these fds what they mean these fds if you notice you these are basically like ABC is determining de and de is determining ABC okay is this clear ABC is determining de and D is determining ABC also also de determines F de determines F okay also AB determines D also e determines C okay so these are the functional dependencies okay this is your relation so you can clearly see your relation has these attributes your relation has a b CDE e f these are the attributes on your relation and these are the functional dependencies okay now my first question my first question D determine C is this full dependency or partial dependency de determines c d determine C is this full dependency or is this valid dependency first of all de determine C is this valid functional dependency is this valid functional dependency check it out just check it out just check it out just check it out what is D+ D+ means it will determine de de can determine F de can determine F de can determine ABC de can determine ABC okay D can determine ABC so ABC DF everything so okay now tell me is this is this partial or full is this full FD or partial FD is this full FD or partial FD can you remove something can you remove something tell me can you remove something just tell me this point simple point this is partial why this is partial this is partial FD this is partial FD why because because you don't need de you don't need this de yes or no this e is enough yes or no this e is enough you don't need de so remember this is partial remember this is partial FD is this partial FD is this partial FD is this partial FD this is not partial this is full okay is this clear to everyone so for example this e goes to C the E goes to C is full is full or partial it is full it is full right you cannot remove anything it is full this functional dependency is full this is full functional dependency you cannot remove anything from the LHS so this is full functional dependency let's see the next example d uh ABC determining be what about this one ABC determining be what about that ABC determining de what about this ABC determining de is this full or partial sorry d d ABC determining D is this full or partial so this is also partial this is also partial why because because you cannot AB itself can determine D because AB is enough yes or no because AB is enough because AB is enough so this is part this is partial functional dependency because you don't need the entire LHS so the definition of partial dependency functional dependency is this clear what is partial and what is full functional dependency so you can notice if you have this type of situ a determine C A determine C then what will happen if you have this type of situation if you have this type of situation so basically if if AB is determining C and also a is determining C then then which of them is partial then which of them is partial which of them is partial a determining C okay if this then which of them is partial which of these is partial so which of these is partial and the answer is very simple this is partial so remember this is partial FD because you don't need the entire AB because you don't need entire AB is this clear this is full this is full you don't you need the entire entire a you need entire LHS here you don't need entire LHS okay so here you can notice a determine C A determine C then then then then this AB determined C is partial I can say C is partially dependent on AB okay so this is the idea now what about this one what about this one if there is a dependency C determines e if there is a dependency C determines e then what what can you say about this one BC determining e this is partial right if C can determine e then BC determining e is partial okay so this is the definition anyway now let's move on before we move on let's see the diagram so let's see the diagram let's understand this concept by diagram so remember this is the conclusion I can I can say this is the conclusion so what is the conclusion the conclusion is very simple that I can say that this x a determining B okay is partial basically I'm saying that this is partial means if you have like this x determining uh a is partial when can I say this is partial when can I say this is partial if this is your X let's assume this is the X now X is determining a x is determining a when can can I say this is partial when some subset is determining a when some subset is determining a yes or no when some subset is determining a yes or no in this situation in this situation I can say that this this x determines a this is partial FD is this clear where Y is proper subset of X Y is a proper subset of x okay so very simple this is the definition of partial functional dependency and what about the fully functional dependency what about the full functional dependency when can I say this is full when this can never happen full means this can never happen subset subset can never determine a uh it okay is this clear then we call it full functional dependency so very simple right so this concept we have seen now let's see the next concept that is transitive functional dependency what this concept let's understand okay so let's understand this transitive functional dependency tell me did you understand partial and full functional dependency did you understand partial dependency full functional dependency did you understand the okay very clear also remember only consider non-trivial functional dependency okay only consider non-trivial functional dependencies because trivial functional dependencies they will hold on every relation trivial functional dependency cannot decide anything trivial functional dependency cannot uh cannot do anything basically cannot do anything significant okay anyway now let's see transitive functional dependency so what is the definition of transitive functional dependency let's see the definition from cor this is the book database from cor okay so in this this definition is given what the definition is saying that if you have okay first you understand the definition anyway let me explain this definition Alpha comma beta these are set of attribute so that Alpha implies beta beta does not imply Alpha and beta implies a then a is transitively dependent on Alpha anyway let's explain this definition let me explain first of all what is transitive when you see this word transitive what comes to your mind when you see this word transitive what comes to your mind whenever you see this word transitive it comes to your mind right like something like something is something is implying something and this is implying this then this is transitive this is called transitive this is called transitive yes or no is this clear so whenever you see transitive word whenever you see the word transitive then what will come to your mind this will come to your mind like X can determine y y can determine Zed okay so so so this x determining Z this is transitive so what is transitive is this transitive tell me is this transitive no this is transitive X determining Z this is transitive okay so this is the general transitivity in general this this is what we call transitivity in general in general sense this is the transitive in general sense okay now let's see the definition of transitive FD let's see the definition of transitive FD transitive functional dependency what is the transitive functional dependency so we can say that I'm saying that X determining a okay remember I told you we will consider only single attribute so X determining a is a transitive when can I say this is transitive tell me when can I say this is transitive FD this FD this FD is transitive FD when can I say this FD is transitive FD this FD is transitive FD if there exist something some middleman exist some middleman exist there exist some middleman there exist some middleman such that X is determining y y is determining a correct is this clear tell me is this clear there exist some middleman there exist some middleman such that X is determining y why is determining a okay the only one extra condition is there one extra the last condition this is the extra condition that y should not determine X Y should not determine X this is the only only additional condition okay so tell me is this clear what is the transitive functional dependency definition tell me is this point clear transitive functional dependency definition very simple definition that very simple definition X determining a is a transitive FD when can I say this is transitive FD like X determining z x determining Z when can I say this is transitive this is transitive if there is a middleman if there is a middleman okay if there is a middleman so you can notice this is the definition now nikil is asking nikil is asking nikil is asking can a determine X you tell me nikil you tell me can a determine X this is the complete definition this is the complete definition this is the complete definition okay now now now now can a determine X some observation some observations can a determine X okay tell me can a determine X like if if x is determining y y is determining a y is not determining X Y is not determining X then then can a determine X anyone can a determine X if this situation happens if this situation happens if this situation happens can a determine X why can anyone prove it the answer will be no the answer will be no never can anyone prove it can anyone prove it very simple if contradiction by contradiction yes very good by contradiction by contradiction you can prove by contradiction you can prove if a determines X and we already know we already know Y is determining a we know Y is determining a a is determining X then y determines X that is the contradiction I told you that y should not determine X that is the contradiction is this clear tell me is this point clear let me know okay very simple so it cannot happen but remember this is not part of the definition uh this is not part of the definition is this clear so this is not part of the definition because this is this is I can say uh from this definition you can imply this correct or not is this clear from this definition you can imply this just wait just wait okay is this clear this is a complete definition is this clear tell me did you understand transitive definition transitive FD definition let's take example with example this concept will become more clear so remember the okay again I'm telling you the transitive again I'm telling you the transitive FD definition transitive FD definition so the transitive FD definition is very simple now I'm saying that Alpha determines a this a is a single attribute remember remember this a is a single attribute is this clear here this a is a single attribute whenever I write like this this is a convention I'm using okay remember this is a convention I'm using what convention I'm using that if I write like this a comma B comma C if I write like this then what they mean they mean single attributes okay they mean single attributes they mean single attributes single attributes okay individual attributes and when I write like this Alpha Beta X Y if I write like this then what it means then what it means Alpha Beta x y gamma Jed if I write like this then they means set of attributes okay they means set of attributes they can be single also they can be single also can be single can be single also but these are set of attributes is this clear this convention tell me is this convention clear so now let's move on now you can notice that Alpha goes to a Alpha goes to a is transitive is transitive when can I say Alpha goes to a is transitive Alpha goes to a is transitive if there exist a middleman if there exist a middleman if there exist a beta if there exist a middleman okay if there exist a beta such that such that this will happen okay and also this should not happen the only additional condition is this should not happen this should not happen in this situation if this happens then okay then then then Alpha determines a is transitive dependency is a transitive functional dependency okay is this clear it's transitive functional dependency this t means transitive okay so this is the complete definition and of course of course tell me tell me tell me a cannot determine a cannot determine alha right this we have seen this we have seen but but should I write this this is redundant can you notice should I check this should I check this tell me should I check this no this is redundant this is redundant because if this happens tell me remember if this happens then this this will also happen then this will also happen so this is rant okay anyway let's move on let's see some examples so you can notice this this screenshot is taken from whom this is a screenshot taken from your uh C's original paper this is the screenshot so you can notice this is the definition given transitive dependency definition is given okay this is what we have seen consider this example again you have a relation a b c and let's assume a is determining C let's assume a is determining C okay in this situation this is my question a determining C this is the FD and my question is is AB determining C a transitive dependency is that a transitive dependency is a determining c a transitive dependency I'm I'm asking for this is this a transitive dependency so the answer is yes the answer is yes because there exists some middleman right okay so this a B A determine C this is transitive this is transitive because you cannot this does not determine this you cannot this does not determine this okay so so everything is fine right okay everything is Picture Perfect everything is picture perfect so I can say so what we can say so we can say a c is transitive dependency okay can you notice this is a partial dependency also can you notice this is partial dependency also this a determine C this is partial dependency also this is partial FD also okay so anyway so this is the idea what about a determining C what about a determining C A determining C is trans transitive can I say this is transitive functional dependency can I say this is transitive functional dependency the answer is no there is no middleman a determine C there is no middleman is there anyone is there anyone such that this picture will happen is there anyone such that this picture will happen is there anyone such that this picture will happen also here one more thing I want to tell you uh here in the definition one more thing I want to tell you in the definition this a must not be part of X comma y okay in this one more thing one more note this a is not part because we are considering the non-trivial fds one more thing actually it is part of the definition you can notice you can notice this read this it is not Alpha it is not in beta okay so this is from the cour this is from the book cour so what I'm saying that here I'm saying that here uh also a does not belong to X okay a does not belong to Y is this point clear and a is a single attribute a is a single attribute a does not belong to x a does not belong to Y is this point clear tell me a does not belong to x a does not belong to Y it is a single attribute it is a single attribute and also a does not belong to x a does not belong to y a does not belong to Alpha a does not belong to Beta tell me is this point clear okay so like this now you can notice now tell me now tell me so basically you cannot take this can I take this a determine C the picture is perfect this is Picture Perfect this is Picture Perfect can I do this can I do this can I do this C is part of this C is part of this so This you should not do so this you should not do why why you should not do this because remember because this should not happen this C must not okay if I if I consider this if I consider this beta then then C should not belong to Beta yes or no C should not belong to Beta okay so this is the idea I hope this point is clear so remember this is not a transitive functional dependency okay now let's see some more questions one more example let me take let's assume A B C D and uh yes these are the these defin yes these are the by definition M like these definitions are given by code these definitions are given by code we are using them okay and remember why these definitions were given by Corde like why code gave these definitions he must have done some research he must have done some research he must have done okay then finally he must have given these definitions okay so if you see this research paper written by code if you see this I have this paper if you want I can give it to you but all the gate relevant sections every gate relevant part I already taken a screenshot and I've already put put in this lecture notes so when you read the lecture notes already all the gate relevant I can say uh portion you will be reading but remember in this paper if you see this paper I will send it to you basically in this paper it is also written why these definitions are coming the motivation for these definitions like from where he is getting the idea of two NF from where he's getting the idea of three NF from where he's getting the idea of partial dependency from where he's getting the idea of transitive dependency B basically these definitions these ideas these definitions from where he's getting the idea okay so that is also given he has written it like if you see the research paper then he has written from where he's getting the idea okay why he why he created the definition like this now you might be thinking sir why the transitive dependency definition is like this so he has written in the research paper but we will not we will not go into that okay we will not discuss that in your mte if you take dbms as your if you do PhD in the dbms then you can do that if you do PhD in dbms okay anyway now let's see so this is your another relation I'm giving you a relation r a c d now consider this example that um so consider this a determines b b determines c c determines D okay tell me here in this you tell me what about this one a determines D is this partial is this dependency partial tell me yes Alpha comma beta there can be any set of attributes Alpha comma beta those are any set of attributes the condition should hold so is this partial is this partial so this is full functional dependency right this FD is full FD this functional dependency is full functional dependency because you cannot remove anything from the LHS is this transitive is it transitive a determine D this is transitive right so this is not partial you canot this is not partial and here this is transitive why this is transitive because you can notice a can determine D and you can notice uh a can determine D and you can put B here the middle man you can put so everything is picture perfect yes or no everything is Picture Perfect is this clear let me know so a determining D this is transitive this is transitive because there is a middleman you can put this Middleman s this is the definition see this is the definition just apply the definition this is the definition everything is written in this definition okay this is the definition again I'm repeating that Alpha determines a is a transitive here is a transitive functional dependency here remember here a is a single attribute here a is a single attribute okay a is a single attribute Alpha comma beta these are set of attributes these are set of attributes a is a single attribute Alpha comma beta these are set of attributes also a is not part of a a is a does not belong to Alpha a does not belong to Beta okay is this clear now this is transitive functional dependency if this this picture happens if there is a middleman beta if this picture happens if this picture happens then we say that this is transitive functional dependence so just apply the definition Alpha Comm beta they can be set of attributes but remember beta should not imply Alpha okay and this a is not part of alpha this a is not part of beta okay this a this a is not part of alpha comma beta so this a does not belong to Alpha and this a does not belong to B okay okay so now after the break we will study normal forms which are basically 1 NF 2 NF 3 NF these things we will study bcnf okay