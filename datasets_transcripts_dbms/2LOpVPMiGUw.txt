hi everyone in this particular video I've tried to condense all the things that you need to know about databases and the most frequent questions that are asked generally around it in the interviews I know that your internships and placements are right off the corner and then you are going to be sitting for these companies where you'll be asked these questions so make sure to go through this 30 minutes short crisp explanations of all these questions even if you don't know databases you will still be able to retain some of this information and should be a good gist to go through first and then maybe read more about databases I've also like added the links that would be relevant to read more about databases if you want to do that on your own uh so enjoy the video it's just a 30-minute video but you'll learn everything that you need to know and maybe it just going to save you as interview all together see you in the [Music] video hi everyone welcome to the series on cor's most frequent questions where we talk about the common interview questions that are asked on different corc subjects and today we are talking about databases right database management system so we'll talk about the most frequent types of questions what are generally asked and how to prepare for them now this can even serve like a short summary of the whole subject if you have read it before so that you are ready for the interview now I think in databases there are like two different broad Realms in which questions are generally divided and these divisions create different kinds of questions and you need to be aware about both of them one is uh designing and querying the databases like how do you design a good database there are things related to SQL on querying right these kind of things are generally asked in interviews um how do you normalize how do you like like make sure that anomalies are not present and things like that then there are also uh questions around how does databases um like work what are they what kind of features they support what is rdbms U partitioning sharding bunch of things like this right again questions related to the like systems mechanics of database management systems is also asked so these are two broad realm and both of them needs to be prepared separately in my opinion but again we'll go through the questions that are listed here in some form or the other I've tried to reorder them in a way that you can we can like logically learn everything and uh so that it also serves like a summary of the whole topic all together right let's get started let's see how this goes so we'll start with the right hand side one which is what are they why they work and how they work and stuff like that because I think that's more important um so general questions that might that you might get started with is what are databases what is database management system what is SQL what are the difference between any of these two database versus database Management Systems right these are things that are generally asked in like as a starter questions of databases right and you you are supposed to be knowing the clear uh differentiation between them right so database just means like systematic collection of bunch of data here and there like it's just a systematic collection of the data that's it that's a database now a management system built on top of this data to be uh to ensure that you can actually store these things efficiently and you can organize them you can build indexes you can uh like query on top of them is something called as the management systems that handles this database right we also have a SQL as a language which basically works as an intermediate so that if you have a database you want to ask questions or ask queries or update that database inside the database Management Systems so you use a language to communicate that to the database management system the language used is SQL in most cases right but there are more languages so but SQL is the most common one so on the internet if you think about it like we have Internet requests coming to the websites back end there are web servers that handle it then there are like some services that might be there and it calls the database so my understanding is this this software that you see over here the database that you see is actually a database management system inside that the databases of the like Corporation would exist and on this wire when you are like from your server when it asks the database on what exactly to be retrieved and what needs to be saved and things like that the thing that goes on this wire can be an SQL right so that's that's what is essentially a database three terms Three core terms right sometimes questions are asked around what are the different types of database now most Commons one would be relational database where you have these rows and columns and stuff like this right which I think most of you would be like uh like familiar about but you also have column like you have analytical databases which is generally used for like in just like keeping large Blobs of data and then analyzing them later on for insights and stuff uh like they are like not very either they are like read heavy or right heavy and mostly they are read heavy like you build analytics on top of it so uh there are database systems that support that you also have like column family databases graph databases right uh key value databases right document databases these kind of nosql databases are also supported right and there are plenty of examples of these things in Industry also like there are different implementations of these types of databases but just know the names because somebody might ask you that in an interview one very very common question VI uh I have seen uh that you can actually store a file in C++ and just store whatever is required so why not just use files to store data and use a database because first of all files are local and there are bunch of differences between the temp right this database management system makes a lot of things easier which we don't really appreciate when we are actually using it for an example I've have highlighted the main points with green uh but sharing of data becomes easy because files are a local concept right like it's it's a file resding on one uh computer but databases might replicate or duplicate the files or keep it in a way that it is accessible around in different parts multiple different servers can access it as well as it is uh like like you can say format agnostic so it's not necessarily a txt file it can be any file that you kind of save and everybody can access it right you don't have to like focus on encoding and stuff uh security is something that is super important like files anybody can read and kind of tamper with it but then in database you can create security levels and you can give accesses to certain things to certain users and stuff like that these things aren't possible on a single file recovery mechanism is super important because the files get deleted or the computer gets crashed on which the file is there is no way to recover it um like in this case there is if something fails there is a try of recovery of the file I mean if it's even if it's if it gets corrupted because of some malicious or some interrupted action that was happening it gets recovered so that kind of recovery mechanism is there in database Management Systems of course if whatever system you have the database management system on gets gets on fire then you might lose that too uh but again like it's much better than having just a file which gets corrupted like partially written and half of that is not written and things like that happens right uh then concurrency problems are super important which means uh like a file when being read by a a program another program might not be able to read it or if you allow that to happen if both of them are writing and reading together you might have some problems in the data that that is there in the file at the current time but uh like dbms kind of handles that really well then data redundancy and inconsistency so file system like are created by different programmers so they are lot D files are duplicated a lot but then dbms tries to make uh like data r redundency as minimal as possible so that you can join and then query on top of data things like that so this is also there and obviously you can uh file system is a very local approach quick cheap but uh you don't really want to do that when you are building a production grad server because you don't want to lose data but dbms is the approach that we go towards with that what is rdbs it's basically like you have records or tles being stored in rows of a table kind of structure and that is what is called relational databases so there are bunch of relations that are being existed in over here that for employee ID one you have the name post and salary these are the relations that you have with things and uh there are different names like columns are there which are the fields or attributes there are something called as Keys primary Keys which means something that is unique and identifies everybody uniquely uh you have number of columns called degree cardinality is the number of rows you have domain is what is the range of values that are feasible in a particular column things like this that exist in an rdbms concept but rdbms just makes it a relational database management system the ones that we traditionally use like SQL MySQL servers and postgress and all these things are rdb now there are tons of question that are generally asked in interviews around U how is things actually stored what are indexes what are table scans and like index scans what are different how is data actually stored um how are data actually manipulated in fact right so uh this is something that you need to be clear about so from just as an example you need to think about this let's say you have a particular like table where you have emplo ID employe name employee date of birth and employee salary you would generally create a row ID this is I'm trying to take an example of postgress but it adds a row ID in in front of it right and then it tries to create pages of the data that is there over here so let's suppose a page can fit three rows so what will happen is the database will try to store these things in pages of three three rows so three three rows total so row ID one the employee ID name date of birth is this and then there is a separator and then again the next row next row so that will be in the page zero then page one will contain the row number four 5 six the page number two will contain role number 6 7 89 and so on so this is how it will be stored right so like if you think about it like there is a fixed size page that are being stored in the memory and this can be in fact like small files itself but they are being stored in the memory and then these pages are what are being retrieved to be like to be read and then showed the result on okay so these are the pages that are built in the memory uh we can try and like think of it as a database is nothing but a computer which basically is running the software piece that helps you get the query um like take queries handle it there are a bunch of other processes that goes on inside it I don't want to make it complicated uh but inside it you can think of a hard disk which will contains which will save actually these pages and stuff right and the software that is running on the computer will read these pages on demand whenever it's required and stuff and there are bunch of optimizations built on top of it but I don't think we need to get into there right now one obvious optimization that you need to know about is building indexes right so it's like a separate structure that uh has pointers to this is let's suppose the Heap okay and this data this structure which stores these pages is called a heap and the indexes is basically a separate structure that you built so that you can query efficiently for an example we know that um like I want to query Things based on employee ID right and over here it looks like it's sorted but it might not be okay so some I might insert a new row which might be of a different employee ID which might be lesser than what shubam has right so what we might want to do is we want to create another smaller data structure called index which will contain just the data on which we want to like build index on like this 101 right which is the employee ID and save an pointer that hey it it is saved in the page number Z row number one page one2 is present in page number Z row number two uh 107 is stored in so see 107 is stored in page number zero row number three right so this is how you are saving and obviously since you are not saving the whole data this data has can store much more number of uh like information in one single page because it's just one number and some pointers right it's it's much smaller so more things would be available plus this pages will be maintained in a sorted order like unlike this one where everything was just just by rule IDs this particular pages will have the employee IDs in a sorted order so what will essentially happen is and how is that sorted order maintained it's basically these pages are being maintained by something called as B tree you can read more about it but I don't want to get into that details because generally like you just need to tell the name that it's stored as B trees and stuff nobody gets into too much of details of how does b as a data structure works but um it just makes things remain sorted and insertions and removals are super fast because you might want to remove a row or insert a row right so uh every time you basically have a page and if you want to build an index on top of a particular column there is a separate structure like this that is created which contains the like data on which you are building the uh the index on and the page number and the like row number the ENT entry number in that particular page right so the rows that are there so rows number four row number five row number six is there in this page number one uh yeah this should be page number one I feel yeah so this is basically the idea now when you get some certain query like this like select star from employee where employee ID is equal to 1 2 3 4 and you have not built the index what will happen is you don't know whether employed is sorted or not right so you will basically go through all the pages you will scan the first page read and see that hey one 1 2 3 4 is not present in the employee IDs here you will read the next page see the employee IDs you will go through all the pages so you will eventually have to read all these pages from the disk and that is very costly because reading from disk is a costly IO okay but what if you have an index so which is index scan um is basically you go to the index first and say hey I want to look at 1 2 3 4 now since this index is sorted by employee ID you can think of it being a binary search but in B Tre you can do a traversal and you can find out hey 1 2 3 4 lies in the last page of the index so last page says 1 2 3 4 is present in page number 333 and as a row number uh the row row ID of that is th000 so go to page 333 fetch that page and get the row number one uh th000 and you will directly have the data for the 1 2 3 4 so this is essentially how quickly it can do it like you you need to fetch this page the index page needs to be fetched so first one page and then just the second page right so it makes the fetches much more faster much lesser number of dis IO but then again the cost is you have this extra structure to be maintained in memory you have to update it and qu like as the data is changing over here so those things are there like there's a trade-off between them but again this is how indexes make your query fast now sometimes questions around database partitioning is asked which means hey um what is database partitioning so essentially the concept is if a particular table or a particular database is getting very very large you want to uh a particular table specifically so you want to divide it let's say uh into two different tables or three different tables where you have different information based on your requirements say in a particular uh uh table you have a username profile ID connections and uh content authored so you can split it into two different tables with the same IDs being linked and then you have the username and profile data here and then connections and content authored here and maybe this table is something that gets read much often rather than this because connections and content authored might be something that you hit only when you go to that user's page but maybe like you want to show certain small chips and stuff about that user everywhere so a lot of profile data might be fetched about that user so this P this table you can try and optimize further and this one you can keep in a separate place so it just helps you scale things up very very quickly you can also divide it into like ranges and stuff and divide horizontally so this is called horizontal partitioning this is called uh vertical partitioning in horizontal partitioning you divide a particular table based on ranges of a certain columns value right so in this range whatever the items are this will be there this will be there and it might be relevant because some people query only like high pric things some people query only low pric things and things like that so you can create the queries on around that then there is a concept of sharting basically the concept is very similar to partitioning but when you partition that and send it to different servers right uh right now we just divided the table but those tables are in the same database management system but if you make these database tables that you created just now using partitioning move to different servers and try to manage that in a in a in a proper way what you're essentially trying to do is basically database sting right there are different databases different servers and each contains different partitions of the data so you'll have to decide which part if you get a query which partition this query should go to and things like that so that is called database shardi and there are like Advanced system design concept like consistent hassing and stuff which you can read more about but I think at a like core CS level you don't need to know about these things uh differentiate between an exclusive and shared log this is another thing that is generally use when you like send a query to the database what happens is if the query is updating a particular particular row right you need to make sure that nobody's reading that row at that point in time because then you might have a problem because the reading one might partially read the correct value and partially read the wrong value right so there are locks designed which is called exclusive locks and shared locks exclusive locks basically is essentially a right lock you can say basically you will hold the row right and nobody else who is trying to update or read it will be able to access it anymore because somebody's updating it but then shared lock is a little different shared lock is basically when you get a shared lock on a row nobody will be able to write on it but others can read on it right because if I'm reading a a book and you are reading the same book it's perfectly fine right because the book is not changing but if I'm WR changing the book and you're reading it that's a problem so while somebody's writing things shouldn't be shared it has to be exclusive but when somebody's reading it has to be like it can be shared more so that is how it's managed these are two different types of logs that you can get on rows on certain set of rows on the whole table things like that but essentially this is what is there available when you are handling a transaction right next we come to uh like how to design databases and stuff and uh there are like tons of things around this um like there's something called as ER diagrams which is basically trying to build a relation of the real world system that you want to actually keep in database like student relation student attends course course has subjects teacher lecturer teaches a subject a subject has different properties or attributes which is lecture ID subject ID subject name things like this right so you try to build a diagram like this which is called ER diagram you can read more about it and then from this you convert it to a schema on how the tables will be related who will connect to whom and stuff like that right so over here like course uh has a student right so you have a link between course and like a student can be enrolled in certain course IDs and stuff like that so there has to be some relation between them so you can build schema from that it's not the perfect database schema but it's just a schema on how the objects would be related right so you generally first build the ER diagram then you build this and from there you write the table structures and stuff then there are questions related to uh like types of keys in databases primary key candidate key okay uh basically primary key is something that is unique and shouldn't be null candidate key is something that can be that can be a primary key but a table can only have one primary key so everything that makes that you can choose that uniquely identifies every row is a candidate key but one of them can be the primary key then there is foreign key like which helps you link one table to other which is basically uh it identifies uniquely the row in some other table is called a foreign key comp composite key is basically combination of two or more columns that makes it unique so a candidate key u which is combination of multiple columns right for an example if you have a registration of a student in a course then student ID comma course ID has to be unique in every row right because a student can be enrolled in one course exactly once so student ID comma course ID can be a can composite key unique ke is a constraint basically it just makes sure that that particular column is unique it it's it's a enforcement it's a constraint on top of that that you can build super key is one or more columns that can be used as unifying a record um like it's a it's a little different from what you say as composite key because in this case you can have redundant columns extra but in composite key like each of the columns cannot provide uniqueness alone okay so you can have additional columns that are not necessary then there is secondary key which is a secondary key is a field that is used for saring sorting and searching essentially building indexes and stuff right and surrogate key is basically a key that is artificial identifier for an entity in a database right uh so basically if you use if you think about postgress what you what you do is like whatever the tables are you have a row ID being introduced in front of all of them so that row ID is a surrogate key that is uniquely identifier of everything if if you don't have a primary key that can behave as a primary key like when you have students and data we add a student ID which automatically increments by one um so we aren't trying to the number doesn't make any sense right but we are trying to create a new number for everybody so that it's Unique that's called a surrogate Key by default students doesn't have anything unique like two students can do perfectly the same thing their name the parents name also might be same right okay so this is essentially different keys in databases now you might be asked questions around anomalies in databases like update anomaly like for an example if you want to update given this particular table which is like student in which course number they are enrolled their name their address and course um so suppose Jones is moving from Edinburg to some other location right so if you want to update that you have to update all the rows of this which is bad because I cannot just find out one row and update it I have to find all rows and update it that's that's a bad design right delete so think about this if I delete um like Richard right okay if I delete about uh if I let's let's think about deleting the student Richard so Richard got unenrolled from the course so in that case what will happen is these two rows will get deleted now suddenly you have no information that 9322 corresponds to maths because this row is not there no other row has maths so this course number was corresponding to maths this information is lost altogether which is a anomaly in itself in the design insert anomaly this is again another interesting thing which is if you are inserting a new course let's suppose I'm creating a new course of computer science but then no students is yet yet enrolled into it how do I keep how do I create a new course number and the course name because without a student I cannot make a row no so that's also another problem in database so if you randomly design databases it's going to be bad so that's why we have different concept of normalization that helps us divide like larger tables into smaller ones such that they have proper relationships and stuff okay so it relates a little bit on the functional dependency things that what is dependent on what like for an example I think it's best taken from examples right that if you know the car model of a certain car then you know that what all different colors it is available in or which years it has been manufactured in right so these are properties of the car model of a certain car let's suppose so these things depend on the car model so you have to handle things in that particular way so these functional dependencies is what we trying to like kind of control using normalization so there are multiple normal forms right data can be represented in multiple normal forms uh for an example in first normal form we try to make sure that every like data is like has a single value for an example Janet Jones has both they has they have the same they the same person so they have the same physical address same adapation but they have rented two movies so I could have kept them in the same uh row itself but that's a that's not the best design in first normal form we try to say that every person every uh like column will have a single value in a single row itself so that is there that is the first normal form and generally the second normal form is uh what we want to get into is basically we want to build primary key relationships in top in terms of uh the data that is present for an example the name is a separate thing like names membership ID something that you introduce and the names are different thing names physical address salutation and which movies they have rented you have it in a separate table right so you want to introduce these single column primary keys that are not functionally dependent on anything else you want to introduce these columns member IDs so that problems like the anomalies that we were talking about doesn't happen because if we normalize say table this one this table that we saw earlier it will break down into three things a student number which contains student information like Jones Smith Richard and uh the course numbers and then which student is enrolled in which course this is a separate table right you can say it's a ronment table or things like that now this solves everything for you this is just an to Second normal form but this already solves so many problems like update anomaly like if you want to update the location of Jones you just update here you don't need to do it on all rows if you want to delete a certain thing like if you want to delete the student 30 Richard now you don't now you don't lose the information of maths now you can insert a new uh like subject without even introducing a student in that so all these problems got solved if you normalize the tables properly that's the basic fun of how to normalize and stuff but I think it's more uh intuitive to me that obviously different objects should be kept in different tables and that's what is second normal form and first normal form is keep everything together that's that's what is generally expected to be answered okay so that's about normalizations and normal forms you can read more about them of course but we want to be short crisp and cover everything that is required what is SQL um SQL is basically the language I think you have seen SQL queries select the data that you want to get the columns that you want to fetch from a particular table name right where region ID is equal to one where certain conditions are hold true and then you want to then you might also ask the database to give it in a certain order right so these kind of syntaxes are created the syntax is called SQL structured query language which will tell you which will give the result pulled out from the data base that you have stored and you can play this small game this is a fairly good game which will give you like Clarity on what uh SQL and stuff does okay um but we'll not cover SQL in this session because it'll take a lot of time okay so these are mostly the questions uh one more topic that I like didn't cover much is about transactions because I want to keep this video short 30 minutes or so uh in transactions you have Concepts around U like acid bases number one this is very important question read about it recovery states of transactions right dirty needs rights the problems of transaction that happens but it's more of something that you also read in like operating systems you also have the same critical section problem in other places so read about it a little more about transactions if you have time but again in 30 minutes I think this is a good enough summary of all questions that might be as in interviews now I think further links that you might need I've added it over here uh the DB book slides are fairly good if you want to get a full course on database this is the available course that is there in on internet if you want to practice SQL hacker ranks that is really good uh if you are on algo premium you can also there is a course which contains like all the lectures for databases and the bunch of questions uh that you can practice which are from previous year OAS so I think that should be enough for this particular video but I hope this short concise explanation of the database Management Systems questions help you uh in next video we'll cover something similar but I hope this was enjoyable make sure that you like and subscribe to the channel see you in the next video bye [Music] oh