hey there in this clip I want to talk to you about the very basics of indexing so why are we interested in indexing because indexing is a very easy way to improve the performance of your database in under a set of fairly common circumstances so the point of indexing is improving database performance what is an index an index is a structure that exists independent of the data in your table that improves the query optimizers ability to execute your query quickly well it's not exactly the same an excellent analogy for understanding the basic functionality of a MySQL index is the index that you find in the back of for example a text book and so imagine that you needed to find in your text book every instance of a particular word let's say if you had a database textbook you had to find every instance of the word concatenate well you have two options without the index your only option is start at the first word in the text book read every word in from top to bottom left to right until you've reached the end of the text book making a note of each time that you come across the term concatenation that takes as you could well imagine a very long time and as you likely from your own text book use now there is typically an alternative provided that the term in question is available in the back of the book index you can jump directly to the index go alphabetically through the index until you get the seize find the COS find the word concatenate or concatenation I can't remember which one I said and then find in the index every instance of concatenation and a direct pointer to where you can find it in the textbook obviously that say an inordinate amount of time in terms of tracking down a particular concept or terminology in a text and the basics although the execution is different the basic purpose is exactly the same with database indexing and the performance improvements stand to be equally significant as well okay so let's take a quick look at how indexing works so here we have let me let me get to drawing here here we have unindexed a nun indexed table okay and basically you have is an unordered lumping of data records and we know from our previous studies that ordering can't matter in a database table you know whether a particular record is first or last or 17th shouldn't make any can't really make any difference to us however in terms of the performance of the table that ordering can and so what we have within and more on that in a moment when we actually talk about the index but what we have here with the unindexed table is basically the same situation as a textbook without a back of the book index to find a particular value say for company number you need to say we're looking for every instance of company number with company number equals 14 we got to go from the first to the second all the way down and say okay here's one and here's one and those are the only two and obviously that's not that big a deal with the table as short as this but imagine that we had a table with millions of records or imagine further that we had a table of thousands of records being joined in a query to another table of thousands of records being joined in turn to another table of thousands of records and then we are dealing with comparisons in the billions literally and performance can be impacted so we want to avoid the situation or having to read in series from the first record straight through to the last to scan in other words we want to search instead of scan we want increase efficiency and we can get that with the inclusion of an index and so here we are with our index provided it's an it's an index on company number comp no and what it is is an ordered arrangement of all the instances of company number from smallest to largest together with a pointer to where those instances occur so together with this tenth just like a back of the book index we have a pointer to the underlying data ie the text of the books or in this case the instances in the database so we have 10 here 10 pointing to here and 10 pointing down here and so on we have 11 right up here and 11 right here and 14 here and I won't do all of these you get the picture so we have each of the instances and a pointer to their underlying data in this table and so this improves in performance because instead of having the look top to bottom we can say okay I am looking for a company number every instance of company number 11 okay and so I can say okay instead of scanning the index I can do more sophisticated searching using binary trees or other data structures that we will not talk about but they function similar to guessing game where if you have to get the number from between 0 and 100 your first guess would be 50 if you're able to be told whether your guess is higher or lower and if you guess 50 and you were told that that guess was too low then you would guess halfway between 50 and the maximum value 100 which is 75 and that sort of thing which is beyond the scope of this course but hopefully you get the picture a little bit in any case you can say all right so here's my here's my value of 11 that I'm looking for here's one instance of it go down again okay we're still at 11 here's another instance of it go down again up we're on 214 we have extended the bounds gone above 11 I must have therefore located every instance of 11 and I can stop screwing around I know I am done with this search because the index has done its job now one thing you may be wondering to yourself is this makes a lot of sense and I get it but why do why do we need this to be a separate structure why don't we just order the underlying data in descending order or in ascending order rather from the lowest comp number to the highest well that just basically why don't we order this column instead of creating this index that works fine with an asterisk as long as you only want one attribute indexed it's oftentimes imperative that you index multiple attributes you know if you also wanted to index the add number then which is it going to be you could sort by this column or you could sort by this column but you can sort by both where we could certainly create a separate index with a separate set of pointers over here and that would be fine so that's one of the main reasons that we like to have a separate structure to keep the ordering because it allows us to order on multiple on multiple attributes the other thing is this while this in terms of the number of attributes is just one to three it's very brief and each of the attributes is fairly short in realities is this could go on for many many many attributes some of which are binary large objects or large chunks of text or Lord knows what all and managing the especially if this if this table is changing a lot if it's volatile managing the constant reordering is more time consuming and more difficult if you have all that other junk to have to rearrange as well whereas the index required while it's not it's not costless to have to constantly update the index to reflect the changing nature of the underlying data it's much easier than constantly having to reorder the underlying data itself so that would be a cost as well but really the biggie is the fact that you can only pick one and only one attribute if you were to order the underlying data so instead we go with index so I think that's the basics in terms of conceptual ideas about indexing I want to talk in a follow-on about when it makes sense and when it specifically does not make sense index I want to talk about full-text indexing which is slightly different and more google-like and I want to show you the syntax involved in indexing but for now that's the very basic study hard and I will see you online