Closure method, we are going to discuss closure method Closure Method is very important in DBMS Because this method is helps you to find all the candidate keys in the table. Means, if you have a table given, All the candidate keys are possible in that table If I have to find then So i have to use only one method, that is the closure method. And guys, we are talking about such tables, in which you would not have been given such attribute which we normally use,
as SID, s.name, general table would have been given. Let's start with the example, Like there is a relationship, the relationship means we allready know, relationship means table.. There are four attribute in the table A,B,C and D And they have given the function dependency. A goes to B, B goes to C, C goes to D. These three function dependencies are given So let's start with the closure method, what you have to do is Like what is the first dependency, A So we denote with the A+ that is the closure, so we are finding the closure of A. So the meaning of closure is that what A can determine What A can determine? So we already know, A is determining B. A is determining B.  From the functional dependency 1, You can clearly check, that A is determining B. So i wrote closure of A is B. Now B is determining C. Means B is determining C And A is determining B. So this is what, a transitive property. What is transitive property? Like if A is determining B and B is determining C, So this is common. means A is determining B and B is determining C then you can clearly say that A can determine C through B. So A is determining C over there. So that means here A will
determine B and C both. Now C is determining D. You will have to check very carefully that if C is determining D So, A can also determine D through transitive property. And the last important point is that A will determine itself because it is a reflexive self loop kind of. A, A is kind of roll number If i say, A is a roll number. A roll number can determine itself. Student's name,Student's
name can determine itself. So A is determining itself. Other than that, What else it determine. B, C, and D. So when we have checked the closure method, now check which attributes
came in A's closure? A, B, C and D. & Check, which attribute are in the table? A. B., C & D, means A can determine all the attributes in the table. This is the property of candidate key. Candidate key is a such key that is in any number of columns in the table, if you are having confusion in them, then you can get them determined by candidate key. So here, clearly I can say that  A is the candidate key in the table. So if we make the sets of candidate key So I got the first answer here, that is A. But don't stop here. Because the rule of candidate key which will use in the second normal form, third, and BCNF. Where you have to find all the candidate keys in that table. So let's start with. B+ If we check the closure of B+, then as we already know that B can determine B It is reflexive. It determine it self. Now Check, From Functional dependency. So in the functional dependency, B can determine C Means B is determining C. Its a direct. If its a direct, then we cam directly write it. and C is determining D, means through Transitive, B is also determining D. But see guys, here B cannot able to determine A. So means B is determine BCD But B cannot able to determine A. So it means B cannot be a candidate key. Same for the C's closure. It will be C is determining C C is determining D. So you can say C is determining C and D. Similarly, D is determining only D. Apart from this, it's not determining anyone So, neither C can be a candidate key, nor D can be a candidate key. So there is only one candidate key in this table, that is A. Guys here You have to be very careful. Many times, What do we do that like AB, Many times we check the closure of two attributes by combining them So if AB is combined, if we check the closure of it, then AB will determine AB Because It is again of self loop. AB is determining itself. Now here if you will check that singles A is determining B, B is determining C. So if AB is determining to AB. So from B We can determine C. And from C, we can determine D. So here what answer i get? That AB can be a candidate key. But keep in mind guys, AB is not be a candidate key. It is not a candidate key. Because candidate key, 
we have already discussed that candidate key is always a minimal. And in AB, only A, only A is the candidate key. so if you are combining anything extra with it. So that will be became the Super key. If you're adding anything extra to it, so that will become the super key. So AB is not a candidate key over there It is actually a super key. Let's discuss another example here. There is a relation, ABCD. Here functional dependencies are A B, B goes to C, C goes to D and here i add one more, that is D goes to A. So let's start with the Closure of A So what is the A's closure, A can determine A, A can determine B. through transitive, A can determine C Through transitive A can determine D So means A determined all the attributes in the relation. So A will be the candidate key. Check the relation, closure of B B can determine B Through B, we can determine C Through C, we can determine D But here see, through D, i can determine A. means closure of B also determine all of them. So means B will be the Candidate key. Same for the C, C can determine C, D From D we can determine A. From A to B Same for the D. D, From D we can determine A, From A to B, and From B to C So here, what are my candidate keys? All will be the candidate keys. A, B, C and D So how many candidate keys are there? Four candidate keys. And Keep in mind guys, If your candidate key has come then If You're adding anything extra in it, that will become the Super Key. That's why here is just four candidates here, that is A,B,C and D. Now here, one more thing can be asked in exam, what will be the Prime attribute? Prime attribute. So the prime attribute, when you found out the candidate key, after that you can find, What is a prime attribute? Prime attribute is actually the attribute Which is used in the making of candidate key, which are used in the
formation of candidate key. So here if you see carefully There are four attributes ABCD, in the relation. and in the candidate key, ABCD all four  attribute are there. So what will be the Prime attribute over there? Prime attribute is A, B, C ,D. All are the prime attributes. So what will be the non Prime attribute? Non Prime attribute will be null Null Because of all the four attributes in the relation, are used in the making of candidate key. That's why phi will be the non prime. And if you see here, What is the Candidate key over there, A. So what will be the prime attribute? Prime attribute will be A only. And what is the Non-Prime Attribute? B, C, D What are these three? Non-prime attribute. So, prime attribute is the attribute which is used to make candidate key. The attribute which is used
in making the candidate key That we called Prime Attribute. So guys, you take note of both the examples. Then let's start with the third example. There are relation, ABCDE and these are the functional dependencies given to you. Now here, you may have a problem that How many attributes do we have to take closure like here you took the closure of A, B, C, D So in which way you have to determine that, means this thing will come in my candidate key. So here we are solving this question with an another method. Now see, In the Functional dependency, you have to check first Which attribute are coming at the right side, Meaning of that is the attributes which are coming on right side, They're all getting determined. They're all getting determinded. Means, B is being determined. D is also being determined. C is also being determined. A is also being determined. means ABCD all four is getting determined. But guy if you see here, A came, B also came, C also came, D also came, But E did not came. So it means, what is its funda, that E can come to the right side, only if E will be on the left side. So there is a very important point here. It will help you a lot in solving the question. Means whatever candidate key will be made, right now we do not know
which will be the candidate key, how many candidates will be? But each and every
candidate key must contain E. Because If E comes to the left side, Then only it will be written on the right side as well. So, if you have to bring E, then E have to be on the left side. Let me tell you once again, you have to check that which attributes are coming on the right side. B, D, C and A. The attribute which is not
coming on the right side, that must be on the left side, left side means It will be defintely used to make the candidate. If you check, the closure of only E If we check the closure of E Then E can determine E E can determine C, only C Means, only E is not the candidate key. But it will be use to make the candidate key. Let's start with the, like we start with If i check the closure of Only A. If i check the closure of A. & as I said that E will must come on the left side. So let's check A and E combinedly So A's closure What A can determine? A can determine B and E also. through E, i can determine C. Because AE can determime AE. And A can determine B. So I wrote ABE From E, i can determine C, i.e.. A, B, E, C. & Now I'm Having two attribute B and C. I've got two attributes B and C & check here the second functional dependency, BC can determime D. So, I can also determine D and from D, i cam determine A. I have already written A, so don't mention it again So check it, A,B,C,D,E. & how many do we have in the original table?  A,B,C,D,E. So Guys here, AE is the candidate key. So here, i got the first candidate key, i.e. AE Now what can be the second
candidate key over there? You cam check second candidate key directly, like Yoi can check the closure of B and E. You can check the closure of C and E. Yoi can check the closure of DE. But if we see here the closure of BE Like Then what will be the output From BE, i cam determine BE. From E, i can determine C And From BC, i can determine D B & C has came,  i can determine D From D, i can determine A. So yes, BE can determine again all the attributes. So BE can be the candidate key over there. But there is another better solution than that, you can also check that. If you have got a candidate key, AE. If you have got a candidate key, AE. What you have to check ? Either A or E. present at the right hand side. Whether any value of A or E is present at the right hand side So let's check like A. A is a present on someone's right hand side. Yes, i got it. A is present on the right hand side of D So what can do?  I can replace A with D. You have to check, A is presentat the right hand side means if it is present on
the right hand side of D. So I replaced A, To whom? To D So here, mu candidate key is DE I got D and E both. Now I'm checking the closure of DE So from the closure of DE, DE will definitely come A came from D & now you see carefully, AE both have come. AE is already a candidate key. Means you can clearly say, they can determine all the attributes here i have two candidate key AE DE. Now one more thing you can do. We have just checked that A is present in someone's right hand side or not Yes, A is present on the right-hand side of D Now check, E is Present on the someone's right hand side or not. No, there is no problem. We got another attribute, D check, D is Present on the someone's right hand side or not. Yes, D is present at the
. Right Hand Side of B & C That means, Here you,, I'll write here, replace D with B. So closure of B & E. And You can also replace D with C. So the closure of C & E You check that the closure of BE, BE will  definitely come from BE. Even we already check that. But once again see that BE came from BE. C came from E D came from BC A came from D, means all the attributes are here. And now CE, from CE, i have CE, because it is self loop. Then I have C from E & Now. No CE Will Not Be the, CE is not determining anyone Means CE will not be the candidate key. So here I had three candidate keys here. AE DE & BE Now you can check that B is also present on someone's right hand side. Yes, B is also present on the right hand side of A. And if you will replace B with A. you will replace B with A. Then it will become AE. Which is already a candidate key. Okay guys, so you can use this method. You can again repeat the video. So you will also understand clearly that how to make that candidate keys in the table. And this method is very important. Because without it you cannot solve the questions of the second normal form third normal form & the BCNF normal form Whether it is the GATE exam, or normal your college. This method will help you in both of them. To fimd all the candidate keys in the table. And how many prime attribute are there? & How many non prime attributes are there? So you can check here, which are yours prime attributes? Write it here, prime attributes will be, Prime attributes which are used to form the Candidate key. So here A is being used in making of candidate key D is being used B is being used. E is being used. So means four of them are prime attributes. So non prime attributes, So total all the attributes present in the table, we minus these four. So one is left, C. So, C will be the non-prime attribute. That's it.